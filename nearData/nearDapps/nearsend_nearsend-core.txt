*GitHub Repository "nearsend/nearsend-core"*

'''--- Cargo.toml ---
[package]
name = "nearsend"
version = "1.0.0"
authors = [""]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.6"
uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.6"

fungible-token = { path="./ft" }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
  "ft"
]

'''
'''--- LICENSE.md ---
Business Source License 1.1

License text copyright (c) 2017 MariaDB Corporation Ab, All Rights Reserved.
"Business Source License" is a trademark of MariaDB Corporation Ab.

-----------------------------------------------------------------------------

Parameters

Licensor:             Invoker Labs

Licensed Work:        Nearsend Core
                      The Licensed Work is (c) 2022 Invoker Labs

Change License:       GNU General Public License v2.0 or later

-----------------------------------------------------------------------------

Terms

The Licensor hereby grants you the right to copy, modify, create derivative
works, redistribute, and make non-production use of the Licensed Work. The
Licensor may make an Additional Use Grant, above, permitting limited
production use.

Effective on the Change Date, or the fourth anniversary of the first publicly
available distribution of a specific version of the Licensed Work under this
License, whichever comes first, the Licensor hereby grants you rights under
the terms of the Change License, and the rights granted in the paragraph
above terminate.

If your use of the Licensed Work does not comply with the requirements
currently in effect as described in this License, you must purchase a
commercial license from the Licensor, its affiliated entities, or authorized
resellers, or you must refrain from using the Licensed Work.

All copies of the original and modified Licensed Work, and derivative works
of the Licensed Work, are subject to this License. This License applies
separately for each version of the Licensed Work and the Change Date may vary
for each version of the Licensed Work released by Licensor.

You must conspicuously display this License on each original or modified copy
of the Licensed Work. If you receive the Licensed Work in original or
modified form from a third party, the terms and conditions set forth in this
License apply to your use of that work.

Any use of the Licensed Work in violation of this License will automatically
terminate your rights under this License for the current and all other
versions of the Licensed Work.

This License does not grant you any right in any trademark or logo of
Licensor or its affiliates (provided that you may use a trademark or logo of
Licensor as expressly required by this License).

TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED ON
AN "AS IS" BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS,
EXPRESS OR IMPLIED, INCLUDING (WITHOUT LIMITATION) WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND
TITLE.

MariaDB hereby grants you permission to use this License’s text to license
your works, and to refer to it using the trademark "Business Source License",
as long as you comply with the Covenants of Licensor below.

-----------------------------------------------------------------------------

Covenants of Licensor

In consideration of the right to use this License’s text and the "Business
Source License" name and trademark, Licensor covenants to MariaDB, and to all
other recipients of the licensed work to be provided by Licensor:

1. To specify as the Change License the GPL Version 2.0 or any later version,
   or a license that is compatible with GPL Version 2.0 or a later version,
   where "compatible" means that software provided under the Change License can
   be included in a program with software provided under GPL Version 2.0 or a
   later version. Licensor may specify additional Change Licenses without
   limitation.

2. To either: (a) specify an additional grant of rights to use that does not
   impose any additional restriction on the right granted in this License, as
   the Additional Use Grant; or (b) insert the text "None".

3. To specify a Change Date.

4. Not to modify this License in any other way.

-----------------------------------------------------------------------------

Notice

The Business Source License (this document, or the "License") is not an Open
Source license. However, the Licensed Work will eventually be made available
under an Open Source License, as stated in this License.
'''
'''--- Migrate.md ---
# Migrate smart contract

This docs provide the steps for migrating the contract after upgrades

## Re-deploy contract on testnet and mainnet

Check out the env in [`config.js`](./scripts/config.js) to ensure that the `CONTRACT_ACCOUNT_ID` matches with the account id that current contract was deployed on testnet and mainnet. Also, the `ORACLE_ACCOUNT_ID` and `ORACLE_PROVIDER_ID` account should match with account id in [`oracle docs`](https://docs.fluxprotocol.org/docs/live-data-feeds/fpo-live-networks-and-pairs#near).

```js
const env = {
    WASM_PATH: "./target/res/bulk_sender.wasm",
    testnet: {
        CONTRACT_ACCOUNT_ID: "nearsend.testnet",
        ORACLE_ACCOUNT_ID: "fpo.opfilabs.testnet",
        ORACLE_PROVIDER_ID: "opfilabs.testnet",
    },
    mainnet: {
        CONTRACT_ACCOUNT_ID: "bulksender.near",
        ORACLE_ACCOUNT_ID: "fpo.opfilabs.mainnet",
        ORACLE_PROVIDER_ID: "opfilabs.mainnet",
    }
};
```

Make sure your account is logged in through your near-cli

```bash
near login
```

Run the js script [`migrate.testnet.js`](./scripts/migrate.testnet.js) and [`migrate.mainnet.js`](./scripts/migrate.mainnet.js) for contract migration on testnet and mainnet accordingly. In the script, the following actions will be executed.
* Build the smart contract.
* Re-deploy the compiled contract on the current contract account id. 
* Call the `migrate` method to update the state of the contract.
* Call the `set_oracle` method to update `oracle_account_id` and `oracle_provider_id` in contract state.

For migration on testnet, run command below.

```bash
node scripts/migrate.testnet.js
```

For migration on mainnet, run command below.

```bash
node scripts/migrate.mainnet.js
```

### Nearsend Fees

Nearsend charges $0.05 per address.

```rust,no_run
const FEE_USD_PER_ADDRESS_DECIMAL_OFFSET: u32 = 1;
const FEE_USD_PER_ADDRESS_VALUE: u128 = 1;
```

To edit the service fee per address, we need to edit two variables `FEE_USD_PER_ADDRESS_DECIMAL_OFFSET` and `FEE_USD_PER_ADDRESS_VALUE`. So the USD fee per address will be calculated as follow.

```
FEE_USD_PER_ADDRESS_VALUE * 10 ^ (FLUX_USD_DECIMAL - FEE_USD_PER_ADDRESS_DECIMAL_OFFSET)
```

The `FLUX_USD_DECIMAL` is the base decimal for USD, check [`oracle docs`](https://docs.fluxprotocol.org/docs/live-data-feeds/fpo-live-networks-and-pairs#near) for more information. For example, if we want to have the service fee equal `$0.05` per address, we just need to change `FEE_USD_PER_ADDRESS_DECIMAL_OFFSET` value to `2`

```rust,no_run
const FEE_USD_PER_ADDRESS_DECIMAL_OFFSET: u32 = 2;
const FEE_USD_PER_ADDRESS_VALUE: u128 = 5;
```

Then the USD fee will be calculated as below:

```
usd_per_address = FEE_USD_PER_ADDRESS_VALUE * 10 ^ (FLUX_USD_DECIMAL - FEE_USD_PER_ADDRESS_DECIMAL_OFFSET)
                = 5 * 10 ^ (8 - 2)
                = 5 * 10 ^ 6 (~ $0.05)
```
'''
'''--- Readme.md ---
# Nearsend

Contract code for [Nearsend](https://nearsend.io/)

### Prerequisites

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install -g near-cli`

### Build contract

To build run:
```=bash
bash shell-script/build.sh
```

### Deployment Steps

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this contract on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions on [NEAR Wallet](https://wallet.near.org/).

Switch to `mainnet`. You can skip this step to use `testnet` as a default network.

```=bash
export NEAR_ENV=mainnet
```

In the project root, log in to your newly created account  with `near-cli` by following the instructions after this command:

```=bash
near login
```

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name you just logged in with, including the `.near`:

```=bash
ID=MY_ACCOUNT_NAME
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:

```=bash
echo $ID
```

Now we can deploy the compiled contract in this example to your account:

```=bash
near deploy --wasmFile target/res/bulk_sender.wasm --accountId $ID
```

Contract should be initialized before usage. To initialize the contract, change the oracle_id to your near account and use this command:

```=bash
near call $ID new '{"oracle_id": "YOUR_ORACLE_ACCOUNT_ID_HERE"}' --accountId $ID
```

### Test

Run all tests with this command:

```bash
cargo test
```

### Function Explanation

#### Call Methods

```rust,no_run
    /// A payable method that transfers near from `env::predecessor_account_id` to `receivers`.
    /// 
    /// Requirements:
    /// - The attached deposit must equal the total amount sent to all receivers.
    /// - Caller must pay service fee to get enough quota to transfer near.
    /// - The length of `receivers` and `amount` arguments must be the same.
    /// 
    /// Arguments:
    /// - `receivers` - a vec of all receivers' account ID.
    /// - `amount` - a vec of the amount of near sent to each receiver corresponding.
    pub fn distribute_near(&mut self, receivers: Vec<AccountId>, amount: Vec<U128>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receivers`.
    /// This function is executed when user call `ft_transfer_call` on a fungible token contracts. 
    /// See [ft_transfer_call](https://github.com/near/NEPs/blob/master/neps/nep-0141.md#ft_transfer_call).
    /// 
    /// Requirements:
    /// - `msg` argument must follow this format `"msg": "bob.testnet:20#alice.testnet:50"`. This means
    /// `bob.testnet` receive 20 tokens and `alice.testnet` receive 50 tokens.
    /// - Both `bob` and `alice` must register storage for token contract in advance.
    /// - `sender_id` balance must be greater or equal to the total amount sent to each receiver. 
    /// - `sender_id` must pay service fee to get enough quota to transfer near.
    /// 
    /// Arguments:
    /// - `sender_id`: the account id of sender.
    /// - `amount`: the amount of token that sender transfer to this contract by calling `ft_transfer_call`.
    /// - `msg` - a string message that includes receivers and amount.
    pub fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// A payable method that helps pay token storage fee for multiple accounts. 
    /// 
    /// Requirements:
    /// - The attached deposit must be equal to `min_fee * account_ids.len()`.
    /// - `min_fee` must be equal to the token contract's `StorageBalanceBounds.min`.
    /// - all of the `account_ids` must haven't paid for the token storage fee.
    /// 
    /// Arguments: 
    /// - `token_id`: token contract account id.
    /// - `account_ids`: the vec of all account that needs to pay token storage fee.
    /// - `min_fee`: the minimum fee needed to cover token storage for each account.
    pub fn batch_storage_deposit(
        &mut self,
        token_id: AccountId,
        account_ids: Vec<AccountId>,
        min_fee: U128,
    );

    /// A payable method to pay service fee. This method will increase
    /// the number of user quota to transfer near and tokens.
    /// 
    /// Requirements:
    /// - The difference between `estimated_fee` and the fee calculated 
    /// by the near price fetched from the oracle.
    /// 
    /// Arguments:
    /// - `estimated_fee` is the amount near equals 0.05 USD.
    #[payable]
    pub fn pay_service_fee(&mut self, estimated_fee: U128);

    /// Set the oracle account id and  oracle provider id.
    /// 
    /// Requirements:
    /// - The caller must be contract owners.
    /// - `oracle_account_id` and `oracle_provider_id` must be a valid near account.
    /// 
    /// Arguments:
    /// - `oracle_account_id`: the account id of oracle contract to query token price on-chain.
    /// - `oracle_provider_id`: the account id of provider that update the token price on oracle contract.
    pub fn set_oracle(
        &mut self,
        oracle_account_id: AccountId,
        oracle_provider_id: AccountId,
    ) -> (AccountId, AccountId)
```

#### View Methods

```rust,no_run
    /// Return the `owner_id` of the contract. When contract is initialized `owner_id` is set to 
    /// the account id that is contract is deployed on.
    pub fn owner_id(&self) -> AccountId;

    /// Return the number of quota for `account_id`. This quota is the total number of account that user can 
    /// transfer near and tokens to. For each successful transfer the total quota will be decreased by 1.
    pub fn get_account_quota(&self, account_id: &AccountId) -> u128;

    /// Return the oracle account id and oracle provider id. For more information, refers to FLux oracle docs.
    pub fn oracle(&self) -> (AccountId, AccountId);
```
'''
'''--- ft/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = [""]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"
witgen = "0.14.0"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.7"

'''
'''--- ft/src/lib.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::FT_METADATA_SPEC;
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::Base64VecU8;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, log, near_bindgen, require, AccountId, Balance, PanicOnDefault, PromiseOrValue,
};
use witgen::witgen;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[witgen]
pub struct FungibleTokenMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<Base64VecU8>,
    pub decimals: u8,
}

pub trait FungibleTokenMetadataProvider {
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

impl FungibleTokenMetadata {
    pub fn assert_valid(&self) {
        require!(self.spec == FT_METADATA_SPEC);
        require!(self.reference.is_some() == self.reference_hash.is_some());
        if let Some(reference_hash) = &self.reference_hash {
            require!(reference_hash.0.len() == 32, "Hash has to be 32 bytes");
        }
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Example NEAR fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial tokens supply is minted"),
        }
        .emit();
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
        contract.storage_balance_of(accounts(1).into());
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- package.json ---
{
  "name": "bulksender",
  "version": "1.1.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "release": "standard-version"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "near-api-js": "^0.44.2",
    "shelljs": "^0.8.5",
    "standard-version": "^9.5.0"
  }
}

'''
'''--- scripts/config.js ---
const { keyStores, connect } = require('near-api-js');
const path = require("path");
const homedir = require("os").homedir();

const env = {
    WASM_PATH: "./target/res/bulk_sender.wasm",
    testnet: {
        CONTRACT_ACCOUNT_ID: "nearsend.testnet",
        ORACLE_ACCOUNT_ID: "fpo.opfilabs.testnet",
        ORACLE_PROVIDER_ID: "opfilabs.testnet",
    },
    mainnet: {
        CONTRACT_ACCOUNT_ID: "bulksender.near",
        ORACLE_ACCOUNT_ID: "fpo.opfilabs.near",
        ORACLE_PROVIDER_ID: "opfilabs.near",
    }
};

const setUpTestnet = async () => {
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
    const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

    const config = {
        keyStore,
        networkId: "testnet",
        nodeUrl: "https://rpc.testnet.near.org",
    };
    return near = await connect({ ...config, keyStore });
};

const setUpMainnet = async () => {
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
    const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

    const config = {
        keyStore,
        networkId: "mainnet",
        nodeUrl: "https://rpc.mainnet.near.org",
    };
    return near = await connect({ ...config, keyStore });
};

module.exports = {
    env,
    setUpTestnet,
    setUpMainnet,
};
'''
'''--- scripts/migrate.mainnet.js ---
const { transactions } = require('near-api-js');
const { env, setUpMainnet } = require('./config.js');
const fs = require("fs");
const shell = require('shelljs');

(async () => {
    if (shell.exec('bash shell-script/build.sh').code !== 0) {
        shell.echo('Error: Failed to build smart contract');
        shell.exit(1);
    }

    const near = await setUpMainnet();

    sendTransactions();

    async function sendTransactions() {
        const account = await near.account(env.mainnet.CONTRACT_ACCOUNT_ID);
        const result = await account.signAndSendTransaction({
            receiverId: env.mainnet.CONTRACT_ACCOUNT_ID,
            actions: [
                transactions.deployContract(fs.readFileSync(env.WASM_PATH)),
                transactions.functionCall(
                    "migrate",
                    Buffer.from(JSON.stringify({})),
                    200000000000000,
                    // "1"
                ),
                transactions.functionCall(
                    "set_oracle",
                    Buffer.from(JSON.stringify({
                        "oracle_account_id": env.mainnet.ORACLE_ACCOUNT_ID,
                        "oracle_provider_id": env.mainnet.ORACLE_PROVIDER_ID,
                    })),
                    30000000000000,
                ),
            ],
        });

        console.log(result.receipts_outcome);
        result.receipts_outcome.map(e => console.log(e.outcome));
    }
})();
'''
'''--- scripts/migrate.testnet.js ---
const { transactions } = require('near-api-js');
const { env, setUpTestnet } = require('./config.js');
const fs = require("fs");
const shell = require('shelljs');

(async () => {

    if (shell.exec('bash shell-script/build.sh').code !== 0) {
        shell.echo('Error: Failed to build smart contract');
        shell.exit(1);
    }

    const near = await setUpTestnet();

    sendTransactions();

    async function sendTransactions() {
        const account = await near.account(env.testnet.CONTRACT_ACCOUNT_ID);
        const result = await account.signAndSendTransaction({
            receiverId: env.testnet.CONTRACT_ACCOUNT_ID,
            actions: [
                transactions.deployContract(fs.readFileSync(env.WASM_PATH)),
                transactions.functionCall(
                    "migrate",
                    Buffer.from(JSON.stringify({})),
                    200000000000000,
                    // "1"
                ),
                transactions.functionCall(
                    "set_oracle",
                    Buffer.from(JSON.stringify({
                        "oracle_account_id": env.testnet.ORACLE_ACCOUNT_ID,
                        "oracle_provider_id": env.testnet.ORACLE_PROVIDER_ID,
                    })),
                    30000000000000,
                ),
            ],
        });

        console.log(result.receipts_outcome);
        result.receipts_outcome.map(e => console.log(e.outcome));
    }
})();
'''
'''--- shell-script/build.sh ---
#!/bin/bash

raen build --release

'''
'''--- src/events.rs ---
use crate::*;
use near_sdk::serde_json;
use std::fmt;

pub const EVENT_STANDARD_NAME: &str = "nep297"; 
pub const EVENT_VERSION: &str = "1.0.0";

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    UpdateFee(UpdateFeeLog),
    SetOracleId(SetOracleIdLog),
    PayFee(PayFeeLog),
    RefundNear(RefundNearLog),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep297
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct UpdateFeeLog {
    pub old_service_fee: String,
    pub new_service_fee: String,
    pub oracle_id: String,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct SetOracleIdLog {
    pub old_oracle_id: String,
    pub new_oracle_id: String,
    pub owner_id: String,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PayFeeLog {
    pub amount: String,
    pub refund: String,
    pub user_id: String,
    pub old_quota: String,
    pub new_quota: String,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct RefundNearLog {
    pub refund_amount: String,
    pub user_id: String,
}

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::json;
use near_sdk::{
    env, ext_contract, log, near_bindgen, serde_json, AccountId, Balance, BorshStorageKey, Gas,
    PanicOnDefault, Promise, PromiseOrValue, PromiseResult, StorageUsage,
};

pub use crate::events::*;

mod events;

const NO_DEPOSIT: Balance = 0;
const ONE_NEAR: Balance = 1_000_000_000_000_000_000_000_000;
const GAS_FOR_TRANSFER_NEAR_CALLBACK: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER: Gas = Gas(2_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALLBACK: Gas = Gas(3_000_000_000_000);
const GAS_FOR_STORAGE_DEPOSIT_CALLBACK: Gas = Gas(3_000_000_000_000);
const GAS_FOR_STORAGE_DEPOSIT: Gas = Gas(2_000_000_000_000);
const FEE_USD_PER_ADDRESS_DECIMAL_OFFSET: u32 = 2;
const FEE_USD_PER_ADDRESS_VALUE: u128 = 5;

#[ext_contract(ext_ft)]
pub trait FungibleToken {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OracleEntry {
    pub price: U128,
    pub decimals: u32,
    pub last_update: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

#[ext_contract(ext_ts)]
pub trait StorageManagement {
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    fn storage_balance_of(&mut self, account_id: AccountId) -> Option<StorageBalance>;
}

#[ext_contract(ext_self)]
pub trait Handler {
    fn callback_storage_deposit(&self, account_ids: Vec<AccountId>, min_fee: U128);
    fn callback_transfer_near(&self, receivers: Vec<AccountId>, amount: Vec<U128>);
    fn callback_ft_transfer(&self, account_ids: Vec<AccountId>, amount: Vec<U128>) -> U128;
    fn callback_get_entry(&self, estimated_fee: U128, amount: Balance);
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct OldContract {
    pub owner_id: AccountId,  // admin Id
    pub oracle_id: AccountId, // oracleId
    pub balances: LookupMap<AccountId, u128>,
    pub account_storage_usage: StorageUsage,
    pub service_fee: U128,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    BalanceData,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId, // admin Id
    pub balances: LookupMap<AccountId, u128>,
    pub oracle_account_id: AccountId,
    pub oracle_provider_id: AccountId,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(oracle_account_id: AccountId, oracle_provider_id: AccountId) -> Self {
        let this = Self {
            owner_id: env::signer_account_id(),
            balances: LookupMap::new(StorageKey::BalanceData),
            oracle_account_id,
            oracle_provider_id,
        };
        this
    }

    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let old_state: OldContract = env::state_read().expect("failed");

        // Check the caller is authorized to update the code
        assert!(
            env::predecessor_account_id() == old_state.owner_id,
            "Only owner can update the code"
        );

        Self {
            owner_id: old_state.owner_id, // admin Id
            balances: old_state.balances,
            oracle_account_id: AccountId::new_unchecked("oracle_account_id".to_string()),
            oracle_provider_id: AccountId::new_unchecked("oracle_provider_id".to_string()),
        }
    }

    /// Set the oracle account id and  oracle provider id.
    ///
    /// Requirements:
    /// - The caller must be contract owners.
    /// - `oracle_account_id` and `oracle_provider_id` must be a valid near account.
    ///
    /// Arguments:
    /// - `oracle_account_id`: the account id of oracle contract to query token price on-chain.
    /// - `oracle_provider_id`: the account id of provider that update the token price on oracle contract.
    pub fn set_oracle(
        &mut self,
        oracle_account_id: AccountId,
        oracle_provider_id: AccountId,
    ) -> (AccountId, AccountId) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "only contract owner can set oracle"
        );
        self.oracle_account_id = oracle_account_id;
        self.oracle_provider_id = oracle_provider_id;
        (
            self.oracle_account_id.clone(),
            self.oracle_provider_id.clone(),
        )
    }

    /// Return the oracle account id and oracle provider id. For more information, refers to FLux oracle docs.
    pub fn oracle(&self) -> (AccountId, AccountId) {
        (
            self.oracle_account_id.clone(),
            self.oracle_provider_id.clone(),
        )
    }

    /// Return the `owner_id` of the contract. When contract is initialized `owner_id` is set to
    /// the account id that is contract is deployed on.
    pub fn owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// A payable method that transfers near from `env::predecessor_account_id` to `receivers`.
    ///
    /// Requirements:
    /// - The attached deposit must equal the total amount sent to all receivers.
    /// - Caller must pay service fee to get enough quota to transfer near.
    /// - The length of `receivers` and `amount` arguments must be the same.
    ///
    /// Arguments:
    /// - `receivers` - a vec of all receivers' account ID.
    /// - `amount` - a vec of the amount of near sent to each receiver corresponding.
    #[payable]
    pub fn distribute_near(&mut self, receivers: Vec<AccountId>, amount: Vec<U128>) {
        let total_amount: Balance = amount.iter().map(|x| x.0).sum();
        assert_eq!(receivers.len(), amount.len(), "invalid parameters");
        assert_eq!(
            total_amount,
            env::attached_deposit(),
            "Not enough Near attached"
        );
        assert!(
            self.get_account_quota(&env::signer_account_id()) >= receivers.len() as u128,
            "Not enough quota for user"
        );
        let mut transfer_promise = Promise::new(receivers[0].clone()).transfer(amount[0].0);
        for i in 1..receivers.len() {
            transfer_promise =
                transfer_promise.and(Promise::new(receivers[i].clone()).transfer(amount[i].0));
        }
        self.decrease_account_quota(&env::signer_account_id(), receivers.len() as u128);
        transfer_promise.then(ext_self::callback_transfer_near(
            receivers,
            amount,
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_TRANSFER_NEAR_CALLBACK,
        ));
    }

    #[private]
    pub fn callback_transfer_near(&mut self, receivers: Vec<AccountId>, amount: Vec<U128>) {
        assert_eq!(env::promise_results_count(), receivers.len() as u64);
        let mut refund: U128 = 0.into();
        let mut total_failed_transfer: u128 = 0;
        for i in 0..receivers.len() {
            match env::promise_result(i as u64) {
                PromiseResult::NotReady => {
                    log!(" Transfer not ready ");
                }
                PromiseResult::Failed => {
                    refund = (refund.0 + amount[i].0).into();
                    total_failed_transfer += 1;
                }
                PromiseResult::Successful(_) => {}
            };
        }
        if total_failed_transfer > 0 {
            let refund_log: EventLog = EventLog {
                standard: EVENT_STANDARD_NAME.to_string(),
                version: EVENT_VERSION.to_string(),
                event: EventLogVariant::RefundNear(RefundNearLog {
                    refund_amount: refund.0.to_string(),
                    user_id: env::signer_account_id().to_string(),
                }),
            };
            env::log_str(&refund_log.to_string());
            Promise::new(env::signer_account_id()).transfer(refund.0);
            self.increase_account_quota(&env::signer_account_id(), total_failed_transfer);
        }
    }

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receivers`.
    /// This function is executed when user call `ft_transfer_call` on a fungible token contracts.
    /// See [ft_transfer_call](https://github.com/near/NEPs/blob/master/neps/nep-0141.md#ft_transfer_call).
    ///
    /// Requirements:
    /// - `msg` argument must follow this format `"msg": "bob.testnet:20#alice.testnet:50"`. This means
    /// `bob.testnet` receive 20 tokens and `alice.testnet` receive 50 tokens.
    /// - Both `bob` and `alice` must register storage for token contract in advance.
    /// - `sender_id` balance must be greater or equal to the total amount sent to each receiver.
    /// - `sender_id` must pay service fee to get enough quota to transfer near.
    ///
    /// Arguments:
    /// - `sender_id`: the account id of sender.
    /// - `amount`: the amount of token that sender transfer to this contract by calling `ft_transfer_call`.
    /// - `msg` - a string message that includes receivers and amount.
    pub fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        if env::signer_account_id() != sender_id {
            env::panic_str("sender_id is not signer");
        }
        let receivers_info: Vec<&str> = msg.split("#").collect();
        let mut account_id_arr: Vec<AccountId> = Vec::new();
        let mut amount_arr: Vec<U128> = Vec::new();
        for (_, receiver_info) in receivers_info.iter().enumerate() {
            let mut info = receiver_info.split(":");
            let account_id = info.next().unwrap();
            let transfer_amount: &str = info.next().unwrap();
            account_id_arr.push(AccountId::new_unchecked(String::from(account_id)));
            amount_arr.push(transfer_amount.parse::<u128>().unwrap().into());
        }
        let total_amount: U128 = amount_arr.iter().map(|x| x.0).sum::<u128>().into();
        assert_eq!(total_amount, amount, "Not enough amount of token sent");
        assert!(
            self.get_account_quota(&sender_id) >= account_id_arr.len() as u128,
            "Not enough quota for user"
        );

        let mut ft_transfer_promise = ext_ft::ft_transfer(
            account_id_arr[0].clone(),
            amount_arr[0].clone(),
            Some(String::from("")),
            env::predecessor_account_id(), // contract account id
            1,                             // yocto NEAR to attach
            GAS_FOR_FT_TRANSFER,
        );
        for i in 1..amount_arr.len() {
            ft_transfer_promise = ft_transfer_promise.and(ext_ft::ft_transfer(
                account_id_arr[i].clone(),
                amount_arr[i].clone(),
                Some(String::from("")),
                env::predecessor_account_id(), // contract account id
                1,                             // yocto NEAR to attach
                GAS_FOR_FT_TRANSFER,
            ));
        }
        self.decrease_account_quota(&env::signer_account_id(), account_id_arr.len() as u128);
        ft_transfer_promise
            .then(ext_self::callback_ft_transfer(
                account_id_arr,
                amount_arr,
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_FT_TRANSFER_CALLBACK,
            ))
            .into()
    }

    #[private]
    pub fn callback_ft_transfer(&mut self, account_ids: Vec<AccountId>, amount: Vec<U128>) -> U128 {
        assert_eq!(env::promise_results_count(), account_ids.len() as u64);
        let mut refund: U128 = 0.into();
        let mut total_failed_transfer: u128 = 0;
        for i in 0..account_ids.len() {
            match env::promise_result(i as u64) {
                PromiseResult::NotReady => {
                    log!(" Transfer not ready ");
                }
                PromiseResult::Failed => {
                    refund = (refund.0 + amount[i].0).into();
                    total_failed_transfer += 1;
                }
                PromiseResult::Successful(_) => {}
            };
        }
        if total_failed_transfer > 0 {
            self.increase_account_quota(&env::signer_account_id(), total_failed_transfer);
        }
        refund
    }

    /// A payable method that helps pay token storage fee for multiple accounts.
    ///
    /// Requirements:
    /// - The attached deposit must be equal to `min_fee * account_ids.len()`.
    /// - `min_fee` must be equal to the token contract's `StorageBalanceBounds.min`.
    /// - all of the `account_ids` must haven't paid for the token storage fee.
    ///
    /// Arguments:
    /// - `token_id`: token contract account id.
    /// - `account_ids`: the vec of all account that needs to pay token storage fee.
    /// - `min_fee`: the minimum fee needed to cover token storage for each account.
    #[payable]
    pub fn batch_storage_deposit(
        &mut self,
        token_id: AccountId,
        account_ids: Vec<AccountId>,
        min_fee: U128,
    ) {
        assert_eq!(
            min_fee.0 * account_ids.len() as u128,
            env::attached_deposit(),
            "Not enough Near attached"
        );
        let mut storage_deposit_promise = ext_ft::storage_deposit(
            Option::from(account_ids[0].clone()),
            None,
            token_id.clone(),
            min_fee.0,
            GAS_FOR_STORAGE_DEPOSIT,
        );
        for i in 1..account_ids.len() {
            storage_deposit_promise = storage_deposit_promise.and(ext_ft::storage_deposit(
                Option::from(account_ids[i].clone()),
                None,
                token_id.clone(),
                min_fee.0,
                GAS_FOR_STORAGE_DEPOSIT,
            ));
        }
        storage_deposit_promise.then(ext_self::callback_storage_deposit(
            account_ids,
            min_fee,
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_STORAGE_DEPOSIT_CALLBACK,
        ));
    }

    #[private]
    pub fn callback_storage_deposit(&self, account_ids: Vec<AccountId>, min_fee: U128) {
        assert_eq!(env::promise_results_count(), account_ids.len() as u64);
        let mut refund: U128 = 0.into();
        for i in 0..account_ids.len() {
            match env::promise_result(i as u64) {
                PromiseResult::NotReady => {
                    log!(" Transfer not ready ");
                }
                PromiseResult::Failed => {
                    log!("storage registration for {} failed", account_ids[i]);
                    refund = (refund.0 + min_fee.0).into();
                }
                PromiseResult::Successful(_result) => {}
            };
        }
        if refund.0 > 0 {
            let refund_log: EventLog = EventLog {
                standard: EVENT_STANDARD_NAME.to_string(),
                version: EVENT_VERSION.to_string(),
                event: EventLogVariant::RefundNear(RefundNearLog {
                    refund_amount: refund.0.to_string(),
                    user_id: env::signer_account_id().to_string(),
                }),
            };
            env::log_str(&refund_log.to_string());
            Promise::new(env::signer_account_id()).transfer(refund.0);
        }
    }

    /// A payable method to pay service fee. This method will increase
    /// the number of user quota to transfer near and tokens.
    #[payable]
    pub fn pay_service_fee(&mut self, estimated_fee: U128) {
        Promise::new(AccountId::new_unchecked(self.oracle_account_id.to_string()))
            .function_call(
                "get_entry".to_string(),
                serde_json::to_vec(&json!({
                    "pair": "NEAR/USD".to_string(),
                    "provider": self.oracle_provider_id.to_string()
                }))
                .unwrap(),
                NO_DEPOSIT,
                Gas(5_000_000_000_000),
            )
            .then(ext_self::callback_get_entry(
                estimated_fee,
                env::attached_deposit(),
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_STORAGE_DEPOSIT_CALLBACK,
            ));
    }

    #[private]
    pub fn callback_get_entry(&mut self, estimated_fee: U128, amount: Balance) {
        assert_eq!(env::promise_results_count(), 1, "This is a callback method");
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => {}
            PromiseResult::Successful(result) => {
                let res = near_sdk::serde_json::from_slice::<OracleEntry>(&result).unwrap();
                let oracle_fee: U128 = (ONE_NEAR
                    * FEE_USD_PER_ADDRESS_VALUE
                    * 10u128.pow(res.decimals - FEE_USD_PER_ADDRESS_DECIMAL_OFFSET)
                    / res.price.0)
                    .into();
                log!(
                    "diff: {}, rate: {}, oracle_fee: {}, estimated_fee: {}",
                    oracle_fee.0.abs_diff(estimated_fee.0),
                    oracle_fee.0 / 10u128,
                    oracle_fee.0,
                    estimated_fee.0
                );
                if oracle_fee.0.abs_diff(estimated_fee.0) > oracle_fee.0 / 10u128 {
                    let refund_log: EventLog = EventLog {
                        standard: EVENT_STANDARD_NAME.to_string(),
                        version: EVENT_VERSION.to_string(),
                        event: EventLogVariant::RefundNear(RefundNearLog {
                            refund_amount: amount.to_string(),
                            user_id: env::signer_account_id().to_string(),
                        }),
                    };
                    env::log_str(&refund_log.to_string());
                    Promise::new(env::signer_account_id()).transfer(amount);
                } else {
                    let redundant_coin = amount % estimated_fee.0;
                    if redundant_coin != 0 {
                        Promise::new(env::signer_account_id()).transfer(redundant_coin);
                    }

                    let num_addr: u128 = amount / estimated_fee.0;
                    let current_quota: u128 = self.get_account_quota(&env::signer_account_id());
                    let pay_fee_log: EventLog = EventLog {
                        standard: EVENT_STANDARD_NAME.to_string(),
                        version: EVENT_VERSION.to_string(),
                        event: EventLogVariant::PayFee(PayFeeLog {
                            amount: amount.to_string(),
                            refund: redundant_coin.to_string(),
                            user_id: env::signer_account_id().to_string(),
                            old_quota: current_quota.to_string(),
                            new_quota: (current_quota + num_addr).to_string(),
                        }),
                    };
                    self.increase_account_quota(&env::signer_account_id(), num_addr);
                    env::log_str(&pay_fee_log.to_string());
                }
            }
        }
    }

    fn increase_account_quota(&mut self, account_id: &AccountId, num: u128) {
        let value = self.get_account_quota(account_id) + num;
        self.balances.insert(&account_id, &value);
    }

    fn decrease_account_quota(&mut self, account_id: &AccountId, num: u128) {
        let value = self.get_account_quota(account_id) - num;
        self.balances.insert(&account_id, &value);
    }

    /// Return the number of quota for `account_id`. This quota is the total number of account that user can
    /// transfer near and tokens to. For each successful transfer the total quota will be decreased by 1.
    pub fn get_account_quota(&self, account_id: &AccountId) -> u128 {
        self.balances.get(account_id).unwrap_or_default()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    // use near_sdk::MockedBlockchain;
    use near_sdk::testing_env;

    use super::*;

    // const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new(
            AccountId::new_unchecked("id".to_string()),
            AccountId::new_unchecked("id".to_string()),
        );
        testing_env!(context.is_view(true).build());
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_increase_account_quota() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Contract::new(
            AccountId::new_unchecked("id".to_string()),
            AccountId::new_unchecked("id".to_string()),
        ); // testing_env!(context.is_view(true).build());
        let service_fee: U128 = 1u128.into();
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(service_fee.0)
            .predecessor_account_id(accounts(2))
            .build());
        // contract.pay_service_fee();
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(service_fee.0)
            .predecessor_account_id(accounts(2))
            .build());
        contract.increase_account_quota(&accounts(2), 1);
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.get_account_quota(&accounts(2)), 2);
    }

    #[test]
    fn test_decrease_account_quota() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Contract::new(
            AccountId::new_unchecked("id".to_string()),
            AccountId::new_unchecked("id".to_string()),
        ); // testing_env!(context.is_view(true).build());
        let service_fee: U128 = 1u128.into();
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(service_fee.0)
            .predecessor_account_id(accounts(2))
            .build());
        // contract.pay_service_fee();
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(service_fee.0)
            .predecessor_account_id(accounts(2))
            .build());
        contract.decrease_account_quota(&accounts(2), 1);
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.get_account_quota(&accounts(2)), 0);
    }
}
'''
'''--- tests/sim/macros.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
// use near_sdk::serde_json::json;
use near_sdk_sim::ExecutionResult;
use near_sdk_sim::{call, to_yocto, view, DEFAULT_GAS};

use crate::utils::{init_with_macros as init, register_user};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

#[test]
fn simulate_distribute_near() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("100000");

    let (root, _ft, bs, alice) = init(initial_balance);

    // let service_fee: U128 = view!(bs.service_fee()).unwrap_json();

    // let root_init_balance = root.account().unwrap().amount;
    let alice_init_balance = alice.account().unwrap().amount;

    // let service_res = call!(
    //     root,
    //     bs.pay_service_fee(),
    //     deposit = service_fee.0 * 2
    // );

    // service_res.assert_success();

    let distribute_res = call!(
        root,
        bs.distribute_near(
            vec![alice.account_id(), alice.account_id()],
            vec![transfer_amount.into(), transfer_amount.into()]
        ),
        transfer_amount * 2,
        DEFAULT_GAS / 2
    );

    distribute_res.assert_success();

    // let root_balance = root.account().unwrap().amount;
    let alice_balance = alice.account().unwrap().amount;
    // assert_eq!(root_init_balance - transfer_amount * 2 - distribute_res.tokens_burnt() - service_res.tokens_burnt(), root_balance);
    assert_eq!(alice_init_balance + transfer_amount * 2, alice_balance);
}

#[test]
fn simulate_distribute_ft() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("100000");

    let (root, ft, bs, alice) = init(initial_balance);

    register_user(&bs.user_account);

    // let service_fee: U128 = view!(bs.service_fee()).unwrap_json();

    // call!(
    //     root,
    //     bs.pay_service_fee(),
    //     deposit = service_fee.0 * 2
    // )
    // .assert_success();

    let res: ExecutionResult = call!(
        root,
        ft.ft_transfer_call(
            bs.account_id(),
            (transfer_amount * 2).into(),
            None,
            format!(
                "{}:{}#{}:{}",
                alice.account_id(),
                transfer_amount,
                alice.account_id(),
                transfer_amount
            )
            .into()
        ),
        1,
        DEFAULT_GAS / 2
    );

    res.assert_success();

    // println!("{:#?}", res.promise_results());

    assert_eq!(res.promise_errors().len(), 0);

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let alice_balance: U128 = view!(ft.ft_balance_of(alice.account_id())).unwrap_json();
    // println!("alice_balance: {}", alice_balance.0);
    assert_eq!(initial_balance - transfer_amount * 2, root_balance.0);
    assert_eq!(transfer_amount * 2, alice_balance.0);
}

#[test]
fn simulate_batch_storage_deposit() {
    let initial_balance = to_yocto("100000");

    let (_root, ft, bs, alice) = init(initial_balance);
    let storage_bounds: StorageBalanceBounds = view!(ft.storage_balance_bounds()).unwrap_json();

    call!(
        alice,
        bs.batch_storage_deposit(
            ft.account_id(),
            vec![bs.account_id(), alice.account_id()],
            storage_bounds.min
        ),
        storage_bounds.min.0 * 2,
        DEFAULT_GAS / 2
    )
    .assert_success();
}

'''
'''--- tests/sim/main.rs ---
mod utils;
mod macros;

'''
'''--- tests/sim/utils.rs ---
use bulk_sender::ContractContract as BSContract;
use fungible_token::ContractContract as FtContract;

// use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, ContractAccount, UserAccount, DEFAULT_GAS,
};

// Load in contract bytes at runtime
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    FT_WASM_BYTES => "res/fungible_token.wasm",
    BULKSENDER_WASM_BYTES => "target/res/bulk_sender.wasm",
}

const FT_ID: &str = "ft";
const BS_ID: &str = "bulksender";

// Register the given `user` with FT contract
pub fn register_user(user: &near_sdk_sim::UserAccount) {
    user.call(
        FT_ID.parse().unwrap(),
        "storage_deposit",
        &json!({
            "account_id": user.account_id()
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 125, // attached deposit
    )
    .assert_success();
}

// pub fn init_no_macros(initial_balance: u128) -> (UserAccount, UserAccount, UserAccount, UserAccount) {
//     let root = init_simulator(None);

//     let ft = root.deploy(&FT_WASM_BYTES, FT_ID.parse().unwrap(), STORAGE_AMOUNT);

//     ft.call(
//         FT_ID.parse().unwrap(),
//         "new_default_meta",
//         &json!({
//             "owner_id": root.account_id(),
//             "total_supply": U128::from(initial_balance),
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS / 2,
//         0, // attached deposit
//     )
//     .assert_success();

//     let bs = root.deploy(&BULKSENDER_WASM_BYTES, BS_ID.parse().unwrap(), STORAGE_AMOUNT);

//     bs.call(
//         BS_ID.parse().unwrap(),
//         "new",
//         &json!({
//             "oracle_id": root.account_id()
//         })
//         .to_string()
//         .into_bytes(),
//         DEFAULT_GAS / 2,
//         0,
//     )
//     .assert_success();

//     let alice = root.create_user("alice".parse().unwrap(), to_yocto("100"));
//     register_user(&alice);

//     (root, ft, bs, alice)
// }

pub fn init_with_macros(
    initial_balance: u128,
) -> (UserAccount, ContractAccount<FtContract>, ContractAccount<BSContract>, UserAccount) {
    let root = init_simulator(None);
    // uses default values for deposit and gas
    let ft = deploy!(
        // Contract Proxy
        contract: FtContract,
        // Contract account id
        contract_id: FT_ID,
        // Bytes of contract
        bytes: &FT_WASM_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new_default_meta(
            root.account_id(),
            initial_balance.into()
        )
    );
    let alice = root.create_user("alice".parse().unwrap(), to_yocto("100"));
    register_user(&alice);

    let bulksender = deploy!(
        contract: BSContract,
        contract_id: BS_ID,
        bytes: &BULKSENDER_WASM_BYTES,
        signer_account: root,
        init_method: new(
            root.account_id(),
            root.account_id()
        )
    );

    (root, ft, bulksender, alice)
}

'''