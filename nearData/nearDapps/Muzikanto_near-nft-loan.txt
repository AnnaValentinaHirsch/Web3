*GitHub Repository "Muzikanto/near-nft-loan"*

'''--- README.md ---
## Navigation

### First
- sh nft/dev-deploy.sh (развернуть в тестнете)
- sh nft/dev-init.sh (инициализировать в тестнете)
- sh loan/dev-deploy.sh (развернуть в тестнете)
- sh loan/dev-init.sh (инициализировать в тестнете)
- обновить NFT_CONTRACT и LOAN_CONTRACT в env файлах

### Add Nft to whitelist
- sh loan/loan_update_nft_price.sh (обновить цену и процент от цены нфт который остается в смарт контракте)
- sh loan/loan_nft_whitelist_add.sh (добавить нфт в whitelist)
- sh loan/loan_nft_whitelist.sh (список whitelist)

### Loan Nft
- обновить id в следующих файлах (для тестирования)
- sh /nft/mint.sh (создать nft)
- sh /nft/nft_approve.sh (апрув лэндингового контракта)
- sh /loan/loan_nft.sh (отправляем нфт и получаем займ)
- sh /loan/loan_rest_by_id.sh (смотрим сколько нужно выплатить чтобы погасить займ)
- sh /loan/loan_nft_pay.sh (выплатить займ за нфт)
- sh /loan/loan_nft_claim.sh (вернуть нфт, если займ выплачен)

### Liquidity provider
- sh /loan/loan_deposit.sh (отправить деньги в ликвидность)
- sh /loan/loan_withdraw.sh (вывести часть денег)
- sh /loan/loan_withdraw_all.sh (вывести все деньги)
- sh /loan/loan_balance_of.sh (просмотр баланса)
- sh /loan/loan_reward_of.sh (просмотр баланса ревардов)
- sh /loan/loan_reward_unclaimed_of.sh
- sh /loan/loan_reward_claimed_of.sh
- sh /loan/loan_claim_reward.sh (получить реварды)

'''
'''--- loan/Cargo.toml ---
[package]
name = "loan"
version = "0.1.0"
authors = ["Muzikanto <schiriy_maxim@icloud.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { version = "=4.0.0-pre.6" }
serde = "1"
serde_json = "1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- loan/scripts/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
source flags.sh
cargo build --all --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/*.wasm ../res/

'''
'''--- loan/scripts/deploy.sh ---
sh build.sh && near deploy --accountId mfight-ft.testnet --wasmFile ../res/ft.wasm --helperUrl https://near-contract-helper.onrender.com

'''
'''--- loan/scripts/dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

sh ./build.sh

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# comment out the line below to deploy the other example contract
near dev-deploy ../res/loan.wasm

# uncomment the line below to deploy the other example contract
# near dev-deploy ./build/release/singleton.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- loan/scripts/dev-init.sh ---
#!/bin/bash
source neardev/dev-account.env
OWNER_ID="$CONTRACT_NAME"
near call $CONTRACT_NAME new_default_meta --accountId $CONTRACT_NAME "{ \"owner_id\": \"$OWNER_ID\", \"total_supply\": \"50000000000000000000000000000000\" }"

'''
'''--- loan/scripts/dev-migrate.sh ---
#!/bin/bash
source neardev/dev-account.env

# migrate state
near call $CONTRACT_NAME migrate --accountId $CONTRACT_NAME "{ }"

'''
'''--- loan/scripts/flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- loan/scripts/loan_available_balance.sh ---
#!/bin/bash
source neardev/dev-account.env
near view $CONTRACT_NAME loan_available_balance "{  }"

'''
'''--- loan/scripts/loan_balance_borrowed_of.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME loan_balance_borrowed_of "{ \"account_id\": \"$ACCOUNT_ID\" }"

'''
'''--- loan/scripts/loan_balance_of.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME loan_balance_of "{ \"account_id\": \"$ACCOUNT_ID\" }"

'''
'''--- loan/scripts/loan_claim_rewards.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near call $CONTRACT_NAME loan_claim_rewards --accountId $ACCOUNT_ID "{ }" --gas 300000000000000

'''
'''--- loan/scripts/loan_commission.sh ---
#!/bin/bash
source neardev/dev-account.env
near view $CONTRACT_NAME loan_commission "{  }"

'''
'''--- loan/scripts/loan_deposit.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near call $CONTRACT_NAME loan_deposit --accountId $ACCOUNT_ID "{}" --amount "1"

'''
'''--- loan/scripts/loan_nft.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
TOKEN_ID="6"
near call $CONTRACT_NAME loan_nft --accountId $ACCOUNT_ID "{ \"token_id\": \"$TOKEN_ID\", \"contract_id\": \"$NFT_CONTRACT\" }" --gas 300000000000000

'''
'''--- loan/scripts/loan_nft_by_id.sh ---
#!/bin/bash
source neardev/dev-account.env
NFT_CONTRACT="tiger7.testnet"
TOKEN_ID="1955"
near view $CONTRACT_NAME loan_nft_by_id "{ \"contract_id\": \"$NFT_CONTRACT\", \"token_id\": \"$TOKEN_ID\" }"

'''
'''--- loan/scripts/loan_nft_by_owner.sh ---
#!/bin/bash
source neardev/dev-account.env
OWNER_ID="muzikant.testnet"
LIMIT="10"
FROM_INDEX="0"
near view $CONTRACT_NAME loan_nft_by_owner "{ \"account_id\": \"$OWNER_ID\", \"from_index\": \"$FROM_INDEX\", \"limit\": $LIMIT }"

'''
'''--- loan/scripts/loan_nft_claim.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
TOKEN_ID="6"
near call $CONTRACT_NAME loan_nft_claim --accountId $ACCOUNT_ID "{ \"token_id\": \"$TOKEN_ID\", \"contract_id\": \"$NFT_CONTRACT\" }" --gas 300000000000000

'''
'''--- loan/scripts/loan_nft_claim_expired.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
TOKEN_ID="9269"
near call $CONTRACT_NAME loan_nft_claim_expired --accountId $CONTRACT_NAME "{ \"token_id\": \"$TOKEN_ID\", \"contract_id\": \"$NFT_CONTRACT2\" }" --gas 300000000000000

'''
'''--- loan/scripts/loan_nft_is_whitelist.sh ---
#!/bin/bash
source neardev/dev-account.env
near view $CONTRACT_NAME loan_nft_is_whitelist "{ \"contract_id\": \"$NFT_CONTRACT\" }"

'''
'''--- loan/scripts/loan_nft_pay.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
TOKEN_ID="4"
near call $CONTRACT_NAME loan_nft_pay --accountId $ACCOUNT_ID "{ \"token_id\": \"$TOKEN_ID\", \"contract_id\": \"$NFT_CONTRACT\" }" --amount "0.872" --gas 300000000000000

'''
'''--- loan/scripts/loan_nft_price.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME loan_nft_price "{ \"contract_id\": \"$NFT_CONTRACT\" }"

'''
'''--- loan/scripts/loan_nft_whitelist.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME loan_nft_whitelist "{ }"

'''
'''--- loan/scripts/loan_nft_whitelist_add.sh ---
#!/bin/bash
source neardev/dev-account.env
NFT_CONTRACT="dev-1648577859565-13862973208014"
near call $CONTRACT_NAME loan_nft_whitelist_add --accountId $CONTRACT_NAME "{ \"contract_id\": \"$NFT_CONTRACT\"}" --depositYocto=1

'''
'''--- loan/scripts/loan_nft_whitelist_remove.sh ---
#!/bin/bash
source neardev/dev-account.env
NFT_CONTRACT="dev-1648577859565-13862973208014"
near call $CONTRACT_NAME loan_nft_whitelist_remove --accountId $CONTRACT_NAME "{ \"contract_id\": \"$NFT_CONTRACT\"}" --depositYocto=1

'''
'''--- loan/scripts/loan_owner_by_id.sh ---
#!/bin/bash
source neardev/dev-account.env
TOKEN_ID="4"
near view $CONTRACT_NAME loan_owner_by_id "{ \"token_id\": \"$TOKEN_ID\", \"contract_id\": \"$NFT_CONTRACT\" }"

'''
'''--- loan/scripts/loan_rest_by_id.sh ---
#!/bin/bash
source neardev/dev-account.env
TOKEN_ID="7"
near view $CONTRACT_NAME loan_rest_by_id "{ \"token_id\": \"$TOKEN_ID\", \"contract_id\": \"$NFT_CONTRACT\" }"

'''
'''--- loan/scripts/loan_reward_of.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME loan_reward_of "{ \"account_id\": \"$ACCOUNT_ID\" }"

'''
'''--- loan/scripts/loan_reward_unclaimed_of.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME loan_reward_unclaimed_of "{ \"account_id\": \"$ACCOUNT_ID\" }"

'''
'''--- loan/scripts/loan_shares_of.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME loan_shares_of "{ \"account_id\": \"$ACCOUNT_ID\" }"

'''
'''--- loan/scripts/loan_total_balance.sh ---
#!/bin/bash
source neardev/dev-account.env

near view $CONTRACT_NAME loan_total_balance "{  }"

'''
'''--- loan/scripts/loan_total_loan.sh ---
#!/bin/bash
source neardev/dev-account.env
near view $CONTRACT_NAME loan_total_loan "{  }"

'''
'''--- loan/scripts/loan_total_rewards_pool.sh ---
#!/bin/bash
source neardev/dev-account.env

near view $CONTRACT_NAME loan_total_rewards_pool "{  }"

'''
'''--- loan/scripts/loan_total_shares.sh ---
#!/bin/bash
source neardev/dev-account.env
near view $CONTRACT_NAME loan_total_shares "{  }"

'''
'''--- loan/scripts/loan_update_nft_price.sh ---
#!/bin/bash
source neardev/dev-account.env
NFT_CONTRACT="dev-1648577859565-13862973208014"
PRICE="1000000000000000000000000"
PERCENT="20"
near call $CONTRACT_NAME loan_update_nft_price --accountId $CONTRACT_NAME "{ \"contract_id\": \"$NFT_CONTRACT\", \"price\": \"$PRICE\", \"percent\": $PERCENT }" --gas 300000000000000

'''
'''--- loan/scripts/loan_withdraw.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
AMOUNT="1000000000000000000000000"
near call $CONTRACT_NAME loan_withdraw --accountId $ACCOUNT_ID "{ \"amount\": \"$AMOUNT\" }"

'''
'''--- loan/scripts/loan_withdraw_all.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near call $CONTRACT_NAME loan_withdraw_all --accountId $ACCOUNT_ID "{ }"

'''
'''--- loan/scripts/neardev/dev-account.env ---
CONTRACT_NAME=dev-1653750482708-69295012022419
NFT_CONTRACT=dev-1648577859565-13862973208014

'''
'''--- loan/scripts/test.sh ---
#!/bin/bash
source neardev/dev-account.env

ACCOUNT_ID="muzikant.testnet"
#ACCOUNT_ID="$NFT_CONTRACT"
#ACCOUNT_ID="dev-1643800447163-39288638998900" #test

#sh dev-deploy.sh
#sh dev-init.sh
#sh loan_update_nft_price.sh
#sh load_nft_whitelist_add.sh

#near call $CONTRACT_NAME loan_deposit --accountId $ACCOUNT_ID "{}" --amount "100" --gas 300000000000000
#near view $CONTRACT_NAME loan_total_balance "{  }"
#near view $CONTRACT_NAME loan_total_shares "{  }"
#near view $CONTRACT_NAME loan_total_rewards_pool "{  }"
#near view $CONTRACT_NAME loan_reward_of "{ \"account_id\": \"$ACCOUNT_ID\" }"
#near view $CONTRACT_NAME loan_shares_of "{ \"account_id\": \"$ACCOUNT_ID\" }"
#near call $CONTRACT_NAME loan_claim_rewards --accountId $ACCOUNT_ID "{ }" --gas 300000000000000
#near call $CONTRACT_NAME loan_withdraw_all --accountId $ACCOUNT_ID "{ }" --gas 300000000000000
#near view $CONTRACT_NAME loan_reward_unclaimed_of "{ \"account_id\": \"$ACCOUNT_ID\" }"

#near call $CONTRACT_NAME test --accountId $ACCOUNT_ID "{ \"account_id\": \"$ACCOUNT_ID\" }"

'''
'''--- loan/src/base/base.rs ---
use near_sdk::{Balance, AccountId, ext_contract};
use near_sdk::json_types::U128;
use crate::meta::JsonLoan;

pub type TokenId = String;
pub type ContractId = AccountId;

pub trait LoanFactoryCore {
    fn loan_nft(&mut self, token_id: TokenId, contract_id: ContractId);
    fn loan_nft_pay(&mut self, token_id: TokenId, contract_id: ContractId);
    fn loan_nft_claim(&mut self, token_id: TokenId, contract_id: ContractId);
    fn loan_update_nft_price(&mut self, contract_id: ContractId, price: U128, percent: u64);
    fn loan_nft_claim_expired(&mut self, token_id: TokenId, contract_id: ContractId);

    fn loan_balance_borrowed_of(&self, account_id: AccountId) -> U128;
    fn loan_rest_by_id(&self, token_id: TokenId, contract_id: ContractId) -> U128;
    fn loan_owner_by_id(&self, token_id: TokenId, contract_id: ContractId) -> AccountId;

  fn loan_nft_price(&self, contract_id: ContractId) -> Vec<U128>;
  fn loan_total_nft(&self) -> u128;
  fn loan_commission(&self) -> u128;

    fn loan_nft_by_id(&self, token_id: TokenId, contract_id: ContractId) -> JsonLoan;
    fn loan_nft_by_owner(&self, account_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonLoan>;
}

pub trait LoanFactoryResolver {
    fn loan_resolve_nft(&mut self, receiver_id: AccountId, contract_id: ContractId, token_id: TokenId, contract_token_id: TokenId, price: Balance, percent: u64);
    fn loan_resolve_nft_claim(&mut self, receiver_id: AccountId, contract_id: ContractId, token_id: TokenId, contract_token_id: TokenId);
}

'''
'''--- loan/src/base/base_impl.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet, TreeMap};
use near_sdk::json_types::U128;
use near_sdk::{env, ext_contract, log, require, AccountId, Balance, Gas, IntoStorageKey, PromiseOrValue, PromiseResult, StorageUsage, Promise, is_promise_success};
use crate::base::{LoanFactoryCore, LoanFactoryResolver};
use crate::base::base::{ContractId, TokenId};
use std::collections::HashMap;
use crate::utils::date_now;
use crate::meta::JsonLoan;
use crate::event::{LoanWhitelistUpdatePrice, LoanNftClaimExpired, LoanNftClaim, LoanNft, LoanNftPay};

const CALLBACK_ON_RESOLVE_NFT: Gas = Gas(50_000_000_000_000);
const CALLBACK_ON_PAY: Gas = Gas(20_000_000_000_000);

const GAS_FOR_LOAN_NFT: Gas = Gas(60_000_000_000_000);
const GAS_FOR_LOAN_CLAIM_NFT: Gas = Gas(60_000_000_000_000);
const GAS_FOR_NFT_TRANSFER: Gas = Gas(18_000_000_000_000);
const NO_DEPOSIT: Balance = 0;
const ONE_YOCTO: Balance = 1;
pub(crate) const TIME_IN_WEEK: u64 = 604800000; // 5 min // 604800000; // 1 week

#[ext_contract(ext_self)]
pub trait ExtSelf {
  fn loan_resolve_nft(&mut self, receiver_id: AccountId, contract_id: ContractId, token_id: TokenId, contract_token_id: TokenId, price: Balance, percent: u64);
  fn loan_resolve_nft_claim(&mut self, receiver_id: AccountId, contract_id: ContractId, token_id: TokenId, contract_token_id: TokenId);

  fn on_transfer_nft_pay(&mut self, account_id: AccountId, amount_sent: U128, fee: U128, recipient: AccountId, contract_token_id: TokenId, contract_id: AccountId, token_id: TokenId);
  fn on_transfer_resolve_nft(&mut self, account_id: AccountId, amount_sent: U128, recipient: AccountId, contract_token_id: TokenId, contract_id: AccountId, token_id: TokenId, expire_date: u64);
}

#[ext_contract(ext_nft)]
pub trait NonFungibleTokenLockedReceiver {
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    );
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct LoanFactory {
    pub total_balance: U128,
    pub total_rewards_pool: U128,
    pub total_shares: U128,
    pub total_loan: U128,
    pub commission: u128,
    pub accounts: TreeMap<AccountId, Balance>,
    pub loan_by_nft: LookupMap<TokenId, Balance>,

    pub price_by_nft: LookupMap<TokenId, Balance>,
    pub percent_by_nft: LookupMap<TokenId, u64>,

    pub loan_by_account: LookupMap<AccountId, Balance>,
    pub loan_date_by_nft: TreeMap<TokenId, u64>,
    pub nft_by_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

    pub owner_by_nft: LookupMap<TokenId, AccountId>,

    pub price_by_contract: LookupMap<ContractId, Balance>,
    pub percent_by_contract: LookupMap<ContractId, u64>,
    pub shares_by_account: LookupMap<AccountId, U128>,

    pub claim_date_by_account: LookupMap<AccountId, u64>,
    pub reward_by_account: LookupMap<AccountId, U128>,

    pub whitelist: HashMap<ContractId, bool>,

    pub owner_id: AccountId,
}

impl LoanFactory {
    pub fn new<S, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13>(
        owner_id: AccountId,
        commission: u128,
        account_prefix: S,
        loan_by_nft_prefix: S2,
        loan_by_account_prefix: S3,
        nft_owner_prefix: S4,
        price_by_nft_prefix: S5,
        loan_date_by_nft_prefix: S6,
        claim_date_by_nft_prefix: S7,
        reward_by_account_prefix: S8,
        percent_by_nft_prefix: S9,
        nft_by_owner_prefix: S10,
        percent_by_contract_prefix: S11,
        price_by_contract_prefix: S12,
      shares_by_account_prefix: S13
    ) -> Self
        where
            S: IntoStorageKey,
            S2: IntoStorageKey,
            S3: IntoStorageKey,
            S4: IntoStorageKey,
            S5: IntoStorageKey,
            S6: IntoStorageKey,
            S7: IntoStorageKey,
            S8: IntoStorageKey,
            S9: IntoStorageKey,
            S10: IntoStorageKey,
            S11: IntoStorageKey,
            S12: IntoStorageKey,
            S13: IntoStorageKey,
    {
        let mut this = Self {
          total_shares: U128::from(0),
            commission,
            total_rewards_pool: U128::from(0),
            total_loan: U128::from(0),
            total_balance: U128::from(0),
            accounts: TreeMap::new(account_prefix),
            loan_by_nft: LookupMap::new(loan_by_nft_prefix),
            loan_by_account: LookupMap::new(loan_by_account_prefix),
            owner_by_nft: LookupMap::new(nft_owner_prefix),
            price_by_nft: LookupMap::new(price_by_nft_prefix),
            percent_by_nft: LookupMap::new(percent_by_nft_prefix),
            loan_date_by_nft: TreeMap::new(loan_date_by_nft_prefix),
            claim_date_by_account: LookupMap::new(claim_date_by_nft_prefix),
            reward_by_account: LookupMap::new(reward_by_account_prefix),
            nft_by_owner: LookupMap::new(nft_by_owner_prefix),
            percent_by_contract: LookupMap::new(percent_by_contract_prefix),
            price_by_contract: LookupMap::new(price_by_contract_prefix),
            shares_by_account: LookupMap::new(shares_by_account_prefix),
            owner_id,
            whitelist: HashMap::new(),
        };

        this
    }
}

impl LoanFactoryCore for LoanFactory {
    fn loan_nft(&mut self, token_id: TokenId, contract_id: ContractId) {
      self.assert_nft_whitelist(&contract_id);

      let signer_id = env::signer_account_id();
      let receiver_id = env::current_account_id();
      let contract_token_id = self.internal_get_token_id(&contract_id, &token_id);

      let loan = self.loan_by_nft.get(&contract_token_id).unwrap_or_else(|| 0);

      let price = self.price_by_contract.get(&contract_id).expect("Not found price for current nft");
      let percent = self.percent_by_contract.get(&contract_id).expect("Not found percent for current nft");

      self.assert_available_balance(&U128::from(price));

        if loan > 0 {
            env::panic_str("Nft already in loan");
        }

        self.internal_set_nft_owner(&signer_id, &contract_token_id);

        ext_nft::nft_transfer(
            receiver_id,
            token_id.clone(),
            None,
            None,

            contract_id.clone(),
            ONE_YOCTO,
            GAS_FOR_NFT_TRANSFER,
        ).then(ext_self::loan_resolve_nft(
            signer_id.clone(),
            contract_id.clone(),
            token_id.clone(),
            contract_token_id.clone(),
            price.clone(),
            percent.clone(),

            env::current_account_id().clone(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_LOAN_NFT,
        ));
    }

    fn loan_nft_pay(&mut self, token_id: TokenId, contract_id: ContractId) {
      let signer_id = env::predecessor_account_id();
      let contract_token_id = self.internal_get_token_id(&contract_id, &token_id);

      let loan_amount = self.internal_rest_of_loan(&contract_token_id).0;
      let balance = env::attached_deposit();
      let fee = loan_amount * self.commission / 100;
      let return_amount = loan_amount + fee;

      self.assert_loan_not_expired(&contract_token_id);

      if return_amount != balance {
        env::panic_str(&format!("Invalid attached deposit, require {}, current {}", return_amount.to_string(), balance.to_string()));
      }

      self.internal_decrease_loan_nft(&contract_token_id, &U128(loan_amount));
      self.internal_decrease_loan_balance(&signer_id, &U128(loan_amount));
      self.total_loan = U128::from(self.total_loan.0 - loan_amount);
      self.total_rewards_pool = U128::from(self.total_rewards_pool.0 + fee);

      Promise::new(env::current_account_id())
        .transfer(return_amount)
        .then(
        ext_self::on_transfer_nft_pay(
          env::predecessor_account_id(),
          U128::from(return_amount),
          U128::from(fee),
          env::current_account_id(),
          contract_token_id.clone(),
          contract_id.clone(),
          token_id.clone(),
          env::current_account_id(),
          0,
          CALLBACK_ON_PAY,
        )
      );

      // self.total_balance = U128::from(self.total_balance.0 );

      // LoanNftPay {
      //     owner_id: &signer_id,
      //     contract_id: &contract_id,
      //     token_id: &token_id,
      //     loan_amount: &U128::from(loan_amount),
      //   }.emit();

      self.loan_nft_claim(token_id.clone(), contract_id.clone());
    }

    fn loan_nft_claim(&mut self, token_id: TokenId, contract_id: ContractId) {
        let contract_token_id = self.internal_get_token_id(&contract_id, &token_id);
        let receiver_id = self.owner_by_nft.get(&contract_token_id).expect("Not found token owner");
        let loan =self.internal_rest_of_loan(&contract_token_id).0;

        if loan > 0 {
            env::panic_str(&"Close loan first");
        }

        ext_nft::nft_transfer(
            receiver_id.clone(),
            token_id.clone(),
            None,
            None,

            contract_id.clone(),
            ONE_YOCTO,
            GAS_FOR_NFT_TRANSFER,
        ).then(ext_self::loan_resolve_nft_claim(
            receiver_id.clone(),
            contract_id.clone(),
            token_id.clone(),
            contract_token_id.clone(),

            env::current_account_id().clone(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_LOAN_CLAIM_NFT,
        ));
    }

  fn loan_update_nft_price(&mut self, contract_id: ContractId, price: U128, percent: u64) {
    self.assert_owner();

    if percent > (50 as u64) {
      env::panic_str("Max percent is 50");
    }
    if percent < (1 as u64) {
      env::panic_str("Min percent is 1");
    }
    if price.0 < ONE_YOCTO {
      env::panic_str("Invalid price");
    }

    self.internal_set_nft_price(&contract_id, &price.0, &percent);

    LoanWhitelistUpdatePrice {
      contract_id: &contract_id,
      price: &price,
      percent: &percent
    }.emit();
  }

  fn loan_nft_claim_expired(&mut self, token_id: TokenId, contract_id: ContractId) {
    // self.assert_owner();

    let current_id = env::current_account_id();
    let contract_token_id = self.internal_get_token_id(&contract_id, &token_id);
    let owner_id = self.owner_by_nft.get(&contract_token_id).expect("Not found token owner");

    self.assert_loan_expired(&contract_token_id);

    self.internal_remove_nft_owner(&owner_id, &contract_token_id);
    self.internal_set_nft_owner(&current_id, &contract_token_id);
    self.loan_date_by_nft.remove(&contract_token_id);

    LoanNftClaimExpired {
        old_owner_id: &owner_id,
        contract_id: &contract_id,
        token_id: &token_id
      }.emit();
    }

  fn loan_balance_borrowed_of(&self, account_id: AccountId) -> U128 {
      self.internal_balance_of_loan(&account_id)
  }

  fn loan_rest_by_id(&self, token_id: TokenId, contract_id: ContractId) -> U128 {
      let contract_token_id = self.internal_get_token_id(&contract_id, &token_id);

      U128::from(self.loan_by_nft.get(&contract_token_id).expect("Not found loan"))
  }

  fn loan_owner_by_id(&self, token_id: TokenId, contract_id: ContractId) -> AccountId {
      let contract_token_id = self.internal_get_token_id(&contract_id, &token_id);

      self.owner_by_nft.get(&contract_token_id).expect("Not found loan")
  }

  fn loan_nft_price(&self, contract_id: ContractId) -> Vec<U128> {
    let price = self.price_by_contract.get(&contract_id).expect("Not found price");
    let percent = self.percent_by_contract.get(&contract_id).expect("Not found percent");

    vec![U128::from(price), U128::from(percent as u128)]
  }

  fn loan_total_nft(&self) -> u128 {
    self.loan_date_by_nft.len() as u128
  }

  fn loan_commission(&self) -> u128 {
    self.commission
  }

  fn loan_nft_by_id(&self, token_id: TokenId, contract_id: ContractId) -> JsonLoan {
    let contract_token_id = self.internal_get_token_id(&contract_id, &token_id);

    self.enum_get_loan(&contract_token_id)
  }

  fn loan_nft_by_owner(&self, account_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonLoan> {
    let token_set = if let Some(token_set) = self.nft_by_owner.get(&account_id) {
      token_set
    } else {
      return vec![];
    };
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    require!(limit != 0, "Cannot provide limit of 0.");
    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    require!(
            token_set.len() as u128 > start_index,
            "Out of bounds, please use a smaller from_index."
        );

    token_set
      .iter()
      .skip(start_index as usize)
      .take(limit)
      .map(|contract_token_id| self.enum_get_loan(&contract_token_id))
      .collect()
  }
}

impl LoanFactoryResolver for LoanFactory {
    fn loan_resolve_nft(&mut self, receiver_id: AccountId, contract_id: ContractId, token_id: TokenId, contract_token_id: TokenId, price: Balance, percent: u64) {
        let is_success = is_promise_success();

        if is_success {
          let loan_amount = U128::from(price  * ((100 - percent) as u128) / (100 as u128));
          let expire_date = date_now() + TIME_IN_WEEK;

          self.total_loan = U128::from(self.total_loan.0 + loan_amount.0);
          self.internal_increase_loan_nft(&contract_token_id, &loan_amount);
          self.internal_increase_loan_balance(&receiver_id, &loan_amount);
          self.internal_set_loan_expire_date(&contract_token_id, &expire_date);
          // self.owner_by_nft.insert(&contract_token_id, &receiver_id);
          self.price_by_nft.insert(&contract_token_id, &price);
          self.percent_by_nft.insert(&contract_token_id, &percent);

          Promise::new(receiver_id.clone())
            .transfer(loan_amount.0)
            .then(
              ext_self::on_transfer_resolve_nft(
                env::current_account_id(),
                loan_amount.clone(),
                receiver_id.clone(),
                contract_token_id.clone(),
                contract_id.clone(),
                token_id.clone(),
                expire_date.clone(),
                env::current_account_id(),
                0,
                CALLBACK_ON_RESOLVE_NFT,
              ));

          // LoanNft {
          //     owner_id: &receiver_id,
          //     contract_id: &contract_id,
          //     token_id: &token_id,
          //     expire_date: &expire_date,
          //     loan_amount: &loan_amount,
          //     price: &loan_amount,
          //   }.emit();
        } else {
          self.internal_remove_nft_owner(&receiver_id, &contract_token_id);
        }
    }

    fn loan_resolve_nft_claim(&mut self, receiver_id: AccountId, contract_id: ContractId, token_id: TokenId, contract_token_id: TokenId) {
        let is_success = is_promise_success();

        if is_success {
          self.internal_remove_nft_owner(&receiver_id, &contract_token_id);
          self.loan_date_by_nft.remove(&contract_token_id);
          self.price_by_nft.remove(&contract_token_id);
          self.percent_by_nft.remove(&contract_token_id);

          LoanNftClaim {
            receiver_id: &receiver_id,
            contract_id: &contract_id,
            token_id: &token_id
          }.emit();
        } else {
          // self.internal_remove_loan_owner(&receiver_id, &contract_token_id);
        }
    }
}

'''
'''--- loan/src/base/internal.rs ---
use near_sdk::collections::{LookupMap, UnorderedSet};
use std::collections::HashMap;
use near_sdk::{AccountId, env, IntoStorageKey, BorshStorageKey, ONE_YOCTO, Balance};
use near_sdk::json_types::U128;
use crate::base::{ContractId, TokenId, LoanFactory};
use crate::utils::date_now;
use crate::meta::JsonLoan;
use crate::base::base_impl::TIME_IN_WEEK;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
  TokensPerOwner { account_hash: Vec<u8> },
}

impl LoanFactory {
    pub(crate) fn assert_owner(&self) {
        assert_eq!(env::predecessor_account_id(), self.owner_id, "Unauthorized");
    }
    pub(crate) fn assert_loan_expired(&self, contract_token_id: &TokenId) {
        let expire_date = self.loan_date_by_nft.get(&contract_token_id).expect("Not found loan expire date");

        if expire_date >= date_now() {
            env::panic_str("Loan does not expired");
        }
    }
    pub(crate) fn assert_loan_not_expired(&self, contract_token_id: &TokenId) {
        let expire_date = self.loan_date_by_nft.get(&contract_token_id).expect("Not found loan expire date");

        if expire_date < date_now() {
            env::panic_str("Loan is expired");
        }
    }

    pub(crate) fn internal_get_token_id(&self, contract_id: &ContractId, token_id: &TokenId) -> TokenId {
        format!("{}||{}", contract_id.clone(), token_id.clone())
    }

    // loan balance

    pub(crate) fn internal_increase_loan_balance(&mut self, account_id: &AccountId, amount: &U128) {
        let current = self.loan_by_account.get(&account_id).unwrap_or_else(|| 0);
        let next = current + amount.0;

        self.loan_by_account.insert(&account_id, &next);
    }
    pub(crate) fn internal_decrease_loan_balance(&mut self, account_id: &AccountId, amount: &U128) {
        let current = self.loan_by_account.get(&account_id).unwrap_or_else(|| 0);

        if amount.0 > current {
            env::panic_str(&format!("No funds {} {}", amount.0.to_string(), current.to_string()));
        }

        let next = current - amount.0;

        self.loan_by_account.insert(&account_id, &next);
    }

    pub(crate) fn internal_balance_of_loan(&self, account_id: &AccountId) -> U128 {
        U128::from(self.loan_by_account.get(&account_id).unwrap_or_else(|| 0))
    }

    // loan nft

    pub(crate) fn internal_increase_loan_nft(&mut self, contract_token_id: &TokenId, amount: &U128) {
        let current = self.loan_by_nft.get(&contract_token_id).unwrap_or_else(|| 0);
        let next = current + amount.0;

        self.loan_by_nft.insert(&contract_token_id, &next);
    }
    pub(crate) fn internal_decrease_loan_nft(&mut self, contract_token_id: &TokenId, amount: &U128) {
        let current = self.loan_by_nft.get(&contract_token_id).unwrap_or_else(|| 0);

        if amount.0 > current {
            env::panic_str("No funds");
        }

        let next = current - amount.0;

        self.loan_by_nft.insert(&contract_token_id, &next);
    }

    pub(crate) fn internal_rest_of_loan(&self, contract_token_id: &TokenId) -> U128 {
        U128::from(self.loan_by_nft.get(&contract_token_id).unwrap_or_else(|| 0))
    }

    pub(crate) fn internal_set_nft_price(&mut self, contract_id: &ContractId, price: &Balance, percent: &u64) {
        self.price_by_contract.insert(&contract_id, &price);
        self.percent_by_contract.insert(&contract_id, &percent);
    }
    pub(crate) fn internal_set_loan_expire_date(&mut self, contract_token_id: &TokenId, date: &u64) {
        self.loan_date_by_nft.insert(&contract_token_id, &date);
    }

    pub(crate) fn enum_get_loan(&self, contract_token_id: &TokenId) -> JsonLoan {
      let owner_id = self.owner_by_nft.get(&contract_token_id).expect("Not found token owner");
      let loan = self.loan_by_nft.get(&contract_token_id).expect("Not found loan");
      let expire_date = self.loan_date_by_nft.get(&contract_token_id).unwrap_or_else(|| 0);
      let expired = expire_date < date_now();
      let arr = contract_token_id.split("||").collect::<Vec<&str>>();
      let started_at = if expire_date == 0 {
        0
      } else {
        expire_date - TIME_IN_WEEK
      };

      JsonLoan {
        token_id: arr[1].to_string(),
        contract_id: AccountId::new_unchecked(arr[0].to_string()),
        owner_id,
        price: U128::from(loan),
        started_at,
        expired_at: expire_date,
        expired,
      }
    }

    pub(crate) fn internal_set_nft_owner(&mut self, account_id: &AccountId, contract_token_id: &TokenId) {
      self.owner_by_nft.insert(&contract_token_id, &account_id);

      let mut receiver_tokens = self.nft_by_owner.get(&account_id).unwrap_or_else(|| {
        UnorderedSet::new(StorageKey::TokensPerOwner {
          account_hash: env::sha256(account_id.as_bytes()),
        })
      });
      receiver_tokens.insert(&contract_token_id);
      self.nft_by_owner.insert(&account_id, &receiver_tokens);
    }

    pub(crate) fn internal_remove_nft_owner(&mut self, account_id: &AccountId, contract_token_id: &TokenId) {
      self.owner_by_nft.remove(&contract_token_id);

      let mut owner_tokens = self.nft_by_owner.get(&account_id).unwrap_or_else(|| {
        env::panic_str("Unable to access tokens per owner in unguarded call.")
      });

      owner_tokens.remove(&contract_token_id);

      if owner_tokens.is_empty() {
        self.nft_by_owner.remove(&account_id);
      } else {
        self.nft_by_owner.insert(&account_id, &owner_tokens);
      }
    }
}

'''
'''--- loan/src/base/mod.rs ---
pub mod base_impl;
mod base;
mod internal;

pub use base_impl::{LoanFactory};
pub use base::{ContractId, TokenId};

pub use self::base::{LoanFactoryCore, LoanFactoryResolver};

'''
'''--- loan/src/event.rs ---
use near_sdk::{env, AccountId};
use serde::Serialize;
use near_sdk::json_types::U128;
use crate::base::TokenId;

// storage

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanFtDeposit<'a> {
  pub account_id: &'a AccountId,
  pub amount: &'a U128,
}

impl LoanFtDeposit<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanFtDeposit<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanFtDeposit(data)).emit()
  }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanFtWithdraw<'a> {
  pub account_id: &'a AccountId,
  pub amount: &'a U128,
}

impl LoanFtWithdraw<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanFtWithdraw<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanFtWithdraw(data)).emit()
  }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanFtClaimRewards<'a> {
  pub account_id: &'a AccountId,
  pub amount: &'a U128,
}

impl LoanFtClaimRewards<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanFtClaimRewards<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanFtClaimRewards(data)).emit()
  }
}

// whitelist

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanWhitelistAdd<'a> {
  pub contract_id: &'a AccountId,
}

impl LoanWhitelistAdd<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanWhitelistAdd<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanWhitelistAdd(data)).emit()
  }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanWhitelistRemove<'a> {
  pub contract_id: &'a AccountId,
}

impl LoanWhitelistRemove<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanWhitelistRemove<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanWhitelistRemove(data)).emit()
  }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanWhitelistUpdatePrice<'a> {
  pub contract_id: &'a AccountId,
  pub price: &'a U128,
  pub percent: &'a u64,
}

impl LoanWhitelistUpdatePrice<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanWhitelistUpdatePrice<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanWhitelistUpdatePrice(data)).emit()
  }
}

// base

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanNft<'a> {
  pub owner_id: &'a AccountId,
  pub contract_id: &'a AccountId,
  pub token_id: &'a TokenId,
  pub expire_date: &'a u64,
  pub loan_amount: &'a U128,
  pub price: &'a U128,
}

impl LoanNft<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanNft<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanNft(data)).emit()
  }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanNftPay<'a> {
  pub owner_id: &'a AccountId,
  pub contract_id: &'a AccountId,
  pub token_id: &'a TokenId,
  pub loan_amount: &'a U128,
}

impl LoanNftPay<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanNftPay<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanNftPay(data)).emit()
  }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanNftClaim<'a> {
  pub receiver_id: &'a AccountId,
  pub contract_id: &'a AccountId,
  pub token_id: &'a TokenId,
}

impl LoanNftClaim<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanNftClaim<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanNftClaim(data)).emit()
  }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct LoanNftClaimExpired<'a> {
  pub old_owner_id: &'a AccountId,
  pub contract_id: &'a AccountId,
  pub token_id: &'a TokenId,
}

impl LoanNftClaimExpired<'_> {
  pub fn emit(self) {
    Self::emit_many(&[self])
  }

  pub fn emit_many<'a>(data: &'a [LoanNftClaimExpired<'a>]) {
    new_loan_v1(NepLoanEventKind::LoanNftClaimExpired(data)).emit()
  }
}

//

#[derive(Serialize, Debug)]
pub(crate) struct NepLoanEvent<'a> {
  version: &'static str,
  #[serde(flatten)]
  event_kind: NepLoanEventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum NepLoanEventKind<'a> {
  LoanFtDeposit(&'a [LoanFtDeposit<'a>]),
  LoanFtWithdraw(&'a [LoanFtWithdraw<'a>]),
  LoanFtClaimRewards(&'a [LoanFtClaimRewards<'a>]),

  LoanWhitelistAdd(&'a [LoanWhitelistAdd<'a>]),
  LoanWhitelistRemove(&'a [LoanWhitelistRemove<'a>]),
  LoanWhitelistUpdatePrice(&'a [LoanWhitelistUpdatePrice<'a>]),

  LoanNft(&'a [LoanNft<'a>]),
  LoanNftPay(&'a [LoanNftPay<'a>]),
  LoanNftClaim(&'a [LoanNftClaim<'a>]),
  LoanNftClaimExpired(&'a [LoanNftClaimExpired<'a>]),
}

fn new_loan<'a>(version: &'static str, event_kind: NepLoanEventKind<'a>) -> NearEvent<'a> {
  NearEvent::NepLoan(NepLoanEvent { version, event_kind })
}

fn new_loan_v1(event_kind: NepLoanEventKind) -> NearEvent {
  new_loan("1.0.0", event_kind)
}

// base

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    // Nep171(crate::non_fungible_token::events::Nep171Event<'a>),
    // Nep141(crate::base::Nep141Event<'a>),
  NepLoan(NepLoanEvent<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

'''
'''--- loan/src/lib.rs ---
use near_sdk::{AccountId, Balance, env, log, near_bindgen, PanicOnDefault, PromiseOrValue, BorshStorageKey, assert_self, is_promise_success};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedSet, TreeMap};
use near_sdk::json_types::U128;use crate::base::LoanFactory;
use std::collections::HashMap;
use crate::utils::yton;
use crate::event::{LoanFtDeposit, LoanFtWithdraw, LoanFtClaimRewards, LoanNftPay, LoanNft};

mod event;
mod base;
mod macros;
mod nft_callback;
mod whitelist;
mod storage;
mod utils;
mod meta;

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
  BalanceByAccount,
  LoanBalanceByAccount,
  LoanByNft,
  NftContractOwner,
  PriceByNft,
  LoanDateByNft,
  ClaimDateByAccount,
  RewardByAccount,
  PercentByNft,
  NftByOwner,
  PriceByContract,
  PercentByContract,
  SharesByAccount,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  loan: LoanFactory,
}

#[near_bindgen]
impl Contract {
  /// Initializes the contract with the given total supply owned by the given `owner_id` with
  /// default metadata (for example purposes only).
  #[init]
  pub fn new_default_meta(owner_id: AccountId) -> Self {
    Self::new(
      owner_id,
    )
  }

  /// Initializes the contract with the given total supply owned by the given `owner_id` with
  /// the given fungible token metadata.
  #[init]
  pub fn new(
    owner_id: AccountId,
  ) -> Self {
    assert!(!env::state_exists(), "Already initialized");

    let mut this = Self {
      loan: LoanFactory::new(
        owner_id,
        9,
        StorageKey::BalanceByAccount,
        StorageKey::LoanBalanceByAccount,
        StorageKey::LoanByNft,
        StorageKey::NftContractOwner,
        StorageKey::PriceByNft,
        StorageKey::LoanDateByNft,
        StorageKey::ClaimDateByAccount,
        StorageKey::RewardByAccount,
        StorageKey::PercentByNft,
        StorageKey::NftByOwner,
        StorageKey::PercentByContract,
        StorageKey::PriceByContract,
        StorageKey::SharesByAccount,
      ),
    };

    this
  }

    #[init(ignore_state)]
    #[private]
    pub fn migrate() -> Self {
        #[derive(BorshDeserialize, BorshSerialize)]
        pub struct OldLoan {
          pub total_balance: U128,
          pub total_rewards_pool: U128,
          pub total_shares: U128,
          pub total_loan: U128,
          pub commission: u128,
          pub accounts: TreeMap<AccountId, Balance>,
          pub loan_by_nft: LookupMap<TokenId, Balance>,

          pub price_by_nft: LookupMap<TokenId, Balance>,
          pub percent_by_nft: LookupMap<TokenId, u64>,

          pub loan_by_account: LookupMap<AccountId, Balance>,
          pub loan_date_by_nft: TreeMap<TokenId, u64>,
          pub nft_by_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

          pub owner_by_nft: LookupMap<TokenId, AccountId>,

          pub price_by_contract: LookupMap<ContractId, Balance>,
          pub percent_by_contract: LookupMap<ContractId, u64>,
          pub shares_by_account: LookupMap<AccountId, U128>,

          pub claim_date_by_account: LookupMap<AccountId, u64>,
          pub reward_by_account: LookupMap<AccountId, U128>,

          pub whitelist: HashMap<ContractId, bool>,

          pub owner_id: AccountId,
        }
        #[derive(BorshDeserialize)]
        struct Old {
            loan: OldLoan,
        }

        let old: Old = env::state_read().expect("Error");

        let loan = LoanFactory {
          total_shares: U128::from(0),
            commission: old.loan.commission,
            total_rewards_pool: old.loan.total_rewards_pool,
            total_loan: old.loan.total_loan,
            total_balance: old.loan.total_balance,
            accounts: old.loan.accounts,
            loan_by_nft: old.loan.loan_by_nft,
            loan_by_account: old.loan.loan_by_account,
            owner_by_nft: old.loan.owner_by_nft,
            whitelist: old.loan.whitelist,
            owner_id: old.loan.owner_id,
            price_by_contract: old.loan.price_by_contract,
            percent_by_contract: old.loan.percent_by_contract,
            price_by_nft: old.loan.price_by_nft,
            percent_by_nft: old.loan.percent_by_nft,
            shares_by_account: LookupMap::new(StorageKey::SharesByAccount),
            loan_date_by_nft: old.loan.loan_date_by_nft,
            claim_date_by_account: old.loan.claim_date_by_account,
            reward_by_account: old.loan.reward_by_account,
            nft_by_owner: old.loan.nft_by_owner,
        };

        Self {
            loan
        }
    }

  pub fn on_transfer_nft_pay(&mut self, account_id: AccountId, amount_sent: U128, fee: U128, recipient: AccountId, contract_token_id: TokenId, contract_id: AccountId, token_id: TokenId) {
    assert_self();

    let transfer_succeeded = is_promise_success();

    if transfer_succeeded {
      LoanNftPay {
        owner_id: &account_id,
        contract_id: &contract_id,
        token_id: &token_id,
        loan_amount: &U128::from(amount_sent.0),
      }.emit();
    }

    if !transfer_succeeded {
      env::log_str(&format!("Transaction to @{} failed. {} yNEAR (~{} NEAR) kept on the app deposit", recipient, amount_sent.0, yton(amount_sent.0)));

      self.loan.internal_increase_loan_nft(&contract_token_id, &amount_sent);
      self.loan.internal_increase_loan_balance(&account_id, &amount_sent);
      self.loan.total_loan = U128::from(self.loan.total_loan.0 - amount_sent.0);
      self.loan.total_rewards_pool = U128::from(self.loan.total_rewards_pool.0 - fee.0);
    }
  }

  pub fn on_transfer_resolve_nft(&mut self, account_id: AccountId, amount_sent: U128, recipient: AccountId, contract_token_id: TokenId, contract_id: AccountId, token_id: TokenId, expire_date: u64) {
    assert_self();

    let transfer_succeeded = is_promise_success();

    if transfer_succeeded {
      LoanNft {
        owner_id: &recipient,
        contract_id: &contract_id,
        token_id: &token_id,
        expire_date: &expire_date,
        loan_amount: &amount_sent,
        price: &amount_sent,
      }.emit();
    }

    if !transfer_succeeded {
      env::log_str(&format!("Transaction to @{} failed. {} yNEAR (~{} NEAR) kept on the app deposit", recipient, amount_sent.0, yton(amount_sent.0)));

      self.loan.total_loan = U128::from(self.loan.total_loan.0 - amount_sent.0);
      self.loan.internal_decrease_loan_nft(&contract_token_id, &amount_sent);
      self.loan.internal_decrease_loan_balance(&recipient, &amount_sent);
      self.loan.loan_date_by_nft.remove(&contract_token_id);
      // self.owner_by_nft.insert(&contract_token_id, &receiver_id);
      self.loan.price_by_nft.remove(&contract_token_id);
      self.loan.percent_by_nft.remove(&contract_token_id);
    }
  }

  pub fn on_transfer_loan_deposit(&mut self, account_id: AccountId, amount_sent: U128, recipient: AccountId) {
    assert_self();

    let transfer_succeeded = is_promise_success();

    if transfer_succeeded {
      LoanFtDeposit {
        account_id: &account_id,
        amount: &U128(amount_sent.0),
      }.emit();
    }

    if !transfer_succeeded {
      env::log_str(&format!("Transaction to @{} failed. {} yNEAR (~{} NEAR) kept on the app deposit", recipient, amount_sent.0, yton(amount_sent.0)));
      self.loan.internal_decrease_balance(&recipient, &amount_sent);
    }
  }

  pub fn on_transfer_loan_withdraw(&mut self, account_id: AccountId, amount_sent: U128, recipient: AccountId) {
    assert_self();

    let transfer_succeeded = is_promise_success();

    if transfer_succeeded {
      LoanFtWithdraw {
        account_id: &account_id,
        amount: &amount_sent,
      }.emit();
    }

    if !transfer_succeeded {
      env::log_str(&format!("Transaction to @{} failed. {} yNEAR (~{} NEAR) kept on the app deposit", recipient, amount_sent.0, yton(amount_sent.0)));
      self.loan.internal_increase_balance(&recipient, &amount_sent);
    }
  }

  pub fn on_transfer_claim_rewards(&mut self, account_id: AccountId, amount_sent: U128, recipient: AccountId) {
    assert_self();

    let transfer_succeeded = is_promise_success();

    if transfer_succeeded {
      LoanFtClaimRewards {
        account_id: &account_id,
        amount: &amount_sent,
      }.emit();
    }

    if !transfer_succeeded {
      env::log_str(&format!("Transaction to @{} failed. {} yNEAR (~{} NEAR) kept on the app deposit", recipient, amount_sent.0, yton(amount_sent.0)));
      self.loan.reward_by_account.insert(&recipient, &amount_sent);
      self.loan.total_rewards_pool = U128::from(self.loan.total_rewards_pool.0 - amount_sent.0);
    }
  }
}

// macros

impl_loan_core!(Contract, loan);
impl_loan_storage!(Contract, loan);
impl_loan_whitelist!(Contract, loan);

'''
'''--- loan/src/macros.rs ---
/// The core methods for a basic fungible token. Extension standards may be
/// added in addition to this macro.
#[macro_export]
macro_rules! impl_loan_core {
    ($contract: ident, $token: ident) => {
        use $crate::base::{LoanFactoryCore, LoanFactoryResolver};
        use $crate::base::{ContractId, TokenId};
        use $crate::meta::{JsonLoan};

        #[near_bindgen]
        impl LoanFactoryCore for $contract {
            fn loan_balance_borrowed_of(&self, account_id: AccountId) -> U128 {
                self.$token.loan_balance_borrowed_of(account_id)
            }

            #[payable]
            fn loan_nft(&mut self, token_id: TokenId, contract_id: ContractId) {
                self.$token.loan_nft(token_id, contract_id)
            }

            fn loan_owner_by_id(&self, token_id: TokenId, contract_id: ContractId) -> AccountId {
                self.$token.loan_owner_by_id(token_id, contract_id)
            }

            fn loan_rest_by_id(&self, token_id: TokenId, contract_id: ContractId) -> U128 {
                self.$token.loan_rest_by_id(token_id, contract_id)
            }

            #[payable]
            fn loan_nft_pay(&mut self, token_id: TokenId, contract_id: ContractId) {
                self.$token.loan_nft_pay(token_id, contract_id)
            }

            fn loan_nft_claim(&mut self, token_id: TokenId, contract_id: ContractId) {
                self.$token.loan_nft_claim(token_id, contract_id)
            }

            fn loan_update_nft_price(&mut self, contract_id: ContractId, price: U128, percent: u64) {
                self.$token.loan_update_nft_price(contract_id, price, percent)
            }
            fn loan_nft_price(&self, contract_id: ContractId) -> Vec<U128> {
                self.$token.loan_nft_price(contract_id)
            }
            fn loan_nft_claim_expired(&mut self, token_id: TokenId, contract_id: ContractId) {
                self.$token.loan_nft_claim_expired(token_id, contract_id)
            }

            fn loan_nft_by_id(&self, token_id: TokenId, contract_id: ContractId) -> JsonLoan {
                self.$token.loan_nft_by_id(token_id, contract_id)
            }
            fn loan_nft_by_owner(&self, account_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonLoan> {
                self.$token.loan_nft_by_owner(account_id, from_index, limit)
            }

             fn loan_total_nft(&self) -> u128 {
                self.$token.loan_total_nft()
            }
            fn loan_commission(&self) -> u128 {
                self.$token.loan_commission()
            }
        }

        #[near_bindgen]
        impl LoanFactoryResolver for $contract {
            fn loan_resolve_nft(&mut self, receiver_id: AccountId, contract_id: ContractId, token_id: TokenId, contract_token_id: TokenId, price: Balance, percent: u64) {
                self.$token.loan_resolve_nft(receiver_id, contract_id, token_id, contract_token_id, price, percent)
            }
            fn loan_resolve_nft_claim(&mut self, receiver_id: AccountId, contract_id: ContractId, token_id: TokenId, contract_token_id: TokenId) {
                self.$token.loan_resolve_nft_claim(receiver_id, contract_id, token_id, contract_token_id)
            }
        }
    };
}

/// The core methods for a basic fungible token. Extension standards may be
/// added in addition to this macro.
#[macro_export]
macro_rules! impl_loan_whitelist {
    ($contract: ident, $token: ident) => {
        use $crate::whitelist::{LoanFactoryWhitelist};

        #[near_bindgen]
        impl LoanFactoryWhitelist for $contract {
            #[payable]
            fn loan_nft_whitelist_add(&mut self, contract_id: ContractId) {
                self.$token.loan_nft_whitelist_add(contract_id)
            }
            #[payable]
            fn loan_nft_whitelist_remove(&mut self, contract_id: ContractId) {
                self.$token.loan_nft_whitelist_remove(contract_id)
            }

            fn loan_nft_whitelist(&self) -> Vec<ContractId> {
                self.$token.loan_nft_whitelist()
            }
            fn loan_nft_is_whitelist(&self, contract_id: ContractId) -> bool {
                self.$token.loan_nft_is_whitelist(contract_id)
            }
        }
    };
}

/// The core methods for a basic fungible token. Extension standards may be
/// added in addition to this macro.
#[macro_export]
macro_rules! impl_loan_storage {
    ($contract: ident, $token: ident) => {
        use $crate::storage::{LoanFactoryStorage};

        #[near_bindgen]
        impl LoanFactoryStorage for $contract {
            #[payable]
            fn loan_deposit(&mut self) -> U128 {
                self.$token.loan_deposit()
            }
            fn loan_withdraw(&mut self, amount: U128) -> U128 {
                self.$token.loan_withdraw(amount)
            }
            fn loan_withdraw_all(&mut self) -> U128 {
                self.$token.loan_withdraw_all()
            }
            fn loan_balance_of(&self, account_id: AccountId) -> U128 {
                self.$token.loan_balance_of(account_id)
            }
            fn loan_shares_of(&self, account_id: AccountId) -> U128 {
                self.$token.loan_shares_of(account_id)
            }
            fn loan_reward_of(&self, account_id: AccountId) -> U128 {
                self.$token.loan_reward_of(account_id)
            }
            fn loan_reward_unclaimed_of(&self, account_id: AccountId) -> U128 {
                self.$token.loan_reward_unclaimed_of(account_id)
            }
            fn loan_reward_claimed_of(&self, account_id: AccountId) -> U128 {
                self.$token.loan_reward_claimed_of(account_id)
            }
             fn loan_claim_rewards(&mut self) -> U128 {
                self.$token.loan_claim_rewards()
            }
            fn loan_total_balance(&self) -> U128 {
              self.$token.loan_total_balance()
            }
             fn loan_total_shares(&self) -> U128 {
              self.$token.loan_total_shares()
            }
            fn loan_total_rewards_pool(&self) -> U128 {
              self.$token.loan_total_rewards_pool()
            }
            fn loan_available_balance(&self) -> U128 {
              self.$token.loan_available_balance()
            }
            fn loan_total_loan(&self) -> U128 {
              self.$token.loan_total_loan()
            }
        }
    };
}

'''
'''--- loan/src/meta.rs ---
use crate::base::{TokenId, ContractId};
use near_sdk::AccountId;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::U128;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonLoan {
  pub token_id: TokenId,
  pub contract_id: ContractId,
  pub owner_id: AccountId,
  pub started_at: u64,
  pub expired_at: u64,
  pub price: U128,
  pub expired: bool,
}

'''
'''--- loan/src/nft_callback.rs ---
use crate::*;
use near_sdk::env;
use near_sdk::serde::{Deserialize, Serialize};
use crate::base::TokenId;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleArgs {
    pub price_per_hour: U128,
    pub min_time: u64,
    pub max_time: u64,
}

trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();
        assert_ne!(
            nft_contract_id,
            signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        assert_eq!(
            &owner_id,
            &signer_id,
            "owner_id should be signer_id"
        );

      self.loan_nft(token_id, nft_contract_id);
        //
    }
}

'''
'''--- loan/src/storage/internal.rs ---

use crate::base::LoanFactory;
use near_sdk::{AccountId, env};
use near_sdk::json_types::U128;

impl LoanFactory {
  pub(crate) fn assert_available_balance(&self, amount: &U128) {
    let available_balance = self.internal_available_balance();

    if available_balance.0 < amount.0 {
      env::panic_str(&"Not found available fund");
    }
  }

  pub(crate) fn assert_available_rewards(&self, amount: &U128) {
    let available_balance = self.total_rewards_pool;

    if available_balance.0 < amount.0 {
      env::panic_str(&"Not found available fund for rewards");
    }
  }

  // storage
  pub(crate) fn internal_balance_of(&self, account_id: &AccountId) -> U128 {
      U128::from(self.accounts.get(&account_id).unwrap_or_else(|| 0))
  }
  pub(crate) fn internal_increase_balance(&mut self, account_id: &AccountId, amount: &U128) {
    let current = self.accounts.get(&account_id).unwrap_or_else(|| 0);
    let next = current + amount.0;
    let num_shares = if self.total_balance.0 == 0 {
      U128::from(100)
    } else {
      U128::from(self.total_shares.0 * amount.0 / self.total_balance.0)
    };
    let current_shares = self.shares_by_account.get(&account_id).unwrap_or_else(|| U128::from(0));
    let new_shares = U128::from(num_shares.0 + current_shares.0);

    self.accounts.insert(&account_id, &next);
    self.total_balance = U128::from(self.total_balance.0 + amount.0);

    self.total_shares = U128::from(self.total_shares.0 + num_shares.0);
    self.shares_by_account.insert(&account_id, &new_shares);
  }
  pub(crate) fn internal_decrease_balance(&mut self, account_id: &AccountId, amount: &U128) {
    let current = self.accounts.get(&account_id).unwrap_or_else(|| 0);
    let num_shares = U128::from(self.total_shares.0 * amount.0 / self.total_balance.0);
    let current_shares = self.shares_by_account.get(&account_id).unwrap_or_else(|| U128::from(0));
    let new_shares = U128::from(num_shares.0 - current_shares.0);

    if amount.0 > current {
        env::panic_str("No funds");
    }

    let next = current - amount.0;

    self.accounts.insert(&account_id, &next);
    self.total_balance = U128::from(self.total_balance.0 - amount.0);

    self.total_shares = U128::from(self.total_shares.0 - num_shares.0);
    self.shares_by_account.insert(&account_id, &new_shares);
  }
  pub(crate) fn internal_reward_claimed_of(&self, account_id: &AccountId) -> U128 {
      self.reward_by_account.get(&account_id).unwrap_or_else(|| U128::from(0))
  }
  pub(crate) fn internal_reward_unclaimed_of(&self, account_id: &AccountId) -> U128 {
      let now = env::block_timestamp();
      let claim_date = self.claim_date_by_account.get(&account_id);

    if let Some(num_shares) = self.shares_by_account.get(&account_id) {
      if let Some(claim_date) = claim_date {
        let time_diff = u128::from(now - claim_date);

        if time_diff > 0 {
          let balance = self.internal_balance_of(&account_id);

          if balance.0 == 0 {
            return U128::from(0);
          }

          let total_shares = self.total_shares.0;
          let total_rewards = self.total_rewards_pool.0;
          let rewards = total_rewards * num_shares.0 / total_shares;

          let max_rewards = balance.0 * 28 / 100 / 31536000000000000 * time_diff;

          if rewards > max_rewards {
            return U128::from(max_rewards);
          }

          return U128::from(rewards);
        }
      }
    }

     U128::from(0)
  }
  pub(crate) fn internal_temp_claim(&mut self, account_id: &AccountId) {
      let add_rewards = self.internal_reward_unclaimed_of(&account_id);
      self.claim_date_by_account.insert(&account_id, &env::block_timestamp());

      let prev_rewards = self.reward_by_account.get(&account_id).unwrap_or_else(|| U128::from(0));
      let next_rewards = U128::from(prev_rewards.0 + add_rewards.0);

      self.reward_by_account.insert(&account_id,&next_rewards);
  }
  pub(crate) fn internal_available_balance(&self) -> U128 {
    U128::from(self.total_balance.0 - self.total_loan.0)
  }
}

'''
'''--- loan/src/storage/mod.rs ---
mod storage;
mod storage_impl;
mod internal;

pub use self::storage::{LoanFactoryStorage};

'''
'''--- loan/src/storage/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::AccountId;

pub trait LoanFactoryStorage {
  fn loan_deposit(&mut self) -> U128;
  fn loan_withdraw(&mut self, amount: U128) -> U128;
  fn loan_withdraw_all(&mut self) -> U128;
  fn loan_claim_rewards(&mut self) -> U128;

  fn loan_balance_of(&self, account_id: AccountId) -> U128;
  fn loan_total_balance(&self) -> U128;
  fn loan_total_loan(&self) -> U128;
  fn loan_total_shares(&self) -> U128;
  fn loan_total_rewards_pool(&self) -> U128;
  fn loan_available_balance(&self) -> U128;
  fn loan_reward_of(&self, account_id: AccountId) -> U128;
  fn loan_shares_of(&self, account_id: AccountId) -> U128;
  fn loan_reward_claimed_of(&self, account_id: AccountId) -> U128;
  fn loan_reward_unclaimed_of(&self, account_id: AccountId) -> U128;
}

'''
'''--- loan/src/storage/storage_impl.rs ---
use crate::base::LoanFactory;
use crate::storage::LoanFactoryStorage;
use near_sdk::json_types::U128;
use near_sdk::{AccountId, env, Promise, Gas, ext_contract};
use crate::utils::method_disabled;
use crate::event::{LoanFtDeposit, LoanFtWithdraw, LoanFtClaimRewards};

pub const CALLBACK_ON_DEPOSIT: Gas = Gas(50_000_000_000_000);

#[ext_contract(ext_self)]
pub trait ExtSelf {
  fn on_transfer_loan_deposit(&mut self, account_id: AccountId, amount_sent: U128, recipient: AccountId);
  fn on_transfer_loan_withdraw(&mut self, account_id: AccountId, amount_sent: U128, recipient: AccountId);
  fn on_transfer_claim_rewards(&mut self, account_id: AccountId, amount_sent: U128, recipient: AccountId);
}

impl LoanFactoryStorage for LoanFactory {
    fn loan_deposit(&mut self) -> U128 {
        let account_id = env::predecessor_account_id();
        let balance = env::attached_deposit();

        self.internal_temp_claim(&account_id);

        self.internal_increase_balance(&account_id, &U128::from(balance));

        Promise::new(env::current_account_id())
          .transfer(balance)
          .then(
            ext_self::on_transfer_loan_deposit(
              env::predecessor_account_id(),
              U128::from(balance),
              env::current_account_id(),
              env::current_account_id(),
              0,
              CALLBACK_ON_DEPOSIT,
            )
          );

        // LoanFtDeposit {
        //   account_id: &account_id,
        //   amount: &U128(balance),
        // }.emit();

        self.internal_balance_of(&account_id)
    }
    fn loan_withdraw(&mut self, amount: U128) -> U128 {
      let account_id = env::predecessor_account_id();

      self.assert_available_balance(&amount);

      self.internal_temp_claim(&account_id);
      // self.loan_claim_rewards();

      self.internal_decrease_balance(&account_id, &amount);
      Promise::new(account_id.clone())
        .transfer(amount.0)
        .then(
          ext_self::on_transfer_loan_withdraw(
            env::current_account_id(),
            amount.clone(),
            account_id.clone(),
            env::current_account_id(),
            0,
            CALLBACK_ON_DEPOSIT,
          )
        );

      // LoanFtWithdraw {
      //   account_id: &account_id,
      //   amount: &amount,
      // }.emit();

      amount
    }
    fn loan_withdraw_all(&mut self) -> U128 {
      let account_id = env::predecessor_account_id();
      let balance = self.internal_balance_of(&account_id);

      self.loan_withdraw(balance)
    }
  fn loan_claim_rewards(&mut self) -> U128 {
    let account_id = env::predecessor_account_id();

    self.internal_temp_claim(&account_id);

    let amount = self.loan_reward_of(account_id.clone());

    self.assert_available_rewards(&amount);

    self.reward_by_account.insert(&account_id, &U128::from(0));
    self.total_rewards_pool = U128::from(self.total_rewards_pool.0 - amount.0);

    Promise::new(account_id.clone())
      .transfer(amount.0)
      .then(
      ext_self::on_transfer_claim_rewards(
        env::current_account_id(),
        amount.clone(),
        account_id.clone(),
        env::current_account_id(),
        0,
        CALLBACK_ON_DEPOSIT,
      )
    );

    // LoanFtClaimRewards {
    //   account_id: &account_id,
    //   amount: &amount,
    // }.emit();

    amount
  }

  fn loan_balance_of(&self, account_id: AccountId) -> U128 {
      self.internal_balance_of(&account_id)
  }

  fn loan_total_balance(&self) -> U128 {
    self.total_balance
  }

  fn loan_total_loan(&self) -> U128 {
     self.total_loan
  }

  fn loan_total_shares(&self) -> U128 {
    self.total_shares
  }

  fn loan_total_rewards_pool(&self) -> U128 {
    self.total_rewards_pool
  }

  fn loan_available_balance(&self) -> U128 {
    self.internal_available_balance()
  }

  fn loan_reward_of(&self, account_id: AccountId) -> U128 {
      let unclaimed = self.internal_reward_unclaimed_of(&account_id);
      let claimed = self.internal_reward_claimed_of(&account_id);

      U128::from(unclaimed.0 + claimed.0)
  }

  fn loan_shares_of(&self, account_id: AccountId) -> U128 {
    self.shares_by_account.get(&account_id).unwrap_or_else(|| U128::from(0))
  }

  fn loan_reward_claimed_of(&self, account_id: AccountId) -> U128 {
      self.internal_reward_claimed_of(&account_id)
  }

  fn loan_reward_unclaimed_of(&self, account_id: AccountId) -> U128 {
     self.internal_reward_unclaimed_of(&account_id)
  }
}

'''
'''--- loan/src/utils.rs ---
use near_sdk::{env, Balance};

pub(crate) fn date_now() -> u64 {
    env::block_timestamp() / 1000000
}
pub(crate) fn method_disabled() {
  env::panic_str("Method disabled");
}
pub fn yton(yocto_amount: Balance) -> Balance {
  (yocto_amount + (5 * 10u128.pow(23))) / 10u128.pow(24)
}

'''
'''--- loan/src/whitelist/internal.rs ---
use crate::base::{ContractId, LoanFactory};
use near_sdk::env;

impl LoanFactory {
    pub(crate) fn assert_nft_whitelist(&self, contract_id: &ContractId) {
        let is_contain = self.internal_is_nft_whitelist(&contract_id);

        if is_contain != true {
            env::panic_str("Nft not allowed");
        }
    }
    pub(crate) fn internal_is_nft_whitelist(&self, contract_id: &ContractId) -> bool {
      let exists = self.whitelist.contains_key(contract_id);
      let price = self.price_by_contract.get(&contract_id).is_some();
      let percent = self.percent_by_contract.get(&contract_id).is_some();

      exists && price && percent
    }
}

'''
'''--- loan/src/whitelist/mod.rs ---
mod whitelist_impl;
mod whitelist;
mod internal;

pub use self::whitelist::{ LoanFactoryWhitelist };

'''
'''--- loan/src/whitelist/whitelist.rs ---
use crate::base::ContractId;

pub trait LoanFactoryWhitelist {
    fn loan_nft_whitelist_add(&mut self, contract_id: ContractId);
    fn loan_nft_whitelist_remove(&mut self, contract_id: ContractId);
    fn loan_nft_whitelist(&self) -> Vec<ContractId>;
    fn loan_nft_is_whitelist(&self, contract_id: ContractId) -> bool;
}

'''
'''--- loan/src/whitelist/whitelist_impl.rs ---
use crate::base::{LoanFactory, ContractId};
use crate::whitelist::LoanFactoryWhitelist;
use near_sdk::env;
use crate::event::{LoanWhitelistAdd, LoanWhitelistRemove};

impl LoanFactoryWhitelist for LoanFactory {
    fn loan_nft_whitelist_add(&mut self, contract_id: ContractId) {
        self.assert_owner();
        // let price = self.price_by_contract.get(&contract_id).is_some();

        // if !price {
        //     env::panic_str("Please setup price first");
        // }
        // let percent = self.percent_by_contract.get(&contract_id).is_some();
        //
        // if !percent {
        //     env::panic_str("Please setup percent first");
        // }

        self.whitelist.insert(contract_id.clone(), true);

        LoanWhitelistAdd {
          contract_id: &contract_id,
        }.emit();
    }
    fn loan_nft_whitelist_remove(&mut self, contract_id: ContractId) {
        self.assert_owner();
        self.whitelist.remove(&contract_id);
        self.price_by_contract.remove(&contract_id);
        self.percent_by_contract.remove(&contract_id);

      LoanWhitelistRemove {
        contract_id: &contract_id,
      }.emit();
    }
    fn loan_nft_whitelist(&self) -> Vec<ContractId> {
        self.whitelist
            .iter()
            .filter(|el | {
              self.internal_is_nft_whitelist(el.0)
            })
            .map(|key| key.0.clone())
            .collect()
    }
    fn loan_nft_is_whitelist(&self, contract_id: ContractId) -> bool {
        self.internal_is_nft_whitelist(&contract_id)
    }
}

'''
'''--- nft/Cargo.toml ---
[package]
name = "nft"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

'''
'''--- nft/scripts/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
source flags.sh
cargo build --all --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/*.wasm ../res/

'''
'''--- nft/scripts/deploy.sh ---
sh build.sh \
&& near deploy --accountId mfight-nft_v1.testnet --wasmFile ../res/nft.wasm --helperUrl https://near-contract-helper.onrender.com

'''
'''--- nft/scripts/dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

sh ./build.sh

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# comment out the line below to deploy the other example contract
near dev-deploy ../res/nft.wasm

# uncomment the line below to deploy the other example contract
# near dev-deploy ./build/release/singleton.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- nft/scripts/dev-init.sh ---
#!/bin/bash
source neardev/dev-account.env
OWNER_ID="$CONTRACT_NAME"
near call $CONTRACT_NAME new_default_meta --accountId $CONTRACT_NAME "{ \"owner_id\": \"$OWNER_ID\" }"

'''
'''--- nft/scripts/dev-paras.sh ---
#!/bin/bash
source neardev/dev-account.env

TOKEN_ID="11"
ACCOUNT_ID="muzikant.testnet"
PARAS_CONTRACT="paras-marketplace-v1.testnet"

near call $PARAS_CONTRACT storage_deposit "{\"accountId\":\"$CONTRACT_NAME\"}" --accountId $CONTRACT_NAME --depositYocto 8590000000000000000000
near call $CONTRACT_NAME nft_approve --accountId $ACCOUNT_ID "{ \"token_id\": \"$TOKEN_ID\", \"account_id\": \"$PARAS_CONTRACT\",\"msg\": \"{\\\"market_type\\\":\\\"sale\\\",\\\"price\\\":\\\"1000000000000000000000000\\\",\\\"ft_token_id\\\":\\\"near\\\"}\" }" --depositYocto 400000000000000000000

#near call paras-marketplace-v1.testnet storage_withdraw "{\"amount\":\"8590000000000000000000\"}" --accountId $CONTRACT_NAME --depositYocto 1

'''
'''--- nft/scripts/flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- nft/scripts/init.sh ---
near call "mfight-nft_v1.testnet" new_with_default_meta --accountId "mfight-nft_v1.testnet" "{ \"owner_id\": \"mfight-nft_v1.testnet\" }"

'''
'''--- nft/scripts/neardev/dev-account.env ---
CONTRACT_NAME=dev-1648577859565-13862973208014
LOAN_CONTRACT=dev-1653750482708-69295012022419

'''
'''--- nft/scripts/nft_approve.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
TOKEN_ID="4"
near call $CONTRACT_NAME nft_approve --accountId $ACCOUNT_ID "{ \"token_id\": \"$TOKEN_ID\", \"account_id\": \"$LOAN_CONTRACT\", \"msg\": \"1\" }" --amount "0.1" --gas 300000000000000

'''
'''--- nft/scripts/nft_metadata.sh ---
#!/bin/bash
source neardev/dev-account.env
CONTRACT_NAME="tiger7.testnet"
near view $CONTRACT_NAME nft_metadata "{ }"

'''
'''--- nft/scripts/nft_mint.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
TOKEN_ID="11"
near call $CONTRACT_NAME nft_mint --accountId $CONTRACT_NAME "{ \"token_id\": \"$TOKEN_ID\", \"token_metadata\": { \"title\": \"Token$TOKEN_ID\", \"media\": \"https://images.mfight.io/nft/1082.png\"}, \"token_owner_id\": \"$ACCOUNT_ID\" }" --amount "0.1" --gas 300000000000000

'''
'''--- nft/scripts/nft_revoke_all.sh ---
#!/bin/bash
source neardev/dev-account.env
TOKEN_ID="1"
ACCOUNT_ID="muzikant.testnet"
near call $CONTRACT_NAME nft_revoke_all --accountId $ACCOUNT_ID "{ \"token_id\": \"$TOKEN_ID\" }" --amount "0.1" --gas 300000000000000

'''
'''--- nft/scripts/nft_supply_for_owner.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME nft_supply_for_owner "{ \"account_id\": \"$ACCOUNT_ID\" }"

'''
'''--- nft/scripts/nft_token.sh ---
#!/bin/bash
source neardev/dev-account.env
#CONTRACT_NAME="tiger7.testnet"
TOKEN_ID="11"
near view $CONTRACT_NAME nft_token "{ \"token_id\": \"$TOKEN_ID\" }"

'''
'''--- nft/scripts/nft_tokens.sh ---
#!/bin/bash
source neardev/dev-account.env
near view $CONTRACT_NAME nft_tokens "{ \"limit\": 1, \"from_index\": \"0\" }"

'''
'''--- nft/scripts/nft_tokens_for_owner.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="muzikant.testnet"
near view $CONTRACT_NAME nft_tokens_for_owner "{ \"account_id\": \"$ACCOUNT_ID\" }"

'''
'''--- nft/scripts/nft_total_supply.sh ---
#!/bin/bash
source neardev/dev-account.env
near view $CONTRACT_NAME nft_total_supply "{ }"

'''
'''--- nft/scripts/nft_transfer.sh ---
#!/bin/bash
source neardev/dev-account.env
ACCOUNT_ID="nft_tests.testnet"
RECEIVER_ID="muzikant.testnet"
TOKEN_ID="1689"

near call $CONTRACT_NAME nft_transfer --accountId $ACCOUNT_ID "{ \"token_id\": \"$TOKEN_ID\", \"receiver_id\":\"$RECEIVER_ID\" }" --depositYocto 1

'''
'''--- nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
  NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::{
  env, near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  tokens: NonFungibleToken,
  metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
  NonFungibleToken,
  Metadata,
  TokenMetadata,
  Enumeration,
  Approval,
}

#[near_bindgen]
impl Contract {
  /// Initializes the contract owned by `owner_id` with
  /// default metadata (for example purposes only).
  #[init]
  pub fn new_default_meta(owner_id: AccountId) -> Self {
    Self::new(
      owner_id,
      NFTContractMetadata {
        spec: NFT_METADATA_SPEC.to_string(),
        name: "Example NEAR non-fungible token".to_string(),
        symbol: "EXAMPLE".to_string(),
        icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
        base_uri: None,
        reference: None,
        reference_hash: None,
      },
    )
  }

  #[init]
  pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
    require!(!env::state_exists(), "Already initialized");
    metadata.assert_valid();
    Self {
      tokens: NonFungibleToken::new(
        StorageKey::NonFungibleToken,
        owner_id,
        Some(StorageKey::TokenMetadata),
        Some(StorageKey::Enumeration),
        Some(StorageKey::Approval),
      ),
      metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
    }
  }

  /// Mint a new token with ID=`token_id` belonging to `token_owner_id`.
  ///
  /// Since this example implements metadata, it also requires per-token metadata to be provided
  /// in this call. `self.tokens.mint` will also require it to be Some, since
  /// `StorageKey::TokenMetadata` was provided at initialization.
  ///
  /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
  /// initialization call to `new`.
  #[payable]
  pub fn nft_mint(
    &mut self,
    token_id: TokenId,
    token_owner_id: AccountId,
    token_metadata: TokenMetadata,
  ) -> Token {
    assert_eq!(env::predecessor_account_id(), self.tokens.owner_id, "Unauthorized");
    self.tokens.internal_mint(token_id, token_owner_id, Some(token_metadata))
  }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
  fn nft_metadata(&self) -> NFTContractMetadata {
    self.metadata.get().unwrap()
  }
}

'''