*GitHub Repository "Igor-Koniukhov/app-for-certification"*

'''--- .env ---
ACCOUNT=ikon-examenator.testnet
'''
'''--- .gitpod.yml ---
tasks:
  - init: yarn
    command: yarn dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
app-for-certification
==================

- This [React] app was initialized with [create-near-app].
- The application for passing tests or exams and in a case, you succeed you get certificate which you could print in PDF
  format or mint and get your certificate with information about your results as NFT.

Quick Start
===========

To run this project locally:

1. Prerequisites: Make sure you've installed [Node.js] ≥ 12
2. Install dependencies: `yarn install`
3. Run the local development server: `yarn dev` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Exploring The Code
==================

1. The "backend" code lives in the `/contract` folder. See the README there for
   more info.
2. The frontend code lives in the `/src` folder. `/src/index.html` is a great
   place to start exploring. Note that it loads in `/src/index.js`, where you
   can learn how the frontend connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and the smart
   contract. See `contract/README` for info about how it's tested. The frontend
   code gets tested with [jest]. You can run both of these at once with `yarn
   run test`.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `yarn dev`, your smart
contract gets deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's
how.

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the
local `node_modules` folder when you ran `yarn install`, but for best ergonomics you may want to install it globally:

    yarn install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such
as `your-name.testnet`, you can deploy your contract to `app-for-certification.your-name.testnet`. Assuming you've
already created an account on [NEAR Wallet], here's how to create `app-for-certification.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

   near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

   near create-account app-for-certification.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please
see [this issue](https://github.com/zkat/npx/issues/209) for more details.

[React]: https://reactjs.org/

[create-near-app]: https://github.com/near/create-near-app

[Node.js]: https://nodejs.org/en/download/package-manager/

[jest]: https://jestjs.io/

[NEAR accounts]: https://docs.near.org/docs/concepts/account

[NEAR Wallet]: https://wallet.testnet.near.org/

[near-cli]: https://github.com/near/near-cli

[gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- contract/Cargo.toml ---
[package]
name = "examinator"
version = "0.1.0"
authors = ["i_koniukhov"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.7"
time = "0.1.38"
serde = "1.0"
serde_derive = "1.0"
serde_json = "1.0"
sha2 = "0.7.0"
itertools = "0.9.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
app-for-certification Smart Contract
==================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile it with
   the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard Rust tests using [cargo] with a `--nocapture` flag so that you
   can see any debug info you print to the console.

  [smart contract]: https://docs.near.org/docs/develop/contracts/overview
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://github.com/near/near-sdk-rs#pre-requisites
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contract/src/approval.rs ---
use near_sdk::{ext_contract, Gas};

use crate::*;

const GAS_FOR_NFT_APPROVE: Gas = Gas(10_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

pub trait NonFungibleTokenCore {
    //approve an account ID to transfer a token on your behalf
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);

    //check if the passed in account has access to approve the token ID
    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool;

    //revoke a specific account from transferring the token on your behalf
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId);

    //revoke all accounts from transferring the token on your behalf
    fn nft_revoke_all(&mut self, token_id: TokenId);
}

#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    //cross contract call to an external contract that is initiated during nft_approve
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //allow a specific account ID to approve a token on your behalf
    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>) {
        /*
            assert at least one yocto for security reasons - this will cause a redirect to the NEAR wallet.
            The user needs to attach enough to pay for storage on the contract
        */
        assert_at_least_one_yocto();

        //get the token object from the token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //make sure that the person calling the function is the owner of the token
        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Predecessor must be the token owner."
        );

        //get the next approval ID if we need a new approval
        let approval_id: u64 = token.next_approval_id;

        //check if the account has been approved already for this token
        let is_new_approval = token
            .approved_account_ids
            //insert returns none if the key was not present.
            .insert(account_id.clone(), approval_id)
            //if the key was not present, .is_none() will return true so it is a new approval.
            .is_none();

        //if it was a new approval, we need to calculate how much storage is being used to add the account.
        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
            //if it was not a new approval, we used no storage.
        } else {
            0
        };

        //increment the token's next approval ID by 1
        token.next_approval_id += 1;
        //insert the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        //refund any excess storage attached by the user. If the user didn't attach enough, panic.
        refund_deposit(storage_used);

        //if some message was passed into the function, we initiate a cross contract call on the
        //account we're giving access to.
        if let Some(msg) = msg {
            ext_non_fungible_approval_receiver::nft_on_approve(
                token_id,
                token.owner_id,
                approval_id,
                msg,
                account_id,                               //contract account we're calling
                NO_DEPOSIT,                               //NEAR deposit we attach to the call
                env::prepaid_gas() - GAS_FOR_NFT_APPROVE, //GAS we're attaching
            )
            .as_return(); // Returning this promise
        }
    }

    //check if the passed in account has access to approve the token ID
    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool {
        //get the token object from the token_id
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the approval number for the passed in account ID
        let approval = token.approved_account_ids.get(&approved_account_id);

        //if there was some approval ID found for the account ID
        if let Some(approval) = approval {
            //if a specific approval_id was passed into the function
            if let Some(approval_id) = approval_id {
                //return if the approval ID passed in matches the actual approval ID for the account
                approval_id == *approval
                //if there was no approval_id passed into the function, we simply return true
            } else {
                true
            }
            //if there was no approval ID found for the account ID, we simply return false
        } else {
            false
        }
    }

    //revoke a specific account from transferring the token on your behalf
    #[payable]
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId) {
        //assert that the user attached exactly 1 yoctoNEAR for security reasons
        assert_one_yocto();
        //get the token object using the passed in token_id
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the caller of the function and assert that they are the owner of the token
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //if the account ID was in the token's approval, we remove it and the if statement logic executes
        if token.approved_account_ids.remove(&account_id).is_some() {
            //refund the funds released by removing the approved_account_id to the caller of the function
            refund_approved_account_ids_iter(predecessor_account_id, [account_id].iter());

            //insert the token back into the tokens_by_id collection with the account_id removed from the approval list
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    //revoke all accounts from transferring the token on your behalf
    #[payable]
    fn nft_revoke_all(&mut self, token_id: TokenId) {
        //assert that the caller attached exactly 1 yoctoNEAR for security
        assert_one_yocto();

        //get the token object from the passed in token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");
        //get the caller and make sure they are the owner of the tokens
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //only revoke if the approved account IDs for the token is not empty
        if !token.approved_account_ids.is_empty() {
            //refund the approved account IDs to the caller of the function
            refund_approved_account_ids(predecessor_account_id, &token.approved_account_ids);
            //clear the approved account IDs
            token.approved_account_ids.clear();
            //insert the token back into the tokens_by_id collection with the approved account IDs cleared
            self.tokens_by_id.insert(&token_id, &token);
        }
    }
}

'''
'''--- contract/src/enumeration.rs ---
use crate::nft_core::NonFungibleTokenCore;
use crate::*;

#[near_bindgen]
impl Contract {
    //Query for nft tokens on the contract regardless of the owner using pagination
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        //get a vector of the keys in the token_metadata_by_id collection.
        let keys = self.token_metadata_by_id.keys_as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the total supply of NFTs for a given owner
    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    //Query for all the tokens for an owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        //if there is some set of tokens, we'll set the tokens variable equal to that set
        let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            tokens_for_owner_set
        } else {
            //if there is no set of tokens, we'll simply return an empty vector.
            return vec![];
        };
        //we'll convert the UnorderedSet into a vector of strings
        let keys = tokens.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }
}

'''
'''--- contract/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nep_format_vector() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![
                NftMintLog {
                    owner_id: "foundation.near".to_owned(),
                    token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                    memo: None,
                },
                NftMintLog {
                    owner_id: "user1.near".to_owned(),
                    token_ids: vec!["meme".to_string()],
                    memo: None,
                },
            ]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_mint() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: "foundation.near".to_owned(),
                token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                memo: None,
            }]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_transfer_all_fields() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: Some("market.near".to_string()),
                old_owner_id: "user1.near".to_string(),
                new_owner_id: "user2.near".to_string(),
                token_ids: vec!["token".to_string()],
                memo: Some("Go Team!".to_owned()),
            }]),
        };
        assert_eq!(expected, log.to_string());
    }
}

'''
'''--- contract/src/internal.rs ---
use std::mem::size_of;

use near_sdk::CryptoHash;

use crate::*;

//convert the royalty percentage and amount to pay into a payout (U128)
pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}

//calculate how many bytes the account ID is taking up
pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

//refund the storage taken up by passed in approved account IDs and send the funds to the passed in account ID.
pub(crate) fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I, //the approved account IDs must be passed in as an iterator
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    //get the storage total by going through and summing all the bytes for each approved account IDs
    let storage_released: u64 = approved_account_ids
        .map(bytes_for_approved_account_id)
        .sum();
    //transfer the account the storage that is released
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

//refund a map of approved account IDs and send the funds to the passed in account ID
pub(crate) fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    //call the refund_approved_account_ids_iter with the approved account IDs as keys
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_answer_id(answer_id: String) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(answer_id.as_bytes()));
    hash
}

//used to make sure the user attached exactly 1 yoctoNEAR
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
}

//Assert that the user has attached at least 1 yoctoNEAR (for security reasons and to pay for storage)
pub(crate) fn assert_at_least_one_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Requires attached deposit of at least 1 yoctoNEAR",
    )
}

//refund the initial deposit based on the amount of storage that was used up
pub(crate) fn refund_deposit(storage_used: u64) {
    //get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    //get the attached deposit
    let attached_deposit = env::attached_deposit();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    //get the refund amount from the attached deposit - required cost
    let refund = attached_deposit - required_cost;

    //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

impl Contract {
    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //get the set of tokens for the given account
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        tokens_set.insert(token_id);

        //we insert that set for the given account ID.
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    //remove a token from an owner (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //we get the set of tokens that the owner has
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            //if there is no set of tokens for the owner, we panic with the following message:
            .expect("Token should be owned by the sender");

        //we remove the the token_id from the set of tokens
        tokens_set.remove(token_id);

        //if the token set is now empty, we remove the owner from the tokens_per_owner collection
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
            //if the token set is not empty, we simply insert it back for the account ID.
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    //transfers the NFT to the receiver_id (internal method and can't be called directly via CLI).
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    ) -> Token {
        //get the token object by passing in the token_id
        let token = self.tokens_by_id.get(token_id).expect("No token");

        //if the sender doesn't equal the owner, we check if the sender is in the approval list
        if sender_id != &token.owner_id {
            //if the token's approved account IDs doesn't contain the sender, we panic
            if !token.approved_account_ids.contains_key(sender_id) {
                env::panic_str("Unauthorized");
            }

            // If they included an approval_id, check if the sender's actual approval_id is the same as the one included
            if let Some(enforced_approval_id) = approval_id {
                //get the actual approval ID
                let actual_approval_id = token
                    .approved_account_ids
                    .get(sender_id)
                    //if the sender isn't in the map, we panic
                    .expect("Sender is not approved account");

                //make sure that the actual approval ID is the same as the one provided
                assert_eq!(
                    actual_approval_id, &enforced_approval_id,
                    "The actual approval_id {} is different from the given approval_id {}",
                    actual_approval_id, enforced_approval_id,
                );
            }
        }

        //we make sure that the sender isn't sending the token to themselves
        assert_ne!(
            &token.owner_id, receiver_id,
            "The token owner and the receiver should be different"
        );

        //we remove the token from it's current owner's set
        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        //we then add the token to the receiver_id's set
        self.internal_add_token_to_owner(receiver_id, token_id);

        //we create a new token struct
        let new_token = Token {
            owner_id: receiver_id.clone(),
            //reset the approval account IDs
            approved_account_ids: Default::default(),
            next_approval_id: token.next_approval_id,
            //we copy over the royalties from the previous token
            royalty: token.royalty.clone(),
        };
        //insert that new token into the tokens_by_id, replacing the old entry
        self.tokens_by_id.insert(token_id, &new_token);

        //if there was some memo attached, we log it.
        if let Some(memo) = memo.as_ref() {
            env::log_str(&format!("Memo: {}", memo).to_string());
        }

        // Default the authorized ID to be None for the logs.
        let mut authorized_id = None;
        //if the approval ID was provided, set the authorized ID equal to the sender
        if approval_id.is_some() {
            authorized_id = Some(sender_id.to_string());
        }

        // Construct the transfer log as per the events standard.
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: token.owner_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: receiver_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_transfer_log.to_string());

        //return the preivous token object that was transferred.
        token
    }
}

'''
'''--- contract/src/lib.rs ---
extern crate time;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, CryptoHash, PanicOnDefault, Promise, PromiseOrValue,
};

use std::collections::HashMap;
use time::at;

pub use crate::approval::*;
use crate::chemistry::chemistry;
use crate::chemistry::Section;
pub use crate::events::*;
use crate::internal::*;
pub use crate::metadata::*;
use crate::microbiology::microbiology;
pub use crate::mint::*;
pub use crate::nft_core::*;
use crate::physic::physic;
pub use crate::royalty::*;
use crate::sociology::sociology;

mod approval;
mod enumeration;
mod events;
mod internal;
mod metadata;
mod mint;
mod nft_core;
mod royalty;

#[path = "subjects/chemistry.rs"]
mod chemistry;
#[path = "subjects/microbiology.rs"]
mod microbiology;
#[path = "subjects/physic.rs"]
mod physic;
#[path = "subjects/sociology.rs"]
mod sociology;
#[path = "subjects/subjects_struct.rs"]
mod subjects_struct;

// for validation attempt of exam
const VALID_RESULT: f32 = 70 as f32;
/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    //status of initiation
    pub is_init: bool,

    //contract owner
    pub owner_id: AccountId,

    //keeps track of the id_attempts vec for a given account ID
    pub id_attempts: UnorderedMap<AccountId, Vec<String>>,

    //keeps track of the tickets vec for a given individual key
    subjects: UnorderedMap<String, Vec<Section>>,

    //keeps track of the answers vec for a given individual key
    pub answers: UnorderedMap<String, Vec<Answer>>,

    //keeps track of the answers_id for a given attempt_key
    pub key_answers_id: LookupMap<String, UnorderedSet<String>>,

    //keeps track of the result struct for a given account ID
    pub results: UnorderedMap<AccountId, Result>,

    //keeps track of the numbers attempts for a given account ID
    pub attempt: UnorderedMap<AccountId, u8>,

    //keeps track of all the token IDs for a given account
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

    //keeps track of the token struct for a given token ID
    pub tokens_by_id: LookupMap<TokenId, Token>,

    //keeps track of the token metadata for a given token ID
    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,

    //keeps track of the metadata for the contract
    pub metadata: LazyOption<NFTContractMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokensById,
    TokenMetadataById,
    NFTContractMetadata,
    TokensPerType,
    TokensPerTypeInner { token_type_hash: CryptoHash },
    TokenTypesLocked,
    IdAttempts,
    Subject,
    Answers,
    KeyForResult { answer_id_hash: CryptoHash },
    Results,
    Attempt,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Answer {
    pub id: u8,
    pub article_id: u8,
    pub your_answer: String,
    pub correct_answer: String,
    pub pass: bool,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Response {
    pub ok: bool,
    pub message: String,
    pub attempt: u8,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Result {
    pub subject_name: String,
    pub attempt: u8,
    pub attempt_id: String,
    pub number_of_questions: u8,
    pub number_of_correct_answers: u8,
    pub number_of_incorrect_answers: u8,
    pub score: f32,
    pub is_valid: bool,
}

#[near_bindgen]
impl Contract {
    //initialization of the contract can only be called once.
    #[init]
    pub fn new_default_data(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: "nft-1.0.0".to_string(),
                name: "NFT Contract For Certification".to_string(),
                symbol: "CERTIFICATOR".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        Self {
            is_init: true,
            owner_id,
            id_attempts: UnorderedMap::<AccountId, Vec<String>>::new(
                StorageKey::IdAttempts.try_to_vec().unwrap(),
            ),
            subjects: UnorderedMap::<String, Vec<Section>>::new(
                StorageKey::Subject.try_to_vec().unwrap(),
            ),
            answers: UnorderedMap::<String, Vec<Answer>>::new(
                StorageKey::Answers.try_to_vec().unwrap(),
            ),
            key_answers_id: LookupMap::new(
                StorageKey::KeyForResult {
                    answer_id_hash: CryptoHash::default(),
                }
                    .try_to_vec()
                    .unwrap(),
            ),
            results: UnorderedMap::<AccountId, Result>::new(
                StorageKey::Results.try_to_vec().unwrap(),
            ),
            attempt: UnorderedMap::<AccountId, u8>::new(StorageKey::Attempt.try_to_vec().unwrap()),
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(
                StorageKey::TokenMetadataById.try_to_vec().unwrap(),
            ),
            metadata: LazyOption::new(
                StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        }

    }

    pub fn set_subjects(&mut self) -> Response {
        let chemistry = chemistry();
        let physic = physic();
        let sociology = sociology();
        let microbiology = microbiology();

        self.set_tickets(String::from("chemistry"), chemistry);
        self.set_tickets(String::from("physic"), physic);
        self.set_tickets(String::from("sociology"), sociology);
        self.set_tickets(String::from("microbiology"), microbiology);

        Response {
            ok: true,
            message: "Subjects is set up".to_string(),
            attempt: 0,
        }
    }

    //set_tickets - set tickets from source when exam is started
    pub fn set_tickets(&mut self, key_subject: String, sections: Vec<Section>) -> String {
        let mut array_of_sections: Vec<Section> = vec![];
        for section in sections {
            array_of_sections.push(section);
        }
        self.subjects.insert(&key_subject, &array_of_sections);
        String::from("Tickets set up")
    }

    pub fn set_answer(
        &mut self,
        subject_name: String,
        attempt: u8,
        article: u8,
        answers: Vec<Answer>,
        account_id: AccountId,
    ) -> String {
        let answer_id = format!("{}{}-{}-{}", attempt, article, subject_name, account_id);
        let attempt_id = format!("{}-{}-{}", attempt, subject_name, account_id);

        /*self.add_key_answer_to_owner_attempt(attempt_id, answer_id.clone());*/
        let mut answers_id_set = self.key_answers_id.get(&attempt_id).unwrap_or_else(|| {
            //if the account doesn't have any answers_id, we create a new unordered set
            UnorderedSet::new(
                StorageKey::KeyForResult {
                    //we get a new unique prefix for the collection
                    answer_id_hash: hash_answer_id(answer_id.clone()),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        // insert the answer ID into the set
        answers_id_set.insert(&answer_id);
        // insert that set for the given account ID.
        self.key_answers_id.insert(&attempt_id, &answers_id_set);
        self.answers.insert(&answer_id, &answers);
        String::from("Answers set up")
    }

    pub fn set_current_result(
        &mut self,
        account_id: AccountId,
        subject_name: String,
        answers: Vec<Answer>,
        attempt: u8,
    ) -> Response {
        let mut num_correct: Vec<bool> = vec![];
        let mut num_incorrect: Vec<bool> = vec![];
        let attempt_id = format!("{}-{}-{}", attempt, subject_name, account_id);
        for answer in &answers {
            if answer.pass == true {
                num_correct.push(answer.pass);
            } else {
                num_incorrect.push(answer.pass);
            }
        }
        let score: f32 =
            (num_correct.len() * 100 / (num_correct.len() + num_incorrect.len())) as f32;
        let sum_answers: u8 = (num_correct.len() + num_incorrect.len()) as u8;
        let result: Result = Result {
            subject_name,
            attempt,
            attempt_id,
            number_of_questions: sum_answers,
            number_of_correct_answers: num_correct.len() as u8,
            number_of_incorrect_answers: num_incorrect.len() as u8,
            score,
            is_valid: score >= VALID_RESULT as f32,
        };
        self.results.insert(&account_id, &result);
        Response {
            ok: true,
            message: "Result is set".to_string(),
            attempt,
        }
    }

    pub fn increment(&mut self, account_id: AccountId) -> Response {
        let current_attempt = self.get_num(&account_id).clone();
        let attempt = current_attempt + 1;

        self.attempt.insert(&account_id, &attempt);
        log!("Attempt {}", attempt);
        Response {
            ok: true,
            message: String::from("Success! "),
            attempt,
        }
    }

    pub fn reset(&mut self, account_id: AccountId) {
        self.attempt.remove(&account_id);
        log!("Reset attempt");
    }

    pub fn get_token_metadata(&self, account_id: AccountId) -> Vec<TokenMetadata> {
        let mut tokens: Vec<TokenMetadata> = vec![];
        match self.tokens_per_owner.get(&account_id) {
            None => {}
            Some(tokens_id_collection) => {
                for id in tokens_id_collection.to_vec() {
                    match self.token_metadata_by_id.get(&id) {
                        None => {}
                        Some(token) => tokens.push(token),
                    }
                }
            }
        }
        tokens
    }

    pub fn get_tickets_by_subject_name(&self, name: &String) -> Vec<Section> {
        match self.subjects.get(&name) {
            Some(tickets) => tickets,
            None => vec![],
        }
    }

    pub fn get_current_result(&self, account_id: &AccountId) -> Result {
        match self.results.get(&account_id) {
            Some(result) => result,
            None => Result {
                subject_name: String::from(""),
                attempt: 0,
                attempt_id: String::from(""),
                number_of_questions: 0,
                number_of_incorrect_answers: 0,
                number_of_correct_answers: 0,
                score: 0.00,
                is_valid: false,
            },
        }
    }

    //returns all answers which equal the expected attempt
    pub fn get_answers_by_attempt_id(&self, attempt_id: String) -> Vec<Vec<Answer>> {
        let mut answers_id_by_attempt: Vec<Vec<Answer>> = vec![];
        match self.key_answers_id.get(&attempt_id) {
            None => {}
            Some(answers_id_collection) => {
                for id in answers_id_collection.to_vec() {
                    match self.answers.get(&id) {
                        None => {}
                        Some(answers) => answers_id_by_attempt.push(answers),
                    }
                }
            }
        }
        answers_id_by_attempt
    }

    pub fn get_answers_by_key(&self, key: &String) -> Vec<Answer> {
        match self.answers.get(&key) {
            Some(answer_array) => answer_array,
            None => vec![],
        }
    }

    pub fn get_answers(&self) -> Vec<(String, Vec<Answer>)> {
        self.answers.to_vec()
    }

    pub fn get_id_attempts(&self, account_id: &AccountId) -> Vec<String> {
        match self.id_attempts.get(&account_id) {
            Some(key_array) => key_array,
            None => vec![],
        }
    }

    pub fn get_num(&self, account_id: &AccountId) -> u8 {
        match self.attempt.get(&account_id) {
            Some(attempt) => attempt,
            None => 1,
        }
    }

    pub fn get_status_init(&self) -> bool {
        self.is_init
    }

    pub fn get_subjects(&self) -> Vec<(String, Vec<Section>)> {
        self.subjects.to_vec()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::{test_utils::*, testing_env, Gas, ONE_NEAR};

    use crate::*;

    fn account_id() -> AccountId {
        "certificator.testnet".parse::<AccountId>().unwrap()
    }

    fn owner_id() -> AccountId {
        "owner.testnet".parse::<AccountId>().unwrap()
    }

    fn metadata() -> TokenMetadata {
        TokenMetadata {
            title: Option::from(String::from("Token title")),
            description: Option::from(String::from("Some test description")),
            media: None,
            media_hash: None,
            copies: None,
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn answers() -> Vec<Answer> {
        vec![
            Answer {
                id: 1,
                article_id: 2,
                your_answer: "yes".to_string(),
                correct_answer: "no".to_string(),
                pass: true,
            },
            Answer {
                id: 2,
                article_id: 1,
                your_answer: "yes".to_string(),
                correct_answer: "yes".to_string(),
                pass: true,
            },
            Answer {
                id: 3,
                article_id: 1,
                your_answer: "yes".to_string(),
                correct_answer: "no".to_string(),
                pass: true,
            },
        ]
    }

    fn get_context(signer: &AccountId, deposit: Option<u128>) -> VMContextBuilder {
        let mut contex = VMContextBuilder::new();
        contex
            .current_account_id(account_id())
            .account_balance(100 * ONE_NEAR)
            .signer_account_id(signer.clone())
            .attached_deposit(deposit.unwrap_or(0))
            .prepaid_gas(Gas(30_000_000_000_000))
            .is_view(false);
        contex
    }

    //check status of contract initiation after initiation, expect true
    #[test]
    fn get_status_init() {
        let context = get_context(&owner_id(), None);
        testing_env!(context.build());
        let contract = Contract::new_default_meta(owner_id());
        let status = contract.get_status_init();
        assert_eq!(status, true)
    }

    //set subjects exam, get subject by name 'chemistry' and expect that result.length == chemistry.length
    #[test]
    fn set_subjects() {
        let context = get_context(&owner_id(), None);
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(owner_id());
        let chemistry = chemistry();
        contract.set_subjects();

        assert_eq!(
            contract
                .get_tickets_by_subject_name(&String::from("chemistry"))
                .len(),
            chemistry.len()
        );
    }

    //set tickets for chemistry exam and expect that result.length == chemistry.length
    #[test]
    fn set_tickets() {
        let context = get_context(&owner_id(), None);
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(owner_id());
        let chemistry = chemistry();
        contract.set_tickets(String::from("chemistry"), chemistry.clone());
        let result = contract.get_tickets_by_subject_name(&String::from("chemistry"));

        assert_eq!(result.len(), chemistry.len());
    }

    // after set answers expected  answers.result == answers.length (3)
    #[test]
    fn set_answer() {
        let context = get_context(&owner_id(), None);
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(owner_id());

        let attempt = 0;
        let article = 1;
        let subject_name = String::from("chemistry");
        let key_attempt = format!("{}{}-{}-{}", attempt, article, subject_name, &owner_id());

        contract.answers.insert(&key_attempt, &answers());
        println!(
            "answers {:?}",
            contract.get_answers_by_key(&key_attempt).len()
        );
        assert_eq!(
            contract.get_answers_by_key(&key_attempt).len(),
            answers().len()
        );
    }

    //in answers struct all answer.pass == true, so we expect score 100
    #[test]
    fn set_current_result() {
        let context = get_context(&owner_id(), None);
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(owner_id());
        let name = String::from("chemistry");

        contract.set_current_result(owner_id(), name, answers(), 0);

        assert_eq!(contract.get_current_result(&owner_id()).score, 100 as f32);
    }

    //expected increment of attempt increasing on 1
    #[test]
    fn increment() {
        let mut contract = Contract::new_default_meta(owner_id());
        contract.increment(owner_id());
        assert_eq!(1, contract.get_num(&owner_id()));
    }

    //expected 0 after increase on 1 and then reset
    #[test]
    fn increment_and_reset() {
        let mut contract = Contract::new_default_meta(owner_id());
        contract.increment(owner_id());
        contract.reset(owner_id());
        assert_eq!(0, contract.get_num(&owner_id()));
    }

    // after mint expected result should be equal TokenMetadata type
    #[test]
    fn nft_mint() {
        let context = get_context(&owner_id(), Some(ONE_NEAR));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(owner_id());
        let token_id: TokenId = TokenId::from("101-test-id");
        let mut contract = Contract::new_default_meta(owner_id());

        let mut royalty = HashMap::<AccountId, u32>::new();

        royalty.insert(owner_id(), ONE_NEAR as u32);

        contract.nft_mint(
            token_id.clone(),
            metadata(),
            owner_id(),
            Some(royalty.clone()),
        );
        match contract.token_metadata_by_id.get(&token_id) {
            None => {}
            Some(meta) => assert_eq!(meta, metadata()),
        };
    }

    //expected result should be equal TokenMetadata type
    #[test]
    fn get_token_metadata() {
        let context = get_context(&owner_id(), Some(ONE_NEAR));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(owner_id());
        let token_id: TokenId = TokenId::from("101-test-id");
        let mut contract = Contract::new_default_meta(owner_id());

        let mut royalty = HashMap::<AccountId, u32>::new();

        royalty.insert(owner_id(), ONE_NEAR as u32);

        contract.nft_mint(
            token_id.clone(),
            metadata(),
            owner_id(),
            Some(royalty.clone()),
        );
        let meta_array = contract.get_token_metadata(owner_id());
        assert_eq!(meta_array, vec![metadata()])
    }
}

'''
'''--- contract/src/metadata.rs ---
use crate::*;
pub type TokenId = String;
//defines the payout type we'll be returning as a part of the royalty standards.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    //owner of the token
    pub owner_id: AccountId,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //the next approval ID to give out.
    pub next_approval_id: u64,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: HashMap<AccountId, u32>,
}

//The Json token is what will be returned from view calls.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    //token ID
    pub token_id: TokenId,
    //owner of the token
    pub owner_id: AccountId,
    //token metadata
    pub metadata: TokenMetadata,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: HashMap<AccountId, u32>,
}

pub trait NonFungibleTokenMetadata {
    //view call for returning the contract metadata
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- contract/src/mint.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        metadata: TokenMetadata,
        receiver_id: AccountId,
        //we add an optional parameter for perpetual royalties
        perpetual_royalties: Option<HashMap<AccountId, u32>>,
    ) {
        //measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        // create a royalty map to store in the token
        let mut royalty = HashMap::new();

        // if perpetual royalties were passed into the function:
        if let Some(perpetual_royalties) = perpetual_royalties {
            //make sure that the length of the perpetual royalties is below 7 since we won't have enough GAS to pay out that many people
            assert!(
                perpetual_royalties.len() < 7,
                "Cannot add more than 6 perpetual royalty amounts"
            );

            //iterate through the perpetual royalties and insert the account and amount in the royalty map
            for (account, amount) in perpetual_royalties {
                royalty.insert(account, amount);
            }
        }

        //specify the token struct that contains the owner ID
        let token = Token {
            //set the owner ID equal to the receiver ID passed into the function
            owner_id: receiver_id,
            //we set the approved account IDs to the default value (an empty map)
            approved_account_ids: Default::default(),
            //the next approval ID is set to 0
            next_approval_id: 0,
            //the map of perpetual royalties for the token (The owner will get 100% - total perpetual royalties)
            royalty,
        };

        //insert the token ID and token struct and make sure that the token doesn't exist
        assert!(
            self.tokens_by_id.insert(&token_id, &token).is_none(),
            "Token already exists"
        );

        //insert the token ID and metadata
        self.token_metadata_by_id.insert(&token_id, &metadata);

        //call the internal method for adding the token to the owner
        self.internal_add_token_to_owner(&token.owner_id, &token_id);

        // Construct the mint log as per the events standard.
        let nft_mint_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftMint(vec![NftMintLog {
                // Owner of the token.
                owner_id: token.owner_id.to_string(),
                // Vector of token IDs that were minted.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo: None,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_mint_log.to_string());

        //calculate the required storage which was the used - initial
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        //refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes);
    }
    pub fn check_token(&self, id: TokenId) -> bool {
        self.tokens_by_id.contains_key(&id)
    }
}

'''
'''--- contract/src/nft_core.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);
const MIN_GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(100_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

pub trait NonFungibleTokenCore {
    //transfers an NFT to a receiver ID
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: u64,
        memo: Option<String>,
    );

    //transfers an NFT to a receiver and calls a function on the receiver ID's contract
    /// Returns `true` if the token was transferred from the sender's account.
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: u64,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    //get information about the NFT token passed in
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    //Method stored on the receiver contract that is called via cross contract call when nft_transfer_call is called
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    /*
        resolves the promise of the cross contract call to the receiver contract
        this is stored on THIS contract and is meant to analyze what happened in the cross contract call when nft_on_transfer was called
        as part of the nft_transfer_call method
    */
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool;
}

/*
    resolves the promise of the cross contract call to the receiver contract
    this is stored on THIS contract and is meant to analyze what happened in the cross contract call when nft_on_transfer was called
    as part of the nft_transfer_call method
*/
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver.
    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: u64,
        memo: Option<String>,
    ) {
        //assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be redirected to the NEAR wallet.
        assert_one_yocto();
        //get the sender to transfer the token from the sender to the receiver
        let sender_id = env::predecessor_account_id();

        //call the internal transfer method and get back the previous token so we can refund the approved account IDs
        let previous_token =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, Some(approval_id), memo);

        //we refund the owner for releasing the storage used up by the approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
    }

    //implementation of the transfer call method. This will transfer the NFT and call a method on the reciver_id contract
    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: u64,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        //assert that the user attached exactly 1 yocto for security reasons.
        assert_one_yocto();

        //get the GAS attached to the call
        let attached_gas = env::prepaid_gas();

        /*
            make sure that the attached gas is greater than the minimum GAS for NFT transfer call.
            This is to ensure that the cross contract call to nft_on_transfer won't cause a prepaid GAS error.
            If this happens, the event will be logged in internal_transfer but the actual transfer logic will be
            reverted due to the panic. This will result in the databases thinking the NFT belongs to the wrong person.
        */
        assert!(
            attached_gas >= MIN_GAS_FOR_NFT_TRANSFER_CALL,
            "You cannot attach less than {:?} Gas to nft_transfer_call",
            MIN_GAS_FOR_NFT_TRANSFER_CALL
        );

        //get the sender ID
        let sender_id = env::predecessor_account_id();

        //transfer the token and get the previous token object
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            memo.clone(),
        );

        //default the authorized_id to none
        let mut authorized_id = None;
        //if the sender isn't the owner of the token, we set the authorized ID equal to the sender.
        if sender_id != previous_token.owner_id {
            authorized_id = Some(sender_id.to_string());
        }

        // Initiating receiver's call and the callback
        ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id,
            previous_token.owner_id.clone(),
            token_id.clone(),
            msg,
            receiver_id.clone(), //contract account to make the call to
            NO_DEPOSIT,          //attached deposit
            env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL, //attached GAS
        )
        //we then resolve the promise and call nft_resolve_transfer on our own contract
        .then(ext_self::nft_resolve_transfer(
            authorized_id, // we introduce an authorized ID so that we can log the transfer
            previous_token.owner_id,
            receiver_id,
            token_id,
            approval_id,
            previous_token.approved_account_ids,
            memo,                      // we introduce a memo for logging in the events standard
            env::current_account_id(), //contract account to make the call to
            NO_DEPOSIT,                //attached deposit
            GAS_FOR_RESOLVE_TRANSFER,  //GAS attached to the call
        ))
        .into()
    }

    //get the information for a specific token ID
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        //if there is some token ID in the tokens_by_id collection
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            //we'll get the metadata for that token
            let metadata = self.token_metadata_by_id.get(&token_id).unwrap();
            //we return the JsonToken (wrapped by Some since we return an option)
            Some(JsonToken {
                token_id,
                owner_id: token.owner_id,
                metadata,
                approved_account_ids: token.approved_account_ids,
                royalty: token.royalty,
            })
        } else {
            //if there wasn't a token ID in the tokens_by_id collection, we return None
            None
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    //resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
    //returns true if the token was successfully transferred to the receiver_id
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool {
        // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`
        // call result.
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            //As per the standard, the nft_on_transfer should return whether we should return the token to it's owner or not
            if let Ok(return_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                //if we need don't need to return the token, we simply return true meaning everything went fine
                if !return_token {
                    /*
                        since we've already transferred the token and nft_on_transfer returned false, we don't have to
                        revert the original transfer and thus we can just return true since nothing went wrong.
                    */
                    //we refund the owner for releasing the storage used up by the approved account IDs
                    refund_approved_account_ids(owner_id, &approved_account_ids);
                    return true;
                }
            }
        }

        //get the token object if there is some token object
        let mut token = if let Some(token) = self.tokens_by_id.get(&token_id) {
            if token.owner_id != receiver_id {
                //we refund the owner for releasing the storage used up by the approved account IDs
                refund_approved_account_ids(owner_id, &approved_account_ids);
                // The token is not owner by the receiver anymore. Can't return it.
                return true;
            }
            token
        //if there isn't a token object, it was burned and so we return true
        } else {
            //we refund the owner for releasing the storage used up by the approved account IDs
            refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };

        //we remove the token from the receiver
        self.internal_remove_token_from_owner(&receiver_id.clone(), &token_id);
        //we add the token to the original owner
        self.internal_add_token_to_owner(&owner_id, &token_id);

        //we change the token struct's owner to be the original owner
        token.owner_id = owner_id.clone();

        //we refund the receiver any approved account IDs that they may have set on the token
        refund_approved_account_ids(receiver_id.clone(), &token.approved_account_ids);
        //reset the approved account IDs to what they were before the transfer
        token.approved_account_ids = approved_account_ids;

        //we inset the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        /*
            We need to log that the NFT was reverted back to the original owner.
            The old_owner_id will be the receiver and the new_owner_id will be the
            original owner of the token since we're reverting the transfer.
        */
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: receiver_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: owner_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        //we perform the actual logging
        env::log_str(&nft_transfer_log.to_string());

        //return false
        false
    }
}

'''
'''--- contract/src/royalty.rs ---
use crate::*;

pub trait NonFungibleTokenCore {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout;

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance.
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: String,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout {
        //get the token object
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the owner of the token
        let owner_id = token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        //keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };
        //get the royalty object from token
        let royalty = token.royalty;

        //make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        //go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            //get the key
            let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
            if key != owner_id {
                //
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // payout to previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        //return the payout object
        payout_object
    }

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance.
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: String,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout {
        //assert that the user attached 1 yocto NEAR for security reasons
        assert_one_yocto();
        //get the sender ID
        let sender_id = env::predecessor_account_id();
        //transfer the token to the passed in receiver and get the previous token object back
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            Some(memo),
        );

        //refund the previous token owner for the storage used up by the previous approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );

        //get the owner of the token
        let owner_id = previous_token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        //keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };
        //get the royalty object from token
        let royalty = previous_token.royalty;

        //make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        //go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            //get the key
            let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
            if key != owner_id {
                //
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // payout to previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        //return the payout object
        payout_object
    }
}

'''
'''--- contract/src/subjects/chemistry.rs ---
mod subjects_struct;

pub use crate::subjects_struct::{Section, Ticket};

pub fn chemistry() -> Vec<Section> {
    vec![
        Section {
            article: 1,
            title: "1".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 1,
                    question: "When a beam of white rays is dispersed by a prism which colour will be refracted to a larger extent?".to_string(),
                    options: Vec::from(
                        [
                            "red".to_string(),
                            "blue".to_string(),
                            "yellow".to_string(),
                            "violet".to_string()
                        ]),
                    correct_answer: "violet".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 1,
                    question: "The modern atomic mass unit is based on__".to_string(),
                    options: Vec::from(
                        ["C-12".to_string(),
                            "N-14".to_string(),
                            "O-16".to_string(),
                            "H-1".to_string()]),
                    correct_answer: "C-12".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 1,
                    question: "Which element on adding to natural rubber makes it less sticky in hot weather and less hard in cold weather?".to_string(),
                    options: Vec::from(
                        ["Chlorine".to_string(),
                            "Sulfur".to_string(),
                            "Sodium".to_string(),
                            "Carbon".to_string()]),
                    correct_answer: "Sulfur".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                }],
        },
        Section {
            article: 2,
            title: "2".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 2,
                    question: "Glass is made out of what?".to_string(),
                    options: Vec::from(
                        ["Carbon".to_string(),
                            "Silicon".to_string(),
                            "Sand".to_string(),
                            "Concrete".to_string()]),
                    correct_answer: "Sand".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 2,
                    question: "The scientist who introduced the model of the atom similar to the solar system?".to_string(),
                    options: Vec::from(
                        ["Niels Bohr".to_string(),
                            "Robert Boyle".to_string(),
                            "Ernest Rutherford".to_string(),
                            "Robert Bunsen".to_string()]),
                    correct_answer: "Ernest Rutherford".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 2,
                    question: "What happens when an electron moves nearer to the nucleus of the atom?".to_string(),
                    options: Vec::from(
                        ["Antimatter".to_string(),
                            "An explosion".to_string(),
                            "Its energy increases".to_string(),
                            "Its energy decreases".to_string()]),
                    correct_answer: "Its energy decreases".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
            ],
        },
        Section {
            article: 3,
            title: "3".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 3,
                    question: "Which chemical causes Minamata disease?".to_string(),
                    options: Vec::from(
                        ["Minamata".to_string(),
                            "Mercury".to_string(),
                            "Manganese".to_string(),
                            "Hassium".to_string()]),
                    correct_answer: "Mercury".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 3,
                    question: "Which element has no neutrons in it?".to_string(),
                    options: Vec::from(
                        ["All options correct".to_string(),
                            "Hydrogen".to_string(),
                            "Helium".to_string(),
                            "Neon".to_string()]),
                    correct_answer: "Hydrogen".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 3,
                    question: "Which element can easily form chains?".to_string(),
                    options: Vec::from(
                        ["Phosphorus".to_string(),
                            "Silicon".to_string(),
                            "Carbon".to_string(),
                            "Uranium".to_string()]),
                    correct_answer: "Carbon".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 4,
                    article_id: 3,
                    question: "Cement mixed with gravel, sand, and water is called what?".to_string(),
                    options: Vec::from(
                        ["Stone".to_string(),
                            "Concrete".to_string(),
                            "Rock".to_string(),
                            "Marble".to_string()]),
                    correct_answer: "Concrete".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
            ],
        },
    ]
}

'''
'''--- contract/src/subjects/microbiology.rs ---
mod subjects_struct;

use crate::subjects_struct::{Section, Ticket};

pub fn microbiology() -> Vec<Section> {
    vec![
        Section {
            article: 1,
            title: "1".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 1,
                    question: "What is Sporophyll?".to_string(),
                    options: Vec::from(
                        [
                            "Leaves with associated sporangia".to_string(),
                            "Leaves with associated epidermis".to_string(),
                            "Leaves with associated chloroplasts".to_string(),
                            "Leaves with associated spongy mesophyl".to_string()
                        ]),
                    correct_answer: "Leaves with associated sporangia".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 1,
                    question: "Which is the first oxygen-producing organism?".to_string(),
                    options: Vec::from(
                        ["Autotrophic cyanobacteria".to_string(),
                            "Staphylococcus haemolyticus".to_string(),
                            "Moraxella spp".to_string(),
                            "Bacillus spp".to_string()]),
                    correct_answer: "Autotrophic cyanobacteria".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 1,
                    question: "Archaebacteria differ from eubacteria in:".to_string(),
                    options: Vec::from(
                        ["Cell membrane".to_string(),
                            "Mode of nutrition".to_string(),
                            "Cell shape".to_string(),
                            "Mode of reproduction".to_string()]),
                    correct_answer: "Cell membrane".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                }],
        },
        Section {
            article: 2,
            title: "2".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 2,
                    question: "Viruses have:".to_string(),
                    options: Vec::from(
                        ["DNA enclosed in a protein coat".to_string(),
                            "Prokaryotic nucleus".to_string(),
                            "Single chromosome".to_string(),
                            "Both DNA and RNA".to_string()]),
                    correct_answer: "DNA enclosed in a protein coat".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 2,
                    question: "The motile bacteria are able to move by:".to_string(),
                    options: Vec::from(
                        ["Flagella".to_string(),
                            "Fimbriae".to_string(),
                            "Cilia".to_string(),
                            "Pili".to_string()]),
                    correct_answer: "Flagella".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 2,
                    question: "If test results are within +/-2 standard deviations, the ratio of test results beyond the +/-2 SD limit will be 1 out of".to_string(),
                    options: Vec::from(
                        ["3".to_string(),
                            "5".to_string(),
                            "20".to_string(),
                            "300".to_string()]),
                    correct_answer: "5".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
            ],
        },
        Section {
            article: 3,
            title: "3".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 3,
                    question: "True nucleus is absent in:".to_string(),
                    options: Vec::from(
                        ["Anabaena".to_string(),
                            "Mucor".to_string(),
                            "Vaucheria".to_string(),
                            "Volvox".to_string()]),
                    correct_answer: "Anabaena".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 3,
                    question: "Carbohydrates are organic compounds of 1. carbon 2. hydrogen 33. oxygen".to_string(),
                    options: Vec::from(
                        ["1 and 2 only".to_string(),
                            "1 and 3 only".to_string(),
                            "2 and 3 only".to_string(),
                            "1, 2 and 3 only".to_string()]),
                    correct_answer: "1 and 2 only".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 3,
                    question: "Which of the following structures is not found in a prokaryotic cell?".to_string(),
                    options: Vec::from(
                        ["Nuclear envelope".to_string(),
                            "Ribosome".to_string(),
                            "Mesosome".to_string(),
                            "Plasma membrane".to_string()]),
                    correct_answer: "Nuclear envelope".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 4,
                    article_id: 3,
                    question: "The imperfect fungi which are decomposer of litter and help in mineral cycling belong to:".to_string(),
                    options: Vec::from(
                        ["Deuteromycetes".to_string(),
                            "Basidiomycetes".to_string(),
                            "Phycomycetes".to_string(),
                            "Ascomycetes".to_string()]),
                    correct_answer: "Deuteromycetes".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
            ],
        },
    ]
}

'''
'''--- contract/src/subjects/physic.rs ---
mod subjects_struct;
pub use crate::subjects_struct::{Section, Ticket};

pub fn physic() -> Vec<Section> {
    vec![
        Section {
            article: 1,
            title: "1".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 1,
                    question: "Who was the first person to design models of flying machine?".to_string(),
                    options: Vec::from(
                        [
                            "Issac Newton".to_string(),
                            "Leonardo da Vinci".to_string(),
                            "Albert Einstein".to_string(),
                            "Ernest Rutherford".to_string()
                        ]),
                    correct_answer: "Leonardo da Vinci".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 1,
                    question: "Of the following quantities, which one has dimension different from the remaining three?".to_string(),
                    options: Vec::from(
                        ["Angular momentum".to_string(),
                            "Energy per unit volume".to_string(),
                            "Force per unit area".to_string(),
                            "Product of voltage and charge per unit volume".to_string()]),
                    correct_answer: "Angular momentum".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 1,
                    question: "Who invented Aqua-Lung?".to_string(),
                    options: Vec::from(
                        ["Jacques Cousteau".to_string(),
                            "Leonardo da Vinci".to_string(),
                            "Galileo Galilei".to_string(),
                            "Lev Landau".to_string()]),
                    correct_answer: "5".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                }],
        },
        Section {
            article: 2,
            title: "2".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 2,
                    question: "Who is the real inventor of helicopter?".to_string(),
                    options: Vec::from(
                        ["Igor Sikorsky".to_string(),
                            "Paul Cornu".to_string(),
                            "Leonardo da Vinci".to_string(),
                            "Albert Einstein".to_string()]),
                    correct_answer: "Igor Sikorsky".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 2,
                    question: "Who invented Archimedean screw?".to_string(),
                    options: Vec::from(
                        ["Archimedean".to_string(),
                            "Leonardo da Vinci".to_string(),
                            "Albert Einstein".to_string(),
                            "Michael Faraday".to_string()]),
                    correct_answer: "1 and 2 only".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 2,
                    question: "The vacant space of a solid’s, electronic energy level is _".to_string(),
                    options: Vec::from(
                        ["Hole".to_string(),
                            "Port".to_string(),
                            "Slot".to_string(),
                            "Gap".to_string()]),
                    correct_answer: "Hole".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
            ],
        },
        Section {
            article: 3,
            title: "3".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 3,
                    question: "A petrol engine used to mix petrol and air in a certain ratio for combustion, is called _".to_string(),
                    options: Vec::from(
                        ["Carburettor".to_string(),
                            "Alternator".to_string(),
                            "Radiator".to_string(),
                            "Transmission".to_string()]),
                    correct_answer: "Carburettor".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 3,
                    question: "Which of the following is a dimensional constant?".to_string(),
                    options: Vec::from(
                        ["Gravitational".to_string(),
                            "Refractive index".to_string(),
                            "Poissons ratio".to_string(),
                            "Relative density".to_string()]),
                    correct_answer: "Gravitational".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 3,
                    question: "What is the potential energy of an electron when it is far away from the nucleus?".to_string(),
                    options: Vec::from(
                        ["1000".to_string(),
                            "0".to_string(),
                            "0.12".to_string(),
                            "unlimited".to_string()]),
                    correct_answer: "5".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 4,
                    article_id: 3,
                    question: "The book Hydrodynamic containing the explanation of Bernoulli’s theorem was published by whom in the year 1738?".to_string(),
                    options: Vec::from(
                        ["Daniel Bernoulli".to_string(),
                            "Albert Einstein".to_string(),
                            "Marie Curie".to_string(),
                            "Enrico Fermi".to_string()]),
                    correct_answer: "Daniel Bernoulli".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
            ],
        },
    ]
}

'''
'''--- contract/src/subjects/sociology.rs ---
mod subjects_struct;

pub use crate::subjects_struct::{Section, Ticket};

pub fn sociology() -> Vec<Section> {
    vec![
        Section {
            article: 1,
            title: "1".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 1,
                    question: "A community generally includes a number of neighbourhoods. Is it correct?".to_string(),
                    options: Vec::from(
                        [
                            "Yes".to_string(),
                            "No".to_string()
                        ]),
                    correct_answer: "Yes".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 1,
                    question: "Which one is a “Mass Society”?".to_string(),
                    options: Vec::from(
                        ["Gesellschaft".to_string(),
                            "Tribal".to_string(),
                            "Agrarian".to_string(),
                            "Post-Industrial".to_string()]),
                    correct_answer: "Gesellschaft".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 1,
                    question: " A rural community is characterised by:".to_string(),
                    options: Vec::from(
                        ["Community sentiment".to_string(),
                            "Competition".to_string(),
                            "A number of statuses".to_string(),
                            "All options correct".to_string()]),
                    correct_answer: "Community sentiment".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                }],
        },
        Section {
            article: 2,
            title: "2".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 2,
                    question: "A person in a society occupies:".to_string(),
                    options: Vec::from(
                        ["A number of statuses".to_string(),
                            "No status atoll".to_string(),
                            "Status undefined".to_string(),
                            "Some place".to_string()]),
                    correct_answer: "A number of statuses".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 2,
                    question: "A traditional society is not characterised by:".to_string(),
                    options: Vec::from(
                        ["Competition".to_string(),
                            "With a predominant role for custom and habit".to_string(),
                            "An orientation to the past".to_string(),
                            "Not the future".to_string()]),
                    correct_answer: "Competition".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 2,
                    question: "Society is group, but most groups are not societies. Is it correct?".to_string(),
                    options: Vec::from(
                        ["Yes".to_string(),
                            "No".to_string(),
                            ]),
                    correct_answer: "Yes".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
            ],
        },
        Section {
            article: 3,
            title: "3".to_string(),
            tickets: vec![
                Ticket {
                    id: 1,
                    article_id: 3,
                    question: "Who related function of institution to biological needs?".to_string(),
                    options: Vec::from(
                        ["Bronisław Malinowski".to_string(),
                            "Karl Marx".to_string(),
                            "Raymond Aron".to_string(),
                            "William Julius Wilson".to_string()]),
                    correct_answer: "Bronisław Malinowski".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 2,
                    article_id: 3,
                    question: "Sumner called an institution deliberately formed to satisfy needs:".to_string(),
                    options: Vec::from(
                        ["Enacted".to_string(),
                            "Not enacted".to_string(),
                            "Institution".to_string(),
                            "Bar".to_string()]),
                    correct_answer: "Enacted".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 3,
                    article_id: 3,
                    question: "If test results are within +/-2 standard deviations, the ratio of test results beyond the +/-2 SD limit will be 1 out of".to_string(),
                    options: Vec::from(
                        ["3".to_string(),
                            "5".to_string(),
                            "20".to_string(),
                            "300".to_string()]),
                    correct_answer: "5".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
                Ticket {
                    id: 4,
                    article_id: 3,
                    question: "The German word 'Gemeinschaft' means:".to_string(),
                    options: Vec::from(
                        ["Community".to_string(),
                            "Festival".to_string(),
                            "Type of beer".to_string(),
                            "Traditional sausages".to_string()]),
                    correct_answer: "Community".to_string(),
                    pass: false,
                    started: "".to_string(),
                    finished: "".to_string(),
                },
            ],
        },
    ]
}

'''
'''--- contract/src/subjects/subjects_struct.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::Deserialize;
use near_sdk::serde::Serialize;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Ticket {
    pub id: u8,
    pub article_id: u8,
    pub question: String,
    pub options: Vec<String>,
    pub correct_answer: String,
    pub pass: bool,
    pub started: String,
    pub finished: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug, Clone, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Section {
    pub article: u8,
    pub title: String,
    pub tickets: Vec<Ticket>,
}

'''
'''--- package.json ---
{
  "name": "app-for-certification",
  "homepage": "https://github.com/Igor-Koniukhov/app-for-certification",
  "version": "0.1.0",
  "license": "UNLICENSED",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "node contract/compile.js",
    "build:contract:debug": "node contract/compile.js --debug",
    "build:web": "parcel build src/index.html --public-url ./",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d dist/",
    "deploy": "npm run build && npm run deploy:contract && npm run deploy:pages",
    "prestart": "npm run build:contract:debug && npm run dev:deploy:contract",
    "start": "echo The app is starting! It will automatically open in your browser when ready && env-cmd -f ./neardev/dev-account.env parcel src/index.html --open",
    "dev": "nodemon --watch contract/src -e rs --exec \"npm run start\"",
    "test": "npm run build:contract:debug && cd contract && cargo test -- --nocapture && cd .. && jest test --runInBand"
  },
  "devDependencies": {
    "@babel/core": "~7.14.0",
    "@babel/preset-env": "~7.14.0",
    "@babel/preset-react": "~7.13.13",
    "babel-jest": "~26.6.2",
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~2.1.1",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "react-test-renderer": "~17.0.1",
    "shelljs": "~0.8.4"
  },
  "dependencies": {
    "bn.js": "^5.2.1",
    "bootstrap": "^5.2.0",
    "html-to-image": "^1.9.0",
    "near-api-js": "~0.43.1",
    "react": "~17.0.1",
    "react-canvas-draw": "^1.2.1",
    "react-dom": "~17.0.1",
    "react-router-dom": "^5.3.3",
    "react-to-print": "^2.14.7",
    "regenerator-runtime": "~0.13.5"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "jest": {
    "moduleNameMapper": {
      "\\.(jpg|ico|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "<rootDir>/src/__mocks__/fileMock.js",
      "\\.(css|less)$": "<rootDir>/src/__mocks__/fileMock.js"
    },
    "setupFiles": [
      "<rootDir>/src/jest.init.js"
    ],
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/App.js ---
import 'regenerator-runtime/runtime';
import React, {useEffect} from 'react';
import {BrowserRouter, Redirect, Route, Switch} from "react-router-dom";
import './global.css'
import IntroContent from "./components/IntroContent";
import Sociology from "./pages/subjects/Sociology";
import Chemistry from "./pages/subjects/Chemistry";
import Physic from "./pages/subjects/Physic";
import Microbiology from "./pages/subjects/Microbiology";
import Results from "./pages/Results";
import Layout from "./components/layout/Layout";
import Certificate from "./pages/Certificate";
import Home from "./pages/Home"
import NFTCollections from "./pages/NFTCollections";

let pageIsLoad = true;

export default function App() {
    const isSignedIn = window.walletConnection.isSignedIn();

    useEffect(() => {
        if (isSignedIn) {
            pageIsLoad = false;
            return
        }
    }, [isSignedIn]);

    return (
        <Layout>
            <Switch>
                    {!isSignedIn && <IntroContent/>}
                    {isSignedIn &&
                        <Route path='/' exact>
                            <Home/>
                        </Route>}
                    <Route path='/chemistry'>
                        <Chemistry
                            isLoad={pageIsLoad}
                        />
                    </Route>
                    <Route path='/sociology'>
                        <Sociology
                            isLoad={pageIsLoad}
                        />
                    </Route>
                    <Route path='/physic'>
                        <Physic
                            isLoad={pageIsLoad}
                        />
                    </Route>
                    <Route path='/microbiology'>
                        <Microbiology
                            isLoad={pageIsLoad}
                        />
                    </Route>
                    }

                    <Route path='/results'>
                        <Results/>
                    </Route>
                    <Route path='/certificate'>
                        <Certificate/>
                    </Route>
                    <Route path='/nft-collections'>
                        <NFTCollections/>
                    </Route>

            </Switch>

        </Layout>
    )
}

'''
'''--- src/__mocks__/fileMock.js ---
// NOTE: This is used to mock resource imports in JSX for tests
module.exports = '' 

'''
'''--- src/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- src/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- src/components/Article.js ---
import React, {useContext, useEffect, useState} from "react";
import QuestionItems from "./QuestionItems";
import ArticleContext from "../store/article-context";

const Article = (props) => {
    const {
        set_answer,
        get_num
    } = window.contract;

    const {tickets} = props.source;
    const cnx = useContext(ArticleContext);
    const filteredAnswers = cnx.answers.filter(answer => answer.article_id === props.article);
    const questionLength = tickets.length
    const answersLength = filteredAnswers.length
    const buttonDisabled = questionLength !== answersLength
    const [shuffledQuestionsState, setShuffledQuestions] = useState([])
    const numberOfAnswers = cnx.answers.length
    const isSuccess = cnx.numberOfQuestions === numberOfAnswers
    const [buttonDisabledState, setButtonDisabledState] = useState(buttonDisabled)
    const [stateStatusSending, setStateStatusSending] = useState('sent')
    const [stateButtonColor, setStateButtonColor]= useState('btn btn-secondary me-2')
    const [stateAttempt, setStateAttempt]=useState(0);

    useEffect(()=>{
        const getAttempt = async()=>{
            await get_num({account_id: window.accountId}).then((data)=>{
                setStateAttempt(data)
            })
        }
        getAttempt()
    }, [stateAttempt])

    let shuffledQuestions = tickets
        .map(value => ({value, sort: Math.random()}))
        .sort((a, b) => a.sort - b.sort)
        .map(({value}) => value)

    useEffect(() => {
        setShuffledQuestions(shuffledQuestions)
        cnx.getNumbersOfQuestions(shuffledQuestionsState.length)
    }, [shuffledQuestionsState.length]);

    useEffect(() => {
        setButtonDisabledState(buttonDisabled)
    }, [buttonDisabled]);

    const sentMessage = async (answers) => {
        try {
            await set_answer({
                subject_name: props.subJectName,
                attempt: stateAttempt,
                article: cnx.article,
                answers: answers,
                account_id: window.accountId,
            })
        } catch (e) {
            alert(
                'Something went wrong! ' +
                'Maybe you need to sign out and back in? ' +
                'Check your browser console for more info.'
            )
            throw e
        } finally {
            setButtonDisabledState(true)
            props.buttonDisabled(true, isSuccess)
            console.log('SENT!')
        }
    };
    const handlerSubmit = async (event) => {
        event.preventDefault();
        const sentAnswers = async () => {
               await sentMessage(filteredAnswers)

            props.setShowNotification(true);
            setTimeout(() => {
                props.setShowNotification(false);
            }, 4000);
        };
        await sentAnswers();
    }

    const list = shuffledQuestionsState.map((item, index) =>
        <QuestionItems
            article={props.article}
            index={index}
            key={item.id}
            id={item.id}
            question={item.question}
            options={item.options}
            correct_answer={item.correct_answer}
            isAllChoosen={!buttonDisabledState}
        />
    )
    const sendEventHandler = () => {
        setStateStatusSending('sending...')
        setStateButtonColor('btn btn-warning me-2')
    }
    return (
        <form onSubmit={handlerSubmit}>
            <h1>{props.source.title}</h1>
            <p>{props.source.content}</p>
            {list}
            <button
                className={`${!buttonDisabledState ? stateButtonColor :  buttonDisabled ? stateButtonColor :'btn btn-success me-2'}`}
                id={`button-${props.article}`}
                disabled={buttonDisabledState}
                onClick={sendEventHandler}
            >
                { !buttonDisabledState ? stateStatusSending : buttonDisabled ? stateStatusSending :'succeed!'}
            </button>
        </form>
    )

}

export default Article;
'''
'''--- src/components/Content.js ---
import React, {useContext, useEffect, useState} from "react";
import {useHistory} from "react-router-dom";
import Notification from "./UI/Notification";
import Article from "./Article";
import LoadingSpinner from "./UI/LoadingSpinner";
import ArticleContext from "../store/article-context";

let isLoaded = true;

const Content = (props) => {
    const {
        get_tickets_by_subject_name,
        increment,
        get_num,
        set_current_result,
    } = window.contract;
    const cnx = useContext(ArticleContext);
    const [stateResultMessage, setStateResultMessage] = useState(false);
    const [showNotification, setShowNotification] = useState(false);
    const [buttonDisabledState, setButtonDisabledState] = useState(false);
    const [successState, setSuccessState] = useState(false);
    let [ticketsState, setTicketsState] = useState([]);
    const [stateGettingResult, setStateGettingResult] = useState('Get results')
    const [stateButtonColor, setStateButtonColor]= useState('btn btn-secondary mt-4')
    const [stateAttempt, setStateAttempt]=useState(0);
    const history = useHistory();
    const success = successState && buttonDisabledState;
    const ticketError = ticketsState === null || ticketsState === undefined
    if (ticketError) {
        ticketsState = [];
    }
    const isTicketLoad = ticketsState.length === 0;
    const isTicketSucceed = !ticketError && !isTicketLoad

    useEffect(() => {
        const getTickets = async () => {
            await get_tickets_by_subject_name({name: props.subjectName})
                .then((data) => {
                    setTicketsState(data)
                })
        };
        getTickets();
    }, [isLoaded, ticketsState.length]);

    useEffect(() => {
        if (isLoaded) {
            isLoaded = false;
            return
        }
    }, [isLoaded]);

    useEffect(()=>{
        const getAttempt = async()=>{
            await get_num({account_id: window.accountId}).then((data)=>{
                setStateAttempt(data)
            })
        }
        getAttempt()
    }, [isLoaded])

    useEffect(() => {
        if (success) {
            const setCollectionOfAnswers = async () => {
                await set_current_result({
                    account_id: window.accountId,
                    subject_name: props.subjectName,
                    answers: cnx.answers,
                    attempt: stateAttempt,
                }).then((data) => {
                    if (data.ok) {
                        setStateResultMessage(true)
                    }
                })
            }
            setCollectionOfAnswers();
        }
    }, [success]);

    const getResultsHandler = async (event) => {
        event.preventDefault()
        setStateButtonColor('btn btn-warning mt-4')
        setStateGettingResult('getting...')
        const {ok, message} = await increment({account_id: window.accountId})
        cnx.setRequestStatus(ok);
        history.push('/results')
    };

    const buttonDisabled = (buttonDisabled, success) => {
        setButtonDisabledState(buttonDisabled)
        setSuccessState(success)
    }
    const articles = ticketsState.map((content, index) =>
        <Article
            subJectName={props.subjectName}
            article={content.article}
            key={content.article}
            source={content}
            index={index}
            buttonDisabled={buttonDisabled}
            setShowNotification={setShowNotification}
        />
    )

    return (
        <div className="container pb-5 pt-5 wrapper">
            <h1>{props.subjectName.toUpperCase()}</h1>
            {articles}
            {success && stateResultMessage &&
                <div>
                    <button
                        className={`${success ? stateButtonColor :'btn btn-success mt-4'}`}
                        onClick={getResultsHandler}>{success ? stateGettingResult : 'Got'}
                    </button>
                </div>}
            {
                showNotification &&
                <Notification/>}
            {
                !isTicketSucceed &&
                (
                    <div className='backdrop'>
                        <LoadingSpinner/>
                    </div>
                )}
            {success && !stateResultMessage &&
                (
                    <div className='backdrop'>
                        <LoadingSpinner/>
                    </div>
                )
            }
        </div>
    )
}

export default Content;
'''
'''--- src/components/IntroContent.js ---
import React from "react";
import './IntroContent.module.css';

const IntroContent = () => {
    return (

        <div id="carouselExampleSlidesOnly" className="carousel slide" data-bs-ride="carousel">
            <div className="carousel-inner">
                <div className="carousel-item active ">
                    <div className="certificate-blank-black">
                    </div>
                </div>
                <div className="carousel-item ">
                    <div className="certificate-blank">
                    </div>
                </div>
                <div className="carousel-item">
                    <div className="certificate-blank-black">
                    </div>
                </div>
            </div>
        </div>
    )
}

export default IntroContent;

'''
'''--- src/components/IntroContent.module.css ---
.certificate-blank {
    position: relative;
}

.certificate-blank::before {
    display: block;
    content: '';
    background-image: url(../img/certificate-blank-black.png);
    background-repeat: no-repeat;
    background-size: contain;
    background-position: center;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    z-index: 0;
    height: 100vh;
    background-color: #41464b;

}

.certificate-blank {
    position: relative;
}

.certificate-blank::before {
    display: block;
    content: '';
    background-image: url(../img/certificate-blank.jpg);
    background-repeat: no-repeat;
    background-size: contain;
    background-position: center;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    z-index: 0;
    height: 100vh;
    background-color: #41464b;

}

.certificate-blank-black {
    position: relative;
}

.certificate-blank-black::before {
    display: block;
    content: '';
    background-image: url(../img/certificate-blank-black.png);
    background-repeat: no-repeat;
    background-size: contain;
    background-position: center;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    z-index: 0;
    height: 100vh;
    background-color: #41464b;

}

.carousel-inner {
    height: 100vh;

}

.certificate-content {
    display: flex;
    flex-direction: column;
    position: absolute;
    background-size: contain;
    background-position: center;
    top: 310px;
    color: #e6fcfc;
    z-index: 10;
    height: 100%;
    width: inherit;
    left: 0;
    right: 0;
    margin: 0 auto;

}
'''
'''--- src/components/NFTItem.js ---
import React from "react";

const NFTItem = (props) => {
    return (
        <div
            className="col-lg-4 col-md-4 col-sm-6 d-flex flex-column"
        >
            <strong className="text-center">{props.d.title}</strong>
            <details style={{textAlign: "justify"}}>
                <summary>description:</summary>
                <p style={{fontSize: "14px"}}>{props.d.description}</p>
            </details>
            <img src={props.d.media}/>
        </div>
    )
}

export default NFTItem;
'''
'''--- src/components/QuestionItem.module.css ---
input[type="radio"] {
    appearance: none;
    background-color: #fff;
    margin: 0;
    font: inherit;
    color: currentColor;
    width: 1em;
    height: 1em;
    border: 1px solid currentColor;
    border-radius: 50%;
}
input[type="radio"]:hover{
    cursor: pointer;
    background-color: #0072CE;
    opacity: 0.4;
}
input[type="radio"]:checked:hover{
    background-color: #0072CE;
    opacity: unset;
}
input[type="radio"]:disabled:checked:hover{
    background-color: #0072CE;
    opacity: unset;
}
input[type="radio"]:disabled:hover{
    background-color: unset;
    opacity: unset;
    cursor: unset;
}
input[type="radio"]:checked{
    background-color: #0072CE;
}

'''
'''--- src/components/QuestionItems.js ---
import React, {useContext, useEffect, useState} from "react";
import ArticleContext from "../store/article-context";
import './QuestionItem.module.css'

const QuestionItems = (props) => {
    const artCtx = useContext(ArticleContext);
    const [buttonDisabled, setButtonDisabled] = useState(false)
    const [shuffledAnswers, setShuffledAnswers] = useState([])

    const answer = {
        id: "",
        article_id: "",
        your_answer: "",
        correct_answer: "",
        pass: false
    }
    const onChangeHandler = (e) => {
        setButtonDisabled(true);
        answer.id = props.id
        answer.article_id = props.article
        answer.your_answer = e.target.value
        answer.correct_answer = props.correct_answer
        artCtx.article_id = props.article
        artCtx.addAnswer(answer, props.article, props.id);

        if (answer.your_answer.trim() === answer.correct_answer.trim()) {
            answer.pass = true
        }
    }

    let answers = props.options
        .map(value => ({value, sort: Math.random()}))
        .sort((a, b) => a.sort - b.sort)
        .map(({value}) => value)
    useEffect(() => {
        setShuffledAnswers(answers)
    }, [])

    return (
        <ol>
            <h3>{props.index + 1}. {props.question}</h3>
            {shuffledAnswers.map((a, i) =>
                <li key={i}>
                    <input
                        className={props.id + "-" + "checked"}
                        id={props.id + "-" + i}
                        type="radio"
                        value={a}
                        onChange={onChangeHandler}
                        disabled={buttonDisabled}
                    />
                    <label style={{paddingLeft: '10px'}} htmlFor={props.id + "-" + i}>{a}</label>
                </li>)}

        </ol>
    )
}

export default QuestionItems;
'''
'''--- src/components/ResultItem.js ---
import React from "react";

const ResultItem = (props) => {

    return (
        <div className="d-flex flex-row justify-content-between border mt-1"
             style={{paddingLeft: "10px", paddingRight: "10px"}}
        >
            <div className="col-2 flex-column">
                <div style={{marginRight: "auto"}}> {props.artickle}/{props.questionId}</div>
            </div>
            <div className="col-4k text-center">{props.your_answer}</div>
            <div className="col-4 text-center">{props.correct_answer}</div>
            <div style={{color: props.pass ? 'green' : 'red', marginLeft: "5px",}}
                 className="col-1 ">
                {props.pass ? ' Passed' : ' Failed'}
            </div>
        </div>
    )
}

export default ResultItem;
'''
'''--- src/components/UI/LoadingSpinner.js ---
import React from 'react';
import  './LoadingSpinner.module.css';

const LoadingSpinner = () => {
  return <div className='spinner'></div>;
}

export default LoadingSpinner;

'''
'''--- src/components/UI/LoadingSpinner.module.css ---
.spinner {

  display: inline-block;
  width: 80px;
  height: 80px;
}
.spinner:after {
  content: ' ';
  display: block;
  width: 64px;
  height: 64px;
  margin: 8px;
  border-radius: 50%;
  border: 6px solid #41464b;
  border-color: #41464b transparent #41464b transparent;
  animation: spinner 1.2s linear infinite;
}
@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

'''
'''--- src/components/UI/Notification.js ---
import React from "react";

const Notification =()=>{

    return (
                <aside style={{
                    display: 'flex',
                    justifyContent: 'space-around',
                    alignItems: 'center',
                    marginLeft: 'auto',
                    position: "fixed",
                    zIndex: 100,
                    bottom: 0,
                    right: 0,
                    width: '100%',
                    backgroundColor: 'green'

                }}>

                        {window.accountId}

                        {window.contract.contractId}

                    <footer>
                        <div>✔ Succeeded</div>
                    </footer>
                </aside>
    )
}

export default Notification;
'''
'''--- src/components/UI/SubjectItemButton.js ---
import React, {useState, useContext} from "react";
import "./SubjectItemButton.module.css"
import {useHistory} from "react-router-dom";
import LoadingSpinner from "./LoadingSpinner";
import ArticleContext from "../../store/article-context";
const homepage = "https://igor-koniukhov.github.io/app-for-certification/";

const SubjectItemButton = (props) => {
    const [stateSpinner, setStateSpinner] = useState(false);
    const history = useHistory();
    const cnx = useContext(ArticleContext);
    const moveToExamHandler = () => {
        cnx.resetState();
        setStateSpinner(true)
        history.push(`${props.path}`)
        setStateSpinner(false)
    }
    let title = props.path.substring(1).toUpperCase();
    return (
        <div
            className="col-xl-5 col-md-5 col-sm-5 img-btn  "
            style={{
                backgroundImage: `url(${homepage + props.image})`,
                backgroundRepeat: 'no-repeat',
                backgroundPosition: 'center',
                backgroundSize: 'cover',
                height: '230px',
                padding: '2px',
                color: '#ffffff',
                display: 'flex',
                justifyContent: 'space-around',
                alignItems: 'center',
                position: 'relative',
                margin: '3px',
            }}>
            <div className="img-cover">
                {stateSpinner &&
                    <LoadingSpinner/>
                }

            </div>
            <div className="button-title">  {title}</div>
            <div className="handler" onClick={moveToExamHandler}></div>
        </div>
    )
}

export default SubjectItemButton;
'''
'''--- src/components/UI/SubjectItemButton.module.css ---
.img-btn {
    position: relative;
    z-index: 2;
    margin: 3px;
}

.handler {
    content: '';
    display: block;
    position: absolute;
    background-repeat: no-repeat;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 6;
    border: unset;
}

.handler:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.3);
    border: 1px solid #fff;
    top: 3px;
    bottom: 3px;
    left: 3px;
    right: 3px;
}

.img-cover {
    content: '';
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    background-repeat: no-repeat;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 3;
}

.button-title {
    position: absolute;
    text-align: center;

    z-index: 5;
}

'''
'''--- src/components/helper/errorHelper.js ---

const errorHelper = (err) => {

    if (err.message.includes('Cannot deserialize the contract state')) {
        console.warn('NEAR Warning: the contract/account seems to have state that is not (or no longer) compatible.\n' +
            'This may require deleting and recreating the NEAR account as shown here:\n' +
            'https://stackoverflow.com/a/60767144/711863');
    }
    if (err.message.includes('Cannot deserialize the contract state')) {
        console.warn('NEAR Warning: the contract/account seems to have state that is not (or no longer) compatible.\n' +
            'This may require deleting and recreating the NEAR account as shown here:\n' +
            'https://stackoverflow.com/a/60767144/711863');
    }
    console.error(err);
}

export default errorHelper;
'''
'''--- src/components/layout/Footer.js ---
import React from "react";

const Footer = ()=>{
    const isSignedIn = window.walletConnection.isSignedIn();
    return (
        <footer className="w-auto text-bg-dark footer">
            {
                isSignedIn &&
            <ul className="nav justify-content-center border-bottom pb-3 mb-3">

                <li>
                    <a href='https://github.com/Igor-Koniukhov/app-for-certification'
                       className="nav-link px-2 text-white"> SourceCode</a>
                </li>
            </ul>}
            <p className="text-center text-muted">© 2022 Company, Inc</p>
        </footer>
    )
}

export default Footer
'''
'''--- src/components/layout/Layout.js ---
import React, {useContext, useEffect, useState} from "react";
import './Layout.module.css';
import NavBar from "./NavBar";
import ArticleProvider from "../../store/ArticleProvider";
import Footer from "./Footer";
import errorHelper from "../helper/errorHelper";
import ArticleContext from "../../store/article-context";

let pageIsLoad = false

const Layout = (props) => {
    const isSignedIn = window.walletConnection.isSignedIn();
    const {get_num} = window.contract;
    const [countState, setCountState] = useState(0);
    const cnx = useContext(ArticleContext);
    const {isSent} = cnx

    useEffect(() => {
        const getCounter = async () => {
            await get_num({account_id: window.accountId}).then((attempt) => {
                setCountState(attempt === undefined ? 0 : attempt)

            }).catch(err => errorHelper(err))

        }
        cnx.attempt = countState;
        getCounter();
        pageIsLoad = false

    }, [isSignedIn, pageIsLoad || isSent]);

    pageIsLoad = true

    return (
        <ArticleProvider>
            <NavBar attempt={countState}/>
            <main className='main'>
                {props.children}
            </main>
            <Footer/>
        </ArticleProvider>
    )
};

export default Layout;

'''
'''--- src/components/layout/Layout.module.css ---

'''
'''--- src/components/layout/NavBar.js ---
import {useHistory, NavLink} from "react-router-dom";
import './NavBar.module.css';
import {login, logout} from "../../utils";
import React, {Fragment, useContext, useEffect, useState} from "react";
import ArticleContext from "../../store/article-context";
import errorHelper from "../helper/errorHelper";

const MainNavigation = (props) => {
    const isSignedIn = window.walletConnection.isSignedIn();
    const ctx = useContext(ArticleContext);
    const history = useHistory();
    const { isMeta} = ctx

const isHomepage = history.location.pathname === '/'

    return (

        <Fragment>
            <header className="p-3 text-bg-dark">
                <div className="d-flex flex-wrap align-items-center justify-content-around ">
                    <div className="d-flex align-items-center mb-2 mb-lg-0 text-white text-decoration-none">
                        <div>{window.accountId}</div>

                    </div>
                    {!isSignedIn && <h1 className="main-title">Certificator</h1>}
                    {isSignedIn &&
                        <ul className="nav col-12 col-lg-auto me-lg-auto mb-2 justify-content-center mb-md-0">
                            <li>
                                <NavLink to='/' className="nav-link px-2 text-white">
                                    Subjects
                                </NavLink>

                            </li>
                            <li>
                                <a href='https://github.com/Igor-Koniukhov/app-for-certification'
                                   className="nav-link px-2 text-white"> SourceCode</a>
                            </li>

                            { isMeta &&
                                <li>
                                    <NavLink to='/nft-collections' className="nav-link px-2 text-white">
                                        NFT-collection
                                    </NavLink>

                                </li>
                            }
                        </ul>}
                    {
                        isSignedIn &&
                        <div className="d-flex align-items-center mb-2 mb-lg-0 text-white text-decoration-none mx-5">
                            {!isHomepage &&  <span>Attempt: <strong>{ props.attempt}</strong> </span>}
                        </div>
                    }
                    <div className="text-start">
                        {
                            isSignedIn &&
                            <button type="button" className="btn btn-warning logout" onClick={logout}>Logout</button>
                        }

                        {
                            !isSignedIn &&
                            <button type="button" className="btn btn-outline-light me-2" onClick={login}>Login</button>
                        }
                    </div>
                </div>

            </header>

        </Fragment>

    )
};
export default MainNavigation;

'''
'''--- src/components/layout/NavBar.module.css ---
.header {
    width: 100%;
    display: flex;
    flex-direction: column;
    padding: 0 30px;
    background-color: #008080;
}

.account {
    margin-left: auto;
    font-size: 1rem;
    color: white;
}
.nav{
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px ;
    margin: 0 auto;
}

.nav ul {
    list-style: none;
    display: flex;
    margin: 0;
    padding: 0;
    max-width: 700px;
    width: 100%;
}

.nav li {
    margin-left: 1.5rem;
    font-size: 1.25rem;
}

.nav a {
    text-decoration: none;
    color: #88dfdf;
}

.nav a:hover,
.nav a:active,
.nav a.active {
    color: #e6fcfc;
}
.nav-btn{
    width: 120px;
    color: #88dfdf;
    padding: 3px;
    border-radius: 5px;
    border: unset;
    box-shadow: 2px 2px 2px 2px rgba(250, 250, 250, .5);
    background:#124a4a;
    margin-left: auto;
}
.nav-btn:hover{
    cursor: pointer;
}

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME ||'examenator-iko.testnet'

function getConfig(env) {

      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        explorerUrl: 'https://explorer.testnet.near.org',
      }

}

module.exports = getConfig

'''
'''--- src/global.css ---
@import url('https://fonts.googleapis.com/css2?family=Jomolhari&display=swap');
* {
  padding: 0;
  margin: 0;
  vertical-align: top;
  box-sizing: border-box;
  border: 0;
}
html {

  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}
.wrapper {
  min-height: 100%;
  flex: 1 0 auto;

}
.main-title{
  text-transform: uppercase;
  text-align: center;
  color:#c5a649;
  font-family: 'Jomolhari', serif;
}
footer{
  padding: 30px 0;
}
html{
  min-height: 100%;
  position: relative;
}
html, body {
  height: 100%;
  margin: 0;
}
#root{
  height: 100%;
}
.logout{
  margin-left: auto;
}

body {
  min-height: 100%;
  display: flex;
  position: relative;
  flex-direction: column;
}

main {
  min-height: 100%;
  width: 100%;
}
.footer{
  flex-shrink: 0;

}

h1 {
  margin-top: 0;
  text-align: center;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}

.backdrop {
  display: flex;
  justify-content: center;
  align-items: center;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  z-index: 20;
  background-color: rgba(0, 0, 0, .4);
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}
button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}
button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}
button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}
[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}
[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}
[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid #fff;
  border-color: var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}

input[disabled]:hover{
  cursor: unset;
}
@keyframes loader {
  0% { transform: rotate(0deg) }
  100% { transform: rotate(360deg) }
}

fieldset {
  border: none;
  padding: 2em 0;
}

input::selection {
  background-color: var(--secondary);
  color: #efefef;
}
input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}
aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  bottom: 0;
  font-size: 0.8em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
.changed:disabled  {
  background-color: blue;
}

@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }
  h1 {
    background-image: url(assets/logo-white.svg);
  }
  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./assets/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="apple-touch-icon" href="./assets/favicon.ico" />
    <title>App For Certification</title>
  </head>
  <body>
    <div id="root"></div>

    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import 'bootstrap/dist/css/bootstrap.min.css';
import 'bootstrap/dist/js/bootstrap.bundle.min';
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import { initContract } from './utils'
import { HashRouter} from "react-router-dom";

window.nearInitPromise = initContract()
  .then(() => {
    ReactDOM.render(
        <HashRouter>
            <App />
        </HashRouter>,
      document.querySelector('#root')
    )
  })
  .catch(console.error)

'''
'''--- src/jest.init.js ---
import 'regenerator-runtime/runtime'

'''
'''--- src/pages/Certificate.js ---
import React, {Fragment, useContext, useEffect, useRef, useState} from "react";
import "./Certificate.module.css"
import LoadingSpinner from "../components/UI/LoadingSpinner";
import {useReactToPrint} from "react-to-print";
import {toJpeg} from 'html-to-image';
import ArticleContext from "../store/article-context";

const BN = require("bn.js");
const pageStyle = `
  @page {
    size: 210mm 297mm;
  }

  @media all {
    .pagebreak {
      display: none;
    }
  }

  @media print {
    .pagebreak {
      page-break-before: always;
    }
  }
`;

const Certificate = () => {
    const componentRef = useRef();
    const handlePrint = useReactToPrint({
        content: () => componentRef.current,
    });
    const cnx = useContext(ArticleContext)

    const {
        nft_mint,
        get_current_result,
        get_token_metadata,
    } = window.contract
    const [stateDate, setStateDate] = useState('');
    const [stateResult, setStateResult] = useState({})
    const isResult = stateResult.score !== undefined && stateResult.score !== null;

    const [stateDataUrl, setStateDataUrl] = useState('');
    const node = document.getElementById('screenshot');

    useEffect(() => {
        toJpeg(node, {quality: 0.8})
            .then((dataUrl) => {
                setStateDataUrl(dataUrl)
            })
            .catch((error) => {
                console.error('oops, something went wrong!', error);
            });
    }, [isResult])

    let today = new Date();
    let dd = String(today.getDate()).padStart(2, '0');
    let mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!
    let yyyy = today.getFullYear();
    today = dd + '/' + mm + '/' + yyyy;

    const description = ` That certificate of achievement is presented to ${window.accountId}, for passing the exam with score: ${stateResult.score}. Date: ${today}`
    const token_id = `${stateResult.attempt}-${window.accountId}`
    const mintNFT = async () => {
        await nft_mint(
            {
                token_id: token_id,
                metadata: {
                    title: `${stateResult.subject_name}-${window.accountId}`,
                    description: description,
                    media: stateDataUrl,
                },
                receiver_id: window.accountId,
                approval_id: window.accountId,
            },
            300000000000000, // attached GAS (optional)
            new BN("1000000000000000000000000")
        );

    };
    useEffect(() => {
        const getResults = async () => {
            await get_current_result({account_id: window.accountId}).then((data) => {
                setStateResult(data)
            })
        }
        setStateDate(today)
        getResults();

    }, [isResult])

    useEffect(() => {
        const getTokenMetadata = async () => {
            await get_token_metadata({account_id: window.accountId})
                .then((data) => {
                    if (data.length > 0) {
                        cnx.setMetadate(data, true)
                    }
                })
        }
        getTokenMetadata();
    }, [])

    return (
        <Fragment>
            <style type="text/css" media="print">{" @page {size: landscape;}"}</style>
            <div ref={componentRef}>
                <style> {pageStyle}</style>
                <div>
                    <div className="container-frame frame stamp">
                        <h1 className="header-title">Certificate</h1>
                        <p className="header-title">for achievement in exam of {stateResult.subject_name}</p>
                        <h2 className="header-title">Owner:</h2>
                        <h3 className="header-title">{window.accountId}</h3>
                        <h4 className="header-title">number of points scored:</h4>
                        <h5 className="header-title header-title_font-size">{stateResult.score}</h5>
                        <h6 className="header-title">
                            certificate issued by
                            <strong className="text-decoration-underline"> certificator</strong>
                        </h6>
                        <h6 className="header-title">date: {stateDate} </h6>
                    </div>
                    <div/>
                </div>
            </div>
            <div className="container pt-5">
                <div className="row  justify-content-center">

                    <button
                        onClick={handlePrint}
                        className="btn btn-warning d-inline-block col-md-3 m-1">Print out
                    </button>
                    <button
                        type="submit"
                        className="btn btn-warning d-inline  col-md-3 m-1"
                        onClick={mintNFT}
                    >
                        Mint NFT
                    </button>
                </div>
            </div>
            <div id="screenshot">
                <div className="container-frame-nft frame-nft stamp-nft">
                    <h1 className="header-title-nft">Certificate</h1>
                    <p className="p-header-title-nft">for achievement in exam of {stateResult.subject_name}</p>
                    <h2 className="header-title-nft">Owner:</h2>
                    <h3 className="header-title-nft">{window.accountId}</h3>
                    <h6 className="header-title-nft">number of points scored:</h6>
                    <h6 className="header-title-nft header-title_font-size">{stateResult.score}</h6>
                    <h6 className="header-title-nft">
                        certificate issued by
                        certificator
                    </h6>
                    <h6 className="header-title-nft">date: {stateDate} </h6>
                </div>
                <div/>
            </div>
            {!isResult &&
                <div className='backdrop'>
                    <LoadingSpinner/>
                </div>
            }
        </Fragment>
    )
}

export default Certificate;
'''
'''--- src/pages/Certificate.module.css ---
.frame {
    position: relative;
    top: 30px;
    max-width: 760px;
    width: 100%;
    height: 992px;
    margin: 0 auto;
    box-shadow: 4px 4px 4px 4px rgba(0, 0, 0, 0.2);
    border: unset;

}

.header-title {
    display: block;
    position: relative;
    top: 100px;
    left: 0;
    right: 0;
    margin: 0 auto;
    z-index: 2;
    text-transform: uppercase;
    text-align: center;
    color: #c5a649;
    font-family: 'Jomolhari', serif;
}

.header-title_font-size {
    font-size: 56px;
}

.issued {
    display: block;
    position: relative;
    top: 250px;
    left: 0;
    right: 0;
    margin: 0 auto;
    z-index: 2;
    text-transform: uppercase;
    text-align: center;
    color: #c5a649;
    font-family: 'Jomolhari', serif;
}

.mint-button {
    display: block;
    position: relative;
    top: 130px;
    left: 0;
    right: 0;
    margin: 0 auto;
    z-index: 2;

    font-family: 'Jomolhari', serif;
}

.frame::before {
    display: flex;
    content: '';
    background-image: url(../img/frame-certificate-stamp.png);
    background-repeat: no-repeat;
    background-size: contain;
    background-position: top;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    z-index: -10;
    background-color: #41464b;

}

/*devider*/
#screenshot {
    margin: 0 auto;

    display: inline-block;
    position: relative;
    padding: 1px;
    height: 100%;
    border: unset;

}

.frame-nft {
    width: 240px;
    height: 175px;
    background-color: #41464b;
    border: 2px solid #c5a649;
}

.header-title-nft {
    display: block;
    position: relative;
    font-size: 14px;
    top: 18px;
    left: 0;
    right: 0;
    margin: 0 auto;
    z-index: 2;
    text-transform: uppercase;
    text-align: center;
    color: #c5a649;
    font-family: 'Jomolhari', serif;
}
.p-header-title-nft{
    display: block;
    position: relative;
    font-size: 8px;
    top: 18px;
    left: 0;
    right: 0;
    margin: 0 auto;
    z-index: 2;
    text-transform: uppercase;
    text-align: center;
    color: #c5a649;
    font-family: 'Jomolhari', serif;
}

/*devider*/

@media screen and (max-width: 900px) {
    .frame {
        position: relative;
        max-width: 945px;
        width: 100%;
        height: 1240px;
        margin: 0 auto;
    }

    .frame::before {
        display: flex;
        content: '';
        background-image: url(../img/frame-certificate-stamp.png);
        background-repeat: no-repeat;
        background-size: contain;
        background-position: top;
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        z-index: 0;
        background-color: unset;
    }

}

@media screen and (max-width: 400px) {
    .frame {
        height: 430px;
    }

}

@media screen and (max-width: 600px) {
    .frame {
        height: 430px;
    }

}

@media screen and (max-width: 800px) {
    .frame {
        height: 860px;
    }

}
'''
'''--- src/pages/Home.js ---
import React, {Fragment, useEffect, useState} from "react";

import "./Home.module.css";
import ChemistryImage from "../img/subject/IUPAC-feature-image.png";
import PhysicImage from "../img/subject/physic.png";
import SociologyImage from "../img/subject/sociology.png";
import MicroBiologyImage from "../img/subject/microbiology.png"
import SubjectItemButton from "../components/UI/SubjectItemButton";
import LoadingSpinner from "../components/UI/LoadingSpinner";

const Home = () => {

    const subjectRange = [
        {
            path: '/chemistry',
            img: ChemistryImage,
        },
        {
            path: '/physic',
            img: PhysicImage,
        },
        {
            path: '/sociology',
            img: SociologyImage,
        },
        {
            path: '/microbiology',
            img: MicroBiologyImage
        }
    ]

    const initContractHandler = () => {
        setStateSpinner(true)
        const initContract = async () => {
            await new_default_data({owner_id: window.accountId}).then((data) => {
                if (data !== undefined || data !== null) {
                    setStateSpinner(false)
                    setStateIsInit(true)
                }
            }).then(()=>{
                const setSubjects = async () => {
                    await set_subjects({})
                }
                setSubjects();
            })
        }
        initContract();
    }

    return (
        <Fragment>
            <div className="container text-center pt-5 ">
                <h1>Welcome to Examinator</h1>
                    <Fragment>
                        <p>Choose your subject and start exam</p>
                        <div className="row justify-content-center">
                            {subjectRange.map((sbj, index) =>
                                <SubjectItemButton
                                    key={index}
                                    image={sbj.img}
                                    path={sbj.path}
                                />
                            )}
                        </div>
                    </Fragment>

            </div>

        </Fragment>
    )

}

export default Home;
'''
'''--- src/pages/Home.module.css ---

'''
'''--- src/pages/NFTCollections.js ---
import React, {useContext, useState, useEffect} from "react";
import ArticleContext from "../store/article-context";
import NFTItem from "../components/NFTItem";

const NFTCollections = () => {
    const {get_token_metadata}=window.contract
    const [stateTokenMetadata, setStateTokenMetadata]=useState([])
    const {isMeta} = useContext(ArticleContext);
    useEffect(() => {
        const getTokenMetadata = async () => {
            await get_token_metadata({account_id: window.accountId}).then((data) => {
                if (data.length !==0 ){
                    setStateTokenMetadata(data)
                }
            })
        }
        getTokenMetadata();

    }, [isMeta])

    return (
        <div className="container">
            <div className="row">
            {
                stateTokenMetadata.map((data, index) =>
                    <NFTItem key={index} d={data}/>)
            }
            </div>
        </div>
    )
}
export default NFTCollections;
'''
'''--- src/pages/Results.js ---
import React, {Fragment, useContext, useEffect, useState} from "react";
import {useHistory} from "react-router-dom";
import './Certificate.module.css';
import ArticleContext from "../store/article-context";
import ResultItem from "../components/ResultItem";
import LoadingSpinner from "../components/UI/LoadingSpinner";

const Certificate = () => {
    const history = useHistory();
    const {isLoaded} = useContext(ArticleContext);
    let [stateAnswers, setStateAnswers] = useState([])
    const [stateResult, setStateResult] = useState({})
    const [stateSubjectName, setStateSubjectName] = useState('');
    const [stateAttemptId, setStateAttemptId] = useState('');
    const {
        get_answers_by_attempt_id,
        get_current_result,
    } = window.contract;
    const answerError = stateAnswers === null || stateAnswers === undefined;
    const isAnswersGot = !answerError && stateAnswers.length > 0;

    if (answerError) {
        stateAnswers = []
    }
    useEffect(() => {
        const getResults = async () => {
            await get_current_result({account_id: window.accountId})
                .then((data) => {
                    setStateResult(data)
                    setStateSubjectName(data.subject_name);
                    setStateAttemptId(data.attempt_id)
                })
        }
        getResults();

    }, [isLoaded])

    useEffect(() => {
        const getAndSetAnswers = async () => {
            get_answers_by_attempt_id({attempt_id: stateAttemptId}).then((data) => {
                setStateAnswers(data)
            })
        }

        getAndSetAnswers()
    }, [stateAttemptId])

    let passed = stateAnswers.map(array => array.filter((answer) =>
        answer.pass === true
    ))

    let notPassed = stateAnswers.map(array => array.filter((answer) =>
        answer.pass === false
    ))

    const getCertificateHandler = () => {
        history.push('/certificate');
    }
    const resultPassed = passed.map((data) =>
        data.map((answer, index) =>
            <ResultItem
                index={index}
                key={index}
                artickle={answer.article_id}
                questionId={answer.id}
                your_answer={answer.your_answer}
                correct_answer={answer.correct_answer}
                pass={answer.pass}

            />
        )
    )
    const resultFailed = notPassed.map((data) =>
        data.map((answer, index) =>
            <ResultItem
                index={index}
                key={index}
                artickle={answer.article_id}
                questionId={answer.id}
                your_answer={answer.your_answer}
                correct_answer={answer.correct_answer}
                pass={answer.pass}

            />
        )
    )

    return <div style={{width: "100%", marginLeft: "auto", marginRight: "auto"}}>
        <Fragment>
            <h1 className="text-capitalize">{stateSubjectName} test results:</h1>
            <h2 className="text-center">Score: {stateResult.score}</h2>
            <p>*Id=ArticleId/QuestionId</p>
            <div className="d-flex flex-row justify-content-between border"
                 style={{paddingLeft: "10px", paddingRight: "10px"}}
            >
                <div className="col-2 flex-column" style={{marginRight: "auto"}}>
                    Id
                </div>
                <div className="col-4">Your answers</div>
                <div className="col-4">Correct answers</div>
                <div style={{marginLeft: "5px",}}
                     className="col-1"
                >
                    result
                </div>
            </div>
            {
                isAnswersGot ?
                    <Fragment>
                        {resultPassed.length !== 0 && <h3 className="text-center">Passed answers: </h3>}
                        {resultPassed}
                        {resultFailed.length !== 0 && <h3 className="text-center">Not passed answers: </h3>}
                        {resultFailed}
                        {stateResult.is_valid &&
                            <button className="btn btn-warning mt-3 d-block mx-auto" onClick={getCertificateHandler}>Get
                                Certificate</button>}
                        {!stateResult.is_valid &&
                            <p className="text-center mt-3 "
                               style={{color: "red"}}
                            >Required min number of score for getting a certificate - 70. Try it the next time. </p>}
                    </Fragment> :
                    <div className='backdrop'>
                        <LoadingSpinner/>
                    </div>
            }
        </Fragment>
    </div>
}

export default Certificate;
'''
'''--- src/pages/subjects/Chemistry.js ---
import React  from "react";
import {useHistory} from "react-router-dom";
import Content from "../../components/Content";

const Chemistry = (props)=>{
    const history = useHistory();
    let subjectName = history.location.pathname.substring(1);
    return (
        <Content
            subjectName={subjectName}
            isLoad ={props.isLoad}
        />
    )
}

export default Chemistry;
'''
'''--- src/pages/subjects/Microbiology.js ---
import React from "react";
import {useHistory} from "react-router-dom";
import Content from "../../components/Content";

const Microbiology = (props)=>{
    const history = useHistory();
    let subjectName = history.location.pathname.substring(1);
    return (
        <Content
            subjectName={subjectName}
            isLoad = {props.isLoad}
        />
    )
}

export default Microbiology;
'''
'''--- src/pages/subjects/Physic.js ---
import React from "react";
import {useHistory} from "react-router-dom";
import Content from "../../components/Content";

const Physic = (props)=>{
    const history = useHistory();
    let subjectName = history.location.pathname.substring(1);
    return (
        <Content
            subjectName={subjectName}
            isLoad = {props.isLoad}
        />
    )
}

export default Physic;
'''
'''--- src/pages/subjects/Sociology.js ---
import React from "react";
import {useHistory} from "react-router-dom";
import Content from "../../components/Content";

const Sociology = (props)=>{
    const history = useHistory();
    let subjectName = history.location.pathname.substring(1);
    return (
        <Content
            subjectName={subjectName}
            isLoad = {props.isLoad}
        />
    )
}

export default Sociology
'''
'''--- src/store/ArticleProvider.js ---
import React, { useReducer} from "react";
import ArticleContext from "./article-context";

const defaultArticleState={
    article: 0,
    attempt: 0,
    answers: [],
    metadata:[],
    isMeta: false,
    chapter: {},
    numberOfQuestions: 0,
    isSent: false
}

const articleReducer = (state, action) =>{
    if (action.type ==='ADD_ANSWER'){
        const currentIdArticle = action.article
        const updatedAnswers = [...state.answers, action.answer]
        const updatedChapter={}
        if(action.article===action.article_id){
            updatedChapter[action.article]=updatedAnswers
        }
        return {
            answers: updatedAnswers,
            attempt: state.attempt,
            article: currentIdArticle,
            isMeta: state.isMeta,
            metadata: state.metadata,
            chapter: updatedChapter,
            numberOfQuestions:state.numberOfQuestions,
            isSent: state.isSent
        }
    }

    if(action.type==='GET_NUMBERS_OF_QUESTIONS'){
        const updatedNumbersOfQuestions= state.numberOfQuestions + action.length
        return {
            answers: state.answers,
            attempt: state.attempt,
            article: state.article,
            isMeta: state.isMeta,
            metadata: state.metadata,
            chapter: state.chapter,
            numberOfQuestions: updatedNumbersOfQuestions,
            isSent: state.isSent
        }
    }
    if(action.type==='RESET'){
        return defaultArticleState
    }
    if(action.type === 'SET_STATUS'){
        const updatedStatus = action.isSent
        return {
            answers: state.answers,
            attempt: state.attempt,
            article: state.article,
            isMeta: state.isMeta,
            metadata: state.metadata,
            chapter: state.chapter,
            numberOfQuestions: state.numberOfQuestions,
            isSent: updatedStatus
        }

    }
    if(action.type === 'SET_ANSWERS'){
        const updatedAnswers= action.answers

        return {
            answers: updatedAnswers,
            attempt: state.attempt,
            article: state.article,
            isMeta: state.isMeta,
            metadata: state.metadata,
            chapter: state.chapter,
            numberOfQuestions: state.numberOfQuestions,
            isSent: state.isSent
        }

    }
    if(action.type === 'SET_METADATA'){
        const updatedMetaData= action.metadata
        const isMeta = action.isMeta

        return {
            answers: state.answers,
            attempt: state.attempt,
            article: state.article,
            isMeta: isMeta,
            metadata: updatedMetaData,
            chapter: state.chapter,
            numberOfQuestions: state.numberOfQuestions,
            isSent: state.isSent
        }

    }
    if(action.type === 'SET_ATTEMPT'){
        const updateAttempt= action.attempt

        return {
            answers: state.answers,
            attempt: updateAttempt,
            article: state.article,
            isMeta: state.isMeta,
            metadata: state.metadata,
            chapter: state.chapter,
            numberOfQuestions: state.numberOfQuestions,
            isSent: state.isSent
        }

    }

    return defaultArticleState;
}

const ArticleProvider = (props)=>{
    const [articleState, dispatchArticleAction]=useReducer(articleReducer, defaultArticleState);
    const addAnswersHandler = (answer, article, article_id)=>{
        dispatchArticleAction({
            type: 'ADD_ANSWER',
            article: article,
            answer: answer,
            article_id: article_id,
        })
    }
const getNumbersOfQuestionsHandler=(length)=>{
        dispatchArticleAction({
            type: 'GET_NUMBERS_OF_QUESTIONS',
            length: length
        })
    }
const resetStateHandler=()=>{
        dispatchArticleAction({
            type: 'RESET',
        })
    }
const setRequestStatusHandler = (isSent) =>{
        dispatchArticleAction({
            type: 'SET_STATUS',
            isSent: isSent
        })
}
const setCollectionAnswersHandler =(answers)=>{
        dispatchArticleAction({
            type: 'SET_ANSWERS',
            answers: answers,
        })

}
const setMetadataHandler = (metadata, isMeta)=>{
        dispatchArticleAction({
            type:'SET_METADATA',
            metadata: metadata,
            isMeta: isMeta,
        })
}
const setAttemptHandler =(attempt)=>{
        dispatchArticleAction({
            type: 'SET_ATTEMPT',
            attempt: attempt,
        })
}

    const articleContext = {
        article: articleState.article,
        attempt: articleState.attempt,
        answers: articleState.answers,
        isMeta: articleState.isMeta,
        metadata: articleState.metadata,
        chapter: articleState.chapter,
        numberOfQuestions: articleState.numberOfQuestions,
        isSent: articleState.isSent,
        addAnswer: addAnswersHandler,
        getNumbersOfQuestions: getNumbersOfQuestionsHandler,
        setRequestStatus: setRequestStatusHandler,
        setCollectionAnswers: setCollectionAnswersHandler,
        setMetadate: setMetadataHandler,
        setAttempt: setAttemptHandler,
        resetState: resetStateHandler
    }
    return <ArticleContext.Provider value={articleContext}>
        {props.children}
            </ArticleContext.Provider>

}

export default ArticleProvider;
'''
'''--- src/store/article-context.js ---
import React from 'react';

const ArticleContext = React.createContext({
    article:0,
    attempt:0,
    answers:[],
    metadata:[],
    isMeta: false,
    chapter: {},
    numberOfQuestions:0,
    isSent: false,
    addAnswer: (article, article_id, answer)=>{},
    getNumbersOfQuestions:(length)=>{},
    resetState:()=>{},
    setRequestStatus: (status)=>{},
    setCollectionAnswers:(answer)=>{},
    setMetadate:(metatada)=>{},
    setAttempt:(attepmt)=>{},
})

export default ArticleContext;
'''
'''--- src/utils.js ---
import {
    connect,
    Contract,
    keyStores,
    WalletConnection
} from 'near-api-js'
import getConfig from './config'

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

// Initialize contract & set global variables
export async function initContract() {
    // Initialize connection to the NEAR testnet
    const near = await connect(Object.assign({deps: {keyStore: new keyStores.BrowserLocalStorageKeyStore()}}, nearConfig))

    // Initializing Wallet based Account. It can work with NEAR testnet wallet that
    // is hosted at https://wallet.testnet.near.org
    window.walletConnection = new WalletConnection(near)

    // Getting the Account ID. If still unauthorized, it's just empty string
    window.accountId = window.walletConnection.getAccountId()

    // Initializing our contract APIs by contract name and configuration
    window.contract = await new Contract(
        window.walletConnection.account(),
        nearConfig.contractName, {
        // View methods are read only. They don't modify the state, but usually return some value.
        viewMethods: [
            'get_num',
            'check_token',
            'get_token_metadata',
            'get_answers',
            'get_tickets_by_subject_name',
            'get_status_init',
            'get_answers_by_attempt_id',
            'get_id_attempts'
        ],
        // Change methods can modify the state. But you don't receive the returned value when called.
        changeMethods: [
            'set_subjects',
            'get_tickets',
            'set_tickets',
            'set_answer',
            'get_id_answers',
            'increment',
            'reset',
            'nft_mint',
            'set_current_result',
            'get_current_result',
            'new_default_data'
            ],
    })
}

export function logout() {
    window.walletConnection.signOut()
    // reload page
    window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
    window.walletConnection.requestSignIn(nearConfig.contractName)

}

'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>For local account login, Please run the following command in NEAR CLI, then enter account id here.
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''