*GitHub Repository "near/workspaces-rs"*

'''--- .github/workflows/test.yml ---
name: Test & Release

permissions:
  pull-requests: write
  contents: write

on:
  push:
    branches: [ main ]
  pull_request:

env:
  CARGO_TERM_COLOR: always
  RUSTFLAGS: '-D warnings'
  CARGO_INCREMENTAL: 0
  RUST_BACKTRACE: short

jobs:
  clippy:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: Run clippy
      run: cargo clippy --all-targets -- -D clippy::all -D clippy::nursery

  cargo-fmt:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: Run cargo fmt
      run: cargo fmt --check

  # there're sometimes warnings, which signal, that the generated doc
  # won't look as expected, when rendered, and sometimes errors, which will prevent doc from being
  # generated at release time altogether.
  cargo-doc:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: run cargo doc
      run: RUSTDOCFLAGS="-D warnings" cargo doc

  test:
    needs: cargo-fmt
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
        toolchain: [stable]
    runs-on: ${{ matrix.platform }}

    steps:
    - uses: actions/checkout@v2
    - name: "${{ matrix.toolchain }}"
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: ${{ matrix.toolchain }}
        default: true
    - uses: Swatinem/rust-cache@v1
    - name: Add wasm32 target
      run: rustup target add wasm32-unknown-unknown
    - name: Check with stable features
      run: cargo check --verbose
    - name: Run tests with unstable features
      run: NEAR_RPC_TIMEOUT_SECS=100 cargo test --verbose --features unstable

  release-plz:
    runs-on: ubuntu-latest
    needs: [clippy, cargo-fmt, cargo-doc, test]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.MY_GITHUB_TOKEN }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://release-plz.ieni.dev/docs/github/trigger
          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- CHANGELOG.md ---
# Changelog

## [Unreleased]

## [0.10.0](https://github.com/near/near-workspaces-rs/compare/near-workspaces-v0.9.0...near-workspaces-v0.10.0) - 2024-01-25

### Other
- Impl Clone on result Value ([#345](https://github.com/near/near-workspaces-rs/pull/345))
- Upgraded NEAR crates to 0.20.0 release ([#346](https://github.com/near/near-workspaces-rs/pull/346))
- dependecy bumps ([#338](https://github.com/near/near-workspaces-rs/pull/338))
- cleanup internals ([#329](https://github.com/near/near-workspaces-rs/pull/329))
- use stable sandbox by default ([#335](https://github.com/near/near-workspaces-rs/pull/335))
- [**breaking**] Remove `interop_sdk` feature from defaults ([#339](https://github.com/near/near-workspaces-rs/pull/339))
- fix typos ([#340](https://github.com/near/near-workspaces-rs/pull/340))

## [0.9.0](https://github.com/near/near-workspaces-rs/compare/near-workspaces-v0.8.0...near-workspaces-v0.9.0) - 2023-10-30

### Added
- Require Send + Sync for T in Worker<T> to allow near-workspaces usage in multithreading async runtimes  ([#328](https://github.com/near/near-workspaces-rs/pull/328))
- Added API for measuring gas ([#284](https://github.com/near/near-workspaces-rs/pull/284))

### Fixed
- Fixed await during acquired lock in rpc::client::fetch_tx_nonce ([#334](https://github.com/near/near-workspaces-rs/pull/334))

### Other
- [**breaking**] Migrate to use NearToken instead of raw u128 for balance variables to ensure strict typing ([#333](https://github.com/near/near-workspaces-rs/pull/333))
- Restrict GasHook type to require RefUnwindSafe and UnwindSafe to avoid breaking release ([#323](https://github.com/near/near-workspaces-rs/pull/323)) ([#326](https://github.com/near/near-workspaces-rs/pull/326))
- remove unwraps ([#321](https://github.com/near/near-workspaces-rs/pull/321))

## [0.8.0](https://github.com/near/near-workspaces-rs/compare/near-workspaces-v0.7.0...near-workspaces-v0.8.0) - 2023-10-04

- [**breaking**] renamed crate to near-workspaces to avoid confusion with Cargo workspaces; imports should now use `near_workspaces` instead of just `workspaces` ([#318](https://github.com/near/near-workspaces-rs/pull/318))
- [Upgraded to Rust Stable Toolchain](https://github.com/near/near-workspaces-rs/commit/8d93197d06aee2a426b6da99e270ce1658c2cd4f). Deprecates requirement of only using rustc-1.69 and lower.

### Added

- [Import a couple functions over from near_crypto for PublicKey](https://github.com/near/workspaces-rs/pull/265)
  - Impl `Ord`, `PartialOrd`, `Hash`, `BorshSerialize`, `BorshDeserialize`, `Display`, and `FromStr` for `PublicKey`
    - NOTE: Borsh bytes format is the same as near-sdk, where it is in the form of [bytes_len, key_type, key_data..]
  - Added `PublicKey::{empty, len, key_data}`
  - Impl `Display` for `SecretKey`.
  - more docs were added to both `SecretKey` and `PublicKey`.
  - Impl `Display`, `FromStr`, `TryFrom<u8>` for `KeyType`.
- [Added `TryFrom<near_sdk::PublicKey>` for `workspaces::PublicKey`](https://github.com/near/workspaces-rs/pull/267)
  - Added `KeyType::len` and `PublicKey::try_from_bytes`
- [Added experimental apis from near-sdk-rs](https://github.com/near/near-workspaces-rs/pull/285), available under the **experimental** flag.
  - Methods added are: EXPERIMENTAL_changes_in_block, EXPERIMENTAL_changes, EXPERIMENTAL_genesis_config, EXPERIMENTAL_protocol_config, EXPERIMENTAL_receipt, EXPERIMENTAL_tx_status, EXPERIMENTAL_validators_ordered
- [Added Worker::patch to patch account, keys, code, and state in a generic builder](https://github.com/near/near-workspaces-rs/pull/291)
  - Added `Worker::patch` and `PatchTransaction` that provide builders for patching accounts, keys, code, and state.
  - Added `AccountDetails` and `AccountDetailsPatch` which hold the state of the patch.
- Allow to select a specific version of near-sandbox ([#311](https://github.com/near/near-workspaces-rs/pull/311))
- Enable support for RPCs that require API keys and support for custom networks ([#306](https://github.com/near/near-workspaces-rs/pull/306))
- expose more `Block` and `Chunk` fields ([#243](https://github.com/near/near-workspaces-rs/pull/243))
- support manually supplied validator key ([#274](https://github.com/near/near-workspaces-rs/pull/274))

### Changed

- [`Transaction::transact_async` no longer has a lifetime parameter to make it easier to use](https://github.com/near/workspaces-rs/pull/249)
- [Improved error message on calling a json on a void function](https://github.com/near/near-workspaces-rs/pull/286)
- [Removed serde-arbitrary-precision feature in examples](https://github.com/near/near-workspaces-rs/pull/287)

### Fixed

- improve error msg on calling `json` on void function ([#286](https://github.com/near/near-workspaces-rs/pull/286))
- fix typos ([#280](https://github.com/near/near-workspaces-rs/pull/280))
- Run `neard` on `localhost` instead of `0.0.0.0` to prevent firewall popups on MacOS ([#277](https://github.com/near/near-workspaces-rs/pull/277))
- storing credentials ([#258](https://github.com/near/near-workspaces-rs/pull/258))
- Make call consistent with worker::view ([#245](https://github.com/near/near-workspaces-rs/pull/245))

### Other

- drop async-process in favor of tokio ([#316](https://github.com/near/near-workspaces-rs/pull/316))
- switch to `near-gas` crate for Gas where possible ([#305](https://github.com/near/near-workspaces-rs/pull/305))
- Improved fast_forward docs ([#299](https://github.com/near/near-workspaces-rs/pull/299))
- Added test for delete_account ([#289](https://github.com/near/near-workspaces-rs/pull/289))
- Added a test for transfer_near ([#290](https://github.com/near/near-workspaces-rs/pull/290))
- using url return type ([#297](https://github.com/near/near-workspaces-rs/pull/297))
- dependencies and removed unused deps ([#292](https://github.com/near/near-workspaces-rs/pull/292))
- upgrade to stable toolchain ([#293](https://github.com/near/near-workspaces-rs/pull/293))
- Updated near deps to 0.17 ([#283](https://github.com/near/near-workspaces-rs/pull/283))
- Use cargo-near to build project ([#275](https://github.com/near/near-workspaces-rs/pull/275))
- Added network builder for mainnet, testnet, betanet ([#221](https://github.com/near/near-workspaces-rs/pull/221))
- bump borsh version and other deps ([#271](https://github.com/near/near-workspaces-rs/pull/271))
- bump sandbox to 0.6.2 ([#270](https://github.com/near/near-workspaces-rs/pull/270))
- Import some functions over from near_crypto for PublicKey ([#265](https://github.com/near/near-workspaces-rs/pull/265))
- Added destination account-id for `import_contract` call ([#260](https://github.com/near/near-workspaces-rs/pull/260))
- Fix port collision ([#257](https://github.com/near/near-workspaces-rs/pull/257))
- Removed the lifetime in transact_async ([#249](https://github.com/near/near-workspaces-rs/pull/249))
- configure sandbox ([#251](https://github.com/near/near-workspaces-rs/pull/251))

## [0.7.0]

### Added

- [`view_*` asynchronous builders have been added which provides being able to query from a specific block hash or block height](https://github.com/near/workspaces-rs/pull/218)
- [`{CallTransaction, Transaction}::transact_async` for performing transactions without directly having to wait for it complete it on chain](https://github.com/near/workspaces-rs/pull/222)
- [`view_chunk` added for querying into chunk related info on the network.](https://github.com/near/workspaces-rs/pull/234)
  - Adds `Chunk` and `ChunkHeader` type to reference specific chunk info.
- [`Error::{simple, message, custom}` are now public and usable for custom errors](https://github.com/near/workspaces-rs/pull/224)

### Changed

- [Apart of the changes from adding `view_*` async builders, we have a couple breaking changes to the `view_*` functions](https://github.com/near/workspaces-rs/pull/218):
  - `{Account, Contract, Worker}::view_state` moved `prefix` parameter into builder. i.e.
    ```
    worker.view_state("account_id", Some(prefix)).await?;
    // is now
    worker.view_state("account_id")
        .prefix(prefix)
        .await?;
    // if prefix was `None`, then simply delete the None argument.
    ```
  - `view` function changed to be a builder, and no longer take in `args` as a parameter. It instead has been moved to the builder side.
  - Changed `Worker::view_latest_block` to `Worker::view_block` as the default behavior is equivalent.
  - `operations::Function` type no longer takes a lifetime parameter.
  - `operations::CallTransaction` type takes one less lifetime parameter.
- [`Worker::call` signature changed to be more in line with `view_*` async builders. It will now return a builder like `{Account, Contract}::call`](https://github.com/near/workspaces-rs/pull/245)
  - This `call` no longer accepts `Contract` since that was not as accessible. Instead a `InMemorySigner` is now required to sign transactions (which can be retrieved from `{Account, Contract}::signer` or `InMemorySigner::{from_secret_key, from_file}`).
  - `{Account, Contract}::signer` now exposed.

### Fixed

- [Changed the docs to reflect proper size of of rate limits on near.org RPC](https://github.com/near/workspaces-rs/pull/219)
- [Cached nonces now are per account-id and public-key instead of just public-key](https://github.com/near/workspaces-rs/pull/231)
  - this didn't matter if only one KeyPair was being used per account, but could be problematic when there were multiple KeyPairs per account utilizing the same nonces.
- [Error message context wasn't being exposed properly by sandbox, so this fixed it](https://github.com/near/workspaces-rs/pull/236)

## [0.6.1]

### Fixed

- Fixed query variant error when supply invalid function name or arguments: https://github.com/near/workspaces-rs/pull/239

## [0.6.0]

### Added

- `Account::view` API exposed: https://github.com/near/workspaces-rs/pull/202

### Changed

- Unstable `compile_project` uses new the workspaces errors: https://github.com/near/workspaces-rs/pull/204
- `ValueOrReceiptId::Value(String)` changed to `ValueOrReceiptId::Value(Value)`: https://github.com/near/workspaces-rs/pull/208
  - `Value` type offers convenient APIs like `raw_bytes`, `json`, and `borsh` like one would find from a `ExecutionFinalResult`.
- internal dependencies like near-jsonrpc-client upgraded to 0.4.0 from 0.4.0-beta: https://github.com/near/workspaces-rs/pull/210
  - Note, the RNG for `SecretKey::{from_random, from_seed}(KeyType::SECP256K1, ...)` has been changed as well, and will produce different keys than before.

### Fixed

- `docs.rs` now shows `unstable` feature flag: https://github.com/near/workspaces-rs/pull/198
- No longer orphaning sandbox processes on early termination of tests: https://github.com/near/workspaces-rs/pull/205
- Fixed sandbox colliding installs: https://github.com/near/workspaces-rs/pull/211
- sandbox no longer spamming stats logs: https://github.com/near/workspaces-rs/pull/213

## [0.5.0]

### Added

- Error handling with opaque `workspaces::error::Error` type: https://github.com/near/workspaces-rs/pull/149
- Require `#[must_use]` on the Execution value returned by `transact()`: https://github.com/near/workspaces-rs/pull/150
  - Added `ExecutionFinalResult`, `ExecutionResult`, `ExecutionSuccess` and `ExecutionFailure` types
  - Added `into_result()` to easily handle `#[must_use] ExecutionFinalResult`
  - Added `unwrap()` to not care about Err variant in `ExecutionResult`s

### Changed

- Renamed CallExecution\* types: https://github.com/near/workspaces-rs/pull/150
  - Renamed ` CallExecution`` to  `Execution`
  - Renamed `CallExecutionDetails` to `ExecutionFinalResult`
- `args_json` and `args_borsh` no longer return `Result`s and are deferred till later when `transact()`ed: https://github.com/near/workspaces-rs/pull/149
- API changes from removing `worker` parameter from function calls: https://github.com/near/workspaces-rs/pull/181
  - `Account::from_file` function signature change, requiring a `&worker` to be passed in.
  - `workspaces::prelude::*` import no longer necessary, where we no longer able to import `workspaces::prelude::DevAccountDeployer` directly.

### Removed

- Removed impls from exection result: https://github.com/near/workspaces-rs/pull/150
  - Removed `impl<T> From<CallExecution<T>> for Result<T>`
  - Removed `impl From<FinalExecutionOutcomeView> for CallExecutionDetails`
- No longer require `worker` to be passed in for each transaction: https://github.com/near/workspaces-rs/pull/181

### Fixed

- Gas estimation issue resolved with latest sandbox node (Aug 29, 2022): https://github.com/near/workspaces-rs/pull/188
- Fixed parallel tests, where calling into the same contract would require waiting on a previous call: https://github.com/near/workspaces-rs/pull/173

## [0.4.1] - 2022-08-16

### Added

- Derive `Eq` on `AccountDetails` type: https://github.com/near/workspaces-rs/pull/177/files

### Fixed

- Fix macOS non-deterministic overflow error when starting up sandbox: https://github.com/near/workspaces-rs/pull/179

## [0.4.0] - 2022-07-20

### Added

- Mac M1 Support: https://github.com/near/workspaces-rs/pull/169
- Added `Account::secret_key` to grab the account's secret key: https://github.com/near/workspaces-rs/pull/144
- `Debug`/`Clone` impls for `Account`/`Contract`, and `Debug` for `Worker`: https://github.com/near/workspaces-rs/pull/167
- `ExecutionOutcome::tokens_burnt` is now available: https://github.com/near/workspaces-rs/pull/168

### Fixed

- internally no longer creating a new RPC client per call: https://github.com/near/workspaces-rs/pull/154
- upped near dependencies to fix transitive vulnerabilities: https://github.com/near/workspaces-rs/pull/169

### Changed

- Default sandbox version is now using commit hash master/13a66dda709a4148f6395636914dca2a55df1390 (July 18, 2022): https://github.com/near/workspaces-rs/pull/169

## [0.3.1] - 2022-06-20

### Added

- Raw bytes API similar to `json`/`borsh` calls: https://github.com/near/workspaces-rs/pull/133/files
- Expose `types` module and added `SecretKey` creation: https://github.com/near/workspaces-rs/pull/139

### Fixed

- If sandbox gets started multiple times, short circuit it early on: https://github.com/near/workspaces-rs/pull/135
- Fix short timeouts on connecting to RPC for macos with custom env variable to specify timeout if needed: https://github.com/near/workspaces-rs/pull/143

## [0.3.0] - 2022-05-10

### Added

- Added betanet support https://github.com/near/workspaces-rs/pull/116

### Changed

- Updated default sandbox version to `97c0410de519ecaca369aaee26f0ca5eb9e7de06` commit of nearcore to include 1.26 protocol changes https://github.com/near/workspaces-rs/pull/134

- Exposed `CallExecutionDetails::raw_bytes` API: https://github.com/near/workspaces-rs/pull/133

## [0.2.1] - 2022-04-12

### Added

- Added more docs to top level or exposed types/functions: https://github.com/near/workspaces-rs/pull/115

### Fixed

- Fix `docs.rs` builds failing on sandbox install: https://github.com/near/workspaces-rs/pull/115

## [0.2.0] - 2022-04-05

### Added

- Time-traveling - the ability to go forwards in block height within tests. This allows to test time specific data changing within contracts: https://github.com/near/workspaces-rs/pull/73
- Credentials created from account/contract creation are now allowed to be stored and specified by users. https://github.com/near/workspaces-rs/pull/98
- [Unstable] Allow users to compile contract projects within tests without having to manually go through this step. https://github.com/near/workspaces-rs/pull/77
- Batch transactions or transactions with multiple actions are now possible. https://github.com/near/workspaces-rs/pull/72
- Sandbox node (nearcore binary) logs are now suppressed and can be re-enabled if desired. https://github.com/near/workspaces-rs/pull/85
- Results now expose logs, receipts, and transaction outcome values. https://github.com/near/workspaces-rs/pull/70
- Convenience methods `Worker::view_code`, `Worker::view_latest_block`, `Worker::view_account`, `Account::view_account`, `Contract::view_account`, `Contract::view_code` now available. https://github.com/near/workspaces-rs/pull/82
- Improve error handling. If a transaction fails, this error will now be apart of the `Result` return initially. https://github.com/near/workspaces-rs/pull/83
- Added `tracing` logging to internal code and examples. https://github.com/near/workspaces-rs/pull/55 and https://github.com/near/workspaces-rs/pull/75
- Convenient `CallExecutionDetails::{is_success, is_failure}` for testing outcomes of transactions. https://github.com/near/workspaces-rs/pull/58
- Added `mainnet_archival` and `testnet_archival`, where `ref-finance` example now uses `mainnet_archival`. https://github.com/near/workspaces-rs/pull/57 and https://github.com/near/workspaces-rs/pull/94

### Changed

- key type for `patch_state` now a slice and no longer require `StoreKey`. https://github.com/near/workspaces-rs/pull/109
- Reorganized imports internally for better maintainability. https://github.com/near/workspaces-rs/pull/102
- No longer running into non-deterministic query failures if RPC isn't available, but this is a breaking API. All `workspaces::{sandbox, testnet, mainnet}` now require `.await?` at the end. https://github.com/near/workspaces-rs/pull/99
- TLA trait no longer apart of all networks -- only dev-networks (sandbox, testnet). https://github.com/near/workspaces-rs/pull/101
- Retry times have now been shorten and should take a maximum of 1 second. https://github.com/near/workspaces-rs/pull/92
- doc builds on [docs.rs](https://docs.rs) has now been fixed. https://github.com/near/workspaces-rs/pull/90
- `patch_state` now takes in slices. https://github.com/near/workspaces-rs/pull/80 and https://github.com/near/workspaces-rs/pull/79
- Make `access_key` call do optimistic queries which led to better retry times. https://github.com/near/workspaces-rs/pull/60
- Functions no longer take in owned but referenced `AccountId`s now. https://github.com/near/workspaces-rs/pull/52

### Removed

- Empty JSON array is no longer a valid default argument supplied to transactions. Recommended to supply empty `{}` in the case of JSON if all function arguments in the contract are optional types. https://github.com/near/workspaces-rs/pull/84

## [0.1.1] - 2021-01-24

### Changed

- Fix race condition when installing sandbox and running multiples tests at the same time. https://github.com/near/workspaces-rs/pull/46

[unreleased]: https://github.com/near/workspaces-rs/compare/0.7.0...HEAD
[0.7.0]: https://github.com/near/workspaces-rs/compare/0.6.1...0.7.0
[0.6.1]: https://github.com/near/workspaces-rs/compare/0.6.0...0.6.1
[0.6.0]: https://github.com/near/workspaces-rs/compare/0.5.0...0.6.0
[0.5.0]: https://github.com/near/workspaces-rs/compare/0.4.1...0.5.0
[0.4.1]: https://github.com/near/workspaces-rs/compare/0.4.0...0.4.1
[0.4.0]: https://github.com/near/workspaces-rs/compare/0.3.1...0.4.0
[0.3.1]: https://github.com/near/workspaces-rs/compare/0.3.0...0.3.1
[0.3.0]: https://github.com/near/workspaces-rs/compare/0.2.1...0.3.0
[0.2.1]: https://github.com/near/workspaces-rs/compare/0.2.0...0.2.1
[0.2.0]: https://github.com/near/workspaces-rs/compare/0.1.1...0.2.0
[0.1.1]: https://github.com/near/workspaces-rs/compare/0.1.0...0.1.1
[0.1.0]: https://github.com/near/workspaces-rs/releases/tag/0.1.0

'''
'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

- Using welcoming and inclusive language
- Being respectful of differing viewpoints and experiences
- Gracefully accepting constructive criticism
- Focusing on what is best for the community
- Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

- The use of sexualized language or imagery and unwelcome sexual attention or
  advances
- Trolling, insulting/derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or electronic
  address, without explicit permission
- Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at social@nearprotocol.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq

'''
'''--- CONTRIBUTING.md ---
# Contributing to workspaces-rs

Thank you for your interest in contributing to NEAR's Rust Workspaces! We appreciate any type of contribution.

Below are various bits of information to help you get started. If you require additional help, please reach out to us on the `Rust Support` channel on [discord](https://discord.gg/nearprotocol) or our [zulip channel](https://near.zulipchat.com/)

## Quick Start

`workspaces-rs` is like any other rust project so we can easily get started by doing `cargo build`.

## Code of Conduct

We have an open and welcoming environment, please review our [code of conduct](CODE_OF_CONDUCT.md).

## Development

### Architecture

The current design of workspaces is mostly just a client communicating to an RPC service. For mainnet/testnet, this is just pointing the client to the `near.org` RPCs for each of them respectively. For sandbox, this is a little more involved where we spin up a local sandbox node when a user directly calls into `workspaces::sandbox()`. A `Worker` is considered the client and main way to interact with each of these networks. It offers a single interface into calling common RPC calls between all the networks, and also allowing for specific features for each network.

### Commits

Please use descriptive PR titles. We loosely follow the [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/) style, but this is not a requirement to follow exactly. PRs will be addressed more quickly if it is clear what the intention is.

### Before opening a PR

Ensure the following are satisfied before opening a PR:

- Code is formatted with `rustfmt` by running `cargo fmt`
- Run `cargo clippy`
- Run tests with `cargo test`
- Ensure any new functionality is adequately tested
- If any new public types or functions are added, ensure they have appropriate [rustdoc](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html) documentation
- Add an entry to the CHANGELOG.md
- Optional. Consider running the actions locally to ensure they pass. See [here](https://github.com/nektos/act).

'''
'''--- Cargo.toml ---
[workspace]
members = [
    "workspaces",
    "examples",
]

'''
'''--- README.md ---
<div align="center">

  <h1>NEAR Workspaces (Rust Edition)</h1>

  <p>
    <strong>Rust library for automating workflows and writing tests for NEAR smart contracts. This software is not final, and will likely change.</strong>
  </p>

  <p>
    <a href="https://crates.io/crates/near-workspaces"><img src="https://img.shields.io/crates/v/near-workspaces.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-workspaces"><img src="https://img.shields.io/crates/d/near-workspaces.svg?style=flat-square" alt="Download" /></a>
    <a href="https://docs.rs/near-workspaces"><img src="https://docs.rs/near-workspaces/badge.svg" alt="Reference Documentation" /></a>
  </p>
</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Requirements

- Rust v1.69.0 and up.
- MacOS (x86 and M1) or Linux (x86) for sandbox tests.

### WASM compilation not supported

`near-workspaces-rs`, the library itself, does not currently compile to WASM. Best to put this dependency in `[dev-dependencies]` section of `Cargo.toml` if we were trying to run this library alongside something that already does compile to WASM, such as `near-sdk-rs`.

## Simple Testing Case

A simple test to get us going and familiar with `near-workspaces` framework. Here, we will be going through the NFT contract and how we can test it with `near-workspaces-rs`.

### Setup -- Imports

First, we need to declare some imports for convenience.

```rust
// macro allowing us to convert args into JSON bytes to be read by the contract.
use serde_json::json;
```

We will need to have our pre-compiled WASM contract ahead of time and know its path. Refer to the respective near-sdk-{rs, js} repos/language for where these paths are located.

In this showcase, we will be pointing to the example's NFT contract:

```rust
const NFT_WASM_FILEPATH: &str = "./examples/res/non_fungible_token.wasm";
```

NOTE: there is an unstable feature that will allow us to compile our projects during testing time as well. Take a look at the feature section [Compiling Contracts During Test Time](#compiling-contracts-during-test-time)

### Setup -- Setting up Sandbox and Deploying NFT Contract

This includes launching our sandbox, loading our wasm file and deploying that wasm file to the sandbox environment.

```rust

#[tokio::test]
async fn test_nft_contract() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;
```

Where

- `anyhow` - A crate that deals with error handling, making it more robust for developers.
- `worker` - Our gateway towards interacting with our sandbox environment.
- `contract`- The deployed contract on sandbox the developer interacts with.

### Initialize Contract & Test Output

Then we'll go directly into making a call into the contract, and initialize the NFT contract's metadata:

```rust
    let outcome = contract
        .call("new_default_meta")
        .args_json(json!({
            "owner_id": contract.id(),
        }))
        .transact()  // note: we use the contract's keys here to sign the transaction
        .await?;

    // outcome contains data like logs, receipts and transaction outcomes.
    println!("new_default_meta outcome: {:#?}", outcome);
```

Afterwards, let's mint an NFT via `nft_mint`. This showcases some extra arguments we can supply, such as deposit and gas:

```rust
    use near_gas::NearGas;
    use near_workspaces::types::NearToken;

    let deposit = NearToken::from_near(100);
    let outcome = contract
        .call("nft_mint")
        .args_json(json!({
            "token_id": "0",
            "token_owner_id": contract.id(),
            "token_metadata": {
                "title": "Olympus Mons",
                "description": "Tallest mountain in charted solar system",
                "copies": 1,
            },
        }))
        .deposit(deposit)
        // nft_mint might consume more than default gas, so supply our own gas value:
        .gas(NearGas::from_tgas(300))
        .transact()
        .await?;

    println!("nft_mint outcome: {:#?}", outcome);
```

Then later on, we can view our minted NFT's metadata via our `view` call into `nft_metadata`:

```rust
    let result: serde_json::Value = contract
        .call("nft_metadata")
        .view()
        .await?
        .json()?;

    println!("--------------\n{}", result);
    println!("Dev Account ID: {}", contract.id());
    Ok(())
}
```

### Updating Contract Afterwards

Note that if our contract code changes, `near-workspaces-rs` does nothing about it since we are utilizing `deploy`/`dev_deploy` to merely send the contract bytes to the network. So if it does change, we will have to recompile the contract as usual, and point `deploy`/`dev_deploy` again to the right WASM files. However, there is a feature that will recompile contract changes for us: refer to the experimental/unstable [`compile_project`](#compiling-contracts-during-test-time) function for telling near-workspaces to compile a _Rust_ project for us.

## Examples

More standalone examples can be found in `examples/src/*.rs`.

To run the above NFT example, execute:

```sh
cargo run --example nft
```

## Features

### Choosing a network

```rust
#[tokio::main]  // or whatever runtime we want
async fn main() -> anyhow::Result<()> {
    // Create a sandboxed environment.
    // NOTE: Each call will create a new sandboxed environment
    let worker = near_workspaces::sandbox().await?;
    // or for testnet:
    let worker = near_workspaces::testnet().await?;
}
```

### Helper Functions

Need to make a helper functions utilizing contracts? Just import it and pass it around:

```rust
use near_workspaces::Contract;

// Helper function that calls into a contract we give it
async fn call_my_func(contract: &Contract) -> anyhow::Result<()> {
    // Call into the function `contract_function` with args:
    contract.call("contract_function")
        .args_json(serde_json::json!({
            "message": msg,
        })
        .transact()
        .await?;
    Ok(())
}
```

Or to pass around workers regardless of networks:

```rust
use near_workspaces::{DevNetwork, Worker};

const CONTRACT_BYTES: &[u8] = include_bytes!("./relative/path/to/file.wasm");

// Create a helper function that deploys a specific contract
// NOTE: `dev_deploy` is only available on `DevNetwork`s such as sandbox and testnet.
async fn deploy_my_contract(worker: Worker<impl DevNetwork>) -> anyhow::Result<Contract> {
    worker.dev_deploy(CONTRACT_BYTES).await
}
```

### View Account Details

We can check the balance of our accounts like so:

```rs
#[test(tokio::test)]
async fn test_contract_transfer() -> anyhow::Result<()> {
    let transfer_amount = NearToken::from_millinear(100);
    let worker = near_workspaces::sandbox().await?;

    let contract = worker
        .dev_deploy(include_bytes!("../target/res/your_project_name.wasm"))
        .await?;
    contract.call("new")
        .max_gas()
        .transact()
        .await?;

    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let bob_original_balance = bob.view_account().await?.balance;

    alice.call(contract.id(), "function_that_transfers")
        .args_json(json!({ "destination_account": bob.id() }))
        .max_gas()
        .deposit(transfer_amount)
        .transact()
        .await?;
    assert_eq!(
        bob.view_account().await?.balance,
        bob_original_balance + transfer_amount
    );

    Ok(())
}
```

For viewing other chain related details, look at the docs for [Worker](https://docs.rs/near-workspaces/latest/near_workspaces/struct.Worker.html), [Account](https://docs.rs/near-workspaces/latest/near_workspaces/struct.Account.html) and [Contract](https://docs.rs/near-workspaces/latest/near_workspaces/struct.Contract.html)

### Spooning - Pulling Existing State and Contracts from Mainnet/Testnet

This example will showcase spooning state from a testnet contract into our local sandbox environment.

We will first start with the usual imports:

```rust
use near_workspaces::network::Sandbox;
use near_workspaces::{Account, AccountId, BlockHeight, Contract, Worker};
```

Then specify the contract name from testnet we want to be pulling:

```rust
const CONTRACT_ACCOUNT: &str = "contract_account_name_on_testnet.testnet";
```

Let's also specify a specific block ID referencing back to a specific time. Just in case our contract or the one we're referencing has been changed or updated:

```rust
const BLOCK_HEIGHT: BlockHeight = 12345;
```

Create a function called `pull_contract` which will pull the contract's `.wasm` file from the chain and deploy it onto our local sandbox. We'll have to re-initialize it with all the data to run tests.

```rust
async fn pull_contract(owner: &Account, worker: &Worker<Sandbox>) -> anyhow::Result<Contract> {
    let testnet = near_workspaces::testnet_archival().await?;
    let contract_id: AccountId = CONTRACT_ACCOUNT.parse()?;
```

This next line will actually pull down the relevant contract from testnet and set an initial balance on it with 1000 NEAR.

Following that we will have to init the contract again with our own metadata. This is because the contract's data is to big for the RPC service to pull down, who's limits are set to 50kb.

```rust

    use near_workspaces::types::NearToken;
    let contract = worker
        .import_contract(&contract_id, &testnet)
        .initial_balance(NearToken::from_near(1000))
        .block_height(BLOCK_HEIGHT)
        .transact()
        .await?;

    owner
        .call(contract.id(), "init_method_name")
        .args_json(serde_json::json!({
            "arg1": value1,
            "arg2": value2,
        }))
        .transact()
        .await?;

    Ok(contract)
}
```

### Time Traveling

`workspaces` testing offers support for forwarding the state of the blockchain to the future. This means contracts which require time sensitive data do not need to sit and wait the same amount of time for blocks on the sandbox to be produced. We can simply just call `worker.fast_forward` to get us further in time.
Note: This is not to be confused with speeding up the current in-flight transactions; the state being forwarded in this case refers to time-related state (the block height, timestamp and epoch).

```rust
#[tokio::test]
async fn test_contract() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker.dev_deploy(WASM_BYTES).await?;

    let blocks_to_advance = 10000;
    worker.fast_forward(blocks_to_advance).await?;

    // Now, "do_something_with_time" will be in the future and can act on future time-related state.
    contract.call("do_something_with_time")
        .transact()
        .await?;
}
```

For a full example, take a look at [examples/src/fast_forward.rs](https://github.com/near/near-workspaces-rs/blob/main/examples/src/fast_forward.rs).

### Compiling Contracts During Test Time

Note, this is an unstable feature and will very likely change. To enable it, add the `unstable` feature flag to `workspaces` dependency in `Cargo.toml`:

```toml
[dependencies]
near-workspaces = { version = "...", features = ["unstable"] }
```

Then, in our tests right before we call into `deploy` or `dev_deploy`, we can compile our projects:

```rust
#[tokio::test]
async fn test_contract() -> anyhow::Result<()> {
    let wasm = near_workspaces::compile_project("path/to/contract-rs-project").await?;

    let worker = workspaces::sandbox().await?;
    let contract = worker.dev_deploy(&wasm).await?;
    ...
}
```

For a full example, take a look at [workspaces/tests/deploy_project.rs](https://github.com/near/near-workspaces-rs/blob/main/workspaces/tests/deploy_project.rs).

### Coverage analysis of WASM executables

Generated code coverage reports help identify areas of code that are executed during testing, making it a valuable tool for ensuring the reliability and quality of your contracts.
[Here](https://hknio.github.io/wasmcov/docs/NEAR) is the step by step guide documentation to achieve this.

The project can be found here: <https://github.com/hknio/wasmcov>

### Other Features

Other features can be directly found in the `examples/` folder, with some documentation outlining how they can be used.

### Environment Variables

These environment variables will be useful if there was ever a snag hit:

- `NEAR_RPC_TIMEOUT_SECS`: The default is 10 seconds, but this is the amount of time before timing out waiting for a RPC service when talking to the sandbox or any other network such as testnet.
- `NEAR_SANDBOX_BIN_PATH`: Set this to our own prebuilt `neard-sandbox` bin path if we want to use a non-default version of the sandbox or configure nearcore with our own custom features that we want to test in near-workspaces.
- `NEAR_SANDBOX_MAX_PAYLOAD_SIZE`: Sets the max payload size for sending transaction commits to sandbox. The default is 1gb and is necessary for patching large states.
- `NEAR_SANDBOX_MAX_FILES`: Set the max amount of files that can be opened at a time in the sandbox. If none is specified, the default size of 4096 will be used. The actual near chain will use over 10,000 in practice, but for testing this should be much lower since we do not have a constantly running blockchain unless our tests take up that much time.
- `NEAR_RPC_API_KEY`: This is the API key necessary for communicating with RPC nodes. This is useful when interacting with services such as Pagoda Console or a service that can access RPC metrics. This is not a **hard** requirement, but it is recommended to running the Pagoda example in the examples folder.
- `NEAR_ENABLE_SANDBOX_LOG`: Set this to `1` to enable sandbox logging. This is useful for debugging issues with the `neard-sandbox` binary.

'''
'''--- examples/Cargo.toml ---
[package]
name = "examples"
version = "0.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
maplit = "1.0"
near-units = "0.2.0"
near-gas = { version = "0.2.5", features = ["serde", "borsh", "schemars"] }
near-jsonrpc-primitives = "0.20.0"
near-primitives = "0.20.0"
serde = "1.0"
serde_with = "3.4"
serde_json = { version = "1.0" }
tokio = { version = "1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.5", features = ["env-filter"] }
near-workspaces = { path = "../workspaces", features = [
    "experimental",
    "unstable",
] }

[build-dependencies]
anyhow = "1.0"
near-workspaces = { path = "../workspaces" }

[[example]]
name = "async_transaction"
path = "src/async_transaction.rs"

[[example]]
name = "nft"
path = "src/nft.rs"

[[example]]
name = "status_message"
path = "src/status_message.rs"

[[example]]
name = "spooning"
path = "src/spooning.rs"

[[example]]
name = "ref_finance"
path = "src/ref_finance.rs"

[[example]]
name = "fast_forward"
path = "src/fast_forward.rs"

[[example]]
name = "croncat"
path = "src/croncat.rs"

[[example]]
name = "various_queries"
path = "src/various_queries.rs"

[[example]]
name = "genesis_config"
path = "src/genesis_config.rs"

[[example]]
name = "validators_ordered"
path = "src/validators_ordered.rs"

[[example]]
name = "protocol_config"
path = "src/protocol_config.rs"

[[example]]
name = "changes_in_block"
path = "src/changes_in_block.rs"

[[example]]
name = "changes"
path = "src/changes.rs"

[[example]]
name = "receipt"
path = "src/receipt.rs"

[[example]]
name = "tx_status"
path = "src/tx_status.rs"

[[example]]
name = "noop"
path = "src/noop.rs"

[[example]]
name = "custom_network"
path = "src/custom_network.rs"

[[example]]
name = "build_gen_abi"
path = "src/build_gen_abi.rs"

[[example]]
name = "macro_gen_abi"
path = "src/macro_gen_abi.rs"

'''
'''--- examples/build.rs ---
fn main() -> anyhow::Result<()> {
    near_workspaces::near_abi_client::Generator::new("src/gen".into())
        .file("res/adder.json")
        .generate()?;
    Ok(())
}

'''
'''--- examples/manually-spawned-sandbox.md ---
# Utilizing custom sandbox node

This example will show us how to spin up a sandbox node of our own choosing. Follow the guide in <https://github.com/near/sandbox> to download it. This is mainly needed if a user wants to manage their own node and/or not require each test to spin up a new node each time.

Then initialize the chain via `init` and run it:

```sh
near-sandbox --home ${MY_HOME_DIRECTORY} init
near-sandbox --home ${MY_HOME_DIRECTORY} run
```

This will launch the chain onto `localhost:3030` by default. The `${MY_HOME_DIRECTORY}` is a path of our choosing here and this will be needed when running the workspaces code later on. In the following example, we had it set to `/home/user/.near-sandbox-home`.

In workspaces, to connect to our manually launched node, all we have to do is add a few additional parameters to `workspaces::sandbox()`:

```rs
#[tokio::main]
fn main() {
    let worker = workspaces::sandbox()
        .rpc_addr("http://localhost:3030")
        .home_dir("/home/user/.near-sandbox-home")
        .await?;

    Ok(())
}
```

Then afterwards, we can continue performing our tests as we normally would if workspaces has spawned its own sandbox process.

'''
'''--- examples/noop-contract/Cargo.toml ---
[package]
name = "simple-contract"
version = "0.1.0"
publish = false
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "5.0.0-alpha.2"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- examples/noop-contract/src/lib.rs ---
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::near_bindgen;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
#[borsh(crate = "near_sdk::borsh")]
pub struct Noop;

#[near_bindgen]
impl Noop {
    pub fn noop() {}
}

'''
'''--- examples/res/adder.json ---
{
  "schema_version": "0.4.0",
  "metadata": {
    "name": "abi",
    "version": "0.1.0",
    "authors": [
      "Near Inc <hello@nearprotocol.com>"
    ]
  },
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}
'''
'''--- examples/simple-contract/Cargo.toml ---
[package]
name = "simple-contract"
version = "0.1.0"
publish = false
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "5.0.0-alpha.2"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

'''
'''--- examples/simple-contract/src/lib.rs ---
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen};

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
#[borsh(crate = "near_sdk::borsh")]
pub struct Simple {}

#[near_bindgen]
impl Simple {
    pub fn current_env_data() -> (u64, u64) {
        let now = env::block_timestamp();
        let eh = env::epoch_height();
        log!("Timestamp: {}", now);
        (now, eh)
    }
}

'''
'''--- examples/src/async_transaction.rs ---
const STATUS_MSG_WASM_FILEPATH: &str = "./examples/res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let status = contract
        .call("set_status")
        .args_json(serde_json::json!({
            "message": "hello_world",
        }))
        .transact_async()
        .await?;

    let outcome = status.await;
    println!(
        "Async transaction result from setting hello world: {:#?}",
        outcome
    );

    Ok(())
}

'''
'''--- examples/src/build_gen_abi.rs ---
// This example shows how to use the `near_abi_client` Generation Based API.
// We are generating client code using the schema for the ABI and and `workspaces-rs` to call into the contract.
// More information about usage can be found here: <https://github.com/near/near-abi-client-rs/blob/main/README.md>
//
// A good scenario for usage might be when you are interacting with a contract or multiple contracts at an automated level
// and you want to have a type-safe way of interacting with them.

/// The generated api requires setup in the `build.rs` file to generate the client code.
#[path = "gen/adder.rs"]
mod generation_adder;

const ADDER_WASM_FILEPATH: &str = "./examples/res/adder.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(ADDER_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // The client is initialized with the contract.
    let abi_client = generation_adder::AbiClient { contract };

    // Here we can call the method, now typed with arguments and return types.
    let res = abi_client.add(vec![1, 2], vec![3, 4]).await?;

    assert_eq!(res, [4, 6]);
    Ok(())
}

'''
'''--- examples/src/changes.rs ---
use near_primitives::{types::BlockReference, views::StateChangesRequestView};
use serde_json::json;

const STATUS_MSG_WASM_FILEPATH: &str = "./examples/res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let outcome = contract
        .call("set_status")
        .args_json(json!({
            "message": "hello_world",
        }))
        .transact()
        .await?;

    let block_ref = {
        let hash = near_primitives::hash::CryptoHash(outcome.outcome().block_hash.0);
        BlockReference::BlockId(near_primitives::types::BlockId::Hash(hash))
    };

    let state_changes = {
        StateChangesRequestView::ContractCodeChanges {
            account_ids: vec![contract.id().clone()],
        }
    };

    // NOTE: this API is under the "experimental" flag and no guarantees are given.
    let res = worker.changes(block_ref, state_changes).await?;

    // Example output:
    //
    // StateChangesInBlock RpcStateChangesInBlockResponse {
    //     block_hash: 5SnL82tfQX1NtsSuqU5334ThZxM1B5KkUWUbeeMvVNRH,
    //     changes: [],
    // }
    println!("StateChangesInBlock {res:#?}");
    Ok(())
}

'''
'''--- examples/src/changes_in_block.rs ---
use near_primitives::types::BlockReference;
use serde_json::json;

const STATUS_MSG_WASM_FILEPATH: &str = "./examples/res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let outcome = contract
        .call("set_status")
        .args_json(json!({
            "message": "hello_world",
        }))
        .transact()
        .await?;

    let block_ref = {
        let hash = near_primitives::hash::CryptoHash(outcome.outcome().block_hash.0);
        BlockReference::BlockId(near_primitives::types::BlockId::Hash(hash))
    };

    // NOTE: this API is under the "experimental" flag and no guarantees are given.
    let res = worker.changes_in_block(block_ref).await?;

    // Example output:
    //
    // StateChangesInBlockByType RpcStateChangesInBlockByTypeResponse {
    //     block_hash: 7ifRdyBsJMXVyp8zw8uGdBMaRShiXuD6yghrp66jqrst,
    //     changes: [
    //         AccountTouched {
    //             account_id: AccountId(
    //                 "dev-20230822100117-44171728969098",
    //             ),
    //         },
    //         AccessKeyTouched {
    //             account_id: AccountId(
    //                 "dev-20230822100117-44171728969098",
    //             ),
    //         },
    //         DataTouched {
    //             account_id: AccountId(
    //                 "dev-20230822100117-44171728969098",
    //             ),
    //         },
    //     ],
    // }
    println!("StateChangesInBlockByType {res:#?}");
    Ok(())
}

'''
'''--- examples/src/croncat.rs ---
// This example will go over the croncat contracts found
// [here](https://github.com/CronCats/contracts/blob/cafd3caafb91b45abb6e811ce0fa2819980d6f96/manager/src/lib.rs)
// This will demonstrate a more involved example for fast-forwarding the blockchain to a future
// state/time. This is useful for testing anything that is time dependent such as scheduling
// This is perfect to showcase cron.cat which will schedule calling into contract functions
// at a set amount of time we supply.

use near_gas::NearGas;
use near_workspaces::network::Sandbox;
use near_workspaces::types::NearToken;
use near_workspaces::{Account, AccountId, Contract, Worker};
use serde::Deserialize;
use serde_json::json;
use serde_with::{serde_as, DisplayFromStr};

const MANAGER_CONTRACT: &[u8] = include_bytes!("../res/manager.wasm");
const COUNTER_CONTRACT: &[u8] = include_bytes!("../res/counter.wasm");

/// `AgentStatus` struct taken from [croncat repo](github.com/CronCats/contracts/) to
/// deserialize into after we get the result of a transaction and converting over to
/// this particular type.
#[derive(Debug, Deserialize, PartialEq, Eq)]
pub enum AgentStatus {
    Active,
    Pending,
}

/// `Agent` struct taken from [croncat repo](github.com/CronCats/contracts/) to deserialize
/// into after we get the result of a transaction and converting over to this particular type.
/// Helpful for understanding what our output is from a contract call. For a more in depth
/// look at what an `Agent` is all about, refer to the [croncat docs](https://docs.cron.cat/docs/)
/// to understand further, but for this example all we care about is that an Agent is something
/// that can run scheduled tasks once it is time and collect rewards thereafter.
#[serde_as]
#[derive(Debug, Deserialize)]
pub struct Agent {
    pub status: AgentStatus,
    pub payable_account_id: AccountId,
    // NOTE: DisplayFromStr is used to deserialize from a U128 type returned from the contract
    // which is represented as a string there, and then converted into a rust u128 here.
    pub balance: NearToken,
    #[serde_as(as = "DisplayFromStr")]
    pub total_tasks_executed: u128,
    pub last_missed_slot: u128,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Spawn sandbox as normal and get us a local blockchain for us to interact and toy with:
    let worker = near_workspaces::sandbox().await?;

    // Initialize counter contract, which will be pointed to in the manager contract to schedule
    // a task later to increment the counter, inside counter contract.
    let counter_contract = worker.dev_deploy(COUNTER_CONTRACT).await?;

    // deploy the manager contract so we can schedule tasks via our agents.
    let manager_contract = worker.dev_deploy(MANAGER_CONTRACT).await?;
    manager_contract
        .call("new")
        .transact()
        .await?
        .into_result()?;

    // Create a root croncat account with agent subaccounts to schedule tasks.
    let croncat = worker.dev_create_account().await?;

    // This will setup a task to call into the counter contract, with a cadence of 1 hour.
    println!("Creating task for `counter.increment`");
    let outcome = croncat
        .call(manager_contract.id(), "create_task")
        .args_json(json!({
            "contract_id": counter_contract.id(),
            "function_id": "increment",
            "cadence": "*/1 * * * * *",
            "recurring": true,
        }))
        .max_gas()
        .deposit(NearToken::from_near(1))
        .transact()
        .await?;
    println!("-- outcome: {:#?}\n", outcome);

    // Let's create an agent that will eventually execute the above task and get rewards
    // for executing it:
    let agent_1 = croncat
        .create_subaccount("agent_1")
        .initial_balance(NearToken::from_near(10))
        .transact()
        .await?
        .into_result()?;

    // Now with all the above setup complete, we can now have the agent run our task:
    run_scheduled_tasks(&worker, &manager_contract, &agent_1).await?;

    Ok(())
}

/// This function will schedule a particular task (`counter.increment`) and a single agent
/// will run that task to eventually get rewards.
pub async fn run_scheduled_tasks(
    worker: &Worker<Sandbox>,
    contract: &Contract,
    agent: &Account,
) -> anyhow::Result<()> {
    // Register the agent to eventually execute the task
    let outcome = agent
        .call(contract.id(), "register_agent")
        .args_json(json!({}))
        .deposit(NearToken::from_yoctonear(2260000000000000000000u128))
        .transact()
        .await?;
    println!("Registering agent outcome: {:#?}\n", outcome);

    // Check the right agent was registered correctly:
    let registered_agent = contract
        .call("get_agent")
        .args_json(json!({ "account_id": agent.id() }))
        .view()
        .await?
        .json::<Option<Agent>>()?
        .unwrap();
    println!("Registered agent details: {:#?}", registered_agent);
    assert_eq!(registered_agent.status, AgentStatus::Active);
    assert_eq!(&registered_agent.payable_account_id, agent.id());

    // Advance 4500 blocks in the chain. 1 block takes approx 1.5 seconds to be produced, but we
    // don't actually wait that long since we are time travelling to the future via `fast_forward`!
    // After this `fast_forward` call, we should be ahead by about an hour, and it is expected for
    // our agents to be able to execute the task we scheduled.
    println!("Waiting until next slot occurs...");
    worker.fast_forward(4500).await?;

    // Quick proxy call to earn a reward. Essentially telling the agent to execute the task
    // if it can. The time based conditions are checked right in the contract. We are in the future
    // here, so the agent should be executing the task.
    agent
        .call(contract.id(), "proxy_call")
        .gas(NearGas::from_tgas(200))
        .transact()
        .await?
        .into_result()?;

    // Do it again, just to show that this can be done multiple times since our task is a
    // recurring one that happens every hour:
    worker.fast_forward(4500).await?;
    agent
        .call(contract.id(), "proxy_call")
        .gas(NearGas::from_gas(200))
        .transact()
        .await?
        .into_result()?;

    // Check accumulated agent balance after completing our task. This value is held within
    // the manager contract, and we want to eventually withdraw this amount.
    let agent_details = contract
        .call("get_agent")
        .args_json(json!({"account_id": agent.id()}))
        .view()
        .await?
        .json::<Option<Agent>>()?
        .unwrap();
    println!("Agent details after completing task: {:#?}", agent_details);
    assert_eq!(
        agent_details.balance,
        NearToken::from_yoctonear(3860000000000000000000u128)
    );
    let before_withdraw = agent_details.balance;

    // Withdraw the reward from completing the task to our agent's account
    agent
        .call(contract.id(), "withdraw_task_balance")
        .transact()
        .await?
        .into_result()?;

    // Check accumulated agent balance to see that the amount has been taken out of the manager
    // contract:
    let agent_details = contract
        .call("get_agent")
        .args_json(json!({"account_id": agent.id() }))
        .view()
        .await?
        .json::<Option<Agent>>()?
        .unwrap();
    println!("Agent details after withdrawing task: {:#?}", agent_details);
    assert_eq!(
        agent_details.balance,
        NearToken::from_yoctonear(2260000000000000000000u128)
    );

    // This shows how much the agent has profited from executing the task:
    println!(
        "Agent profited {} yN and has been transferred to the agent's account",
        before_withdraw.as_yoctonear() - agent_details.balance.as_yoctonear()
    );

    // Not that everything is done, let's cleanup and unregister the agent from doing anything.
    agent
        .call(contract.id(), "unregister_agent")
        .deposit(NearToken::from_yoctonear(1))
        .transact()
        .await?
        .into_result()?;

    // Check to see if the agent has been successfully unregistered
    let removed_agent: Option<Agent> = contract
        .call("get_agent")
        .args_json(json!({ "account_id": agent.id() }))
        .view()
        .await?
        .json()?;
    assert!(
        removed_agent.is_none(),
        "Agent should have been removed via `unregister_agent`"
    );

    Ok(())
}

'''
'''--- examples/src/custom_network.rs ---
/// URL to the Pagoda API to use for testnet.
pub const PAGODA_TESTNET_RPC_URL: &str = "https://near-testnet.api.pagoda.co/rpc/v1/";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // `NEAR_RPC_API_KEY="xxx" cargo run --package examples --example custom_network`
    if let Ok(val) = std::env::var("NEAR_RPC_API_KEY") {
        // Reference to what can be called by this network: https://docs.pagoda.co/endpoints
        let worker = near_workspaces::custom(PAGODA_TESTNET_RPC_URL)
            .api_key(&val)
            .await?;
        let res = worker.view_block().await?;

        assert!(res.height() > 0);
        return Ok(());
    }

    // skip the test
    println!("NEAR_RPC_API_KEY is not set, skipping the example");
    Ok(())
}

'''
'''--- examples/src/fast_forward.rs ---
/// Our simple contract. Has a function to called `current_env_data` to just grab
/// the current block_timestamp and epoch_height. Will be used to showcase what
/// our contracts can see pre-and-post fast forwarding.
const SIMPLE_WASM_FILEPATH: &str = "./examples/res/simple_contract.wasm";

/// This example will call into `fast_forward` to show us that our contracts are
/// are being fast forward in regards to the timestamp, block height and epoch height.
/// This saves us the time from having to wait a while for the same amount of blocks
/// to be produced, which could take hours with the default genesis configuration.
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker
        .dev_deploy(&std::fs::read(SIMPLE_WASM_FILEPATH)?)
        .await?;

    let (timestamp, epoch_height): (u64, u64) =
        contract.call("current_env_data").view().await?.json()?;
    println!("timestamp = {}, epoch_height = {}", timestamp, epoch_height);

    let block_info = worker.view_block().await?;
    println!("BlockInfo pre-fast_forward {:?}", block_info);

    // Call into fast_forward. This will take a bit of time to invoke, but is
    // faster than manually waiting for the same amounts of blocks to be produced
    worker.fast_forward(10000).await?;

    let (timestamp, epoch_height): (u64, u64) =
        contract.call("current_env_data").view().await?.json()?;
    println!("timestamp = {}, epoch_height = {}", timestamp, epoch_height);

    let block_info = worker.view_block().await?;
    println!("BlockInfo post-fast_forward {:?}", block_info);

    Ok(())
}

'''
'''--- examples/src/gen/adder.rs ---
// No content here, it's to be generated on build. Here to allow cargofmt to work.

'''
'''--- examples/src/genesis_config.rs ---
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;

    // NOTE: this API is under the "experimental" flag and no guarantees are given.
    let genesis_config = worker.genesis_config().await?;

    // Example output:
    //
    // GenesisConfig GenesisConfig {
    //     protocol_version: 60,
    //     genesis_time: 2023-08-22T10:05:32.129104Z,
    //     chain_id: "test-chain-5oKXo",
    //     genesis_height: 0,
    //     num_block_producer_seats: 50,
    //     num_block_producer_seats_per_shard: [
    //         50,
    //     ],
    //     avg_hidden_validator_seats_per_shard: [
    //         0,
    //     ],
    //     dynamic_resharding: false,
    //     protocol_upgrade_stake_threshold: Ratio {
    //         numer: 4,
    //         denom: 5,
    //     },
    //     epoch_length: 500,
    //     gas_limit: 1000000000000000,
    //     min_gas_price: 100000000,
    //     max_gas_price: 10000000000000000000000,
    //     block_producer_kickout_threshold: 90,
    //     chunk_producer_kickout_threshold: 90,
    //     online_min_threshold: Ratio {
    //         numer: 9,
    //         denom: 10,
    //     },
    //     online_max_threshold: Ratio {
    //         numer: 99,
    //         denom: 100,
    //     },
    //     gas_price_adjustment_rate: Ratio {
    //         numer: 1,
    //         denom: 100,
    //     },
    //     validators: [
    //         AccountInfo {
    //             account_id: AccountId(
    //                 "test.near",
    //             ),
    //             public_key: ed25519:4Q4fpCWcsVFj3WT7xkCt45qwW84hskFB4SRMHAQfuCne,
    //             amount: 50000000000000000000000000000000,
    //         },
    //     ],
    //     transaction_validity_period: 100,
    //     protocol_reward_rate: Ratio {
    //         numer: 1,
    //         denom: 10,
    //     },
    //     max_inflation_rate: Ratio {
    //         numer: 1,
    //         denom: 20,
    //     },
    //     total_supply: 2050000000000000000000000000000000,
    //     num_blocks_per_year: 31536000,
    //     protocol_treasury_account: AccountId(
    //         "test.near",
    //     ),
    //     fishermen_threshold: 10000000000000000000000000,
    //     minimum_stake_divisor: 10,
    //     shard_layout: V0(
    //         ShardLayoutV0 {
    //             num_shards: 1,
    //             version: 0,
    //         },
    //     ),
    //     num_chunk_only_producer_seats: 300,
    //     minimum_validators_per_shard: 1,
    //     max_kickout_stake_perc: 100,
    //     minimum_stake_ratio: Ratio {
    //         numer: 1,
    //         denom: 6250,
    //     },
    //     use_production_config: false,
    // }
    println!("GenesisConfig {:#?}", genesis_config);
    Ok(())
}

'''
'''--- examples/src/macro_gen_abi.rs ---
// This example shows how to use the `near_abi_client` Macro Based API.
// We are generating client code using the schema for the ABI and and `workspaces-rs` to call into the contract.
// More information about usage can be found here: <https://github.com/near/near-abi-client-rs/blob/main/README.md>
//
// A good scenario for usage might be when you are interacting with a contract or multiple contracts at an automated level
// and you want to have a type-safe way of interacting with them.

const ADDER_WASM_FILEPATH: &str = "./examples/res/adder.wasm";

near_workspaces::near_abi_client::generate!(AbiClient for "res/adder.json");

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(ADDER_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // The client is initialized with the contract.
    let abi_client = AbiClient { contract };

    // Here we can call the method, now typed with arguments and return types.
    let res = abi_client.add(vec![1, 2], vec![3, 4]).await?;

    assert_eq!(res, [4, 6]);
    Ok(())
}

'''
'''--- examples/src/nft.rs ---
use near_workspaces::types::NearToken;
use serde_json::json;

const NFT_WASM_FILEPATH: &str = "./examples/res/non_fungible_token.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let outcome = contract
        .call("new_default_meta")
        .args_json(json!({
                "owner_id": contract.id(),
        }))
        .transact()
        .await?;

    println!("new_default_meta outcome: {:#?}", outcome);

    let deposit = NearToken::from_yoctonear(10000000000000000000000);
    let outcome = contract
        .call("nft_mint")
        .args_json(json!({
            "token_id": "0",
            "token_owner_id": contract.id(),
            "token_metadata": {
                "title": "Olympus Mons",
                "description": "Tallest mountain in charted solar system",
                "copies": 1,
            },
        }))
        .deposit(deposit)
        .transact()
        .await?;

    println!("nft_mint outcome: {:#?}", outcome);

    let result: serde_json::Value = worker.view(contract.id(), "nft_metadata").await?.json()?;

    println!("--------------\n{}", result);
    println!("Dev Account ID: {}", contract.id());

    Ok(())
}

'''
'''--- examples/src/noop.rs ---
/// This contract has only one method `noop` which does nothing and returns nothing.
const NOOP_CONTRACT_WASM_FILEPATH: &str = "./examples/res/noop_contract.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(NOOP_CONTRACT_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let res = contract.call("noop").transact().await?.json::<()>();

    // Ok to error for call with no return value
    assert_eq!(
        *res.unwrap_err().kind(),
        near_workspaces::error::ErrorKind::DataConversion,
        "the function call returned an empty value, which cannot be parsed as JSON"
    );
    Ok(())
}

'''
'''--- examples/src/protocol_config.rs ---
const STATUS_MSG_WASM_FILEPATH: &str = "./examples/res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let outcome = contract
        .call("set_status")
        .args_json(serde_json::json!({
            "message": "hello_world",
        }))
        .transact()
        .await?;

    let block_reference = {
        let hash = outcome.outcome().block_hash;
        near_primitives::types::BlockReference::BlockId(near_primitives::types::BlockId::Hash(
            near_primitives::hash::CryptoHash(hash.0),
        ))
    };

    // NOTE: this API is under the "experimental" flag and no guarantees are given.
    let protocol_config = worker.protocol_config(block_reference).await?;

    // Example output:
    //
    // ProtocolConfig ProtocolConfigView {
    //     protocol_version: 60,
    //     genesis_time: 2023-08-22T10:07:46.377793Z,
    //     chain_id: "test-chain-trbrQ",
    //     genesis_height: 0,
    //     num_block_producer_seats: 50,
    //     num_block_producer_seats_per_shard: [
    //         50,
    //     ],
    //     avg_hidden_validator_seats_per_shard: [
    //         0,
    //     ],
    //     dynamic_resharding: false,
    //     protocol_upgrade_stake_threshold: Ratio {
    //         numer: 4,
    //         denom: 5,
    //     },
    //     epoch_length: 500,
    //     gas_limit: 1000000000000000,
    //     min_gas_price: 100000000,
    //     max_gas_price: 10000000000000000000000,
    //     block_producer_kickout_threshold: 90,
    //     chunk_producer_kickout_threshold: 90,
    //     online_min_threshold: Ratio {
    //         numer: 9,
    //         denom: 10,
    //     },
    //     online_max_threshold: Ratio {
    //         numer: 99,
    //         denom: 100,
    //     },
    //     gas_price_adjustment_rate: Ratio {
    //         numer: 1,
    //         denom: 100,
    //     },
    //     runtime_config: RuntimeConfigView {
    //         storage_amount_per_byte: 10000000000000000000,
    //         transaction_costs: RuntimeFeesConfigView {
    //             action_receipt_creation_config: Fee {
    //                 send_sir: 108059500000,
    //                 send_not_sir: 108059500000,
    //                 execution: 108059500000,
    //             },
    //             data_receipt_creation_config: DataReceiptCreationConfigView {
    //                 base_cost: Fee {
    //                     send_sir: 36486732312,
    //                     send_not_sir: 36486732312,
    //                     execution: 36486732312,
    //                 },
    //                 cost_per_byte: Fee {
    //                     send_sir: 17212011,
    //                     send_not_sir: 17212011,
    //                     execution: 17212011,
    //                 },
    //             },
    //             action_creation_config: ActionCreationConfigView {
    //                 create_account_cost: Fee {
    //                     send_sir: 3850000000000,
    //                     send_not_sir: 3850000000000,
    //                     execution: 3850000000000,
    //                 },
    //                 deploy_contract_cost: Fee {
    //                     send_sir: 184765750000,
    //                     send_not_sir: 184765750000,
    //                     execution: 184765750000,
    //                 },
    //                 deploy_contract_cost_per_byte: Fee {
    //                     send_sir: 6812999,
    //                     send_not_sir: 6812999,
    //                     execution: 64572944,
    //                 },
    //                 function_call_cost: Fee {
    //                     send_sir: 2319861500000,
    //                     send_not_sir: 2319861500000,
    //                     execution: 2319861500000,
    //                 },
    //                 function_call_cost_per_byte: Fee {
    //                     send_sir: 2235934,
    //                     send_not_sir: 2235934,
    //                     execution: 2235934,
    //                 },
    //                 transfer_cost: Fee {
    //                     send_sir: 115123062500,
    //                     send_not_sir: 115123062500,
    //                     execution: 115123062500,
    //                 },
    //                 stake_cost: Fee {
    //                     send_sir: 141715687500,
    //                     send_not_sir: 141715687500,
    //                     execution: 102217625000,
    //                 },
    //                 add_key_cost: AccessKeyCreationConfigView {
    //                     full_access_cost: Fee {
    //                         send_sir: 101765125000,
    //                         send_not_sir: 101765125000,
    //                         execution: 101765125000,
    //                     },
    //                     function_call_cost: Fee {
    //                         send_sir: 102217625000,
    //                         send_not_sir: 102217625000,
    //                         execution: 102217625000,
    //                     },
    //                     function_call_cost_per_byte: Fee {
    //                         send_sir: 1925331,
    //                         send_not_sir: 1925331,
    //                         execution: 1925331,
    //                     },
    //                 },
    //                 delete_key_cost: Fee {
    //                     send_sir: 94946625000,
    //                     send_not_sir: 94946625000,
    //                     execution: 94946625000,
    //                 },
    //                 delete_account_cost: Fee {
    //                     send_sir: 147489000000,
    //                     send_not_sir: 147489000000,
    //                     execution: 147489000000,
    //                 },
    //                 delegate_cost: Fee {
    //                     send_sir: 200000000000,
    //                     send_not_sir: 200000000000,
    //                     execution: 200000000000,
    //                 },
    //             },
    //             storage_usage_config: StorageUsageConfigView {
    //                 num_bytes_account: 100,
    //                 num_extra_bytes_record: 40,
    //             },
    //             burnt_gas_reward: Ratio {
    //                 numer: 3,
    //                 denom: 10,
    //             },
    //             pessimistic_gas_price_inflation_ratio: Ratio {
    //                 numer: 103,
    //                 denom: 100,
    //             },
    //         },
    //         wasm_config: VMConfigView {
    //             ext_costs: ExtCostsConfigView {
    //                 base: 264768111,
    //                 contract_loading_base: 35445963,
    //                 contract_loading_bytes: 216750,
    //                 read_memory_base: 2609863200,
    //                 read_memory_byte: 3801333,
    //                 write_memory_base: 2803794861,
    //                 write_memory_byte: 2723772,
    //                 read_register_base: 2517165186,
    //                 read_register_byte: 98562,
    //                 write_register_base: 2865522486,
    //                 write_register_byte: 3801564,
    //                 utf8_decoding_base: 3111779061,
    //                 utf8_decoding_byte: 291580479,
    //                 utf16_decoding_base: 3543313050,
    //                 utf16_decoding_byte: 163577493,
    //                 sha256_base: 4540970250,
    //                 sha256_byte: 24117351,
    //                 keccak256_base: 5879491275,
    //                 keccak256_byte: 21471105,
    //                 keccak512_base: 5811388236,
    //                 keccak512_byte: 36649701,
    //                 ripemd160_base: 853675086,
    //                 ripemd160_block: 680107584,
    //                 ed25519_verify_base: 210000000000,
    //                 ed25519_verify_byte: 9000000,
    //                 ecrecover_base: 278821988457,
    //                 log_base: 3543313050,
    //                 log_byte: 13198791,
    //                 storage_write_base: 64196736000,
    //                 storage_write_key_byte: 70482867,
    //                 storage_write_value_byte: 31018539,
    //                 storage_write_evicted_byte: 32117307,
    //                 storage_read_base: 56356845750,
    //                 storage_read_key_byte: 30952533,
    //                 storage_read_value_byte: 5611005,
    //                 storage_remove_base: 53473030500,
    //                 storage_remove_key_byte: 38220384,
    //                 storage_remove_ret_value_byte: 11531556,
    //                 storage_has_key_base: 54039896625,
    //                 storage_has_key_byte: 30790845,
    //                 storage_iter_create_prefix_base: 0,
    //                 storage_iter_create_prefix_byte: 0,
    //                 storage_iter_create_range_base: 0,
    //                 storage_iter_create_from_byte: 0,
    //                 storage_iter_create_to_byte: 0,
    //                 storage_iter_next_base: 0,
    //                 storage_iter_next_key_byte: 0,
    //                 storage_iter_next_value_byte: 0,
    //                 touching_trie_node: 16101955926,
    //                 read_cached_trie_node: 2280000000,
    //                 promise_and_base: 1465013400,
    //                 promise_and_per_promise: 5452176,
    //                 promise_return: 560152386,
    //                 validator_stake_base: 911834726400,
    //                 validator_total_stake_base: 911834726400,
    //                 contract_compile_base: 0,
    //                 contract_compile_bytes: 0,
    //                 alt_bn128_g1_multiexp_base: 713000000000,
    //                 alt_bn128_g1_multiexp_element: 320000000000,
    //                 alt_bn128_g1_sum_base: 3000000000,
    //                 alt_bn128_g1_sum_element: 5000000000,
    //                 alt_bn128_pairing_check_base: 9686000000000,
    //                 alt_bn128_pairing_check_element: 5102000000000,
    //             },
    //             grow_mem_cost: 1,
    //             regular_op_cost: 822756,
    //             limit_config: VMLimitConfig {
    //                 max_gas_burnt: 300000000000000,
    //                 max_stack_height: 16384,
    //                 contract_prepare_version: V1,
    //                 initial_memory_pages: 1024,
    //                 max_memory_pages: 2048,
    //                 registers_memory_limit: 1073741824,
    //                 max_register_size: 104857600,
    //                 max_number_registers: 100,
    //                 max_number_logs: 100,
    //                 max_total_log_length: 16384,
    //                 max_total_prepaid_gas: 300000000000000,
    //                 max_actions_per_receipt: 100,
    //                 max_number_bytes_method_names: 2000,
    //                 max_length_method_name: 256,
    //                 max_arguments_length: 4194304,
    //                 max_length_returned_data: 4194304,
    //                 max_contract_size: 4194304,
    //                 max_transaction_size: 4194304,
    //                 max_length_storage_key: 2048,
    //                 max_length_storage_value: 4194304,
    //                 max_promises_per_function_call_action: 1024,
    //                 max_number_input_data_dependencies: 128,
    //                 max_functions_number_per_contract: Some(
    //                     10000,
    //                 ),
    //                 wasmer2_stack_limit: 204800,
    //                 max_locals_per_contract: Some(
    //                     1000000,
    //                 ),
    //                 account_id_validity_rules_version: V1,
    //             },
    //         },
    //         account_creation_config: AccountCreationConfigView {
    //             min_allowed_top_level_account_length: 32,
    //             registrar_account_id: AccountId(
    //                 "registrar",
    //             ),
    //         },
    //     },
    //     transaction_validity_period: 100,
    //     protocol_reward_rate: Ratio {
    //         numer: 1,
    //         denom: 10,
    //     },
    //     max_inflation_rate: Ratio {
    //         numer: 1,
    //         denom: 20,
    //     },
    //     num_blocks_per_year: 31536000,
    //     protocol_treasury_account: AccountId(
    //         "test.near",
    //     ),
    //     fishermen_threshold: 10000000000000000000000000,
    //     minimum_stake_divisor: 10,
    // }
    println!("ProtocolConfig {protocol_config:#?}");
    Ok(())
}

'''
'''--- examples/src/receipt.rs ---
use near_jsonrpc_primitives::types::receipts::ReceiptReference;

const STATUS_MSG_WASM_FILEPATH: &str = "./examples/res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let outcome = contract
        .call("set_status")
        .args_json(serde_json::json!({
            "message": "hello_world",
        }))
        .transact()
        .await?;

    let receipt_ref = {
        let mut ids = outcome.outcome().receipt_ids.clone();
        if ids.is_empty() {
            println!("no receipt ids present");
            return Ok(());
        }

        println!("receipts found: {ids:?}");

        ReceiptReference {
            receipt_id: near_primitives::hash::CryptoHash(
                ids.pop().expect("expected at least one receipt id").0,
            ),
        }
    };

    // NOTE: this API is under the "experimental" flag and no guarantees are given.
    let resp = worker.receipt(receipt_ref).await?;

    println!("ReceiptView: {resp:?}");
    Ok(())
}

'''
'''--- examples/src/ref_finance.rs ---
use std::collections::HashMap;
use std::convert::TryInto;

use near_gas::NearGas;
use near_workspaces::network::Sandbox;
use near_workspaces::types::NearToken;
use near_workspaces::{Account, AccountId, Contract, Worker};
use near_workspaces::{BlockHeight, DevNetwork};
use serde_json::json;

const FT_CONTRACT_FILEPATH: &str = "./examples/res/fungible_token.wasm";

/// Contract id of ref-finance on mainnet.
const REF_FINANCE_ACCOUNT_ID: &str = "v2.ref-finance.near";

/// BlockId referencing back to a specific time just in case the contract has
/// changed or has been updated at a later time.
const BLOCK_HEIGHT: BlockHeight = 50_000_000;

/// Pull down the ref-finance contract and deploy it to the sandbox network,
/// initializing it with all data required to run the tests.
async fn create_ref(owner: &Account, worker: &Worker<Sandbox>) -> anyhow::Result<Contract> {
    let mainnet = near_workspaces::mainnet_archival().await?;
    let ref_finance_id: AccountId = REF_FINANCE_ACCOUNT_ID.parse()?;

    // This will pull down the relevant ref-finance contract from mainnet. We're going
    // to be overriding the initial balance with 1000N instead of what's on mainnet.
    let ref_finance = worker
        .import_contract(&ref_finance_id, &mainnet)
        .initial_balance(NearToken::from_near(1000))
        .block_height(BLOCK_HEIGHT)
        .transact()
        .await?;

    // NOTE: We are not pulling down the contract's data here, so we'll need to initialize
    // our own set of metadata. This is because the contract's data is too big for the rpc
    // service to pull down (i.e. greater than 50kb).

    owner
        .call(ref_finance.id(), "new")
        .args_json(json!({
            "owner_id": ref_finance.id(),
            "exchange_fee": 4,
            "referral_fee": 1,
        }))
        .transact()
        .await?
        .into_result()?;

    owner
        .call(ref_finance.id(), "storage_deposit")
        .args_json(json!({}))
        .deposit(NearToken::from_millinear(30))
        .transact()
        .await?
        .into_result()?;

    Ok(ref_finance)
}

/// Pull down the WNear contract from mainnet and initialize it with our own metadata.
async fn create_wnear(owner: &Account, worker: &Worker<Sandbox>) -> anyhow::Result<Contract> {
    let mainnet = near_workspaces::mainnet_archival().await?;
    let wnear_id: AccountId = "wrap.near".to_string().try_into()?;
    let wnear = worker
        .import_contract(&wnear_id, &mainnet)
        .block_height(BLOCK_HEIGHT)
        .transact()
        .await?;

    owner
        .call(wnear.id(), "new")
        .transact()
        .await?
        .into_result()?;

    owner
        .call(wnear.id(), "storage_deposit")
        .args_json(json!({}))
        .deposit(NearToken::from_millinear(8))
        .transact()
        .await?
        .into_result()?;

    owner
        .call(wnear.id(), "near_deposit")
        .deposit(NearToken::from_near(200))
        .transact()
        .await?
        .into_result()?;

    Ok(wnear)
}

/// Create a liquidity pool on Ref-Finance, registering the tokens we provide it.
/// Add's the amount in `tokens` we set for liquidity. This will return us the
/// pool_id after the pool has been created.
async fn create_pool_with_liquidity(
    owner: &Account,
    ref_finance: &Contract,
    tokens: HashMap<&AccountId, u128>,
) -> anyhow::Result<u64> {
    let (token_ids, token_amounts): (Vec<String>, Vec<String>) = tokens
        .iter()
        .map(|(id, amount)| (id.to_string(), amount.to_string()))
        .unzip();

    ref_finance
        .call("extend_whitelisted_tokens")
        .args_json(json!({ "tokens": token_ids }))
        .transact()
        .await?
        .into_result()?;

    let pool_id: u64 = ref_finance
        .call("add_simple_pool")
        .args_json(json!({
            "tokens": token_ids,
            "fee": 25
        }))
        .deposit(NearToken::from_millinear(3))
        .transact()
        .await?
        .json()?;

    owner
        .call(ref_finance.id(), "register_tokens")
        .args_json(json!({
            "token_ids": token_ids,
        }))
        .deposit(NearToken::from_yoctonear(1))
        .transact()
        .await?
        .into_result()?;

    deposit_tokens(owner, ref_finance, tokens).await?;

    owner
        .call(ref_finance.id(), "add_liquidity")
        .args_json(json!({
            "pool_id": pool_id,
            "amounts": token_amounts,
        }))
        .deposit(NearToken::from_near(1))
        .transact()
        .await?
        .into_result()?;

    Ok(pool_id)
}

/// Deposit tokens into Ref-Finance
async fn deposit_tokens(
    owner: &Account,
    ref_finance: &Contract,
    tokens: HashMap<&AccountId, u128>,
) -> anyhow::Result<()> {
    for (contract_id, amount) in tokens {
        ref_finance
            .as_account()
            .call(contract_id, "storage_deposit")
            .args_json(json!({
                "registration_only": true,
            }))
            .deposit(NearToken::from_near(1))
            .transact()
            .await?
            .into_result()?;

        owner
            .call(contract_id, "ft_transfer_call")
            .args_json(json!({
                "receiver_id": ref_finance.id(),
                "amount": amount.to_string(),
                "msg": "",
            }))
            .gas(NearGas::from_tgas(200))
            .deposit(NearToken::from_yoctonear(1))
            .transact()
            .await?
            .into_result()?;
    }

    Ok(())
}

/// Create our own custom Fungible Token contract and setup the initial state.
async fn create_custom_ft(
    owner: &Account,
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<Contract> {
    let ft: Contract = worker
        .dev_deploy(&std::fs::read(FT_CONTRACT_FILEPATH)?)
        .await?;

    // Initialize our FT contract with owner metadata and total supply available
    // to be traded and transferred into other contracts such as Ref-Finance
    ft.call("new_default_meta")
        .args_json(json!({
            "owner_id": owner.id(),
            "total_supply": NearToken::from_near(1_000_000_000),
        }))
        .transact()
        .await?
        .into_result()?;

    Ok(ft)
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let owner = worker.root_account()?;

    ///////////////////////////////////////////////////////////////////////////
    // Stage 1: Deploy relevant contracts such as FT, WNear, and Ref-Finance
    ///////////////////////////////////////////////////////////////////////////

    let ft = create_custom_ft(&owner, &worker).await?;
    let ref_finance = create_ref(&owner, &worker).await?;
    let wnear = create_wnear(&owner, &worker).await?;

    ///////////////////////////////////////////////////////////////////////////
    // Stage 2: create a pool with liquidity and deposit/transfer tokens into
    // them from our contracts such as FT and WNear.
    ///////////////////////////////////////////////////////////////////////////

    let pool_id = create_pool_with_liquidity(
        &owner,
        &ref_finance,
        maplit::hashmap! {
            ft.id() => NearToken::from_near(5).as_yoctonear(),
            wnear.id() => NearToken::from_near(10).as_yoctonear(),
        },
    )
    .await?;
    println!(
        "Created a liquid pool on {} with id {}",
        ref_finance.id(),
        pool_id
    );

    deposit_tokens(
        &owner,
        &ref_finance,
        maplit::hashmap! {
            ft.id() => NearToken::from_near(100).as_yoctonear(),
            wnear.id() => NearToken::from_near(100).as_yoctonear(),
        },
    )
    .await?;

    ///////////////////////////////////////////////////////////////////////////
    // Stage 3: View our deposited/transferred tokens in ref-finance
    ///////////////////////////////////////////////////////////////////////////

    let ft_deposit: NearToken = worker
        .view(ref_finance.id(), "get_deposit")
        .args_json(json!({
            "account_id": owner.id(),
            "token_id": ft.id(),
        }))
        .await?
        .json()?;
    println!("Current FT deposit: {}", ft_deposit);
    assert_eq!(ft_deposit, NearToken::from_near(100));

    let wnear_deposit: NearToken = worker
        .view(ref_finance.id(), "get_deposit")
        .args_json(json!({
            "account_id": owner.id(),
            "token_id": wnear.id(),
        }))
        .await?
        .json()?;

    println!("Current WNear deposit: {}", wnear_deposit);
    assert_eq!(wnear_deposit, NearToken::from_near(100));

    ///////////////////////////////////////////////////////////////////////////
    // Stage 4: Check how much our expected rate is for swapping and then swap
    ///////////////////////////////////////////////////////////////////////////

    let expected_return: String = worker
        .view(ref_finance.id(), "get_return")
        .args_json(json!({
            "pool_id": pool_id,
            "token_in": ft.id(),
            "token_out": wnear.id(),
            "amount_in": NearToken::from_near(1),
        }))
        .await?
        .json()?;

    println!(
        "Expect return for trading in 1 FT token for WNear: {}",
        expected_return
    );
    assert_eq!(expected_return, "1662497915624478906119726");

    let actual_out = owner
        .call(ref_finance.id(), "swap")
        .args_json(json!({
            "actions": vec![json!({
                "pool_id": pool_id,
                "token_in": ft.id(),
                "token_out": wnear.id(),
                "amount_in": NearToken::from_near(1),
                "min_amount_out": "1",
            })],
        }))
        .deposit(NearToken::from_yoctonear(1))
        .gas(NearGas::from_tgas(100))
        .transact()
        .await?;
    let gas_burnt = actual_out.total_gas_burnt;
    let actual_out: String = actual_out.json()?;
    println!(
        "Actual return for trading in 1 FT token for WNear: {}",
        actual_out
    );
    assert_eq!(actual_out, expected_return);
    println!("Gas burnt from swapping: {}", gas_burnt);

    ///////////////////////////////////////////////////////////////////////////
    // Stage 5: See that our swap tokens reflect in our deposits
    ///////////////////////////////////////////////////////////////////////////

    let ft_deposit: NearToken = worker
        .view(ref_finance.id(), "get_deposit")
        .args_json(json!({
            "account_id": owner.id(),
            "token_id": ft.id(),
        }))
        .await?
        .json()?;
    println!("New FT deposit after swap: {}", ft_deposit);
    assert_eq!(ft_deposit, NearToken::from_near(99));

    let wnear_deposit: String = ref_finance
        .view("get_deposit")
        .args_json(json!({
            "account_id": owner.id(),
            "token_id": wnear.id(),
        }))
        .await?
        .json()?;
    println!("New WNear deposit after swap: {}", wnear_deposit);

    Ok(())
}

'''
'''--- examples/src/spooning.rs ---
use std::env;

use near_primitives::borsh::{BorshDeserialize, BorshSerialize};
use near_workspaces::{AccountId, Contract, DevNetwork, Worker};
use serde_json::json;
use tracing::info;
use tracing_subscriber::filter::LevelFilter;
use tracing_subscriber::EnvFilter;

const STATUS_MSG_WASM_FILEPATH: &str = "./examples/res/status_message.wasm";

/// This is the cached contract_id from running `deploy_testnet` the first time. Used so we don't
/// overload testnet and have to go through a couple more cycles than we have to, to showcase spooning.
///
/// If you'd like a different account to deploy it to, run the following:
/// ```rust, norun
/// async fn deploy_testnet() -> anyhow::Result<()> {
///     let worker = near_workspaces::testnet().await?;
///
///     let contract = deploy_status_contract(worker, "hello from testnet").await?;
///     println!("{}", contract.id());
/// }
/// ```
const TESTNET_PREDEPLOYED_CONTRACT_ID: &str = "dev-20211013002148-59466083160385";

// The following two structs (Record and StatusMessage) are representation of the
// internal data stored on chain. They will be deserialized into the following
// formats. Note that these will be different depending on what data structure
// we use in our contract.
#[derive(Clone, Eq, PartialEq, Debug, BorshDeserialize, BorshSerialize)]
#[borsh(crate = "near_primitives::borsh")]
struct Record {
    k: String,
    v: String,
}

#[derive(Clone, Eq, PartialEq, Debug, BorshDeserialize, BorshSerialize)]
#[borsh(crate = "near_primitives::borsh")]
struct StatusMessage {
    records: Vec<Record>,
}

/// Deploy a status message smart contract (https://examples.near.org/rust-status-message)
/// with an attached message associated to the contract id.
///
/// For example, our predeployed testnet contract has already done this:
///    set_status(TESTNET_PREDEPLOYED_CONTRACT_ID) = "hello from testnet"
async fn deploy_status_contract(
    worker: &Worker<impl DevNetwork>,
    msg: &str,
) -> anyhow::Result<Contract> {
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // This will `call` into `set_status` with the message we want to set.
    contract
        .call("set_status")
        .args_json(json!({
            "message": msg,
        }))
        .transact()
        .await?
        .into_result()?;

    Ok(contract)
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Parse log filters from RUST_LOG or fallback to INFO if empty
    let filter = if env::var(EnvFilter::DEFAULT_ENV).is_ok() {
        EnvFilter::from_default_env()
    } else {
        EnvFilter::default().add_directive(LevelFilter::INFO.into())
    };
    tracing_subscriber::fmt().with_env_filter(filter).init();

    // Grab STATE from the testnet status_message contract. This contract contains the following data:
    //   get_status(dev-20211013002148-59466083160385) => "hello from testnet"
    let (testnet_contract_id, status_msg) = {
        let worker = near_workspaces::testnet().await?;
        let contract_id: AccountId = TESTNET_PREDEPLOYED_CONTRACT_ID
            .parse()
            .map_err(anyhow::Error::msg)?;

        let state = worker
            .view_state(&contract_id)
            .await?
            .remove(b"STATE".as_slice())
            .unwrap();

        (contract_id, state)
    };

    info!(target: "spooning", "Testnet: {:?}", StatusMessage::try_from_slice(&status_msg)?);

    // Create our sandboxed environment and grab a worker to do stuff in it:
    let worker = near_workspaces::sandbox().await?;

    // Deploy with the following status_message state: sandbox_contract_id => "hello from sandbox"
    let sandbox_contract = deploy_status_contract(&worker, "hello from sandbox").await?;

    // Patch our testnet STATE into our local sandbox:
    worker
        .patch_state(sandbox_contract.id(), b"STATE", &status_msg)
        .await?;

    // Now grab the state to see that it has indeed been patched:
    let status: String = sandbox_contract
        .view("get_status")
        .args_json(json!({
            "account_id": testnet_contract_id,
        }))
        .await?
        .json()?;

    info!(target: "spooning", "New status patched: {:?}", status);
    assert_eq!(&status, "hello from testnet");

    // See that sandbox state was overridden. Grabbing get_status(sandbox_contract_id) should yield Null
    let result: Option<String> = sandbox_contract
        .view("get_status")
        .args_json(json!({
            "account_id": sandbox_contract.id(),
        }))
        .await?
        .json()?;
    assert_eq!(result, None);

    Ok(())
}

'''
'''--- examples/src/status_message.rs ---
use serde_json::json;

const STATUS_MSG_WASM_FILEPATH: &str = "./examples/res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let outcome = contract
        .call("set_status")
        .args_json(json!({
            "message": "hello_world",
        }))
        .transact()
        .await?;
    println!("set_status: {:?}", outcome);

    let result: String = contract
        .view("get_status")
        .args_json(json!({
            "account_id": contract.id(),
        }))
        .await?
        .json()?;

    println!("status: {:?}", result);

    Ok(())
}

'''
'''--- examples/src/tx_status.rs ---
use near_jsonrpc_primitives::types::transactions::TransactionInfo;
use near_primitives::hash::CryptoHash;
use serde_json::json;

const STATUS_MSG_WASM_FILEPATH: &str = "./examples/res/status_message.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    let outcome = contract
        .call("set_status")
        .args_json(json!({
            "message": "hello_world",
        }))
        .transact()
        .await?;

    let tx_info = {
        let outcome = outcome.outcome();
        TransactionInfo::TransactionId {
            tx_hash: CryptoHash(outcome.transaction_hash.0),
            sender_account_id: outcome.executor_id.clone(),
        }
    };

    // NOTE: this API is under the "experimental" flag and no guarantees are given.
    let resp = worker.tx_status(tx_info).await?;

    // Example outcome:
    //
    // FinalExecutionOutcomeWithReceiptView FinalExecutionOutcomeWithReceiptView {
    //     final_outcome: FinalExecutionOutcome {
    //         status: SuccessValue(''),
    //         transaction: SignedTransactionView {
    //             signer_id: AccountId(
    //                 "dev-20230822130616-84011708140052",
    //             ),
    //             public_key: ed25519:5WMgq6gKZbAr7xBZmXJHjnj4C3UZkNJ4F5odisUBFcRh,
    //             nonce: 2000001,
    //             receiver_id: AccountId(
    //                 "dev-20230822130616-84011708140052",
    //             ),
    //             actions: [
    //                 FunctionCall {
    //                     method_name: "set_status",
    //                     args: FunctionArgs(
    //                         [
    //                             123,
    //                             34,
    //                             109,
    //                             101,
    //                             115,
    //                             115,
    //                             97,
    //                             103,
    //                             101,
    //                             34,
    //                             58,
    //                             34,
    //                             104,
    //                             101,
    //                             108,
    //                             108,
    //                             111,
    //                             95,
    //                             119,
    //                             111,
    //                             114,
    //                             108,
    //                             100,
    //                             34,
    //                             125,
    //                         ],
    //                     ),
    //                     gas: 10000000000000,
    //                     deposit: 0,
    //                 },
    //             ],
    //             signature: ed25519:25z5farfJh4ccYoLJeJtKTrfEfecWSXqksafEnFCA724NHaGZWowtpKxGdMZTYSzzpAJ3iT6sWNyEF2oC2u1CvCR,
    //             hash: HWRjprUXTN7fhnvzMaDxXBXbJTVqvbW8j56PvfyL8uB6,
    //         },
    //         transaction_outcome: ExecutionOutcomeWithIdView {
    //             proof: [
    //                 MerklePathItem {
    //                     hash: 8a7iJ6vWjvwHKFLXPETciDbZtdHeHaX6xPqVT42CrEfi,
    //                     direction: Right,
    //                 },
    //             ],
    //             block_hash: BeMy3czUnz7EndbaSSHTSZ7WhozdAxSRAtYYqCo5XSSo,
    //             id: HWRjprUXTN7fhnvzMaDxXBXbJTVqvbW8j56PvfyL8uB6,
    //             outcome: ExecutionOutcomeView {
    //                 logs: [],
    //                 receipt_ids: [
    //                     ByE39xUGnYHrfVsNyxTgDjkPY7yFFLCHQcUb7m5Qiwkp,
    //                 ],
    //                 gas_burnt: 2427999257690,
    //                 tokens_burnt: 242799925769000000000,
    //                 executor_id: AccountId(
    //                     "dev-20230822130616-84011708140052",
    //                 ),
    //                 status: SuccessReceiptId(ByE39xUGnYHrfVsNyxTgDjkPY7yFFLCHQcUb7m5Qiwkp),
    //                 metadata: ExecutionMetadataView {
    //                     version: 1,
    //                     gas_profile: None,
    //                 },
    //             },
    //         },
    //         receipts_outcome: [
    //             ExecutionOutcomeWithIdView {
    //                 proof: [
    //                     MerklePathItem {
    //                         hash: 5hxa61Hv5a82HUh2qWVSVEVB5f2txx4JpmbXK5qmdwnv,
    //                         direction: Left,
    //                     },
    //                 ],
    //                 block_hash: BeMy3czUnz7EndbaSSHTSZ7WhozdAxSRAtYYqCo5XSSo,
    //                 id: ByE39xUGnYHrfVsNyxTgDjkPY7yFFLCHQcUb7m5Qiwkp,
    //                 outcome: ExecutionOutcomeView {
    //                     logs: [
    //                         "A",
    //                     ],
    //                     receipt_ids: [
    //                         AhbLBVzfPa2ebNkTtdTyK1pB6zE6Srucwob32UCNFS5E,
    //                     ],
    //                     gas_burnt: 2666186302694,
    //                     tokens_burnt: 266618630269400000000,
    //                     executor_id: AccountId(
    //                         "dev-20230822130616-84011708140052",
    //                     ),
    //                     status: SuccessValue(''),
    //                     metadata: ExecutionMetadataView {
    //                         version: 3,
    //                         gas_profile: Some(
    //                             [
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "BASE",
    //                                     gas_used: 2647681110,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "CONTRACT_LOADING_BASE",
    //                                     gas_used: 35445963,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "CONTRACT_LOADING_BYTES",
    //                                     gas_used: 26988192750,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "LOG_BASE",
    //                                     gas_used: 3543313050,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "LOG_BYTE",
    //                                     gas_used: 13198791,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "READ_CACHED_TRIE_NODE",
    //                                     gas_used: 4560000000,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "READ_MEMORY_BASE",
    //                                     gas_used: 10439452800,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "READ_MEMORY_BYTE",
    //                                     gas_used: 254689311,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "READ_REGISTER_BASE",
    //                                     gas_used: 5034330372,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "READ_REGISTER_BYTE",
    //                                     gas_used: 5716596,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "STORAGE_READ_BASE",
    //                                     gas_used: 56356845750,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "STORAGE_READ_KEY_BYTE",
    //                                     gas_used: 154762665,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "STORAGE_WRITE_BASE",
    //                                     gas_used: 64196736000,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "STORAGE_WRITE_KEY_BYTE",
    //                                     gas_used: 352414335,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "STORAGE_WRITE_VALUE_BYTE",
    //                                     gas_used: 1737038184,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "TOUCHING_TRIE_NODE",
    //                                     gas_used: 32203911852,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "UTF8_DECODING_BASE",
    //                                     gas_used: 3111779061,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "UTF8_DECODING_BYTE",
    //                                     gas_used: 291580479,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "WASM_INSTRUCTION",
    //                                     gas_used: 11695476540,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "WRITE_MEMORY_BASE",
    //                                     gas_used: 8411384583,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "WRITE_MEMORY_BYTE",
    //                                     gas_used: 201559128,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "WRITE_REGISTER_BASE",
    //                                     gas_used: 5731044972,
    //                                 },
    //                                 CostGasUsed {
    //                                     cost_category: "WASM_HOST_COST",
    //                                     cost: "WRITE_REGISTER_BYTE",
    //                                     gas_used: 220490712,
    //                                 },
    //                             ],
    //                         ),
    //                     },
    //                 },
    //             },
    //             ExecutionOutcomeWithIdView {
    //                 proof: [],
    //                 block_hash: AG5nJGsWxCtAHPzq3m7NsTnSdSmQaxeLwffvFKMeWT9b,
    //                 id: AhbLBVzfPa2ebNkTtdTyK1pB6zE6Srucwob32UCNFS5E,
    //                 outcome: ExecutionOutcomeView {
    //                     logs: [],
    //                     receipt_ids: [],
    //                     gas_burnt: 223182562500,
    //                     tokens_burnt: 0,
    //                     executor_id: AccountId(
    //                         "dev-20230822130616-84011708140052",
    //                     ),
    //                     status: SuccessValue(''),
    //                     metadata: ExecutionMetadataView {
    //                         version: 3,
    //                         gas_profile: Some(
    //                             [],
    //                         ),
    //                     },
    //                 },
    //             },
    //         ],
    //     },
    //     receipts: [
    //         ReceiptView {
    //             predecessor_id: AccountId(
    //                 "system",
    //             ),
    //             receiver_id: AccountId(
    //                 "dev-20230822130616-84011708140052",
    //             ),
    //             receipt_id: AhbLBVzfPa2ebNkTtdTyK1pB6zE6Srucwob32UCNFS5E,
    //             receipt: Action {
    //                 signer_id: AccountId(
    //                     "dev-20230822130616-84011708140052",
    //                 ),
    //                 signer_public_key: ed25519:5WMgq6gKZbAr7xBZmXJHjnj4C3UZkNJ4F5odisUBFcRh,
    //                 gas_price: 0,
    //                 output_data_receivers: [],
    //                 input_data_ids: [],
    //                 actions: [
    //                     Transfer {
    //                         deposit: 1051867810978932100000,
    //                     },
    //                 ],
    //             },
    //         },
    //     ],
    // }
    println!("FinalExecutionOutcomeWithReceiptView {resp:#?}");
    Ok(())
}

'''
'''--- examples/src/validators_ordered.rs ---
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;

    // NOTE: this API is under the "experimental" flag and no guarantees are given.
    let validators = worker.validators_ordered(None).await?;

    // Example output:
    //
    // Validators [
    //     V1(
    //         ValidatorStakeViewV1 {
    //             account_id: AccountId(
    //                 "test.near",
    //             ),
    //             public_key: ed25519:HguH1hFyR4voJUomR67QqxACtSo3sYTMXtJ9oSzFSoYy,
    //             stake: 50000000000000000000000000000000,
    //         },
    //     ),
    // ]
    println!("Validators {validators:#?}");
    Ok(())
}

'''
'''--- examples/src/various_queries.rs ---
use serde_json::json;

/// This example will show various calls into viewing information from what's on the sandbox chain
/// to what was on the chain prior to modifying state.
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;

    // Fetch the latest block produced from the network.
    let block = worker.view_block().await?;
    println!("Latest Block: {block:#?}");

    // Fetch the block from the genesis point of the sandbox network. This is not necessarily
    // the genesis of every network since they can re-genesis at a higher block height.
    let genesis_block = worker
        .view_block()
        .block_height(0)
        // can instead use .block_hash(CryptoHash) as well
        .await?;
    println!("Sandbox Genesis Block: {genesis_block:#?}");

    // Reference the chunk via the block hash we queried for earlier:
    let shard_id = 0;
    let chunk = worker
        .view_chunk()
        .block_hash_and_shard(*block.hash(), shard_id)
        .await?;
    println!("Latest Chunk: {chunk:#?}");

    let bob = worker.dev_create_account().await?;
    println!("\nCreated bob's account with id {:?}", bob.id());

    // Show all the access keys relating to bob:
    let access_keys = bob.view_access_keys().await?;
    println!("bob's access keys: {access_keys:?}");

    let status_msg = worker
        .dev_deploy(include_bytes!("../res/status_message.wasm"))
        .await?;

    // Let's have bob set the "Hello" message into the contract.
    let outcome = bob
        .call(status_msg.id(), "set_status")
        .args_json(json!({
            "message": "Hello"
        }))
        .transact()
        .await?
        .into_result()?;
    println!(
        "Bob burnt {} gas calling into `set_status('Hello')`",
        outcome.total_gas_burnt
    );

    // let's get a reference point to the chain at it's current state, so we can reference it back later
    // when we want older data from the chain.
    let block = worker.view_block().await?;

    // Override bob's message of "Hello" with "World".
    let outcome = bob
        .call(status_msg.id(), "set_status")
        .args_json(json!({
            "message": "World"
        }))
        .transact()
        .await?
        .into_result()?;
    println!(
        "Bob burnt {} gas calling into `set_status('World')`",
        outcome.total_gas_burnt
    );

    // Then view that it indeed has changed:
    let msg: String = status_msg
        .view("get_status")
        .args_json(json!({
            "account_id": bob.id(),
        }))
        .await?
        .json()?;
    println!("Bob's status message: '{}'", msg);

    // But since we have a reference point to before bob overrode his message, we can view the message
    // from then as well, by giving the reference into the view function call:
    let msg: String = status_msg
        .view("get_status")
        .args_json(json!({
            "account_id": bob.id(),
        }))
        .block_hash(*block.hash())
        .await?
        .json()?;
    println!("Bob's older status message: '{}'", msg);

    Ok(())
}

'''
'''--- release-plz.toml ---
[workspace]
# Use `workspaces` crate CHANGELOG as top-level one
changelog_update = false

[[package]]
name = "near-workspaces"
changelog_update = true
changelog_path = "./CHANGELOG.md"

'''
'''--- workspaces/Cargo.toml ---
[package]
name = "near-workspaces"
version = "0.10.0"
edition = "2018"
license = "MIT OR Apache-2.0"
readme = "README.md"
repository = "https://github.com/near/near-workspaces-rs"
description = """
Library for automating workflows and testing NEAR smart contracts.
"""

[dependencies]
async-trait = "0.1"
base64 = "0.21"
bs58 = "0.5"
cargo_metadata = { version = "0.18", optional = true }
cargo-near = { version = "0.5.2", default-features = false }
chrono = "0.4.19"
fs2 = "0.4"
rand = "0.8.4"
reqwest = { version = "0.11", features = ["json"] }
sha2 = "0.10"
serde = "1.0"
serde_json = "1.0"
json-patch = "1.0"
tempfile = "3.3"
thiserror = "1.0"
tokio = { version = "1", features = ["full"] }
tokio-retry = "0.3"
tracing = "0.1"
url = { version = "2.2.2", features = ["serde"] }

near-abi-client = "0.1.1"
near-gas = { version = "0.2.5", features = ["serde", "borsh", "schemars"] }
near-token = { version = "0.2.0", features = ["serde"] }
near-sdk = { version = "5.0.0-alpha.2", optional = true }
near-account-id = "1.0.0"
near-crypto = "0.20.0"
near-primitives = "0.20.0"
near-jsonrpc-primitives = "0.20.0"
near-jsonrpc-client = { version = "0.8", features = ["sandbox"] }
near-sandbox-utils = "0.7.0"
near-chain-configs = { version = "0.20.0", optional = true }

[build-dependencies]
near-sandbox-utils = "0.7.0"

[target.'cfg(unix)'.dependencies]
libc = "0.2"

[dev-dependencies]
anyhow = "1.0"
futures = "0.3"
near-sdk = "5.0.0-alpha.2"
test-log = { version = "0.2.8", default-features = false, features = ["trace"] }
tracing-subscriber = { version = "0.3.5", features = ["env-filter"] }

[features]
default = ["install"]
install = []                          # Install the sandbox binary during compile time
interop_sdk = ["near-sdk"]
unstable = ["cargo_metadata"]
experimental = ["near-chain-configs"]

[package.metadata.docs.rs]
features = ["unstable"]

'''
'''--- workspaces/README.md ---
<div align="center">

  <h1>NEAR Workspaces (Rust Edition)</h1>

  <p>
    <strong>Rust library for automating workflows and writing tests for NEAR smart contracts. This software is not final, and will likely change.</strong>
  </p>

  <p>
    <a href="https://crates.io/crates/near-workspaces"><img src="https://img.shields.io/crates/v/near-workspaces.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-workspaces"><img src="https://img.shields.io/crates/d/near-workspaces.svg?style=flat-square" alt="Download" /></a>
    <a href="https://docs.rs/near-workspaces"><img src="https://docs.rs/near-workspaces/badge.svg" alt="Reference Documentation" /></a>
  </p>
</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Requirements

- Rust v1.69.0 and up.
- MacOS (x86 and M1) or Linux (x86) for sandbox tests.

### WASM compilation not supported

`near-workspaces-rs`, the library itself, does not currently compile to WASM. Best to put this dependency in `[dev-dependencies]` section of `Cargo.toml` if we were trying to run this library alongside something that already does compile to WASM, such as `near-sdk-rs`.

## Simple Testing Case

A simple test to get us going and familiar with `near-workspaces` framework. Here, we will be going through the NFT contract and how we can test it with `near-workspaces-rs`.

### Setup -- Imports

First, we need to declare some imports for convenience.

```rust
// macro allowing us to convert args into JSON bytes to be read by the contract.
use serde_json::json;
```

We will need to have our pre-compiled WASM contract ahead of time and know its path. Refer to the respective near-sdk-{rs, js} repos/language for where these paths are located.

In this showcase, we will be pointing to the example's NFT contract:

```rust
const NFT_WASM_FILEPATH: &str = "./examples/res/non_fungible_token.wasm";
```

NOTE: there is an unstable feature that will allow us to compile our projects during testing time as well. Take a look at the feature section [Compiling Contracts During Test Time](#compiling-contracts-during-test-time)

### Setup -- Setting up Sandbox and Deploying NFT Contract

This includes launching our sandbox, loading our wasm file and deploying that wasm file to the sandbox environment.

```rust

#[tokio::test]
async fn test_nft_contract() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;
```

Where

- `anyhow` - A crate that deals with error handling, making it more robust for developers.
- `worker` - Our gateway towards interacting with our sandbox environment.
- `contract`- The deployed contract on sandbox the developer interacts with.

### Initialize Contract & Test Output

Then we'll go directly into making a call into the contract, and initialize the NFT contract's metadata:

```rust
    let outcome = contract
        .call("new_default_meta")
        .args_json(json!({
            "owner_id": contract.id(),
        }))
        .transact()  // note: we use the contract's keys here to sign the transaction
        .await?;

    // outcome contains data like logs, receipts and transaction outcomes.
    println!("new_default_meta outcome: {:#?}", outcome);
```

Afterwards, let's mint an NFT via `nft_mint`. This showcases some extra arguments we can supply, such as deposit and gas:

```rust
    use near_gas::NearGas;
    use near_workspaces::types::NearToken;

    let deposit = NearToken::from_near(100);
    let outcome = contract
        .call("nft_mint")
        .args_json(json!({
            "token_id": "0",
            "token_owner_id": contract.id(),
            "token_metadata": {
                "title": "Olympus Mons",
                "description": "Tallest mountain in charted solar system",
                "copies": 1,
            },
        }))
        .deposit(deposit)
        // nft_mint might consume more than default gas, so supply our own gas value:
        .gas(NearGas::from_tgas(300))
        .transact()
        .await?;

    println!("nft_mint outcome: {:#?}", outcome);
```

Then later on, we can view our minted NFT's metadata via our `view` call into `nft_metadata`:

```rust
    let result: serde_json::Value = contract
        .call("nft_metadata")
        .view()
        .await?
        .json()?;

    println!("--------------\n{}", result);
    println!("Dev Account ID: {}", contract.id());
    Ok(())
}
```

### Updating Contract Afterwards

Note that if our contract code changes, `near-workspaces-rs` does nothing about it since we are utilizing `deploy`/`dev_deploy` to merely send the contract bytes to the network. So if it does change, we will have to recompile the contract as usual, and point `deploy`/`dev_deploy` again to the right WASM files. However, there is a feature that will recompile contract changes for us: refer to the experimental/unstable [`compile_project`](#compiling-contracts-during-test-time) function for telling near-workspaces to compile a _Rust_ project for us.

## Examples

More standalone examples can be found in `examples/src/*.rs`.

To run the above NFT example, execute:

```sh
cargo run --example nft
```

## Features

### Choosing a network

```rust
#[tokio::main]  // or whatever runtime we want
async fn main() -> anyhow::Result<()> {
    // Create a sandboxed environment.
    // NOTE: Each call will create a new sandboxed environment
    let worker = near_workspaces::sandbox().await?;
    // or for testnet:
    let worker = near_workspaces::testnet().await?;
}
```

### Helper Functions

Need to make a helper functions utilizing contracts? Just import it and pass it around:

```rust
use near_workspaces::Contract;

// Helper function that calls into a contract we give it
async fn call_my_func(contract: &Contract) -> anyhow::Result<()> {
    // Call into the function `contract_function` with args:
    contract.call("contract_function")
        .args_json(serde_json::json!({
            "message": msg,
        })
        .transact()
        .await?;
    Ok(())
}
```

Or to pass around workers regardless of networks:

```rust
use near_workspaces::{DevNetwork, Worker};

const CONTRACT_BYTES: &[u8] = include_bytes!("./relative/path/to/file.wasm");

// Create a helper function that deploys a specific contract
// NOTE: `dev_deploy` is only available on `DevNetwork`s such as sandbox and testnet.
async fn deploy_my_contract(worker: Worker<impl DevNetwork>) -> anyhow::Result<Contract> {
    worker.dev_deploy(CONTRACT_BYTES).await
}
```

### View Account Details

We can check the balance of our accounts like so:

```rs
#[test(tokio::test)]
async fn test_contract_transfer() -> anyhow::Result<()> {
    let transfer_amount = NearToken::from_millinear(100);
    let worker = near_workspaces::sandbox().await?;

    let contract = worker
        .dev_deploy(include_bytes!("../target/res/your_project_name.wasm"))
        .await?;
    contract.call("new")
        .max_gas()
        .transact()
        .await?;

    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let bob_original_balance = bob.view_account().await?.balance;

    alice.call(contract.id(), "function_that_transfers")
        .args_json(json!({ "destination_account": bob.id() }))
        .max_gas()
        .deposit(transfer_amount)
        .transact()
        .await?;
    assert_eq!(
        bob.view_account().await?.balance,
        bob_original_balance + transfer_amount
    );

    Ok(())
}
```

For viewing other chain related details, look at the docs for [Worker](https://docs.rs/near-workspaces/latest/near_workspaces/struct.Worker.html), [Account](https://docs.rs/near-workspaces/latest/near_workspaces/struct.Account.html) and [Contract](https://docs.rs/near-workspaces/latest/near_workspaces/struct.Contract.html)

### Spooning - Pulling Existing State and Contracts from Mainnet/Testnet

This example will showcase spooning state from a testnet contract into our local sandbox environment.

We will first start with the usual imports:

```rust
use near_workspaces::network::Sandbox;
use near_workspaces::{Account, AccountId, BlockHeight, Contract, Worker};
```

Then specify the contract name from testnet we want to be pulling:

```rust
const CONTRACT_ACCOUNT: &str = "contract_account_name_on_testnet.testnet";
```

Let's also specify a specific block ID referencing back to a specific time. Just in case our contract or the one we're referencing has been changed or updated:

```rust
const BLOCK_HEIGHT: BlockHeight = 12345;
```

Create a function called `pull_contract` which will pull the contract's `.wasm` file from the chain and deploy it onto our local sandbox. We'll have to re-initialize it with all the data to run tests.

```rust
async fn pull_contract(owner: &Account, worker: &Worker<Sandbox>) -> anyhow::Result<Contract> {
    let testnet = near_workspaces::testnet_archival().await?;
    let contract_id: AccountId = CONTRACT_ACCOUNT.parse()?;
```

This next line will actually pull down the relevant contract from testnet and set an initial balance on it with 1000 NEAR.

Following that we will have to init the contract again with our own metadata. This is because the contract's data is to big for the RPC service to pull down, who's limits are set to 50kb.

```rust

    use near_workspaces::types::NearToken;
    let contract = worker
        .import_contract(&contract_id, &testnet)
        .initial_balance(NearToken::from_near(1000))
        .block_height(BLOCK_HEIGHT)
        .transact()
        .await?;

    owner
        .call(contract.id(), "init_method_name")
        .args_json(serde_json::json!({
            "arg1": value1,
            "arg2": value2,
        }))
        .transact()
        .await?;

    Ok(contract)
}
```

### Time Traveling

`workspaces` testing offers support for forwarding the state of the blockchain to the future. This means contracts which require time sensitive data do not need to sit and wait the same amount of time for blocks on the sandbox to be produced. We can simply just call `worker.fast_forward` to get us further in time.
Note: This is not to be confused with speeding up the current in-flight transactions; the state being forwarded in this case refers to time-related state (the block height, timestamp and epoch).

```rust
#[tokio::test]
async fn test_contract() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker.dev_deploy(WASM_BYTES).await?;

    let blocks_to_advance = 10000;
    worker.fast_forward(blocks_to_advance).await?;

    // Now, "do_something_with_time" will be in the future and can act on future time-related state.
    contract.call("do_something_with_time")
        .transact()
        .await?;
}
```

For a full example, take a look at [examples/src/fast_forward.rs](https://github.com/near/near-workspaces-rs/blob/main/examples/src/fast_forward.rs).

### Compiling Contracts During Test Time

Note, this is an unstable feature and will very likely change. To enable it, add the `unstable` feature flag to `workspaces` dependency in `Cargo.toml`:

```toml
[dependencies]
near-workspaces = { version = "...", features = ["unstable"] }
```

Then, in our tests right before we call into `deploy` or `dev_deploy`, we can compile our projects:

```rust
#[tokio::test]
async fn test_contract() -> anyhow::Result<()> {
    let wasm = near_workspaces::compile_project("path/to/contract-rs-project").await?;

    let worker = workspaces::sandbox().await?;
    let contract = worker.dev_deploy(&wasm).await?;
    ...
}
```

For a full example, take a look at [workspaces/tests/deploy_project.rs](https://github.com/near/near-workspaces-rs/blob/main/workspaces/tests/deploy_project.rs).

### Coverage analysis of WASM executables

Generated code coverage reports help identify areas of code that are executed during testing, making it a valuable tool for ensuring the reliability and quality of your contracts.
[Here](https://hknio.github.io/wasmcov/docs/NEAR) is the step by step guide documentation to achieve this.

The project can be found here: <https://github.com/hknio/wasmcov>

### Other Features

Other features can be directly found in the `examples/` folder, with some documentation outlining how they can be used.

### Environment Variables

These environment variables will be useful if there was ever a snag hit:

- `NEAR_RPC_TIMEOUT_SECS`: The default is 10 seconds, but this is the amount of time before timing out waiting for a RPC service when talking to the sandbox or any other network such as testnet.
- `NEAR_SANDBOX_BIN_PATH`: Set this to our own prebuilt `neard-sandbox` bin path if we want to use a non-default version of the sandbox or configure nearcore with our own custom features that we want to test in near-workspaces.
- `NEAR_SANDBOX_MAX_PAYLOAD_SIZE`: Sets the max payload size for sending transaction commits to sandbox. The default is 1gb and is necessary for patching large states.
- `NEAR_SANDBOX_MAX_FILES`: Set the max amount of files that can be opened at a time in the sandbox. If none is specified, the default size of 4096 will be used. The actual near chain will use over 10,000 in practice, but for testing this should be much lower since we do not have a constantly running blockchain unless our tests take up that much time.
- `NEAR_RPC_API_KEY`: This is the API key necessary for communicating with RPC nodes. This is useful when interacting with services such as Pagoda Console or a service that can access RPC metrics. This is not a **hard** requirement, but it is recommended to running the Pagoda example in the examples folder.
- `NEAR_ENABLE_SANDBOX_LOG`: Set this to `1` to enable sandbox logging. This is useful for debugging issues with the `neard-sandbox` binary.

'''
'''--- workspaces/build.rs ---
fn main() {
    println!("cargo:rerun-if-env-changed=NEAR_SANDBOX_BIN_PATH");

    let doc_build = cfg!(doc) || std::env::var("DOCS_RS").is_ok();
    let env_bin = std::env::var("NEAR_SANDBOX_BIN_PATH").is_ok();
    if !doc_build && !env_bin && cfg!(feature = "install") {
        near_sandbox_utils::install().expect("Could not install sandbox");
    }
}

'''
'''--- workspaces/src/cargo/mod.rs ---
use crate::error::ErrorKind;

use cargo_near::commands::build_command::{build, BuildCommand};

/// Builds the cargo project located at `project_path` and returns the generated wasm file contents.
///
/// NOTE: This function does not check whether the resulting wasm file is a valid smart
/// contract or not.
pub async fn compile_project(project_path: &str) -> crate::Result<Vec<u8>> {
    let project_path = std::fs::canonicalize(project_path).map_err(|e| match e.kind() {
        std::io::ErrorKind::NotFound => ErrorKind::Io.message(format!(
            "Incorrect file supplied to compile_project('{}')",
            project_path
        )),
        _ => ErrorKind::Io.custom(e),
    })?;

    let cargo_near_build_command = BuildCommand {
        release: true,
        embed_abi: true,
        doc: false,
        color: None,
        no_abi: true,
        out_dir: None,
        manifest_path: Some(
            cargo_near::types::utf8_path_buf::Utf8PathBuf::from_path_buf(
                project_path.join("Cargo.toml"),
            )
            .map_err(|error_path| {
                ErrorKind::Io.custom(format!(
                    "Unable to construct UTF-8 path from: {}",
                    error_path.display()
                ))
            })?,
        ),
    };

    let compile_artifact =
        build::run(cargo_near_build_command).map_err(|e| ErrorKind::Io.custom(e))?;

    let file = compile_artifact
        .path
        .canonicalize()
        .map_err(|e| ErrorKind::Io.custom(e))?;
    tokio::fs::read(file)
        .await
        .map_err(|e| ErrorKind::Io.custom(e))
}

'''
'''--- workspaces/src/error/execution.rs ---
use std::fmt;

use crate::error::{Error, ErrorKind};
use crate::result::ExecutionFailure;

impl From<ExecutionFailure> for Error {
    fn from(error: ExecutionFailure) -> Self {
        ErrorKind::Execution.detailed(error)
    }
}

impl std::error::Error for ExecutionFailure {}

impl fmt::Display for ExecutionFailure {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.value)
    }
}

'''
'''--- workspaces/src/error/impls.rs ---
use std::fmt;
use std::{borrow::Cow, sync::PoisonError};

use crate::result::ExecutionFailure;

use super::{Error, ErrorKind, ErrorRepr, RpcErrorCode, SandboxErrorCode};

impl ErrorKind {
    pub(crate) fn custom<E>(self, error: E) -> Error
    where
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        Error::custom(self, error)
    }

    pub(crate) fn message<T>(self, msg: T) -> Error
    where
        T: Into<Cow<'static, str>>,
    {
        Error::message(self, msg)
    }

    pub(crate) fn full<T, E>(self, msg: T, error: E) -> Error
    where
        T: Into<Cow<'static, str>>,
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        Error::full(self, msg, error)
    }

    pub(crate) fn detailed(self, error: ExecutionFailure) -> Error {
        Error::detailed(self, error)
    }
}

impl Error {
    pub(crate) fn detailed(kind: ErrorKind, error: ExecutionFailure) -> Self {
        Self {
            repr: ErrorRepr::Detailed {
                kind,
                error: Box::new(error),
            },
        }
    }

    /// Construct a workspaces [`Error`] with the full details of an error which includes
    /// the internal error it references, the custom error message with further context
    /// and the [`ErrorKind`] that represents the category of error.
    pub(crate) fn full<T, E>(kind: ErrorKind, msg: T, error: E) -> Self
    where
        T: Into<Cow<'static, str>>,
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        Self {
            repr: ErrorRepr::Full {
                kind,
                message: msg.into(),
                error: error.into(),
            },
        }
    }

    /// Construct a workspaces [`Error`] with the details of an error which includes
    /// the internal error it references and the [`ErrorKind`] that represents the
    /// category of error.
    pub fn custom<E>(kind: ErrorKind, error: E) -> Self
    where
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        Self {
            repr: ErrorRepr::Custom {
                kind,
                error: error.into(),
            },
        }
    }

    /// Construct a workspaces [`Error`] with the details of an error which includes
    /// the custom error message with further context and the [`ErrorKind`] that
    /// represents the category of error.
    pub fn message<T>(kind: ErrorKind, msg: T) -> Self
    where
        T: Into<Cow<'static, str>>,
    {
        Self {
            repr: ErrorRepr::Message {
                kind,
                message: msg.into(),
            },
        }
    }

    /// Construct a workspaces [`Error`] with the details of an error which only
    /// includes the [`ErrorKind`] that represents the category of error.
    pub fn simple(kind: ErrorKind) -> Self {
        Self {
            repr: ErrorRepr::Simple(kind),
        }
    }

    /// Returns the corresponding [`ErrorKind`] for this error.
    pub fn kind(&self) -> &ErrorKind {
        match &self.repr {
            ErrorRepr::Simple(kind) => kind,
            ErrorRepr::Message { kind, .. } => kind,
            ErrorRepr::Custom { kind, .. } => kind,
            ErrorRepr::Full { kind, .. } => kind,
            ErrorRepr::Detailed { kind, .. } => kind,
        }
    }

    /// Consumes the `Error`, returning its inner error (if any).
    ///
    /// If this [`Error`] was constructed via a Custom or Full variant, then
    /// this function will return [`Ok`], otherwise it will return [`Err`].
    pub fn into_inner(self) -> Result<Box<dyn std::error::Error + Send + Sync>, Self> {
        match self.repr {
            ErrorRepr::Custom { error, .. } => Ok(error),
            ErrorRepr::Full { error, .. } => Ok(error),
            ErrorRepr::Detailed { error, .. } => Ok(error),
            _ => Err(self),
        }
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.repr)
    }
}

impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        self.repr.source()
    }
}

impl<T> From<PoisonError<T>> for Error {
    fn from(value: PoisonError<T>) -> Self {
        Self::custom(ErrorKind::Other, value.to_string())
    }
}

impl SandboxErrorCode {
    pub(crate) fn message<T>(self, msg: T) -> Error
    where
        T: Into<Cow<'static, str>>,
    {
        Error::message(ErrorKind::Sandbox(self), msg)
    }

    pub(crate) fn custom<E>(self, error: E) -> Error
    where
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        Error::custom(ErrorKind::Sandbox(self), error)
    }

    pub(crate) fn full<T, E>(self, msg: T, error: E) -> Error
    where
        T: Into<Cow<'static, str>>,
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        Error::full(ErrorKind::Sandbox(self), msg, error)
    }
}

impl From<SandboxErrorCode> for Error {
    fn from(code: SandboxErrorCode) -> Self {
        Self::simple(ErrorKind::Sandbox(code))
    }
}

impl RpcErrorCode {
    pub(crate) fn message<T>(self, msg: T) -> Error
    where
        T: Into<Cow<'static, str>>,
    {
        Error::message(ErrorKind::Rpc(self), msg)
    }

    pub(crate) fn custom<E>(self, error: E) -> Error
    where
        E: Into<Box<dyn std::error::Error + Send + Sync>>,
    {
        Error::custom(ErrorKind::Rpc(self), error)
    }
}

impl From<RpcErrorCode> for Error {
    fn from(code: RpcErrorCode) -> Self {
        Self::simple(ErrorKind::Rpc(code))
    }
}

'''
'''--- workspaces/src/error/mod.rs ---
//! All errors that can occur within workspaces, including but not limited to
//! the following: IO, RPC, Execution, Sandbox, DataConversion errors.

pub(crate) mod execution;
mod impls;

use std::borrow::Cow;

use crate::result::ExecutionFailure;

/// A list specifying general categories of NEAR workspace error.
#[derive(Clone, Debug, Eq, PartialEq, thiserror::Error)]
#[non_exhaustive]
pub enum ErrorKind {
    /// An error occurred while performing an RPC request.
    #[error("{0}")]
    Rpc(#[from] RpcErrorCode),
    /// An error occurred while processing a transaction.
    #[error("Execution")]
    Execution,
    /// An error having to do with running sandbox.
    #[error("{0}")]
    Sandbox(#[from] SandboxErrorCode),
    /// An error from performing IO.
    #[error("IO")]
    Io,
    /// An error from converting data.
    #[error("DataConversion")]
    DataConversion,
    /// An error that cannot be categorized into the other error kinds.
    #[error("Other")]
    Other,
}

#[derive(Debug, thiserror::Error)]
enum ErrorRepr {
    #[error("{0}")]
    Simple(ErrorKind),
    #[error("{message}")]
    Message {
        kind: ErrorKind,
        message: Cow<'static, str>,
    },
    #[error("{kind}")]
    Custom {
        kind: ErrorKind,
        #[source]
        error: Box<dyn std::error::Error + Send + Sync>,
    },
    #[error("{message}")]
    Full {
        kind: ErrorKind,
        message: Cow<'static, str>,
        #[source]
        error: Box<dyn std::error::Error + Send + Sync>,
    },
    #[error("{error}")]
    Detailed {
        kind: ErrorKind,
        // NOTE: Box to mitigate large size difference between enum variants
        error: Box<ExecutionFailure>,
    },
}

/// Error type that workspaces will make use of for all the errors
/// returned from this library
#[derive(Debug)]
pub struct Error {
    repr: ErrorRepr,
}

#[derive(Clone, Debug, Eq, PartialEq, thiserror::Error)]
#[non_exhaustive]
pub enum SandboxErrorCode {
    #[error("Sandbox has already been started")]
    AlreadyStarted,
    #[error("Could not initialize sandbox node")]
    InitFailure,
    #[error("Could not startup and run sandbox node")]
    RunFailure,
    #[error("Sandbox failed to patch state")]
    PatchStateFailure,
    #[error("Sandbox failed to fast forward")]
    FastForwardFailure,
}

#[derive(Clone, Debug, Eq, PartialEq, thiserror::Error)]
#[non_exhaustive]
pub enum RpcErrorCode {
    #[error("unable to create a new account via helper")]
    HelperAccountCreationFailure,
    #[error("failed to connect to rpc service")]
    ConnectionFailure,
    #[error("access key was unable to be retrieved")]
    UnableToRetrieveAccessKey,
    #[error("unable to broadcast the transaction to the network")]
    BroadcastTxFailure,
    #[error("unable to call into a view function")]
    ViewFunctionFailure,
    #[error("unable to fulfill the query request")]
    QueryFailure,
    #[error("incorrect variant retrieved while querying (maybe a bug in RPC code?)")]
    QueryReturnedInvalidData,
}

'''
'''--- workspaces/src/lib.rs ---
//! # NEAR Workspaces
//!
//! A library for automating workflows and writing tests for NEAR smart contracts.
//! This software is not final, and will likely change.

// We want to enable all clippy lints, but some of them generate false positives.
#![allow(clippy::missing_const_for_fn, clippy::redundant_pub_crate)]

#[cfg(feature = "unstable")]
mod cargo;
#[cfg(feature = "unstable")]
pub use cargo::compile_project;

mod worker;

pub mod error;
pub mod network;
pub mod operations;
pub mod prelude;
pub mod result;
pub mod rpc;
pub mod types;

/// The near_abi_client implementation is currently in flux and we offer a re-export
/// of it and example code. No public near_abi APIs are baked into workspace-rs yet.
pub use near_abi_client;

pub use network::pick_unused_port;
pub use network::variants::{DevNetwork, Network};
pub use result::Result;
pub use types::account::{Account, AccountDetailsPatch, Contract};
pub use types::block::Block;
pub use types::chunk::Chunk;
pub use types::{AccessKey, AccountId, BlockHeight, CryptoHash, InMemorySigner};
pub use worker::{
    betanet, mainnet, mainnet_archival, sandbox, sandbox_with_version, testnet, testnet_archival,
    with_betanet, with_mainnet, with_mainnet_archival, with_sandbox, with_testnet,
    with_testnet_archival, Worker,
};

#[cfg(feature = "unstable")]
pub use worker::{custom, with_custom};

'''
'''--- workspaces/src/network/betanet.rs ---
use url::Url;

use crate::network::builder::{FromNetworkBuilder, NetworkBuilder};
use crate::network::{Info, NetworkClient, NetworkInfo};
use crate::rpc::client::Client;

use std::path::PathBuf;

/// URL to the betanet RPC node provided by near.org.
pub const RPC_URL: &str = "https://rpc.betanet.near.org";

/// Betanet related configuration for interacting with betanet. Look at
/// [`workspaces::betanet`] for how to spin up a [`Worker`] that can be
/// used to interact with betanet. Note that betanet account creation
/// is not currently supported, and these calls into creating a betanet
/// worker is meant for retrieving data and/or making queries only.
/// Also, note that betanet can be unstable and does not provide an
/// archival endpoint similar to that of mainnet.
///
/// [`workspaces::betanet`]: crate::betanet
/// [`workspaces::betanet_archival`]: crate::betanet_archival
/// [`Worker`]: crate::Worker
pub struct Betanet {
    client: Client,
    info: Info,
}

#[async_trait::async_trait]
impl FromNetworkBuilder for Betanet {
    async fn from_builder<'a>(build: NetworkBuilder<'a, Self>) -> crate::result::Result<Self> {
        let rpc_url = build.rpc_addr.unwrap_or_else(|| RPC_URL.into());
        let client = Client::new(&rpc_url, build.api_key)?;
        client.wait_for_rpc().await?;

        Ok(Self {
            client,
            info: Info {
                name: build.name.into(),
                root_id: "near".parse().unwrap(),
                keystore_path: PathBuf::from(".near-credentials/betanet/"),
                rpc_url: Url::parse(&rpc_url).expect("url is hardcoded"),
            },
        })
    }
}

impl NetworkClient for Betanet {
    fn client(&self) -> &Client {
        &self.client
    }
}

impl NetworkInfo for Betanet {
    fn info(&self) -> &Info {
        &self.info
    }
}

'''
'''--- workspaces/src/network/builder.rs ---
use std::future::{Future, IntoFuture};
use std::marker::PhantomData;

use crate::network::Sandbox;
use crate::{Network, Worker};

use super::server::ValidatorKey;

pub(crate) type BoxFuture<'a, T> = std::pin::Pin<Box<dyn Future<Output = T> + Send + 'a>>;

/// This trait provides a way to construct Networks out of a single builder. Currently,
/// not planned to offer this trait outside, since the custom networks can just construct
/// themselves however they want utilizing `Worker::new` like so:
/// ```ignore
/// Worker::new(CustomNetwork {
///   ... // fields
/// })
/// ```
#[async_trait::async_trait]
pub(crate) trait FromNetworkBuilder: Sized {
    async fn from_builder<'a>(build: NetworkBuilder<'a, Self>) -> crate::result::Result<Self>;
}

/// Builder for Networks. Only usable with workspaces provided Networks.
// Note, this is currently the aggregated state for all network types you can have since
// I didn't want to add additional reading complexity with another trait that associates the
// Network state.
pub struct NetworkBuilder<'a, T> {
    pub(crate) name: &'a str,
    pub(crate) rpc_addr: Option<String>,
    pub(crate) validator_key: Option<ValidatorKey>,
    pub(crate) api_key: Option<String>,
    _network: PhantomData<T>,
}

impl<'a, T> IntoFuture for NetworkBuilder<'a, T>
where
    T: FromNetworkBuilder + Network + Send + 'a,
{
    type Output = crate::result::Result<Worker<T>>;
    type IntoFuture = BoxFuture<'a, Self::Output>;

    fn into_future(self) -> Self::IntoFuture {
        let fut = async {
            let network = FromNetworkBuilder::from_builder(self).await?;
            Ok(Worker::new(network))
        };
        Box::pin(fut)
    }
}

impl<'a, T> NetworkBuilder<'a, T> {
    pub(crate) fn new(name: &'a str) -> Self {
        Self {
            name,
            rpc_addr: None,
            validator_key: None,
            api_key: None,
            _network: PhantomData,
        }
    }

    /// Sets the RPC addr for this network. Useful for setting the Url to a different RPC
    /// node than the default one provided by near.org. This enables certain features that
    /// the default node doesn't provide such as getting beyond the data cap when downloading
    /// state from the network.
    ///
    /// Note that, for sandbox, we are required to specify `validator_key` as well to connect to
    /// a manually spawned sandbox node.
    pub fn rpc_addr(mut self, addr: &str) -> Self {
        self.rpc_addr = Some(addr.into());
        self
    }

    /// Sets the API key for this network. Useful for setting the API key to an RPC
    /// server that requires it.
    ///
    /// Note that if you're using a custom network, the burden is on you to ensure that
    /// the methods you're calling are supported by the RPC server you're connecting to.
    pub fn api_key(mut self, api_key: &str) -> Self {
        self.api_key = Some(api_key.into());
        self
    }
}

// So far, only Sandbox makes use of validator_key.
impl NetworkBuilder<'_, Sandbox> {
    /// Specify how to fetch the validator key of the manually spawned sandbox node.
    /// We are expected to init our own sandbox before running this builder. To learn more
    /// about initializing and  starting our own sandbox, go to [near-sandbox](https://github.com/near/sandbox).
    /// This can be either set to a known key value or to the home directory where all the chain data lives.
    /// This is the `my_home_folder` we passed into `near-sandbox --home {my_home_folder} init`.
    pub fn validator_key(mut self, validator_key: ValidatorKey) -> Self {
        self.validator_key = Some(validator_key);
        self
    }
}

'''
'''--- workspaces/src/network/config.rs ---
//! Network specific configurations used to modify behavior inside a chain.
//! This is so far only useable with sandbox networks since it would require
//! direct access to a node to change the config. Each network like mainnet
//! and testnet already have pre-configured settings; meanwhile sandbox can
//! have additional settings on top of them to facilitate custom behavior
//! such as sending large requests to the sandbox network.
//
// NOTE: nearcore has many, many configs which can easily change in the future
// so this config.rs file just purely modifies the data and does not try to
// replicate all the structs from nearcore side; which can be a huge maintenance
// churn if we were to.

use std::fs::File;
use std::io::BufReader;
use std::path::Path;

use serde_json::Value;

use crate::error::ErrorKind;
use crate::Result;

/// Overwrite the $home_dir/config.json file over a set of entries. `value` will be used per (key, value) pair
/// where value can also be another dict. This recursively sets all entry in `value` dict to the config
/// dict, and saves back into `home_dir` at the end of the day.
fn overwrite(home_dir: impl AsRef<Path>, value: Value) -> Result<()> {
    let home_dir = home_dir.as_ref();
    let config_file =
        File::open(home_dir.join("config.json")).map_err(|err| ErrorKind::Io.custom(err))?;
    let config = BufReader::new(config_file);
    let mut config: Value =
        serde_json::from_reader(config).map_err(|err| ErrorKind::DataConversion.custom(err))?;

    json_patch::merge(&mut config, &value);
    let config_file =
        File::create(home_dir.join("config.json")).map_err(|err| ErrorKind::Io.custom(err))?;
    serde_json::to_writer(config_file, &config).map_err(|err| ErrorKind::Io.custom(err))?;

    Ok(())
}

/// Parse an environment variable or return a default value.
fn parse_env<T>(env_var: &str) -> Result<Option<T>>
where
    T: std::str::FromStr,
    T::Err: std::error::Error + Send + Sync + 'static,
{
    match std::env::var(env_var) {
        Ok(val) => {
            let val = val
                .parse::<T>()
                .map_err(|err| ErrorKind::DataConversion.custom(err))?;

            Ok(Some(val))
        }
        Err(_err) => Ok(None),
    }
}

/// Set extra configs for the sandbox defined by workspaces.
pub(crate) fn set_sandbox_configs(home_dir: impl AsRef<Path>) -> Result<()> {
    overwrite(
        home_dir,
        serde_json::json!({
            "rpc": {
                "limits_config": {
                    // default to 1GB payload size so that large state patches can work.
                    "json_payload_max_size": parse_env("NEAR_SANDBOX_MAX_PAYLOAD_SIZE")?.unwrap_or(1024 * 1024 * 1024),
                },
            },
            "store": {
                // default to 3,000 files open at a time so that windows WSL can work without configuring.
                "max_open_files": parse_env("NEAR_SANDBOX_MAX_FILES")?.unwrap_or(3000),
            }
        }),
    )
}

'''
'''--- workspaces/src/network/custom.rs ---
use crate::network::{Info, NetworkClient, NetworkInfo};
use crate::result::Result;
use crate::rpc::client::Client;
use std::path::PathBuf;

use super::builder::{FromNetworkBuilder, NetworkBuilder};

/// Holds information about a custom network.
pub struct Custom {
    client: Client,
    info: Info,
}

#[async_trait::async_trait]
impl FromNetworkBuilder for Custom {
    async fn from_builder<'a>(build: NetworkBuilder<'a, Self>) -> Result<Self> {
        let rpc_url = build
            .rpc_addr
            .expect("rpc address should be provided for custom network");
        let client = Client::new(&rpc_url, build.api_key)?;
        client.wait_for_rpc().await?;

        Ok(Self {
            client,
            info: Info {
                name: build.name.into(),
                root_id: "near".parse().unwrap(),
                keystore_path: PathBuf::from(".near-credentials/mainnet/"),
                rpc_url: url::Url::parse(&rpc_url).expect("custom provided url should be valid"),
            },
        })
    }
}

impl std::fmt::Debug for Custom {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Custom")
            .field("root_id", &self.info.root_id)
            .field("rpc_url", &self.info.rpc_url)
            .finish()
    }
}

impl NetworkClient for Custom {
    fn client(&self) -> &Client {
        &self.client
    }
}

impl NetworkInfo for Custom {
    fn info(&self) -> &Info {
        &self.info
    }
}

'''
'''--- workspaces/src/network/info.rs ---
use std::path::PathBuf;

use crate::types::AccountId;

pub struct Info {
    /// Name of the network itself
    pub name: String,
    /// Root Account ID of the network. Mainnet has `near`, testnet has `testnet`.
    pub root_id: AccountId,
    /// Path to the keystore directory
    pub keystore_path: PathBuf,

    /// Rpc endpoint to point our client to
    pub rpc_url: url::Url,
}

'''
'''--- workspaces/src/network/mainnet.rs ---
use crate::network::{Info, NetworkClient, NetworkInfo};
use crate::result::Result;
use crate::rpc::client::Client;
use std::path::PathBuf;

use super::builder::{FromNetworkBuilder, NetworkBuilder};

/// URL to the mainnet RPC node provided by near.org.
pub const RPC_URL: &str = "https://rpc.mainnet.near.org";

/// URL to the mainnet archival RPC node provided by near.org.
pub const ARCHIVAL_URL: &str = "https://archival-rpc.mainnet.near.org";

/// Mainnet related configuration for interacting with mainnet. Look at
/// [`workspaces::mainnet`] and [`workspaces::mainnet_archival`] for how to
/// spin up a [`Worker`] that can be used to interact with mainnet. Note that
/// mainnet account creation is not currently supported, and these calls into
/// creating a mainnet worker is meant for retrieving data and/or making
/// queries only.
///
/// [`workspaces::mainnet`]: crate::mainnet
/// [`workspaces::mainnet_archival`]: crate::mainnet_archival
/// [`Worker`]: crate::Worker
pub struct Mainnet {
    client: Client,
    info: Info,
}

#[async_trait::async_trait]
impl FromNetworkBuilder for Mainnet {
    async fn from_builder<'a>(build: NetworkBuilder<'a, Self>) -> Result<Self> {
        let rpc_url = build.rpc_addr.unwrap_or_else(|| RPC_URL.into());
        let client = Client::new(&rpc_url, build.api_key)?;
        client.wait_for_rpc().await?;

        Ok(Self {
            client,
            info: Info {
                name: build.name.into(),
                root_id: "near".parse().unwrap(),
                keystore_path: PathBuf::from(".near-credentials/mainnet/"),
                rpc_url: url::Url::parse(&rpc_url).expect("url is hardcoded"),
            },
        })
    }
}

impl std::fmt::Debug for Mainnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Mainnet")
            .field("root_id", &self.info.root_id)
            .field("rpc_url", &self.info.rpc_url)
            .finish()
    }
}

impl NetworkClient for Mainnet {
    fn client(&self) -> &Client {
        &self.client
    }
}

impl NetworkInfo for Mainnet {
    fn info(&self) -> &Info {
        &self.info
    }
}

'''
'''--- workspaces/src/network/mod.rs ---
//! All builtin network types and traits.
//!
//! Currently the builtin network types are [`Mainnet`], [`Testnet`], and [`Sandbox`].

mod config;
mod info;
mod sandbox;
mod server;

pub(crate) mod builder;
pub(crate) mod variants;

pub mod betanet;
pub mod custom;
pub mod mainnet;
pub mod testnet;

pub(crate) use variants::DEV_ACCOUNT_SEED;

pub use self::betanet::Betanet;
pub use self::custom::Custom;
pub use self::info::Info;
pub use self::mainnet::Mainnet;
pub use self::sandbox::Sandbox;
pub use self::server::{pick_unused_port, ValidatorKey};
pub use self::testnet::Testnet;
pub use self::variants::{
    AllowDevAccountCreation, NetworkClient, NetworkInfo, TopLevelAccountCreator,
};

'''
'''--- workspaces/src/network/sandbox.rs ---
use std::path::PathBuf;
use std::str::FromStr;

use async_trait::async_trait;
use near_jsonrpc_client::methods::sandbox_fast_forward::RpcSandboxFastForwardRequest;
use near_jsonrpc_client::methods::sandbox_patch_state::RpcSandboxPatchStateRequest;
use near_primitives::state_record::StateRecord;
use near_sandbox_utils as sandbox;

use super::builder::{FromNetworkBuilder, NetworkBuilder};
use super::server::ValidatorKey;
use super::{AllowDevAccountCreation, NetworkClient, NetworkInfo, TopLevelAccountCreator};
use crate::error::SandboxErrorCode;
use crate::network::server::SandboxServer;
use crate::network::Info;
use crate::result::{Execution, ExecutionFinalResult, Result};
use crate::rpc::client::Client;
use crate::types::{AccountId, InMemorySigner, NearToken, SecretKey};
use crate::{Account, Contract, Network, Worker};

// Constant taken from nearcore crate to avoid dependency
const DEFAULT_DEPOSIT: NearToken = NearToken::from_near(100);
/// Local sandboxed environment/network, which can be used to test without interacting with
/// networks that are online such as mainnet and testnet. Look at [`workspaces::sandbox`]
/// for how to spin up a sandboxed network and interact with it.
///
/// [`workspaces::sandbox`]: crate::sandbox
pub struct Sandbox {
    pub(crate) server: SandboxServer,
    client: Client,
    info: Info,
    version: Option<String>,
}

impl Sandbox {
    pub(crate) fn root_signer(&self) -> Result<InMemorySigner> {
        match &self.server.validator_key {
            ValidatorKey::HomeDir(home_dir) => {
                let path = home_dir.join("validator_key.json");
                InMemorySigner::from_file(&path)
            }
            ValidatorKey::Known(account_id, secret_key) => Ok(InMemorySigner::from_secret_key(
                account_id.clone(),
                secret_key.clone(),
            )),
        }
    }
    pub(crate) async fn from_builder_with_version<'a>(
        build: NetworkBuilder<'a, Self>,
        version: &str,
    ) -> Result<Self> {
        // Check the conditions of the provided rpc_url and validator_key
        let mut server = match (build.rpc_addr, build.validator_key) {
            // Connect to a provided sandbox:
            (Some(rpc_url), Some(validator_key)) => {
                SandboxServer::connect(rpc_url, validator_key).await?
            }

            // Spawn a new sandbox since rpc_url and home_dir weren't specified:
            (None, None) => SandboxServer::run_new_with_version(version).await?,

            // Missing inputted parameters for sandbox:
            (Some(rpc_url), None) => {
                return Err(SandboxErrorCode::InitFailure.message(format!(
                    "Custom rpc_url={rpc_url} requires validator_key set."
                )));
            }
            (None, Some(validator_key)) => {
                return Err(SandboxErrorCode::InitFailure.message(format!(
                    "Custom validator_key={validator_key:?} requires rpc_url set."
                )));
            }
        };

        let client = Client::new(&server.rpc_addr(), build.api_key)?;
        client.wait_for_rpc().await?;

        // Server locks some ports on startup due to potential port collision, so we need
        // to unlock the lockfiles after RPC is ready. Not necessarily needed here since
        // they get unlocked anyways on the server's drop, but it is nice to clean up the
        // lockfiles as soon as possible.
        server.unlock_lockfiles()?;

        let info = Info {
            name: build.name.into(),
            root_id: AccountId::from_str("test.near").unwrap(),
            keystore_path: PathBuf::from(".near-credentials/sandbox/"),
            rpc_url: url::Url::parse(&server.rpc_addr()).expect("url is hardcoded"),
        };

        Ok(Self {
            server,
            client,
            info,
            version: Some(version.to_string()),
        })
    }
}

impl std::fmt::Debug for Sandbox {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Sandbox")
            .field("root_id", &self.info.root_id)
            .field("rpc_url", &self.info.rpc_url)
            .field("rpc_port", &self.server.rpc_port())
            .field("net_port", &self.server.net_port())
            .field("version", &self.version)
            .finish()
    }
}

#[async_trait]
impl FromNetworkBuilder for Sandbox {
    async fn from_builder<'a>(build: NetworkBuilder<'a, Self>) -> Result<Self> {
        Self::from_builder_with_version(build, sandbox::DEFAULT_NEAR_SANDBOX_VERSION).await
    }
}

impl AllowDevAccountCreation for Sandbox {}

#[async_trait]
impl TopLevelAccountCreator for Sandbox {
    async fn create_tla(
        &self,
        worker: Worker<dyn Network>,
        id: AccountId,
        sk: SecretKey,
    ) -> Result<Execution<Account>> {
        let root_signer = self.root_signer()?;
        let outcome = self
            .client()
            .create_account(&root_signer, &id, sk.public_key(), DEFAULT_DEPOSIT)
            .await?;

        let signer = InMemorySigner::from_secret_key(id, sk);
        Ok(Execution {
            result: Account::new(signer, worker),
            details: ExecutionFinalResult::from_view(outcome),
        })
    }

    async fn create_tla_and_deploy(
        &self,
        worker: Worker<dyn Network>,
        id: AccountId,
        sk: SecretKey,
        wasm: &[u8],
    ) -> Result<Execution<Contract>> {
        let root_signer = self.root_signer()?;
        let outcome = self
            .client()
            .create_account_and_deploy(
                &root_signer,
                &id,
                sk.public_key(),
                DEFAULT_DEPOSIT,
                wasm.into(),
            )
            .await?;

        let signer = InMemorySigner::from_secret_key(id, sk);
        Ok(Execution {
            result: Contract::new(signer, worker),
            details: ExecutionFinalResult::from_view(outcome),
        })
    }
}

impl NetworkClient for Sandbox {
    fn client(&self) -> &Client {
        &self.client
    }
}

impl NetworkInfo for Sandbox {
    fn info(&self) -> &Info {
        &self.info
    }
}

impl Sandbox {
    pub(crate) async fn patch_state(
        &self,
        contract_id: &AccountId,
        key: &[u8],
        value: &[u8],
    ) -> Result<()> {
        let state = StateRecord::Data {
            account_id: contract_id.to_owned(),
            data_key: key.to_vec().into(),
            value: value.to_vec().into(),
        };
        let records = vec![state];

        // NOTE: RpcSandboxPatchStateResponse is an empty struct with no fields, so don't do anything with it:
        let _patch_resp = self
            .client()
            .query(&RpcSandboxPatchStateRequest { records })
            .await
            .map_err(|e| SandboxErrorCode::PatchStateFailure.custom(e))?;

        Ok(())
    }

    pub(crate) async fn fast_forward(&self, delta_height: u64) -> Result<()> {
        // NOTE: RpcSandboxFastForwardResponse is an empty struct with no fields, so don't do anything with it:
        self.client()
            // TODO: replace this with the `query` variant when RpcSandboxFastForwardRequest impls Debug
            .query_nolog(&RpcSandboxFastForwardRequest { delta_height })
            .await
            .map_err(|e| SandboxErrorCode::FastForwardFailure.custom(e))?;

        Ok(())
    }
}

'''
'''--- workspaces/src/network/server.rs ---
use std::fs::File;
use std::net::{Ipv4Addr, SocketAddrV4};
use std::path::PathBuf;

use crate::error::{ErrorKind, SandboxErrorCode};
use crate::result::Result;
use crate::types::SecretKey;

use fs2::FileExt;

use near_account_id::AccountId;
use reqwest::Url;
use tempfile::TempDir;
use tokio::process::Child;

use tracing::info;

use near_sandbox_utils as sandbox;
use tokio::net::TcpListener;

// Must be an IP address as `neard` expects socket address for network address.
const DEFAULT_RPC_HOST: &str = "127.0.0.1";

fn rpc_socket(port: u16) -> String {
    format!("{DEFAULT_RPC_HOST}:{}", port)
}

/// Request an unused port from the OS.
pub async fn pick_unused_port() -> Result<u16> {
    // Port 0 means the OS gives us an unused port
    // Important to use localhost as using 0.0.0.0 leads to users getting brief firewall popups to
    // allow inbound connections on MacOS.
    let addr = SocketAddrV4::new(Ipv4Addr::LOCALHOST, 0);
    let listener = TcpListener::bind(addr)
        .await
        .map_err(|err| ErrorKind::Io.full("failed to bind to random port", err))?;
    let port = listener
        .local_addr()
        .map_err(|err| ErrorKind::Io.full("failed to get local address for random port", err))?
        .port();
    Ok(port)
}

/// Acquire an unused port and lock it for the duration until the sandbox server has
/// been started.
async fn acquire_unused_port() -> Result<(u16, File)> {
    loop {
        let port = pick_unused_port().await?;
        let lockpath = std::env::temp_dir().join(format!("near-sandbox-port{}.lock", port));
        let lockfile = File::create(lockpath).map_err(|err| {
            ErrorKind::Io.full(format!("failed to create lockfile for port {}", port), err)
        })?;
        if lockfile.try_lock_exclusive().is_ok() {
            break Ok((port, lockfile));
        }
    }
}

#[allow(dead_code)]
async fn init_home_dir() -> Result<TempDir> {
    init_home_dir_with_version(sandbox::DEFAULT_NEAR_SANDBOX_VERSION).await
}

async fn init_home_dir_with_version(version: &str) -> Result<TempDir> {
    let home_dir = tempfile::tempdir().map_err(|e| ErrorKind::Io.custom(e))?;

    let output = sandbox::init_with_version(&home_dir, version)
        .map_err(|e| SandboxErrorCode::InitFailure.custom(e))?
        .wait_with_output()
        .await
        .map_err(|e| SandboxErrorCode::InitFailure.custom(e))?;

    info!(target: "workspaces", "sandbox init: {:?}", output);

    Ok(home_dir)
}

#[derive(Debug)]
#[non_exhaustive]
pub enum ValidatorKey {
    HomeDir(PathBuf),
    Known(AccountId, SecretKey),
}

pub struct SandboxServer {
    pub(crate) validator_key: ValidatorKey,
    rpc_addr: Url,
    net_port: Option<u16>,
    rpc_port_lock: Option<File>,
    net_port_lock: Option<File>,
    process: Option<Child>,
}

impl SandboxServer {
    /// Connect a sandbox server that's already been running, provided we know the rpc_addr
    /// and home_dir pointing to the sandbox process.
    pub(crate) async fn connect(rpc_addr: String, validator_key: ValidatorKey) -> Result<Self> {
        let rpc_addr = Url::parse(&rpc_addr).map_err(|e| {
            SandboxErrorCode::InitFailure.full(format!("Invalid rpc_url={rpc_addr}"), e)
        })?;
        Ok(Self {
            validator_key,
            rpc_addr,
            net_port: None,
            rpc_port_lock: None,
            net_port_lock: None,
            process: None,
        })
    }

    /// Run a new SandboxServer, spawning the sandbox node in the process.
    #[allow(dead_code)]
    pub(crate) async fn run_new() -> Result<Self> {
        Self::run_new_with_version(sandbox::DEFAULT_NEAR_SANDBOX_VERSION).await
    }

    pub(crate) async fn run_new_with_version(version: &str) -> Result<Self> {
        // Suppress logs for the sandbox binary by default:
        suppress_sandbox_logs_if_required();

        let home_dir = init_home_dir_with_version(version).await?.into_path();
        // Configure `$home_dir/config.json` to our liking. Sandbox requires extra settings
        // for the best user experience, and being able to offer patching large state payloads.
        crate::network::config::set_sandbox_configs(&home_dir)?;

        // Try running the server with the follow provided rpc_ports and net_ports
        let (rpc_port, rpc_port_lock) = acquire_unused_port().await?;
        let (net_port, net_port_lock) = acquire_unused_port().await?;
        // It's important that the address doesn't have a scheme, since the sandbox expects
        // a valid socket address.
        let rpc_addr = rpc_socket(rpc_port);
        let net_addr = rpc_socket(net_port);

        info!(target: "workspaces", "Starting up sandbox at localhost:{}", rpc_port);

        let options = &[
            "--home",
            home_dir
                .as_os_str()
                .to_str()
                .expect("home_dir is valid utf8"),
            "run",
            "--rpc-addr",
            &rpc_addr,
            "--network-addr",
            &net_addr,
        ];

        let child = sandbox::run_with_options_with_version(options, version)
            .map_err(|e| SandboxErrorCode::RunFailure.custom(e))?;

        info!(target: "workspaces", "Started up sandbox at localhost:{} with pid={:?}", rpc_port, child.id());

        let rpc_addr: Url = format!("http://{rpc_addr}")
            .parse()
            .expect("static scheme and host name with variable u16 port numbers form valid urls");

        Ok(Self {
            validator_key: ValidatorKey::HomeDir(home_dir),
            rpc_addr,
            net_port: Some(net_port),
            rpc_port_lock: Some(rpc_port_lock),
            net_port_lock: Some(net_port_lock),
            process: Some(child),
        })
    }

    /// Unlock port lockfiles that were used to avoid port contention when starting up
    /// the sandbox node.
    pub(crate) fn unlock_lockfiles(&mut self) -> Result<()> {
        if let Some(rpc_port_lock) = self.rpc_port_lock.take() {
            rpc_port_lock.unlock().map_err(|e| {
                ErrorKind::Io.full(
                    format!(
                        "failed to unlock lockfile for rpc_port={:?}",
                        self.rpc_port()
                    ),
                    e,
                )
            })?;
        }
        if let Some(net_port_lock) = self.net_port_lock.take() {
            net_port_lock.unlock().map_err(|e| {
                ErrorKind::Io.full(
                    format!("failed to unlock lockfile for net_port={:?}", self.net_port),
                    e,
                )
            })?;
        }

        Ok(())
    }

    pub fn rpc_port(&self) -> Option<u16> {
        self.rpc_addr.port()
    }

    pub fn net_port(&self) -> Option<u16> {
        self.net_port
    }

    pub fn rpc_addr(&self) -> String {
        self.rpc_addr.to_string()
    }
}

impl Drop for SandboxServer {
    fn drop(&mut self) {
        if let Some(mut child) = self.process.take() {
            info!(
                target: "workspaces",
                "Cleaning up sandbox: pid={:?}",
                child.id()
            );

            child.start_kill().expect("failed to kill sandbox");
            let _ = child.try_wait();
        }
    }
}

/// Turn off neard-sandbox logs by default. Users can turn them back on with
/// NEAR_ENABLE_SANDBOX_LOG=1 and specify further parameters with the custom
/// NEAR_SANDBOX_LOG for higher levels of specificity. NEAR_SANDBOX_LOG args
/// will be forward into RUST_LOG environment variable as to not conflict
/// with similar named log targets.
fn suppress_sandbox_logs_if_required() {
    if let Ok(val) = std::env::var("NEAR_ENABLE_SANDBOX_LOG") {
        if val != "0" {
            return;
        }
    }

    // non-exhaustive list of targets to suppress, since choosing a default LogLevel
    // does nothing in this case, since nearcore seems to be overriding it somehow:
    std::env::set_var("NEAR_SANDBOX_LOG", "near=error,stats=error,network=error");
}

'''
'''--- workspaces/src/network/testnet.rs ---
use std::path::PathBuf;
use std::str::FromStr;

use async_trait::async_trait;
use near_gas::NearGas;
use url::Url;

use near_primitives::views::ExecutionStatusView;

use crate::network::builder::{FromNetworkBuilder, NetworkBuilder};
use crate::network::Info;
use crate::network::{AllowDevAccountCreation, NetworkClient, NetworkInfo, TopLevelAccountCreator};
use crate::result::{Execution, ExecutionDetails, ExecutionFinalResult, ExecutionOutcome, Result};
use crate::rpc::{client::Client, tool};
use crate::types::{AccountId, InMemorySigner, NearToken, SecretKey};
use crate::{Account, Contract, CryptoHash, Network, Worker};

/// URL to the testnet RPC node provided by near.org.
pub const RPC_URL: &str = "https://rpc.testnet.near.org";

/// URL to the helper contract used to create top-level-accounts (TLA) provided by near.org.
pub const HELPER_URL: &str = "https://helper.testnet.near.org";

/// URL to the testnet archival RPC node provided by near.org.
pub const ARCHIVAL_URL: &str = "https://archival-rpc.testnet.near.org";

/// Testnet related configuration for interacting with testnet. Look at
/// [`workspaces::testnet`] and [`workspaces::testnet_archival`] for how
/// to spin up a [`Worker`] that can be used to run tests in testnet.
///
/// [`workspaces::testnet`]: crate::testnet
/// [`workspaces::testnet_archival`]: crate::testnet_archival
/// [`Worker`]: crate::Worker
pub struct Testnet {
    client: Client,
    info: Info,
}

#[async_trait]
impl FromNetworkBuilder for Testnet {
    async fn from_builder<'a>(build: NetworkBuilder<'a, Self>) -> Result<Self> {
        let rpc_url = build.rpc_addr.unwrap_or_else(|| RPC_URL.into());
        let client = Client::new(&rpc_url, build.api_key)?;
        client.wait_for_rpc().await?;

        Ok(Self {
            client,
            info: Info {
                name: build.name.into(),
                root_id: AccountId::from_str("testnet").unwrap(),
                keystore_path: PathBuf::from(".near-credentials/testnet/"),
                rpc_url: Url::parse(&rpc_url).expect("url is hardcoded"),
            },
        })
    }
}

impl std::fmt::Debug for Testnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Testnet")
            .field("root_id", &self.info.root_id)
            .field("rpc_url", &self.info.rpc_url)
            .finish()
    }
}

impl AllowDevAccountCreation for Testnet {}

#[async_trait]
impl TopLevelAccountCreator for Testnet {
    async fn create_tla(
        &self,
        worker: Worker<dyn Network>,
        id: AccountId,
        sk: SecretKey,
        // TODO: return Account only, but then you don't get metadata info for it...
    ) -> Result<Execution<Account>> {
        let url = Url::parse(HELPER_URL).unwrap();
        tool::url_create_account(url, id.clone(), sk.public_key()).await?;
        let signer = InMemorySigner::from_secret_key(id, sk);

        Ok(Execution {
            result: Account::new(signer, worker),
            details: ExecutionFinalResult {
                // We technically have not burnt any gas ourselves since someone else paid to
                // create the account for us in testnet when we used the Helper contract.
                total_gas_burnt: NearGas::from_gas(0),

                status: near_primitives::views::FinalExecutionStatus::SuccessValue(Vec::new()),
                details: ExecutionDetails {
                    transaction: ExecutionOutcome {
                        transaction_hash: CryptoHash::default(),
                        block_hash: CryptoHash::default(),
                        logs: Vec::new(),
                        receipt_ids: Vec::new(),
                        gas_burnt: NearGas::from_gas(0),
                        tokens_burnt: NearToken::from_near(0),
                        executor_id: "testnet".parse().unwrap(),
                        status: ExecutionStatusView::SuccessValue(Vec::new()),
                    },
                    receipts: Vec::new(),
                },
            },
        })
    }

    async fn create_tla_and_deploy(
        &self,
        worker: Worker<dyn Network>,
        id: AccountId,
        sk: SecretKey,
        wasm: &[u8],
    ) -> Result<Execution<Contract>> {
        let signer = InMemorySigner::from_secret_key(id.clone(), sk.clone());
        let account = self.create_tla(worker, id.clone(), sk).await?;

        let outcome = self.client().deploy(&signer, &id, wasm.into()).await?;

        Ok(Execution {
            result: Contract::account(account.into_result()?),
            details: ExecutionFinalResult::from_view(outcome),
        })
    }
}

impl NetworkClient for Testnet {
    fn client(&self) -> &Client {
        &self.client
    }
}

impl NetworkInfo for Testnet {
    fn info(&self) -> &Info {
        &self.info
    }
}

'''
'''--- workspaces/src/network/variants.rs ---
use crate::network::Info;
use crate::result::{Execution, Result};
use crate::rpc::client::Client;
use crate::types::{AccountId, KeyType, SecretKey};
use crate::{Account, Contract, Worker};
use async_trait::async_trait;

pub(crate) const DEV_ACCOUNT_SEED: &str = "testificate";

pub trait NetworkClient {
    fn client(&self) -> &Client;
}

pub trait NetworkInfo {
    fn info(&self) -> &Info;
}

#[async_trait]
pub trait TopLevelAccountCreator {
    async fn create_tla(
        &self,
        worker: Worker<dyn Network>,
        id: AccountId,
        sk: SecretKey,
    ) -> Result<Execution<Account>>;

    async fn create_tla_and_deploy(
        &self,
        worker: Worker<dyn Network>,
        id: AccountId,
        sk: SecretKey,
        wasm: &[u8],
    ) -> Result<Execution<Contract>>;
}

// NOTE: Not all networks/runtimes will have the ability to be able to do dev_deploy.
// This trait acts as segmented boundary for only specific networks such as sandbox and testnet.
pub trait AllowDevAccountCreation {}

impl<T> Worker<T>
where
    T: DevNetwork + TopLevelAccountCreator + 'static,
{
    pub async fn create_tla(&self, id: AccountId, sk: SecretKey) -> Result<Execution<Account>> {
        let res = self
            .workspace
            .create_tla(self.clone().coerce(), id, sk)
            .await?;

        for callback in self.tx_callbacks.iter() {
            callback(res.details.total_gas_burnt)?;
        }

        Ok(res)
    }

    pub async fn create_tla_and_deploy(
        &self,
        id: AccountId,
        sk: SecretKey,
        wasm: &[u8],
    ) -> Result<Execution<Contract>> {
        let res = self
            .workspace
            .create_tla_and_deploy(self.clone().coerce(), id, sk, wasm)
            .await?;

        for callback in self.tx_callbacks.iter() {
            callback(res.details.total_gas_burnt)?;
        }

        Ok(res)
    }

    pub async fn dev_generate(&self) -> (AccountId, SecretKey) {
        let id = crate::rpc::tool::random_account_id();
        let sk = SecretKey::from_seed(KeyType::ED25519, DEV_ACCOUNT_SEED);
        (id, sk)
    }

    pub async fn dev_create_account(&self) -> Result<Account> {
        let (id, sk) = self.dev_generate().await;
        let account = self.create_tla(id.clone(), sk).await?;
        Ok(account.into_result()?)
    }

    pub async fn dev_deploy(&self, wasm: &[u8]) -> Result<Contract> {
        let (id, sk) = self.dev_generate().await;
        let contract = self.create_tla_and_deploy(id.clone(), sk, wasm).await?;
        Ok(contract.into_result()?)
    }
}

/// Network trait specifies the functionality of a network type such as mainnet, testnet or any
/// other networks that are not specified in this library.
pub trait Network: NetworkInfo + NetworkClient + Send + Sync {}

impl<T> Network for T where T: NetworkInfo + NetworkClient + Send + Sync {}

/// DevNetwork is a Network that can call into `dev_create` and `dev_deploy` to create developer accounts.
pub trait DevNetwork: TopLevelAccountCreator + AllowDevAccountCreation + Network + 'static {}

impl<T> DevNetwork for T where
    T: TopLevelAccountCreator + AllowDevAccountCreation + Network + 'static
{
}

'''
'''--- workspaces/src/operations.rs ---
//! All operation types that are generated/used when making transactions or view calls.

use crate::error::{ErrorKind, RpcErrorCode};
use crate::result::{Execution, ExecutionFinalResult, Result, ViewResultDetails};
use crate::rpc::client::{
    send_batch_tx_and_retry, send_batch_tx_async_and_retry, DEFAULT_CALL_DEPOSIT,
    DEFAULT_CALL_FN_GAS,
};
use crate::rpc::query::{Query, ViewFunction};
use crate::types::{
    AccessKey, AccountId, Gas, InMemorySigner, KeyType, NearToken, PublicKey, SecretKey,
};
use crate::worker::Worker;
use crate::{Account, CryptoHash, Network};

use near_account_id::ParseAccountError;
use near_gas::NearGas;
use near_jsonrpc_client::errors::{JsonRpcError, JsonRpcServerError};
use near_jsonrpc_client::methods::tx::RpcTransactionError;
use near_primitives::borsh;
use near_primitives::transaction::{
    Action, AddKeyAction, CreateAccountAction, DeleteAccountAction, DeleteKeyAction,
    DeployContractAction, FunctionCallAction, StakeAction, TransferAction,
};
use near_primitives::views::FinalExecutionOutcomeView;
use std::convert::TryInto;
use std::fmt;
use std::future::IntoFuture;
use std::pin::Pin;
use std::task::Poll;

const MAX_GAS: NearGas = NearGas::from_tgas(300);

/// A set of arguments we can provide to a transaction, containing
/// the function name, arguments, the amount of gas to use and deposit.
#[derive(Debug)]
pub struct Function {
    pub(crate) name: String,
    pub(crate) args: Result<Vec<u8>>,
    pub(crate) deposit: NearToken,
    pub(crate) gas: Gas,
}

impl Function {
    /// Initialize a new instance of [`Function`], tied to a specific function on a
    /// contract that lives directly on a contract we've specified in [`Transaction`].
    pub fn new(name: &str) -> Self {
        Self {
            name: name.into(),
            args: Ok(vec![]),
            deposit: DEFAULT_CALL_DEPOSIT,
            gas: DEFAULT_CALL_FN_GAS,
        }
    }

    /// Provide the arguments for the call. These args are serialized bytes from either
    /// a JSON or Borsh serializable set of arguments. To use the more specific versions
    /// with better quality of life, use `args_json` or `args_borsh`.
    pub fn args(mut self, args: Vec<u8>) -> Self {
        if self.args.is_err() {
            return self;
        }
        self.args = Ok(args);
        self
    }

    /// Similar to `args`, specify an argument that is JSON serializable and can be
    /// accepted by the equivalent contract. Recommend to use something like
    /// `serde_json::json!` macro to easily serialize the arguments.
    pub fn args_json<U: serde::Serialize>(mut self, args: U) -> Self {
        match serde_json::to_vec(&args) {
            Ok(args) => self.args = Ok(args),
            Err(e) => self.args = Err(ErrorKind::DataConversion.custom(e)),
        }
        self
    }

    /// Similar to `args`, specify an argument that is borsh serializable and can be
    /// accepted by the equivalent contract.
    pub fn args_borsh<U: borsh::BorshSerialize>(mut self, args: U) -> Self {
        match borsh::to_vec(&args) {
            Ok(args) => self.args = Ok(args),
            Err(e) => self.args = Err(ErrorKind::DataConversion.custom(e)),
        }
        self
    }

    /// Specify the amount of tokens to be deposited where `deposit` is the amount of
    /// tokens in yocto near.
    pub fn deposit(mut self, deposit: NearToken) -> Self {
        self.deposit = deposit;
        self
    }

    /// Specify the amount of gas to be used.
    pub fn gas(mut self, gas: Gas) -> Self {
        self.gas = gas;
        self
    }

    /// Use the maximum amount of gas possible to perform this function call into the contract.
    pub fn max_gas(self) -> Self {
        self.gas(MAX_GAS)
    }
}

/// A builder-like object that will allow specifying various actions to be performed
/// in a single transaction. For details on each of the actions, find them in
/// [NEAR transactions](https://docs.near.org/docs/concepts/transaction).
///
/// All actions are performed on the account specified by `receiver_id`. This object
/// is most commonly constructed from [`Account::batch`] or [`Contract::batch`],
/// where `receiver_id` is specified in the `Account::batch` while `Contract::id()`
/// is used by default for `Contract::batch`.
///
/// [`Contract::batch`]: crate::Contract::batch
pub struct Transaction {
    worker: Worker<dyn Network>,
    signer: InMemorySigner,
    receiver_id: AccountId,
    // Result used to defer errors in argument parsing to later when calling into transact
    actions: Result<Vec<Action>>,
}

impl Transaction {
    pub(crate) fn new(
        worker: Worker<dyn Network>,
        signer: InMemorySigner,
        receiver_id: AccountId,
    ) -> Self {
        Self {
            worker,
            signer,
            receiver_id,
            actions: Ok(Vec::new()),
        }
    }

    /// Adds a key to the `receiver_id`'s account, where the public key can be used
    /// later to delete the same key.
    pub fn add_key(mut self, pk: PublicKey, ak: AccessKey) -> Self {
        if let Ok(actions) = &mut self.actions {
            actions.push(
                AddKeyAction {
                    public_key: pk.into(),
                    access_key: ak.into(),
                }
                .into(),
            );
        }

        self
    }

    /// Call into the `receiver_id`'s contract with the specific function arguments.
    pub fn call(mut self, function: Function) -> Self {
        let args = match function.args {
            Ok(args) => args,
            Err(err) => {
                self.actions = Err(err);
                return self;
            }
        };

        if let Ok(actions) = &mut self.actions {
            actions.push(Action::FunctionCall(Box::new(FunctionCallAction {
                method_name: function.name.to_string(),
                args,
                deposit: function.deposit.as_yoctonear(),
                gas: function.gas.as_gas(),
            })));
        }

        self
    }

    /// Create a new account with the account id being `receiver_id`.
    pub fn create_account(mut self) -> Self {
        if let Ok(actions) = &mut self.actions {
            actions.push(CreateAccountAction {}.into());
        }
        self
    }

    /// Deletes the `receiver_id`'s account. The beneficiary specified by
    /// `beneficiary_id` will receive the funds of the account deleted.
    pub fn delete_account(mut self, beneficiary_id: &AccountId) -> Self {
        if let Ok(actions) = &mut self.actions {
            actions.push(
                DeleteAccountAction {
                    beneficiary_id: beneficiary_id.clone(),
                }
                .into(),
            );
        }
        self
    }

    /// Deletes a key from the `receiver_id`'s account, where the public key is
    /// associated with the access key to be deleted.
    pub fn delete_key(mut self, pk: PublicKey) -> Self {
        if let Ok(actions) = &mut self.actions {
            actions.push(DeleteKeyAction { public_key: pk.0 }.into());
        }
        self
    }

    /// Deploy contract code or WASM bytes to the `receiver_id`'s account.
    pub fn deploy(mut self, code: &[u8]) -> Self {
        if let Ok(actions) = &mut self.actions {
            actions.push(DeployContractAction { code: code.into() }.into());
        }
        self
    }

    /// An action which stakes the signer's tokens and setups a validator public key.
    pub fn stake(mut self, stake: NearToken, pk: PublicKey) -> Self {
        if let Ok(actions) = &mut self.actions {
            actions.push(
                StakeAction {
                    stake: stake.as_yoctonear(),
                    public_key: pk.0,
                }
                .into(),
            );
        }
        self
    }

    /// Transfer `deposit` amount from `signer`'s account into `receiver_id`'s account.
    pub fn transfer(mut self, deposit: NearToken) -> Self {
        if let Ok(actions) = &mut self.actions {
            actions.push(
                TransferAction {
                    deposit: deposit.as_yoctonear(),
                }
                .into(),
            );
        }
        self
    }

    async fn transact_raw(self) -> Result<FinalExecutionOutcomeView> {
        let view = send_batch_tx_and_retry(
            self.worker.client(),
            &self.signer,
            &self.receiver_id,
            self.actions?,
        )
        .await?;

        if !self.worker.tx_callbacks.is_empty() {
            let total_gas_burnt = view.transaction_outcome.outcome.gas_burnt
                + view
                    .receipts_outcome
                    .iter()
                    .map(|t| t.outcome.gas_burnt)
                    .sum::<u64>();

            for callback in self.worker.tx_callbacks {
                callback(Gas::from_gas(total_gas_burnt))?;
            }
        }

        Ok(view)
    }

    /// Process the transaction, and return the result of the execution.
    pub async fn transact(self) -> Result<ExecutionFinalResult> {
        self.transact_raw()
            .await
            .map(ExecutionFinalResult::from_view)
            .map_err(crate::error::Error::from)
    }

    /// Send the transaction to the network to be processed. This will be done asynchronously
    /// without waiting for the transaction to complete. This returns us a [`TransactionStatus`]
    /// for which we can call into [`status`] and/or `.await` to retrieve info about whether
    /// the transaction has been completed or not. Note that `.await` will wait till completion
    /// of the transaction.
    ///
    /// [`status`]: TransactionStatus::status
    pub async fn transact_async(self) -> Result<TransactionStatus> {
        send_batch_tx_async_and_retry(self.worker, &self.signer, &self.receiver_id, self.actions?)
            .await
    }
}

/// Similar to a [`Transaction`], but more specific to making a call into a contract.
/// Note, only one call can be made per `CallTransaction`.
pub struct CallTransaction {
    worker: Worker<dyn Network>,
    signer: InMemorySigner,
    contract_id: AccountId,
    function: Function,
}

impl CallTransaction {
    pub(crate) fn new(
        worker: Worker<dyn Network>,
        contract_id: AccountId,
        signer: InMemorySigner,
        function: &str,
    ) -> Self {
        Self {
            worker,
            signer,
            contract_id,
            function: Function::new(function),
        }
    }

    /// Provide the arguments for the call. These args are serialized bytes from either
    /// a JSON or Borsh serializable set of arguments. To use the more specific versions
    /// with better quality of life, use `args_json` or `args_borsh`.
    pub fn args(mut self, args: Vec<u8>) -> Self {
        self.function = self.function.args(args);
        self
    }

    /// Similar to `args`, specify an argument that is JSON serializable and can be
    /// accepted by the equivalent contract. Recommend to use something like
    /// `serde_json::json!` macro to easily serialize the arguments.
    pub fn args_json<U: serde::Serialize>(mut self, args: U) -> Self {
        self.function = self.function.args_json(args);
        self
    }

    /// Similar to `args`, specify an argument that is borsh serializable and can be
    /// accepted by the equivalent contract.
    pub fn args_borsh<U: borsh::BorshSerialize>(mut self, args: U) -> Self {
        self.function = self.function.args_borsh(args);
        self
    }

    /// Specify the amount of tokens to be deposited where `deposit` is the amount of
    /// tokens in yocto near.
    pub fn deposit(mut self, deposit: NearToken) -> Self {
        self.function = self.function.deposit(deposit);
        self
    }

    /// Specify the amount of gas to be used where `gas` is the amount of gas in yocto near.
    pub fn gas(mut self, gas: NearGas) -> Self {
        self.function = self.function.gas(gas);
        self
    }

    /// Use the maximum amount of gas possible to perform this transaction.
    pub fn max_gas(self) -> Self {
        self.gas(MAX_GAS)
    }

    /// Finally, send the transaction to the network. This will consume the `CallTransaction`
    /// object and return us the execution details, along with any errors if the transaction
    /// failed in any process along the way.
    pub async fn transact(self) -> Result<ExecutionFinalResult> {
        let txn = self
            .worker
            .client()
            .call(
                &self.signer,
                &self.contract_id,
                self.function.name.to_string(),
                self.function.args?,
                self.function.gas.as_gas(),
                self.function.deposit,
            )
            .await
            .map(ExecutionFinalResult::from_view)
            .map_err(crate::error::Error::from)?;

        for callback in self.worker.tx_callbacks.iter() {
            callback(txn.total_gas_burnt)?;
        }
        Ok(txn)
    }

    /// Send the transaction to the network to be processed. This will be done asynchronously
    /// without waiting for the transaction to complete. This returns us a [`TransactionStatus`]
    /// for which we can call into [`status`] and/or `.await` to retrieve info about whether
    /// the transaction has been completed or not. Note that `.await` will wait till completion
    /// of the transaction.
    ///
    /// [`status`]: TransactionStatus::status
    pub async fn transact_async(self) -> Result<TransactionStatus> {
        send_batch_tx_async_and_retry(
            self.worker,
            &self.signer,
            &self.contract_id,
            vec![FunctionCallAction {
                args: self.function.args?,
                method_name: self.function.name,
                gas: self.function.gas.as_gas(),
                deposit: self.function.deposit.as_yoctonear(),
            }
            .into()],
        )
        .await
    }

    /// Instead of transacting the transaction, call into the specified view function.
    pub async fn view(self) -> Result<ViewResultDetails> {
        Query::new(
            self.worker.client(),
            ViewFunction {
                account_id: self.contract_id.clone(),
                function: self.function,
            },
        )
        .await
    }
}

/// Similar to a [`Transaction`], but more specific to creating an account.
/// This transaction will create a new account with the specified `receiver_id`
pub struct CreateAccountTransaction<'a, 'b> {
    worker: &'a Worker<dyn Network>,
    signer: InMemorySigner,
    parent_id: AccountId,
    new_account_id: &'b str,

    initial_balance: NearToken,
    secret_key: Option<SecretKey>,
}

impl<'a, 'b> CreateAccountTransaction<'a, 'b> {
    pub(crate) fn new(
        worker: &'a Worker<dyn Network>,
        signer: InMemorySigner,
        parent_id: AccountId,
        new_account_id: &'b str,
    ) -> Self {
        Self {
            worker,
            signer,
            parent_id,
            new_account_id,
            initial_balance: NearToken::from_yoctonear(100000000000000000000000u128),
            secret_key: None,
        }
    }

    /// Specifies the initial balance of the new account. Amount directly taken out
    /// from the caller/signer of this transaction.
    pub fn initial_balance(mut self, initial_balance: NearToken) -> Self {
        self.initial_balance = initial_balance;
        self
    }

    /// Set the secret key of the new account.
    pub fn keys(mut self, secret_key: SecretKey) -> Self {
        self.secret_key = Some(secret_key);
        self
    }

    /// Send the transaction to the network. This will consume the `CreateAccountTransaction`
    /// and give us back the details of the execution and finally the new [`Account`] object.
    pub async fn transact(self) -> Result<Execution<Account>> {
        let sk = self
            .secret_key
            .unwrap_or_else(|| SecretKey::from_seed(KeyType::ED25519, "subaccount.seed"));
        let id: AccountId = format!("{}.{}", self.new_account_id, self.parent_id)
            .try_into()
            .map_err(|e: ParseAccountError| ErrorKind::DataConversion.custom(e))?;

        let outcome = self
            .worker
            .client()
            .create_account(&self.signer, &id, sk.public_key(), self.initial_balance)
            .await?;

        let signer = InMemorySigner::from_secret_key(id, sk);
        let account = Account::new(signer, self.worker.clone());
        let details = ExecutionFinalResult::from_view(outcome);

        for callback in self.worker.tx_callbacks.iter() {
            callback(details.total_gas_burnt)?;
        }

        Ok(Execution {
            result: account,
            details,
        })
    }
}

/// `TransactionStatus` object relating to an [`asynchronous transaction`] on the network.
/// Used to query into the status of the Transaction for whether it has completed or not.
///
/// [`asynchronous transaction`]: https://docs.near.org/api/rpc/transactions#send-transaction-async
#[must_use]
pub struct TransactionStatus {
    worker: Worker<dyn Network>,
    sender_id: AccountId,
    hash: CryptoHash,
}

impl TransactionStatus {
    pub(crate) fn new(
        worker: Worker<dyn Network>,
        id: AccountId,
        hash: near_primitives::hash::CryptoHash,
    ) -> Self {
        Self {
            worker,
            sender_id: id,
            hash: CryptoHash(hash.0),
        }
    }

    /// Checks the status of the transaction. If an `Err` is returned, then the transaction
    /// is in an unexpected state. The error should have further context. Otherwise, if an
    /// `Ok` value with [`Poll::Pending`] is returned, then the transaction has not finished.
    pub async fn status(&self) -> Result<Poll<ExecutionFinalResult>> {
        let result = self
            .worker
            .client()
            .tx_async_status(
                &self.sender_id,
                near_primitives::hash::CryptoHash(self.hash.0),
            )
            .await
            .map(ExecutionFinalResult::from_view);

        match result {
            Ok(result) => Ok(Poll::Ready(result)),
            Err(err) => match err {
                JsonRpcError::ServerError(JsonRpcServerError::HandlerError(
                    RpcTransactionError::UnknownTransaction { .. },
                )) => Ok(Poll::Pending),
                other => Err(RpcErrorCode::BroadcastTxFailure.custom(other)),
            },
        }
    }

    /// Wait until the completion of the transaction by polling [`TransactionStatus::status`].
    pub(crate) async fn wait(self) -> Result<ExecutionFinalResult> {
        loop {
            match self.status().await? {
                Poll::Ready(val) => break Ok(val),
                Poll::Pending => (),
            }

            tokio::time::sleep(std::time::Duration::from_millis(300)).await;
        }
    }

    /// Get the [`AccountId`] of the account that initiated this transaction.
    pub fn sender_id(&self) -> &AccountId {
        &self.sender_id
    }

    /// Reference [`CryptoHash`] to the submitted transaction, pending completion.
    pub fn hash(&self) -> &CryptoHash {
        &self.hash
    }
}

impl fmt::Debug for TransactionStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("TransactionStatus")
            .field("sender_id", &self.sender_id)
            .field("hash", &self.hash)
            .finish()
    }
}

impl IntoFuture for TransactionStatus {
    type Output = Result<ExecutionFinalResult>;
    type IntoFuture = Pin<Box<dyn std::future::Future<Output = Self::Output>>>;

    fn into_future(self) -> Self::IntoFuture {
        Box::pin(async { self.wait().await })
    }
}

'''
'''--- workspaces/src/prelude.rs ---
//! All traits that are essential to the ease of use of workspaces.

pub use crate::network::TopLevelAccountCreator;

'''
'''--- workspaces/src/result.rs ---
//! Result and execution types from results of RPC calls to the network.

use std::fmt;

use base64::{engine::general_purpose, Engine as _};

use near_account_id::AccountId;
use near_gas::NearGas;
use near_primitives::borsh;
use near_primitives::errors::TxExecutionError;
use near_primitives::views::{
    CallResult, ExecutionOutcomeWithIdView, ExecutionStatusView, FinalExecutionOutcomeView,
    FinalExecutionStatus,
};

use crate::error::ErrorKind;
use crate::types::{CryptoHash, Gas, NearToken};

pub type Result<T, E = crate::error::Error> = core::result::Result<T, E>;

/// Execution related info as a result of performing a successful transaction
/// execution on the network. This value can be converted into the returned
/// value of the transaction via [`ExecutionSuccess::json`] or [`ExecutionSuccess::borsh`]
pub type ExecutionSuccess = ExecutionResult<Value>;

/// Execution related info as a result of performing a failed transaction
/// execution on the network. The related error message can be retrieved
/// from this object or can be forwarded.
pub type ExecutionFailure = ExecutionResult<TxExecutionError>;

/// Struct to hold a type we want to return along w/ the execution result view.
/// This view has extra info about the execution, such as gas usage and whether
/// the transaction failed to be processed on the chain.
#[non_exhaustive]
#[must_use = "use `into_result()` to handle potential execution errors"]
pub struct Execution<T> {
    pub result: T,
    pub details: ExecutionFinalResult,
}

impl<T> Execution<T> {
    pub fn unwrap(self) -> T {
        self.into_result().unwrap()
    }

    #[allow(clippy::result_large_err)]
    pub fn into_result(self) -> Result<T, ExecutionFailure> {
        self.details.into_result()?;
        Ok(self.result)
    }

    /// Checks whether the transaction was successful. Returns true if
    /// the transaction has a status of FinalExecutionStatus::Success.
    pub fn is_success(&self) -> bool {
        self.details.is_success()
    }

    /// Checks whether the transaction has failed. Returns true if
    /// the transaction has a status of FinalExecutionStatus::Failure.
    pub fn is_failure(&self) -> bool {
        self.details.is_failure()
    }
}

/// The transaction/receipt details of a transaction execution. This object
/// can be used to retrieve data such as logs and gas burnt per transaction
/// or receipt.
#[derive(PartialEq, Eq, Clone)]
pub(crate) struct ExecutionDetails {
    pub(crate) transaction: ExecutionOutcome,
    pub(crate) receipts: Vec<ExecutionOutcome>,
}

impl ExecutionDetails {
    /// Returns just the transaction outcome.
    pub fn outcome(&self) -> &ExecutionOutcome {
        &self.transaction
    }

    /// Grab all outcomes after the execution of the transaction. This includes outcomes
    /// from the transaction and all the receipts it generated.
    pub fn outcomes(&self) -> Vec<&ExecutionOutcome> {
        let mut outcomes = vec![&self.transaction];
        outcomes.extend(self.receipt_outcomes());
        outcomes
    }

    /// Grab all outcomes after the execution of the transaction. This includes outcomes
    /// only from receipts generated by this transaction.
    pub fn receipt_outcomes(&self) -> &[ExecutionOutcome] {
        &self.receipts
    }

    /// Grab all outcomes that did not succeed the execution of this transaction. This
    /// will also include the failures from receipts as well.
    pub fn failures(&self) -> Vec<&ExecutionOutcome> {
        let mut failures = Vec::new();
        if matches!(self.transaction.status, ExecutionStatusView::Failure(_)) {
            failures.push(&self.transaction);
        }
        failures.extend(self.receipt_failures());
        failures
    }

    /// Just like `failures`, grab only failed receipt outcomes.
    pub fn receipt_failures(&self) -> Vec<&ExecutionOutcome> {
        self.receipts
            .iter()
            .filter(|receipt| matches!(receipt.status, ExecutionStatusView::Failure(_)))
            .collect()
    }

    /// Grab all logs from both the transaction and receipt outcomes.
    pub fn logs(&self) -> Vec<&str> {
        self.outcomes()
            .iter()
            .flat_map(|outcome| &outcome.logs)
            .map(String::as_str)
            .collect()
    }
}

/// The result after evaluating the status of an execution. This can be [`ExecutionSuccess`]
/// for successful executions or a [`ExecutionFailure`] for failed ones.
#[derive(PartialEq, Eq, Clone)]
#[non_exhaustive]
pub struct ExecutionResult<T> {
    /// Total gas burnt by the execution
    pub total_gas_burnt: Gas,

    /// Value returned from an execution. This is a base64 encoded str for a successful
    /// execution or a `TxExecutionError` if a failed one.
    pub(crate) value: T,
    // pub(crate) transaction: ExecutionOutcome,
    // pub(crate) receipts: Vec<ExecutionOutcome>,
    pub(crate) details: ExecutionDetails,
}

impl<T: fmt::Debug> fmt::Debug for ExecutionResult<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ExecutionResult")
            .field("total_gas_burnt", &self.total_gas_burnt)
            .field("transaction", &self.details.transaction)
            .field("receipts", &self.details.receipts)
            .field("value", &self.value)
            .finish()
    }
}

/// Execution related info found after performing a transaction. Can be converted
/// into [`ExecutionSuccess`] or [`ExecutionFailure`] through [`into_result`]
///
/// [`into_result`]: crate::result::ExecutionFinalResult::into_result
#[derive(PartialEq, Eq, Clone)]
#[must_use = "use `into_result()` to handle potential execution errors"]
pub struct ExecutionFinalResult {
    /// Total gas burnt by the execution
    pub total_gas_burnt: Gas,

    pub(crate) status: FinalExecutionStatus,
    pub(crate) details: ExecutionDetails,
}

impl fmt::Debug for ExecutionFinalResult {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ExecutionFinalResult")
            .field("total_gas_burnt", &self.total_gas_burnt)
            .field("transaction", &self.details.transaction)
            .field("receipts", &self.details.receipts)
            .field("status", &self.status)
            .finish()
    }
}

impl ExecutionFinalResult {
    pub(crate) fn from_view(view: FinalExecutionOutcomeView) -> Self {
        let total_gas_burnt = view.transaction_outcome.outcome.gas_burnt
            + view
                .receipts_outcome
                .iter()
                .map(|t| t.outcome.gas_burnt)
                .sum::<u64>();

        let transaction = view.transaction_outcome.into();
        let receipts = view
            .receipts_outcome
            .into_iter()
            .map(ExecutionOutcome::from)
            .collect();

        let total_gas_burnt = NearGas::from_gas(total_gas_burnt);
        Self {
            total_gas_burnt,
            status: view.status,
            details: ExecutionDetails {
                transaction,
                receipts,
            },
        }
    }

    /// Converts this object into a [`Result`] holding either [`ExecutionSuccess`] or [`ExecutionFailure`].
    #[allow(clippy::result_large_err)]
    pub fn into_result(self) -> Result<ExecutionSuccess, ExecutionFailure> {
        match self.status {
            FinalExecutionStatus::SuccessValue(value) => Ok(ExecutionResult {
                total_gas_burnt: self.total_gas_burnt,
                value: Value::from_string(general_purpose::STANDARD.encode(value)),
                details: self.details,
            }),
            FinalExecutionStatus::Failure(tx_error) => Err(ExecutionResult {
                total_gas_burnt: self.total_gas_burnt,
                value: tx_error,
                details: self.details,
            }),
            _ => unreachable!(),
        }
    }

    /// Returns the contained Ok value, consuming the self value.
    ///
    /// Because this function may panic, its use is generally discouraged. Instead, prefer
    /// to call into [`into_result`] then pattern matching and handle the Err case explicitly.
    ///
    /// [`into_result`]: crate::result::ExecutionFinalResult::into_result
    pub fn unwrap(self) -> ExecutionSuccess {
        self.into_result().unwrap()
    }

    /// Deserialize an instance of type `T` from bytes of JSON text sourced from the
    /// execution result of this call. This conversion can fail if the structure of
    /// the internal state does not meet up with [`serde::de::DeserializeOwned`]'s
    /// requirements.
    pub fn json<T: serde::de::DeserializeOwned>(self) -> Result<T> {
        let val = self.into_result()?;
        match val.json() {
            Err(err) => {
                // This catches the case: `EOF while parsing a value at line 1 column 0`
                // for a function that doesn't return anything; this is a more descriptive error.
                if *err.kind() == ErrorKind::DataConversion && val.value.repr.is_empty() {
                    return Err(ErrorKind::DataConversion.custom(
                        "the function call returned an empty value, which cannot be parsed as JSON",
                    ));
                }

                Err(err)
            }
            ok => ok,
        }
    }

    /// Deserialize an instance of type `T` from bytes sourced from the execution
    /// result. This conversion can fail if the structure of the internal state does
    /// not meet up with [`borsh::BorshDeserialize`]'s requirements.
    pub fn borsh<T: borsh::BorshDeserialize>(self) -> Result<T> {
        self.into_result()?.borsh()
    }

    /// Grab the underlying raw bytes returned from calling into a contract's function.
    /// If we want to deserialize these bytes into a rust datatype, use [`ExecutionResult::json`]
    /// or [`ExecutionResult::borsh`] instead.
    pub fn raw_bytes(self) -> Result<Vec<u8>> {
        self.into_result()?.raw_bytes()
    }

    /// Checks whether the transaction was successful. Returns true if
    /// the transaction has a status of [`FinalExecutionStatus::SuccessValue`].
    pub fn is_success(&self) -> bool {
        matches!(self.status, FinalExecutionStatus::SuccessValue(_))
    }

    /// Checks whether the transaction has failed. Returns true if
    /// the transaction has a status of [`FinalExecutionStatus::Failure`].
    pub fn is_failure(&self) -> bool {
        matches!(self.status, FinalExecutionStatus::Failure(_))
    }

    /// Returns just the transaction outcome.
    pub fn outcome(&self) -> &ExecutionOutcome {
        self.details.outcome()
    }

    /// Grab all outcomes after the execution of the transaction. This includes outcomes
    /// from the transaction and all the receipts it generated.
    pub fn outcomes(&self) -> Vec<&ExecutionOutcome> {
        self.details.outcomes()
    }

    /// Grab all outcomes after the execution of the transaction. This includes outcomes
    /// only from receipts generated by this transaction.
    pub fn receipt_outcomes(&self) -> &[ExecutionOutcome] {
        self.details.receipt_outcomes()
    }

    /// Grab all outcomes that did not succeed the execution of this transaction. This
    /// will also include the failures from receipts as well.
    pub fn failures(&self) -> Vec<&ExecutionOutcome> {
        self.details.failures()
    }

    /// Just like `failures`, grab only failed receipt outcomes.
    pub fn receipt_failures(&self) -> Vec<&ExecutionOutcome> {
        self.details.receipt_failures()
    }

    /// Grab all logs from both the transaction and receipt outcomes.
    pub fn logs(&self) -> Vec<&str> {
        self.details.logs()
    }
}

impl ExecutionSuccess {
    /// Deserialize an instance of type `T` from bytes of JSON text sourced from the
    /// execution result of this call. This conversion can fail if the structure of
    /// the internal state does not meet up with [`serde::de::DeserializeOwned`]'s
    /// requirements.
    pub fn json<T: serde::de::DeserializeOwned>(&self) -> Result<T> {
        self.value.json()
    }

    /// Deserialize an instance of type `T` from bytes sourced from the execution
    /// result. This conversion can fail if the structure of the internal state does
    /// not meet up with [`borsh::BorshDeserialize`]'s requirements.
    pub fn borsh<T: borsh::BorshDeserialize>(&self) -> Result<T> {
        self.value.borsh()
    }

    /// Grab the underlying raw bytes returned from calling into a contract's function.
    /// If we want to deserialize these bytes into a rust datatype, use [`ExecutionResult::json`]
    /// or [`ExecutionResult::borsh`] instead.
    pub fn raw_bytes(&self) -> Result<Vec<u8>> {
        self.value.raw_bytes()
    }
}

impl<T> ExecutionResult<T> {
    /// Returns just the transaction outcome.
    pub fn outcome(&self) -> &ExecutionOutcome {
        self.details.outcome()
    }

    /// Grab all outcomes after the execution of the transaction. This includes outcomes
    /// from the transaction and all the receipts it generated.
    pub fn outcomes(&self) -> Vec<&ExecutionOutcome> {
        self.details.outcomes()
    }

    /// Grab all outcomes after the execution of the transaction. This includes outcomes
    /// only from receipts generated by this transaction.
    pub fn receipt_outcomes(&self) -> &[ExecutionOutcome] {
        self.details.receipt_outcomes()
    }

    /// Grab all outcomes that did not succeed the execution of this transaction. This
    /// will also include the failures from receipts as well.
    pub fn failures(&self) -> Vec<&ExecutionOutcome> {
        self.details.failures()
    }

    /// Just like `failures`, grab only failed receipt outcomes.
    pub fn receipt_failures(&self) -> Vec<&ExecutionOutcome> {
        self.details.receipt_failures()
    }

    /// Grab all logs from both the transaction and receipt outcomes.
    pub fn logs(&self) -> Vec<&str> {
        self.details.logs()
    }
}

/// The result from a call into a View function. This contains the contents or
/// the results from the view function call itself. The consumer of this object
/// can choose how to deserialize its contents.
#[derive(PartialEq, Eq, Clone, Debug)]
#[non_exhaustive]
pub struct ViewResultDetails {
    /// Our result from our call into a view function.
    pub result: Vec<u8>,
    /// Logs generated from the view function.
    pub logs: Vec<String>,
}

impl ViewResultDetails {
    /// Deserialize an instance of type `T` from bytes of JSON text sourced from the
    /// execution result of this call. This conversion can fail if the structure of
    /// the internal state does not meet up with [`serde::de::DeserializeOwned`]'s
    /// requirements.
    pub fn json<T: serde::de::DeserializeOwned>(&self) -> Result<T> {
        serde_json::from_slice(&self.result).map_err(|e| ErrorKind::DataConversion.custom(e))
    }

    /// Deserialize an instance of type `T` from bytes sourced from this view call's
    /// result. This conversion can fail if the structure of the internal state does
    /// not meet up with [`borsh::BorshDeserialize`]'s requirements.
    pub fn borsh<T: borsh::BorshDeserialize>(&self) -> Result<T> {
        borsh::BorshDeserialize::try_from_slice(&self.result)
            .map_err(|e| ErrorKind::DataConversion.custom(e))
    }
}

impl From<CallResult> for ViewResultDetails {
    fn from(result: CallResult) -> Self {
        Self {
            result: result.result,
            logs: result.logs,
        }
    }
}

/// The execution outcome of a transaction. This type contains all data relevant to
/// calling into a function, and getting the results back.
#[derive(Clone, Debug, PartialEq, Eq)]
#[non_exhaustive]
pub struct ExecutionOutcome {
    /// The hash of the transaction that generated this outcome.
    pub transaction_hash: CryptoHash,
    /// The hash of the block that generated this outcome.
    pub block_hash: CryptoHash,
    /// Logs from this transaction or receipt.
    pub logs: Vec<String>,
    /// Receipt IDs generated by this transaction or receipt.
    pub receipt_ids: Vec<CryptoHash>,
    /// The amount of the gas burnt by the given transaction or receipt.
    pub gas_burnt: Gas,
    /// The amount of tokens burnt corresponding to the burnt gas amount.
    /// This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
    /// the prepaid gas price might be lower than the actual gas price and it creates a deficit.
    pub tokens_burnt: NearToken,
    /// The id of the account on which the execution happens. For transaction this is signer_id,
    /// for receipt this is receiver_id.
    pub executor_id: AccountId,
    /// Execution status. Contains the result in case of successful execution.
    pub(crate) status: ExecutionStatusView,
}

impl ExecutionOutcome {
    /// Checks whether this execution outcome was a success. Returns true if a success value or
    /// receipt id is present.
    pub fn is_success(&self) -> bool {
        matches!(
            self.status,
            ExecutionStatusView::SuccessValue(_) | ExecutionStatusView::SuccessReceiptId(_)
        )
    }

    /// Checks whether this execution outcome was a failure. Returns true if it failed with
    /// an error or the execution state was unknown or pending.
    pub fn is_failure(&self) -> bool {
        matches!(
            self.status,
            ExecutionStatusView::Failure(_) | ExecutionStatusView::Unknown
        )
    }

    /// Converts this [`ExecutionOutcome`] into a Result type to match against whether the
    /// particular outcome has failed or not.
    pub fn into_result(self) -> Result<ValueOrReceiptId> {
        match self.status {
            ExecutionStatusView::SuccessValue(value) => Ok(ValueOrReceiptId::Value(
                Value::from_string(general_purpose::STANDARD.encode(value)),
            )),
            ExecutionStatusView::SuccessReceiptId(hash) => {
                Ok(ValueOrReceiptId::ReceiptId(CryptoHash(hash.0)))
            }
            ExecutionStatusView::Failure(err) => Err(ErrorKind::Execution.custom(err)),
            ExecutionStatusView::Unknown => {
                Err(ErrorKind::Execution.message("Execution pending or unknown"))
            }
        }
    }
}

/// Value or ReceiptId from a successful execution.
#[derive(Debug)]
pub enum ValueOrReceiptId {
    /// The final action succeeded and returned some value or an empty vec encoded in base64.
    Value(Value),
    /// The final action of the receipt returned a promise or the signed transaction was converted
    /// to a receipt. Contains the receipt_id of the generated receipt.
    ReceiptId(CryptoHash),
}

/// Value type returned from an [`ExecutionOutcome`] or receipt result. This value
/// can be converted into the underlying Rust datatype, or directly grab the raw
/// bytes associated to the value.
#[derive(Debug, Clone)]
pub struct Value {
    repr: String,
}

impl Value {
    fn from_string(value: String) -> Self {
        Self { repr: value }
    }

    /// Deserialize an instance of type `T` from bytes of JSON text sourced from the
    /// execution result of this call. This conversion can fail if the structure of
    /// the internal state does not meet up with [`serde::de::DeserializeOwned`]'s
    /// requirements.
    pub fn json<T: serde::de::DeserializeOwned>(&self) -> Result<T> {
        let buf = self.raw_bytes()?;
        serde_json::from_slice(&buf).map_err(|e| ErrorKind::DataConversion.custom(e))
    }

    /// Deserialize an instance of type `T` from bytes sourced from the execution
    /// result. This conversion can fail if the structure of the internal state does
    /// not meet up with [`borsh::BorshDeserialize`]'s requirements.
    pub fn borsh<T: borsh::BorshDeserialize>(&self) -> Result<T> {
        let buf = self.raw_bytes()?;
        borsh::BorshDeserialize::try_from_slice(&buf)
            .map_err(|e| ErrorKind::DataConversion.custom(e))
    }

    /// Grab the underlying raw bytes returned from calling into a contract's function.
    /// If we want to deserialize these bytes into a rust datatype, use [`json`]
    /// or [`borsh`] instead.
    ///
    /// [`json`]: Value::json
    /// [`borsh`]: Value::borsh
    pub fn raw_bytes(&self) -> Result<Vec<u8>> {
        general_purpose::STANDARD
            .decode(&self.repr)
            .map_err(|e| ErrorKind::DataConversion.custom(e))
    }
}

impl From<ExecutionOutcomeWithIdView> for ExecutionOutcome {
    fn from(view: ExecutionOutcomeWithIdView) -> Self {
        Self {
            transaction_hash: CryptoHash(view.id.0),
            block_hash: CryptoHash(view.block_hash.0),
            logs: view.outcome.logs,
            receipt_ids: view
                .outcome
                .receipt_ids
                .into_iter()
                .map(|c| CryptoHash(c.0))
                .collect(),
            gas_burnt: NearGas::from_gas(view.outcome.gas_burnt),
            tokens_burnt: NearToken::from_yoctonear(view.outcome.tokens_burnt),
            executor_id: view.outcome.executor_id,
            status: view.outcome.status,
        }
    }
}

'''
'''--- workspaces/src/rpc/client.rs ---
use std::collections::HashMap;
use std::fmt::Debug;
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::Duration;

use crate::types::NearToken;
use near_gas::NearGas;
use tokio::sync::RwLock;
use tokio_retry::strategy::{jitter, ExponentialBackoff};
use tokio_retry::Retry;

use near_jsonrpc_client::errors::{JsonRpcError, JsonRpcServerError};
use near_jsonrpc_client::methods::health::RpcStatusError;
use near_jsonrpc_client::methods::tx::RpcTransactionError;
use near_jsonrpc_client::{methods, JsonRpcClient, MethodCallResult};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::account::{AccessKey, AccessKeyPermission};
use near_primitives::errors::InvalidTxError;
use near_primitives::hash::CryptoHash;
use near_primitives::transaction::{
    Action, AddKeyAction, CreateAccountAction, DeleteAccountAction, DeployContractAction,
    FunctionCallAction, SignedTransaction, TransferAction,
};
use near_primitives::types::{BlockReference, Finality, Gas};
use near_primitives::views::{
    AccessKeyView, BlockView, FinalExecutionOutcomeView, QueryRequest, StatusResponse,
};

#[cfg(feature = "experimental")]
use {
    near_chain_configs::{GenesisConfig, ProtocolConfigView},
    near_jsonrpc_primitives::types::{
        changes::RpcStateChangesInBlockByTypeResponse, changes::RpcStateChangesInBlockResponse,
        receipts::ReceiptReference, transactions::TransactionInfo,
    },
    near_primitives::{
        types::MaybeBlockId,
        views::{
            validator_stake_view::ValidatorStakeView, FinalExecutionOutcomeWithReceiptView,
            ReceiptView, StateChangesRequestView,
        },
    },
};

use crate::error::{Error, ErrorKind, RpcErrorCode};
use crate::operations::TransactionStatus;
use crate::result::Result;
use crate::types::{AccountId, InMemorySigner, Nonce, PublicKey};
use crate::{Network, Worker};

pub(crate) const DEFAULT_CALL_FN_GAS: NearGas = NearGas::from_tgas(10);
pub(crate) const DEFAULT_CALL_DEPOSIT: NearToken = NearToken::from_near(0);

/// A client that wraps around [`JsonRpcClient`], and provides more capabilities such
/// as retry w/ exponential backoff and utility functions for sending transactions.
pub struct Client {
    rpc_addr: String,
    rpc_client: JsonRpcClient,
    /// AccessKey nonces to reference when sending transactions.
    pub(crate) access_key_nonces: RwLock<HashMap<(AccountId, near_crypto::PublicKey), AtomicU64>>,
}

impl Client {
    pub(crate) fn new(rpc_addr: &str, api_key: Option<String>) -> Result<Self> {
        let connector = JsonRpcClient::new_client();
        let mut rpc_client = connector.connect(rpc_addr);
        if let Some(api_key) = api_key {
            let api_key = near_jsonrpc_client::auth::ApiKey::new(api_key)
                .map_err(|e| ErrorKind::DataConversion.custom(e))?;
            rpc_client = rpc_client.header(api_key);
        }

        Ok(Self {
            rpc_client,
            rpc_addr: rpc_addr.into(),
            access_key_nonces: RwLock::new(HashMap::new()),
        })
    }

    pub(crate) async fn query_broadcast_tx(
        &self,
        method: &methods::broadcast_tx_commit::RpcBroadcastTxCommitRequest,
    ) -> MethodCallResult<FinalExecutionOutcomeView, RpcTransactionError> {
        retry(|| async {
            let result = self.rpc_client.call(method).await;
            match &result {
                Ok(response) => {
                    // When user sets logging level to INFO we only print one-liners with submitted
                    // actions and the resulting status. If the level is DEBUG or lower, we print
                    // the entire request and response structures.
                    if tracing::level_enabled!(tracing::Level::DEBUG) {
                        tracing::debug!(
                            target: "workspaces",
                            "Calling RPC method {:?} succeeded with {:?}",
                            method,
                            response
                        );
                    } else {
                        tracing::info!(
                            target: "workspaces",
                            "Submitting transaction with actions {:?} succeeded with status {:?}",
                            method.signed_transaction.transaction.actions,
                            response.status
                        );
                    }
                }
                Err(error) => {
                    tracing::error!(
                        target: "workspaces",
                        "Calling RPC method {:?} resulted in error {:?}",
                        method,
                        error
                    );
                }
            };
            result
        })
        .await
    }

    pub(crate) async fn query_nolog<M>(&self, method: M) -> MethodCallResult<M::Response, M::Error>
    where
        M: methods::RpcMethod + Send + Sync,
    {
        retry(|| async { self.rpc_client.call(&method).await }).await
    }

    pub(crate) async fn query<M>(&self, method: M) -> MethodCallResult<M::Response, M::Error>
    where
        M: methods::RpcMethod + Debug + Send + Sync,
        M::Response: Debug + Send,
        M::Error: Debug + Send,
    {
        retry(|| async {
            let result = self.rpc_client.call(&method).await;
            tracing::debug!(
                target: "workspaces",
                "Querying RPC with {:?} resulted in {:?}",
                method,
                result
            );
            result
        })
        .await
    }

    async fn send_tx_and_retry(
        &self,
        signer: &InMemorySigner,
        receiver_id: &AccountId,
        action: Action,
    ) -> Result<FinalExecutionOutcomeView> {
        send_batch_tx_and_retry(self, signer, receiver_id, vec![action]).await
    }

    pub(crate) async fn call(
        &self,
        signer: &InMemorySigner,
        contract_id: &AccountId,
        method_name: String,
        args: Vec<u8>,
        gas: Gas,
        deposit: NearToken,
    ) -> Result<FinalExecutionOutcomeView> {
        self.send_tx_and_retry(
            signer,
            contract_id,
            FunctionCallAction {
                args,
                method_name,
                gas,
                deposit: deposit.as_yoctonear(),
            }
            .into(),
        )
        .await
    }

    pub(crate) async fn view_block(&self, block_ref: Option<BlockReference>) -> Result<BlockView> {
        let block_reference = block_ref.unwrap_or_else(|| Finality::None.into());
        let block_view = self
            .query(&methods::block::RpcBlockRequest { block_reference })
            .await
            .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;

        Ok(block_view)
    }

    pub(crate) async fn deploy(
        &self,
        signer: &InMemorySigner,
        contract_id: &AccountId,
        wasm: Vec<u8>,
    ) -> Result<FinalExecutionOutcomeView> {
        self.send_tx_and_retry(
            signer,
            contract_id,
            DeployContractAction { code: wasm }.into(),
        )
        .await
    }

    pub(crate) async fn transfer_near(
        &self,
        signer: &InMemorySigner,
        receiver_id: &AccountId,
        amount_yocto: NearToken,
    ) -> Result<FinalExecutionOutcomeView> {
        self.send_tx_and_retry(
            signer,
            receiver_id,
            TransferAction {
                deposit: amount_yocto.as_yoctonear(),
            }
            .into(),
        )
        .await
    }

    pub(crate) async fn create_account(
        &self,
        signer: &InMemorySigner,
        new_account_id: &AccountId,
        new_account_pk: PublicKey,
        amount: NearToken,
    ) -> Result<FinalExecutionOutcomeView> {
        send_batch_tx_and_retry(
            self,
            signer,
            new_account_id,
            vec![
                CreateAccountAction {}.into(),
                AddKeyAction {
                    public_key: new_account_pk.into(),
                    access_key: AccessKey {
                        nonce: 0,
                        permission: AccessKeyPermission::FullAccess,
                    },
                }
                .into(),
                TransferAction {
                    deposit: amount.as_yoctonear(),
                }
                .into(),
            ],
        )
        .await
    }

    pub(crate) async fn create_account_and_deploy(
        &self,
        signer: &InMemorySigner,
        new_account_id: &AccountId,
        new_account_pk: PublicKey,
        amount: NearToken,
        code: Vec<u8>,
    ) -> Result<FinalExecutionOutcomeView> {
        send_batch_tx_and_retry(
            self,
            signer,
            new_account_id,
            vec![
                CreateAccountAction {}.into(),
                AddKeyAction {
                    public_key: new_account_pk.into(),
                    access_key: AccessKey {
                        nonce: 0,
                        permission: AccessKeyPermission::FullAccess,
                    },
                }
                .into(),
                TransferAction {
                    deposit: amount.as_yoctonear(),
                }
                .into(),
                DeployContractAction { code }.into(),
            ],
        )
        .await
    }

    pub(crate) async fn delete_account(
        &self,
        signer: &InMemorySigner,
        account_id: &AccountId,
        beneficiary_id: &AccountId,
    ) -> Result<FinalExecutionOutcomeView> {
        let beneficiary_id = beneficiary_id.to_owned();
        self.send_tx_and_retry(
            signer,
            account_id,
            DeleteAccountAction { beneficiary_id }.into(),
        )
        .await
    }

    pub(crate) async fn status(&self) -> Result<StatusResponse, JsonRpcError<RpcStatusError>> {
        let result = self
            .rpc_client
            .call(methods::status::RpcStatusRequest)
            .await;

        tracing::debug!(
            target: "workspaces",
            "Querying RPC with RpcStatusRequest resulted in {:?}",
            result,
        );
        result
    }

    pub(crate) async fn tx_async_status(
        &self,
        sender_id: &AccountId,
        tx_hash: CryptoHash,
    ) -> Result<FinalExecutionOutcomeView, JsonRpcError<RpcTransactionError>> {
        self.query(methods::tx::RpcTransactionStatusRequest {
            transaction_info: methods::tx::TransactionInfo::TransactionId {
                sender_account_id: sender_id.clone(),
                tx_hash,
            },
        })
        .await
    }

    pub(crate) async fn wait_for_rpc(&self) -> Result<()> {
        let timeout_secs = match std::env::var("NEAR_RPC_TIMEOUT_SECS") {
            // hard fail on not being able to parse the env var, since this isn't something
            // the user should handle with the library.
            Ok(secs) => secs.parse::<usize>().map_err(|err| {
                Error::full(
                    ErrorKind::DataConversion,
                    format!("Failed to parse provided NEAR_RPC_TIMEOUT_SECS={}", secs),
                    err,
                )
            })?,
            Err(_) => 10,
        };

        let retry_strategy =
            std::iter::repeat_with(|| Duration::from_millis(500)).take(2 * timeout_secs);
        Retry::spawn(retry_strategy, || async { self.status().await })
            .await
            .map_err(|e| {
                Error::full(
                    RpcErrorCode::ConnectionFailure.into(),
                    format!(
                        "Failed to connect to RPC service {} within {} seconds",
                        self.rpc_addr, timeout_secs
                    ),
                    e,
                )
            })?;
        Ok(())
    }
}

#[cfg(feature = "experimental")]
impl Client {
    pub(crate) async fn changes_in_block(
        &self,
        block_reference: BlockReference,
    ) -> Result<RpcStateChangesInBlockByTypeResponse> {
        let resp = self
            .rpc_client
            .call(
                methods::EXPERIMENTAL_changes_in_block::RpcStateChangesInBlockRequest {
                    block_reference,
                },
            )
            .await
            .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;

        Ok(resp)
    }

    pub(crate) async fn changes(
        &self,
        block_reference: BlockReference,
        state_changes_request: StateChangesRequestView,
    ) -> Result<RpcStateChangesInBlockResponse> {
        let resp = self
            .rpc_client
            .call(
                methods::EXPERIMENTAL_changes::RpcStateChangesInBlockByTypeRequest {
                    block_reference,
                    state_changes_request,
                },
            )
            .await
            .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;
        Ok(resp)
    }

    pub(crate) async fn genesis_config(&self) -> Result<GenesisConfig> {
        let resp = self
            .rpc_client
            .call(methods::EXPERIMENTAL_genesis_config::RpcGenesisConfigRequest)
            .await
            .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;
        Ok(resp)
    }

    pub(crate) async fn protocol_config(
        &self,
        block_reference: BlockReference,
    ) -> Result<ProtocolConfigView> {
        let resp = self
            .rpc_client
            .call(
                methods::EXPERIMENTAL_protocol_config::RpcProtocolConfigRequest { block_reference },
            )
            .await
            .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;
        Ok(resp)
    }

    pub(crate) async fn receipt(&self, receipt_reference: ReceiptReference) -> Result<ReceiptView> {
        let resp = self
            .rpc_client
            .call(methods::EXPERIMENTAL_receipt::RpcReceiptRequest { receipt_reference })
            .await
            .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;
        Ok(resp)
    }

    pub(crate) async fn tx_status(
        &self,
        transaction_info: TransactionInfo,
    ) -> Result<FinalExecutionOutcomeWithReceiptView> {
        let resp = self
            .rpc_client
            .call(methods::EXPERIMENTAL_tx_status::RpcTransactionStatusRequest { transaction_info })
            .await
            .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;
        Ok(resp)
    }

    pub(crate) async fn validators_ordered(
        &self,
        block_id: MaybeBlockId,
    ) -> Result<Vec<ValidatorStakeView>> {
        let resp = self
            .rpc_client
            .call(
                methods::EXPERIMENTAL_validators_ordered::RpcValidatorsOrderedRequest { block_id },
            )
            .await
            .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;
        Ok(resp)
    }
}

pub(crate) async fn access_key(
    client: &Client,
    account_id: AccountId,
    public_key: near_crypto::PublicKey,
) -> Result<(AccessKeyView, CryptoHash)> {
    let query_resp = client
        .query(&methods::query::RpcQueryRequest {
            block_reference: Finality::None.into(),
            request: QueryRequest::ViewAccessKey {
                account_id,
                public_key,
            },
        })
        .await
        .map_err(|e| {
            Error::full(
                RpcErrorCode::QueryFailure.into(),
                "Failed to query access key",
                e,
            )
        })?;

    match query_resp.kind {
        QueryResponseKind::AccessKey(access_key) => Ok((access_key, query_resp.block_hash)),
        _ => Err(RpcErrorCode::QueryReturnedInvalidData.message("while querying access key")),
    }
}

/// Fetches the transaction nonce and block hash associated to the access key. Internally
/// caches the nonce as to not need to query for it every time, and ending up having to run
/// into contention with others.
async fn fetch_tx_nonce(
    client: &Client,
    cache_key: &(AccountId, near_crypto::PublicKey),
) -> Result<(CryptoHash, Nonce)> {
    let nonces = client.access_key_nonces.read().await;
    if let Some(nonce) = nonces.get(cache_key) {
        let nonce = nonce.fetch_add(1, Ordering::SeqCst);
        drop(nonces);

        // Fetch latest block_hash since the previous one is now invalid for new transactions:
        let block = client.view_block(Some(Finality::Final.into())).await?;
        let block_hash = block.header.hash;
        Ok((block_hash, nonce + 1))
    } else {
        drop(nonces);

        let (account_id, public_key) = cache_key;
        let (access_key, block_hash) =
            access_key(client, account_id.clone(), public_key.clone()).await?;

        // case where multiple writers end up at the same lock acquisition point and tries
        // to overwrite the cached value that a previous writer already wrote.
        let nonce = client
            .access_key_nonces
            .write()
            .await
            .entry(cache_key.clone())
            .or_insert_with(|| AtomicU64::new(access_key.nonce + 1))
            .fetch_max(access_key.nonce + 1, Ordering::SeqCst)
            .max(access_key.nonce + 1);

        Ok((block_hash, nonce))
    }
}

pub(crate) async fn retry<R, E, T, F>(task: F) -> T::Output
where
    F: FnMut() -> T + Send,
    T: core::future::Future<Output = core::result::Result<R, E>> + Send,
{
    // Exponential backoff starting w/ 5ms for maximum retry of 4 times with the following delays:
    //   5, 25, 125, 625 ms
    let retry_strategy = ExponentialBackoff::from_millis(5).map(jitter).take(4);

    Retry::spawn(retry_strategy, task).await
}

pub(crate) async fn send_tx(
    client: &Client,
    cache_key: &(AccountId, near_crypto::PublicKey),
    tx: SignedTransaction,
) -> Result<FinalExecutionOutcomeView> {
    let result = client
        .query_broadcast_tx(&methods::broadcast_tx_commit::RpcBroadcastTxCommitRequest {
            signed_transaction: tx,
        })
        .await;

    // InvalidNonce, cached nonce is potentially very far behind, so invalidate it.
    if let Err(JsonRpcError::ServerError(JsonRpcServerError::HandlerError(
        RpcTransactionError::InvalidTransaction {
            context: InvalidTxError::InvalidNonce { .. },
            ..
        },
    ))) = &result
    {
        let mut nonces = client.access_key_nonces.write().await;
        nonces.remove(cache_key);
    }

    result.map_err(|e| RpcErrorCode::BroadcastTxFailure.custom(e))
}

pub(crate) async fn send_batch_tx_and_retry(
    client: &Client,
    signer: &InMemorySigner,
    receiver_id: &AccountId,
    actions: Vec<Action>,
) -> Result<FinalExecutionOutcomeView> {
    let signer = signer.inner();
    let cache_key = (signer.account_id.clone(), signer.secret_key.public_key());
    retry(|| async {
        let (block_hash, nonce) = fetch_tx_nonce(client, &cache_key).await?;
        send_tx(
            client,
            &cache_key,
            SignedTransaction::from_actions(
                nonce,
                signer.account_id.clone(),
                receiver_id.clone(),
                &signer as &dyn near_crypto::Signer,
                actions.clone(),
                block_hash,
            ),
        )
        .await
    })
    .await
}

pub(crate) async fn send_batch_tx_async_and_retry(
    worker: Worker<dyn Network>,
    signer: &InMemorySigner,
    receiver_id: &AccountId,
    actions: Vec<Action>,
) -> Result<TransactionStatus> {
    let signer = &signer.inner();
    let cache_key = (signer.account_id.clone(), signer.secret_key.public_key());
    retry(|| async {
        let (block_hash, nonce) = fetch_tx_nonce(worker.client(), &cache_key).await?;
        let hash = worker
            .client()
            .query(&methods::broadcast_tx_async::RpcBroadcastTxAsyncRequest {
                signed_transaction: SignedTransaction::from_actions(
                    nonce,
                    signer.account_id.clone(),
                    receiver_id.clone(),
                    signer as &dyn near_crypto::Signer,
                    actions.clone(),
                    block_hash,
                ),
            })
            .await
            .map_err(|e| RpcErrorCode::BroadcastTxFailure.custom(e))?;

        Ok(TransactionStatus::new(
            worker.clone(),
            signer.account_id.clone(),
            hash,
        ))
    })
    .await
}

'''
'''--- workspaces/src/rpc/mod.rs ---
pub(crate) mod client;
pub(crate) mod tool;

pub mod patch;
pub mod query;

pub type BoxFuture<'a, T> = std::pin::Pin<Box<dyn std::future::Future<Output = T> + Send + 'a>>;

'''
'''--- workspaces/src/rpc/patch.rs ---
use near_jsonrpc_client::methods::sandbox_patch_state::RpcSandboxPatchStateRequest;
use near_primitives::state_record::StateRecord;
use near_primitives::types::{BlockId, BlockReference};
use near_token::NearToken;

use crate::error::SandboxErrorCode;
use crate::network::{Sandbox, DEV_ACCOUNT_SEED};
use crate::types::account::AccountDetails;
use crate::types::{BlockHeight, KeyType, PublicKey, SecretKey};
use crate::{AccessKey, AccountDetailsPatch, Result};
use crate::{AccountId, Contract, CryptoHash, InMemorySigner, Network, Worker};

/// A [`Transaction`]-like object that allows us to specify details about importing
/// a contract from a different network into our sandbox local network. This creates
/// a new [`Transaction`] to be committed to the sandbox network once `transact()`
/// has been called. This does not commit any new transactions from the network
/// this object is importing from.
///
/// [`Transaction`]: crate::operations::Transaction
pub struct ImportContractTransaction<'a> {
    account_id: &'a AccountId,
    from_network: Worker<dyn Network>,
    into_network: Worker<Sandbox>,

    /// Whether to grab data down from the other contract or not
    import_data: bool,

    /// Initial balance of the account. If None, uses what is specified
    /// from the other account instead.
    initial_balance: Option<NearToken>,

    block_ref: Option<BlockReference>,

    /// AccountId if specified, will be the destination account to clone the contract to.
    into_account_id: Option<AccountId>,
}

impl<'a> ImportContractTransaction<'a> {
    pub(crate) fn new(
        account_id: &'a AccountId,
        from_network: Worker<dyn Network>,
        into_network: Worker<Sandbox>,
    ) -> Self {
        ImportContractTransaction {
            account_id,
            from_network,
            into_network,
            import_data: false,
            initial_balance: None,
            block_ref: None,
            into_account_id: None,
        }
    }

    /// Specify at which block height to import the contract from. This is usable with
    /// any network this object is importing from, but be aware that only archival
    /// networks will have the full history while networks like mainnet or testnet
    /// only has the history from 5 or less epochs ago.
    pub fn block_height(mut self, block_height: BlockHeight) -> Self {
        self.block_ref = Some(BlockId::Height(block_height).into());
        self
    }

    /// Specify at which block hash to import the contract from. This is usable with
    /// any network this object is importing from, but be aware that only archival
    /// networks will have the full history while networks like mainnet or testnet
    /// only has the history from 5 or less epochs ago.
    pub fn block_hash(mut self, block_hash: CryptoHash) -> Self {
        self.block_ref =
            Some(BlockId::Hash(near_primitives::hash::CryptoHash(block_hash.0)).into());
        self
    }

    /// Along with importing the contract code, this will import the state from the
    /// contract itself. This is useful for testing current network state or state
    /// at a specific block. Note that there is a limit of 50kb of state data that
    /// can be pulled down using the usual RPC service. To get beyond this, our own
    /// RPC node has to be spun up and used instead.
    pub fn with_data(mut self) -> Self {
        self.import_data = true;
        self
    }

    /// Specifies the balance of the contract. This will override the balance currently
    /// on the network this transaction is importing from.
    pub fn initial_balance(mut self, initial_balance: NearToken) -> Self {
        self.initial_balance = Some(initial_balance);
        self
    }

    /// Sets the destination [`AccountId`] where the import will be transacted to.
    /// This function is provided so users can import to a different [`AccountId`]
    /// than the one initially provided to import from.
    pub fn dest_account_id(mut self, account_id: &AccountId) -> Self {
        self.into_account_id = Some(account_id.clone());
        self
    }

    /// Process the transaction, and return the result of the execution.
    pub async fn transact(self) -> Result<Contract> {
        let from_account_id = self.account_id;
        let into_account_id = self.into_account_id.as_ref().unwrap_or(from_account_id);

        let sk = SecretKey::from_seed(KeyType::ED25519, DEV_ACCOUNT_SEED);
        let pk = sk.public_key();
        let signer = InMemorySigner::from_secret_key(into_account_id.clone(), sk);
        let block_ref = self.block_ref.unwrap_or_else(BlockReference::latest);

        let mut account_view = self
            .from_network
            .view_account(from_account_id)
            .block_reference(block_ref.clone())
            .await?;

        let code_hash = account_view.code_hash;
        if let Some(initial_balance) = self.initial_balance {
            account_view.balance = initial_balance;
        }

        let mut patch = PatchTransaction::new(&self.into_network, into_account_id.clone())
            .account(account_view.into())
            .access_key(pk, AccessKey::full_access());

        if code_hash != CryptoHash::default() {
            let code = self
                .from_network
                .view_code(from_account_id)
                .block_reference(block_ref.clone())
                .await?;
            patch = patch.code(&code);
        }

        if self.import_data {
            let states = self
                .from_network
                .view_state(from_account_id)
                .block_reference(block_ref)
                .await?;

            patch = patch.states(
                states
                    .iter()
                    .map(|(key, value)| (key.as_slice(), value.as_slice())),
            );
        }

        patch.transact().await?;
        Ok(Contract::new(signer, self.into_network.coerce()))
    }
}

/// Internal enum for determining whether to update the account on chain
/// or to patch an entire account.
enum AccountUpdate {
    Update(AccountDetailsPatch),
    FromCurrent(Box<dyn Fn(AccountDetails) -> AccountDetailsPatch + Send>),
}

pub struct PatchTransaction {
    account_id: AccountId,
    records: Vec<StateRecord>,
    worker: Worker<Sandbox>,
    account_updates: Vec<AccountUpdate>,
    code_hash_update: Option<CryptoHash>,
}

impl PatchTransaction {
    pub(crate) fn new(worker: &Worker<Sandbox>, account_id: AccountId) -> Self {
        Self {
            account_id,
            records: vec![],
            worker: worker.clone(),
            account_updates: vec![],
            code_hash_update: None,
        }
    }

    /// Patch and overwrite the info contained inside an [`crate::Account`] in sandbox.
    pub fn account(mut self, account: AccountDetailsPatch) -> Self {
        self.account_updates.push(AccountUpdate::Update(account));
        self
    }

    /// Patch and overwrite the info contained inside an [`crate::Account`] in sandbox. This
    /// will allow us to fetch the current details on the chain and allow us to update
    /// the account details w.r.t to them.
    pub fn account_from_current<F>(mut self, f: F) -> Self
    where
        F: Fn(AccountDetails) -> AccountDetailsPatch + Send + 'static,
    {
        self.account_updates
            .push(AccountUpdate::FromCurrent(Box::new(f)));
        self
    }

    /// Patch the access keys of an account. This will add or overwrite the current access key
    /// contained in sandbox with the access key we specify.
    pub fn access_key(mut self, pk: PublicKey, ak: AccessKey) -> Self {
        self.records.push(StateRecord::AccessKey {
            account_id: self.account_id.clone(),
            public_key: pk.into(),
            access_key: ak.into(),
        });
        self
    }

    /// Patch the access keys of an account. This will add or overwrite the current access keys
    /// contained in sandbox with a list of access keys we specify.
    ///
    /// Similar to [`PatchTransaction::access_key`], but allows us to specify multiple access keys
    pub fn access_keys<I>(mut self, access_keys: I) -> Self
    where
        I: IntoIterator<Item = (PublicKey, AccessKey)>,
    {
        // Move account_id out of self struct so we can appease borrow checker.
        // We'll put it back in after we're done.
        let account_id = self.account_id;

        self.records.extend(
            access_keys
                .into_iter()
                .map(|(pk, ak)| StateRecord::AccessKey {
                    account_id: account_id.clone(),
                    public_key: pk.into(),
                    access_key: ak.into(),
                }),
        );

        self.account_id = account_id;
        self
    }

    /// Sets the code for this account. This will overwrite the current code contained in the account.
    /// Note that if a patch for [`Self::account`] or [`Self::account_from_current`] is specified, the code hash
    /// in those will be overwritten with the code hash of the code we specify here.
    pub fn code(mut self, wasm_bytes: &[u8]) -> Self {
        self.code_hash_update = Some(CryptoHash::hash_bytes(wasm_bytes));
        self.records.push(StateRecord::Contract {
            account_id: self.account_id.clone(),
            code: wasm_bytes.to_vec(),
        });
        self
    }

    /// Patch state into the sandbox network, given a prefix key and value. This will allow us
    /// to set contract state that we have acquired in some manner, where we are able to test
    /// random cases that are hard to come up naturally as state evolves.
    pub fn state(mut self, key: &[u8], value: &[u8]) -> Self {
        self.records.push(StateRecord::Data {
            account_id: self.account_id.clone(),
            data_key: key.to_vec().into(),
            value: value.to_vec().into(),
        });
        self
    }

    /// Patch a series of states into the sandbox network. Similar to [`PatchTransaction::state`],
    /// but allows us to specify multiple state patches at once.
    pub fn states<'b, 'c, I>(mut self, states: I) -> Self
    where
        I: IntoIterator<Item = (&'b [u8], &'c [u8])>,
    {
        // Move account_id out of self struct so we can appease borrow checker.
        // We'll put it back in after we're done.
        let account_id = self.account_id;

        self.records
            .extend(states.into_iter().map(|(key, value)| StateRecord::Data {
                account_id: account_id.clone(),
                data_key: key.to_vec().into(),
                value: value.to_vec().into(),
            }));

        self.account_id = account_id;
        self
    }

    /// Perform the state patch transaction into the sandbox network.
    pub async fn transact(mut self) -> Result<()> {
        // NOTE: updating the account is done here because we need to fetch the current
        // account details from the chain. This is an async operation so it is deferred
        // till the transact function.
        let account_patch = if !self.account_updates.is_empty() {
            let mut account = AccountDetailsPatch::default();
            for update in self.account_updates {
                // reduce the updates into a single account details patch
                account.reduce(match update {
                    AccountUpdate::Update(account) => account,
                    AccountUpdate::FromCurrent(f) => {
                        let account = self.worker.view_account(&self.account_id).await?;
                        f(account)
                    }
                });
            }

            // Update the code hash if the user supplied a code patch.
            if let Some(code_hash) = self.code_hash_update.take() {
                account.code_hash = Some(code_hash);
            }

            Some(account)
        } else if let Some(code_hash) = self.code_hash_update {
            // No account patch, but we have a code patch. We need to fetch the current account
            // to reflect the code hash change.
            let mut account = self.worker.view_account(&self.account_id).await?;
            account.code_hash = code_hash;
            Some(account.into())
        } else {
            None
        };

        // Account patch should be the first entry in the records, since the account might not
        // exist yet and the consequent patches might lookup the account on the chain.
        let records = if let Some(account) = account_patch {
            let account: AccountDetails = account.into();
            let mut records = vec![StateRecord::Account {
                account_id: self.account_id.clone(),
                account: account.into_near_account(),
            }];
            records.extend(self.records);
            records
        } else {
            self.records
        };

        self.worker
            .client()
            .query(&RpcSandboxPatchStateRequest {
                records: records.clone(),
            })
            .await
            .map_err(|err| SandboxErrorCode::PatchStateFailure.custom(err))?;

        self.worker
            .client()
            .query(&RpcSandboxPatchStateRequest { records })
            .await
            .map_err(|err| SandboxErrorCode::PatchStateFailure.custom(err))?;
        Ok(())
    }
}

'''
'''--- workspaces/src/rpc/query.rs ---
//! This module defines a bunch of internal types used solely for querying into RPC
//! methods to retrieve info about what's on the chain. Note that the types defined
//! are exposed as-is for users to reference in their own functions or structs as
//! needed. These types cannot be created outside of workspaces. To use them, refer
//! to surface level types like [`Account`], [`Contract`] and [`Worker`].
//!
//! For example, to query into downloading contract state:
//! ```
//! use near_workspaces::{AccountId, Network, Worker};
//! use near_workspaces::rpc::query::{Query, ViewState};
//!
//! async fn my_func(worker: &Worker<impl Network>) -> anyhow::Result<()> {
//!     let contract_id: AccountId = "some-contract.near".parse()?;
//!     let query: Query<'_, ViewState> = worker.view_state(&contract_id);
//!     let bytes = query.await?;
//!     Ok(())
//! }
//! ```
//! But most of the time, we do not need to worry about these types as they are
//! meant to be transitory, and only exist while calling into their immediate
//! methods. So the above example should look more like the following:
//! ```ignore
//! async fn my_func(worker: &Worker<impl Network>) -> anyhow::Result<()> {
//!     let contract_id: AccountId = "some-contract.near".parse()?;
//!     let bytes = worker.view_state(&contract_id).await?;
//!     Ok(())
//! }
//! ```
//!
//! [`Account`]: crate::Account
//! [`Contract`]: crate::Contract
//! [`Worker`]: crate::Worker

use std::collections::HashMap;
use std::fmt::{Debug, Display};

use near_account_id::AccountId;
use near_jsonrpc_client::methods::query::RpcQueryResponse;
use near_jsonrpc_client::methods::{self, RpcMethod};
use near_jsonrpc_primitives::types::chunks::ChunkReference;
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::types::{BlockId, BlockReference, StoreKey};
use near_primitives::views::{BlockView, QueryRequest};
use near_token::NearToken;

use crate::error::RpcErrorCode;
use crate::operations::Function;
use crate::result::ViewResultDetails;
use crate::rpc::client::Client;
use crate::rpc::{tool, BoxFuture};
use crate::types::account::AccountDetails;
use crate::types::{AccessKey, AccessKeyInfo, BlockHeight, Finality, PublicKey, ShardId};
use crate::{Block, Chunk, CryptoHash, Result};

/// `Query` object allows creating queries into the network of our choice. This object is
/// usually given from making calls from other functions such as [`view_state`].
///
/// [`view_state`]: crate::worker::Worker::view_state
pub struct Query<'a, T> {
    pub(crate) method: T,
    pub(crate) client: &'a Client,
    pub(crate) block_ref: Option<BlockReference>,
}

impl<'a, T> Query<'a, T> {
    pub(crate) fn new(client: &'a Client, method: T) -> Self {
        Self {
            method,
            client,
            block_ref: None,
        }
    }

    /// Specify at which block height to query from. Note that only archival
    /// networks will have the full history while networks like mainnet or testnet will
    /// only have the history from 5 or less epochs ago.
    pub fn block_height(mut self, height: BlockHeight) -> Self {
        self.block_ref = Some(BlockId::Height(height).into());
        self
    }

    /// Specify at which block hash to query from. Note that only archival
    /// networks will have the full history while networks like mainnet or testnet will
    /// only have the history from 5 or less epochs ago.
    pub fn block_hash(mut self, hash: CryptoHash) -> Self {
        self.block_ref = Some(BlockId::Hash(near_primitives::hash::CryptoHash(hash.0)).into());
        self
    }
}

// Constrained to RpcQueryRequest, since methods like GasPrice only take block_id but not Finality.
impl<'a, T> Query<'a, T>
where
    T: ProcessQuery<Method = methods::query::RpcQueryRequest>,
{
    /// Specify at which block [`Finality`] to query from.
    pub fn finality(mut self, value: Finality) -> Self {
        self.block_ref = Some(value.into());
        self
    }

    pub(crate) fn block_reference(mut self, value: BlockReference) -> Self {
        self.block_ref = Some(value);
        self
    }
}

impl<'a, T, R> std::future::IntoFuture for Query<'a, T>
where
    T: ProcessQuery<Output = R> + Send + Sync + 'static,
    <T as ProcessQuery>::Method: RpcMethod + Debug + Send + Sync,
    <<T as ProcessQuery>::Method as RpcMethod>::Response: Debug + Send + Sync,
    <<T as ProcessQuery>::Method as RpcMethod>::Error: Debug + Display + Send + Sync,
{
    type Output = Result<R>;

    // TODO: boxed future required due to impl Trait as type alias being unstable. So once
    // https://github.com/rust-lang/rust/issues/63063 is resolved, we can move to that instead.
    type IntoFuture = BoxFuture<'a, Self::Output>;

    fn into_future(self) -> Self::IntoFuture {
        Box::pin(async move {
            let block_reference = self.block_ref.unwrap_or_else(BlockReference::latest);
            let resp = self
                .client
                .query(self.method.into_request(block_reference)?)
                .await
                .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;

            T::from_response(resp)
        })
    }
}

// Note: this trait is exposed publicly due to constraining with the impl offering `finality`.
/// Trait used as a converter from WorkspaceRequest to near-rpc request, and from near-rpc
/// response to a WorkspaceResult. Mostly used internally to facilitate syntax sugar for performing
/// RPC requests with async builders.
pub trait ProcessQuery {
    // TODO: associated default type is unstable. So for now, will require writing
    // the manual impls for query_request
    /// Method for doing the internal RPC request to the network of our choosing.
    type Method: RpcMethod;

    /// Expected output after performing a query. This is mainly to convert over
    /// the type from near-primitives to a workspace type.
    type Output;

    /// Convert into the Request object that is required to perform the RPC request.
    fn into_request(self, block_ref: BlockReference) -> Result<Self::Method>;

    /// Convert the response from the RPC request to a type of our choosing, mainly to conform
    /// to workspaces related types from the near-primitives or json types from the network.
    fn from_response(resp: <Self::Method as RpcMethod>::Response) -> Result<Self::Output>;
}

pub struct ViewFunction {
    pub(crate) account_id: AccountId,
    pub(crate) function: Function,
}

pub struct ViewCode {
    pub(crate) account_id: AccountId,
}

pub struct ViewAccount {
    pub(crate) account_id: AccountId,
}

pub struct ViewBlock;

pub struct ViewState {
    account_id: AccountId,
    prefix: Option<Vec<u8>>,
}

pub struct ViewAccessKey {
    pub(crate) account_id: AccountId,
    pub(crate) public_key: PublicKey,
}

pub struct ViewAccessKeyList {
    pub(crate) account_id: AccountId,
}

pub struct GasPrice;

impl ProcessQuery for ViewFunction {
    type Method = methods::query::RpcQueryRequest;
    type Output = ViewResultDetails;

    fn into_request(self, block_reference: BlockReference) -> Result<Self::Method> {
        Ok(Self::Method {
            block_reference,
            request: QueryRequest::CallFunction {
                account_id: self.account_id,
                method_name: self.function.name,
                args: self.function.args?.into(),
            },
        })
    }

    fn from_response(resp: RpcQueryResponse) -> Result<Self::Output> {
        match resp.kind {
            QueryResponseKind::CallResult(result) => Ok(result.into()),
            _ => Err(RpcErrorCode::QueryReturnedInvalidData.message("while querying account")),
        }
    }
}

// Specific builder methods attached to a ViewFunction.
impl Query<'_, ViewFunction> {
    /// Provide the arguments for the call. These args are serialized bytes from either
    /// a JSON or Borsh serializable set of arguments. To use the more specific versions
    /// with better quality of life, use `args_json` or `args_borsh`.
    pub fn args(mut self, args: Vec<u8>) -> Self {
        self.method.function = self.method.function.args(args);
        self
    }

    /// Similar to `args`, specify an argument that is JSON serializable and can be
    /// accepted by the equivalent contract. Recommend to use something like
    /// `serde_json::json!` macro to easily serialize the arguments.
    pub fn args_json<U: serde::Serialize>(mut self, args: U) -> Self {
        self.method.function = self.method.function.args_json(args);
        self
    }

    /// Similar to `args`, specify an argument that is borsh serializable and can be
    /// accepted by the equivalent contract.
    pub fn args_borsh<U: near_primitives::borsh::BorshSerialize>(mut self, args: U) -> Self {
        self.method.function = self.method.function.args_borsh(args);
        self
    }
}

impl ProcessQuery for ViewCode {
    type Method = methods::query::RpcQueryRequest;
    type Output = Vec<u8>;

    fn into_request(self, block_reference: BlockReference) -> Result<Self::Method> {
        Ok(Self::Method {
            block_reference,
            request: QueryRequest::ViewCode {
                account_id: self.account_id,
            },
        })
    }

    fn from_response(resp: RpcQueryResponse) -> Result<Self::Output> {
        match resp.kind {
            QueryResponseKind::ViewCode(contract) => Ok(contract.code),
            _ => Err(RpcErrorCode::QueryReturnedInvalidData.message("while querying code")),
        }
    }
}

impl ProcessQuery for ViewAccount {
    type Method = methods::query::RpcQueryRequest;
    type Output = AccountDetails;

    fn into_request(self, block_reference: BlockReference) -> Result<Self::Method> {
        Ok(Self::Method {
            block_reference,
            request: QueryRequest::ViewAccount {
                account_id: self.account_id,
            },
        })
    }

    fn from_response(resp: RpcQueryResponse) -> Result<Self::Output> {
        match resp.kind {
            QueryResponseKind::ViewAccount(account) => Ok(account.into()),
            _ => Err(RpcErrorCode::QueryReturnedInvalidData.message("while querying account")),
        }
    }
}

impl ProcessQuery for ViewBlock {
    type Method = methods::block::RpcBlockRequest;
    type Output = Block;

    fn into_request(self, block_reference: BlockReference) -> Result<Self::Method> {
        Ok(Self::Method { block_reference })
    }

    fn from_response(view: BlockView) -> Result<Self::Output> {
        Ok(view.into())
    }
}

impl ProcessQuery for ViewState {
    type Method = methods::query::RpcQueryRequest;
    type Output = HashMap<Vec<u8>, Vec<u8>>;

    fn into_request(self, block_reference: BlockReference) -> Result<Self::Method> {
        Ok(Self::Method {
            block_reference,
            request: QueryRequest::ViewState {
                account_id: self.account_id,
                prefix: StoreKey::from(self.prefix.map(Vec::from).unwrap_or_default()),
                include_proof: false,
            },
        })
    }

    fn from_response(resp: <Self::Method as RpcMethod>::Response) -> Result<Self::Output> {
        match resp.kind {
            QueryResponseKind::ViewState(state) => Ok(tool::into_state_map(state.values)),
            _ => Err(RpcErrorCode::QueryReturnedInvalidData.message("while querying state")),
        }
    }
}

impl<'a> Query<'a, ViewState> {
    pub(crate) fn view_state(client: &'a Client, id: &AccountId) -> Self {
        Self::new(
            client,
            ViewState {
                account_id: id.clone(),
                prefix: None,
            },
        )
    }

    /// Set the prefix for viewing the state.
    pub fn prefix(mut self, value: &[u8]) -> Self {
        self.method.prefix = Some(value.into());
        self
    }
}

impl ProcessQuery for ViewAccessKey {
    type Method = methods::query::RpcQueryRequest;
    type Output = AccessKey;

    fn into_request(self, block_reference: BlockReference) -> Result<Self::Method> {
        Ok(Self::Method {
            block_reference,
            request: QueryRequest::ViewAccessKey {
                account_id: self.account_id,
                public_key: self.public_key.into(),
            },
        })
    }

    fn from_response(resp: <Self::Method as RpcMethod>::Response) -> Result<Self::Output> {
        match resp.kind {
            QueryResponseKind::AccessKey(key) => Ok(key.into()),
            _ => Err(RpcErrorCode::QueryReturnedInvalidData.message("while querying access key")),
        }
    }
}

impl ProcessQuery for ViewAccessKeyList {
    type Method = methods::query::RpcQueryRequest;
    type Output = Vec<AccessKeyInfo>;

    fn into_request(self, block_reference: BlockReference) -> Result<Self::Method> {
        Ok(Self::Method {
            block_reference,
            request: QueryRequest::ViewAccessKeyList {
                account_id: self.account_id,
            },
        })
    }

    fn from_response(resp: <Self::Method as RpcMethod>::Response) -> Result<Self::Output> {
        match resp.kind {
            QueryResponseKind::AccessKeyList(keylist) => {
                Ok(keylist.keys.into_iter().map(Into::into).collect())
            }
            _ => Err(RpcErrorCode::QueryReturnedInvalidData.message("while querying access keys")),
        }
    }
}

impl ProcessQuery for GasPrice {
    type Method = methods::gas_price::RpcGasPriceRequest;
    type Output = NearToken;

    fn into_request(self, block_ref: BlockReference) -> Result<Self::Method> {
        let block_id = match block_ref {
            // User provided input via `block_hash` or `block_height` functions.
            BlockReference::BlockId(block_id) => Some(block_id),
            // default case, set by `Query` struct via BlockReference::latest.
            BlockReference::Finality(_finality) => None,
            // Should not be reachable, unless code got changed.
            BlockReference::SyncCheckpoint(point) => {
                return Err(RpcErrorCode::QueryFailure.message(format!(
                    "Cannot supply sync checkpoint to gas price: {point:?}. Potential API bug?"
                )))
            }
        };

        Ok(Self::Method { block_id })
    }

    fn from_response(resp: <Self::Method as RpcMethod>::Response) -> Result<Self::Output> {
        Ok(NearToken::from_yoctonear(resp.gas_price))
    }
}

/// Query object used to query for chunk related details at a specific `ChunkReference` which
/// consists of either a chunk [`CryptoHash`], or a `BlockShardId` (which consists of [`ShardId`]
/// and either block [`CryptoHash`] or [`BlockHeight`]).
///
/// The default behavior where a `ChunkReference` is not supplied will use a `BlockShardId`
/// referencing the latest block `CryptoHash` with `ShardId` of 0.
pub struct QueryChunk<'a> {
    client: &'a Client,
    chunk_ref: Option<ChunkReference>,
}

impl<'a> QueryChunk<'a> {
    pub(crate) fn new(client: &'a Client) -> Self {
        Self {
            client,
            chunk_ref: None,
        }
    }

    /// Specify at which block hash and shard id to query the chunk from. Note that only
    /// archival networks will have the full history while networks like mainnet or testnet
    /// will only have the history from 5 or less epochs ago.
    pub fn block_hash_and_shard(mut self, hash: CryptoHash, shard_id: ShardId) -> Self {
        self.chunk_ref = Some(ChunkReference::BlockShardId {
            block_id: BlockId::Hash(near_primitives::hash::CryptoHash(hash.0)),
            shard_id,
        });
        self
    }

    /// Specify at which block height and shard id to query the chunk from. Note that only
    /// archival networks will have the full history while networks like mainnet or testnet
    /// will only have the history from 5 or less epochs ago.
    pub fn block_height_and_shard(mut self, height: BlockHeight, shard_id: ShardId) -> Self {
        self.chunk_ref = Some(ChunkReference::BlockShardId {
            block_id: BlockId::Height(height),
            shard_id,
        });
        self
    }

    /// Specify at which chunk hash to query the chunk from.
    pub fn chunk_hash(mut self, hash: CryptoHash) -> Self {
        self.chunk_ref = Some(ChunkReference::ChunkHash {
            chunk_id: near_primitives::hash::CryptoHash(hash.0),
        });
        self
    }
}

impl<'a> std::future::IntoFuture for QueryChunk<'a> {
    type Output = Result<Chunk>;
    type IntoFuture = BoxFuture<'a, Self::Output>;

    fn into_future(self) -> Self::IntoFuture {
        Box::pin(async move {
            let chunk_reference = if let Some(chunk_ref) = self.chunk_ref {
                chunk_ref
            } else {
                // Use the latest block hash in the case the user doesn't supply the ChunkReference. Note that
                // shard_id 0 is used in the default case.
                let block_view = self.client.view_block(None).await?;
                ChunkReference::BlockShardId {
                    block_id: BlockId::Hash(block_view.header.hash),
                    shard_id: 0,
                }
            };

            let chunk_view = self
                .client
                .query(methods::chunk::RpcChunkRequest { chunk_reference })
                .await
                .map_err(|e| RpcErrorCode::QueryFailure.custom(e))?;

            Ok(chunk_view.into())
        })
    }
}

'''
'''--- workspaces/src/rpc/tool.rs ---
use std::collections::HashMap;
use std::convert::TryInto;
use std::fs::File;
use std::io::Write;
use std::path::Path;

use chrono::Utc;
use rand::Rng;
use url::Url;

use near_crypto::SecretKey;
use near_primitives::views::StateItem;

use crate::error::{ErrorKind, RpcErrorCode};
use crate::result::Result;
use crate::types::{AccountId, PublicKey};

/// Convert `StateItem`s over to a Map<data_key, value_bytes> representation.
/// Assumes key and value are base64 encoded, so this also decodes them.
pub(crate) fn into_state_map(state_items: Vec<StateItem>) -> HashMap<Vec<u8>, Vec<u8>> {
    state_items
        .into_iter()
        .map(|s| (s.key.into(), s.value.into()))
        .collect()
}

pub(crate) fn random_account_id() -> AccountId {
    let mut rng = rand::thread_rng();
    let random_num = rng.gen_range(10000000000000usize..99999999999999);
    let account_id = format!("dev-{}-{}", Utc::now().format("%Y%m%d%H%M%S"), random_num);
    let account_id: AccountId = account_id
        .try_into()
        .expect("could not convert dev account into AccountId");

    account_id
}

pub(crate) async fn url_create_account(
    helper_url: Url,
    account_id: AccountId,
    pk: PublicKey,
) -> Result<()> {
    let helper_url = helper_url.join("account").unwrap();

    // TODO(maybe): need this in near-jsonrpc-client as well:
    let _resp = reqwest::Client::new()
        .post(helper_url)
        .header("Content-Type", "application/json")
        .body(
            serde_json::to_vec(&serde_json::json!({
                "newAccountId": account_id,
                "newAccountPublicKey": pk,
            }))
            .map_err(|e| ErrorKind::DataConversion.custom(e))?,
        )
        .send()
        .await
        .map_err(|e| RpcErrorCode::HelperAccountCreationFailure.custom(e))?;

    Ok(())
}

pub(crate) fn write_cred_to_file(path: &Path, id: &AccountId, sk: &SecretKey) -> Result<()> {
    let mut file = File::create(path).map_err(|err| {
        ErrorKind::Io.full(
            format!("failed to open {path:?} for writing credentials"),
            err,
        )
    })?;

    #[cfg(unix)]
    {
        use std::os::unix::prelude::PermissionsExt;
        let mut perm = file
            .metadata()
            .map_err(|err| ErrorKind::Io.full("Failed to retrieve key file metadata.", err))?
            .permissions();

        #[cfg(target_os = "macos")]
        perm.set_mode(u32::from(libc::S_IWUSR | libc::S_IRUSR));
        #[cfg(not(target_os = "macos"))]
        perm.set_mode(libc::S_IWUSR | libc::S_IRUSR);

        file.set_permissions(perm)
            .map_err(|err| ErrorKind::Io.full("Failed to set permissions for a key file.", err))?;
    }

    let content = serde_json::json!({
        "account_id": id,
        "public_key": sk.public_key(),
        "secret_key": sk,
    })
    .to_string()
    .into_bytes();

    file.write_all(&content)
        .map_err(|err| ErrorKind::Io.full("Failed to write a key file", err))
}

'''
'''--- workspaces/src/types/account.rs ---
use std::fmt;
use std::path::Path;

use near_primitives::views::AccountView;

use crate::error::ErrorKind;
use crate::rpc::query::{
    Query, ViewAccessKey, ViewAccessKeyList, ViewAccount, ViewCode, ViewFunction, ViewState,
};
use crate::types::{AccountId, InMemorySigner, NearToken, PublicKey, SecretKey};
use crate::{BlockHeight, CryptoHash, Network, Worker};

use crate::operations::{CallTransaction, CreateAccountTransaction, Transaction};
use crate::result::{Execution, ExecutionFinalResult, Result};

/// `Account` is directly associated to an account in the network provided by the
/// [`Worker`] that creates it. This type offers methods to interact with any
/// network, such as creating transactions and calling into contract functions.
#[derive(Clone)]
pub struct Account {
    signer: InMemorySigner,
    worker: Worker<dyn Network>,
}

impl fmt::Debug for Account {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Account")
            .field("id", &self.signer.account_id)
            .finish()
    }
}

impl Account {
    /// Create a new account with the given path to the credentials JSON file
    pub fn from_file(
        path: impl AsRef<Path>,
        worker: &Worker<impl Network + 'static>,
    ) -> Result<Self> {
        let signer = InMemorySigner::from_file(path.as_ref())?;
        Ok(Self::new(signer, worker.clone().coerce()))
    }

    /// Create an [`Account`] object from an [`AccountId`] and [`SecretKey`].
    pub fn from_secret_key(
        id: AccountId,
        sk: SecretKey,
        worker: &Worker<impl Network + 'static>,
    ) -> Self {
        Self {
            signer: InMemorySigner::from_secret_key(id, sk),
            worker: worker.clone().coerce(),
        }
    }

    pub(crate) fn new(signer: InMemorySigner, worker: Worker<dyn Network>) -> Self {
        Self { signer, worker }
    }

    /// Grab the current account identifier
    pub fn id(&self) -> &AccountId {
        &self.signer.account_id
    }

    /// Grab the signer of the account. This signer is used to sign all transactions
    /// sent to the network.
    pub fn signer(&self) -> &InMemorySigner {
        &self.signer
    }

    /// Call a contract on the network specified within `worker`, and return
    /// a [`CallTransaction`] object that we will make use to populate the
    /// rest of the call details. Note that the current [`Account`]'s secret
    /// key is used as the signer of the transaction.
    pub fn call(&self, contract_id: &AccountId, function: &str) -> CallTransaction {
        CallTransaction::new(
            self.worker.clone(),
            contract_id.to_owned(),
            self.signer.clone(),
            function,
        )
    }

    /// View call to a specified contract function. Returns a result which can
    /// be deserialized into borsh or JSON.
    pub fn view(&self, contract_id: &AccountId, function: &str) -> Query<'_, ViewFunction> {
        self.worker.view(contract_id, function)
    }

    /// Transfer NEAR to an account specified by `receiver_id` with the amount
    /// specified by `amount`. Returns the execution details of this transaction
    pub async fn transfer_near(
        &self,
        receiver_id: &AccountId,
        amount: NearToken,
    ) -> Result<ExecutionFinalResult> {
        self.worker
            .transfer_near(self.signer(), receiver_id, amount)
            .await
    }

    /// Deletes the current account, and returns the execution details of this
    /// transaction. The beneficiary will receive the funds of the account deleted
    pub async fn delete_account(self, beneficiary_id: &AccountId) -> Result<ExecutionFinalResult> {
        self.worker
            .delete_account(self.id(), &self.signer, beneficiary_id)
            .await
    }

    /// Views the current account's details such as balance and storage usage.
    pub fn view_account(&self) -> Query<'_, ViewAccount> {
        self.worker.view_account(self.id())
    }

    /// Views the current accounts's access key, given the [`PublicKey`] associated to it.
    pub fn view_access_key(&self, pk: &PublicKey) -> Query<'_, ViewAccessKey> {
        Query::new(
            self.worker.client(),
            ViewAccessKey {
                account_id: self.id().clone(),
                public_key: pk.clone(),
            },
        )
    }

    /// Views all the [`AccessKey`]s of the current account. This will return a list of
    /// [`AccessKey`]s along with each associated [`PublicKey`].
    ///
    /// [`AccessKey`]: crate::types::AccessKey
    pub fn view_access_keys(&self) -> Query<'_, ViewAccessKeyList> {
        Query::new(
            self.worker.client(),
            ViewAccessKeyList {
                account_id: self.id().clone(),
            },
        )
    }

    /// Create a new sub account. Returns a [`CreateAccountTransaction`] object
    /// that we can make use of to fill out the rest of the details. The subaccount
    /// id will be in the form of: "{new_account_id}.{parent_account_id}"
    pub fn create_subaccount<'a, 'b>(
        &'a self,
        new_account_id: &'b str,
    ) -> CreateAccountTransaction<'a, 'b> {
        CreateAccountTransaction::new(
            &self.worker,
            self.signer.clone(),
            self.id().clone(),
            new_account_id,
        )
    }

    /// Deploy contract code or WASM bytes to the account, and return us a new
    /// [`Contract`] object that we can use to interact with the contract.
    pub async fn deploy(&self, wasm: &[u8]) -> Result<Execution<Contract>> {
        let outcome = self
            .worker
            .client()
            .deploy(&self.signer, self.id(), wasm.into())
            .await?;

        Ok(Execution {
            result: Contract::new(self.signer().clone(), self.worker.clone()),
            details: ExecutionFinalResult::from_view(outcome),
        })
    }

    /// Start a batch transaction, using the current account as the signer and
    /// making calls into the contract provided by `contract_id`. Returns a
    /// [`Transaction`] object that we can use to add Actions to the batched
    /// transaction. Call `transact` to send the batched transaction to the
    /// network.
    pub fn batch(&self, contract_id: &AccountId) -> Transaction {
        Transaction::new(
            self.worker.clone(),
            self.signer().clone(),
            contract_id.clone(),
        )
    }

    /// Store the credentials of this account locally in the directory provided.
    pub async fn store_credentials(&self, save_dir: impl AsRef<Path> + Send) -> Result<()> {
        let savepath = save_dir.as_ref();
        std::fs::create_dir_all(&save_dir).map_err(|e| ErrorKind::Io.custom(e))?;
        let savepath = savepath.join(format!("{}.json", self.id()));
        crate::rpc::tool::write_cred_to_file(&savepath, self.id(), &self.secret_key().0)
    }

    /// Get the keys of this account. The public key can be retrieved from the secret key.
    pub fn secret_key(&self) -> &SecretKey {
        &self.signer.secret_key
    }

    /// Sets the [`SecretKey`] of this account. Future transactions will be signed
    /// using this newly provided key.
    pub fn set_secret_key(&mut self, sk: SecretKey) {
        self.signer.secret_key = sk;
    }
}

/// `Contract` is directly associated to a contract in the network provided by the
/// [`Worker`] that creates it. This type offers methods to interact with any
/// network, such as creating transactions and calling into contract functions.
#[derive(Clone)]
pub struct Contract {
    pub(crate) account: Account,
}

impl fmt::Debug for Contract {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Contract")
            .field("id", self.account.id())
            .finish()
    }
}

impl Contract {
    /// Create a [`Contract`] object from an [`AccountId`] and [`SecretKey`].
    pub fn from_secret_key(
        id: AccountId,
        sk: SecretKey,
        worker: &Worker<impl Network + 'static>,
    ) -> Self {
        Self::account(Account::from_secret_key(id, sk, worker))
    }

    pub(crate) fn new(signer: InMemorySigner, worker: Worker<dyn Network>) -> Self {
        Self {
            account: Account::new(signer, worker),
        }
    }

    pub(crate) fn account(account: Account) -> Self {
        Self { account }
    }

    /// Grab the current contract's account identifier
    pub fn id(&self) -> &AccountId {
        self.account.id()
    }

    /// Treat this [`Contract`] object as an [`Account`] type. This does nothing
    /// on chain/network, and is merely allowing `Account::*` functions to be
    /// used from this `Contract`.
    pub fn as_account(&self) -> &Account {
        &self.account
    }

    /// Treat this [`Contract`] object as an [`Account`] type. This does nothing
    /// on chain/network, and is merely allowing `Account::*` functions to be
    /// used from this `Contract`.
    pub fn as_account_mut(&mut self) -> &mut Account {
        &mut self.account
    }

    /// Grab the signer of the account. This signer is used to sign all transactions
    /// sent to the network.
    pub fn signer(&self) -> &InMemorySigner {
        self.account.signer()
    }

    /// Call the current contract's function using the contract's own account
    /// secret key to do the signing. Returns a [`CallTransaction`] object that
    /// we will make use to populate the rest of the call details.
    ///
    /// If we want to make use of the contract's secret key as a signer to call
    /// into another contract, use `contract.as_account().call` instead.
    pub fn call(&self, function: &str) -> CallTransaction {
        self.account.call(self.id(), function)
    }

    /// Call a view function into the current contract. Returns a result which can
    /// be deserialized into borsh or JSON.
    pub fn view(&self, function: &str) -> Query<'_, ViewFunction> {
        self.account.view(self.id(), function)
    }

    /// View the WASM code bytes of this contract.
    pub fn view_code(&self) -> Query<'_, ViewCode> {
        self.account.worker.view_code(self.id())
    }

    /// View a contract's state map of key value pairs.
    pub fn view_state(&self) -> Query<'_, ViewState> {
        self.account.worker.view_state(self.id())
    }

    /// Views the current contract's details such as balance and storage usage.
    pub fn view_account(&self) -> Query<'_, ViewAccount> {
        self.account.worker.view_account(self.id())
    }

    /// Views the current contract's access key, given the [`PublicKey`] associated to it.
    pub fn view_access_key(&self, pk: &PublicKey) -> Query<'_, ViewAccessKey> {
        self.account.view_access_key(pk)
    }

    /// Views all the [`AccessKey`]s of the current contract. This will return a list of
    /// [`AccessKey`]s along with each associated [`PublicKey`].
    ///
    /// [`AccessKey`]: crate::types::AccessKey
    pub fn view_access_keys(&self) -> Query<'_, ViewAccessKeyList> {
        self.account.view_access_keys()
    }

    /// Deletes the current contract, and returns the execution details of this
    /// transaction. The beneficiary will receive the funds of the account deleted
    pub async fn delete_contract(self, beneficiary_id: &AccountId) -> Result<ExecutionFinalResult> {
        self.account.delete_account(beneficiary_id).await
    }

    /// Start a batch transaction, using the current contract's secret key as the
    /// signer, making calls into itself. Returns a [`Transaction`] object that
    /// we can use to add Actions to the batched transaction. Call `transact`
    /// to send the batched transaction to the network.
    pub fn batch(&self) -> Transaction {
        self.account.batch(self.id())
    }
}

/// Details of an Account or Contract. This is an non-exhaustive list of items
/// that the account stores in the blockchain state.
///
/// This struct is the same as [`AccountDetails`] with the exception that it provides
/// optional fields that guard against 'null' overwrites when making a patch.
#[derive(Debug, Default, Eq, PartialEq)]
#[non_exhaustive]
pub struct AccountDetailsPatch {
    pub balance: Option<NearToken>,
    pub locked: Option<NearToken>,
    pub code_hash: Option<CryptoHash>,
    pub storage_usage: Option<u64>,
    pub(crate) storage_paid_at: Option<BlockHeight>,
}

impl AccountDetailsPatch {
    pub fn reduce(&mut self, acc: Self) {
        if let Some(balance) = acc.balance {
            self.balance = Some(balance);
        }
        if let Some(locked) = acc.locked {
            self.locked = Some(locked);
        }
        if let Some(code_hash) = acc.code_hash {
            self.code_hash = Some(code_hash);
        }
        if let Some(storage) = acc.storage_usage {
            self.storage_usage = Some(storage);
        }
        if let Some(storage_paid_at) = acc.storage_paid_at {
            self.storage_paid_at = Some(storage_paid_at);
        }
    }

    pub fn balance(mut self, balance: NearToken) -> Self {
        self.balance = Some(balance);
        self
    }

    pub fn locked(mut self, locked: NearToken) -> Self {
        self.locked = Some(locked);
        self
    }

    pub fn code_hash(mut self, code_hash: CryptoHash) -> Self {
        self.code_hash = Some(code_hash);
        self
    }

    pub fn storage_usage(mut self, storage_usage: u64) -> Self {
        self.storage_usage = Some(storage_usage);
        self
    }
}

impl From<AccountDetails> for AccountDetailsPatch {
    fn from(account: AccountDetails) -> Self {
        Self {
            balance: Some(account.balance),
            locked: Some(account.locked),
            code_hash: Some(account.code_hash),
            storage_usage: Some(account.storage_usage),
            storage_paid_at: Some(account.storage_paid_at),
        }
    }
}

/// Details of an Account or Contract. This is an non-exhaustive list of items
/// that the account stores in the blockchain state.
#[derive(Debug, Eq, PartialEq)]
#[non_exhaustive]
pub struct AccountDetails {
    pub balance: NearToken,
    pub locked: NearToken,
    pub code_hash: CryptoHash,
    pub storage_usage: u64,
    // Deprecated value. Mainly used to be able to convert back into an AccountView
    pub(crate) storage_paid_at: BlockHeight,
}

impl AccountDetails {
    pub fn new() -> Self {
        Self {
            balance: NearToken::from_near(0),
            locked: NearToken::from_near(0),
            code_hash: CryptoHash::default(),
            storage_usage: 0,
            storage_paid_at: 0,
        }
    }

    pub(crate) fn into_near_account(self) -> near_primitives::account::Account {
        near_primitives::account::Account::new(
            self.balance.as_yoctonear(),
            self.locked.as_yoctonear(),
            near_primitives::hash::CryptoHash(self.code_hash.0),
            self.storage_usage,
        )
    }
}

impl Default for AccountDetails {
    fn default() -> Self {
        Self::new()
    }
}

impl From<AccountView> for AccountDetails {
    fn from(account: AccountView) -> Self {
        Self {
            balance: NearToken::from_yoctonear(account.amount),
            locked: NearToken::from_yoctonear(account.locked),
            code_hash: CryptoHash(account.code_hash.0),
            storage_usage: account.storage_usage,
            storage_paid_at: account.storage_paid_at,
        }
    }
}

impl From<AccountDetailsPatch> for AccountDetails {
    fn from(value: AccountDetailsPatch) -> Self {
        Self {
            balance: value.balance.unwrap_or_default(),
            locked: value.locked.unwrap_or_default(),
            code_hash: value.code_hash.unwrap_or_default(),
            storage_usage: value.storage_usage.unwrap_or_default(),
            storage_paid_at: value.storage_paid_at.unwrap_or_default(),
        }
    }
}

'''
'''--- workspaces/src/types/block.rs ---
use near_account_id::AccountId;
use near_primitives::views::{BlockHeaderView, BlockView};

use crate::types::{ChunkHeader, NearToken};
use crate::{BlockHeight, CryptoHash};

/// Struct containing information on block coming from the network
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Block {
    author: AccountId,
    header: BlockHeader,
    chunks: Vec<ChunkHeader>,
}

impl Block {
    /// The account id of the block author.
    pub fn author(&self) -> &AccountId {
        &self.author
    }

    /// The block header info.
    pub fn header(&self) -> &BlockHeader {
        &self.header
    }

    /// The list of chunks in this block.
    pub fn chunks(&self) -> &[ChunkHeader] {
        &self.chunks
    }

    /// The block timestamp in nanoseconds.
    pub fn timestamp(&self) -> u64 {
        self.header.timestamp_nanosec
    }

    /// Current height of this block.
    pub fn height(&self) -> BlockHeight {
        self.header.height
    }

    /// The hash of the block itself.
    pub fn hash(&self) -> &CryptoHash {
        &self.header.hash
    }

    /// The id of an epoch this block belongs to.
    pub fn epoch_id(&self) -> &CryptoHash {
        &self.header.epoch_id
    }
}

/// The block header info. This is a non-exhaustive list of items that
/// could be present in a block header. More can be added in the future.
///
/// NOTE: For maintainability purposes, some items have been excluded. If required,
/// please submit an issue to [workspaces](https://github.com/near/workspaces-rs/issues).
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BlockHeader {
    height: BlockHeight,
    epoch_id: CryptoHash,
    next_epoch_id: CryptoHash,
    hash: CryptoHash,
    prev_hash: CryptoHash,
    timestamp_nanosec: u64,
    random_value: CryptoHash,
    gas_price: NearToken,
    block_ordinal: Option<u64>,
    total_supply: NearToken,
    last_final_block: CryptoHash,
    last_ds_final_block: CryptoHash,
    next_bp_hash: CryptoHash,
    latest_protocol_version: u32,

    prev_state_root: CryptoHash,
    chunk_receipts_root: CryptoHash,
    chunk_headers_root: CryptoHash,
    chunk_tx_root: CryptoHash,
    outcome_root: CryptoHash,
    challenges_root: CryptoHash,
    block_merkle_root: CryptoHash,
}

impl BlockHeader {
    /// Current height of this block.
    pub fn height(&self) -> BlockHeight {
        self.height
    }

    /// The id of an epoch this block belongs to.
    pub fn epoch_id(&self) -> &CryptoHash {
        &self.epoch_id
    }

    /// The next epoch id.
    pub fn next_epoch_id(&self) -> &CryptoHash {
        &self.next_epoch_id
    }

    /// The hash of the block itself.
    pub fn hash(&self) -> &CryptoHash {
        &self.hash
    }

    /// The hash of the previous block.
    pub fn prev_hash(&self) -> &CryptoHash {
        &self.prev_hash
    }

    /// The block timestamp in nanoseconds.
    pub fn timestamp_nanosec(&self) -> u64 {
        self.timestamp_nanosec
    }

    /// The random value of the block.
    pub fn random_value(&self) -> &CryptoHash {
        &self.random_value
    }

    /// The gas price of the block.
    pub fn gas_price(&self) -> NearToken {
        self.gas_price
    }

    /// The block ordinal.
    pub fn block_ordinal(&self) -> Option<u64> {
        self.block_ordinal
    }

    /// The total supply balance of the block.
    pub fn total_supply(&self) -> NearToken {
        self.total_supply
    }

    /// The last final block hash.
    pub fn last_final_block(&self) -> &CryptoHash {
        &self.last_final_block
    }

    /// The last ds final block hash.
    pub fn last_ds_final_block(&self) -> &CryptoHash {
        &self.last_ds_final_block
    }

    /// The next bp hash.
    pub fn next_bp_hash(&self) -> &CryptoHash {
        &self.next_bp_hash
    }

    /// The latest protocol version.
    pub fn latest_protocol_version(&self) -> u32 {
        self.latest_protocol_version
    }

    /// The previous state root.
    pub fn prev_state_root(&self) -> &CryptoHash {
        &self.prev_state_root
    }

    /// The chunk receipts root.
    pub fn chunk_receipts_root(&self) -> &CryptoHash {
        &self.chunk_receipts_root
    }

    /// The chunk headers root.
    pub fn chunk_headers_root(&self) -> &CryptoHash {
        &self.chunk_headers_root
    }

    /// The chunk tx root.
    pub fn chunk_tx_root(&self) -> &CryptoHash {
        &self.chunk_tx_root
    }

    /// The outcome root.
    pub fn outcome_root(&self) -> &CryptoHash {
        &self.outcome_root
    }

    /// The challenges root.
    pub fn challenges_root(&self) -> &CryptoHash {
        &self.challenges_root
    }

    /// The block merkle root.
    pub fn block_merkle_root(&self) -> &CryptoHash {
        &self.block_merkle_root
    }
}

impl From<BlockView> for Block {
    fn from(view: BlockView) -> Self {
        Self {
            author: view.author,
            header: view.header.into(),
            chunks: view.chunks.into_iter().map(Into::into).collect(),
        }
    }
}

impl From<BlockHeaderView> for BlockHeader {
    fn from(header_view: BlockHeaderView) -> Self {
        Self {
            height: header_view.height,
            epoch_id: header_view.epoch_id.into(),
            next_epoch_id: header_view.next_epoch_id.into(),
            hash: header_view.hash.into(),
            prev_hash: header_view.prev_hash.into(),
            timestamp_nanosec: header_view.timestamp_nanosec,
            random_value: header_view.random_value.into(),
            gas_price: NearToken::from_yoctonear(header_view.gas_price),
            block_ordinal: header_view.block_ordinal,
            total_supply: NearToken::from_yoctonear(header_view.total_supply),
            last_final_block: header_view.last_final_block.into(),
            last_ds_final_block: header_view.last_ds_final_block.into(),
            next_bp_hash: header_view.next_bp_hash.into(),
            latest_protocol_version: header_view.latest_protocol_version,

            prev_state_root: header_view.prev_state_root.into(),
            chunk_receipts_root: header_view.chunk_receipts_root.into(),
            chunk_headers_root: header_view.chunk_headers_root.into(),
            chunk_tx_root: header_view.chunk_tx_root.into(),
            outcome_root: header_view.outcome_root.into(),
            challenges_root: header_view.challenges_root.into(),
            block_merkle_root: header_view.block_merkle_root.into(),
        }
    }
}

'''
'''--- workspaces/src/types/chunk.rs ---
use near_account_id::AccountId;
use near_gas::NearGas;
use near_primitives::views::{ChunkHeaderView, ChunkView};

use crate::types::{Gas, NearToken, ShardId};
use crate::{BlockHeight, CryptoHash};

// Chunk object associated to a chunk on chain. This provides info about what
// current state of a chunk is like.
#[derive(Debug, Clone, Eq, PartialEq)]
#[non_exhaustive]
pub struct Chunk {
    pub author: AccountId,
    pub header: ChunkHeader,
}

/// The header belonging to a [`Chunk`]. This is a non-exhaustive list of
/// members belonging to a Chunk, where newer fields can be added in the future.
///
/// NOTE: For maintainability purposes, some items have been excluded. If required,
/// please submit an issue to [workspaces](https://github.com/near/workspaces-rs/issues).
#[derive(Debug, Clone, Eq, PartialEq)]
#[non_exhaustive]
pub struct ChunkHeader {
    pub chunk_hash: CryptoHash,
    pub prev_block_hash: CryptoHash,
    pub height_created: BlockHeight,
    pub height_included: BlockHeight,
    pub shard_id: ShardId,
    pub gas_used: Gas,
    pub gas_limit: Gas,
    pub balance_burnt: NearToken,

    pub tx_root: CryptoHash,
    pub outcome_root: CryptoHash,
    pub prev_state_root: CryptoHash,
    pub outgoing_receipts_root: CryptoHash,
    pub encoded_merkle_root: CryptoHash,
    pub encoded_length: u64,
}

impl From<ChunkView> for Chunk {
    fn from(view: ChunkView) -> Self {
        Self {
            author: view.author,
            header: view.header.into(),
        }
    }
}

impl From<ChunkHeaderView> for ChunkHeader {
    fn from(view: ChunkHeaderView) -> Self {
        Self {
            chunk_hash: view.chunk_hash.into(),
            prev_block_hash: view.prev_block_hash.into(),
            height_created: view.height_created,
            height_included: view.height_included,
            shard_id: view.shard_id,
            gas_used: NearGas::from_gas(view.gas_used),
            gas_limit: NearGas::from_gas(view.gas_limit),
            balance_burnt: NearToken::from_yoctonear(view.balance_burnt),
            tx_root: view.tx_root.into(),
            outcome_root: view.outcome_root.into(),
            prev_state_root: view.prev_state_root.into(),
            outgoing_receipts_root: view.outgoing_receipts_root.into(),
            encoded_merkle_root: view.encoded_merkle_root.into(),
            encoded_length: view.encoded_length,
        }
    }
}

impl Chunk {
    /// The hash of the chunk itself.
    pub fn hash(&self) -> &CryptoHash {
        &self.header.chunk_hash
    }

    /// Which specific shard this chunk belongs to.
    pub fn shard_id(&self) -> ShardId {
        self.header.shard_id
    }
}

'''
'''--- workspaces/src/types/gas_meter.rs ---
use std::panic::{RefUnwindSafe, UnwindSafe};
use std::sync::{Arc, Mutex};

use super::Gas;
use crate::result::Result;
use crate::Worker;

/// A hook that is called on every transaction that is sent to the network.
/// This is useful for debugging purposes, or for tracking the amount of gas
/// that is being used.
///
/// The auto-traits [`Send`], [`Sync`], [`UnwindSafe`] and [`RefUnwindSafe`] are added explicitly because they
/// do not fall under the rules the compiler uses to automatically add them.
/// See here: <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>
pub(crate) type GasHook = Arc<dyn Fn(Gas) -> Result<()> + Send + Sync + UnwindSafe + RefUnwindSafe>;

/// Allows you to meter the amount of gas consumed by transaction(s).
/// Note: This only works with transactions that resolve to [`crate::result::ExecutionFinalResult`]
/// Example
/// ```rust, ignore, no_run
/// let mut worker = near_workspaces::sandbox().await?;
/// let meter = GasMeter::now(&mut worker);
///
/// let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
/// let contract = worker.dev_deploy(&wasm).await?;
///
/// contract
///    .call("set_status")
///    .args_json(json!({
///        "message": "hello_world",
///    }))
///    .transact()
///    .await?;
///
/// println!("Total Gas consumed: {}", meter.elapsed()?);
/// ```
pub struct GasMeter {
    gas: Arc<Mutex<Gas>>,
}

impl GasMeter {
    /// Create a new gas meter with 0 gas consumed.
    pub fn now<T: ?Sized>(worker: &mut Worker<T>) -> Self {
        let meter = Self {
            gas: Arc::new(Mutex::new(Gas::from_gas(0))),
        };

        let gas_consumed = Arc::downgrade(&Arc::clone(&meter.gas));
        worker.tx_callbacks.push(Arc::new(move |gas: Gas| {
            // upgrades if meter is still alive, else noop.
            if let Some(consumed) = gas_consumed.upgrade() {
                let mut consumed = consumed.lock()?;
                *consumed = Gas::from_gas(consumed.as_gas() + gas.as_gas());
            }

            Ok(())
        }));

        meter
    }

    /// Get the total amount of gas consumed.
    pub fn elapsed(&self) -> Result<Gas> {
        let meter = self.gas.lock()?;
        Ok(*meter)
    }

    /// Reset the gas consumed to 0.
    pub fn reset(&self) -> Result<()> {
        *self.gas.lock()? = Gas::from_gas(0);
        Ok(())
    }
}

'''
'''--- workspaces/src/types/mod.rs ---
//! Types used in the workspaces crate. A lot of these are types are copied over from near_primitives
//! since those APIs are not yet stable. Once they are, we can directly reference them here, so no
//! changes on the library consumer side is needed. Just keep using these types defined here as-is.

pub(crate) mod account;
pub(crate) mod block;
pub(crate) mod chunk;
pub(crate) mod gas_meter;

#[cfg(feature = "interop_sdk")]
mod sdk;

use std::convert::TryFrom;
use std::fmt::{self, Debug, Display};
use std::io;
use std::path::Path;
use std::str::FromStr;

pub use near_account_id::AccountId;
use near_primitives::borsh::{BorshDeserialize, BorshSerialize};

use serde::{Deserialize, Serialize};
use sha2::Digest;

use crate::error::{Error, ErrorKind};
use crate::result::Result;

pub use self::account::{AccountDetails, AccountDetailsPatch};
pub use self::chunk::{Chunk, ChunkHeader};
pub use self::gas_meter::GasMeter;

/// Nonce is a unit used to determine the order of transactions in the pool.
pub type Nonce = u64;

/// Gas units used in the execution of transactions. For a more in depth description of
/// how and where it can be used, visit [Gas](https://docs.near.org/docs/concepts/gas).
pub use near_gas::NearGas as Gas;

pub use near_token::NearToken;

/// Height of a specific block
pub type BlockHeight = u64;

/// Shard index, from 0 to NUM_SHARDS - 1.
pub type ShardId = u64;

fn from_base58(s: &str) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {
    bs58::decode(s).into_vec().map_err(|err| err.into())
}

/// Key types supported for either a [`SecretKey`] or [`PublicKey`]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)]
#[non_exhaustive]
pub enum KeyType {
    ED25519 = 0,
    SECP256K1 = 1,
}

impl KeyType {
    const fn into_near_keytype(self) -> near_crypto::KeyType {
        match self {
            Self::ED25519 => near_crypto::KeyType::ED25519,
            Self::SECP256K1 => near_crypto::KeyType::SECP256K1,
        }
    }

    const fn from_near_keytype(key_type: near_crypto::KeyType) -> Self {
        match key_type {
            near_crypto::KeyType::ED25519 => Self::ED25519,
            near_crypto::KeyType::SECP256K1 => Self::SECP256K1,
        }
    }

    /// Length of the bytes of the public key associated with this key type.
    pub const fn data_len(&self) -> usize {
        match self {
            Self::ED25519 => 32,
            Self::SECP256K1 => 64,
        }
    }
}

impl Display for KeyType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.into_near_keytype())
    }
}

impl FromStr for KeyType {
    type Err = Error;

    fn from_str(value: &str) -> Result<Self, Self::Err> {
        let key_type = near_crypto::KeyType::from_str(value)
            .map_err(|e| ErrorKind::DataConversion.custom(e))?;

        Ok(Self::from_near_keytype(key_type))
    }
}

impl TryFrom<u8> for KeyType {
    type Error = Error;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(Self::ED25519),
            1 => Ok(Self::SECP256K1),
            unknown_key_type => Err(ErrorKind::DataConversion
                .custom(format!("Unknown key type provided: {unknown_key_type}"))),
        }
    }
}

impl From<PublicKey> for near_crypto::PublicKey {
    fn from(pk: PublicKey) -> Self {
        pk.0
    }
}

/// Public key of an account on chain. Usually created along with a [`SecretKey`]
/// to form a keypair associated to the account.
#[derive(Debug, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Serialize, Deserialize)]
pub struct PublicKey(pub(crate) near_crypto::PublicKey);

#[allow(clippy::len_without_is_empty)] // PublicKey is guaranteed to never be empty due to KeyType restrictions.
impl PublicKey {
    /// Create an empty `PublicKey` with the given [`KeyType`]. This is a zero-ed out public key with the
    /// length of the bytes determined by the associated key type.
    pub fn empty(key_type: KeyType) -> Self {
        Self(near_crypto::PublicKey::empty(key_type.into_near_keytype()))
    }

    /// Create a new [`PublicKey`] from the given bytes. This will return an error if the bytes are not in the
    /// correct format. Expected to have key type be the first byte encoded, with the remaining bytes being the
    /// key data.
    pub fn try_from_parts(key_type: KeyType, bytes: &[u8]) -> Result<Self> {
        let mut buf = Vec::new();
        buf.push(key_type as u8);
        buf.extend(bytes);
        Ok(Self(near_crypto::PublicKey::try_from_slice(&buf).map_err(
            |e| {
                ErrorKind::DataConversion
                    .full(format!("Invalid key data for key type: {key_type}"), e)
            },
        )?))
    }

    #[cfg(feature = "interop_sdk")]
    fn try_from_bytes(bytes: &[u8]) -> Result<Self> {
        let key_type = KeyType::try_from(bytes[0])?;
        Ok(Self(
            near_crypto::PublicKey::try_from_slice(bytes).map_err(|e| {
                ErrorKind::DataConversion
                    .full(format!("Invalid key data for key type: {key_type}"), e)
            })?,
        ))
    }

    /// Get the number of bytes this key uses. This will differ depending on the [`KeyType`]. i.e. for
    /// ED25519 keys, this will return 32 + 1, while for SECP256K1 keys, this will return 64 + 1. The +1
    /// is used to store the key type, and will appear at the start of the serialized key.
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Get the [`KeyType`] of the public key.
    pub fn key_type(&self) -> KeyType {
        KeyType::from_near_keytype(self.0.key_type())
    }

    /// Get the key data of the public key. This is serialized bytes of the public key. This will not
    /// include the key type, and will only contain the raw key data.
    pub fn key_data(&self) -> &[u8] {
        self.0.key_data()
    }
}

impl Display for PublicKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl FromStr for PublicKey {
    type Err = Error;

    fn from_str(value: &str) -> Result<Self, Self::Err> {
        let pk = near_crypto::PublicKey::from_str(value)
            .map_err(|e| ErrorKind::DataConversion.custom(e))?;

        Ok(Self(pk))
    }
}

impl BorshSerialize for PublicKey {
    fn serialize<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        // NOTE: sdk::PublicKey requires that we serialize the length of the key first, then the key itself.
        // Casted usize to u32 since the length in WASM is only 4 bytes long.
        BorshSerialize::serialize(&(self.len() as u32), writer)?;
        // Serialize key type and key data:
        BorshSerialize::serialize(&self.0, writer)
    }
}

impl BorshDeserialize for PublicKey {
    fn deserialize_reader<R: io::Read>(reader: &mut R) -> io::Result<Self> {
        let len: u32 = BorshDeserialize::deserialize_reader(reader)?;
        let pk: near_crypto::PublicKey = BorshDeserialize::deserialize_reader(reader)?;

        // Check that the length of the key matches the length we read from the buffer:
        if pk.len() != len as usize {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                format!(
                    "Key length of {} does not match length of {} read from buffer",
                    pk.len(),
                    len
                ),
            ));
        }
        Ok(Self(pk))
    }
}

/// Secret key of an account on chain. Usually created along with a [`PublicKey`]
/// to form a keypair associated to the account. To generate a new keypair, use
/// one of the creation methods found here, such as [`SecretKey::from_seed`]
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct SecretKey(pub(crate) near_crypto::SecretKey);

impl SecretKey {
    /// Get the [`KeyType`] of the secret key.
    pub fn key_type(&self) -> KeyType {
        KeyType::from_near_keytype(self.0.key_type())
    }

    /// Get the [`PublicKey`] associated to this secret key.
    pub fn public_key(&self) -> PublicKey {
        PublicKey(self.0.public_key())
    }

    /// Generate a new secret key provided the [`KeyType`] and seed.
    pub fn from_seed(key_type: KeyType, seed: &str) -> Self {
        let key_type = key_type.into_near_keytype();
        Self(near_crypto::SecretKey::from_seed(key_type, seed))
    }

    /// Generate a new secret key provided the [`KeyType`]. This will use OS provided entropy
    /// to generate the key.
    pub fn from_random(key_type: KeyType) -> Self {
        let key_type = key_type.into_near_keytype();
        Self(near_crypto::SecretKey::from_random(key_type))
    }
}

impl Display for SecretKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "{}", self.0)
    }
}

impl FromStr for SecretKey {
    type Err = Error;

    fn from_str(value: &str) -> Result<Self, Self::Err> {
        let sk = near_crypto::SecretKey::from_str(value)
            .map_err(|e| ErrorKind::DataConversion.custom(e))?;

        Ok(Self(sk))
    }
}

#[derive(Clone)]
pub struct InMemorySigner {
    pub(crate) account_id: AccountId,
    pub(crate) secret_key: SecretKey,
}

impl InMemorySigner {
    pub fn from_secret_key(account_id: AccountId, secret_key: SecretKey) -> Self {
        Self {
            account_id,
            secret_key,
        }
    }

    pub fn from_file(path: &Path) -> Result<Self> {
        let signer = near_crypto::InMemorySigner::from_file(path)
            .map_err(|err| ErrorKind::Io.custom(err))?;
        Ok(Self::from_secret_key(
            signer.account_id,
            SecretKey(signer.secret_key),
        ))
    }

    pub(crate) fn inner(&self) -> near_crypto::InMemorySigner {
        near_crypto::InMemorySigner::from_secret_key(
            self.account_id.clone(),
            self.secret_key.0.clone(),
        )
    }
}

// type taken from near_primitives::hash::CryptoHash.
/// CryptoHash is type for storing the hash of a specific block.
#[derive(Copy, Clone, Default, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct CryptoHash(pub [u8; 32]);

impl CryptoHash {
    pub(crate) fn hash_bytes(bytes: &[u8]) -> Self {
        let hash = sha2::Sha256::digest(bytes).into();
        Self(hash)
    }
}

impl FromStr for CryptoHash {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bytes = from_base58(s).map_err(|e| ErrorKind::DataConversion.custom(e))?;
        Self::try_from(bytes)
    }
}

impl TryFrom<&[u8]> for CryptoHash {
    type Error = Error;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        if bytes.len() != 32 {
            return Err(Error::message(
                ErrorKind::DataConversion,
                format!(
                    "incorrect hash length (expected 32, but {} was given)",
                    bytes.len()
                ),
            ));
        }
        let mut buf = [0; 32];
        buf.copy_from_slice(bytes);
        Ok(Self(buf))
    }
}

impl TryFrom<Vec<u8>> for CryptoHash {
    type Error = Error;

    fn try_from(v: Vec<u8>) -> Result<Self, Self::Error> {
        <Self as TryFrom<&[u8]>>::try_from(v.as_ref())
    }
}

impl Debug for CryptoHash {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self)
    }
}

impl Display for CryptoHash {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        Display::fmt(&bs58::encode(self.0).into_string(), f)
    }
}

impl From<near_primitives::hash::CryptoHash> for CryptoHash {
    fn from(hash: near_primitives::hash::CryptoHash) -> Self {
        Self(hash.0)
    }
}

/// Access key provides limited access to an account. Each access key belongs to some account and
/// is identified by a unique (within the account) public key. One account may have large number of
/// access keys. Access keys allow to act on behalf of the account by restricting transactions
/// that can be issued.
#[derive(Clone, Debug)]
pub struct AccessKey {
    /// The nonce for this access key.
    /// NOTE: In some cases the access key needs to be recreated. If the new access key reuses the
    /// same public key, the nonce of the new access key should be equal to the nonce of the old
    /// access key. It's required to avoid replaying old transactions again.
    pub nonce: Nonce,

    /// Defines permissions for this access key.
    pub permission: AccessKeyPermission,
}

impl AccessKey {
    pub fn full_access() -> Self {
        Self {
            nonce: 0,
            permission: AccessKeyPermission::FullAccess,
        }
    }

    pub fn function_call_access(
        receiver_id: &AccountId,
        method_names: &[&str],
        allowance: Option<NearToken>,
    ) -> Self {
        Self {
            nonce: 0,
            permission: AccessKeyPermission::FunctionCall(FunctionCallPermission {
                receiver_id: receiver_id.clone().into(),
                method_names: method_names.iter().map(|s| s.to_string()).collect(),
                allowance,
            }),
        }
    }
}

/// Similar to an [`AccessKey`], but also has the [`PublicKey`] associated with it.
#[derive(Clone, Debug)]
pub struct AccessKeyInfo {
    pub public_key: PublicKey,
    pub access_key: AccessKey,
}

impl From<near_primitives::views::AccessKeyInfoView> for AccessKeyInfo {
    fn from(view: near_primitives::views::AccessKeyInfoView) -> Self {
        Self {
            public_key: PublicKey(view.public_key),
            access_key: view.access_key.into(),
        }
    }
}

/// Defines permissions for AccessKey
#[derive(Clone, Debug)]
pub enum AccessKeyPermission {
    FunctionCall(FunctionCallPermission),

    /// Grants full access to the account.
    /// NOTE: It's used to replace account-level public keys.
    FullAccess,
}

/// Grants limited permission to make transactions with FunctionCallActions
/// The permission can limit the allowed balance to be spent on the prepaid gas.
/// It also restrict the account ID of the receiver for this function call.
/// It also can restrict the method name for the allowed function calls.
#[derive(Clone, Debug)]
pub struct FunctionCallPermission {
    /// Allowance is a balance limit to use by this access key to pay for function call gas and
    /// transaction fees. When this access key is used, both account balance and the allowance is
    /// decreased by the same value.
    /// `None` means unlimited allowance.
    /// NOTE: To change or increase the allowance, the old access key needs to be deleted and a new
    /// access key should be created.
    pub allowance: Option<NearToken>,

    // This isn't an AccountId because already existing records in testnet genesis have invalid
    // values for this field (see: https://github.com/near/nearcore/pull/4621#issuecomment-892099860)
    // we accommodate those by using a string, allowing us to read and parse genesis.
    /// The access key only allows transactions with the given receiver's account id.
    pub receiver_id: String,

    /// A list of method names that can be used. The access key only allows transactions with the
    /// function call of one of the given method names.
    /// Empty list means any method name can be used.
    pub method_names: Vec<String>,
}

impl From<AccessKey> for near_primitives::account::AccessKey {
    fn from(access_key: AccessKey) -> Self {
        Self {
            nonce: access_key.nonce,
            permission: match access_key.permission {
                AccessKeyPermission::FunctionCall(function_call_permission) => {
                    near_primitives::account::AccessKeyPermission::FunctionCall(
                        near_primitives::account::FunctionCallPermission {
                            allowance: function_call_permission.allowance.map(|a| a.as_yoctonear()),
                            receiver_id: function_call_permission.receiver_id,
                            method_names: function_call_permission.method_names,
                        },
                    )
                }
                AccessKeyPermission::FullAccess => {
                    near_primitives::account::AccessKeyPermission::FullAccess
                }
            },
        }
    }
}

impl From<near_primitives::views::AccessKeyView> for AccessKey {
    fn from(access_key: near_primitives::views::AccessKeyView) -> Self {
        Self {
            nonce: access_key.nonce,
            permission: match access_key.permission {
                near_primitives::views::AccessKeyPermissionView::FunctionCall {
                    allowance,
                    receiver_id,
                    method_names,
                } => AccessKeyPermission::FunctionCall(FunctionCallPermission {
                    allowance: allowance.map(NearToken::from_yoctonear),
                    receiver_id,
                    method_names,
                }),
                near_primitives::views::AccessKeyPermissionView::FullAccess => {
                    AccessKeyPermission::FullAccess
                }
            },
        }
    }
}

/// Finality of a transaction or block in which transaction is included in. For more info
/// go to the [NEAR finality](https://docs.near.org/docs/concepts/transaction#finality) docs.
#[derive(Clone, Debug)]
#[non_exhaustive]
pub enum Finality {
    /// Optimistic finality. The latest block recorded on the node that responded to our query
    /// (<1 second delay after the transaction is submitted).
    Optimistic,
    /// Near-final finality. Similarly to `Final` finality, but delay should be roughly 1 second.
    DoomSlug,
    /// Final finality. The block that has been validated on at least 66% of the nodes in the
    /// network. (At max, should be 2 second delay after the transaction is submitted.)
    Final,
}

impl From<Finality> for near_primitives::types::BlockReference {
    fn from(value: Finality) -> Self {
        let value = match value {
            Finality::Optimistic => near_primitives::types::Finality::None,
            Finality::DoomSlug => near_primitives::types::Finality::DoomSlug,
            Finality::Final => near_primitives::types::Finality::Final,
        };
        value.into()
    }
}

'''
'''--- workspaces/src/types/sdk.rs ---
use std::convert::TryFrom;

use crate::error::{Error, ErrorKind};

use super::PublicKey;

impl TryFrom<near_sdk::PublicKey> for PublicKey {
    type Error = Error;

    fn try_from(pk: near_sdk::PublicKey) -> Result<Self, Self::Error> {
        Self::try_from_bytes(pk.as_bytes()).map_err(|e| {
            ErrorKind::DataConversion.full(
                "Could not convert sdk::PublicKey into workspaces::PublicKey",
                e,
            )
        })
    }
}

'''
'''--- workspaces/src/worker/impls.rs ---
use crate::network::{AllowDevAccountCreation, NetworkClient, NetworkInfo};
use crate::network::{Info, Sandbox};
use crate::operations::{CallTransaction, Function};
use crate::result::{ExecutionFinalResult, Result};
use crate::rpc::client::Client;
use crate::rpc::patch::{ImportContractTransaction, PatchTransaction};
use crate::rpc::query::{
    GasPrice, Query, QueryChunk, ViewAccessKey, ViewAccessKeyList, ViewAccount, ViewBlock,
    ViewCode, ViewFunction, ViewState,
};
use crate::types::{AccountId, InMemorySigner, NearToken, PublicKey};
use crate::worker::Worker;
use crate::{Account, Network};

#[cfg(feature = "experimental")]
use {
    near_chain_configs::{GenesisConfig, ProtocolConfigView},
    near_jsonrpc_primitives::types::{
        changes::{RpcStateChangesInBlockByTypeResponse, RpcStateChangesInBlockResponse},
        receipts::ReceiptReference,
        transactions::TransactionInfo,
    },
    near_primitives::{
        types::{BlockReference, MaybeBlockId},
        views::{
            validator_stake_view::ValidatorStakeView, FinalExecutionOutcomeWithReceiptView,
            ReceiptView, StateChangesRequestView,
        },
    },
};

impl<T: ?Sized> Clone for Worker<T> {
    fn clone(&self) -> Self {
        Self {
            workspace: self.workspace.clone(),
            tx_callbacks: self.tx_callbacks.clone(),
        }
    }
}

impl<T> AllowDevAccountCreation for Worker<T> where T: AllowDevAccountCreation {}

impl<T> NetworkInfo for Worker<T>
where
    T: NetworkInfo,
{
    fn info(&self) -> &Info {
        self.workspace.info()
    }
}

impl<T> Worker<T>
where
    T: NetworkClient + ?Sized,
{
    pub(crate) fn client(&self) -> &Client {
        self.workspace.client()
    }

    /// Call into a contract's view function. Returns a [`Query`] which allows us
    /// to specify further details like the arguments of the view call, or at what
    /// point in the chain we want to view.
    pub fn view(&self, contract_id: &AccountId, function: &str) -> Query<'_, ViewFunction> {
        self.view_by_function(contract_id, Function::new(function))
    }

    pub(crate) fn view_by_function(
        &self,
        contract_id: &AccountId,
        function: Function,
    ) -> Query<'_, ViewFunction> {
        Query::new(
            self.client(),
            ViewFunction {
                account_id: contract_id.clone(),
                function,
            },
        )
    }

    /// View the WASM code bytes of a contract on the network.
    pub fn view_code(&self, contract_id: &AccountId) -> Query<'_, ViewCode> {
        Query::new(
            self.client(),
            ViewCode {
                account_id: contract_id.clone(),
            },
        )
    }

    /// View the state of a account/contract on the network. This will return the internal
    /// state of the account in the form of a map of key-value pairs; where STATE contains
    /// info on a contract's internal data.
    pub fn view_state(&self, contract_id: &AccountId) -> Query<'_, ViewState> {
        Query::view_state(self.client(), contract_id)
    }

    /// View the block from the network. Supply additional parameters such as [`block_height`]
    /// or [`block_hash`] to get the block.
    ///
    /// [`block_height`]: Query::block_height
    /// [`block_hash`]: Query::block_hash
    pub fn view_block(&self) -> Query<'_, ViewBlock> {
        Query::new(self.client(), ViewBlock)
    }

    /// View the chunk from the network once awaited. Supply additional parameters such as
    /// [`block_hash_and_shard`], [`block_height_and_shard`] or [`chunk_hash`] to get the
    /// chunk at a specific reference point. If none of those are supplied, the default
    /// reference point will be used, which will be the latest block_hash with a shard_id
    /// of 0.
    ///
    /// [`block_hash_and_shard`]: QueryChunk::block_hash_and_shard
    /// [`block_height_and_shard`]: QueryChunk::block_height_and_shard
    /// [`chunk_hash`]: QueryChunk::chunk_hash
    pub fn view_chunk(&self) -> QueryChunk<'_> {
        QueryChunk::new(self.client())
    }

    /// Views the [`AccessKey`] of the account specified by [`AccountId`] associated with
    /// the [`PublicKey`]
    ///
    /// [`AccessKey`]: crate::types::AccessKey
    pub fn view_access_key(&self, id: &AccountId, pk: &PublicKey) -> Query<'_, ViewAccessKey> {
        Query::new(
            self.client(),
            ViewAccessKey {
                account_id: id.clone(),
                public_key: pk.clone(),
            },
        )
    }

    /// Views all the [`AccessKey`]s of the account specified by [`AccountId`]. This will
    /// return a list of [`AccessKey`]s along with the associated [`PublicKey`].
    ///
    /// [`AccessKey`]: crate::types::AccessKey
    pub fn view_access_keys(&self, id: &AccountId) -> Query<'_, ViewAccessKeyList> {
        Query::new(
            self.client(),
            ViewAccessKeyList {
                account_id: id.clone(),
            },
        )
    }

    /// View account details of a specific account on the network.
    pub fn view_account(&self, account_id: &AccountId) -> Query<'_, ViewAccount> {
        Query::new(
            self.client(),
            ViewAccount {
                account_id: account_id.clone(),
            },
        )
    }

    pub fn gas_price(&self) -> Query<'_, GasPrice> {
        Query::new(self.client(), GasPrice)
    }
}

impl<T> Worker<T>
where
    T: NetworkClient + Send + Sync + ?Sized,
{
    /// Transfer tokens from one account to another. The signer is the account
    /// that will be used to send from.
    pub async fn transfer_near(
        &self,
        signer: &InMemorySigner,
        receiver_id: &AccountId,
        amount_yocto: NearToken,
    ) -> Result<ExecutionFinalResult> {
        self.client()
            .transfer_near(signer, receiver_id, amount_yocto)
            .await
            .map(ExecutionFinalResult::from_view)
            .map_err(crate::error::Error::from)
    }

    /// Deletes an account from the network. The beneficiary will receive the balance
    /// of the account deleted.
    pub async fn delete_account(
        &self,
        account_id: &AccountId,
        signer: &InMemorySigner,
        beneficiary_id: &AccountId,
    ) -> Result<ExecutionFinalResult> {
        self.client()
            .delete_account(signer, account_id, beneficiary_id)
            .await
            .map(ExecutionFinalResult::from_view)
            .map_err(crate::error::Error::from)
    }
}

#[cfg(feature = "experimental")]
impl<T> Worker<T>
where
    T: NetworkClient + Send + Sync + ?Sized,
{
    /// Provides a list of changes in block associated with the given block reference.
    pub async fn changes_in_block(
        &self,
        block_reference: BlockReference,
    ) -> Result<RpcStateChangesInBlockByTypeResponse> {
        self.client().changes_in_block(block_reference).await
    }

    /// Provides a list of changes in block associated with the given block reference and state changes request.
    pub async fn changes(
        &self,
        block_reference: BlockReference,
        state_changes_request: StateChangesRequestView,
    ) -> Result<RpcStateChangesInBlockResponse> {
        self.client()
            .changes(block_reference, state_changes_request)
            .await
    }

    /// Provides a genesis config associated with the network being used.
    pub async fn genesis_config(&self) -> Result<GenesisConfig> {
        self.client().genesis_config().await
    }

    /// Provides a protocol config associated with the given block reference.
    pub async fn protocol_config(
        &self,
        block_reference: BlockReference,
    ) -> Result<ProtocolConfigView> {
        self.client().protocol_config(block_reference).await
    }

    /// Provides a receipt associated with the given receipt reference.
    pub async fn receipt(&self, receipt_reference: ReceiptReference) -> Result<ReceiptView> {
        self.client().receipt(receipt_reference).await
    }

    /// Returns the transaction status for a given transaction hash or signed transaction.
    pub async fn tx_status(
        &self,
        transaction_info: TransactionInfo,
    ) -> Result<FinalExecutionOutcomeWithReceiptView> {
        self.client().tx_status(transaction_info).await
    }

    /// Provides a list of validators ordered with respect to their stake.
    pub async fn validators_ordered(
        &self,
        block_id: MaybeBlockId,
    ) -> Result<Vec<ValidatorStakeView>> {
        self.client().validators_ordered(block_id).await
    }
}

impl<T> Worker<T>
where
    T: Network + 'static,
{
    /// Call into a contract's change function. Returns a [`CallTransaction`] object
    /// that we will make use to populate the rest of the call details. The [`signer`]
    /// will be used to sign the transaction.
    ///
    /// [`signer`]: crate::types::InMemorySigner
    pub fn call(
        &self,
        signer: &InMemorySigner,
        contract_id: &AccountId,
        function: &str,
    ) -> CallTransaction {
        CallTransaction::new(
            self.clone().coerce(),
            contract_id.to_owned(),
            signer.clone(),
            function,
        )
    }
}

impl Worker<Sandbox> {
    pub fn root_account(&self) -> Result<Account> {
        let signer = self.workspace.root_signer()?;
        Ok(Account::new(signer, self.clone().coerce()))
    }

    /// Import a contract from the the given network, and return us a [`ImportContractTransaction`]
    /// which allows to specify further details, such as being able to import contract data and
    /// how far back in time we wanna grab the contract.
    pub fn import_contract<'a>(
        &self,
        id: &'a AccountId,
        worker: &Worker<impl Network + 'static>,
    ) -> ImportContractTransaction<'a> {
        ImportContractTransaction::new(id, worker.clone().coerce(), self.clone())
    }

    /// Start patching the state of the account specified by the [`AccountId`]. This will create
    /// a [`PatchTransaction`] that will allow us to patch access keys, code, and contract state.
    /// This is similar to functions like [`Account::batch`] where we can perform multiple actions
    /// in one transaction.
    pub fn patch(&self, account_id: &AccountId) -> PatchTransaction {
        PatchTransaction::new(self, account_id.clone())
    }

    /// Patch state into the sandbox network, given a prefix key and value. This will allow us
    /// to set contract state that we have acquired in some manner, where we are able to test
    /// random cases that are hard to come up naturally as state evolves.
    pub async fn patch_state(
        &self,
        contract_id: &AccountId,
        key: &[u8],
        value: &[u8],
    ) -> Result<()> {
        self.workspace.patch_state(contract_id, key, value).await
    }

    /// Fast forward to a point in the future. The delta block height is supplied to tell the
    /// network to advanced a certain amount of blocks. This comes with the advantage only having
    /// to wait a fraction of the time it takes to produce the same number of blocks.
    ///
    /// Estimate as to how long it takes: if our delta_height crosses `X` epochs, then it would
    /// roughly take `X * 5` seconds for the fast forward request to be processed.
    ///
    /// Note: This is not to be confused with speeding up the current in-flight transactions;
    /// the state being forwarded in this case refers to time-related state (the block height, timestamp and epoch).
    pub async fn fast_forward(&self, delta_height: u64) -> Result<()> {
        self.workspace.fast_forward(delta_height).await
    }

    /// The port being used by RPC
    pub fn rpc_port(&self) -> Option<u16> {
        self.workspace.server.rpc_port()
    }

    /// Get the address the client is using to connect to the RPC of the network.
    pub fn rpc_addr(&self) -> String {
        self.workspace.server.rpc_addr()
    }
}

'''
'''--- workspaces/src/worker/mod.rs ---
mod impls;

use std::fmt;
use std::sync::Arc;

use crate::network::builder::NetworkBuilder;
use crate::network::{Betanet, Custom, Mainnet, Sandbox, Testnet};
use crate::types::gas_meter::GasHook;
use crate::{Network, Result};

/// The `Worker` type allows us to interact with any NEAR related networks, such
/// as mainnet and testnet. This controls where the environment the worker is
/// running on top of it. Refer to this for all network related actions such as
/// deploying a contract, or interacting with transactions.
pub struct Worker<T: ?Sized> {
    pub(crate) workspace: Arc<T>,
    pub(crate) tx_callbacks: Vec<GasHook>,
}

impl<T> Worker<T>
where
    T: Network,
{
    pub(crate) fn new(network: T) -> Self {
        Self {
            workspace: Arc::new(network),
            tx_callbacks: vec![],
        }
    }
}

impl<T: Network + 'static> Worker<T> {
    pub(crate) fn coerce(self) -> Worker<dyn Network> {
        Worker {
            workspace: self.workspace,
            tx_callbacks: self.tx_callbacks,
        }
    }
}

impl<T: fmt::Debug> fmt::Debug for Worker<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Worker")
            .field("workspace", &self.workspace)
            .finish()
    }
}

/// Spin up a new sandbox instance, and grab a [`Worker`] that interacts with it.
pub fn sandbox<'a>() -> NetworkBuilder<'a, Sandbox> {
    NetworkBuilder::new("sandbox")
}

/// Spin up a new sandbox instance, and grab a [`Worker`] that interacts with it.
pub async fn sandbox_with_version<'a>(version: &str) -> Result<Worker<Sandbox>> {
    let network_builder = NetworkBuilder::new("sandbox");
    let network = Sandbox::from_builder_with_version(network_builder, version).await?;
    Ok(Worker::new(network))
}

/// Connect to the [testnet](https://explorer.testnet.near.org/) network, and grab
/// a [`Worker`] that can interact with it.
pub fn testnet<'a>() -> NetworkBuilder<'a, Testnet> {
    NetworkBuilder::new("testnet")
}

/// Connect to the [testnet archival](https://near-nodes.io/intro/node-types#archival-node)
/// network, and grab a [`Worker`] that can interact with it.
pub fn testnet_archival<'a>() -> NetworkBuilder<'a, Testnet> {
    NetworkBuilder::new("testnet-archival").rpc_addr(crate::network::testnet::ARCHIVAL_URL)
}

/// Connect to the [mainnet](https://explorer.near.org/) network, and grab
/// a [`Worker`] that can interact with it.
pub fn mainnet<'a>() -> NetworkBuilder<'a, Mainnet> {
    NetworkBuilder::new("mainnet")
}

/// Connect to the [mainnet archival](https://near-nodes.io/intro/node-types#archival-node)
/// network, and grab a [`Worker`] that can interact with it.
pub fn mainnet_archival<'a>() -> NetworkBuilder<'a, Mainnet> {
    NetworkBuilder::new("mainnet-archival").rpc_addr(crate::network::mainnet::ARCHIVAL_URL)
}

/// Connect to the betanet network, and grab a [`Worker`] that can interact with it.
pub fn betanet<'a>() -> NetworkBuilder<'a, Betanet> {
    NetworkBuilder::new("betanet")
}

/// Connect to a custom network, and grab a [`Worker`] that can interact with it.
///
/// Note: the burden of ensuring the methods that are able to be called are left up to the user.
pub fn custom<'a>(rpc_url: &str) -> NetworkBuilder<'a, Custom> {
    NetworkBuilder::new("custom").rpc_addr(rpc_url)
}

/// Run a locally scoped task where a [`sandbox`] instanced [`Worker`] is supplied.
pub async fn with_sandbox<F, T>(task: F) -> Result<T::Output>
where
    F: Fn(Worker<Sandbox>) -> T + Send + Sync,
    T: core::future::Future + Send,
{
    Ok(task(sandbox().await?).await)
}

/// Run a locally scoped task where a [`testnet`] instanced [`Worker`] is supplied.
pub async fn with_testnet<F, T>(task: F) -> Result<T::Output>
where
    F: Fn(Worker<Testnet>) -> T + Send + Sync,
    T: core::future::Future + Send,
{
    Ok(task(testnet().await?).await)
}

/// Run a locally scoped task where a [`testnet_archival`] instanced [`Worker`] is supplied.
pub async fn with_testnet_archival<F, T>(task: F) -> Result<T::Output>
where
    F: Fn(Worker<Testnet>) -> T + Send + Sync,
    T: core::future::Future + Send,
{
    Ok(task(testnet_archival().await?).await)
}

/// Run a locally scoped task where a [`mainnet`] instanced [`Worker`] is supplied.
pub async fn with_mainnet<F, T>(task: F) -> Result<T::Output>
where
    F: Fn(Worker<Mainnet>) -> T + Send + Sync,
    T: core::future::Future + Send,
{
    Ok(task(mainnet().await?).await)
}

/// Run a locally scoped task where a [`mainnet_archival`] instanced [`Worker`] is supplied.
pub async fn with_mainnet_archival<F, T>(task: F) -> Result<T::Output>
where
    F: Fn(Worker<Mainnet>) -> T + Send + Sync,
    T: core::future::Future + Send,
{
    Ok(task(mainnet_archival().await?).await)
}

/// Run a locally scoped task where a [`betanet`] instanced [`Worker`] is supplied.
pub async fn with_betanet<F, T>(task: F) -> Result<T::Output>
where
    F: Fn(Worker<Betanet>) -> T + Send + Sync,
    T: core::future::Future + Send,
{
    Ok(task(betanet().await?).await)
}

#[allow(dead_code)]
pub async fn with_custom<F, T>(task: F, rpc_url: &str) -> Result<T::Output>
where
    F: Fn(Worker<Custom>) -> T + Send + Sync,
    T: core::future::Future + Send,
{
    Ok(task(custom(rpc_url).await?).await)
}

'''
'''--- workspaces/tests/account.rs ---
#![recursion_limit = "256"]
use near_token::NearToken;
use serde_json::{Map, Value};
use test_log::test;

use std::fs::File;
use std::path::Path;

#[test(tokio::test)]
async fn test_subaccount_creation() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let account = worker.dev_create_account().await?;

    let sub = account
        .create_subaccount("subaccount")
        .transact()
        .await?
        .into_result()?;

    let expect_id = format!("subaccount.{}", account.id());
    let actual_id = sub.id().to_string();

    assert_eq!(actual_id, expect_id);

    // Check if the stored credentials match with the subaccount created.
    let savedir = Path::new("../target/credentials");
    sub.store_credentials(savedir).await?;
    let creds = File::open(savedir.join(format!("{}.json", sub.id())))?;
    let contents: Map<String, Value> = serde_json::from_reader(creds)?;
    assert_eq!(
        contents.get("account_id"),
        Some(&Value::String(sub.id().to_string()))
    );

    Ok(())
}

#[test(tokio::test)]
async fn test_transfer_near() -> anyhow::Result<()> {
    const INITIAL_BALANCE: NearToken = NearToken::from_near(100);

    let worker = near_workspaces::sandbox().await?;
    let (alice, bob) = (
        worker.dev_create_account().await?,
        worker.dev_create_account().await?,
    );

    assert_eq!(alice.view_account().await?.balance, INITIAL_BALANCE);
    assert_eq!(bob.view_account().await?.balance, INITIAL_BALANCE);

    const SENT_AMOUNT: NearToken = NearToken::from_yoctonear(500_000_000);

    // transfer 500_000_000 token from alice to bob
    let _ = alice.transfer_near(bob.id(), SENT_AMOUNT).await?;

    // Assert the the tokens have been transferred.
    assert_eq!(
        bob.view_account().await?.balance,
        INITIAL_BALANCE.saturating_add(SENT_AMOUNT),
    );

    // We can only assert that the balance is less than the initial balance - sent amount because of the gas fees.
    assert!(alice.view_account().await?.balance <= INITIAL_BALANCE.saturating_sub(SENT_AMOUNT));

    Ok(())
}

#[test(tokio::test)]
async fn test_delete_account() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;

    let (alice, bob) = (
        worker.dev_create_account().await?,
        worker.dev_create_account().await?,
    );

    _ = alice.clone().delete_account(bob.id()).await?;

    // All sandbox accounts start with a balance of 100 NEAR tokens.
    // On account deletion, alice's balance is debited to bob as beneficiary.
    assert!(bob.view_account().await?.balance > NearToken::from_near(100));

    // Alice's account should be deleted.
    let res = alice.view_account().await;

    assert!(res.is_err());

    assert!(res
        .unwrap_err()
        .into_inner()
        .unwrap()
        .to_string()
        .contains(&format!("{} does not exist while viewing", alice.id())),);

    Ok(())
}

'''
'''--- workspaces/tests/batch_tx.rs ---
use near_workspaces::operations::Function;
use near_workspaces::types::NearToken;
use serde_json::json;
use test_log::test;

#[test(tokio::test)]
async fn test_batch_tx() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker
        .dev_deploy(include_bytes!("../../examples/res/status_message.wasm"))
        .await?;

    // Batch transaction with two `call`s into `set_status`. The second one
    // should override the first one.
    contract
        .batch()
        .call(
            Function::new("set_status")
                .args_json(json!({
                    "message": "hello_world",
                }))
                .deposit(NearToken::from_near(0)),
        )
        .call(Function::new("set_status").args_json(json!({
            "message": "world_hello",
        })))
        .transact()
        .await?
        .into_result()?;

    let status_msg: String = contract
        .call("get_status")
        .args_json(serde_json::json!({
            "account_id": contract.id(),
        }))
        .view()
        .await?
        .json()?;

    assert_eq!(status_msg, "world_hello");
    Ok(())
}

'''
'''--- workspaces/tests/cross_contract.rs ---
use near_workspaces::result::ExecutionFinalResult;
use near_workspaces::types::NearToken;
use near_workspaces::{AccountId, Contract};

/// The factory contract used in these tests can be found in
/// [near-sdk/examples/factory-contract](https://github.com/near/near-sdk-rs/tree/master/examples/factory-contract/high-level).
const FACTORY_CONTRACT: &[u8] =
    include_bytes!("../../examples/res/factory_contract_high_level.wasm");

/// Create a new contract account through a cross contract call with "deploy_status_message".
async fn cross_contract_create_contract(
    status_id: &AccountId,
    status_amt: &NearToken,
    contract: &Contract,
) -> anyhow::Result<ExecutionFinalResult> {
    contract
        .call("deploy_status_message")
        .args_json((status_id.clone(), status_amt))
        .deposit(NearToken::from_near(50))
        .max_gas()
        .transact()
        .await
        .map_err(Into::into)
}

#[tokio::test]
async fn test_cross_contract_create_contract() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker.dev_deploy(FACTORY_CONTRACT).await?;
    let status_amt = NearToken::from_near(35);

    // Expect to fail for trying to create a new contract account with too short of a
    // top level account name, such as purely just "status"
    let status_id: AccountId = "status".parse().unwrap();
    let outcome = cross_contract_create_contract(&status_id, &status_amt, &contract).await?;
    let failures = outcome.failures();
    assert!(
        failures.len() == 1,
        "Expected one receipt failure for creating too short of a TLA, but got {} failures",
        failures.len()
    );

    // Expect to succeed after calling into the contract with expected length for a
    // top level account.
    let status_id: AccountId = "status-top-level-account-long-name".parse().unwrap();
    let outcome = cross_contract_create_contract(&status_id, &status_amt, &contract).await?;
    let failures = outcome.failures();
    assert!(
        failures.is_empty(),
        "Expected no failures for creating a TLA, but got {} failures",
        failures.len(),
    );

    Ok(())
}

#[tokio::test]
async fn test_cross_contract_calls() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker.dev_deploy(FACTORY_CONTRACT).await?;
    let status_amt = NearToken::from_near(35);

    let status_id: AccountId = "status-top-level-account-long-name".parse().unwrap();
    cross_contract_create_contract(&status_id, &status_amt, &contract)
        .await?
        .into_result()?;

    let message = "hello world";
    let result = contract
        .call("complex_call")
        .args_json((status_id, message))
        .max_gas()
        .transact()
        .await?
        .json::<String>()?;
    assert_eq!(
        message, result,
        "Results from cross contract call do not match."
    );

    Ok(())
}

'''
'''--- workspaces/tests/deploy.rs ---
#![recursion_limit = "256"]
use serde::{Deserialize, Serialize};
use test_log::test;

use near_workspaces::network::{Sandbox, ValidatorKey};
use near_workspaces::{pick_unused_port, Worker};

const NFT_WASM_FILEPATH: &str = "../examples/res/non_fungible_token.wasm";
const EXPECTED_NFT_METADATA: &str = r#"{
  "spec": "nft-1.0.0",
  "name": "Example NEAR non-fungible token",
  "symbol": "EXAMPLE",
  "icon": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E",
  "base_uri": null,
  "reference": null,
  "reference_hash": null
}"#;

#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]
struct NftMetadata {
    spec: String,
    name: String,
    symbol: String,
    icon: String,
    base_uri: Option<String>,
    reference: Option<String>,
    reference_hash: Option<String>,
}

fn expected() -> NftMetadata {
    serde_json::from_str(EXPECTED_NFT_METADATA).unwrap()
}

async fn deploy_and_assert(worker: Worker<Sandbox>) -> anyhow::Result<()> {
    let wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    contract
        .call("new_default_meta")
        .args_json(serde_json::json!({
            "owner_id": contract.id()
        }))
        .transact()
        .await?
        .into_result()?;

    let actual: NftMetadata = contract.view("nft_metadata").await?.json()?;

    assert_eq!(actual, expected());
    Ok(())
}

#[test(tokio::test)]
async fn test_dev_deploy() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    deploy_and_assert(worker).await?;
    Ok(())
}

#[test(tokio::test)]
async fn test_manually_spawned_deploy() -> anyhow::Result<()> {
    let rpc_port = pick_unused_port().await?;
    let net_port = pick_unused_port().await?;
    let mut home_dir = std::env::temp_dir();
    home_dir.push(format!("test-sandbox-{}", rpc_port));

    // initialize chain data with supplied home dir
    let output = near_sandbox_utils::init(&home_dir)?
        .wait_with_output()
        .await
        .unwrap();
    tracing::info!(target: "workspaces-test", "sandbox-init: {:?}", output);

    let mut child = near_sandbox_utils::run(&home_dir, rpc_port, net_port)?;

    // connect to local sandbox node
    let worker = near_workspaces::sandbox()
        .rpc_addr(&format!("http://localhost:{}", rpc_port))
        .validator_key(ValidatorKey::HomeDir(home_dir))
        .await?;
    deploy_and_assert(worker).await?;

    child.kill().await?;
    Ok(())
}

'''
'''--- workspaces/tests/deploy_project.rs ---
#![cfg(feature = "unstable")]
#![recursion_limit = "256"]
use test_log::test;

#[test(tokio::test)]
async fn test_dev_deploy_project() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let wasm = near_workspaces::compile_project("./tests/test-contracts/status-message").await?;
    let contract = worker.dev_deploy(&wasm).await?;

    contract
        .call("set_status")
        .args_json(("foo",))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let res = contract
        .call("get_status")
        .args_json((contract.id(),))
        .view()
        .await?;
    assert_eq!(res.json::<String>()?, "foo");

    Ok(())
}

'''
'''--- workspaces/tests/gas_meter.rs ---
use near_workspaces::types::NearToken;
use serde_json::json;
use test_log::test;

use near_workspaces::operations::Function;
use near_workspaces::types::GasMeter;

#[test(tokio::test)]
async fn test_gas_meter_with_single_transaction() -> anyhow::Result<()> {
    let mut worker = near_workspaces::sandbox().await?;
    let gas_meter = GasMeter::now(&mut worker);
    let mut total_gas = 0;

    // analogous to: worker.dev_deploy(include_bytes!("*.wasm")).await?;
    let status_msg = {
        let (id, sk) = worker.dev_generate().await;
        let contract = worker
            .create_tla_and_deploy(
                id.clone(),
                sk,
                include_bytes!("../../examples/res/status_message.wasm"),
            )
            .await?;
        total_gas += contract.details.total_gas_burnt.as_gas();

        contract.into_result()?
    };

    // analogous to: worker.dev_create_account().await?;
    let account = {
        let (id, sk) = worker.dev_generate().await;
        let account = worker.create_tla(id.clone(), sk).await?;
        total_gas += account.details.total_gas_burnt.as_gas();

        account.into_result()?
    };

    let txn = account
        .call(status_msg.id(), "set_status")
        .args_json(serde_json::json!({
            "message": "hello world",
        }))
        .transact()
        .await?;
    total_gas += txn.total_gas_burnt.as_gas();

    assert_eq!(total_gas, gas_meter.elapsed().unwrap().as_gas());

    Ok(())
}

#[test(tokio::test)]
async fn test_gas_meter_with_multiple_transactions() -> anyhow::Result<()> {
    let mut worker = near_workspaces::sandbox().await?;
    let gas_meter = GasMeter::now(&mut worker);
    let mut total_gas = 0;

    // analogous to: worker.dev_deploy(include_bytes!("*.wasm")).await?;
    let status_msg = {
        let (id, sk) = worker.dev_generate().await;
        let contract = worker
            .create_tla_and_deploy(
                id.clone(),
                sk,
                include_bytes!("../../examples/res/status_message.wasm"),
            )
            .await?;
        total_gas += contract.details.total_gas_burnt.as_gas();

        contract.into_result()?
    };

    // analogous to: worker.dev_create_account().await?;
    let account = {
        let (id, sk) = worker.dev_generate().await;
        let account = worker.create_tla(id.clone(), sk).await?;
        total_gas += account.details.total_gas_burnt.as_gas();

        account.into_result()?
    };

    let txn = account
        .call(status_msg.id(), "set_status")
        .args_json(serde_json::json!({
            "message": "hello world",
        }))
        .transact()
        .await?;
    total_gas += txn.total_gas_burnt.as_gas();

    let txn = account
        .call(status_msg.id(), "set_status")
        .args_json(serde_json::json!({
            "message": "hello world",
        }))
        .transact()
        .await?;
    total_gas += txn.total_gas_burnt.as_gas();

    assert_eq!(total_gas, gas_meter.elapsed().unwrap().as_gas());

    Ok(())
}

#[test(tokio::test)]
async fn test_gas_meter_with_parallel_transactions() -> anyhow::Result<()> {
    let mut worker = near_workspaces::sandbox().await?;
    let gas_meter = GasMeter::now(&mut worker);
    let mut total_gas = 0;

    // analogous to: worker.dev_deploy(include_bytes!("*.wasm")).await?;
    let status_msg = {
        let (id, sk) = worker.dev_generate().await;
        let contract = worker
            .create_tla_and_deploy(
                id.clone(),
                sk,
                include_bytes!("../../examples/res/status_message.wasm"),
            )
            .await?;
        total_gas += contract.details.total_gas_burnt.as_gas();

        contract.into_result()?
    };

    // analogous to: worker.dev_create_account().await?;
    let account = {
        let (id, sk) = worker.dev_generate().await;
        let account = worker.create_tla(id.clone(), sk).await?;
        total_gas += account.details.total_gas_burnt.as_gas();

        account.into_result()?
    };

    let mut tasks = Vec::new();

    for _ in 0..10 {
        let account = account.clone();
        let status_msg = status_msg.clone();

        tasks.push(tokio::spawn(async move {
            let txn = account
                .call(status_msg.id(), "set_status")
                .args_json(serde_json::json!({
                    "message": "hello world",
                }))
                .transact()
                .await?;

            Ok::<_, anyhow::Error>(txn.total_gas_burnt)
        }));
    }

    for task in tasks {
        total_gas += task.await??.as_gas();
    }

    assert_eq!(total_gas, gas_meter.elapsed().unwrap().as_gas());

    Ok(())
}

#[test(tokio::test)]
async fn test_gas_meter_with_multiple_transactions_and_view() -> anyhow::Result<()> {
    let mut worker = near_workspaces::sandbox().await?;
    let gas_meter = GasMeter::now(&mut worker);
    let mut total_gas = 0;

    // analogous to: worker.dev_deploy(include_bytes!("*.wasm")).await?;
    let status_msg = {
        let (id, sk) = worker.dev_generate().await;
        let contract = worker
            .create_tla_and_deploy(
                id.clone(),
                sk,
                include_bytes!("../../examples/res/status_message.wasm"),
            )
            .await?;
        total_gas += contract.details.total_gas_burnt.as_gas();

        contract.into_result()?
    };

    // analogous to: worker.dev_create_account().await?;
    let account = {
        let (id, sk) = worker.dev_generate().await;
        let account = worker.create_tla(id.clone(), sk).await?;
        total_gas += account.details.total_gas_burnt.as_gas();

        account.into_result()?
    };

    let txn = account
        .call(status_msg.id(), "set_status")
        .args_json(serde_json::json!({
            "message": "hello world",
        }))
        .transact()
        .await?;
    total_gas += txn.total_gas_burnt.as_gas();

    let txn = account
        .call(status_msg.id(), "set_status")
        .args_json(serde_json::json!({
            "message": "hello world",
        }))
        .transact()
        .await?;
    total_gas += txn.total_gas_burnt.as_gas();

    assert_eq!(total_gas, gas_meter.elapsed().unwrap().as_gas());

    let _ = account
        .call(status_msg.id(), "get_status")
        .args_json(serde_json::json!({
            "account_id": account.id(),
        }))
        .view()
        .await?;

    assert_eq!(total_gas, gas_meter.elapsed().unwrap().as_gas());

    Ok(())
}

#[test(tokio::test)]
async fn test_gas_meter_batch_tx() -> anyhow::Result<()> {
    let mut worker = near_workspaces::sandbox().await?;
    let gas_meter = GasMeter::now(&mut worker);
    let mut total_gas = 0;

    // analogous to: worker.dev_deploy(include_bytes!("*.wasm")).await?;
    let contract = {
        let (id, sk) = worker.dev_generate().await;
        let contract = worker
            .create_tla_and_deploy(
                id.clone(),
                sk,
                include_bytes!("../../examples/res/status_message.wasm"),
            )
            .await?;
        total_gas += contract.details.total_gas_burnt.as_gas();

        contract.into_result()?
    };

    let txn = contract
        .batch()
        .call(
            Function::new("set_status")
                .args_json(json!({
                    "message": "hello_world",
                }))
                .deposit(NearToken::from_near(0)),
        )
        .call(Function::new("set_status").args_json(json!({
            "message": "world_hello",
        })))
        .transact()
        .await?;
    total_gas += txn.total_gas_burnt.as_gas();

    let txn = contract
        .batch()
        .call(
            Function::new("set_status")
                .args_json(json!({
                    "message": "hello_world",
                }))
                .deposit(NearToken::from_near(0)),
        )
        .call(Function::new("set_status").args_json(json!({
            "message": "world_hello",
        })))
        .transact()
        .await?;

    total_gas += txn.total_gas_burnt.as_gas();

    assert_eq!(total_gas, gas_meter.elapsed().unwrap().as_gas());

    Ok(())
}

#[test(tokio::test)]
async fn test_gas_meter_create_account_transaction() -> anyhow::Result<()> {
    let mut worker = near_workspaces::sandbox().await?;
    let gas_meter = GasMeter::now(&mut worker);
    let mut total_gas = 0;

    // analogous to: worker.dev_create_account().await?;
    let account = {
        let (id, sk) = worker.dev_generate().await;
        let account = worker.create_tla(id.clone(), sk).await?;
        total_gas += account.details.total_gas_burnt.as_gas();

        account.into_result()?
    };

    let sub = account.create_subaccount("subaccount").transact().await?;
    total_gas += sub.details.total_gas_burnt.as_gas();

    assert_eq!(total_gas, gas_meter.elapsed().unwrap().as_gas());

    Ok(())
}

#[test(tokio::test)]
async fn test_dropped_gas_meter() -> anyhow::Result<()> {
    let mut worker = near_workspaces::sandbox().await?;
    let gas_meter = GasMeter::now(&mut worker);
    drop(gas_meter);

    worker.dev_create_account().await?;

    Ok(())
}

'''
'''--- workspaces/tests/optional_args.rs ---
#![recursion_limit = "256"]
use near_gas::NearGas;
use near_workspaces::types::NearToken;
use near_workspaces::{Contract, DevNetwork, Worker};
use test_log::test;

async fn init(worker: &Worker<impl DevNetwork>) -> anyhow::Result<Contract> {
    let contract = worker
        .dev_deploy(include_bytes!("../../examples/res/fungible_token.wasm"))
        .await?;

    contract
        .call("new_default_meta")
        .args_json(serde_json::json!({
            "owner_id": contract.id(),
            "total_supply": NearToken::from_near(1_000_000_000),
        }))
        .transact()
        .await?
        .into_result()?;

    Ok(contract)
}

#[test(tokio::test)]
async fn test_empty_args_error() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = init(&worker).await?;

    let res = contract
        .call("storage_unregister")
        .max_gas()
        .deposit(NearToken::from_yoctonear(1))
        .transact()
        .await?
        .into_result();

    if let Some(execution_err) = res.err() {
        assert!(format!("{}", execution_err).contains("Failed to deserialize input from JSON"));
        assert!(
            execution_err.total_gas_burnt > NearGas::from_gas(0),
            "Gas is still burnt for transaction although inputs are incorrect"
        );
    } else {
        panic!("Expected execution to error out");
    }

    Ok(())
}

#[test(tokio::test)]
async fn test_optional_args_present() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = init(&worker).await?;

    let res = contract
        .call("storage_unregister")
        .args_json(serde_json::json!({
            "force": true
        }))
        .max_gas()
        .deposit(NearToken::from_yoctonear(1))
        .transact()
        .await?;
    assert!(res.json::<bool>()?);

    Ok(())
}

'''
'''--- workspaces/tests/parallel_transactions.rs ---
use std::{collections::VecDeque, task::Poll};

use serde_json::json;

const STATUS_MSG_CONTRACT: &[u8] = include_bytes!("../../examples/res/status_message.wasm");

#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_parallel() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker.dev_deploy(STATUS_MSG_CONTRACT).await?;
    let account = worker.dev_create_account().await?;

    let parallel_tasks = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]
        .iter()
        .map(|msg| {
            let id = contract.id().clone();
            let account = account.clone();

            tokio::spawn(async move {
                account
                    .call(&id, "set_status")
                    .args_json(json!({
                        "message": msg.to_string(),
                    }))
                    .transact()
                    .await?
                    .into_result()?;
                anyhow::Result::<()>::Ok(())
            })
        });
    futures::future::join_all(parallel_tasks).await;

    // Check the final set message. This should be random each time this test function is called:
    let final_set_msg = account
        .call(contract.id(), "get_status")
        .args_json(json!({ "account_id": account.id() }))
        .view()
        .await?
        .json::<String>()?;
    println!("Final set message: {:?}", final_set_msg);

    Ok(())
}

#[tokio::test]
async fn test_parallel_async() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker.dev_deploy(STATUS_MSG_CONTRACT).await?;
    let account = worker.dev_create_account().await?;

    // nonce of access key before any transactions occurred.
    let nonce_start = worker
        .view_access_key(account.id(), &account.secret_key().public_key())
        .await?
        .nonce;

    // Create a queue statuses we can check the status of later.
    let mut statuses = VecDeque::new();
    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for msg in messages {
        let status = account
            .call(contract.id(), "set_status")
            .args_json(json!({
                "message": msg,
            }))
            .transact_async()
            .await?;
        statuses.push_back(status);
    }

    // Retry checking the statuses of all transactions until the queue is empty
    // with all transactions completed.
    while let Some(status) = statuses.pop_front() {
        match status.status().await? {
            Poll::Ready(_) => (),
            Poll::Pending => statuses.push_back(status),
        }
    }

    // Check the final set message. This should be "j" due to the ordering of the queue.
    let final_set_msg = account
        .call(contract.id(), "get_status")
        .args_json(json!({ "account_id": account.id() }))
        .view()
        .await?
        .json::<String>()?;
    assert_eq!(final_set_msg, "j");

    let nonce_end = worker
        .view_access_key(account.id(), &account.secret_key().public_key())
        .await?
        .nonce;

    // The amount of transactions should equal the increase in nonce:
    assert!(nonce_end - nonce_start == messages.len() as u64);

    Ok(())
}

'''
'''--- workspaces/tests/patch_state.rs ---
// Required since `test_log` adds more recursion than the standard recursion limit of 128
#![recursion_limit = "256"]

use near_primitives::borsh::{self, BorshDeserialize, BorshSerialize};
use near_token::NearToken;
use serde_json::json;
use test_log::test;

use near_workspaces::types::{KeyType, SecretKey};
use near_workspaces::{AccessKey, AccountDetailsPatch, AccountId, Contract, DevNetwork, Worker};

const STATUS_MSG_WASM_FILEPATH: &str = "../examples/res/status_message.wasm";

#[derive(Clone, Eq, PartialEq, Debug, BorshDeserialize, BorshSerialize)]
#[borsh(crate = "near_primitives::borsh")]
struct Record {
    k: String,
    v: String,
}

#[derive(Clone, Eq, PartialEq, Debug, BorshDeserialize, BorshSerialize)]
#[borsh(crate = "near_primitives::borsh")]
struct StatusMessage {
    records: Vec<Record>,
}

async fn view_status_state(
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<(AccountId, StatusMessage)> {
    let wasm = std::fs::read(STATUS_MSG_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await.unwrap();

    contract
        .call("set_status")
        .args_json(json!({
            "message": "hello",
        }))
        .transact()
        .await?
        .into_result()?;

    let mut state_items = contract.view_state().await?;
    let state = state_items
        .remove(b"STATE".as_slice())
        .ok_or_else(|| anyhow::anyhow!("Could not retrieve STATE"))?;
    let status_msg: StatusMessage = StatusMessage::try_from_slice(&state)?;

    Ok((contract.id().clone(), status_msg))
}

#[test(tokio::test)]
async fn test_view_state() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (contract_id, status_msg) = view_status_state(&worker).await?;

    assert_eq!(
        status_msg,
        StatusMessage {
            records: vec![Record {
                k: contract_id.to_string(),
                v: "hello".to_string(),
            }]
        }
    );

    Ok(())
}

#[test(tokio::test)]
async fn test_patch_state() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (contract_id, mut status_msg) = view_status_state(&worker).await?;
    status_msg.records.push(Record {
        k: "alice.near".to_string(),
        v: "hello world".to_string(),
    });

    worker
        .patch_state(&contract_id, b"STATE", &borsh::to_vec(&status_msg)?)
        .await?;

    let status: String = worker
        .view(&contract_id, "get_status")
        .args_json(json!({
            "account_id": "alice.near",
        }))
        .await?
        .json()?;

    assert_eq!(status, "hello world".to_string());

    Ok(())
}

#[test(tokio::test)]
async fn test_patch() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (contract_id, mut status_msg) = view_status_state(&worker).await?;
    status_msg.records.push(Record {
        k: "alice.near".to_string(),
        v: "hello world".to_string(),
    });

    worker
        .patch(&contract_id)
        .state(b"STATE", &borsh::to_vec(&status_msg)?)
        .transact()
        .await?;

    let status: String = worker
        .view(&contract_id, "get_status")
        .args_json(json!({
            "account_id": "alice.near",
        }))
        .await?
        .json()?;

    assert_eq!(status, "hello world".to_string());

    Ok(())
}

#[test(tokio::test)]
async fn test_patch_full() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (contract_id, status_msg) = view_status_state(&worker).await?;
    let status_msg_acc = worker.view_account(&contract_id).await?;
    let status_msg_code = worker.view_code(&contract_id).await?;

    let bob_id: AccountId = "bob.test.near".parse()?;
    let sk = SecretKey::from_seed(KeyType::ED25519, "bob's test key");

    // Equivalent to worker.import_contract()
    worker
        .patch(&bob_id)
        .account(
            AccountDetailsPatch::default()
                .balance(NearToken::from_near(100))
                .locked(status_msg_acc.locked)
                .code_hash(status_msg_acc.code_hash)
                .storage_usage(status_msg_acc.storage_usage),
        )
        .access_key(sk.public_key(), AccessKey::full_access())
        .code(&status_msg_code)
        .state(b"STATE", &borsh::to_vec(&status_msg)?)
        .transact()
        .await?;

    let bob_status_msg_acc = Contract::from_secret_key(bob_id, sk, &worker);
    let msg: String = bob_status_msg_acc
        .view("get_status")
        .args_json(json!({
            "account_id": contract_id,
        }))
        .await?
        .json()?;

    // Check that a complete contract got imported over correctly. This should be return "hello"
    // from the original contract `set_status("hello")`
    assert_eq!(msg, "hello".to_string());

    Ok(())
}

#[tokio::test]
async fn test_patch_code_hash() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (contract_id, _) = view_status_state(&worker).await?;
    let status_msg_acc = worker.view_account(&contract_id).await?;
    let status_msg_code = worker.view_code(&contract_id).await?;

    let bob = worker.dev_create_account().await?;

    // Patching code bytes should also set the code hash, otherwise the node will crash
    // when we try to do anything with the contract.
    worker
        .patch(bob.id())
        .code(&status_msg_code)
        .transact()
        .await?;

    let code_hash = worker.view_account(bob.id()).await?.code_hash;
    assert_eq!(status_msg_acc.code_hash, code_hash);

    Ok(())
}

// account_from_current
#[tokio::test]
async fn test_patch_account_from_current() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;

    let bob = worker.dev_create_account().await?;

    const NEW_BALANCE: NearToken = NearToken::from_yoctonear(10_u128.pow(16));

    let f = |mut acc: near_workspaces::types::AccountDetails| {
        acc.balance = NEW_BALANCE;
        AccountDetailsPatch::from(acc)
    };
    worker
        .patch(bob.id())
        .account_from_current(f)
        .transact()
        .await?;

    let bob_acc = worker.view_account(bob.id()).await?;

    assert_eq!(bob_acc.balance, NEW_BALANCE);

    Ok(())
}

'''
'''--- workspaces/tests/query.rs ---
use near_workspaces::types::NearToken;
use near_workspaces::{network::Sandbox, Contract, Worker};

async fn init() -> anyhow::Result<(Worker<Sandbox>, Contract)> {
    let worker = near_workspaces::sandbox().await?;
    let status_msg = worker
        .dev_deploy(include_bytes!("../../examples/res/status_message.wasm"))
        .await?;

    Ok((worker, status_msg))
}

#[tokio::test]
async fn test_invalid_query() -> anyhow::Result<()> {
    let (_worker, contract) = init().await?;

    // incorrect method name;
    let result = contract.view("view_status").args_json(("some_id",)).await;
    let error =
        result.expect_err("expected error while calling invalid method `status_msg.view_status`");
    assert!(format!("{error:?}").contains("MethodNotFound"));

    // incorrect args:
    let result = contract
        .view("get_status")
        .args_json(serde_json::json!({
            "account_id": 10,
        }))
        .await;
    let error =
        result.expect_err("expected error while passing invalid args to `status_msg.get_status`");
    assert!(format!("{error:?}").contains("Failed to deserialize input from JSON."));

    // deposit supplied when not required:
    let result = contract
        .call("set_status")
        .args_json(("some message",))
        .deposit(NearToken::from_yoctonear(1))
        .transact()
        .await?
        .into_result();
    let error =
        result.expect_err("expected error while passing deposit to `status_msg.set_status`");
    assert!(format!("{error:?}").contains("Smart contract panicked: Method doesn't accept deposit"));

    Ok(())
}

'''
'''--- workspaces/tests/test-contracts/status-message/Cargo.toml ---
[package]
name = "test-contract-status-message"
version = "0.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "5.0.0-alpha.2"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]

'''
'''--- workspaces/tests/test-contracts/status-message/src/lib.rs ---
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen, AccountId};
use std::collections::HashMap;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
#[borsh(crate = "near_sdk::borsh")]
pub struct StatusMessage {
    records: HashMap<AccountId, String>,
}

#[near_bindgen]
impl StatusMessage {
    #[payable]
    pub fn set_status(&mut self, message: String) {
        let account_id = env::signer_account_id();
        log!("{} set_status with message {}", account_id, message);
        self.records.insert(account_id, message);
    }

    pub fn get_status(&self, account_id: AccountId) -> Option<String> {
        log!("get_status for account_id {}", account_id);
        self.records.get(&account_id).cloned()
    }
}

'''
'''--- workspaces/tests/test-contracts/type-serialize/Cargo.toml ---
[package]
name = "test-contract-type-serialization"
version = "0.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
bs58 = "0.5"
near-sdk = "5.0.0-alpha.2"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]

'''
'''--- workspaces/tests/test-contracts/type-serialize/build.sh ---
#!/bin/sh

cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/test_contract_type_serialization.wasm ./res/

'''
'''--- workspaces/tests/test-contracts/type-serialize/src/lib.rs ---
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::near_bindgen;
use near_sdk::{CurveType, PublicKey};

use std::convert::TryFrom;

#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "near_sdk::borsh")]
#[near_bindgen]
struct Contract {}

#[near_bindgen]
impl Contract {
    pub fn pass_pk_back_and_forth(&self, pk: PublicKey) -> PublicKey {
        let mut data = vec![CurveType::ED25519 as u8];
        data.extend(
            bs58::decode("6E8sCci9badyRkXb3JoRpBj5p8C6Tw41ELDZoiihKEtp")
                .into_vec()
                .expect("could not convert bs58 to vec"),
        );
        let pk_expected =
            PublicKey::try_from(data).expect("could not create public key from parts");

        assert_eq!(pk, pk_expected);
        pk
    }

    #[result_serializer(borsh)]
    pub fn pass_borsh_pk_back_and_forth(&self, #[serializer(borsh)] pk: PublicKey) -> PublicKey {
        let mut data = vec![CurveType::ED25519 as u8];
        data.extend(
            bs58::decode("6E8sCci9badyRkXb3JoRpBj5p8C6Tw41ELDZoiihKEtp")
                .into_vec()
                .expect("could not convert bs58 to vec"),
        );
        let pk_expected =
            PublicKey::try_from(data).expect("could not create public key from parts");

        assert_eq!(pk, pk_expected);
        pk
    }
}

'''
'''--- workspaces/tests/types.rs ---
use std::str::FromStr;

use near_primitives::borsh::{self, BorshDeserialize};

use near_workspaces::types::{KeyType, PublicKey, SecretKey};
use near_workspaces::AccountId;

fn default_workspaces_pubkey() -> anyhow::Result<PublicKey> {
    let data = bs58::decode("279Zpep9MBBg4nKsVmTQE7NbXZkWdxti6HS1yzhp8qnc1ExS7gU").into_vec()?;
    Ok(PublicKey::try_from_slice(data.as_slice())?)
}

#[test]
fn test_keypair_ed25519() -> anyhow::Result<()> {
    let pk_expected = "\"ed25519:DcA2MzgpJbrUATQLLceocVckhhAqrkingax4oJ9kZ847\"";
    let sk_expected = "\"ed25519:3KyUuch8pYP47krBq4DosFEVBMR5wDTMQ8AThzM8kAEcBQEpsPdYTZ2FPX5ZnSoLrerjwg66hwwJaW1wHzprd5k3\"";

    let sk = SecretKey::from_seed(KeyType::ED25519, "test");
    let pk = sk.public_key();
    assert_eq!(serde_json::to_string(&pk)?, pk_expected);
    assert_eq!(serde_json::to_string(&sk)?, sk_expected);
    assert_eq!(pk, serde_json::from_str(pk_expected)?);
    assert_eq!(sk, serde_json::from_str(sk_expected)?);

    Ok(())
}

#[test]
fn test_keypair_secp256k1() -> anyhow::Result<()> {
    let pk_expected = "\"secp256k1:5ftgm7wYK5gtVqq1kxMGy7gSudkrfYCbpsjL6sH1nwx2oj5NR2JktohjzB6fbEhhRERQpiwJcpwnQjxtoX3GS3cQ\"";
    let sk_expected = "\"secp256k1:X4ETFKtQkSGVoZEnkn7bZ3LyajJaK2b3eweXaKmynGx\"";

    let sk = SecretKey::from_seed(KeyType::SECP256K1, "test");
    let pk = sk.public_key();
    assert_eq!(serde_json::to_string(&pk)?, pk_expected);
    assert_eq!(serde_json::to_string(&sk)?, sk_expected);
    assert_eq!(pk, serde_json::from_str(pk_expected)?);
    assert_eq!(sk, serde_json::from_str(sk_expected)?);

    Ok(())
}

#[test]
fn test_pubkey_serialization() -> anyhow::Result<()> {
    for key_type in [KeyType::ED25519, KeyType::SECP256K1] {
        let sk = SecretKey::from_seed(key_type, "test");
        let pk = sk.public_key();
        let bytes = borsh::to_vec(&pk)?;

        // Borsh Deserialization should equate to the original public key:
        assert_eq!(PublicKey::try_from_slice(&bytes)?, pk);

        // invalid public key should error out on deserialization:
        assert!(PublicKey::try_from_slice(&[0]).is_err());
    }

    Ok(())
}

#[cfg(feature = "interop_sdk")]
#[tokio::test]
async fn test_pubkey_from_sdk_ser() -> anyhow::Result<()> {
    const TYPE_SER_BYTES: &[u8] =
        include_bytes!("test-contracts/type-serialize/res/test_contract_type_serialization.wasm");
    let worker = near_workspaces::sandbox().await?;
    let contract = worker.dev_deploy(TYPE_SER_BYTES).await?;

    // Test out serde serialization and deserialization for PublicKey
    let ws_pk = default_workspaces_pubkey()?;
    let sdk_pk: PublicKey = contract
        .call("pass_pk_back_and_forth")
        .args_json(serde_json::json!({ "pk": ws_pk }))
        .transact()
        .await?
        .json()?;
    assert_eq!(ws_pk, sdk_pk);

    // Test out borsh serialization and deserialization for PublicKey
    let sdk_pk: PublicKey = contract
        .call("pass_borsh_pk_back_and_forth")
        .args_borsh(&ws_pk)
        .transact()
        .await?
        .borsh()?;
    assert_eq!(ws_pk, sdk_pk);

    Ok(())
}

#[test]
fn test_pubkey_borsh_format_change() -> anyhow::Result<()> {
    let pk = default_workspaces_pubkey()?;
    assert_eq!(
        borsh::to_vec(&pk)?,
        bs58::decode("279Zpep9MBBg4nKsVmTQE7NbXZkWdxti6HS1yzhp8qnc1ExS7gU").into_vec()?
    );

    Ok(())
}

#[test]
fn test_valid_account_id() {
    let account_id = "testnet";
    assert!(
        AccountId::from_str(account_id).is_ok(),
        "Something changed underneath for testnet to not be a valid Account ID"
    );
}

'''