*GitHub Repository "here-wallet/data-proxy-server"*

'''--- docker-compose.yml ---
version: '3.7'
volumes:
  pg-data:

services:
  web:
    build:
      context: .
    volumes:
      - ./:/workdir/
    command: "python3 src/run_web.py"
    restart: always
    ports:
      - "6699:6699"
'''
'''--- requirements.txt ---
anyio==3.6.2
cachetools==5.2.0
click==8.1.3
fastapi==0.87.0
h11==0.14.0
idna==3.4
loguru==0.6.0
pydantic==1.10.2
sniffio==1.3.0
starlette==0.21.0
typing_extensions==4.4.0
uvicorn==0.20.0
sse-starlette==1.2.1
PyYAML==5.4.1
hyper==0.7.0
hyperframe==3.2.0
PyJWT==2.6.0
cryptography==38.0.4
base58==2.1.1
py-near==1.0.6
'''
'''--- src/app/__init__.py ---

'''
'''--- src/app/models.py ---
from typing import Optional, List

from pydantic import BaseModel

class ResponseInModel(BaseModel):
    data: Optional[str]

class SSEEventModel(BaseModel):
    near_account_id: Optional[str]
    data: Optional[str]

class SSEInModel(SSEEventModel):
    key: str

class SSEIEventsInModel(BaseModel):
    key: str
    events: List[SSEEventModel]

class RequestInModel(BaseModel):
    data: Optional[str]
    type: str = "login"
    topic_id: Optional[str]
    ttl: Optional[int]
    encrypted: bool = False

class RequestOutModel(BaseModel):
    data: Optional[str]
    encrypted: bool = False

'''
'''--- src/app/routes.py ---
import asyncio
import json

from fastapi import APIRouter, Depends, HTTPException, Header
from loguru import logger
from sse_starlette import EventSourceResponse
from starlette.requests import Request
from starlette.responses import HTMLResponse, RedirectResponse
from starlette.websockets import WebSocket, WebSocketDisconnect

from app.models import RequestInModel, ResponseInModel, RequestOutModel, SSEInModel, SSEIEventsInModel
from configs import APPLE_APP_SITE_ASSOCIATION, APY_KEY
from connection_manager import (
    get_connection_manager,
    ConnectionManager,
    get_push_manager,
)
from push_notification import ApnsPusher, Task

router = APIRouter()

@router.post("/{request_id}/request")
def put_request(
    request_id: str,
    d: RequestInModel,
    cm: ConnectionManager = Depends(get_connection_manager()),
):
    cm.put_request(request_id, d.dict(), d.topic_id)
    return {"status": "ok"}

@router.post("/{request_id}/response")
def put_response(
    request_id: str,
    d: ResponseInModel,
    cm: ConnectionManager = Depends(get_connection_manager()),
):
    cm.put_response(request_id, d.data)
    return {"status": "ok"}

@router.get("/{request_id}/response")
def get_response(
    request_id: str, cm: ConnectionManager = Depends(get_connection_manager())
):
    return {"data": cm.get_response(request_id)}

@router.get("/{request_id}/request", response_model=RequestOutModel)
def get_request(
    request_id: str, cm: ConnectionManager = Depends(get_connection_manager())
):
    return cm.get_request(request_id)

@router.websocket("/ws/{request_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    request_id: str,
    cm: ConnectionManager = Depends(get_connection_manager(True)),
):
    await cm.connect(request_id, websocket)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        cm.disconnect(request_id)

@router.delete("/{request_id}")
def delete_response(
    request_id: str, cm: ConnectionManager = Depends(get_connection_manager())
):
    cm.delete_request(request_id)
    return {"status": "ok"}

@router.get("/by_topic")
def get_request(
    topic_ids: str, cm: ConnectionManager = Depends(get_connection_manager())
):
    requests = cm.get_requests_by_topics(topic_ids.split(";"))
    return {"ids": requests}

@router.get("/apple-app-site-association")
def get_apple_app_clip():
    return HTMLResponse(
        content=APPLE_APP_SITE_ASSOCIATION,
        status_code=200,
        headers={
            "Content-Type": "application/octet-stream",
        },
    )

@router.post("/sse_event")
def put_response(
    d: SSEInModel,
    cm: ConnectionManager = Depends(get_connection_manager()),
):
    if d.key != APY_KEY:
        raise HTTPException(status_code=403, detail="Invalid key")
    cm.send_sse_for_user(d.near_account_id, d.data)
    return {"status": "ok"}

@router.post("/sse_events")
def put_response(
    data: SSEIEventsInModel,
    cm: ConnectionManager = Depends(get_connection_manager()),
):
    if data.key != APY_KEY:
        raise HTTPException(status_code=403, detail="Invalid key")
    for d in data.events:
        print("Send to user", d.near_account_id)
        cm.send_sse_for_user(d.near_account_id, d.data)
    return {"status": "ok"}

@router.post("/push_notification")
def push_notification(
    task: Task,
    authorization: str = Header(),
    ap: ApnsPusher = Depends(get_push_manager()),
):
    if authorization != APY_KEY:
        raise HTTPException(status_code=403, detail="Invalid key")
    ap.send_notification(task)
    return {"status": "ok"}

@router.get("/notificator_stream")
async def message_stream(
    request: Request,
    near_account_id: str,
    cm: ConnectionManager = Depends(get_connection_manager()),
):

    cm.connect_sse(near_account_id)
    logger.info(f"Connect SSE {near_account_id}")

    async def event_generator():
        while True:
            # If client closes connection, stop sending events
            if await request.is_disconnected():
                logger.info("Client disconnected")
                cm.disconnect_sse(near_account_id)
                break

            # Checks for new messages and return them to client if any
            for mes in cm.get_sse_for_user(near_account_id):
                if isinstance(mes, dict):
                    mes = json.dumps(mes)
                yield mes

            await asyncio.sleep(0.1)

    return EventSourceResponse(event_generator())

@router.get("/{request}")
def redirect_to_web(
    request: str,
):
    return RedirectResponse(url=f"https://my.herewallet.app/approve/{request}")

@router.get("/a/{linkdrop}")
def redirect_to_linkdrop(
    linkdrop: str,
):
    return RedirectResponse(url=f"https://phone.herewallet.app/a/{linkdrop}")
'''
'''--- src/app/trx_generator_routes.py ---
import json

from fastapi import APIRouter
from pynear import transactions
from pynear.constants import TGAS
from pynear.dapps.core import NEAR
from starlette.responses import RedirectResponse

from connection_manager import (
    actions_to_link,
)

router = APIRouter()

@router.get("/keypom/{password}")
def redirect_to_keypom(
    password: str,
):
    link = actions_to_link(
        [
            (
                "v1-3.keypom.near",
                [
                    transactions.create_function_call_action(
                        "claim",
                        json.dumps({"password": password}).encode("utf8"),
                        50 * TGAS,
                        0,
                    )
                ],
            )
        ]
    )
    return RedirectResponse(url=link)

@router.get("/send/{receiver_id}")
def redirect_to_send(receiver_id: str, amount: int = NEAR // 10):
    link = actions_to_link(
        [
            (
                receiver_id,
                [transactions.create_transfer_action(amount)],
            )
        ]
    )
    return RedirectResponse(url=link)

@router.get("/sent/{reciver_id}")
def redirect_to_sent(
    reciver_id: str,
    amount: int = NEAR // 10,
):
    link = actions_to_link(
        [
            (
                reciver_id,
                [transactions.create_transfer_action(amount)],
            )
        ]
    )
    return RedirectResponse(url=link)

@router.get("/test/sent2/{reciver_id}")
def redirect_to_sent(
    reciver_id: str,
    amount: int = NEAR // 10,
):
    link = actions_to_link(
        [
            (
                reciver_id,
                [
                    transactions.create_transfer_action(amount),
                    transactions.create_transfer_action(amount),
                ],
            )
        ]
    )
    return RedirectResponse(url=link)

@router.get("/test/3/{receiver_id}")
def redirect_to_sent(
    receiver_id: str,
    amount: int = NEAR // 10,
):
    link = actions_to_link(
        [
            (
                receiver_id,
                [
                    transactions.create_transfer_action(amount),
                ],
            ),
            (
                "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near",
                [
                    transactions.create_function_call_action(
                        "ft_transfer",
                        json.dumps(
                            {"receiver_id": receiver_id, "amount": "100"}
                        ).encode("utf8"),
                        25 * TGAS,
                        1,
                    ),
                ],
            ),
            (
                "{{signer_id}}",
                [
                    transactions.create_function_call_access_key_action(
                        "F5KkCsjjbiS2NXuJBEChYWWP1JLvRra7yKzLGbqPnPJG",
                        25 * TGAS,
                        "storage.herewallet.near",
                        [],
                    ),
                ],
            ),
        ]
    )
    return RedirectResponse(url=link)

'''
'''--- src/configs.py ---
import yaml

with open("configs/apple-app-site-association", "r") as f:
    APPLE_APP_SITE_ASSOCIATION = f.read()

with open("configs/apy_key", "r") as f:
    APY_KEY = f.read().replace("\n", "")

with open("configs/config.yaml", "r") as config_file:
    CONFIG = yaml.safe_load(config_file)

'''
'''--- src/connection_manager.py ---
import collections
import json
import re
from enum import Enum
from typing import Dict, List, Union, Tuple

import base58
from loguru import logger
from pyonear.transaction import Action
from starlette.requests import Request
from starlette.websockets import WebSocket
from pydantic import BaseModel

class ClientNotificationEnum(int, Enum):
    PUSH = 1
    RATES_UPDATE = 2
    REFRESH = 3
    REFRESH_BALANCE = 4

class ClientNotificationData(BaseModel):
    event_type: ClientNotificationEnum = ClientNotificationEnum.PUSH
    payload: Union[dict, None] = None

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.requests = dict()
        self.response = dict()
        self.requests_by_topic = dict()
        self.topic_by_request = dict()

        self._connected_sse_users = set()
        self.notifications: Dict[
            str, List[ClientNotificationData]
        ] = collections.defaultdict(list)

    async def connect(self, request_id, websocket):
        await websocket.accept()
        self.active_connections[request_id] = websocket

    def disconnect(self, request_id):
        self.active_connections.pop(request_id, None)

    def put_request(self, id_, request, topic_id):
        self.requests[id_] = request
        if topic_id:
            self.requests_by_topic[topic_id] = id_
            self.topic_by_request[id_] = topic_id
        if id_ in self.active_connections:
            self.active_connections[id_].send_json(request)

    def delete_request(self, id_):
        self.requests.pop(id_, None)
        self.response.pop(id_, None)
        if id_ in self.topic_by_request:
            self.requests_by_topic.pop(self.topic_by_request[id_], None)
            self.topic_by_request.pop(id_)
        if id_ in self.active_connections:
            self.active_connections[id_].send_json(
                {
                    "type": "delete",
                }
            )

    def put_response(self, id_, response):
        self.response[id_] = response
        if id_ in self.active_connections:
            self.active_connections[id_].send_json(
                {"type": "response", "data": response}
            )

    def get_request(self, id_):
        return self.requests.get(id_, None)

    def get_response(self, id_):
        return self.response.get(id_, None)

    def get_requests_by_topics(self, topic_ids: List[str]):
        res = []
        for tid in topic_ids:
            if tid in self.requests_by_topic:
                res.append(self.requests_by_topic[tid])
        return res

    def connect_sse(self, near_account_id):
        self._connected_sse_users.add(near_account_id)

    def disconnect_sse(self, near_account_id):
        if near_account_id in self._connected_sse_users:
            self._connected_sse_users.remove(near_account_id)
        self.notifications[near_account_id] = []

    def get_sse_for_user(self, near_account_id):
        return self.notifications.pop(near_account_id, [])

    def send_sse_for_user(self, near_account_id, data):
        if near_account_id is None:
            logger.info(
                "Sending SSE to all users {}".format(len(self._connected_sse_users))
            )
            for near_account_id in self._connected_sse_users:
                self.notifications[near_account_id].append(data)
            return

        if near_account_id not in self._connected_sse_users:
            return
        return self.notifications[near_account_id].append(data)

def get_connection_manager(websocket=False):
    async def app_conf(request: Request) -> ConnectionManager:
        return request.app.extra.get("connection_manager")

    async def app_conf_ws(ws: WebSocket) -> ConnectionManager:
        return ws.app.extra.get("connection_manager")

    if websocket:
        return app_conf_ws
    return app_conf

def get_push_manager(websocket=False):
    async def app_conf(request: Request) -> ConnectionManager:
        return request.app.extra.get("pusher")

    async def app_conf_ws(ws: WebSocket) -> ConnectionManager:
        return ws.app.extra.get("pusher")

    if websocket:
        return app_conf_ws
    return app_conf

def _camel_case(s):
    s = re.sub(r"(_|-)+", " ", s).title().replace(" ", "")
    return "".join([s[0].lower(), s[1:]])

def actions_to_link(transactions: List[Tuple[str, List[Action]]], network="mainnet"):
    rtransactions = []
    for tr in transactions:
        actions_args = []
        receiver_id, actions = tr
        for a in actions:
            params = {}
            for p, v in json.loads(a.to_json()).items():
                if p == "access_key":
                    if "FunctionCall" in v["permission"]:
                        for par, val in v["permission"]["FunctionCall"].items():
                            v["permission"][_camel_case(par)] = val
                        del v["permission"]["FunctionCall"]
                    else:
                        v["permission"] = "FullAccess"
                params[_camel_case(p)] = v
            actions_args.append(
                {
                    "type": type(a).__name__.replace("Action", ""),
                    "params": params,
                }
            )
        rtransactions.append(
            {
                "actions": actions_args,
                "receiverId": receiver_id,
            }
        )
    request = base58.b58encode(
        json.dumps(
            {
                "transactions": rtransactions,
                "network": network,
            }
        ).encode("utf8")
    ).decode("utf8")
    return f"https://my.herewallet.app/call/{request}"

'''
'''--- src/push_notification.py ---
import json
import time
from queue import Queue
from threading import Thread

import jwt
from hyper import HTTPConnection
from loguru import logger
from pydantic import BaseModel

class Task(BaseModel):
    device_token: str
    title: str
    body: str
    push_type: int = 1

class ApnsPusher:
    def __init__(
        self,
        key_id,
        key,
        team_id,
        topic,
        use_sandbox: bool = False,
    ):
        self.key_id = key_id
        with open(key, "r") as f:
            self.secret = f.read()
        self.team_id = team_id
        self.topic = topic
        self.use_sandbox = use_sandbox
        self._task_queue = Queue()

    def _get_request_headers(self, background=False):
        token = jwt.encode(
            {"iss": self.team_id, "iat": time.time()},
            self.secret,
            algorithm="ES256",
            headers={
                "alg": "ES256",
                "kid": self.key_id,
            },
        )

        resp = {
            "apns-expiration": "0",
            "apns-push-type": "alert",
            "apns-priority": "5",
            "apns-topic": self.topic,
            "authorization": "bearer {0}".format(token),
        }
        if background:
            resp["apns-push-type"] = "background"
        return resp

    def _send_push(
        self,
        device_token,
        title,
        body,
        push_type=0,
        payload: dict = None,
        badge=None,
    ):
        path = "/3/device/{0}".format(device_token)

        if self.use_sandbox:
            conn = HTTPConnection("api.development.push.apple.com:443")
        else:
            conn = HTTPConnection("api.push.apple.com:443")

        payload_data = {
            "aps": {
                "alert": {"title": title, "body": body},
                "sound": "default",
                "content-available": 1,
            },
            "push_type": push_type,
        }
        if payload:
            payload_data.update(payload)

        if badge is not None:
            payload_data["aps"]["badge"] = int(badge)

        payload = json.dumps(payload_data).encode("utf-8")

        conn.request("POST", path, payload, headers=self._get_request_headers())
        resp = conn.get_response()
        logger.info("Apn notification resp: " + str(resp.read()))

    def send_notification(self, task: Task):
        self._task_queue.put_nowait(task)

    def _task(self):
        while True:
            t: Task = self._task_queue.get()
            self._send_push(t.device_token, t.title, t.body, t.push_type)

    def run(self, n=10):
        tasks = []
        for i in range(n):
            t = Thread(target=self._task)
            t.start()
            tasks.append(t)

'''
'''--- src/run_web.py ---
#!/usr/bin/env python3

"""Main app file."""
import os

import uvicorn
from fastapi import FastAPI
from loguru import logger
from starlette.middleware.cors import CORSMiddleware

from configs import CONFIG
from connection_manager import ConnectionManager
from push_notification import ApnsPusher
from app.routes import router
from app.trx_generator_routes import router as trx_generator_routes

logger.add(
    "logs/info.log",
    level="INFO",
    rotation="3 days",
    retention="15 days",
    compression="zip",
    enqueue=True,
)

logger.add(
    "logs/debug.log",
    level="DEBUG",
    rotation="3 days",
    retention="15 days",
    compression="zip",
    enqueue=True,
)

logger.add(
    "logs/error.log",
    level="ERROR",
    rotation="3 days",
    retention="15 days",
    compression="zip",
    enqueue=True,
)

if __name__ == "__main__":

    async def on_startup(*args):
        logger.info("Backend init")

    async def on_shutdown(*args):
        pass

    pusher = ApnsPusher(**CONFIG["apple_apn"])
    pusher.run()
    app = FastAPI(
        title="HERE wallet backend",
        connection_manager=ConnectionManager(),
        pusher=pusher,
    )

    app.include_router(router, prefix=f"", tags=["web"])
    app.include_router(trx_generator_routes, prefix=f"/g", tags=["generator"])
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=os.getenv("PORT", 6699),
    )

'''