*GitHub Repository "lesterli/rust-practice"*

'''--- README.md ---
# Rust 语言学习笔记

* [精简手册](https://lester123.gitbook.io/rust/)
* [基础](./simple/README.md)
* [实战](./head-first/README.md)
* [FFI](./ffi/README.md)

'''
'''--- algorithms/README.md ---
# Algorithms

This is a collection of Rust implementations for various algorithm problems.

* `hacker-rant` - [HackerRank](https://www.hackerrank.com/)
'''
'''--- algorithms/hacker_rank/Cargo.toml ---
[package]
name = "hacker-rank"
version = "0.1.0"
authors = ["lesterli <fulfilself@gmail.com>"]
edition = "2018"
'''
'''--- algorithms/hacker_rank/src/flower_bouquets.rs ---
// A person can create a flower bouquet with either 3 roses (cost of bouquet = p) or 1 rose and 1 cosmos (cost = q) In an array of flowers.
// The person has to select contiguous set of flowers i.e. 2 or 3 to gain maximum cost.
// Input format: A string of 0(denotes rose) and 1(denotes cosmos). Output : Maximum cost.
// Examples:
// Input: p = 2, q = 3, s = 0001000 Output: 5
// Input: p = 2, q = 3, s = 001101011 Output: 9
fn flower_bouquets(p: i32, q: i32, s: &str) -> i32 {
    let mut dp = vec![0; s.len()];
    let mut str = String::new();

    for (i, ch) in s.chars().enumerate() {
        dp[i] = if i == 0 { 0 } else { dp[i - 1] };

        str.push(ch);

        if str.contains("000") {
            if i == 2 {
                dp[i] = p;
            } else {
                dp[i] = dp[i - 1].max(p + dp[i - 3]);
            }
        } else if str.contains("01") || str.contains("10") {
            if i == 1 {
                dp[i] = q;
            } else {
                dp[i] = dp[i - 1].max(q + dp[i - 2]);
            }
        }

        if i >= 2 {
            str.clear();
            str.push(ch);
        }
    }

    dp[s.len() - 1]
}

#[test]
fn test_flower_bouquets() {
    assert_eq!(flower_bouquets(2, 3, "0001000"), 5);
    assert_eq!(flower_bouquets(2, 3, "001101011"), 9);
    assert_eq!(flower_bouquets(10, 1, "0"), 0);
}
'''
'''--- algorithms/hacker_rank/src/lib.rs ---
pub mod strings;
pub mod flower_bouquets;
'''
'''--- algorithms/hacker_rank/src/strings.rs ---
fn super_reduced_string(s: &str) -> String {
    let mut stack = Vec::new();

    for c in s.chars() {
        if stack.last() == Some(&c) {
            stack.pop();
        } else {
            stack.push(c);
        }
    }

    if stack.is_empty() {
        "Empty String".to_string()
    } else {
        stack.into_iter().collect()
    }
}

fn camelcase(s: &str) -> i32 {
    let mut count = 1;
    for c in s.chars() {
        if c.is_uppercase() {
            count += 1;
        }
    }
    return count;
}

fn alternate(s: &str) -> i32 {
    let chars: Vec<char> = s.chars().collect();
    let mut max_length = 0;
    for c1 in 'a'..='z' {
        for c2 in (c1 as u8 + 1)..=b'z' {
            let a = c1 as char;
            let b = c2 as char;
            let mut last_char = None;
            let mut length = 0;
            for &c in &chars {
                if c != a && c != b {
                    continue;
                }
                if last_char == Some(c) {
                    length = 0;
                    break;
                }
                last_char = Some(c);
                length += 1;
            }
            if length > max_length {
                max_length = length;
            }
        }
    }
    max_length
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_super_reduced_string() {
        assert_eq!(super_reduced_string("aab"), "b");
        assert_eq!(super_reduced_string("abba"), "Empty String");
        assert_eq!(super_reduced_string("aaabccddd"), "abd");
        assert_eq!(super_reduced_string("abcdeedcba"), "Empty String");
        assert_eq!(super_reduced_string(""), "Empty String");
    }

    #[test]
    fn test_camelcase() {
        assert_eq!(camelcase("oneTwoThree"), 3);
        assert_eq!(camelcase("helloWorld"), 2);
        assert_eq!(camelcase("thisIsACamelCaseString"), 6);
    }

    #[test]
    fn test_alternate() {
        assert_eq!(alternate("abaacdabd"), 4);
        assert_eq!(alternate("beabeefeab"), 5);
    }
}

'''
'''--- ffi/README.md ---
# Rust FFI 

## c-call-rust

## rust-call-c

### 示例代码

* [在 C 中调用 Rust 函数]()
* [在 Rust 中调用 C 函数]()

'''
'''--- ffi/c-call-rust/Cargo.toml ---
[package]
name = "c-call-rust"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

[lib]
name = "c_call_rust"
crate-type = ["staticlib", "cdylib"]

'''
'''--- ffi/c-call-rust/c-src/main.c ---
#include "c_call_rust.h"
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>

int main(void) {
    call_from_rust();

    int my_array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int total = sum(my_array, 10);
    printf("The total is %d\n", total);
    return 0;
}  

'''
'''--- ffi/c-call-rust/src/c_call_rust.h ---
void call_from_rust();
int sum(const int* my_array, int length);
'''
'''--- ffi/c-call-rust/src/lib.rs ---
use std::ffi::CString;
use std::os::raw::c_char;
use std::os::raw::c_int;
use std::slice;

#[no_mangle]
pub extern "C" fn call_from_rust() {
    println!("This is a Rust function for C!");
}

// #[no_mangle]
// pub extern rust_printer(input: *const c_char) -> *mut c_char {
//     let mut hello = String::from("Hello World!");
//     let c_str_to_print = CString::new(hello).unwrap();
//     // 使用 as_ptr 将 CString 转化成 char 指针传给 C 函数
//     c_str_to_print.as_ptr()
// }

#[no_mangle]
pub extern fn sum(array: *const c_int, length: c_int) -> c_int {
    assert!(!array.is_null(), "Null pointer in sum()");
    unsafe {
        let array: &[c_int] = slice::from_raw_parts(array, length as usize);
        array.into_iter().sum()
    }
}

'''
'''--- ffi/example_01/Cargo.toml ---
[package]
name = "example_01"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

[lib]
name = "example_01"
crate-type = ["staticlib", "cdylib"]
'''
'''--- ffi/example_01/csrc/hello.c ---
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include "example_01.h"   

int main(void) {
  // basic string - char array
  char hello1[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
  printf("C hello 1: %s\n", hello1);
  char hello2[6] = "Hello";
  printf("C hello 2: %s\n", hello2);
  if (strcmp(hello1, hello2) ==0)
  {
    printf("hello 1 and 2 are equal\n");
  } else
  {
    printf("hello 1 and 2 are different\n");
  }
  
  // basic string - char pointer
  // char *str;
  // str = "hello";  // Stored in read only part of data segment
  // *(str+1) = 'i'; // Segmentation fault error:  trying to modify read only memory

  char hello_s[] = "hello"; // Stored in stack segment
  *hello_s = 'H';         // No problem: String is now Hello
  printf("new string in stack is %s\n", hello_s);
  
  int size = 6;
  char *hello_h = (char *)malloc(sizeof(char)*size); // Stored in heap segment
  *(hello_h+0) = 'h';  
  *(hello_h+1) = 'e';   
  *(hello_h+2) = 'l';
  *(hello_h+3) = 'l'; 
  *(hello_h+4) = 'o'; 
  *(hello_h+5) = '\0';       
  *(hello_h+0) = 'H';  // No problem: String is now Hello
  printf("new string in heap is: %s\n", hello_h);
  free(hello_h);

  char *c_str = "hello";  
  print_str(c_str); // Problem: still reachable
  c_str = change_str(c_str); // change the previous content
  printf("C side result: %s\n", c_str);
  free_str(c_str);

  // C generate strings
  char *c_hello = (char *)malloc(sizeof(char)*size);
  *(c_hello+0) = 'H';  
  *(c_hello+1) = 'e';   
  *(c_hello+2) = 'l';
  *(c_hello+3) = 'l'; 
  *(c_hello+4) = 'o'; 
  *(c_hello+5) = '\0';       
  printf("C side generate: %s\n", c_hello);
  print_str(c_hello);
  char *c_hello_world = change_str(c_hello);
  printf("C side result: %s\n", c_hello_world);
  free(c_hello);
  free_str(c_hello_world);

  char *c_ping = generate_str();
  printf("C side print: %s\n", c_ping);
  free_str(c_ping);
}
'''
'''--- ffi/example_01/src/example_01.h ---
void print_str(const char *str);
char *change_str(char str[]);
char *generate_str();
void free_str(char *);
'''
'''--- ffi/example_01/src/lib.rs ---
use std::os::raw::c_char;
use std::ffi::{CStr, CString};

#[no_mangle]
pub extern "C" fn print_str(s: *const c_char) {
    let slice = unsafe {
        assert!(!s.is_null());
        CStr::from_ptr(s)
    };
    let r_str = slice.to_str().unwrap();
    println!("Rust side print: {:?}", r_str);
}

#[no_mangle]
pub extern "C" fn change_str(s: *mut c_char) -> *mut c_char {
    let mut string = unsafe {
        assert!(!s.is_null());
        CStr::from_ptr(s).to_string_lossy().into_owned()
    };
    string.push_str(" World!");
    println!("Rust side change: {:?}", string);
    let c_str_changed = CString::new(string).unwrap();
    c_str_changed.into_raw()
}

#[no_mangle]
pub extern "C" fn generate_str() -> *mut c_char {
    let ping = String::from("ping");
    println!("Rust side generate: {:?}", ping);
    let c_str_ping = CString::new(ping).unwrap();
    c_str_ping.into_raw()
}

#[no_mangle]
pub extern "C" fn free_str(s: *mut c_char) {
    unsafe {
        if s.is_null() {
            return;
        }
        CString::from_raw(s)
    };
}

'''
'''--- ffi/example_02/Cargo.toml ---
[package]
name = "example_02"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = "0.7.3"

[lib]
name = "example_02"
crate-type = ["staticlib", "cdylib"]
'''
'''--- ffi/example_02/csrc/main.c ---
#include <stdio.h>
#include <float.h>
#include "example_02.h"

int main(void) {
  char version[] = "v1";
  printf("C call Rust Result: %d\n", handle_result(version));
  *(version+1) = '2';
  printf("C call Rust Result: %d\n", handle_result(version));
  char *n_version = NULL;
  printf("C call Rust Result error: %d\n", handle_result(n_version));

  float x = 2.0, y = 3.0;
  printf("C call Rust Option value: %d\n", handle_option(x, y));
  x = 2.0, y = 0.0;
  printf("C call Rust Option None: %d\n", handle_option(x, y));

  printf("C call Rust panic: %d\n", no_panic());
}
'''
'''--- ffi/example_02/src/example_02.h ---
int handle_result(const char *str);
int handle_option(float x, float y);
int no_panic();
'''
'''--- ffi/example_02/src/lib.rs ---
use std::os::raw::{c_char, c_float, c_void};
use std::ffi::CStr;
use std::panic::catch_unwind;

fn may_panic() {
    if rand::random() {
        panic!("panic happens");
    }
}

#[no_mangle]
pub unsafe extern "C" fn no_panic() -> i32 {
    let result = catch_unwind(may_panic);
    match result {
        Ok(_) => 0,
        Err(_) => -1,
    }
}

#[derive(Debug)]
enum Version { Version1, Version2 }

fn parse_version(header: &str) -> Result<Version, &'static str> {
    match header {
        "" => Err("invalid header length"),
        "v1" => Ok(Version::Version1),
        "v2" => Ok(Version::Version2),
        _ => Err("invalid version"),
    }
}

#[no_mangle]
pub unsafe extern "C" fn handle_result(s: *const c_char) -> i32 {
    if (s as *mut c_void).is_null() {
        return -1;
    }

    let vb = CStr::from_ptr(s).to_str().unwrap();
    let version = parse_version(vb);
    match version {
        Ok(_) => 0,
        Err(_) => -1,
    }
}

fn divide(numerator: f32, denominator: f32) -> Option<f32> {
    if denominator == 0.0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

#[no_mangle]
pub unsafe extern "C" fn handle_option(x: c_float, y: c_float) -> i32 {
    // The return value of the function is an option
    let result = divide(x, y);

    // Pattern match to retrieve the value
    match result {
        // The division was valid
        Some(_) => 0,
        // The division was invalid
        None    => -1,
    }
}

'''
'''--- ffi/example_03/Cargo.toml ---
[package]
name = "example_03"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

[lib]
crate-type = ["cdylib"]
'''
'''--- ffi/example_03/cbindgen.toml ---
language = "C"
no_includes = true

[export]
prefix = "capi_"

[enum]
rename_variants = "SnakeCase"
'''
'''--- ffi/example_03/csrc/main.c ---
#include <stdio.h>
#include <string.h>
#include "example_03.h"

int main(void) {
    Student *c_ptr = student_alice();
    printf("Student Num: %d\t Total: %d\t Name: %s\t\n", c_ptr->num, c_ptr->total, c_ptr->name);
    student_free(c_ptr);
    

    Student *stu = student_new();
    printf("Before fill data: Student Num: %d\t Total: %d\t Name: %s\t Scores: %.1f\t%.1f\t%.1f\n",
    stu->num, stu->total, stu->name, 
    stu->scores[0], stu->scores[1], stu->scores[2]);
    stu->num = 2;
    stu->total = 212;
    strcpy(stu->name, "Bob");
    stu->scores[0] = 60.6;
    stu->scores[1] = 70.7;
    stu->scores[2] = 80.8;
    printf("After fill data: Student Num: %d\t Total: %d\t Name: %s\t Scores: %.1f\t%.1f\t%.1f\n",
        stu->num, stu->total, stu->name, 
        stu->scores[0], stu->scores[1], stu->scores[2]);
    student_free(stu);

    return 0;
}

'''
'''--- ffi/example_03/example_03_header.h ---
typedef enum {
  boy,
  girl,
} capi_gender;

typedef struct {
  int num;
  int total;
  char name[20];
  float scores[3];
  capi_gender gender;
} capi_student;

capi_student *student_new(void);

capi_student *student_alice(void);

void student_free(capi_student *p_stu);

'''
'''--- ffi/example_03/src/example_03.h ---
typedef struct Student
{
    int num;
    int total;
    char name[20];
    float scores[3];
} Student;

Student *student_new();
Student *student_alice();
void student_free(Student *p_stu);

'''
'''--- ffi/example_03/src/lib.rs ---
// We have a lot of c-types in here, stop warning about their names!
#![allow(non_camel_case_types)]

use std::os::raw::{c_char, c_float, c_int};

#[repr(C)]
#[derive(Debug)]
pub enum gender {
    BOY,
    GIRL,
}

#[repr(C)]
#[derive(Debug)]
pub struct student {
    pub num: c_int,
    pub total: c_int,
    pub name: [c_char; 20],
    pub scores: [c_float; 3],
    pub gender: gender,
}

// Default constructor
impl Default for student {
    fn default() -> Self {
        student {
            num: 0 as c_int,
            total: 0 as c_int,
            name: [0 as c_char; 20],
            scores: [0.0 as c_float; 3],
            gender: gender::BOY,            
        }
    }
}

#[no_mangle]
pub extern "C" fn student_new() -> *mut student {
    let new_stu: student = Default::default();
    Box::into_raw(Box::new(new_stu))
}

#[no_mangle]
pub extern "C" fn student_alice() -> *mut student {
    let mut init_char_array: [c_char; 20] = [0; 20];
    for (dest, src) in init_char_array.iter_mut().zip(b"Alice\0".iter()) {
        *dest = *src as _;
    }
    let scores = [92.5, 87.5, 90.0];
    let alice = student {
        num: 1 as c_int,
        total: 280,
        name: init_char_array,
        scores,
        gender: gender::GIRL,
    };
    Box::into_raw(Box::new(alice))
}

#[no_mangle]
pub extern "C" fn student_free(p_stu: *mut student) {
    if !p_stu.is_null() {
        unsafe {
            println!("rust side print: {:?}", Box::from_raw(p_stu));
            Box::from_raw(p_stu)
        };
    }
}
'''
'''--- ffi/example_04/Cargo.toml ---
[package]
name = "example_04"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

'''
'''--- ffi/example_04/README.md ---
## example_04

在 Python 中调用 Rust 代码的示例。

* Python FFI 库有 [ctypes](https://docs.python.org/3/library/ctypes.html) 和 [cffi](https://cffi.readthedocs.io/en/latest/) 库

### 示例说明

* `src` 目录： Rust 源码
* `ffi` 目录： Rust 源码导出的 FFI 代码
* `python` 目录： Python 源码
* 本示例采用的是 `cffi` 库

### 运行步骤

1. 在 `ffi` 目录下，执行 `cargo build` 生成 Rust 源码的动态库(Linux平台，`libexample_04.so`)。
2. 在 `python` 目录下，运行 `python main.py`。

'''
'''--- ffi/example_04/ffi/Cargo.toml ---
[package]
name = "example_04"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
libc = "0.2"

[lib]
name = "example_04"
crate-type = ["cdylib"]
'''
'''--- ffi/example_04/ffi/cbindgen.toml ---
language = "C"
no_includes = true
'''
'''--- ffi/example_04/ffi/example_04_header.h ---
typedef struct c_tuple {
  unsigned int integer;
  bool boolean;
} c_tuple;

unsigned int fibonacci(unsigned int index);

unsigned int count_char(const char *s);

struct c_tuple handle_tuple(struct c_tuple tup);

int sum_of_even(const int *ptr, size_t len);

'''
'''--- ffi/example_04/ffi/src/lib.rs ---
use std::os::raw::{c_char, c_uint, c_int};
use std::ffi::CStr;
use std::convert::From;
use std::slice;
use libc::size_t;

#[no_mangle]
pub extern "C" fn fibonacci(index: c_uint) -> c_uint {
    if index <= 2 {
        1
    } else {
        fibonacci(index - 1) + fibonacci(index - 2)
    }
}

#[no_mangle]
pub extern "C" fn count_char(s: *const c_char) -> c_uint {
    let c_str = unsafe {
        assert!(!s.is_null());
        CStr::from_ptr(s)
    };
    let r_str = c_str.to_str().unwrap();
    r_str.chars().count() as u32
}

// A struct that can be passed between C and Rust
#[repr(C)]
pub struct c_tuple {
    integer: c_uint,
    boolean: bool,
}

impl From<c_tuple> for (u32, bool) {
    fn from(tup: c_tuple) -> (u32, bool) {
        (tup.integer, tup.boolean)
    }
}

impl From<(u32, bool)> for c_tuple {
    fn from(tup: (u32, bool)) -> c_tuple {
        c_tuple {
            integer: tup.0,
            boolean: tup.1,
        }
    }
}

#[no_mangle]
pub extern "C" fn handle_tuple(tup: c_tuple) -> c_tuple {
    let (integer, boolean) = tup.into();

    (integer + 1, !boolean).into()
}

#[no_mangle]
pub extern "C" fn sum_of_even(ptr: *const c_int, len: size_t) -> c_int {
    let slice = unsafe {
        assert!(!ptr.is_null());
        slice::from_raw_parts(ptr, len as usize)
    };

    let sum = slice.iter()
    .filter(|&&num| num % 2 == 0)
    .fold(0, |sum, &num| sum + num);
    sum as c_int
}
'''
'''--- ffi/example_04/python/main.py ---
# coding: utf-8

try:
    from cffi import FFI
except ImportError:
    print "pip install cffi"

ffi = FFI()

ffi.cdef("""
    typedef struct c_tuple {
        unsigned int integer;
        bool boolean;
    } c_tuple;
    unsigned int fibonacci(unsigned int index);
    unsigned int count_char(const char *s);
    struct c_tuple handle_tuple(struct c_tuple tup);
    int sum_of_even(const int *ptr, size_t len);
""")

lib = ffi.dlopen("../ffi/target/debug/libexample_04.so")

print "fibonacci(2) from Rust: ", lib.fibonacci(2)
print "fibonacci(4) from Rust: ", lib.fibonacci(4)
print "fibonacci(6) from Rust: ", lib.fibonacci(6)

print 'count_char("hello") from Rust: ', lib.count_char("hello")
print 'count_char("你好") from Rust: ', lib.count_char(u"你好".encode('utf-8'))

py_cdata = ffi.new('c_tuple *')
py_cdata.integer = 100
py_cdata.boolean = True
print('cdata = {0}, {1}'.format(py_cdata.integer, py_cdata.boolean))
new_py_cdata = lib.handle_tuple(py_cdata[0])
print('change cdata = {0}, {1}'.format(new_py_cdata.integer, new_py_cdata.boolean))

array = ffi.new("int[]", [1, 4, 9, 16, 25])
print 'sum_of_even from Rust: ', lib.sum_of_even(array, len(array))

'''
'''--- ffi/example_04/src/lib.rs ---
pub fn fibonacci(index: u32) -> u32 {
    if index <= 2 {
        1
    } else {
        fibonacci(index - 1) + fibonacci(index - 2)
    }
}

pub fn count_char(s: &str) -> u32 {
    s.chars().count() as u32
}

pub fn handle_tuple(pair: (u32, bool)) -> (u32, bool) {
    let (integer, boolean) = pair;

    (integer + 1, !boolean)
}

pub fn sum_of_even_fixed(array: [i32; 10]) -> i32 {
    array.iter()
    .filter(|&&num| num % 2 == 0)
    .fold(0, |sum, &num| sum + num)
}

pub fn sum_of_even(slice: &[i32]) -> i32 {
    slice.iter()
    .filter(|&&num| num % 2 == 0)
    .fold(0, |sum, &num| sum + num)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fibonacci() {
        assert_eq!(fibonacci(2), 1);
        assert_eq!(fibonacci(4), 3);
        assert_eq!(fibonacci(6), 8);
    }

    #[test]
    fn test_count_char() {
        let hello = "hello";
        assert_eq!(count_char(hello), 5);
        let hello_utf8 = "你好";
        assert_eq!(count_char(hello_utf8), 2);
    }

    #[test]
    fn test_handle_tuple() {
        let pair = (100, true);
        assert_eq!(handle_tuple(pair), (101, false));
    }

    #[test]
    fn test_sum_of_even() {
        let array = [1,2,3,4,5,6,7,8,9,10];
        assert_eq!(sum_of_even(&array), 30);
        assert_eq!(sum_of_even(&array[..5]), 6);
    }
}

'''
'''--- ffi/example_09/Cargo.toml ---
[package]
name = "example_09"
version = "0.1.0"
authors = ["ubuntu"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

'''
'''--- ffi/example_09/csrc/cfoo.c ---
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef struct Student
{
    int num;
    int total;
    char name[20];
    float scores[3];
} Student;

void print_data(Student *stu)
{
    printf("C side print: %d %s %d %.2f %.2f %.2f\n",
           stu->num, 
           stu->name, 
           stu->total, 
           stu->scores[0], 
           stu->scores[1], 
           stu->scores[2]);
}

void fill_data(Student *stu)
{
    stu->num = 2;
    stu->total = 100;
    strcpy(stu->name, "Bob");
    stu->scores[0] = 60.6;
    stu->scores[1] = 70.7;
    stu->scores[2] = 80.8;
}
'''
'''--- ffi/example_09/src/main.rs ---
use std::os::raw::{c_char, c_float, c_int};

#[repr(C)]
#[derive(Debug)]
pub struct CStudent {
    pub num: c_int,
    pub total: c_int,
    pub name: [c_char; 20],
    pub scores: [c_float; 3],
}

// Default constructor
impl Default for CStudent {
    fn default() -> Self {
        CStudent {
            num: 0 as c_int,
            total: 0 as c_int,
            name: [0 as c_char; 20],
            scores: [0.0 as c_float; 3],            
        }
    }
}

#[link(name = "cfoo")]
extern "C" {
    fn print_data(p_stu: *mut CStudent);
    fn fill_data(p_stu: *mut CStudent);
}

fn main() {
    // Initialization of allocated memory
    let new_stu: CStudent = Default::default();
    println!("rust side print new_stu: {:?}", new_stu);
    let box_new_stu = Box::new(new_stu);
    let p_stu = Box::into_raw(box_new_stu);

    unsafe {
        fill_data(p_stu);
        print_data(p_stu);
        //Box::from_raw(p_stu);
        println!("rust side print Bob: {:?}", Box::from_raw(p_stu));
    }
}

'''
'''--- ffi/example_10/Cargo.toml ---
[package]
name = "example_10"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

'''
'''--- ffi/example_10/csrc/compile.sh ---
gcc -fPIC -shared -o ../libsumsquare.so sumsquare.c
'''
'''--- ffi/example_10/csrc/sumsquare.c ---
#include<stdio.h>

typedef void (*SumSquareCB)(int result, void *user_data);

void sum_square_cb(int a, int b, SumSquareCB cb, void *user_data) {
	int result = a*a + b*b;
	cb(result, user_data);
}
'''
'''--- ffi/example_10/src/main.rs ---
use std::os::raw::{c_int, c_void};

pub type SumSquareCB = unsafe extern fn(c_int, *mut c_void);

#[link(name = "sumsquare")]
extern {
    pub fn sum_square_cb(a: c_int, b: c_int, cb: SumSquareCB, user_data: *mut c_void);
}

unsafe extern fn hook<F>(result: c_int, user_data: *mut c_void)
where
    F: FnMut(c_int),
{
    (*(user_data as *mut F))(result)
}

pub fn get_callback<F>(_closure: &F) -> SumSquareCB
where
    F: FnMut(c_int),
{
    hook::<F>
}

#[derive(Debug, Default, Clone, PartialEq)]
struct SumRecord {
    total: c_int,
    calls: usize,
}

fn main() {
    let mut record = SumRecord::default();
    
    unsafe {
        let mut closure = |result: c_int| {
            record.total += result;
            record.calls += 1;
        };
        let callback = get_callback(&closure);

        sum_square_cb(1, 2, callback, &mut closure as *mut _ as *mut c_void);

        sum_square_cb(3, 4, callback, &mut closure as *mut _ as *mut c_void);
    }

    println!("The sum is {:?}", record);
}

'''
'''--- ffi/nix/Cargo.toml ---
[package]
name = "nix"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
nix = "0.17.0"
'''
'''--- ffi/nix/src/main.c ---
#include <signal.h>
#include <unistd.h>

int main(void)
{
    pid_t child = fork();
    if (child)
    {
        sleep(5);
        kill(child, SIGKILL);
    }
    else
    {
        for (;;)
        // 循环直到被 kill 掉
        ;
    }

    return 0;
}
'''
'''--- ffi/nix/src/main.rs ---
// use nix::unistd::*;

// fn main() {
//     match fork() {
//         Ok(ForkResult::Parent { child }) => {
//             // 在父进程中
//             println!("Hello, I am parent thread: {}", getpid());
//         }
//         Ok(ForkResult::Child) => {
//             // 在子进程中
//             println!("Hello, I am child thread: {}", getpid());
//             println!("My parent thread: {}", getppid());            
//         }
//         Err(errno) => {
//             // fork 创建子进程失败
//             println!("Fork creation failed!");
//         }
//     }  
// }

use nix::sys::signal::*;
use nix::unistd::*;

fn main() {
    match fork().expect("fork failed") {
        ForkResult::Parent{ child } => {
            sleep(5);
            kill(child, SIGKILL).expect("kill failed");
        }
        ForkResult::Child => {
            // 直到被 kill 掉
            loop {}
        }
    }
}
'''
'''--- ffi/rust-call-c/Cargo.toml ---
[package]
name = "rust-call-c"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
libc = "0.2"
libloading = "0.6.2"
'''
'''--- ffi/rust-call-c/src/array.rs ---
use std::os::raw::c_int;

// 对 C 库中的 sum 函数进行 Rust 绑定：
extern "C" {
    fn sum(my_array: *const c_int, length: c_int) -> c_int;
}

fn main() {
    let numbers: [c_int; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    unsafe {
        let total = sum(numbers.as_ptr(), numbers.len() as c_int);
        println!("The total is {}", total);

        assert_eq!(total, numbers.iter().sum());
    }
}
'''
'''--- ffi/rust-call-c/src/ffi_array/c_utils.c ---
int sum(const int* my_array, int length) {
    int total = 0;

    for(int i = 0; i < length; i++) {
        total += my_array[i];
    }
    
    return total;
}
'''
'''--- ffi/rust-call-c/src/ffi_opaque/ffi_test.c ---
#include "ffi_test.h"

struct object {
  int info;
};

/**
 * Returns the size of the object struct.
 */
size_t sizeof_obj(void) {
  return sizeof(struct object);
}

/**
 * Allocates memory for a new object on the heap and returns a pointer to it.
 */
struct object* init(void) {
  struct object* obj = (struct object*)malloc(sizeof_obj());
  obj->info = 0;

  return obj;
}

/**
 * Frees the memory allocated for the object.
 */
void free_object(struct object* obj) {
  free(obj);
}

/**
 * Returns the version of the C API used by this library.
 */
int get_api_version(void) {
  return 0;
}

/**
 * Returns the value of the info field of the given object struct.
 */
int get_info(const struct object* obj) {
  return obj->info;
}

/**
 * Sets the info field of the object struct.
 */
void set_info(struct object* obj, int arg) {
  obj->info = arg;
}
'''
'''--- ffi/rust-call-c/src/ffi_opaque/ffi_test.h ---
#ifndef FFI_TEST_H
#define FFI_TEST_H

#include <stdlib.h>

struct object;

struct object* init(void);
void free_object(struct object*);
int get_api_version(void);
int get_info(const struct object*);
void set_info(struct object*, int);
size_t sizeof_obj(void);

#endif /* FFI_TEST_H */
'''
'''--- ffi/rust-call-c/src/layout.rs ---
use std::mem;

// 默认布局
struct DefaultStruct {
    first: i8,
    second: i16,
    third: i8
}

// 默认布局，对齐方式降低到 1
#[repr(packed(1))]
struct PackedStruct {
    first: i8,
    second: i16,
    third: i8
}

// C 布局
#[repr(C)]
struct CStruct {
    first: i8,
    second: i16,
    third: i8
}

// C 布局, 对齐方式升高到 4
#[repr(C, align(4))]
struct AlignedStruct {
    first: i8,
    second: i16,
    third: i8
}

// C 布局的元组结构体
#[repr(C)]
struct TupleStruct(i8, i16, i8);

// C 布局，重新调整字段的顺序可以缩小类型大小
#[repr(C)]
struct FieldStructOptimized {
    first: i8,
    third: i8,
	second: i16
}

// 联合类型的大小等于其字段类型的最大值
#[repr(C)]
union ExampleUnion {
    smaller: i8,
    larger: i16
}

fn main() {
    assert_eq!(mem::align_of::<DefaultStruct>(), 2);
    assert_eq!(mem::size_of::<CStruct>(), 6);
    assert_eq!(mem::align_of::<CStruct>(), 2);
    
    assert_eq!(mem::align_of::<PackedStruct>(), 1);
    assert_eq!(mem::align_of::<AlignedStruct>(), 4);
    
    assert_eq!(mem::size_of::<FieldStructOptimized>(), 4);
    
    assert_eq!(mem::size_of::<TupleStruct>(), 6);

    assert_eq!(mem::size_of::<ExampleUnion>(), 2);
}
'''
'''--- ffi/rust-call-c/src/main.rs ---
use std::ffi::CString;
use std::os::raw::c_char;

// 外部块
extern "C" {
    // 标准库<stdlib.h> abs函数
    #[link_name = "abs"]
    fn abs_in_rust(input: i32) -> i32;

    #[link_name = "printf"]
    fn printf_in_rust(input: *const c_char) -> i32;
}

fn abs_example() {
    unsafe {
        println!("abs(-1) is {}", abs_in_rust(-1));
    }
}

use std::str;

mod time;

fn time_example() {
    let mut v: Vec<u8> = vec![0; 80];
    let mut t = time::tm {
        tm_sec: 15,
        tm_min: 09,
        tm_hour: 18,
        tm_mday: 14,
        tm_mon: 04,
        tm_year: 120,
        tm_wday: 4,
        tm_yday: 135,
        tm_isdst: 0,
    };
    let format = b"%Y-%m-%d %H:%M:%S\0".as_ptr();
    unsafe {
        time::strftime_in_rust(v.as_mut_ptr(), 80, format, &mut t);

        let s = match str::from_utf8(v.as_slice()) {
            Ok(r) => r,
            Err(e) => panic!("Invalid UTF-8 sequence: {}", e),
        };
    
        println!("result: {}", s);
    }
}

fn main() {
    abs_example();
    time_example();
}
'''
'''--- ffi/rust-call-c/src/opaque.rs ---
use std::os::raw::c_int;

#[repr(C)]
pub struct OpaqueObject {
    _private: [u8; 0],
}

extern "C" {
    pub fn free_object(obj: *mut OpaqueObject);
    pub fn init() -> *mut OpaqueObject;
    pub fn get_api_version() -> c_int;
    pub fn get_info(obj: *const OpaqueObject) -> c_int;
    pub fn set_info(obj: *mut OpaqueObject, info: c_int);
}

fn main() {
    unsafe {
        let obj = init();
        println!("Original value: {}", get_info(obj));

        set_info(obj, 521);
        println!("New value: {}", get_info(obj));
    }
}
'''
'''--- ffi/rust-call-c/src/time.rs ---
use libc::{c_int, size_t};

#[repr(C)]
pub struct tm {
    pub tm_sec: c_int,
    pub tm_min: c_int,
    pub tm_hour: c_int,
    pub tm_mday: c_int,
    pub tm_mon: c_int,
    pub tm_year: c_int,
    pub tm_wday: c_int,
    pub tm_yday: c_int,
    pub tm_isdst: c_int,
}

extern {
    // 标准库<time.h> strftime函数的 Rust FFI 绑定
    #[link_name = "strftime"]
    pub fn strftime_in_rust(stra: *mut u8, maxsize: size_t, format: *const u8, timeptr: *mut tm) -> size_t;
}
'''
'''--- ffi/secp256k1-sys/Cargo.toml ---
[package]
name = "libsecp256k1-sys"
version = "0.1.0"
authors = ["ubuntu"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
name = "secp256k1"
path = "src/lib.rs"

[dependencies]

[build-dependencies]
bindgen = "0.55.1"

'''
'''--- ffi/secp256k1-sys/build.rs ---
use std::env;
use std::path::PathBuf;

fn main() {
    println!("cargo:rustc-link-lib=secp256k1");
    println!("cargo:rerun-if-changed=wrapper.h");

    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
'''
'''--- ffi/secp256k1-sys/include/secp256k1.h ---
#ifndef _SECP256K1_
# define _SECP256K1_

# ifdef __cplusplus
extern "C" {
# endif

#include <stddef.h>

/* These rules specify the order of arguments in API calls:
 *
 * 1. Context pointers go first, followed by output arguments, combined
 *    output/input arguments, and finally input-only arguments.
 * 2. Array lengths always immediately the follow the argument whose length
 *    they describe, even if this violates rule 1.
 * 3. Within the OUT/OUTIN/IN groups, pointers to data that is typically generated
 *    later go first. This means: signatures, public nonces, private nonces,
 *    messages, public keys, secret keys, tweaks.
 * 4. Arguments that are not data pointers go last, from more complex to less
 *    complex: function pointers, algorithm names, messages, void pointers,
 *    counts, flags, booleans.
 * 5. Opaque data pointers follow the function pointer they are to be passed to.
 */

/** Opaque data structure that holds context information (precomputed tables etc.).
 *
 *  The purpose of context structures is to cache large precomputed data tables
 *  that are expensive to construct, and also to maintain the randomization data
 *  for blinding.
 *
 *  Do not create a new context object for each operation, as construction is
 *  far slower than all other API calls (~100 times slower than an ECDSA
 *  verification).
 *
 *  A constructed context can safely be used from multiple threads
 *  simultaneously, but API call that take a non-const pointer to a context
 *  need exclusive access to it. In particular this is the case for
 *  secp256k1_context_destroy and secp256k1_context_randomize.
 *
 *  Regarding randomization, either do it once at creation time (in which case
 *  you do not need any locking for the other calls), or use a read-write lock.
 */
typedef struct secp256k1_context_struct secp256k1_context;

/** Opaque data structure that holds a parsed and valid public key.
 *
 *  The exact representation of data inside is implementation defined and not
 *  guaranteed to be portable between different platforms or versions. It is
 *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.
 *  If you need to convert to a format suitable for storage, transmission, or
 *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.
 */
typedef struct {
    unsigned char data[64];
} secp256k1_pubkey;

/** Opaque data structured that holds a parsed ECDSA signature.
 *
 *  The exact representation of data inside is implementation defined and not
 *  guaranteed to be portable between different platforms or versions. It is
 *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.
 *  If you need to convert to a format suitable for storage, transmission, or
 *  comparison, use the secp256k1_ecdsa_signature_serialize_* and
 *  secp256k1_ecdsa_signature_parse_* functions.
 */
typedef struct {
    unsigned char data[64];
} secp256k1_ecdsa_signature;

/** A pointer to a function to deterministically generate a nonce.
 *
 * Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.
 * Out:     nonce32:   pointer to a 32-byte array to be filled by the function.
 * In:      msg32:     the 32-byte message hash being verified (will not be NULL)
 *          key32:     pointer to a 32-byte secret key (will not be NULL)
 *          algo16:    pointer to a 16-byte array describing the signature
 *                     algorithm (will be NULL for ECDSA for compatibility).
 *          data:      Arbitrary data pointer that is passed through.
 *          attempt:   how many iterations we have tried to find a nonce.
 *                     This will almost always be 0, but different attempt values
 *                     are required to result in a different nonce.
 *
 * Except for test cases, this function should compute some cryptographic hash of
 * the message, the algorithm, the key and the attempt.
 */
typedef int (*secp256k1_nonce_function)(
    unsigned char *nonce32,
    const unsigned char *msg32,
    const unsigned char *key32,
    const unsigned char *algo16,
    void *data,
    unsigned int attempt
);

# if !defined(SECP256K1_GNUC_PREREQ)
#  if defined(__GNUC__)&&defined(__GNUC_MINOR__)
#   define SECP256K1_GNUC_PREREQ(_maj,_min) \
 ((__GNUC__<<16)+__GNUC_MINOR__>=((_maj)<<16)+(_min))
#  else
#   define SECP256K1_GNUC_PREREQ(_maj,_min) 0
#  endif
# endif

# if (!defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199901L) )
#  if SECP256K1_GNUC_PREREQ(2,7)
#   define SECP256K1_INLINE __inline__
#  elif (defined(_MSC_VER))
#   define SECP256K1_INLINE __inline
#  else
#   define SECP256K1_INLINE
#  endif
# else
#  define SECP256K1_INLINE inline
# endif

#ifndef SECP256K1_API
# if defined(_WIN32)
#  ifdef SECP256K1_BUILD
#   define SECP256K1_API __declspec(dllexport)
#  else
#   define SECP256K1_API
#  endif
# elif defined(__GNUC__) && defined(SECP256K1_BUILD)
#  define SECP256K1_API __attribute__ ((visibility ("default")))
# else
#  define SECP256K1_API
# endif
#endif

/**Warning attributes
  * NONNULL is not used if SECP256K1_BUILD is set to avoid the compiler optimizing out
  * some paranoid null checks. */
# if defined(__GNUC__) && SECP256K1_GNUC_PREREQ(3, 4)
#  define SECP256K1_WARN_UNUSED_RESULT __attribute__ ((__warn_unused_result__))
# else
#  define SECP256K1_WARN_UNUSED_RESULT
# endif
# if !defined(SECP256K1_BUILD) && defined(__GNUC__) && SECP256K1_GNUC_PREREQ(3, 4)
#  define SECP256K1_ARG_NONNULL(_x)  __attribute__ ((__nonnull__(_x)))
# else
#  define SECP256K1_ARG_NONNULL(_x)
# endif

/** All flags' lower 8 bits indicate what they're for. Do not use directly. */
#define SECP256K1_FLAGS_TYPE_MASK ((1 << 8) - 1)
#define SECP256K1_FLAGS_TYPE_CONTEXT (1 << 0)
#define SECP256K1_FLAGS_TYPE_COMPRESSION (1 << 1)
/** The higher bits contain the actual data. Do not use directly. */
#define SECP256K1_FLAGS_BIT_CONTEXT_VERIFY (1 << 8)
#define SECP256K1_FLAGS_BIT_CONTEXT_SIGN (1 << 9)
#define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)

/** Flags to pass to secp256k1_context_create. */
#define SECP256K1_CONTEXT_VERIFY (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY)
#define SECP256K1_CONTEXT_SIGN (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN)
#define SECP256K1_CONTEXT_NONE (SECP256K1_FLAGS_TYPE_CONTEXT)

/** Flag to pass to secp256k1_ec_pubkey_serialize and secp256k1_ec_privkey_export. */
#define SECP256K1_EC_COMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)
#define SECP256K1_EC_UNCOMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION)

/** Prefix byte used to tag various encoded curvepoints for specific purposes */
#define SECP256K1_TAG_PUBKEY_EVEN 0x02
#define SECP256K1_TAG_PUBKEY_ODD 0x03
#define SECP256K1_TAG_PUBKEY_UNCOMPRESSED 0x04
#define SECP256K1_TAG_PUBKEY_HYBRID_EVEN 0x06
#define SECP256K1_TAG_PUBKEY_HYBRID_ODD 0x07

/** Create a secp256k1 context object.
 *
 *  Returns: a newly created context object.
 *  In:      flags: which parts of the context to initialize.
 *
 *  See also secp256k1_context_randomize.
 */
SECP256K1_API secp256k1_context* secp256k1_context_create(
    unsigned int flags
) SECP256K1_WARN_UNUSED_RESULT;

/** Copies a secp256k1 context object.
 *
 *  Returns: a newly created context object.
 *  Args:    ctx: an existing context to copy (cannot be NULL)
 */
SECP256K1_API secp256k1_context* secp256k1_context_clone(
    const secp256k1_context* ctx
) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;

/** Destroy a secp256k1 context object.
 *
 *  The context pointer may not be used afterwards.
 *  Args:   ctx: an existing context to destroy (cannot be NULL)
 */
SECP256K1_API void secp256k1_context_destroy(
    secp256k1_context* ctx
);

/** Set a callback function to be called when an illegal argument is passed to
 *  an API call. It will only trigger for violations that are mentioned
 *  explicitly in the header.
 *
 *  The philosophy is that these shouldn't be dealt with through a
 *  specific return value, as calling code should not have branches to deal with
 *  the case that this code itself is broken.
 *
 *  On the other hand, during debug stage, one would want to be informed about
 *  such mistakes, and the default (crashing) may be inadvisable.
 *  When this callback is triggered, the API function called is guaranteed not
 *  to cause a crash, though its return value and output arguments are
 *  undefined.
 *
 *  Args: ctx:  an existing context object (cannot be NULL)
 *  In:   fun:  a pointer to a function to call when an illegal argument is
 *              passed to the API, taking a message and an opaque pointer
 *              (NULL restores a default handler that calls abort).
 *        data: the opaque pointer to pass to fun above.
 */
SECP256K1_API void secp256k1_context_set_illegal_callback(
    secp256k1_context* ctx,
    void (*fun)(const char* message, void* data),
    const void* data
) SECP256K1_ARG_NONNULL(1);

/** Set a callback function to be called when an internal consistency check
 *  fails. The default is crashing.
 *
 *  This can only trigger in case of a hardware failure, miscompilation,
 *  memory corruption, serious bug in the library, or other error would can
 *  otherwise result in undefined behaviour. It will not trigger due to mere
 *  incorrect usage of the API (see secp256k1_context_set_illegal_callback
 *  for that). After this callback returns, anything may happen, including
 *  crashing.
 *
 *  Args: ctx:  an existing context object (cannot be NULL)
 *  In:   fun:  a pointer to a function to call when an internal error occurs,
 *              taking a message and an opaque pointer (NULL restores a default
 *              handler that calls abort).
 *        data: the opaque pointer to pass to fun above.
 */
SECP256K1_API void secp256k1_context_set_error_callback(
    secp256k1_context* ctx,
    void (*fun)(const char* message, void* data),
    const void* data
) SECP256K1_ARG_NONNULL(1);

/** Parse a variable-length public key into the pubkey object.
 *
 *  Returns: 1 if the public key was fully valid.
 *           0 if the public key could not be parsed or is invalid.
 *  Args: ctx:      a secp256k1 context object.
 *  Out:  pubkey:   pointer to a pubkey object. If 1 is returned, it is set to a
 *                  parsed version of input. If not, its value is undefined.
 *  In:   input:    pointer to a serialized public key
 *        inputlen: length of the array pointed to by input
 *
 *  This function supports parsing compressed (33 bytes, header byte 0x02 or
 *  0x03), uncompressed (65 bytes, header byte 0x04), or hybrid (65 bytes, header
 *  byte 0x06 or 0x07) format public keys.
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_parse(
    const secp256k1_context* ctx,
    secp256k1_pubkey* pubkey,
    const unsigned char *input,
    size_t inputlen
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Serialize a pubkey object into a serialized byte sequence.
 *
 *  Returns: 1 always.
 *  Args:   ctx:        a secp256k1 context object.
 *  Out:    output:     a pointer to a 65-byte (if compressed==0) or 33-byte (if
 *                      compressed==1) byte array to place the serialized key
 *                      in.
 *  In/Out: outputlen:  a pointer to an integer which is initially set to the
 *                      size of output, and is overwritten with the written
 *                      size.
 *  In:     pubkey:     a pointer to a secp256k1_pubkey containing an
 *                      initialized public key.
 *          flags:      SECP256K1_EC_COMPRESSED if serialization should be in
 *                      compressed format, otherwise SECP256K1_EC_UNCOMPRESSED.
 */
SECP256K1_API int secp256k1_ec_pubkey_serialize(
    const secp256k1_context* ctx,
    unsigned char *output,
    size_t *outputlen,
    const secp256k1_pubkey* pubkey,
    unsigned int flags
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);

/** Parse an ECDSA signature in compact (64 bytes) format.
 *
 *  Returns: 1 when the signature could be parsed, 0 otherwise.
 *  Args: ctx:      a secp256k1 context object
 *  Out:  sig:      a pointer to a signature object
 *  In:   input64:  a pointer to the 64-byte array to parse
 *
 *  The signature must consist of a 32-byte big endian R value, followed by a
 *  32-byte big endian S value. If R or S fall outside of [0..order-1], the
 *  encoding is invalid. R and S with value 0 are allowed in the encoding.
 *
 *  After the call, sig will always be initialized. If parsing failed or R or
 *  S are zero, the resulting sig value is guaranteed to fail validation for any
 *  message and public key.
 */
SECP256K1_API int secp256k1_ecdsa_signature_parse_compact(
    const secp256k1_context* ctx,
    secp256k1_ecdsa_signature* sig,
    const unsigned char *input64
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Parse a DER ECDSA signature.
 *
 *  Returns: 1 when the signature could be parsed, 0 otherwise.
 *  Args: ctx:      a secp256k1 context object
 *  Out:  sig:      a pointer to a signature object
 *  In:   input:    a pointer to the signature to be parsed
 *        inputlen: the length of the array pointed to be input
 *
 *  This function will accept any valid DER encoded signature, even if the
 *  encoded numbers are out of range.
 *
 *  After the call, sig will always be initialized. If parsing failed or the
 *  encoded numbers are out of range, signature validation with it is
 *  guaranteed to fail for every message and public key.
 */
SECP256K1_API int secp256k1_ecdsa_signature_parse_der(
    const secp256k1_context* ctx,
    secp256k1_ecdsa_signature* sig,
    const unsigned char *input,
    size_t inputlen
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Serialize an ECDSA signature in DER format.
 *
 *  Returns: 1 if enough space was available to serialize, 0 otherwise
 *  Args:   ctx:       a secp256k1 context object
 *  Out:    output:    a pointer to an array to store the DER serialization
 *  In/Out: outputlen: a pointer to a length integer. Initially, this integer
 *                     should be set to the length of output. After the call
 *                     it will be set to the length of the serialization (even
 *                     if 0 was returned).
 *  In:     sig:       a pointer to an initialized signature object
 */
SECP256K1_API int secp256k1_ecdsa_signature_serialize_der(
    const secp256k1_context* ctx,
    unsigned char *output,
    size_t *outputlen,
    const secp256k1_ecdsa_signature* sig
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);

/** Serialize an ECDSA signature in compact (64 byte) format.
 *
 *  Returns: 1
 *  Args:   ctx:       a secp256k1 context object
 *  Out:    output64:  a pointer to a 64-byte array to store the compact serialization
 *  In:     sig:       a pointer to an initialized signature object
 *
 *  See secp256k1_ecdsa_signature_parse_compact for details about the encoding.
 */
SECP256K1_API int secp256k1_ecdsa_signature_serialize_compact(
    const secp256k1_context* ctx,
    unsigned char *output64,
    const secp256k1_ecdsa_signature* sig
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Verify an ECDSA signature.
 *
 *  Returns: 1: correct signature
 *           0: incorrect or unparseable signature
 *  Args:    ctx:       a secp256k1 context object, initialized for verification.
 *  In:      sig:       the signature being verified (cannot be NULL)
 *           msg32:     the 32-byte message hash being verified (cannot be NULL)
 *           pubkey:    pointer to an initialized public key to verify with (cannot be NULL)
 *
 * To avoid accepting malleable signatures, only ECDSA signatures in lower-S
 * form are accepted.
 *
 * If you need to accept ECDSA signatures from sources that do not obey this
 * rule, apply secp256k1_ecdsa_signature_normalize to the signature prior to
 * validation, but be aware that doing so results in malleable signatures.
 *
 * For details, see the comments for that function.
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_verify(
    const secp256k1_context* ctx,
    const secp256k1_ecdsa_signature *sig,
    const unsigned char *msg32,
    const secp256k1_pubkey *pubkey
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);

/** Convert a signature to a normalized lower-S form.
 *
 *  Returns: 1 if sigin was not normalized, 0 if it already was.
 *  Args: ctx:    a secp256k1 context object
 *  Out:  sigout: a pointer to a signature to fill with the normalized form,
 *                or copy if the input was already normalized. (can be NULL if
 *                you're only interested in whether the input was already
 *                normalized).
 *  In:   sigin:  a pointer to a signature to check/normalize (cannot be NULL,
 *                can be identical to sigout)
 *
 *  With ECDSA a third-party can forge a second distinct signature of the same
 *  message, given a single initial signature, but without knowing the key. This
 *  is done by negating the S value modulo the order of the curve, 'flipping'
 *  the sign of the random point R which is not included in the signature.
 *
 *  Forgery of the same message isn't universally problematic, but in systems
 *  where message malleability or uniqueness of signatures is important this can
 *  cause issues. This forgery can be blocked by all verifiers forcing signers
 *  to use a normalized form.
 *
 *  The lower-S form reduces the size of signatures slightly on average when
 *  variable length encodings (such as DER) are used and is cheap to verify,
 *  making it a good choice. Security of always using lower-S is assured because
 *  anyone can trivially modify a signature after the fact to enforce this
 *  property anyway.
 *
 *  The lower S value is always between 0x1 and
 *  0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,
 *  inclusive.
 *
 *  No other forms of ECDSA malleability are known and none seem likely, but
 *  there is no formal proof that ECDSA, even with this additional restriction,
 *  is free of other malleability. Commonly used serialization schemes will also
 *  accept various non-unique encodings, so care should be taken when this
 *  property is required for an application.
 *
 *  The secp256k1_ecdsa_sign function will by default create signatures in the
 *  lower-S form, and secp256k1_ecdsa_verify will not accept others. In case
 *  signatures come from a system that cannot enforce this property,
 *  secp256k1_ecdsa_signature_normalize must be called before verification.
 */
SECP256K1_API int secp256k1_ecdsa_signature_normalize(
    const secp256k1_context* ctx,
    secp256k1_ecdsa_signature *sigout,
    const secp256k1_ecdsa_signature *sigin
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(3);

/** An implementation of RFC6979 (using HMAC-SHA256) as nonce generation function.
 * If a data pointer is passed, it is assumed to be a pointer to 32 bytes of
 * extra entropy.
 */
SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979;

/** A default safe nonce generation function (currently equal to secp256k1_nonce_function_rfc6979). */
SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_default;

/** Create an ECDSA signature.
 *
 *  Returns: 1: signature created
 *           0: the nonce generation function failed, or the private key was invalid.
 *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)
 *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)
 *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)
 *           seckey: pointer to a 32-byte secret key (cannot be NULL)
 *           noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used
 *           ndata:  pointer to arbitrary data used by the nonce generation function (can be NULL)
 *
 * The created signature is always in lower-S form. See
 * secp256k1_ecdsa_signature_normalize for more details.
 */
SECP256K1_API int secp256k1_ecdsa_sign(
    const secp256k1_context* ctx,
    secp256k1_ecdsa_signature *sig,
    const unsigned char *msg32,
    const unsigned char *seckey,
    secp256k1_nonce_function noncefp,
    const void *ndata
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);

/** Verify an ECDSA secret key.
 *
 *  Returns: 1: secret key is valid
 *           0: secret key is invalid
 *  Args:    ctx: pointer to a context object (cannot be NULL)
 *  In:      seckey: pointer to a 32-byte secret key (cannot be NULL)
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(
    const secp256k1_context* ctx,
    const unsigned char *seckey
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);

/** Compute the public key for a secret key.
 *
 *  Returns: 1: secret was valid, public key stores
 *           0: secret was invalid, try again
 *  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)
 *  Out:    pubkey:     pointer to the created public key (cannot be NULL)
 *  In:     seckey:     pointer to a 32-byte private key (cannot be NULL)
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(
    const secp256k1_context* ctx,
    secp256k1_pubkey *pubkey,
    const unsigned char *seckey
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Negates a private key in place.
 *
 *  Returns: 1 always
 *  Args:   ctx:        pointer to a context object
 *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(
    const secp256k1_context* ctx,
    unsigned char *seckey
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);

/** Negates a public key in place.
 *
 *  Returns: 1 always
 *  Args:   ctx:        pointer to a context object
 *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(
    const secp256k1_context* ctx,
    secp256k1_pubkey *pubkey
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);

/** Tweak a private key by adding tweak to it.
 * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for
 *          uniformly random 32-byte arrays, or if the resulting private key
 *          would be invalid (only when the tweak is the complement of the
 *          private key). 1 otherwise.
 * Args:    ctx:    pointer to a context object (cannot be NULL).
 * In/Out:  seckey: pointer to a 32-byte private key.
 * In:      tweak:  pointer to a 32-byte tweak.
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(
    const secp256k1_context* ctx,
    unsigned char *seckey,
    const unsigned char *tweak
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Tweak a public key by adding tweak times the generator to it.
 * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for
 *          uniformly random 32-byte arrays, or if the resulting public key
 *          would be invalid (only when the tweak is the complement of the
 *          corresponding private key). 1 otherwise.
 * Args:    ctx:    pointer to a context object initialized for validation
 *                  (cannot be NULL).
 * In/Out:  pubkey: pointer to a public key object.
 * In:      tweak:  pointer to a 32-byte tweak.
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(
    const secp256k1_context* ctx,
    secp256k1_pubkey *pubkey,
    const unsigned char *tweak
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Tweak a private key by multiplying it by a tweak.
 * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for
 *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.
 * Args:   ctx:    pointer to a context object (cannot be NULL).
 * In/Out: seckey: pointer to a 32-byte private key.
 * In:     tweak:  pointer to a 32-byte tweak.
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(
    const secp256k1_context* ctx,
    unsigned char *seckey,
    const unsigned char *tweak
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Tweak a public key by multiplying it by a tweak value.
 * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for
 *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.
 * Args:    ctx:    pointer to a context object initialized for validation
 *                 (cannot be NULL).
 * In/Out:  pubkey: pointer to a public key obkect.
 * In:      tweak:  pointer to a 32-byte tweak.
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(
    const secp256k1_context* ctx,
    secp256k1_pubkey *pubkey,
    const unsigned char *tweak
) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

/** Updates the context randomization to protect against side-channel leakage.
 *  Returns: 1: randomization successfully updated
 *           0: error
 *  Args:    ctx:       pointer to a context object (cannot be NULL)
 *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)
 *
 * While secp256k1 code is written to be constant-time no matter what secret
 * values are, it's possible that a future compiler may output code which isn't,
 * and also that the CPU may not emit the same radio frequencies or draw the same
 * amount power for all values.
 *
 * This function provides a seed which is combined into the blinding value: that
 * blinding value is added before each multiplication (and removed afterwards) so
 * that it does not affect function results, but shields against attacks which
 * rely on any input-dependent behaviour.
 *
 * You should call this after secp256k1_context_create or
 * secp256k1_context_clone, and may call this repeatedly afterwards.
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(
    secp256k1_context* ctx,
    const unsigned char *seed32
) SECP256K1_ARG_NONNULL(1);

/** Add a number of public keys together.
 *  Returns: 1: the sum of the public keys is valid.
 *           0: the sum of the public keys is not valid.
 *  Args:   ctx:        pointer to a context object
 *  Out:    out:        pointer to a public key object for placing the resulting public key
 *                      (cannot be NULL)
 *  In:     ins:        pointer to array of pointers to public keys (cannot be NULL)
 *          n:          the number of public keys to add together (must be at least 1)
 */
SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_combine(
    const secp256k1_context* ctx,
    secp256k1_pubkey *out,
    const secp256k1_pubkey * const * ins,
    size_t n
) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);

# ifdef __cplusplus
}
# endif

#endif

'''
'''--- ffi/secp256k1-sys/include/test.c ---
#include <stdio.h>

#include "./secp256k1.h"

// 返回16进制字符代表的整数值
int hex2int(unsigned char x){
    if(x >= '0' && x <= '9'){
        return (x - '0');
    }
    if(x >= 'A' && x <= 'F'){
        return (x - 'A' + 10);
    }
    if(x >= 'a' && x <= 'f'){
        return (x - 'a' + 10);
    }
    return -1;
}
/** 测试主函数 */
int main(int argc, char** argv) {
    unsigned char prikeyhex[] = "9a9a6539856be209b8ea2adbd155c0919646d108515b60b7b13d6a79f1ae5174";
    int len = sizeof(prikeyhex) / 2;    // 私钥长度 - 32字节
    unsigned char prikey[len];          // 私钥存储
    int ii;                             // 索引值
    int ret;                            // 返回值

    unsigned char CPubKey[65];          // 公钥存储
    size_t clen;                        // 返回公钥长度

    secp256k1_context *secp256k1_context_sign;
    secp256k1_pubkey pubkey;            // secp256k1返回公钥
    // 将私钥字符串转换为字节存储
    for(ii = 0; ii < sizeof(prikeyhex); ii+=2){     
        prikey[ii/2] = hex2int(prikeyhex[ii]) * 16 + hex2int(prikeyhex[ii + 1]);
    }
    // 打印私钥
    printf("Private key: "); 
    for(ii = 0; ii < len; ii++)
    {
        printf("%02x",prikey[ii]);
    } 
    printf("\n");
    // 生成公钥
    secp256k1_context_sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);
    ret = secp256k1_ec_pubkey_create(secp256k1_context_sign, &pubkey, prikey);  

    // 打印公钥
    if(ret){
        printf("Public key : ");  
        printf("[X(");
        for(ii = 63; ii >= 32; ii--){
            printf("%02x", pubkey.data[ii]);
        }
        printf("):Y(");
        for(ii = 31; ii >= 0; ii--){
            printf("%02x", pubkey.data[ii]);
        }
        printf(")]\n");
        // 获取压缩公钥
        clen = 65;
        secp256k1_ec_pubkey_serialize(secp256k1_context_sign, CPubKey, &clen, &pubkey, SECP256K1_EC_COMPRESSED);
        printf("Compressed key  : ");
        for(ii = 0; ii < clen; ii++){
            printf("%02x", CPubKey[ii]);
        }
        printf("\n");
        // 获取非压缩公钥
        clen = 65;
        secp256k1_ec_pubkey_serialize(secp256k1_context_sign, CPubKey, &clen, &pubkey, SECP256K1_EC_UNCOMPRESSED);
        printf("Uncompressed key: ");
        for(ii = 0; ii < clen; ii++){
            printf("%02x", CPubKey[ii]);
        }
        printf("\n");
    }
    if (secp256k1_context_sign) {
        secp256k1_context_destroy(secp256k1_context_sign);
    }
    return 0;
}
'''
'''--- ffi/secp256k1-sys/src/lib.rs ---
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_context_sign() {
        assert_eq!(SECP256K1_CONTEXT_SIGN, 513);
    }

    #[test]
    fn test_create_pubkey() {
        // secp256k1返回公钥
        let mut pubkey: secp256k1_pubkey = secp256k1_pubkey {
            data: [0; 64],
        };
        let prikey: u8 = 1;

        unsafe {
            let context = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);
            assert!(!context.is_null());
            let ret = secp256k1_ec_pubkey_create(& *context, &mut pubkey, &prikey);
            assert_eq!(ret, 1);
        }
    }
}
'''
'''--- ffi/secp256k1-sys/wrapper.h ---
#include <secp256k1.h>
'''
'''--- head-first/Cargo.toml ---
[package]
name = "head-first"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

[dependencies]
clap = "2.33.0"
ring = "0.16.9"

merkle_tree = { package = "merkle_tree", path = "merkle-tree" }
'''
'''--- head-first/README.md ---
# Rust实战

## 并发

创建一个新线程，调用`thread::spawn`函数并传递一个闭包，其重包含希望在新线程运行的代码。

一个确保安全并发的方式是消息传递（message passing），线程通过发送包含数据的消息来相互通信。

> “Do not communicate by sharing memory; instead, share memory by communicating.”

通道（channel）来实现消息传递，创建通道，使用`mpsc::channel`函数。

不允许在线程间直接传递引用，那如何在多个线程间安全地共享变量呢？

不可变的变量，通过`Arc<T>`来共享，它是`Rc<T>`的线程安全版本，其内部使用了原子操作。

有两个并发概念是内嵌于语言中的：`std::marker`中的`Sync`和`Send` trait，使得并发保证能被扩展到用户定义的和标准库中提供的类型中。

## 代码实现

* [并发](./std-marker/example_Send_Sync.rs)

'''
'''--- head-first/async-primer/async-example/Cargo.toml ---
[package]
name = "async-example"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

[dependencies]
futures = "0.3.4"
async-std = "1.5.0"
'''
'''--- head-first/async-primer/async-example/src/file.rs ---
// use std::fs::File;
// use std::io::{self, Read};

// pub async fn read_file(path: &str) -> io::Result<String> {
//     let mut file = File::open(path)?;
//     let mut buffer = String::new();
//     file.read_to_string(&mut buffer)?;
//     Ok(buffer)
// }

// We use async_std instead of std, it's that simple.
use async_std::io;
use async_std::fs::File;
use async_std::prelude::*;

pub async fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path).await?;
    let mut buffer = String::new();
    file.read_to_string(&mut buffer).await?;
    Ok(buffer)
}
'''
'''--- head-first/async-primer/async-example/src/file1.txt ---
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
'''
'''--- head-first/async-primer/async-example/src/file2.txt ---
file2
'''
'''--- head-first/async-primer/async-example/src/main.rs ---
use futures::executor::block_on;
use futures::join;
use std::io;

mod file;

// fn main() -> io::Result<()> {
//     let r1 = file::read_file("src/file1.txt");
//     let r2 = file::read_file("src/file2.txt");

//     let f1 = r1.await;
//     let f2 = r2.await;

//     dbg!(f1);
//     dbg!(f2);

//     Ok(())
// }

fn main() -> io::Result<()> {

    println!("Program started");

    // Block on the final future
    block_on(load_files());

    Ok(())
}

async fn load_files() {
    // Join the two futures together
    join!(load_file_1(), load_file_2());
}

async fn load_file_1() {
    let r1 = file::read_file("src/file1.txt").await;
    println!("file 1 size: {}", r1.unwrap().len());
}

async fn load_file_2() {
    let r2 = file::read_file("src/file2.txt").await;
    println!("file 2 size: {}", r2.unwrap().len());
}
'''
'''--- head-first/async-primer/multi-example/Cargo.toml ---
[package]
name = "multi-example"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

[dependencies]
lazy_static = "1.4.0"
'''
'''--- head-first/async-primer/multi-example/src/file.rs ---
use std::fs::File;
use std::io::{self, Read};

pub fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut buffer = String::new();
    file.read_to_string(&mut buffer)?;
    Ok(buffer)
}
'''
'''--- head-first/async-primer/multi-example/src/file1.txt ---
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
file1
file
file
file
file
file
file
'''
'''--- head-first/async-primer/multi-example/src/file2.txt ---
file2
'''
'''--- head-first/async-primer/multi-example/src/main.rs ---
use std::io;
use std::sync::RwLock;
use std::thread;

use lazy_static::lazy_static;

mod file;

// A sync primitive that allows to read/write from variables between threads.
// we declare the variables here, this requires the lazy_static crate
lazy_static! {
    static ref FILE1: RwLock<String> = RwLock::new(String::from(""));
    static ref FILE2: RwLock<String> = RwLock::new(String::from(""));
}

fn main() -> io::Result<()> {
    println!("program started");

    let thread_1 = thread::spawn(|| {
        let mut w1 = FILE1.write().unwrap();
        *w1 = file::read_file("src/file1.txt").unwrap();
        println!("read file 1");
    });

    println!("Launched Thread 1");

    let thread_2 = thread::spawn(|| {
        let mut w2 = FILE2.write().unwrap();
        *w2 = file::read_file("src/file2.txt").unwrap();
        println!("read file 2");
    });

    println!("Launched Thread 2");

    let mut rf1: bool = false;
    let mut rf2: bool = false;

    loop {
        // read()
        // let r1 = FILE1.read().unwrap();
        // let r2 = FILE2.read().unwrap();

        // if *r1 != String::from("") && rf1 == false {
        //     println!("completed file 1");
        //     rf1 = true;
        // }

        // if *r2 != String::from("") && rf2 == false {
        //     println!("completed file 2");
        //     rf2 = true;
        // }

        // try_read()
        let r1 = FILE1.try_read();
        let r2 = FILE2.try_read();
        
        match r1 {
            Ok(v) => {
                if *v != String::from("") && rf1 == false {
                    println!("completed file 1");
                    rf1 = true;
                }
            }
            // If rwlock can't be acquired, ignore the error
            Err(_) => {}
        }

        match r2 {
            Ok(v) => {
                if *v != String::from("") && rf2 == false {
                    println!("completed file 2");
                    rf2 = true;
                }
            }
            // If rwlock can't be acquired, ignore the error
            Err(_) => {}
        }        
    }

    Ok(())
}
'''
'''--- head-first/async-primer/sync-example/Cargo.toml ---
[package]
name = "sync-example"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

[dependencies]

'''
'''--- head-first/async-primer/sync-example/src/file.rs ---
use std::fs::File;
use std::io::{self, Read};

pub fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut buffer = String::new();
    file.read_to_string(&mut buffer)?;
    Ok(buffer)
}
'''
'''--- head-first/async-primer/sync-example/src/file1.txt ---
file1
'''
'''--- head-first/async-primer/sync-example/src/file2.txt ---
file2
'''
'''--- head-first/async-primer/sync-example/src/main.rs ---
use std::io;

mod file;

fn main() -> io::Result<()> {
    println!("program started");

    let file1 = file::read_file("src/file1.txt")?;
    println!("processed file 1");

    let file2 = file::read_file("src/file2.txt")?;
    println!("processed file 2");

    dbg!(&file1);
    dbg!(&file2);

    Ok(())
}
'''
'''--- head-first/http/Cargo.toml ---
[package]
name = "http"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
reqwest = { version = "0.11", features = ["blocking"] }
html2md = "0.2"

futures = "0.1.26"
hyper = { version = "0.14.27", optional = true }

jsonrpc-core = "14.0.3"
jsonrpc-core-client = "14.0.3"
jsonrpc-http-server = "14.0.3"
jsonrpc-client-transports = "14.0.3"
jsonrpc-derive = "14.0.3"
'''
'''--- head-first/http/src/main.rs ---
mod rpc_server;
mod rpc_client;

use std::fs;

use hyper::rt;
use std::time::Duration;
use std::net::SocketAddr;

use jsonrpc_core::futures::Future;
use jsonrpc_http_server::*;
use jsonrpc_client_transports::transports::http;
use rpc_server::Rpc;
use jsonrpc_core::{Result};
use jsonrpc_core_client::transports::local;
use self::rpc_server::gen_client;

fn id<T>(t: T) -> T {
    t
}

fn example() {
    let mut io = rpc_server::rpc_handler();

    let request = r#"{"jsonrpc": "2.0", "method": "hello", "params": ["world"], "id": 1}"#;
    let response = r#"{"jsonrpc":"2.0","result":"hello world","id":1}"#;

    assert_eq!(io.handle_request(request).wait().unwrap(), Some(response.to_string()));
}

fn example2() {
    // init RPC server
    let server = rpc_server::RpcServer::serve(id);
    let (tx, rx) = std::sync::mpsc::channel();

    // create connect
    let run = http::connect(&server.uri)
        .and_then(|client: rpc_client::RpcClient| {
            client.hello("http").and_then(move |result| {
                drop(client);
                let _ = tx.send(result);
                Ok(())
            })
        })
        .map_err(|e| println!("RPC Client error: {:?}", e));

    rt::run(run);

    // get response
    let result = rx.recv_timeout(Duration::from_secs(3)).unwrap();
    assert_eq!("hello http", result);
}

struct RpcImpl;

impl Rpc for RpcImpl {
	fn add(&self, a: u64, b: u64) -> Result<u64> {
		Ok(a + b)
	}
}

fn example3() {
    let mut handler = rpc_server::rpc_handler();
    handler.extend_with(RpcImpl.to_delegate());
    
    // let server_details = "0.0.0.0:15678";
    // let server_addr: SocketAddr = server_details.parse().unwrap();
    // let new_server = rpc_server::start_http(&server_addr, handler);

    let fut = {
        let (client, server) = local::connect::<gen_client::Client, _, _>(handler);
		client.add(5, 6).map(|res| println!("5 + 6 = {}", res)).join(server)
	};
	fut.wait().unwrap();  
}

fn example1() {
    // init RPC server
    let server_details = "0.0.0.0:15678";
    let socket_addr: SocketAddr = server_details.parse().unwrap();
    let mut handler = rpc_server::rpc_handler();
    let new_server = rpc_server::start_http(&socket_addr, handler);
    let server_uri = format!("http://{}", socket_addr);

    let (tx, rx) = std::sync::mpsc::channel();

    // create connect
    let run = http::connect(&server_uri)
        .and_then(|client: rpc_client::RpcClient| {
            client.hello("http rpc").and_then(move |result| {
                drop(client);
                let _ = tx.send(result);
                Ok(())
            })
        })
        .map_err(|e| println!("RPC Client error: {:?}", e));

    rt::run(run);

    // get response
    let result = rx.recv_timeout(Duration::from_secs(3)).unwrap();
    assert_eq!("hello http rpc", result);
    println!("RPC Client example1: {:?}", result);
}

fn scrape_url() {
    let url = "https://www.rust-lang.org/";
    let output = "rust.md";

    println!("Fetching url: {}", url);
    let body = reqwest::blocking::get(url).unwrap().text().unwrap();

    println!("Converting html to markdown...");
    let md = html2md::parse_html(&body);

    fs::write(output, md.as_bytes()).unwrap();
    println!("Converted markdown has been saved in {}.", output);
}

fn main() {
    scrape_url();
    example();
    example1();
    example2();
    example3();
}
'''
'''--- head-first/http/src/rpc_client.rs ---
use jsonrpc_core_client::{RpcChannel, TypedClient, RpcError};

use futures::Future;

#[derive(Clone)]
pub struct RpcClient(TypedClient);

impl From<RpcChannel> for RpcClient {
    fn from(channel: RpcChannel) -> Self {
        RpcClient(channel.into())
    }
}

impl RpcClient {
    pub fn hello(&self, msg: &'static str) -> impl Future<Item = String, Error = RpcError> {
        self.0.call_method("hello", "String", (msg,))
    }

    pub fn fail(&self) -> impl Future<Item = (), Error = RpcError> {
        self.0.call_method("fail", "()", ())
    }

    pub fn notify(&self, value: u64) -> impl Future<Item = (), Error = RpcError> {
        self.0.notify("notify", (value,))
    }
}
'''
'''--- head-first/http/src/rpc_server.rs ---
use std::net::SocketAddr;
use std::io;

use jsonrpc_core::{Error, ErrorCode, IoHandler, Params, Value, Result};
use jsonrpc_http_server::{Server, ServerBuilder, RestApi};
use jsonrpc_derive::rpc;

pub struct RpcServer {
	pub uri: String,
	socket_addr: SocketAddr,
	server: Option<Server>,
}

impl RpcServer {
	pub fn serve<F: FnOnce(ServerBuilder) -> ServerBuilder>(alter: F) -> Self {
		let builder = ServerBuilder::new(rpc_handler()).rest_api(RestApi::Unsecure);

		let server = alter(builder).start_http(&"127.0.0.1:0".parse().unwrap()).unwrap();
		let socket_addr = server.address().clone();
		let uri = format!("http://{}", socket_addr);

		RpcServer {
			uri,
			socket_addr,
			server: Some(server),
		}
	}

	fn start(&mut self) {
		if self.server.is_none() {
			let server = ServerBuilder::new(rpc_handler())
				.rest_api(RestApi::Unsecure)
				.start_http(&self.socket_addr)
				.unwrap();
			self.server = Some(server);
		} else {
			panic!("Server already running")
		}
	}

	fn stop(&mut self) {
		let server = self.server.take();
		if let Some(server) = server {
			server.close();
		}
	}
}

pub fn rpc_handler() -> IoHandler {
	let mut io = IoHandler::default();
	io.add_method("hello", |params: Params| match params.parse::<(String,)>() {
		Ok((msg,)) => Ok(Value::String(format!("hello {}", msg))),
		_ => Ok(Value::String("world".into())),
	});
	io.add_method("fail", |_: Params| Err(Error::new(ErrorCode::ServerError(-34))));
	io.add_notification("notify", |params: Params| {
		let (value,) = params.parse::<(u64,)>().expect("expected one u64 as param");
		assert_eq!(value, 12);
	});

	io
}

/// Maximal payload accepted by RPC servers.
const MAX_PAYLOAD: usize = 15 * 1024 * 1024;

/// Type alias for http server
pub type HttpServer = Server;

/// The RPC IoHandler containing all requested APIs.
pub type RpcHandler = IoHandler;

/// Start HTTP server listening on given address.
///
/// **Note**: Only available if `not(target_os = "unknown")`.
pub fn start_http(
	addr: &std::net::SocketAddr,
	io: RpcHandler,
) -> io::Result<Server> {
	ServerBuilder::new(io)
		//.threads(4)
		.rest_api(RestApi::Unsecure)
		.max_request_body_size(MAX_PAYLOAD)
		.start_http(addr)
}

/// API
#[rpc]
pub trait Rpc {
	/// Adds two numbers and returns a result
	#[rpc(name = "add")]
	fn add(&self, a: u64, b: u64) -> Result<u64>;
}
'''
'''--- head-first/merkle-tree/Cargo.toml ---
[package]
name = "merkle_tree"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ring = "0.16.9"
'''
'''--- head-first/merkle-tree/README.md ---
## Merkle Tree

The implementation of Merkle Tree in Rust.

This tree is stored in a vector. 

For example, there are four items, merkle tree is kept like: 
[hash0,hash1,hash2,hash3,hash01,hash23,root]

While building a tree, if there is an odd number of nodes at the given level, the last node will be duplicated.

## Usage example

```Rust
extern crate ring;

use ring::digest::{Algorithm, SHA512};
use merkle_tree::MerkleTree;

static ALGO: &'static Algorithm = &SHA512;

fn main() {
    let values = vec!["one", "two", "three", "four"];
    let tree = MerkleTree::new(&values, ALGO);
    let proof = tree.build_proof(&"one");
    let vec = proof.unwrap();
    tree.validate(&vec);
}
```

'''
'''--- head-first/merkle-tree/src/lib.rs ---
/// The implementation of Merkle Tree in Rust.

extern crate ring;

use std::convert::AsRef;
use std::hash::Hash;

use ring::digest::{Algorithm, Context, Digest};

/// This tree is stored in a vector.
///
/// For example, there are four items, merkle tree is kept like:
/// [hash0,hash1,hash2,hash3,hash01,hash23,root]
///
/// # Usage example
///
/// ```
/// extern crate ring;
///
/// use ring::digest::{Algorithm, SHA512};
/// use merkle_tree::MerkleTree;
///
/// static ALGO: &'static Algorithm = &SHA512;
///
/// fn main() {
///     let values = vec!["one", "two", "three", "four"];
///     let tree = MerkleTree::new(&values, ALGO);
///     let proof = tree.build_proof(&"one");
///     let vec = proof.unwrap();
///     tree.validate(&vec);
/// }
/// ```
///

pub struct MerkleTree {
    array: Vec<u8>,
    height: usize,
    items_count: usize,
    algo: &'static Algorithm,
}

impl MerkleTree {
    /// Build Merkle Tree
    pub fn new<T: AsRef<[u8]>>(values: &Vec<T>, algo: &'static Algorithm) -> MerkleTree {
        let (height, array) = build_tree(values, algo);
        MerkleTree {
            array: array,
            height: height,
            items_count: values.len(),
            algo: algo,
        }
    }

    /// Generate Merkle Proof
    pub fn build_proof<T: Eq + Hash + AsRef<[u8]>>(&self, value: &T) -> Option<Vec<&[u8]>> {
        let hash = get_hash(value.as_ref(), self.algo).as_ref().to_vec();
        let index = self.find_item(&hash);
        let mut vec = vec![];
        match index {
            Some(i) => {
                vec.push(&self.array[(i * self.algo.output_len)..(i * self.algo.output_len + self.algo.output_len)]);
                Some(self.add_level(0, i, self.items_count, vec))
            }
            None => None
        }
    }

    fn find_item(&self, hash: &Vec<u8>) -> Option<usize> {
        let mut result = None;
        // linear search item in a loop
        for index in 0..self.items_count {
            let start = index * self.algo.output_len;
            if hash.as_slice() == &self.array[start..(start + self.algo.output_len)] {
                result = Some(index);
                break;
            }
        }
        result
    }

    /// Recursion
    fn add_level<'a>(&'a self, start_index: usize, index: usize, mut level_len: usize, mut result: Vec<&'a [u8]>) -> Vec<&'a [u8]> {
        level_len += level_len & 1;
        let (sibling, parent) = calculate_relatives(index);
        //Add sibling to result
        result.push(&self.array[
            (start_index + sibling * self.algo.output_len)..(start_index + sibling * self.algo.output_len + self.algo.output_len)
            ]);
        let next_level_len = level_len / 2;
        // Do not include root to proof
        if next_level_len == 1 { 
            return result;
        }
        self.add_level(start_index + level_len * self.algo.output_len, parent, next_level_len, result)
    }

    pub fn is_empty(&self) -> bool {
        self.nodes_count() == 0
    }

    pub fn get_root(&self) -> &[u8] {
        if self.is_empty() {
            return &[];
        }
        let root_index = self.array.len() - self.algo.output_len;
        &self.array[root_index..] // Last item
    }

    pub fn nodes_count(&self) -> usize {
        self.array.len() / self.algo.output_len
    }

    pub fn leafs_count(&self) -> usize {
        self.items_count
    }

    pub fn data_size(&self) -> usize {
        self.array.len()
    }

    pub fn height(&self) -> usize {
        self.height
    }

    /// fold() takes two arguments: an initial hash(01)
    /// and a closure with two arguments 
    pub fn validate(&self, proof: &Vec<&[u8]>) -> bool {
        proof[2..].iter()
            .fold(
                get_pair_hash(proof[0], proof[1], self.algo),
                |a, b| get_pair_hash(a.as_ref(), b, self.algo)
            ).as_ref() == self.get_root()
    }
}

/// "2i 2i+1" schema
fn calculate_relatives(index: usize) -> (usize, usize) {
    let mut sibling = index;
    if index & 1 == 0 {
        sibling += 1
    } else {
        sibling -= 1
    };
    let parent = (index + 1 + ((index + 1) & 1)) / 2 - 1;
    (sibling, parent)
}

/// While building a tree, if there is an odd number of nodes at the given
/// level, the last node will be duplicated.
fn build_tree<T: AsRef<[u8]>>(values: &Vec<T>, algo: &'static Algorithm) -> (usize, Vec<u8>) {
    let vec_len = calculate_vec_len(values.len(), algo);
    let mut tree: Vec<u8> = Vec::with_capacity(vec_len);
    for (_i, v) in values.iter().enumerate() { //Hash leafs
        let digest = get_hash(v.as_ref(), algo);
        let hash = digest.as_ref();
        tree.extend_from_slice(hash);
    }
    let height = build_level(&mut tree, 0, values.len(), algo);
    (height, tree)
}

/// length = (leafs + nodes) * output_len
fn calculate_vec_len(len: usize, algo: &'static Algorithm) -> usize {
    //Determine leafs number is even or odd  
    let mut result = len + (len & 1);
    let mut level = result;
    while level > 1 {
        level += level & 1;
        level = level / 2;
        result += level;
    }
    //output_len is the length of a finalized digest
    result * algo.output_len
}

/// Return tree weight and build nodes
fn build_level(tree: &mut Vec<u8>, prev_level_start: usize, mut prev_level_len: usize, algo: &'static Algorithm) -> usize {
    if prev_level_len & 1 == 1 {
        //Previous level has odd number of children
        let prev = &tree[(prev_level_start * algo.output_len + (prev_level_len - 1) * algo.output_len)..]
            .to_owned();
        //Duplicate last item
        tree.extend_from_slice(prev); 
        prev_level_len += 1;
    }
    let level_len = prev_level_len / 2;
    for i in 0..level_len {
        let begin = prev_level_start * algo.output_len + i * 2 * algo.output_len;
        let middle = begin + algo.output_len;
        let end = middle + algo.output_len;
        let hash = get_pair_hash(
            &tree[begin..middle], //Left node
            &tree[middle..end], //Right node
            algo);
        tree.extend_from_slice(hash.as_ref());
    };
    if level_len > 1 {
        return build_level(tree, prev_level_start + prev_level_len, level_len, algo) + 1;
    }
    if level_len > 0 {
        return 2;
    }
    return 0;
}

/// Generate Node hash
pub fn get_pair_hash(x: &[u8], y: &[u8], algo: &'static Algorithm) -> Digest {
    let left = x;
    let right = y;
    let mut ctx = Context::new(algo);
    ctx.update(left);
    ctx.update(right);
    ctx.finish()
}

/// Hash function
pub fn get_hash(x: &[u8], algo: &'static Algorithm) -> Digest {
    let mut ctx = Context::new(algo);
    ctx.update(x);
    ctx.finish()
}

#[cfg(test)]
mod tests {
    use ring::digest::{Algorithm, Context, Digest, SHA512};
    use super::MerkleTree;

    static ALGO: &'static Algorithm = &SHA512;

    #[test]
    fn test_build_tree_with_0_values() {
        let values: Vec<&str> = vec![];
        let tree = MerkleTree::new(&values, ALGO);

        assert_eq!(true, tree.is_empty());
        assert_eq!(0, tree.height());
        assert_eq!(0, tree.nodes_count());
        assert_eq!(0, tree.data_size());
        let empty_root: Vec<u8> = vec![];
        assert_eq!(empty_root, tree.get_root());
    }

    #[test]
    fn test_build_tree_with_odd_number_of_values() {
        let values = vec!["one", "two", "three"];
        let tree = MerkleTree::new(&values, ALGO);

        let _d0: Digest = super::get_hash(values[0].as_ref(), ALGO);
        let _d1: Digest = super::get_hash(values[1].as_ref(), ALGO);
        let _d2: Digest = super::get_hash(values[2].as_ref(), ALGO);
        let _d3: Digest = super::get_hash(values[2].as_ref(), ALGO);

        let _d01 = hash_pair(_d0.as_ref(), _d1.as_ref(), ALGO);
        let _d23 = hash_pair(_d2.as_ref(), _d3.as_ref(), ALGO);
        let _pair = super::get_pair_hash(_d01.as_ref(), _d23.as_ref(), ALGO);

        assert_eq!(false, tree.is_empty());
        assert_eq!(3, tree.height());
        assert_eq!(7, tree.nodes_count());
        assert_eq!(7 * ALGO.output_len, tree.data_size());
        assert_eq!(_pair.as_ref(), tree.get_root());
    }

    #[test]
    fn test_build_tree_with_even_number_of_values() {
        let values = vec!["one", "two", "three", "four"];
        let tree = MerkleTree::new(&values, ALGO);

        let _d0: Digest = super::get_hash(values[0].as_ref(), ALGO);
        let _d1: Digest = super::get_hash(values[1].as_ref(), ALGO);
        let _d2: Digest = super::get_hash(values[2].as_ref(), ALGO);
        let _d3: Digest = super::get_hash(values[3].as_ref(), ALGO);

        let _d01 = hash_pair(_d0.as_ref(), _d1.as_ref(), ALGO);
        let _d23 = hash_pair(_d2.as_ref(), _d3.as_ref(), ALGO);
        let _pair = super::get_pair_hash(_d01.as_ref(), _d23.as_ref(), ALGO);

        assert_eq!(false, tree.is_empty());
        assert_eq!(3, tree.height());
        assert_eq!(7, tree.nodes_count());
        assert_eq!(7 * ALGO.output_len, tree.data_size());
        assert_eq!(_pair.as_ref(), tree.get_root());
    }

    #[test]
    fn test_root_hash_same_if_values_were_same() {
        let values = vec!["one", "one", "one", "one"];
        let tree = MerkleTree::new(&values, ALGO);

        let _d0: Digest = super::get_hash(values[0].as_ref(), ALGO);
        let _d1: Digest = super::get_hash(values[1].as_ref(), ALGO);
        let _d2: Digest = super::get_hash(values[2].as_ref(), ALGO);
        let _d3: Digest = super::get_hash(values[3].as_ref(), ALGO);

        let _d01 = hash_pair(_d0.as_ref(), _d1.as_ref(), ALGO);
        let _d23 = hash_pair(_d2.as_ref(), _d3.as_ref(), ALGO);
        let _pair = super::get_pair_hash(_d23.as_ref(), _d01.as_ref(), ALGO);

        assert_eq!(false, tree.is_empty());
        assert_eq!(3, tree.height());
        assert_eq!(7, tree.nodes_count());
        assert_eq!(7 * ALGO.output_len, tree.data_size());
        assert_eq!(_pair.as_ref(), tree.get_root());
    }

    #[test]
    fn test_root_hash_different_reverse_values() {
        let values1 = vec!["one", "two"];
        let tree1 = MerkleTree::new(&values1, ALGO);

        let values2 = vec!["two", "one"];
        let tree2 = MerkleTree::new(&values2, ALGO);

        assert_ne!(tree1.get_root(), tree2.get_root());
    }

    #[test]
    fn test_generate_merkle_proof_and_validate() {
        let values = vec!["one", "two", "three", "four"];
        let tree = MerkleTree::new(&values, ALGO);

        for v in values {
            let proof = tree.build_proof(&v);
            assert_eq!(true, proof.is_some());
            let vec = proof.unwrap();
            assert_eq!(3, vec.len());
            tree.validate(&vec);
        }

        let absent = vec!["qqq", "www", "eee", "rrr"];
        for v in absent {
            let proof = tree.build_proof(&v);
            assert_eq!(true, proof.is_none());
        }
    }

    #[test]
    fn test_provide_bad_merkle_proof() {
        let values = vec!["one", "two", "three", "four"];
        let tree = MerkleTree::new(&values, ALGO);
        let proof = tree.build_proof(&"one");

        assert_eq!(true, proof.is_some());
        let _d0: Digest = super::get_hash("five".as_ref(), ALGO);
        let proof_vec = proof.unwrap();
        let vec = vec![proof_vec[0], proof_vec[1], _d0.as_ref()];
        assert_eq!(false, tree.validate(&vec));
    }

    // helper function
    fn hash_pair(x: &[u8], y: &[u8], algo: &'static Algorithm) -> Digest {
        let mut ctx = Context::new(algo);
        ctx.update(x);
        ctx.update(y);
        ctx.finish()
    }
    
}

'''
'''--- head-first/rust-trait/Cargo.toml ---
[package]
name = "rust-trait"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

'''
'''--- head-first/rust-trait/src/abstract_type.rs ---
pub fn trait_object() {
    #[derive(Debug)]
    struct Foo;
    trait Bar {
        fn baz(&self);
    }
    impl Bar for Foo {
        fn baz(&self) { println!("{:?}", self) }
    }
    fn static_dispatch<T>(t: &T) where T:Bar {
        t.baz();
    }
    fn dynamic_dispatch(t: &Bar) {
        t.baz();
    }
    let foo = Foo;
    static_dispatch(&foo);
    dynamic_dispatch(&foo);
}

pub fn impl_trait(){
    use std::fmt::Debug;
    pub trait Fly {
        fn fly(&self) -> bool;
    }
    #[derive(Debug)]
    struct Duck;
    #[derive(Debug)]
    struct Pig;
    impl Fly for Duck {
        fn fly(&self) -> bool {
            return true;
        }
    }
    impl Fly for Pig {
        fn fly(&self) -> bool {
            return false;
        }
    }
    fn fly_static(s: impl Fly+Debug) -> bool {
        s.fly()
    }
    fn can_fly(s: impl Fly+Debug) -> impl Fly {
        if s.fly(){
            println!("{:?} can fly", s);
        }else{
            println!("{:?} can't fly", s);
        }
        s
    }
    fn dyn_can_fly(s: impl Fly+Debug+'static) -> Box<dyn Fly> {
        if s.fly(){
            println!("{:?} can fly", s);
        }else{
            println!("{:?} can't fly", s);
        }
        Box::new(s)
    }
    let pig = Pig;
    assert_eq!(fly_static(pig), false);
    let duck = Duck;
    assert_eq!(fly_static(duck), true);

    let pig = Pig;
    can_fly(pig);
    let duck = Duck;
    can_fly(duck);

    let duck = Duck;
    dyn_can_fly(duck);
}

fn main() {
    trait_object();
    impl_trait();
}
'''
'''--- head-first/rust-trait/src/bound.rs ---
pub fn trait_bound(){
    use std::ops::Add;
//    fn sum<T: Add<T, Output=T>>(a: T, b: T) -> T{
//        a + b
//    }
    fn sum<T>(a: T, b: T) -> T where T: Add<T, Output=T> {
        a + b
    }
    assert_eq!(sum(1u32, 2u32), 3);
    assert_eq!(sum(1u64, 2u64), 3);
}

fn main() {
    trait_bound();
}
'''
'''--- head-first/rust-trait/src/interface.rs ---
pub fn generics_trait(){
    trait Add<RHS, Output> {
        fn my_add(self, rhs: RHS) -> Output;
    }
    impl Add<i32, i32> for i32 {
        fn my_add(self, rhs: i32) -> i32 {
            self + rhs
        }
    }
    impl Add<u32, i32> for u32 {
        fn my_add(self, rhs: u32) -> i32 {
            (self + rhs ) as i32
        }
    }

    let (a, b, c, d) = (1i32, 2i32, 3u32, 4u32);
    let x: i32 = a.my_add(b);
    let y: i32 = c.my_add(d);
    assert_eq!(x, 3i32);
    assert_eq!(y, 7i32);
}

fn main() {
    generics_trait();
}
'''
'''--- head-first/rust-trait/src/lib.rs ---
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}

'''
'''--- head-first/rust-trait/src/tag.rs ---
pub fn test_copy_trait(){
    fn test_copy<T: Copy>(i: T) {
        println!("hhh");
    }
    let a = "String";
    test_copy(a);
}

pub fn sync_send_trait(){
    use std::thread;
    let mut x = vec![1, 2, 3, 4];
    thread::spawn(move || x.push(1));
}

fn main() {
    test_copy_trait();
    sync_send_trait();
}
'''
'''--- head-first/src/main.rs ---
//use std::cell::Cell;
//
//fn foo(cell: &Cell<u32>) {
//    let value = cell.get();
//    cell.set(value * 2);
//}

//struct Foo {
//    x: u32,
//}
//
//fn print_foo(foo: &Foo) {
//    println!("x={}", foo.x);
//}

//fn change_foo(foo: &Foo) {
//    foo.x = foo.x *2;
//}

//fn change_foo(foo: &mut Foo) {
//    foo.x = foo.x * 2;
//}

//use std::cell::UnsafeCell;
//use std::cell::Cell;

//fn main() {

//    let mut s = String::from("hello");
//    let r1 = &mut s;
//    let r2 = &mut s; // 可变引用，不能有别名
//    println!("{}, {}", r1, r2);

//    let x = 1;
//    let y = &mut x; // 当有一个不可变值时，不能可变的借用它

//    let mut data = 1_i32;
//    let p : &i32 = &data;
//    data = 10;
//    println!("{}", *p);

//    let data : Cell<i32> = Cell::new(1);
//    let p = &data;
//    data.set(10);
//    println!("{}", p.get());
//
//    p.set(20);
//    println!("{:?}", data);

//}

//    let cell = Cell::new(0);
//    let value = cell.get();
//    let new_value = cell.get() + 1;
//    foo(&cell);
//    cell.set(new_value); // oops, we clobbered the work done by foo

// use std::thread;
// use std::time::Duration;

// fn main() {
//     let t = thread::Builder::new()
//         .name("child1".to_string())
//         .spawn(move || {
//             println!("enter child thread.");
//             thread::park();
//             println!("resume child thread");
//         }).unwrap();
//     println!("spawn a thread");
//     thread::sleep(Duration::new(5,0));
//     t.thread().unpark();
//     t.join();
//     println!("child thread finished");
// }
extern crate ring;

use ring::digest::{Algorithm, SHA512};
use merkle_tree::MerkleTree;

static ALGO: &'static Algorithm = &SHA512;

fn main() {
    let values = vec!["one", "two", "three", "four"];
    let tree = MerkleTree::new(&values, ALGO);
    let proof = tree.build_proof(&"one");
    let vec = proof.unwrap();
    tree.validate(&vec);
}

'''
'''--- head-first/std-box/example_Box.rs ---
use List::{Cons, Nil};

#[derive(Debug)]
enum List<T> {
    Cons(T, Box<List<T>>),
    Nil,
}

fn main() {
	let recursive_list: List<i32> = Cons(1, Box::new(Cons(2, Box::new(Nil))));
	println!("{:?}", recursive_list); // 打印出：Cons(1, Cons(2, Nil))
}
'''
'''--- head-first/std-box/example_Deref.rs ---
use std::ops::Deref;  

#[derive(Debug)]   
struct MyBox<T> {
    value : T,  
}

impl<T> Deref for MyBox<T> {
    type Target = T;
    
    fn deref(&self) -> &Self::Target {
        &self.value
    } 
}

fn main() {
    let instance = MyBox{value : 10};
    assert_eq!(10, *instance);
    println!("{}, {}", *instance, *(instance.deref()));
}
'''
'''--- head-first/std-box/example_TraitObject.rs ---
trait T {
    fn m(&self) -> u64;
}
  
struct S {
    i: u64
}
  
impl T for S {
    fn m(&self) -> u64 { self.i }
}

fn f(x: Box<dyn T>) {
    println!("{}", x.m())
}
  
fn main() {
    let s = S{i : 100};
    println!("{}", s.m());// 

    let b: Box<S> = Box::new(S{i: 100});
    f(b); // 动态调度
}
'''
'''--- head-first/std-cell/example_Cell.rs ---
use std::cell::Cell;

struct SomeStruct {
    regular_field: u8,
    special_field: Cell<u8>,
}

fn main() {
    let my_struct = SomeStruct {
        regular_field: 0,
        special_field: Cell::new(1),
    };

    let new_value = 100;
//    my_struct.regular_field = new_value; // ERROR: `my_struct`是不可变的

    my_struct.special_field.set(new_value); // WORKS: `special_field`是`Cell`类型的，它是可变的
    assert_eq!(my_struct.special_field.get(), new_value);
}
'''
'''--- head-first/std-cell/example_RefCell.rs ---
use std::cell::RefCell;

fn main() {
    let c = RefCell::new(5);
    *c.borrow_mut() = 7;
    assert_eq!(7, *c.borrow());

    let x = RefCell::new(vec![1,2,3]);
    println!("{:?}", x.borrow());
    x.borrow_mut().push(4);
    println!("{:?}", x.borrow());
}
'''
'''--- head-first/std-marker/example_Send_Sync.rs ---
use std::thread;
//use std::rc::Rc;
use std::sync::{Arc, Mutex};
//use std::cell::RefCell;

fn main() {
    //let mut s = Rc::new("example".to_string());
    //let s = Arc::new(RefCell::new("example".to_string()));
    let s = Arc::new(Mutex::new("example".to_string()));
    let mut v = vec![];
    for _ in 0..2 {
        //let mut s_clone = s.clone();
        let s_clone = s.clone();
        let child = thread::spawn(move || {
            let mut s_clone = s_clone.lock().unwrap();
            s_clone.push_str(" Send and Sync!");
            println!("{:?}", s_clone);
        });
        v.push(child);
    }
    for child in v {
        child.join().unwrap();
    }
    println!("{:?}", s);
}
'''
'''--- head-first/tarpc/Cargo.toml ---
[package]
name = "tarpc"
version = "0.6.0"
authors = ["Tim Kuehn <tikue@google.com>"]
edition = "2018"
license = "MIT"
documentation = "https://docs.rs/tarpc-example-service"
homepage = "https://github.com/google/tarpc"
repository = "https://github.com/google/tarpc"
keywords = ["rpc", "network", "server", "microservices", "example"]
categories = ["asynchronous", "network-programming"]
readme = "../README.md"
description = "An example server built on tarpc."

[dependencies]
clap = "2.0"
futures = "0.3"
serde = { version = "1.0" }
tarpc = { version = "0.20", features = ["full"] }
tokio = { version = "0.2", features = ["full"] }
tokio-serde = { version = "0.6", features = ["json"] }
env_logger = "0.6"

[lib]
name = "service"
path = "src/lib.rs"

[[bin]]
name = "server"
path = "src/server.rs"

[[bin]]
name = "client"
path = "src/client.rs"

'''
'''--- head-first/tarpc/src/client.rs ---
// Copyright 2018 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

use clap::{App, Arg};
use std::{io, net::SocketAddr};
use tarpc::{client, context};
use tokio_serde::formats::Json;

#[tokio::main]
async fn main() -> io::Result<()> {
    let flags = App::new("Hello Client")
        .version("0.1")
        .author("Tim <tikue@google.com>")
        .about("Say hello!")
        .arg(
            Arg::with_name("server_addr")
                .long("server_addr")
                .value_name("ADDRESS")
                .help("Sets the server address to connect to.")
                .required(true)
                .takes_value(true),
        )
        .arg(
            Arg::with_name("name")
                .short("n")
                .long("name")
                .value_name("STRING")
                .help("Sets the name to say hello to.")
                .required(true)
                .takes_value(true),
        )
        .get_matches();

    let server_addr = flags.value_of("server_addr").unwrap();
    let server_addr = server_addr
        .parse::<SocketAddr>()
        .unwrap_or_else(|e| panic!(r#"--server_addr value "{}" invalid: {}"#, server_addr, e));

    let name = flags.value_of("name").unwrap().into();

    let transport = tarpc::serde_transport::tcp::connect(server_addr, Json::default()).await?;

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let mut client = service::WorldClient::new(client::Config::default(), transport).spawn()?;

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    let hello = client.hello(context::current(), name).await?;

    println!("{}", hello);

    Ok(())
}
'''
'''--- head-first/tarpc/src/lib.rs ---
// Copyright 2018 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

/// This is the service definition. It looks a lot like a trait definition.
/// It defines one RPC, hello, which takes one arg, name, and returns a String.
#[tarpc::service]
pub trait World {
    /// Returns a greeting for name.
    async fn hello(name: String) -> String;
}
'''
'''--- head-first/tarpc/src/server.rs ---
// Copyright 2018 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

use clap::{App, Arg};
use futures::{
    future::{self, Ready},
    prelude::*,
};
use service::World;
use std::{
    io,
    net::{IpAddr, SocketAddr},
};
use tarpc::{
    context,
    server::{self, Channel, Handler},
};
use tokio_serde::formats::Json;

// This is the type that implements the generated World trait. It is the business logic
// and is used to start the server.
#[derive(Clone)]
struct HelloServer(SocketAddr);

impl World for HelloServer {
    // Each defined rpc generates two items in the trait, a fn that serves the RPC, and
    // an associated type representing the future output by the fn.

    type HelloFut = Ready<String>;

    fn hello(self, _: context::Context, name: String) -> Self::HelloFut {
        future::ready(format!(
            "Hello, {}! You are connected from {:?}.",
            name, self.0
        ))
    }
}

#[tokio::main]
async fn main() -> io::Result<()> {
    env_logger::init();

    let flags = App::new("Hello Server")
        .version("0.1")
        .author("Tim <tikue@google.com>")
        .about("Say hello!")
        .arg(
            Arg::with_name("port")
                .short("p")
                .long("port")
                .value_name("NUMBER")
                .help("Sets the port number to listen on")
                .required(true)
                .takes_value(true),
        )
        .get_matches();

    let port = flags.value_of("port").unwrap();
    let port = port
        .parse()
        .unwrap_or_else(|e| panic!(r#"--port value "{}" invalid: {}"#, port, e));

    let server_addr = (IpAddr::from([0, 0, 0, 0]), port);

    // JSON transport is provided by the json_transport tarpc module. It makes it easy
    // to start up a serde-powered json serialization strategy over TCP.
    tarpc::serde_transport::tcp::listen(&server_addr, Json::default)
        .await?
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = HelloServer(channel.as_ref().as_ref().peer_addr().unwrap());
            channel.respond_with(server.serve()).execute()
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
}
'''
'''--- simple/Cargo.toml ---
[package]
name = "simple"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

[dependencies]
rand = "0.6.5"
'''
'''--- simple/README.md ---
# Rust基础

## [概述](https://mp.weixin.qq.com/s/raM8bpGFIukWVNcR2G4pmw)

摘录片段：
Rust代码非常接近自然语言。

```Rust
5.times(|| println!("Hello Rust"));
2.days().from_now();
```

## [基本语法](https://mp.weixin.qq.com/s/okwXAj6eqB31R5mYmaqKZQ)

Rust一切皆表达式。

### 闭包

闭包语法：由管道符和花括号组合而成。管道符里是闭包函数的参数，花括号里是函数执行体。参数类型，花括号和返回值均可省略。示例如下：

```Rust
|a: i32, b: i32| -> i32 { a + b }
```

* Fn, 调用参数为&self，表示闭包以不可变借用的方式捕获环境中的自由变量，可以多次调用
* FnMut, 调用参数为&mut self，表示闭包以可变借用的方式捕获环境中的自由变量，可以多次调用
* FnOnce，调用参数为self，表示闭包通过转移所有权方式捕获环境中的自由变量，会消耗自己，只能调用一次

个人觉得闭包这种语法糖降低了代码的可读性，一段好的代码，要有良好的阅读体验，而不是写的时候方便。

## [数据类型](https://mp.weixin.qq.com/s/wSqRC-h-RsiNbUuPNVaLMw)

利用元组，函数可以返回多个值。

什么是字符串？

Rust原始的字符串类型：`str`，它是固定长度的。

字符串切片slice：`&str`，它是储存在别处的UTF-8编码字符串数据的引用。

而称作`String`类型的字符串是由标准库提供的，它是可增长的、可变长度的、有所有权的、UTF-8编码的字符串类型。

## [核心概念](https://mp.weixin.qq.com/s/BqtbSUkOZ-DSbv3Mt2UdrQ)

### 类型系统

Rust是一门强类型且类型安全的静态语言。

一个类型系统允许一段代码在不同上下文中具有不同的类型，多态类型系统。三种多态方式：

* 参数化多态，泛型
* 子类型多态，面向对象语言，Java中的继承概念
* 特定多态，同一行为定义，不同上下文中有不同的行为实现，函数重载

`trait`的概念：它是Rust中提供的一种实现特定多态的方法，类似于其他语言中的接口（interfaces）。

### 所有权系统

所有权的规则：

* Rust中的每一个值，都有一个被称为其所有者（owner）的变量
* 值有且只有一个所有者
* 当所有者（变量）离开作用域，这个值将被丢弃

所有权转移，一个值的所有权被转移给另外一个变量绑定的过程。

复制语义和移动语义来对应值语义和引用语义。实现`Copy trait`的类型拥有复制语义。

移动move语义：一个旧的变量（数据存在堆上）在将其赋值给其他变量后，意味着它的所有权被移动了。

### 模块系统

包`crate`的概念：crate代表一个二进制或库项目，用crate root来描述如何构建这个crate的文件。

### 错误处理

使用`Result`类型来处理潜在的错误。Result枚举，它定义有两个成员，Ok和Err：

```Rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

## 练习代码

* [表达式](./src/statement.rs)
* [变量](./src/variable.rs)
* [函数](./src/function.rs)
* [流程控制](./src/control_flow.rs)
* [原始类型](./src/primitives.rs)
* [集合类型](./src/collections.rs)
* [类型系统](./src/generics_trait.rs)
* [所有权系统]()
'''
'''--- simple/function/Cargo.toml ---
[package]
name = "function"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

'''
'''--- simple/function/src/main.rs ---
/// 函数作为参数
pub fn math(op: fn(i32, i32) -> i32, a: i32, b: i32) -> i32 {
    op(a,b)
}
fn sum(a: i32, b: i32) -> i32 {
    a + b
}
fn product(a: i32, b: i32) -> i32 {
    a * b
}

/// 函数作为返回值
fn is_true() -> bool { true }
pub fn true_maker() -> fn() -> bool { is_true }

/// CTFE编译时函数执行
const fn init_len() -> usize { return 5; }

/// 匿名函数闭包作为参数
fn closure_math<F: Fn() -> i32>(op: F) -> i32 {
    // 通过添加一对圆括号，调用传入的闭包
    op()
}

/// 匿名函数闭包作为返回值
fn two_times_impl() -> impl Fn(i32) -> i32 {
    let i = 2;
    // 使用 move 转移变量 i 的所有权，避免悬挂指针，安全返回闭包
    move |j| j * i
}

/// geektime: function
fn apply(value: i32, f: fn(i32) -> i32) -> i32 {
    f(value)
}

fn square(value: i32) -> i32 {
    value * value
}

fn cube(value: i32) -> i32 {
    value * value * value
}

fn pi() -> f64 {
    3.1415925
}

fn not_pi() {
    // 如果最后一个表达式后添加了; 分号，隐含其返回值为 unit
    3.1425926;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fn_return() {
        assert_eq!(pi(), 3.1415925);
        assert_eq!(not_pi(), ());
    }

    #[test]
    fn test_apply() {
        assert_eq!(apply(2, square), 4);
        assert_eq!(apply(2, cube), 8);
    }

    #[test]
    fn test_math() {
        assert_eq!(math(sum, 2, 3), 5);
        assert_eq!(math(product, 2, 3), 6);
    }
}

fn main() {
    println!("is_pi: {:?}, is_unit1: {:?}", pi(), not_pi());

    println!("apply square: {}", apply(2, square));
    println!("apply cube: {}", apply(2, cube));

    // 默认函数名是函数类型，参数显式指定了函数的类型，被转换成函数指针类型
    let a = 2;
    let b = 3;
    println!("2+3={}", math(sum, a, b));
    println!("2*3={}", math(product, a, b));
    
    // 返回函数指针
    println!("return {:p}", true_maker());
    // 函数指针加上括号，就会调用该函数
    println!("return {}", true_maker()());

    // 数组的长度是编译时常量，必须在编译时确定其值
    let arr = [0; init_len()];
    println!("array length is {}", arr.len());

    let out = 42;
    // add 函数内使用外部定义的变量 out，编译器会报错
    // fn add(i: i32, j: i32) -> i32 { i + j + out }
    // 匿名函数，闭包可捕获外部变量 out
    let closure_annotated = |i: i32, j: i32| -> i32 { i + j + out };
    // 闭包自动推断输入和返回类型，个人觉得可读性不好
    let closure_inferred = |i, j| i + j + out;
    let i = 1;
    let j = 2;
    println!("closure annotated: 1+2+42={}", closure_annotated(i, j));
    println!("closure inferred: 1+2+42={}", closure_inferred(i, j));

    // 传入闭包：|| a + b
    println!("closure: 2+3={}", closure_math(|| a + b));
    // 传入闭包：|| a * b
    println!("closure: 2*3={}", closure_math(|| a * b));
    
    let result = two_times_impl();
    println!("closure: 2's two times is {}", result(2));
}
'''
'''--- simple/httpie/Cargo.toml ---
[package]
name = "httpie"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = "1.0"
clap = { version = "4.4.6", features = ["derive"] }
colored = "2.0.4"
mime = "0.3.17"
reqwest = { version = "0.11", features = ["json"] }
tokio = { version = "1", features = ["full"] }
syntect = "5.0"
'''
'''--- simple/httpie/src/main.rs ---
use anyhow::{anyhow, Result};
use clap::{Args, Parser, Subcommand};
use colored::*;
use mime::Mime;
use reqwest::{header, Client, Response, Url};
use std::{collections::HashMap, str::FromStr};
use syntect::{
    easy::HighlightLines,
    highlighting::{ThemeSet, Style},
    parsing::SyntaxSet,
    util::{as_24_bit_terminal_escaped, LinesWithEndings},
};

#[derive(Parser, Debug)]
struct Opts {
    #[command(subcommand)]
    cmd: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Get(Get),
    Post(Post),
}

#[derive(Args, Debug)]
struct Get {
    #[arg(value_parser = parse_url)]
    url: String,
}

#[derive(Args, Debug)]
struct Post {
    #[arg(value_parser = parse_url)]
    url: String,
    #[arg(value_parser = parse_kv_pair)]
    body: Vec<KvPair>,
}

#[derive(Clone, Debug, PartialEq)]
struct KvPair {
    k: String,
    v: String,
}

impl FromStr for KvPair {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut split = s.split('=');
        let err = || anyhow!(format!("Failed to parse {}", s));

        Ok(Self {
            k: (split.next().ok_or_else(err)?).to_string(),
            v: (split.next().ok_or_else(err)?).to_string(),
        })
    }
}

fn parse_kv_pair(s: &str) -> Result<KvPair> {
    s.parse()
}

fn parse_url(s: &str) -> Result<String> {
    let _url: Url = s.parse()?;

    Ok(s.into())
}

async fn get(client: Client, args: &Get) -> Result<()> {
    let resp = client.get(&args.url).send().await?;
    println!("{:?}", resp.text().await?);

    Ok(())
}

async fn post(client: Client, args: &Post) -> Result<()> {
    let mut body = HashMap::new();
    for pair in args.body.iter() {
        body.insert(&pair.k, &pair.v);
    }
    
    let resp = client.post(&args.url).json(&body).send().await?;
    
    Ok(print_resp(resp).await?)
}

fn print_status(resp: &Response) {
    let status = format!("{:?} {}", resp.version(), resp.status()).blue();
    println!("{}\n", status);
}

fn print_headers(resp: &Response) {
    for (name, value) in resp.headers() {
        println!("{}: {:?}", name.to_string().green(), value);
    }
    print!("\n");
}

fn print_body(m: Option<Mime>, body: &String) {
    match m {
        Some(v) if v == mime::APPLICATION_JSON => print_syntect(body, "json"),
        Some(v) if v == mime::TEXT_HTML => print_syntect(body, "html"),

        _ => println!("{}", body),
    }
}

fn print_syntect(s: &str, ext: &str) {
    // Load these once at the start of your program
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();
    let syntax = ps.find_syntax_by_extension(ext).unwrap();
    let mut h = HighlightLines::new(syntax, &ts.themes["base16-ocean.dark"]);
    for line in LinesWithEndings::from(s) {
        let ranges: Vec<(Style, &str)> = h.highlight_line(line, &ps).unwrap();
        let escaped = as_24_bit_terminal_escaped(&ranges[..], true);
        print!("{}", escaped);
    }
}

fn get_content_type(resp: &Response) -> Option<Mime> {
    resp.headers()
        .get(header::CONTENT_TYPE)
        .map(|v| v.to_str().unwrap().parse().unwrap())
}

async fn print_resp(resp: Response) -> Result<()> {
    print_status(&resp);
    print_headers(&resp);
    let mime = get_content_type(&resp);
    let body = resp.text().await?;
    print_body(mime, &body);

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let opts: Opts = Opts::parse();
    println!("{:?}", opts);
    let client = Client::new();
    let result = match opts.cmd {
        Commands::Get(ref args) => get(client, args).await?,
        Commands::Post(ref args) => post(client, args).await?,
    };

    Ok(result)
}
'''
'''--- simple/src/collections.rs ---
use std::collections::HashMap;

// 统计一些文本中每一个单词分别出现了多少次
fn count_word() {
    let text = "hello world wonderful world";
    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }
    println!("count {:?}", map);
}

fn vector_example() {
    let v: Vec<i32> = Vec::new();
    println!("vec size {}", v.len());
    let mut v = Vec::new();
    v.push(8);
    println!("after push vec size {}", v.len());
    let v = vec![1, 2];
    println!("vec get element {}", &v[0]);
    for i in &v {
        println!("vec each item {}", i);
    }
}

fn hashmap_example() {
    let mut hmap = HashMap::new();
    hmap.insert("one", 1);
    hmap.insert("one", 2);
    for (key, value) in &hmap {
        println!("init hashmap {}: {}", key, value);
    }
    {
        let val = hmap.entry("two").or_insert(3);
        println!("insert {}", val);
    }
    println!("after insert hashmap {:?}", hmap);
}

fn string_example() {
    let mut s = String::from("str");
    s.push_str("add");
    println!("s {}", s);
    for c in s.chars() {
        println!("char {}", c);
    }
}

fn overlap() {
    let a = [1, 2, 3];
    let b = [1, 2, 3, 4];

    let c: Vec<i32> = a.iter().zip(&b).map(|(a, b)| a & b).collect();
    println!("overlap {:?}", c);    
}

fn bunch_of_numbers() -> Vec<u32> {
    (0..10).collect()
}

fn new_vector_example() {
    let nums = bunch_of_numbers();

    match nums.last() {
        Some(&0) => println!("Last number is zero"),
        Some(n) => println!("Last number is {}", n),
        None => println!("There are no numbers"),
    }
}

fn slices_example() {
    let mut foo = [0u8; 5];
    foo[1] = 1;
    foo[2] = 2;

    let bar = &foo[..3];
    println!("{:?}", bar);
}

fn main() {
    vector_example();
    hashmap_example();
    string_example();
    count_word();
    overlap();
    new_vector_example();
    slices_example();
}
'''
'''--- simple/src/control_flow.rs ---
/**
 * 条件表达式
 */
pub fn if_expr(x: i32) -> i32 {
    let n = if x < 10 && x > -10 {
        10 * x
    } else {
        // 如果传入奇数，返回类型为i32，编译器是否会报错？
        x / 2
    };
    return n;
}

/**
 * 循环表达式 while
 */
pub fn while_expr() {
    let mut n = 1;
    while n < 16 {
        if n % 15 == 0 {
            println!("3 and 5‘s multiple {}", n);
        } else if n % 5 == 0 {
            println!("5‘s multiple {}", n);
        }
        n += 1;
    }
}

/**
 * 循环表达式 loop
 */
pub fn loop_expr() {
    let mut n = 1;
    loop {
        if n % 15 == 0 {
            println!("3 and 5‘s multiple {}", n);
        } else if n % 3 == 0 {
            println!("3‘s multiple {}", n);
        } else if n > 16 {
            break;
        }
        n += 1;
    }
}

/**
 * 循环表达式 for...in
 */
pub fn for_expr() {
    for n in 1..16 {
        if n % 15 == 0 {
            println!("3 and 5‘s multiple {}", n);
        } else if n % 5 == 0 {
            println!("5‘s multiple {}", n);
        }
    }
}

/**
 * match表达式
 */
pub fn match_expr(n: i32) {
    match n {
        0 => println!("match number"),
        1...3 => println!("match range"),
        | 5 | 7 | 13  => println!("match branch"),
        n @ 42 => println!("binding {}", n),
        _ => println!("default"),
    }
}

/**
 * while let表达式
 */
pub fn while_let_pop() {
    let mut v = vec![1,2,3];
    // 动态数组的pop方法会返回Option类型，数组被取空会返回None
    // 使用match表达式，需要匹配两种情况：Some(x)和None
    while let Some(x) = v.pop() {
        println!("{}", x);
    }
}

fn main() {
    let x = 13;
    // Rust编译器根据上下文，会将结果截取
    println!("result={}", if_expr(x));

    while_expr();
    loop_expr();
    for_expr();

    let mut n = 2;
    match_expr(n);
    n = 5;
    match_expr(n);
    n = 42;
    match_expr(n);
    n = 100;
    match_expr(n);

    while_let_pop();
}
'''
'''--- simple/src/error_handling.rs ---
fn add_numbers(numbers: &[i32]) -> i32 {
    let a = numbers[0];
    let b = numbers[1];

    a + b
}

fn add_numbers_with_option(numbers: &[i32]) -> Option<i32> {
    let a = numbers.get(0)?; // `get` return Option<i32>
    let b = numbers.get(1)?; // ? will early return on None
    // consider dereferencing the borrow: `*b`
    a.checked_add(*b) // returns None on overflow
}

fn main() {
    let arr_normal: [i32; 3] = [1, 2, 3];
    println!("addition: {}",add_numbers(&arr_normal));
    let arr_max: [i32; 3] = [std::i32::MAX, 2, 3];
    // thread 'main' panicked at 'attempt to add with overflow'
    // println!("addition: {}",add_numbers(&arr_max));
    println!("addition: {:?}",add_numbers_with_option(&arr_max));
}
'''
'''--- simple/src/generics_trait.rs ---
/**
 * 找数字列表中最大的数字
 */
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }
    largest
}

/**
 * 泛型实现找列表中最大值
 */
fn generics_largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    &largest
}

// 结构体泛型
struct Point<T, U> {
    x: T,
    y: U,
}

// 方法中定义泛型，必须在 impl 后面声明 T
impl<T, U> Point<T, U> {
    fn x(&self) -> &T {
        &self.x
    }

    // 结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

/**
 * trait
 */
trait Arithmetic {
    fn add(&self) -> i32;
}

struct MyPoint {
    x: i32,
    y: i32,
}

// 为类型实现trait
impl Arithmetic for MyPoint {
    fn add(&self) -> i32 {
        self.x + self.y
    }
}

// trait 作为参数
fn sum(item: impl Arithmetic) {
    println!("sum {}", item.add());
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = generics_largest(&char_list);
    println!("The largest char is {}", result);

    let p = Point { x: 5, y: 1.0 };
    println!("p.x = {}", p.x());

    let p2 = Point { x: "Hello", y: 'c'};
    let p3 = p.mixup(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);

    let mp = MyPoint { x: 5, y: 10 };
    println!("mp.x + mp.y: {}", mp.add());

    sum(mp);
}
'''
'''--- simple/src/main.rs ---
// guess game from TRLB 
extern crate rand;

use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let rand_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("Your guess {}", guess);

        match guess.cmp(&rand_number) {
            Ordering::Less => println!("Too small"),
            Ordering::Greater => println!("Too big"),
            Ordering::Equal => {
                println!("You win");
                break;
            }
        }
    }
}

'''
'''--- simple/src/primitives.rs ---
fn array_example () {

    // 创建数组方式一：[x, y, z]
    let arr: [i32; 3] = [1, 2, 3];
    let mut mut_arr = [4, 5, 6];
    mut_arr[0] = 0;

    assert_eq!(3, arr[2]);
    assert_eq!(0, mut_arr[0]);
    // 这个循环输出: 1 2 3
    for x in &arr {
        print!("{} ", x);
    }
    println!();

    // 创建数组方式二：[x; N]
    let mut array: [i32; 3] = [0; 3];
    array[1] = 1;
    array[2] = 2;

    assert_eq!([1, 2], &array[1..]);
    // 元素个数小于等于32的数组，实现了`trait IntoIterator`
    // 这个循环输出: 0 1 2
    for x in &array {
        print!("{} ", x);
    }
    println!();

    let array: [i32; 33] = [0; 33];
    // error[E0277]: `&[i32; 33]` is not an iterator
//    for x in &array {
//        print!("{} ", x);
//    }
    // 通过调用slice方法将数组强制类型转换为slice
    for x in array.iter() {
        print!("{} ", x);
    }
    println!();
}

fn tuple_example() {
    let tup: (u8, i32, f64) = (1, 100, 1.1314);
    let (x, y, z) = tup;
    let f_number = tup.2;
    let one_tup = (1.1,);
    println!("elements in tuple {},{},{}", x, y, z);
    println!("third element in tuple {}", f_number);
    println!("one element in tuple {}", one_tup.0);
}

fn struct_example() {
    struct Person {
        age: u8,
        is_child: bool,
    }
    struct OnePerson(u8, bool);
    struct UnitStruct;
    let alice = Person {age: 10, is_child: true};
    let bob = OnePerson(32, false);
    let x = UnitStruct;
    println!("alice age {} is child {}", alice.age, alice.is_child);
    println!("bob age {} is child {}", bob.0, bob.1);
    println!("unit struct {:p}", &x);

    impl Person {
        fn create_person(age: u8, is_child: bool) -> Person {
            Person{age, is_child}
        }
        fn check_child(&self) -> bool {
            if self.is_child && self.age < 18 {
                return true;
            } else {
                return false;
            }
        }
    }
    let peter = Person::create_person(33, true);
    println!("peter age {} is child {}", peter.age, peter.is_child);
    println!("peter is child {}", peter.check_child());
}

fn enum_example() {
    enum Number {
        Integer(i64),
        Float {
            inner: f64
        },
    }
    let a = Number::Integer(10);
    let b = Number::Float {
        inner: 3.14
    };
    match a {
        Number::Integer(n) => println!("a is integer: {}", n),
        Number::Float {inner} => println!("a is float: {}", inner),
    }
    if let Number::Float { inner } = b {
        println!("b is float: {}", inner);
    }
}

fn basic_example() {
    // 布尔类型
    let a_boolean: bool = true;

    // 数值类型
    let a_float: f32 = 1.0;  // 变量常规声明
    let an_integer   = 6i16; // 变量后缀声明

    // 可根据上下文自动推断类型
    let mut inferred_type = 8; // 根据下一行的赋值推断为i64类型
    inferred_type = 64i64;

    // 无法类型推断时，按默认方式取类型
    let default_float   = 2.0; // 浮点数值为f64
    let default_integer = 5;   // 整型数值为i32

    // 字符类型
    let a_char: char = 'a';
}

fn main() {
    array_example();
    tuple_example();
    struct_example();
    enum_example();
    basic_example();
}
'''
'''--- simple/src/statement.rs ---
fn main() {
    pub fn answer() -> () {
        // 声明语句
        let a = 40;
        let b = 2;
        // 表达式语句：以分号结尾的表达式
        // println! 宏语句：名字以叹号结尾，并像函数一样被调用
        println!("40 + 2 = {}", sum(a, b));
    }
    /// 求和函数
    pub fn sum(a: i32, b: i32) -> i32 {
        // 表达式，无分号返回求值结果
        a + b
        // Rust中不用return关键字，从代码可读性是否加上好些？
        // return a + b;
    }
    answer();
}
'''
'''--- simple/src/tcp_server_example.rs ---
// 引入相关的Rust标准库std
use std::thread;
use std::net::{TcpListener, TcpStream, Shutdown};
use std::io::{Read, Write};

// 处理tcp客户端的函数
fn handle_client(mut stream: TcpStream) {
    // 初始化100字节
    let mut data = [0 as u8; 100];
    // 读取客户端的数据
    while match stream.read(&mut data) {
        Ok(size) => {
            // 将客户端的数据echo返回
            stream.write(&data[0..size]).unwrap();
            true
        },
        Err(_) => {
            println!("An error occurred, terminating connection with {}", stream.peer_addr().unwrap());
            stream.shutdown(Shutdown::Both).unwrap();
            false
        }
    } {}
}

// 主函数
fn main() {
    // 监听本机的6666端口
    let listener = TcpListener::bind("127.0.0.1:6666").unwrap();
    // 打印提示信息
    println!("Server listening on port 6666");
    // 监听每个连接
    for stream in listener.incoming() {
        match stream {
            // 连接成功
            Ok(stream) => {
                println!("New connection: {}", stream.peer_addr().unwrap());
                // 启动线程
                thread::spawn(move|| {
                    // 调用handle_client函数处理tcp连接
                    handle_client(stream)
                });
            }
            // 连接失败
            Err(e) => {
                println!("Error: {}", e);
            }
        }
    }
    // 关闭socket
    drop(listener);
}
'''
'''--- simple/src/test.rs ---
/// There's a room with a TV and people are coming in and out to watch it. 
/// The TV is on only when there's at least a person in the room.
/// For each person that comes in, we record the start and end time. 
/// We want to know for how long the TV has been on. 
/// In other words:Given a list of arrays of time intervals, 
/// write a function that calculates the total amount of time covered by the intervals.
///```rust
///input = [(1,4), (2,3)]> 3    input = [(4,6), (1,2)]> 3   
///input = [(1,4), (6,8), (2,4), (7,9), (10, 15)]> 11
///```

/// 时间段类型
type TimeIntervals = (i32, i32);

/// 合并有重叠的时间段
fn merge_intervals(input: &[TimeIntervals]) -> Vec<TimeIntervals> {
    let mut output: Vec<TimeIntervals> = Vec::new();
    let mut j = 0;
    let mut current_end = 0;
    for i in 0..input.len() {
        if input[i].1 > current_end {
            current_end = input[i].1;
        }
        println!("j {:?}", &j);
        if i == (input.len() - 1) || input[i+1].0 > current_end {
            output.push((input[j].0, current_end));
            j = i + 1; // 
        }
        println!("current_end {:?}", &current_end);   
    }
    output
}

/// 累加时间段
fn sum_time_interval(input: &TimeIntervals) -> i32 {
    input.1 - input.0
}

fn main() {
    //let mut input = [(1,4), (2,3)];
    //let mut input = [(4,6), (1,2)];
    let mut input = [(1,4), (6,8), (2,4), (7,9), (10,15), (2,6)];
    //let mut input = [(1,3), (2,6), (8,10), (15,18)];
    input.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
    println!("sorted input {:?}", &input);
    
    let merged_input = merge_intervals(&input);
    println!("merged input {:?}", &merged_input);

    let mut sum = 0;
    for item in &merged_input {
        sum = sum + sum_time_interval(item);
    }
    println!("finally sum {:?}", sum);
}
'''
'''--- simple/src/time_intervals.rs ---
/// There's a room with a TV and people are coming in and out to watch it. 
/// The TV is on only when there's at least a person in the room.
/// For each person that comes in, we record the start and end time. 
/// We want to know for how long the TV has been on. 
/// In other words:Given a list of arrays of time intervals, 
/// write a function that calculates the total amount of time covered by the intervals.
///```rust
///input = [(1,4), (2,3)]> 3    input = [(4,6), (1,2)]> 3   
///input = [(1,4), (6,8), (2,4), (7,9), (10, 15)]> 11
///``` 

/// 时间段类型
type TimeIntervals = (i32, i32);

/// 合并有重叠的时间段
fn merge_intervals(input: &[TimeIntervals]) -> Vec<TimeIntervals> {
    let mut output: Vec<TimeIntervals> = Vec::new();
    let mut j = 0;
    let mut current_end = 0;
    for i in 0..input.len() {
        if input[i].1 > current_end {
            current_end = input[i].1;
        }
        println!("j {:?}", &j);
        if i == (input.len() - 1) || input[i+1].0 > current_end {
            output.push((input[j].0, current_end));
            j = i + 1; // 
        }
        println!("current_end {:?}", &current_end);   
    }
    output
}

/// 累加时间段
fn sum_time_interval(input: &TimeIntervals) -> i32 {
    input.1 - input.0
}

fn main() {
    //let mut input = [(1,4), (2,3)];
    //let mut input = [(4,6), (1,2)];
    let mut input = [(1,4), (6,8), (2,4), (7,9), (10,15), (2,6)];
    //let mut input = [(1,3), (2,6), (8,10), (15,18)];
    input.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
    println!("sorted input {:?}", &input);
    
    let merged_input = merge_intervals(&input);
    println!("merged input {:?}", &merged_input);

    let mut sum = 0;
    for item in &merged_input {
        sum = sum + sum_time_interval(item);
    }
    println!("finally sum {:?}", sum);
}
'''
'''--- simple/src/variable.rs ---
const INT1: i32 = 1;
const BIT2: u32 = 1 << 1;
const STRING: &'static str = "String";

static RUST: &'static str = "Rust";
static mut MUT_INT: i32 = 1;

#[derive(Debug)]
struct BitString<'a> {
    mybit: u32,
    mystring: &'a str,
}

const BIT_STRING: BitString<'static> = BitString {
    mybit: BIT2,
    mystring: STRING,
};

fn is_big(n: i32) -> bool {
    // 在一般函数中访问常量
    n > INT1
}

fn main() {
    // 在 main 函数中访问常量
    println!("{:?}", INT1);
    println!("{:?}", BIT2);
    println!("{:?}", STRING);
    println!("{:#?}", BIT_STRING);

    // 报错！不能修改一个 `const` 常量
    INT1 = 5;
    let n = 4;
    println!("{} is {}", n, if is_big(n) { "big" } else { "small" });

    MUT_INT = 5;

    let a = 1;
    // 默认不可变绑定，不能重新赋值
    // a = 2;
    // 可使用mut关键字，创建可变绑定
    println!("a {:p}", &a);
    let mut b = 2;
    b = 3;
    println!("b was changed: {}", b);
    
    // 变量遮蔽：连续定义同名变量
    let s = "Hello Rust";
    let s = "Hello World";
    // 变量生命周期，词法作用域
    {
        let s = "Hello Rust";
    }
    println!("s is {}", s);

    pub fn tmp() -> i32 {
        return 1;
    }
    // 借用操作符&，获取表达式内存地址
    let x = &tmp();
    // 值表达式不能出现在位置上下文中，E0070
    // tmp() = *x;
    println!("x is memory address: {:p}", x);
    // 声明动态数组，vec!
    let mut c = vec![1,2,3];
    // 使用借用操作符&，得到引用类型
    let d = &mut c;
    d.push(4);
    println!("{:?}", d);
    // 字面常量是值表达式，在位置上下文中求值创建临时值
    let e = &42;
    // 使用解引用操作符*，取得引用中的值
    println!("reference e's value is {}", *e)
}
'''
'''--- simple/string/print.c ---
// in `print.c`

#include <stdio.h> // printf
#include <stdint.h> // uint8_t

void print_spaced(char *s) {
    // start at the beginning
    int i = 0;

    while (1) {
        // we're going to be shifting bytes around,
        // so treat them like unsigned 8-bit values
        uint8_t c = s[i];
        if (c == 0) {
            // reached null terminator, stop printing
            break;
        }

        // length of the sequence, ie., number of bytes
        // that encode a single Unicode scalar value
        int len = 1;
        if (c >> 5 == 0b110) {
            len = 2;
        } else if (c >> 4 == 0b1110) {
            len = 3;
        } else if (c >> 3 == 0b11110) {
            len = 4;
        }

        // print the entire UTF-8-encoded Unicode scalar value
        for (; len > 0; len--) {
            printf("%c", s[i]);
            i++;
        }
        // print space separator
        printf(" ");
    }
}

int main(int argc, char **argv) {
    for (int i = 1; i < argc; i++) {
        print_spaced(argv[i]);
        printf("\n");
    }

    return 0;
}
'''
'''--- simple/string/print.js ---
// in `print.js`

const { argv, stdout } = process;

// we have to skip *two* arguments: the path to node,
// and the path to our script
for (const arg of argv.slice(2)) {
    stdout.write(arg.toUpperCase());
    stdout.write("\n");
}
'''
'''--- simple/string/rustre/Cargo.toml ---
[package]
name = "rustre"
version = "0.1.0"
authors = ["lesterli <lester123@live.cn>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

'''
'''--- simple/string/rustre/src/main.rs ---
fn main() {
    let mut upp = String::with_capacity(512);
    for arg in std::env::args().skip(1) {
        upp.clear();
        uppercase(&arg, &mut upp);
        println!("upp = {}", upp);
        println!("arg = {}", arg);
    }
}

// was `mut dst: String`
fn uppercase(src: &str, dst: &mut String) {
    for c in src.chars() {
        for c in c.to_uppercase() {
            dst.push(c);
        }
    }
}
'''
'''--- simple/string/upper.c ---
// in `upper.c`

#include <stdio.h> // printf
#include <stdint.h> // uint8_t, uint32_t
#include <stdlib.h> // exit

void encode_utf8(uint32_t *src, char *dst) {
    int i = 0;
    int j = 0;

    while (1) {
        uint32_t scalar = src[i];

        if (scalar == 0) {
            dst[j] = 0; // null terminator
            break;
        }

        if (scalar > 0b11111111111) {
            fprintf(stderr, "Can only encode codepoints <= 0x%x", 0b11111111111);
            exit(1);
        }

        if (scalar > 0b1111111) { // 7 bits
            // 2-byte sequence

            uint8_t b1 = 0b11000000 | ((uint8_t) ((scalar & 0b11111000000) >> 6));
            //           2-byte marker              first 5 of 11 bits

            uint8_t b2 = 0b10000000 | ((uint8_t) (scalar & 0b111111));
            //           continuation               last 6 of 11 bits  

            dst[j + 0] = b1;
            dst[j + 1] = b2;
            j += 2;
        } else {
            // 1-byte sequence
            dst[j] = (char) scalar;
            j++;
        }

        i++;
    }
}

void decode_utf8(char *src, uint32_t *dst) {
    int i = 0;
    int j = 0;

    while (1) {
        uint8_t c = src[i];
        if (c == 0) {
            dst[j] = 0;
            break; // null terminator
        }

        uint32_t scalar;
        int len;

        if (c >> 3 == 0b11110) {
            fprintf(stderr, "decode_utf8: 4-byte sequences are not supported!\n");
            exit(1);
        } if (c >> 4 == 0b1110) {
            fprintf(stderr, "decode_utf8: 3-byte sequences are not supported!\n");
            exit(1);
        } else if (c >> 5 == 0b110) {
            // 2-byte sequence
            uint32_t b1 = (uint32_t) src[i];
            uint32_t b2 = (uint32_t) src[i + 1];
            uint32_t mask1 = 0b0000011111000000;
            uint32_t mask2 = 0b0000000000111111;

            scalar = ((b1 << 6) & mask1) | ((b2 << 0) & mask2);
            len = 2;
        } else {
            // 1-byte sequence
            scalar = (uint32_t) c;
            len = 1;
        }
        dst[j++] = scalar;
        i += len;
    }
}

#include <ctype.h> // toupper

int main(int argc, char **argv) {
    uint32_t scalars[1024]; // hopefully that's enough
    decode_utf8(argv[1], scalars);

    for (int i = 0;; i++) {
        if (scalars[i] == 0) {
            break;
        }
        printf("U+%04X ", scalars[i]);
    }
    printf("\n");

    // this is the highest codepoint we can decode/encode successfully
    const size_t table_size = 0b11111111111;
    uint32_t lower_to_upper[table_size];
    // initialize the table to just return the codepoint unchanged
    for (uint32_t cp = 0; cp < table_size; cp++) {
        lower_to_upper[cp] = cp;
    }
    // set a-z => A-Z
    for (int c = 97; c <= 122; c++) { // ha.
        lower_to_upper[(uint32_t) c] = (uint32_t) toupper(c);
    }

    // note: nested functions is a GNU extension!
    void set(char *lower, char *upper) {
        uint32_t lower_s[1024];
        uint32_t upper_s[1024];
        decode_utf8(lower, lower_s);
        decode_utf8(upper, upper_s);
        for (int i = 0;; i++) {
            if (lower_s[i] == 0) {
                break;
            }
            lower_to_upper[lower_s[i]] = upper_s[i];
        }
    }
    // set a few more
    set(
        "éêèàâëüöïÿôîçæœ",
        "ÉÊÈÀÂËÜÖÏŸÔÎÇÆŒ"
    );

    // now convert our scalars to upper-case
    for (int i = 0;; i++) {
        if (scalars[i] == 0) {
            break;
        }
        scalars[i] = lower_to_upper[scalars[i]];
    }

    uint8_t result[1024]; // yolo
    encode_utf8(scalars, result);

    printf("%s\n", result);

    return 0;
}
'''
'''--- simple/string/woops.c ---
// in `woops.c`

#include <stdio.h>
#include <ctype.h>

void uppercase(char *s) {
    // this is peak C right there
    do {
        *s = toupper(*s);
    } while (*s++);
}

int main(int argc, char **argv) {
    char *arg = argv[1];

    char *upp = arg;
    uppercase(upp);

    printf("upp = %s\n", upp);
}
'''