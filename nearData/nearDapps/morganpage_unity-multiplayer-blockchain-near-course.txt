*GitHub Repository "morganpage/unity-multiplayer-blockchain-near-course"*

'''--- .vscode/settings.json ---
﻿{
    "files.exclude":
    {
        "**/.DS_Store":true,
        "**/.git":true,
        "**/.gitmodules":true,
        "**/*.booproj":true,
        "**/*.pidb":true,
        "**/*.suo":true,
        "**/*.user":true,
        "**/*.userprefs":true,
        "**/*.unityproj":true,
        "**/*.dll":true,
        "**/*.exe":true,
        "**/*.pdf":true,
        "**/*.mid":true,
        "**/*.midi":true,
        "**/*.wav":true,
        "**/*.gif":true,
        "**/*.ico":true,
        "**/*.jpg":true,
        "**/*.jpeg":true,
        "**/*.png":true,
        "**/*.psd":true,
        "**/*.tga":true,
        "**/*.tif":true,
        "**/*.tiff":true,
        "**/*.3ds":true,
        "**/*.3DS":true,
        "**/*.fbx":true,
        "**/*.FBX":true,
        "**/*.lxo":true,
        "**/*.LXO":true,
        "**/*.ma":true,
        "**/*.MA":true,
        "**/*.obj":true,
        "**/*.OBJ":true,
        "**/*.asset":true,
        "**/*.cubemap":true,
        "**/*.flare":true,
        "**/*.mat":true,
        "**/*.meta":true,
        "**/*.prefab":true,
        "**/*.unity":true,
        "build/":true,
        "Build/":true,
        "Library/":true,
        "library/":true,
        "obj/":true,
        "Obj/":true,
        "ProjectSettings/":true,
        "temp/":true,
        "Temp/":true
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Extension/ILProcessorExtensions.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using MonoFN.Cecil.Cil;

namespace FishNet.CodeGenerating.Extension
{

    internal static class ILProcessorExtensions
    {
        /// <summary>
        /// Creates a variable type within the body and returns it's VariableDef.
        /// </summary>
        internal static VariableDefinition CreateVariable(this ILProcessor processor, System.Type variableType)
        {
            return processor.Body.Method.CreateVariable(variableType);
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Extension/TypeDefinitionExtensions.cs ---
﻿
using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using MonoFN.Cecil;
using UnityEngine;

namespace FishNet.CodeGenerating.Extension
{

    internal static class TypeDefinitionExtensions
    {
        /// <summary>
        /// Returns a method in the next base class.
        /// </summary>
        public static MethodReference GetMethodReferenceInBase(this TypeDefinition td, string methodName)
        {
            if (td == null)
            {
                CodegenSession.LogError($"TypeDefinition is null.");
                return null;
            }
            if (td.BaseType == null)
            {
                CodegenSession.LogError($"BaseType for {td.FullName} is null.");
                return null;
            }

            TypeDefinition baseTd = td.BaseType.CachedResolve();
            MethodDefinition baseMd = baseTd.GetMethod(methodName);
            //Not found.
            if (baseMd == null)
                return null;

            //Is generic.
            if (baseTd.HasGenericParameters)
            {
                TypeReference baseTr = td.BaseType;
                GenericInstanceType baseGit = (GenericInstanceType)baseTr;

                CodegenSession.ImportReference(baseMd.ReturnType);
                MethodReference mr = new MethodReference(methodName, baseMd.ReturnType)
                {
                    DeclaringType = baseGit,
                    CallingConvention = baseMd.CallingConvention,
                    HasThis = baseMd.HasThis,
                    ExplicitThis = baseMd.ExplicitThis,
                };
                return mr;
            }
            //Not generic.
            else
            {
                return CodegenSession.ImportReference(baseMd);
            }
        }

        /// <summary>
        /// Returns a method in any inherited classes. The first found method is returned.
        /// </summary>
        public static MethodDefinition GetMethodDefinitionInAnyBase(this TypeDefinition td, string methodName)
        {
            while (td != null)
            {
                foreach (MethodDefinition md in td.Methods)
                {
                    if (md.Name == methodName)
                        return md;
                }

                try
                {
                    td = td.GetNextBaseTypeDefinition();
                }
                catch
                {
                    return null;
                }
            }

            return null;
        }

        /// <summary>
        /// Returns the next base type.
        /// </summary>
        internal static TypeDefinition GetNextBaseTypeDefinition(this TypeDefinition typeDef)
        {
            return (typeDef.BaseType == null) ? null : typeDef.BaseType.CachedResolve();
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Extension/TypeReferenceExtensions.cs ---
﻿
using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using MonoFN.Cecil;
using UnityEngine;

namespace FishNet.CodeGenerating.Extension
{

    internal static class TypeReferenceExtensions
    {

        /// <summary>
        /// Returns a method in the next base class.
        /// </summary>
        public static MethodReference GetMethodInBase(this TypeReference tr, string methodName)
        {
            return GetMethodInBase(tr.CachedResolve(), methodName);
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/FN_README.txt ---
After updating a custom Cecil to fix conflict with Unity.Burst in 2021 perform the following:

- Open cecil in it's own project; eg: do not place directly in FN.
- Rename namespace.Mono to namespace.MonoFN.
- Current project rename strings, "Mono   to   "MonoFN
- Replace current project #if INSIDE_ROCKS  to  #if UNITY_EDITOR
- Comment out `[assembly: AssemblyTitle ("MonoFN.Cecil.Rocks")]` within rocks\Mono.Cecil.Rocks\AssemblyInfo.cs.
- Delete obj/bin/tests folders.
- Copy into FN project.

'''
'''--- Assets/FishNet/CodeGenerating/Helpers/AttributeHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Object;
using FishNet.Object.Helping;
using FishNet.Object.Prediction;
using FishNet.Object.Synchronizing;
using MonoFN.Cecil;

namespace FishNet.CodeGenerating.Helping
{
    public class AttributeHelper
    {
        #region Reflection references.
        internal string ReplicateAttribute_FullName;
        internal string ReconcileAttribute_FullName;
        private string ServerAttribute_FullName;
        private string ClientAttribute_FullName;
        private string ServerRpcAttribute_FullName;
        private string ObserversRpcAttribute_FullName;
        private string TargetRpcAttribute_FullName;
        private string SyncVarAttribute_FullName;
        private string SyncObjectAttribute_FullName;
        #endregion   

        internal bool ImportReferences()
        {
            ServerAttribute_FullName = typeof(ServerAttribute).FullName;
            ClientAttribute_FullName = typeof(ClientAttribute).FullName;
            ServerRpcAttribute_FullName = typeof(ServerRpcAttribute).FullName;
            ObserversRpcAttribute_FullName = typeof(ObserversRpcAttribute).FullName;
            TargetRpcAttribute_FullName = typeof(TargetRpcAttribute).FullName;
            SyncVarAttribute_FullName = typeof(SyncVarAttribute).FullName;
            SyncObjectAttribute_FullName = typeof(SyncObjectAttribute).FullName;
            ReplicateAttribute_FullName = typeof(ReplicateAttribute).FullName;
            ReconcileAttribute_FullName = typeof(ReconcileAttribute).FullName;

            return true;
        }

        /// <summary>
        /// Returns type of Rpc attributeFullName is for.
        /// </summary>
        /// <param name="attributeFullName"></param>
        /// <returns></returns>
        public RpcType GetRpcAttributeType(CustomAttribute ca)
        {
            if (ca.Is(ServerRpcAttribute_FullName))
                return RpcType.Server;
            else if (ca.Is(ObserversRpcAttribute_FullName))
                return RpcType.Observers;
            else if (ca.Is(TargetRpcAttribute_FullName))
                return RpcType.Target;
            else
                return RpcType.None;
        }

        /// <summary>
        /// Returns type of Rpc attributeFullName is for.
        /// </summary>
        /// <param name="attributeFullName"></param>
        /// <returns></returns>
        internal QolAttributeType GetQolAttributeType(string attributeFullName)
        {
            if (attributeFullName == ServerAttribute_FullName)
                return QolAttributeType.Server;
            else if (attributeFullName == ClientAttribute_FullName)
                return QolAttributeType.Client;
            else
                return QolAttributeType.None;
        }

        /// <summary>
        /// Returns if attribute if a SyncVarAttribute.
        /// </summary>
        /// <param name="attributeFullName"></param>
        /// <returns></returns>
        public bool IsSyncVarAttribute(string attributeFullName)
        {
            return (attributeFullName == SyncVarAttribute_FullName);
        }
        /// <summary>
        /// Returns if attribute if a SyncObjectAttribute.
        /// </summary>
        /// <param name="attributeFullName"></param>
        /// <returns></returns>
        public bool IsSyncObjectAttribute(string attributeFullName)
        {
            return (attributeFullName == SyncObjectAttribute_FullName);
        }
    }

}

'''
'''--- Assets/FishNet/CodeGenerating/Helpers/CodegenSession.cs ---
﻿using FishNet.CodeGenerating.Processing;
using FishNet.CodeGenerating.Processing.Rpc;
using MonoFN.Cecil;
using System.Collections.Generic;
using Unity.CompilationPipeline.Common.Diagnostics;
#if !UNITY_2020_1_OR_NEWER
using UnityEngine;
#endif
using SR = System.Reflection;

namespace FishNet.CodeGenerating.Helping
{

    internal static class CodegenSession
    {
        [System.ThreadStatic]
        internal static ModuleDefinition Module;
        [System.ThreadStatic]
        internal static List<DiagnosticMessage> Diagnostics;

        [System.ThreadStatic]
        internal static TimeManagerHelper TimeManagerHelper;
        [System.ThreadStatic]
        internal static AttributeHelper AttributeHelper;
        [System.ThreadStatic]
        internal static GeneralHelper GeneralHelper;
        [System.ThreadStatic]
        internal static GenericReaderHelper GenericReaderHelper;
        [System.ThreadStatic]
        internal static GenericWriterHelper GenericWriterHelper;
        [System.ThreadStatic]
        internal static ObjectHelper ObjectHelper;
        [System.ThreadStatic]
        internal static NetworkBehaviourHelper NetworkBehaviourHelper;
        [System.ThreadStatic]
        internal static ReaderGenerator ReaderGenerator;
        [System.ThreadStatic]
        internal static ReaderHelper ReaderHelper;
        [System.ThreadStatic]
        internal static CreatedSyncVarGenerator CreatedSyncVarGenerator;
        [System.ThreadStatic]
        internal static TransportHelper TransportHelper;
        [System.ThreadStatic]
        internal static WriterGenerator WriterGenerator;
        [System.ThreadStatic]
        internal static WriterHelper WriterHelper;
        [System.ThreadStatic]
        internal static CustomSerializerProcessor CustomSerializerProcessor;
        [System.ThreadStatic]
        internal static NetworkBehaviourProcessor NetworkBehaviourProcessor;
        [System.ThreadStatic]
        internal static QolAttributeProcessor QolAttributeProcessor;
        [System.ThreadStatic]
        internal static RpcProcessor RpcProcessor;
        [System.ThreadStatic]
        internal static NetworkBehaviourSyncProcessor NetworkBehaviourSyncProcessor;
        [System.ThreadStatic]
        internal static NetworkBehaviourPredictionProcessor NetworkBehaviourPredictionProcessor;
        [System.ThreadStatic]
        internal static NetworkConnectionHelper NetworkConnectionHelper;
        [System.ThreadStatic]
        internal static PredictedObjectHelper PredictedObjectHelper;
        /// <summary>
        /// SyncVars that are being accessed from an assembly other than the currently being processed one.
        /// </summary>
        [System.ThreadStatic]
        internal static List<FieldDefinition> DifferentAssemblySyncVars;

        /// <summary>
        /// Logs a warning.
        /// </summary>
        /// <param name="msg"></param>
        internal static void LogWarning(string msg)
        {
#if UNITY_2020_1_OR_NEWER
            Diagnostics.AddWarning(msg);
#else
            Debug.LogWarning(msg);
#endif
        }
        /// <summary>
        /// Logs an error.
        /// </summary>
        /// <param name="msg"></param>
        internal static void LogError(string msg)
        {
#if UNITY_2020_1_OR_NEWER
            Diagnostics.AddError(msg);
#else
            Debug.LogError(msg);
#endif
        }
        /// <summary>
        /// Resets all helpers while importing any information needed by them.
        /// </summary>
        /// <param name="module"></param>
        /// <returns></returns>
        internal static bool Reset(ModuleDefinition module)
        {
            Module = module;
            Diagnostics = new List<DiagnosticMessage>();

            TimeManagerHelper = new TimeManagerHelper();
            AttributeHelper = new AttributeHelper();
            GeneralHelper = new GeneralHelper();
            GenericReaderHelper = new GenericReaderHelper();
            GenericWriterHelper = new GenericWriterHelper();
            ObjectHelper = new ObjectHelper();
            NetworkBehaviourHelper = new NetworkBehaviourHelper();
            ReaderGenerator = new ReaderGenerator();
            ReaderHelper = new ReaderHelper();
            CreatedSyncVarGenerator = new CreatedSyncVarGenerator();
            TransportHelper = new TransportHelper();
            WriterGenerator = new WriterGenerator();
            WriterHelper = new WriterHelper();
            NetworkConnectionHelper = new NetworkConnectionHelper();
            PredictedObjectHelper = new PredictedObjectHelper();

            CustomSerializerProcessor = new CustomSerializerProcessor();
            NetworkBehaviourProcessor = new NetworkBehaviourProcessor();
            QolAttributeProcessor = new QolAttributeProcessor();
            RpcProcessor = new RpcProcessor();
            NetworkBehaviourSyncProcessor = new NetworkBehaviourSyncProcessor();
            NetworkBehaviourPredictionProcessor = new NetworkBehaviourPredictionProcessor();
            DifferentAssemblySyncVars = new List<FieldDefinition>();

            if (!TimeManagerHelper.ImportReferences())
                return false;
            if (!NetworkBehaviourPredictionProcessor.ImportReferences())
                return false;
            if (!NetworkBehaviourSyncProcessor.ImportReferences())
                return false;
            if (!GeneralHelper.ImportReferences())
                return false;
            if (!AttributeHelper.ImportReferences())
                return false;
            if (!GenericReaderHelper.ImportReferences())
                return false;
            if (!GenericWriterHelper.ImportReferences())
                return false;
            if (!ObjectHelper.ImportReferences())
                return false;
            if (!NetworkBehaviourHelper.ImportReferences())
                return false;
            if (!ReaderGenerator.ImportReferences())
                return false;
            if (!ReaderHelper.ImportReferences())
                return false;
            if (!CreatedSyncVarGenerator.ImportReferences())
                return false;
            if (!TransportHelper.ImportReferences())
                return false;
            if (!WriterGenerator.ImportReferences())
                return false;
            if (!WriterHelper.ImportReferences())
                return false;
            if (!NetworkConnectionHelper.ImportReferences())
                return false;
            if (!PredictedObjectHelper.ImportReferences())
                return false;

            return true;
        }

#region ImportReference.

        public static MethodReference ImportReference(SR.MethodBase method)
        {
            return Module.ImportReference(method);
        }

        public static MethodReference ImportReference(SR.MethodBase method, IGenericParameterProvider context)
        {
            return Module.ImportReference(method, context);
        }

        public static TypeReference ImportReference(TypeReference type)
        {
            return Module.ImportReference(type);
        }

        public static TypeReference ImportReference(TypeReference type, IGenericParameterProvider context)
        {
            return Module.ImportReference(type, context);
        }

        public static FieldReference ImportReference(FieldReference field)
        {
            return Module.ImportReference(field);
        }

        public static FieldReference ImportReference(FieldReference field, IGenericParameterProvider context)
        {
            return Module.ImportReference(field, context);
        }
        public static MethodReference ImportReference(MethodReference method)
        {
            return Module.ImportReference(method);
        }

        public static MethodReference ImportReference(MethodReference method, IGenericParameterProvider context)
        {
            return Module.ImportReference(method, context);
        }
        public static TypeReference ImportReference(System.Type type)
        {
            return ImportReference(type, null);
        }

        public static TypeReference ImportReference(System.Type type, IGenericParameterProvider context)
        {
            return Module.ImportReference(type, context);
        }

        public static FieldReference ImportReference(SR.FieldInfo field)
        {
            return Module.ImportReference(field);
        }

        public static FieldReference ImportReference(SR.FieldInfo field, IGenericParameterProvider context)
        {
            return Module.ImportReference(field, context);
        }

#endregion
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/CreatedSyncVarGenerator.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Object.Synchronizing;
using FishNet.Object.Synchronizing.Internal;
using MonoFN.Cecil;
using MonoFN.Cecil.Rocks;
using System;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Helping
{
    internal class CreatedSyncVarGenerator
    {
        private readonly Dictionary<string, CreatedSyncVar> _createdSyncVars = new Dictionary<string, CreatedSyncVar>();

        #region Relfection references.
        private TypeReference _syncBase_TypeRef;
        internal TypeReference SyncVar_TypeRef;
        private MethodReference _syncVar_Constructor_MethodRef;
        #endregion

        #region Const.
        private const string GETVALUE_NAME = "GetValue";
        private const string SETVALUE_NAME = "SetValue";
        #endregion

        /* //feature add and test the dirty boolean changes
         * eg... instead of base.Dirty()
         * do if (!base.Dirty()) return false;
         * See synclist for more info. */

        /// <summary>
        /// Imports references needed by this helper.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal bool ImportReferences()
        {
            SyncVar_TypeRef = CodegenSession.ImportReference(typeof(SyncVar<>)); 
            MethodDefinition svConstructor = SyncVar_TypeRef.GetFirstConstructor(true);
            _syncVar_Constructor_MethodRef = CodegenSession.ImportReference(svConstructor);

            Type syncBaseType = typeof(SyncBase);
            _syncBase_TypeRef = CodegenSession.ImportReference(syncBaseType);

            return true;
        }

        /// <summary>
        /// Gets and optionally creates data for SyncVar<typeOfField>
        /// </summary>
        /// <param name="dataTr"></param>
        /// <returns></returns>
        internal CreatedSyncVar GetCreatedSyncVar(FieldDefinition originalFd, bool createMissing)
        {
            TypeReference dataTr = originalFd.FieldType;
            TypeDefinition dataTd = dataTr.CachedResolve();

            string typeHash = dataTr.FullName + dataTr.IsArray.ToString();

            if (_createdSyncVars.TryGetValue(typeHash, out CreatedSyncVar createdSyncVar))
            {
                return createdSyncVar;
            }
            else
            {
                if (!createMissing)
                    return null;

                CodegenSession.ImportReference(dataTd);

                GenericInstanceType syncVarGit = SyncVar_TypeRef.MakeGenericInstanceType(new TypeReference[] { dataTr });
                TypeReference genericDataTr = syncVarGit.GenericArguments[0];

                //Make sure can serialize.
                bool canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(genericDataTr, true);
                if (!canSerialize)
                {
                    CodegenSession.LogError($"SyncVar {originalFd.Name} data type {genericDataTr.FullName} does not support serialization. Use a supported type or create a custom serializer.");
                    return null;
                }

                //Set needed methods from syncbase.
                MethodReference setSyncIndexMr;
                MethodReference genericSyncVarCtor = _syncVar_Constructor_MethodRef.MakeHostInstanceGeneric(syncVarGit);

                if (!CodegenSession.NetworkBehaviourSyncProcessor.SetSyncBaseMethods(_syncBase_TypeRef.CachedResolve(), out setSyncIndexMr, out _))
                    return null;

                MethodReference setValueMr = null;
                MethodReference getValueMr = null;
                foreach (MethodDefinition md in SyncVar_TypeRef.CachedResolve().Methods)
                {
                    //GetValue.
                    if (md.Name == GETVALUE_NAME)
                    {
                        MethodReference mr = CodegenSession.ImportReference(md);
                        getValueMr = mr.MakeHostInstanceGeneric(syncVarGit);
                    }
                    //SetValue.
                    else if (md.Name == SETVALUE_NAME)
                    {
                        MethodReference mr = CodegenSession.ImportReference(md);
                        setValueMr = mr.MakeHostInstanceGeneric(syncVarGit);
                    }

                }

                if (setValueMr == null || getValueMr == null)
                    return null;

                CreatedSyncVar csv = new CreatedSyncVar(syncVarGit, dataTd, getValueMr, setValueMr, setSyncIndexMr, null, genericSyncVarCtor);
                _createdSyncVars.Add(typeHash, csv);
                return csv;
            }
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/CustomAttributeExtensions.cs ---
﻿using MonoFN.Cecil;
using System.Linq;

namespace FishNet.CodeGenerating.Helping.Extension
{

    internal static class CustomAttributeExtensions
    {
        /// <summary>
        /// Finds a field within an attribute.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="customAttr"></param>
        /// <param name="field"></param>
        /// <param name="defaultValue"></param>
        /// <returns></returns>
        internal static T GetField<T>(this CustomAttribute customAttr, string field, T defaultValue)
        {
            foreach (CustomAttributeNamedArgument customField in customAttr.Fields)
            {
                if (customField.Name == field)
                {
                    return (T)customField.Argument.Value;
                }
            }

            return defaultValue;
        }

        /// <summary>
        /// Returns if any of the attributes match IAtrribute.
        /// </summary>
        /// <typeparam name="TAttribute"></typeparam>
        /// <param name="attributeProvider"></param>
        /// <returns></returns>
        internal static bool HasCustomAttribute<TAttribute>(this ICustomAttributeProvider attributeProvider)
        {
            return attributeProvider.CustomAttributes.Any(attr => attr.AttributeType.Is<TAttribute>());
        }

        /// <summary>
        /// Returns if ca is of type target.
        /// </summary>
        /// <param name="ca"></param>
        /// <param name="targetFullName"></param>
        /// <returns></returns>
        internal static bool Is(this CustomAttribute ca, string targetFullName)
        {
            return ca.AttributeType.FullName == targetFullName;
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/Diagnostics.cs ---
﻿using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Unity.CompilationPipeline.Common.Diagnostics;

namespace FishNet.CodeGenerating.Helping
{
    internal static class Diagnostics
    {
        internal static void AddError(this List<DiagnosticMessage> diagnostics, string message)
        {
            diagnostics.AddMessage(DiagnosticType.Error, (SequencePoint)null, message);
        }

        internal static void AddWarning(this List<DiagnosticMessage> diagnostics, string message)
        {
            diagnostics.AddMessage(DiagnosticType.Warning, (SequencePoint)null, message);
        }

        internal static void AddError(this List<DiagnosticMessage> diagnostics, MethodDefinition methodDef, string message)
        {
            diagnostics.AddMessage(DiagnosticType.Error, methodDef.DebugInformation.SequencePoints.FirstOrDefault(), message);
        }

        internal static void AddMessage(this List<DiagnosticMessage> diagnostics, DiagnosticType diagnosticType, SequencePoint sequencePoint, string message)
        {
            diagnostics.Add(new DiagnosticMessage
            {
                DiagnosticType = diagnosticType,
                File = sequencePoint?.Document.Url.Replace($"{Environment.CurrentDirectory}{Path.DirectorySeparatorChar}", ""),
                Line = sequencePoint?.StartLine ?? 0,
                Column = sequencePoint?.StartColumn ?? 0,
                MessageData = $" - {message}"
            });
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/FieldReferenceExtensions.cs ---
﻿using MonoFN.Cecil;
using System;

namespace FishNet.CodeGenerating.Helping.Extension
{

    internal static class FieldReferenceExtensions
    {

        /// <summary>
        /// Gets a Resolve favoring cached results first.
        /// </summary>
        internal static FieldDefinition CachedResolve(this FieldReference fieldRef)
        {
            return CodegenSession.GeneralHelper.GetFieldReferenceResolve(fieldRef);
        }

        public static FieldReference MakeHostGenericIfNeeded(this FieldReference fd)
        {
            if (fd.DeclaringType.HasGenericParameters)
            {
                return new FieldReference(fd.Name, fd.FieldType, fd.DeclaringType.CachedResolve().ConvertToGenericIfNeeded());
            }

            return fd;
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/GetConstructor.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using MonoFN.Cecil;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping
{
    public static class Constructors
    {

        /// <summary>
        /// Gets the first constructor that optionally has, or doesn't have parameters.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static MethodDefinition GetFirstConstructor(this TypeReference typeRef, bool requireParameters)
        {
            return typeRef.CachedResolve().GetFirstConstructor(requireParameters);
        }
        /// <summary>
        /// Gets the first constructor that optionally has, or doesn't have parameters.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static MethodDefinition GetFirstConstructor(this TypeDefinition typeDef, bool requireParameters)
        {

            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                if (methodDef.IsConstructor && methodDef.IsPublic)
                {
                    if (requireParameters && methodDef.Parameters.Count > 0)
                        return methodDef;
                    else if (!requireParameters && methodDef.Parameters.Count == 0)
                        return methodDef;
                }

            }

            return null;
        }

        /// <summary>
        /// Gets the first public constructor with no parameters.
        /// </summary>
        /// <returns></returns>
        public static MethodDefinition GetConstructor(this TypeReference typeRef)
        {
            return typeRef.CachedResolve().GetConstructor();
        }
        /// <summary>
        /// Gets the first public constructor with no parameters.
        /// </summary>
        /// <returns></returns>
        public static MethodDefinition GetConstructor(this TypeDefinition typeDef)
        {
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                if (methodDef.IsConstructor && methodDef.IsPublic && methodDef.Parameters.Count == 0)
                    return methodDef;
            }

            return null;
        }

        /// <summary>
        /// Gets all constructors on typeDef.
        /// </summary>
        /// <returns></returns>
        public static List<MethodDefinition> GetConstructors(this TypeDefinition typeDef)
        {
            List<MethodDefinition> lst = new List<MethodDefinition>();
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                if (methodDef.IsConstructor)
                    lst.Add(methodDef);
            }

            return lst;
        }

        /// <summary>
        /// Gets constructor which has arguments.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static MethodDefinition GetConstructor(this TypeReference typeRef, Type[] arguments)
        {
            return typeRef.CachedResolve().GetConstructor(arguments);
        }

        /// <summary>
        /// Gets constructor which has arguments.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        public static MethodDefinition GetConstructor(this TypeDefinition typeDef, Type[] arguments)
        {
            Type[] argsCopy = (arguments == null) ? new Type[0] : arguments;
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                if (methodDef.IsConstructor && methodDef.IsPublic && methodDef.Parameters.Count == argsCopy.Length)
                {
                    bool match = true;
                    for (int i = 0; i < argsCopy.Length; i++)
                    {
                        if (methodDef.Parameters[0].ParameterType.FullName != argsCopy[i].FullName)
                        {
                            match = false;
                            break;
                        }
                    }

                    if (match)
                        return methodDef;
                }
            }
            return null;
        }

        /// <summary>
        /// Gets constructor which has arguments.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static MethodDefinition GetConstructor(this TypeReference typeRef, TypeReference[] arguments)
        {
            return typeRef.CachedResolve().GetConstructor(arguments);
        }

        /// <summary>
        /// Gets constructor which has arguments.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        public static MethodDefinition GetConstructor(this TypeDefinition typeDef, TypeReference[] arguments)
        {
            TypeReference[] argsCopy = (arguments == null) ? new TypeReference[0] : arguments;
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                if (methodDef.IsConstructor && methodDef.IsPublic && methodDef.Parameters.Count == argsCopy.Length)
                {
                    bool match = true;
                    for (int i = 0; i < argsCopy.Length; i++)
                    {
                        if (methodDef.Parameters[0].ParameterType.FullName != argsCopy[i].FullName)
                        {
                            match = false;
                            break;
                        }
                    }

                    if (match)
                        return methodDef;
                }
            }
            return null;
        }

        /// <summary>
        /// Resolves the constructor with parameterCount for typeRef.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static MethodDefinition GetConstructor(this TypeReference typeRef, int parameterCount)
        {
            return typeRef.CachedResolve().GetConstructor(parameterCount);
        }

        /// <summary>
        /// Resolves the constructor with parameterCount for typeRef.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        public static MethodDefinition GetConstructor(this TypeDefinition typeDef, int parameterCount)
        {
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                if (methodDef.IsConstructor && methodDef.IsPublic && methodDef.Parameters.Count == parameterCount)
                    return methodDef;
            }
            return null;
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/ILProcessorExtensions.cs ---
﻿using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Helping.Extension
{

    public static class ILProcessorExtensions
    {

        /// <summary>
        /// Creates a debug log for text without any conditions.
        /// </summary>
        public static void DebugLog(this ILProcessor processor, string txt)
        {
            processor.Emit(OpCodes.Ldstr, txt);
            processor.Emit(OpCodes.Call, CodegenSession.GeneralHelper.Debug_LogCommon_MethodRef);
        }
        /// <summary>
        /// Creates a debug log for vd without any conditions.
        /// </summary>
        public static void DebugLog(this ILProcessor processor, VariableDefinition vd)
        {
            processor.Emit(OpCodes.Ldloc, vd);
            processor.Emit(OpCodes.Box, vd.VariableType);
            processor.Emit(OpCodes.Call, CodegenSession.GeneralHelper.Debug_LogCommon_MethodRef);
        }
        /// <summary>
        /// Creates a debug log for vd without any conditions.
        /// </summary>
        public static void DebugLog(this ILProcessor processor, FieldDefinition fd, bool loadArg0)
        {
            if (loadArg0)
                processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, fd);
            processor.Emit(OpCodes.Box, fd.FieldType);
            processor.Emit(OpCodes.Call, CodegenSession.GeneralHelper.Debug_LogCommon_MethodRef);
        }
        /// <summary>
        /// Creates a debug log for pd without any conditions.
        /// </summary>
        public static void DebugLog(this ILProcessor processor, ParameterDefinition pd)
        {
            processor.Emit(OpCodes.Ldloc, pd);
            processor.Emit(OpCodes.Box, pd.ParameterType);
            processor.Emit(OpCodes.Call, CodegenSession.GeneralHelper.Debug_LogCommon_MethodRef);
        }

        ///// <summary>
        ///// Creates a debug log for mr without any conditions.
        ///// </summary>
        //public static void DebugLog(this ILProcessor processor, MethodReference mr)
        //{
        //    processor.Emit(OpCodes.Call, mr);
        //    processor.Emit(OpCodes.Box, mr.ReturnType);
        //    processor.Emit(OpCodes.Call, CodegenSession.GeneralHelper.Debug_LogCommon_MethodRef);
        //}

        /// <summary>
        /// Inserts instructions at the beginning.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="instructions"></param>
        public static void InsertAt(this ILProcessor processor, int target, List<Instruction> instructions)
        {
            for (int i = 0; i < instructions.Count; i++)
                processor.Body.Instructions.Insert(i + target, instructions[i]);
        }

        /// <summary>
        /// Inserts instructions at the beginning.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="instructions"></param>
        public static void InsertFirst(this ILProcessor processor, List<Instruction> instructions)
        {
            for (int i = 0; i < instructions.Count; i++)
                processor.Body.Instructions.Insert(i, instructions[i]);
        }

        /// <summary>
        /// Inserts instructions at the end while also moving Ret down.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="instructions"></param>
        public static void InsertLast(this ILProcessor processor, List<Instruction> instructions)
        {
            bool retRemoved = false;
            int startingCount = processor.Body.Instructions.Count;
            //Remove ret if it exist and add it back in later.
            if (startingCount > 0)
            {
                if (processor.Body.Instructions[startingCount - 1].OpCode == OpCodes.Ret)
                {
                    processor.Body.Instructions.RemoveAt(startingCount - 1);
                    retRemoved = true;
                }
            }

            foreach (Instruction inst in instructions)
                processor.Append(inst);

            //Add ret back if it was removed.
            if (retRemoved)
                processor.Emit(OpCodes.Ret);
        }

        /// <summary>
        /// Inserts instructions before target.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="instructions"></param>
        public static void InsertBefore(this ILProcessor processor, Instruction target, List<Instruction> instructions)
        {
            int index = processor.Body.Instructions.IndexOf(target);
            for (int i = 0; i < instructions.Count; i++)
                processor.Body.Instructions.Insert(index + i, instructions[i]);
        }

        /// <summary>
        /// Adds instructions to the end of processor.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="instructions"></param>
        public static void Add(this ILProcessor processor, List<Instruction> instructions)
        {
            for (int i = 0; i < instructions.Count; i++)
                processor.Body.Instructions.Add(instructions[i]);
        }

        /// <summary>
        /// Inserts instructions before returns. Only works on void types.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="instructions"></param>
        public static void InsertBeforeReturns(this ILProcessor processor, List<Instruction> instructions)
        {
            if (processor.Body.Method.ReturnType.FullName != CodegenSession.Module.TypeSystem.Void.FullName)
            {
                CodegenSession.LogError($"Cannot insert instructions before returns on {processor.Body.Method.FullName} because it does not return void.");
                return;
            }

            /* Insert at the end of the method
             * and get the first instruction that was inserted.
             * Any returns or breaks which would exit the method
             * will jump to this instruction instead. */
            processor.InsertLast(instructions);
            Instruction startInst = processor.Body.Instructions[processor.Body.Instructions.Count - instructions.Count];

            //Look for anything that jumps to rets.
            for (int i = 0; i < processor.Body.Instructions.Count; i++)
            {
                Instruction inst = processor.Body.Instructions[i];
                if (inst.Operand is Instruction operInst)
                {
                    if (operInst.OpCode == OpCodes.Ret)
                        inst.Operand = startInst;
                }
            }
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/InstructionExtensions.cs ---
﻿using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Helping
{
    public static class Instructions
    {
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/MethodDefinitionExtensions.cs ---
﻿using MonoFN.Cecil;
using MonoFN.Cecil.Cil;

namespace FishNet.CodeGenerating.Helping.Extension
{

    internal static class MethodDefinitionExtensions
    {
        /// <summary>
        /// Clears the method content and returns ret.
        /// </summary>
        internal static void ClearMethodWithRet(this MethodDefinition md, ModuleDefinition importReturnModule = null)
        {
            md.Body.Instructions.Clear();
            ILProcessor processor = md.Body.GetILProcessor();
            processor.Add(CodegenSession.GeneralHelper.CreateRetDefault(md, importReturnModule));
        }

        /// <summary>
        /// Returns the ParameterDefinition index from end of parameters.
        /// </summary>
        /// <param name="md"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        internal static ParameterDefinition GetEndParameter(this MethodDefinition md, int index)
        {
            //Not enough parameters.
            if (md.Parameters.Count < (index + 1))
                return null;

            return md.Parameters[md.Parameters.Count - (index + 1)];
        }

        /// <summary>
        /// Creates a variable type within the body and returns it's VariableDef.
        /// </summary>
        internal static VariableDefinition CreateVariable(this MethodDefinition methodDef, TypeReference variableTypeRef)
        {
            VariableDefinition variableDef = new VariableDefinition(variableTypeRef);
            methodDef.Body.Variables.Add(variableDef);
            return variableDef;
        }

        /// <summary>
        /// Creates a variable type within the body and returns it's VariableDef.
        /// </summary>
        internal static VariableDefinition CreateVariable(this MethodDefinition methodDef, System.Type variableType)
        {
            return CreateVariable(methodDef, CodegenSession.GeneralHelper.GetTypeReference(variableType));
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/MethodReferenceExtensions.cs ---
﻿using MonoFN.Cecil;
using MonoFN.Cecil.Rocks;
using System;

namespace FishNet.CodeGenerating.Helping.Extension
{

    public static class MethodReferenceExtensions
    {
        /// <summary>
        /// Makes a generic method with specified arguments.
        /// </summary>
        /// <param name="method"></param>
        /// <param name="genericArguments"></param>
        /// <returns></returns>
        public static GenericInstanceMethod MakeGenericMethod(this MethodReference method, params TypeReference[] genericArguments)
        {
            GenericInstanceMethod result = new GenericInstanceMethod(method);
            foreach (TypeReference argument in genericArguments)
                result.GenericArguments.Add(argument);
            return result;
        }

        /// <summary>
        /// Makes a generic method with the same arguments as the original.
        /// </summary>
        /// <param name="method"></param>
        /// <returns></returns>
        public static GenericInstanceMethod MakeGenericMethod(this MethodReference method)
        {
            GenericInstanceMethod result = new GenericInstanceMethod(method);
            foreach (ParameterDefinition pd in method.Parameters)
                result.GenericArguments.Add(pd.ParameterType);

            return result;
        }

        /// <summary>
        /// Gets a Resolve favoring cached results first.
        /// </summary>
        internal static MethodDefinition CachedResolve(this MethodReference methodRef)
        {
            return CodegenSession.GeneralHelper.GetMethodReferenceResolve(methodRef);
        }

        /// <summary>
        /// Given a method of a generic class such as ArraySegment`T.get_Count,
        /// and a generic instance such as ArraySegment`int
        /// Creates a reference to the specialized method  ArraySegment`int`.get_Count
        /// <para> Note that calling ArraySegment`T.get_Count directly gives an invalid IL error </para>
        /// </summary>
        /// <param name="self"></param>
        /// <param name="instanceType"></param>
        /// <returns></returns>
        public static MethodReference MakeHostInstanceGeneric(this MethodReference self, GenericInstanceType instanceType)
        {
            MethodReference reference = new MethodReference(self.Name, self.ReturnType, instanceType)
            {
                CallingConvention = self.CallingConvention,
                HasThis = self.HasThis,
                ExplicitThis = self.ExplicitThis
            };

            foreach (ParameterDefinition parameter in self.Parameters)
                reference.Parameters.Add(new ParameterDefinition(parameter.ParameterType));

            foreach (GenericParameter generic_parameter in self.GenericParameters)
                reference.GenericParameters.Add(new GenericParameter(generic_parameter.Name, reference));

            return CodegenSession.ImportReference(reference);
        }
        /// <summary>
        /// Given a method of a generic class such as ArraySegment`T.get_Count,
        /// and a generic instance such as ArraySegment`int
        /// Creates a reference to the specialized method  ArraySegment`int`.get_Count
        /// <para> Note that calling ArraySegment`T.get_Count directly gives an invalid IL error </para>
        /// </summary>
        /// <param name="self"></param>
        /// <param name="instanceType"></param>
        /// <returns></returns>
        public static MethodReference MakeHostInstanceGeneric(this MethodReference self, TypeReference typeRef, params TypeReference[] args)
        {

            GenericInstanceType git = typeRef.MakeGenericInstanceType(args);
            MethodReference reference = new MethodReference(self.Name, self.ReturnType, git)
            {
                CallingConvention = self.CallingConvention,
                HasThis = self.HasThis,
                ExplicitThis = self.ExplicitThis
            };

            foreach (ParameterDefinition parameter in self.Parameters)
                reference.Parameters.Add(new ParameterDefinition(parameter.ParameterType));

            foreach (GenericParameter generic_parameter in self.GenericParameters)
                reference.GenericParameters.Add(new GenericParameter(generic_parameter.Name, reference));

            return reference;
        }
        public static bool Is<T>(this MethodReference method, string name)
        {
            return method.DeclaringType.Is<T>() && method.Name == name;
        }
        public static bool Is<T>(this TypeReference td)
        {
            return Is(td, typeof(T));
        }

        public static bool Is(this TypeReference td, Type t)
        {
            if (t.IsGenericType)
            {
                return td.GetElementType().FullName == t.FullName;
            }
            return td.FullName == t.FullName;
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/ModuleDefinitionExtensions.cs ---
﻿using FishNet.CodeGenerating.ILCore;
using MonoFN.Cecil;
using System;
using System.Linq.Expressions;
using System.Reflection;

namespace FishNet.CodeGenerating.Helping.Extension
{

    public static class ModuleDefinitionExtensions
    {
        /// <summary>
        /// Gets a class within CodegenSession.Module.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        public static TypeDefinition GetClass(this ModuleDefinition moduleDef, string className)
        {
            return CodegenSession.Module.GetType(FishNetILPP.RUNTIME_ASSEMBLY_NAME, className);
        }

        public static TypeReference ImportReference<T>(this ModuleDefinition moduleDef)
        {
            return CodegenSession.ImportReference(typeof(T));
        }

        public static MethodReference ImportReference(this ModuleDefinition moduleDef, Expression<Action> expression)
        {
            return ImportReference(moduleDef, (LambdaExpression)expression);
        }
        public static MethodReference ImportReference<T>(this ModuleDefinition module, Expression<Action<T>> expression)
        {
            return ImportReference(module, (LambdaExpression)expression);
        }

        public static MethodReference ImportReference(this ModuleDefinition module, LambdaExpression expression)
        {
            if (expression.Body is MethodCallExpression outermostExpression)
            {
                MethodInfo methodInfo = outermostExpression.Method;
                return module.ImportReference(methodInfo);
            }

            if (expression.Body is NewExpression newExpression)
            {
                ConstructorInfo methodInfo = newExpression.Constructor;
                // constructor is null when creating an ArraySegment<object>
                methodInfo = methodInfo ?? newExpression.Type.GetConstructors()[0];
                return module.ImportReference(methodInfo);
            }

            if (expression.Body is MemberExpression memberExpression)
            {
                var property = memberExpression.Member as PropertyInfo;
                return module.ImportReference(property.GetMethod);
            }

            throw new ArgumentException($"Invalid Expression {expression.Body.GetType()}");
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/ParameterDefinitionExtensions.cs ---
﻿using MonoFN.Cecil;
using System;

namespace FishNet.CodeGenerating.Helping.Extension
{

    internal static class ParameterDefinitionExtensions
    {
        /// <summary>
        /// Returns if parameterDef is Type.
        /// </summary>
        /// <param name="parameterDef"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public static bool Is(this ParameterDefinition parameterDef, Type type)
        {
            return parameterDef.ParameterType.FullName == type.FullName;
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/TypeDefinitionExtensions.cs ---
﻿using FishNet.CodeGenerating.Extension;
using MonoFN.Cecil;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping.Extension
{

    internal static class TypeDefinitionExtensionsOld
    {

        /// <summary>
        /// Creates a GenericInstanceType and adds parameters.
        /// </summary>
        internal static GenericInstanceType CreateGenericInstanceType(this TypeDefinition type, Collection<GenericParameter> parameters)
        {
            GenericInstanceType git = new GenericInstanceType(type);
            foreach (GenericParameter gp in parameters)
                git.GenericArguments.Add(gp);

            return git;
        }

        /// <summary>
        /// Finds public fields in type and base type
        /// </summary>
        /// <param name="variable"></param>
        /// <returns></returns>
        public static IEnumerable<FieldDefinition> FindAllPublicFields(this TypeDefinition typeDef, bool ignoreStatic, bool ignoreNonSerialized, System.Type[] excludedBaseTypes = null, string[] excludedAssemblyPrefixes = null)
        {
            while (typeDef != null)
            {
                if (IsExcluded(typeDef, excludedBaseTypes, excludedAssemblyPrefixes))
                    break;

                foreach (FieldDefinition fd in typeDef.Fields)
                {
                    if (ignoreStatic && fd.IsStatic)
                        continue;
                    if (fd.IsPrivate)
                        continue;
                    if (ignoreNonSerialized && fd.IsNotSerialized)
                        continue;
                    if (CodegenSession.GeneralHelper.CodegenExclude(fd))
                        continue;

                    yield return fd;
                }

                try { typeDef = typeDef.BaseType?.CachedResolve(); }
                catch { break; }
            }
        }

        /// <summary>
        /// Finds public properties on typeDef and all base types which have a public get/set accessor.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        public static IEnumerable<PropertyDefinition> FindAllPublicProperties(this TypeDefinition typeDef, bool excludeGenerics = true, System.Type[] excludedBaseTypes = null, string[] excludedAssemblyPrefixes = null)
        {
            while (typeDef != null)
            {
                if (IsExcluded(typeDef, excludedBaseTypes, excludedAssemblyPrefixes))
                    break;

                foreach (PropertyDefinition pd in typeDef.Properties)
                {
                    //Missing get or set method.
                    if (pd.GetMethod == null || pd.SetMethod == null)
                        continue;
                    //Get or set is private.
                    if (pd.GetMethod.IsPrivate || pd.SetMethod.IsPrivate)
                        continue;
                    if (excludeGenerics && pd.GetMethod.ReturnType.IsGenericParameter)
                        continue;
                    if (CodegenSession.GeneralHelper.CodegenExclude(pd))
                        continue;

                    yield return pd;
                }

                try { typeDef = typeDef.BaseType?.CachedResolve(); }
                catch { break; }
            }

        }

        /// <summary>
        /// Returns if typeDef is excluded.
        /// </summary>
        private static bool IsExcluded(TypeDefinition typeDef, System.Type[] excludedBaseTypes = null, string[] excludedAssemblyPrefixes = null)
        {
            if (excludedBaseTypes != null)
            {
                foreach (System.Type t in excludedBaseTypes)
                {
                    if (typeDef.FullName == t.FullName)
                        return true;
                }
            }
            if (excludedAssemblyPrefixes != null)
            {
                foreach (string s in excludedAssemblyPrefixes)
                {
                    int len = s.Length;
                    string tdAsmName = typeDef.Module.Assembly.FullName;
                    if (tdAsmName.Length >= len && tdAsmName.Substring(0, len).ToLower() == s.ToLower())
                        return true;
                }
            }

            //Fall through, not excluded.
            return false;
        }

        /// <summary>
        /// Returns if typeDef is excluded.
        /// </summary>
        public static bool IsExcluded(this TypeDefinition typeDef, string excludedAssemblyPrefix)
        {

            int len = excludedAssemblyPrefix.Length;
            string tdAsmName = typeDef.Module.Assembly.FullName;
            if (tdAsmName.Length >= len && tdAsmName.Substring(0, len).ToLower() == excludedAssemblyPrefix.ToLower())
                return true;

            //Fall through, not excluded.
            return false;
        }

        /// <summary>
        /// Returns if typeDef or any of it's parents inherit from NetworkBehaviour.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal static bool InheritsNetworkBehaviour(this TypeDefinition typeDef)
        {
            string nbFullName = CodegenSession.NetworkBehaviourHelper.FullName;

            TypeDefinition copyTd = typeDef;
            while (copyTd != null)
            {
                if (copyTd.FullName == nbFullName)
                    return true;

                copyTd = copyTd.GetNextBaseTypeDefinition();
            }

            //Fall through, network behaviour not found.
            return false;
        }

        /// <summary>
        /// Returns a nested TypeDefinition of name.
        /// </summary>
        internal static TypeDefinition GetNestedType(this TypeDefinition typeDef, string name)
        {
            foreach (TypeDefinition nestedTd in typeDef.NestedTypes)
            {
                if (nestedTd.Name == name)
                    return nestedTd;
            }

            return null;
        }

        /// <summary>
        /// Returns if the BaseType for TypeDef exist and is not NetworkBehaviour,
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal static bool CanProcessBaseType(this TypeDefinition typeDef)
        {
            return (typeDef != null && typeDef.BaseType != null && typeDef.BaseType.FullName != CodegenSession.NetworkBehaviourHelper.FullName);
        }
        /// <summary>
        /// Returns if the BaseType for TypeDef exist and is not NetworkBehaviour,
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal static TypeDefinition GetNextBaseClassToProcess(this TypeDefinition typeDef)
        {
            if (typeDef.BaseType != null && typeDef.BaseType.FullName != CodegenSession.NetworkBehaviourHelper.FullName)
                return typeDef.BaseType.CachedResolve();
            else
                return null;
        }

        internal static TypeDefinition GetLastBaseClass(this TypeDefinition typeDef)
        {
            TypeDefinition copyTd = typeDef;
            while (copyTd.BaseType != null)
                copyTd = copyTd.BaseType.CachedResolve();

            return copyTd;
        }

        /// <summary>
        /// Searches for a type in current and inherited types.
        /// </summary>
        internal static TypeDefinition GetClassInInheritance(this TypeDefinition typeDef, string typeFullName)
        {
            TypeDefinition copyTd = typeDef;
            do
            {
                if (copyTd.FullName == typeFullName)
                    return copyTd;

                if (copyTd.BaseType != null)
                    copyTd = copyTd.BaseType.CachedResolve();
                else
                    copyTd = null;

            } while (copyTd != null);

            //Not found.
            return null;
        }

        /// <summary>
        /// Searches for a type in current and inherited types.
        /// </summary>
        internal static TypeDefinition GetClassInInheritance(this TypeDefinition typeDef, TypeDefinition targetTypeDef)
        {
            if (typeDef == null)
                return null;

            TypeDefinition copyTd = typeDef;
            do
            {
                if (copyTd == targetTypeDef)
                    return copyTd;

                if (copyTd.BaseType != null)
                    copyTd = copyTd.BaseType.CachedResolve();
                else
                    copyTd = null;

            } while (copyTd != null);

            //Not found.
            return null;
        }

        /// <summary>
        /// Returns if typeDef is static (abstract, sealed).
        /// </summary>
        internal static bool IsStatic(this TypeDefinition typeDef)
        {
            //Combining flags in a single check some reason doesn't work right with HasFlag.
            return (typeDef.Attributes.HasFlag(TypeAttributes.Abstract) && typeDef.Attributes.HasFlag(TypeAttributes.Sealed));
        }

        /// <summary>
        /// Gets an enum underlying type for typeDef.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal static TypeReference GetEnumUnderlyingTypeReference(this TypeDefinition typeDef)
        {
            foreach (FieldDefinition field in typeDef.Fields)
            {
                if (!field.IsStatic)
                    return field.FieldType;
            }
            throw new ArgumentException($"Invalid enum {typeDef.FullName}");
        }

        /// <summary>
        /// Returns if typeDef is derived from type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal static bool InheritsFrom<T>(this TypeDefinition typeDef)
        {
            return InheritsFrom(typeDef, typeof(T));
        }

        /// <summary>
        /// Returns if typeDef is derived from type.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        internal static bool InheritsFrom(this TypeDefinition typeDef, Type type)
        {
            if (!typeDef.IsClass)
                return false;

            TypeDefinition copyTd = typeDef;
            while (copyTd.BaseType != null)
            {
                if (copyTd.BaseType.IsType(type))
                    return true;

                copyTd = copyTd.GetNextBaseTypeDefinition();
            }

            //Fall through.
            return false;
        }

        /// <summary>
        /// Adds a method to typeDef.
        /// </summary>
        /// <param name="typDef"></param>
        /// <param name="methodName"></param>
        /// <param name="attributes"></param>
        /// <returns></returns>
        internal static MethodDefinition AddMethod(this TypeDefinition typDef, string methodName, MethodAttributes attributes)
        {
            return AddMethod(typDef, methodName, attributes, typDef.Module.ImportReference(typeof(void)));
        }
        /// <summary>
        /// Adds a method to typeDef.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="methodName"></param>
        /// <param name="attributes"></param>
        /// <param name="typeReference"></param>
        /// <returns></returns>
        internal static MethodDefinition AddMethod(this TypeDefinition typeDef, string methodName, MethodAttributes attributes, TypeReference typeReference)
        {
            var method = new MethodDefinition(methodName, attributes, typeReference);
            typeDef.Methods.Add(method);
            return method;
        }

        /// <summary>
        /// Finds the first method by a given name.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="methodName"></param>
        /// <returns></returns>
        internal static MethodDefinition GetMethod(this TypeDefinition typeDef, string methodName)
        {
            return typeDef.Methods.FirstOrDefault(method => method.Name == methodName);
        }

        /// <summary>
        /// Finds the first method by a given name.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="methodName"></param>
        /// <returns></returns>
        internal static MethodDefinition GetMethod(this TypeDefinition typeDef, string methodName, Type[] types)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns if a type is a subclass of another.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="ClassTypeFullName"></param>
        /// <returns></returns>
        internal static bool IsSubclassOf(this TypeDefinition typeDef, string ClassTypeFullName)
        {
            if (!typeDef.IsClass) return false;

            TypeReference baseTypeRef = typeDef.BaseType;
            while (baseTypeRef != null)
            {
                if (baseTypeRef.FullName == ClassTypeFullName)
                {
                    return true;
                }

                try
                {
                    baseTypeRef = baseTypeRef.CachedResolve().BaseType;
                }
                catch
                {
                    return false;
                }
            }

            return false;
        }

        /// <summary>
        /// Gets a field reference by name.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="fieldName"></param>
        /// <returns></returns>
        public static FieldReference GetField(this TypeDefinition typeDef, string fieldName)
        {
            if (typeDef.HasFields)
            {
                for (int i = 0; i < typeDef.Fields.Count; i++)
                {
                    if (typeDef.Fields[i].Name == fieldName)
                    {
                        return typeDef.Fields[i];
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Returns if the TypeDefinition implements TInterface.
        /// </summary>
        /// <typeparam name="TInterface"></typeparam>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        public static bool ImplementsInterface<TInterface>(this TypeDefinition typeDef)
        {
            for (int i = 0; i < typeDef.Interfaces.Count; i++)
            {
                if (typeDef.Interfaces[i].InterfaceType.Is<TInterface>())
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns if the TypeDefinition implements TInterface.
        /// </summary>
        /// <typeparam name="TInterface"></typeparam>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        public static bool ImplementsInterfaceRecursive<TInterface>(this TypeDefinition typeDef)
        {
            TypeDefinition climbTypeDef = typeDef;

            while (climbTypeDef != null)
            {
                if (climbTypeDef.Interfaces.Any(i => i.InterfaceType.Is<TInterface>()))
                    return true;

                try
                {
                    if (climbTypeDef.BaseType != null)
                        climbTypeDef = climbTypeDef.BaseType.CachedResolve();
                    else
                        climbTypeDef = null;
                }
                //Could not resolve assembly; can happen for assemblies being checked outside FishNet/csharp.
                catch (AssemblyResolutionException)
                {
                    break;
                }
            }

            return false;
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Extension/TypeReferenceExtensions.cs ---
﻿using MonoFN.Cecil;
using MonoFN.Cecil.Rocks;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping.Extension
{

    internal static class TypeReferenceExtensionsOld
    {

        /// <summary>
        /// Gets a Resolve favoring cached results first.
        /// </summary>
        internal static TypeDefinition CachedResolve(this TypeReference typeRef)
        {
            return CodegenSession.GeneralHelper.GetTypeReferenceResolve(typeRef);
        }

        /// <summary>
        /// Returns if typeRef is a class or struct.
        /// </summary>
        internal static bool IsClassOrStruct(this TypeReference typeRef)
        {
            TypeDefinition typeDef = typeRef.CachedResolve();
            return (!typeDef.IsPrimitive && (typeDef.IsClass || typeDef.IsValueType));
        }

        /// <summary>
        /// Returns all properties on typeRef and all base types which have a public get/set accessor.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static IEnumerable<PropertyDefinition> FindAllPublicProperties(this TypeReference typeRef, bool excludeGenerics = true, System.Type[] excludedBaseTypes = null, string[] excludedAssemblyPrefixes = null)
        {
            return typeRef.CachedResolve().FindAllPublicProperties(excludeGenerics, excludedBaseTypes, excludedAssemblyPrefixes);
        }

        /// <summary>
        /// Gets all public fields in typeRef and base type.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static IEnumerable<FieldDefinition> FindAllPublicFields(this TypeReference typeRef, bool ignoreStatic, bool ignoreNonSerialized, System.Type[] excludedBaseTypes = null, string[] excludedAssemblyPrefixes = null)
        {
            return typeRef.Resolve().FindAllPublicFields(ignoreStatic, ignoreNonSerialized, excludedBaseTypes, excludedAssemblyPrefixes);
        }

    
        /// <summary>
        /// Returns if a typeRef is type.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public static bool IsType(this TypeReference typeRef, Type type)
        {
            if (type.IsGenericType)
                return typeRef.GetElementType().FullName == type.FullName;
            else
                return typeRef.FullName == type.FullName;
        }

        /// <summary>
        /// Returns if typeRef is a multidimensional array.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static bool IsMultidimensionalArray(this TypeReference typeRef)
        {
            return typeRef is ArrayType arrayType && arrayType.Rank > 1;
        }

        /// <summary>
        /// Returns if typeRef can be resolved.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        public static bool CanBeResolved(this TypeReference typeRef)
        {
            while (typeRef != null)
            {
                if (typeRef.Scope.Name == "Windows")
                {
                    return false;
                }

                if (typeRef.Scope.Name == "mscorlib")
                {
                    TypeDefinition resolved = typeRef.CachedResolve();
                    return resolved != null;
                }

                try
                {
                    typeRef = typeRef.CachedResolve().BaseType;
                }
                catch
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Creates a generic type out of another type, if needed.
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static TypeReference ConvertToGenericIfNeeded(this TypeDefinition type)
        {
            if (type.HasGenericParameters)
            {
                // get all the generic parameters and make a generic instance out of it
                var genericTypes = new TypeReference[type.GenericParameters.Count];
                for (int i = 0; i < type.GenericParameters.Count; i++)
                {
                    genericTypes[i] = type.GenericParameters[i].GetElementType();
                }

                return type.MakeGenericInstanceType(genericTypes);
            }
            else
            {
                return type;
            }
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/GeneralHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.CodeGenerating.ILCore;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Object;
using FishNet.Object.Helping;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System;
using System.Collections.Generic;
using UnityEngine;
using SR = System.Reflection;

namespace FishNet.CodeGenerating.Helping
{
    internal class GeneralHelper
    {
        #region Reflection references.
        internal string CodegenExcludeAttribute_FullName;
        internal MethodReference Queue_Enqueue_MethodRef;
        internal MethodReference Queue_get_Count_MethodRef;
        internal MethodReference Queue_Dequeue_MethodRef;
        internal MethodReference Queue_Clear_MethodRef;
        internal TypeReference List_TypeRef;
        internal MethodReference List_Clear_MethodRef;
        internal MethodReference List_get_Item_MethodRef;
        internal MethodReference List_get_Count_MethodRef;
        internal MethodReference List_Add_MethodRef;
        internal MethodReference List_RemoveRange_MethodRef;
        private MethodReference InstanceFinder_NetworkManager_MethodRef;
        private MethodReference NetworkBehaviour_CanLog_MethodRef;
        private MethodReference NetworkManager_CanLog_MethodRef;
        private MethodReference NetworkBehaviour_NetworkManager_MethodRef;
        private MethodReference NetworkManager_LogCommon_MethodRef;
        private MethodReference NetworkManager_LogWarning_MethodRef;
        private MethodReference NetworkManager_LogError_MethodRef;
        internal MethodReference Debug_LogCommon_MethodRef;
        internal MethodReference Debug_LogWarning_MethodRef;
        internal MethodReference Debug_LogError_MethodRef;
        internal MethodReference Comparers_EqualityCompare_MethodRef;
        internal MethodReference Comparers_IsDefault_MethodRef;
        internal MethodReference IsServer_MethodRef;
        internal MethodReference IsClient_MethodRef;
        internal MethodReference NetworkObject_Deinitializing_MethodRef;
        internal MethodReference Application_IsPlaying_MethodRef;
        private Dictionary<Type, TypeReference> _importedTypeReferences = new Dictionary<Type, TypeReference>();
        private Dictionary<FieldDefinition, FieldReference> _importedFieldReferences = new Dictionary<FieldDefinition, FieldReference>();
        private Dictionary<MethodReference, MethodDefinition> _methodReferenceResolves = new Dictionary<MethodReference, MethodDefinition>();
        private Dictionary<TypeReference, TypeDefinition> _typeReferenceResolves = new Dictionary<TypeReference, TypeDefinition>();
        private Dictionary<FieldReference, FieldDefinition> _fieldReferenceResolves = new Dictionary<FieldReference, FieldDefinition>();
        private string NonSerialized_Attribute_FullName;
        private string Single_FullName;
        #endregion

        #region Const.
        public const string UNITYENGINE_ASSEMBLY_PREFIX = "UnityEngine.";
        #endregion

        internal bool ImportReferences()
        {
            Type tmpType;
            SR.MethodInfo tmpMi;
            SR.PropertyInfo tmpPi;

            NonSerialized_Attribute_FullName = typeof(NonSerializedAttribute).FullName;
            Single_FullName = typeof(float).FullName;

            CodegenExcludeAttribute_FullName = typeof(CodegenExcludeAttribute).FullName;

            tmpType = typeof(Queue<>);
            CodegenSession.ImportReference(tmpType);
            tmpMi = tmpType.GetMethod("get_Count");
            Queue_get_Count_MethodRef = CodegenSession.ImportReference(tmpMi);
            foreach (SR.MethodInfo mi in tmpType.GetMethods())
            {

                if (mi.Name == nameof(Queue<int>.Enqueue))
                    Queue_Enqueue_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(Queue<int>.Dequeue))
                    Queue_Dequeue_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(Queue<int>.Clear))
                    Queue_Clear_MethodRef = CodegenSession.ImportReference(mi);
            }

            Type comparers = typeof(Comparers);
            foreach (SR.MethodInfo mi in comparers.GetMethods())
            {
                if (mi.Name == nameof(Comparers.EqualityCompare))
                    Comparers_EqualityCompare_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(Comparers.IsDefault))
                    Comparers_IsDefault_MethodRef = CodegenSession.ImportReference(mi);
            }

            //Misc.
            tmpType = typeof(UnityEngine.Application);
            tmpPi = tmpType.GetProperty(nameof(UnityEngine.Application.isPlaying));
            if (tmpPi != null)
                Application_IsPlaying_MethodRef = CodegenSession.ImportReference(tmpPi.GetMethod);

            //Networkbehaviour.
            Type networkBehaviourType = typeof(NetworkBehaviour);
            foreach (SR.MethodInfo methodInfo in networkBehaviourType.GetMethods())
            {
                if (methodInfo.Name == nameof(NetworkBehaviour.CanLog))
                    NetworkBehaviour_CanLog_MethodRef = CodegenSession.ImportReference(methodInfo);
            }
            foreach (SR.PropertyInfo propertyInfo in networkBehaviourType.GetProperties())
            {
                if (propertyInfo.Name == nameof(NetworkBehaviour.NetworkManager))
                    NetworkBehaviour_NetworkManager_MethodRef = CodegenSession.ImportReference(propertyInfo.GetMethod);
            }

            //Instancefinder.
            Type instanceFinderType = typeof(InstanceFinder);
            SR.PropertyInfo getNetworkManagerPropertyInfo = instanceFinderType.GetProperty(nameof(InstanceFinder.NetworkManager));
            InstanceFinder_NetworkManager_MethodRef = CodegenSession.ImportReference(getNetworkManagerPropertyInfo.GetMethod);

            //NetworkManager debug logs. 
            Type networkManagerType = typeof(NetworkManager);
            foreach (SR.MethodInfo methodInfo in networkManagerType.GetMethods())
            {
                if (methodInfo.Name == nameof(NetworkManager.Log))
                    NetworkManager_LogCommon_MethodRef = CodegenSession.ImportReference(methodInfo);
                else if (methodInfo.Name == nameof(NetworkManager.LogWarning))
                    NetworkManager_LogWarning_MethodRef = CodegenSession.ImportReference(methodInfo);
                else if (methodInfo.Name == nameof(NetworkManager.LogError))
                    NetworkManager_LogError_MethodRef = CodegenSession.ImportReference(methodInfo);
                else if (methodInfo.Name == nameof(NetworkManager.CanLog))
                    NetworkManager_CanLog_MethodRef = CodegenSession.ImportReference(methodInfo);
            }

            //Lists.
            tmpType = typeof(List<>);
            List_TypeRef = CodegenSession.ImportReference(tmpType);
            SR.MethodInfo lstMi;
            lstMi = tmpType.GetMethod("Add");
            List_Add_MethodRef = CodegenSession.ImportReference(lstMi);
            lstMi = tmpType.GetMethod("RemoveRange");
            List_RemoveRange_MethodRef = CodegenSession.ImportReference(lstMi);
            lstMi = tmpType.GetMethod("get_Count");
            List_get_Count_MethodRef = CodegenSession.ImportReference(lstMi);
            lstMi = tmpType.GetMethod("get_Item");
            List_get_Item_MethodRef = CodegenSession.ImportReference(lstMi);
            lstMi = tmpType.GetMethod("Clear");
            List_Clear_MethodRef = CodegenSession.ImportReference(lstMi);

            //Unity debug logs.
            Type debugType = typeof(UnityEngine.Debug);
            foreach (SR.MethodInfo methodInfo in debugType.GetMethods())
            {
                if (methodInfo.Name == nameof(Debug.LogWarning) && methodInfo.GetParameters().Length == 1)
                    Debug_LogWarning_MethodRef = CodegenSession.ImportReference(methodInfo);
                else if (methodInfo.Name == nameof(Debug.LogError) && methodInfo.GetParameters().Length == 1)
                    Debug_LogError_MethodRef = CodegenSession.ImportReference(methodInfo);
                else if (methodInfo.Name == nameof(Debug.Log) && methodInfo.GetParameters().Length == 1)
                    Debug_LogCommon_MethodRef = CodegenSession.ImportReference(methodInfo);
            }

            Type codegenHelper = typeof(CodegenHelper);
            foreach (SR.MethodInfo methodInfo in codegenHelper.GetMethods())
            {
                if (methodInfo.Name == nameof(CodegenHelper.NetworkObject_Deinitializing))
                    NetworkObject_Deinitializing_MethodRef = CodegenSession.ImportReference(methodInfo);
                else if (methodInfo.Name == nameof(CodegenHelper.IsClient))
                    IsClient_MethodRef = CodegenSession.ImportReference(methodInfo);
                else if (methodInfo.Name == nameof(CodegenHelper.IsServer))
                    IsServer_MethodRef = CodegenSession.ImportReference(methodInfo);
            }

            return true;
        }

        #region Resolves.
        /// <summary>
        /// Adds a typeRef to TypeReferenceResolves.
        /// </summary>
        internal void AddTypeReferenceResolve(TypeReference typeRef, TypeDefinition typeDef)
        {
            _typeReferenceResolves[typeRef] = typeDef;
        }

        /// <summary>
        /// Gets a TypeDefinition for typeRef.
        /// </summary>
        internal TypeDefinition GetTypeReferenceResolve(TypeReference typeRef)
        {
            TypeDefinition result;
            if (_typeReferenceResolves.TryGetValue(typeRef, out result))
            {
                return result;
            }
            else
            {
                result = typeRef.Resolve();
                AddTypeReferenceResolve(typeRef, result);
            }

            return result;
        }

        /// <summary>
        /// Adds a methodRef to MethodReferenceResolves.
        /// </summary>
        internal void AddMethodReferenceResolve(MethodReference methodRef, MethodDefinition methodDef)
        {
            _methodReferenceResolves[methodRef] = methodDef;
        }

        /// <summary>
        /// Gets a TypeDefinition for typeRef.
        /// </summary>
        internal MethodDefinition GetMethodReferenceResolve(MethodReference methodRef)
        {
            MethodDefinition result;
            if (_methodReferenceResolves.TryGetValue(methodRef, out result))
            {
                return result;
            }
            else
            {
                result = methodRef.Resolve();
                AddMethodReferenceResolve(methodRef, result);
            }

            return result;
        }

        /// <summary>
        /// Adds a fieldRef to FieldReferenceResolves.
        /// </summary>
        internal void AddFieldReferenceResolve(FieldReference fieldRef, FieldDefinition fieldDef)
        {
            _fieldReferenceResolves[fieldRef] = fieldDef;
        }

        /// <summary>
        /// Gets a FieldDefinition for fieldRef.
        /// </summary>
        internal FieldDefinition GetFieldReferenceResolve(FieldReference fieldRef)
        {
            FieldDefinition result;
            if (_fieldReferenceResolves.TryGetValue(fieldRef, out result))
            {
                return result;
            }
            else
            {
                result = fieldRef.Resolve();
                AddFieldReferenceResolve(fieldRef, result);
            }

            return result;
        }
        #endregion

        /// <summary>
        /// Returns if typeDef should be ignored.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal bool IgnoreTypeDefinition(TypeDefinition typeDef)
        {
            //If FishNet assembly.
            if (typeDef.Module.Assembly.Name.Name == FishNetILPP.RUNTIME_ASSEMBLY_NAME)
            {
                foreach (CustomAttribute item in typeDef.CustomAttributes)
                {
                    if (item.AttributeType.FullName == typeof(CodegenIncludeInternalAttribute).FullName)
                    {
                        if (FishNetILPP.CODEGEN_THIS_NAMESPACE.Length > 0)
                            return !typeDef.FullName.Contains(FishNetILPP.CODEGEN_THIS_NAMESPACE);
                        else
                            return false;
                    }
                }

                return true;
            }
            //Not FishNet assembly.
            else
            {
                if (FishNetILPP.CODEGEN_THIS_NAMESPACE.Length > 0)
                    return true;

                foreach (CustomAttribute item in typeDef.CustomAttributes)
                {
                    if (item.AttributeType.FullName == typeof(CodegenExcludeAttribute).FullName)
                        return true;
                }

                return false;
            }
        }

        /// <summary>
        /// Returns if type uses CodegenExcludeAttribute.
        /// </summary>
        internal bool CodegenExclude(SR.MethodInfo methodInfo)
        {
            foreach (SR.CustomAttributeData item in methodInfo.CustomAttributes)
            {
                if (item.AttributeType == typeof(CodegenExcludeAttribute))
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns if type uses CodegenExcludeAttribute.
        /// </summary>
        internal bool CodegenExclude(MethodDefinition methodDef)
        {
            foreach (CustomAttribute item in methodDef.CustomAttributes)
            {
                if (item.AttributeType.FullName == CodegenExcludeAttribute_FullName)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns if type uses CodegenExcludeAttribute.
        /// </summary>
        internal bool CodegenExclude(FieldDefinition fieldDef)
        {
            foreach (CustomAttribute item in fieldDef.CustomAttributes)
            {
                if (item.AttributeType.FullName == CodegenExcludeAttribute_FullName)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns if type uses CodegenExcludeAttribute.
        /// </summary>
        internal bool CodegenExclude(PropertyDefinition propDef)
        {
            foreach (CustomAttribute item in propDef.CustomAttributes)
            {
                if (item.AttributeType.FullName == CodegenExcludeAttribute_FullName)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Calls copiedMd with the assumption md shares the same parameters.
        /// </summary>
        internal void CallCopiedMethod(MethodDefinition md, MethodDefinition copiedMd)
        {
            ILProcessor processor = md.Body.GetILProcessor();
            processor.Emit(OpCodes.Ldarg_0);
            foreach (var item in copiedMd.Parameters)
                processor.Emit(OpCodes.Ldarg, item);
            processor.Emit(OpCodes.Call, copiedMd);

        }

        /// <summary>
        /// Copies one method to another while transferring diagnostic paths.
        /// </summary>
        internal MethodDefinition CopyMethod(MethodDefinition originalMd, string toName, out bool alreadyCreated)
        {
            TypeDefinition typeDef = originalMd.DeclaringType;

            MethodDefinition copyMd = typeDef.GetMethod(toName);
            //Already made.
            if (copyMd != null)
            {
                alreadyCreated = true;
                return copyMd;
            }
            else
            {
                alreadyCreated = false;
            }

            //Create the method body.
            copyMd = new MethodDefinition(
                toName, originalMd.Attributes, originalMd.ReturnType);
            typeDef.Methods.Add(copyMd);
            copyMd.Body.InitLocals = true;

            //Copy parameter expecations into new method.
            foreach (ParameterDefinition pd in originalMd.Parameters)
                copyMd.Parameters.Add(pd);

            //Swap bodies.
            (copyMd.Body, originalMd.Body) = (originalMd.Body, copyMd.Body);
            //Move over all the debugging information
            foreach (SequencePoint sequencePoint in originalMd.DebugInformation.SequencePoints)
                copyMd.DebugInformation.SequencePoints.Add(sequencePoint);
            originalMd.DebugInformation.SequencePoints.Clear();

            foreach (CustomDebugInformation customInfo in originalMd.CustomDebugInformations)
                copyMd.CustomDebugInformations.Add(customInfo);
            originalMd.CustomDebugInformations.Clear();
            //Swap debuginformation scope.
            (originalMd.DebugInformation.Scope, copyMd.DebugInformation.Scope) = (copyMd.DebugInformation.Scope, originalMd.DebugInformation.Scope);

            return copyMd;
        }

        /// <summary>
        /// Creates the RuntimeInitializeOnLoadMethod attribute for a method.
        /// </summary>
        internal void CreateRuntimeInitializeOnLoadMethodAttribute(MethodDefinition methodDef, string loadType = "")
        {
            TypeReference attTypeRef = GetTypeReference(typeof(RuntimeInitializeOnLoadMethodAttribute));
            foreach (CustomAttribute item in methodDef.CustomAttributes)
            {
                //Already exist.
                if (item.AttributeType.FullName == attTypeRef.FullName)
                    return;
            }

            int parameterRequirement = (loadType.Length == 0) ? 0 : 1;
            MethodDefinition constructorMethodDef = attTypeRef.GetConstructor(parameterRequirement);
            MethodReference constructorMethodRef = CodegenSession.ImportReference(constructorMethodDef);
            CustomAttribute ca = new CustomAttribute(constructorMethodRef);
            /* If load type isn't null then it
             * has to be passed in as the first argument. */
            if (loadType.Length > 0)
            {
                Type t = typeof(RuntimeInitializeLoadType);
                foreach (UnityEngine.RuntimeInitializeLoadType value in t.GetEnumValues())
                {
                    if (loadType == value.ToString())
                    {
                        TypeReference tr = CodegenSession.ImportReference(t);
                        CustomAttributeArgument arg = new CustomAttributeArgument(tr, value);
                        ca.ConstructorArguments.Add(arg);
                    }
                }
            }

            methodDef.CustomAttributes.Add(ca);
        }

        /// <summary>
        /// Gets the default AutoPackType to use for typeRef.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal AutoPackType GetDefaultAutoPackType(TypeReference typeRef)
        {
            //Singles are defauled to unpacked.
            if (typeRef.FullName == Single_FullName)
                return AutoPackType.Unpacked;
            else
                return AutoPackType.Packed;
        }

        /// <summary>
        /// Gets the InitializeOnce method in typeDef or creates the method should it not exist.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal MethodDefinition GetOrCreateMethod(TypeDefinition typeDef, out bool created, MethodAttributes methodAttr, string methodName, TypeReference returnType)
        {
            MethodDefinition result = typeDef.GetMethod(methodName);
            if (result == null)
            {
                created = true;
                result = new MethodDefinition(methodName, methodAttr, returnType);
                typeDef.Methods.Add(result);
            }
            else
            {
                created = false;
            }

            return result;
        }

        /// <summary>
        /// Gets a class within moduleDef or creates and returns the class if it does not already exist.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal TypeDefinition GetOrCreateClass(out bool created, TypeAttributes typeAttr, string className, TypeReference baseTypeRef)
        {
            TypeDefinition type = CodegenSession.Module.GetClass(className);
            if (type != null)
            {
                created = false;
                return type;
            }
            else
            {
                created = true;
                type = new TypeDefinition(FishNetILPP.RUNTIME_ASSEMBLY_NAME, className,
                    typeAttr, CodegenSession.ImportReference(typeof(object)));
                //Add base class if specified.
                if (baseTypeRef != null)
                    type.BaseType = CodegenSession.ImportReference(baseTypeRef);

                CodegenSession.Module.Types.Add(type);
                return type;
            }
        }

        #region HasNonSerializableAttribute
        /// <summary>
        /// Returns if fieldDef has a NonSerialized attribute.
        /// </summary>
        /// <param name="fieldDef"></param>
        /// <returns></returns>
        internal bool HasNonSerializableAttribute(FieldDefinition fieldDef)
        {
            foreach (CustomAttribute customAttribute in fieldDef.CustomAttributes)
            {
                if (customAttribute.AttributeType.FullName == NonSerialized_Attribute_FullName)
                    return true;
            }

            //Fall through, no matches.
            return false;
        }
        /// <summary>
        /// Returns if typeDef has a NonSerialized attribute.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal bool HasNonSerializableAttribute(TypeDefinition typeDef)
        {
            foreach (CustomAttribute customAttribute in typeDef.CustomAttributes)
            {
                if (customAttribute.AttributeType.FullName == NonSerialized_Attribute_FullName)
                    return true;
            }

            //Fall through, no matches.
            return false;
        }
        #endregion

        /// <summary>
        /// Gets a TypeReference for a type.
        /// </summary>
        /// <param name="type"></param>
        internal TypeReference GetTypeReference(Type type)
        {
            TypeReference result;
            if (!_importedTypeReferences.TryGetValue(type, out result))
            {
                result = CodegenSession.ImportReference(type);
                _importedTypeReferences.Add(type, result);
            }

            return result;
        }

        /// <summary>
        /// Gets a FieldReference for a type.
        /// </summary>
        /// <param name="type"></param>
        internal FieldReference GetFieldReference(FieldDefinition fieldDef)
        {
            FieldReference result;
            if (!_importedFieldReferences.TryGetValue(fieldDef, out result))
            {
                result = CodegenSession.ImportReference(fieldDef);
                _importedFieldReferences.Add(fieldDef, result);
            }

            return result;
        }

        /// <summary>
        /// Gets the current constructor for typeDef, or makes a new one if constructor doesn't exist.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal MethodDefinition GetOrCreateConstructor(TypeDefinition typeDef, out bool created, bool makeStatic)
        {
            // find constructor
            MethodDefinition constructorMethodDef = typeDef.GetMethod(".cctor");
            if (constructorMethodDef == null)
                constructorMethodDef = typeDef.GetMethod(".ctor");

            //Constructor already exist.
            if (constructorMethodDef != null)
            {
                if (!makeStatic)
                    constructorMethodDef.Attributes &= ~MethodAttributes.Static;

                created = false;
            }
            //Static constructor does not exist yet.
            else
            {
                created = true;
                MethodAttributes methodAttr = (MonoFN.Cecil.MethodAttributes.HideBySig |
                        MonoFN.Cecil.MethodAttributes.SpecialName |
                        MonoFN.Cecil.MethodAttributes.RTSpecialName);
                if (makeStatic)
                    methodAttr |= MonoFN.Cecil.MethodAttributes.Static;

                //Create a constructor.
                constructorMethodDef = new MethodDefinition(".ctor", methodAttr,
                        typeDef.Module.TypeSystem.Void
                        );

                typeDef.Methods.Add(constructorMethodDef);

                //Add ret.
                ILProcessor processor = constructorMethodDef.Body.GetILProcessor();
                processor.Emit(OpCodes.Ret);
            }

            return constructorMethodDef;
        }

        /// <summary>
        /// Creates a return of boolean type.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="result"></param>
        internal void CreateRetBoolean(ILProcessor processor, bool result)
        {
            OpCode code = (result) ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0;
            processor.Emit(code);
            processor.Emit(OpCodes.Ret);
        }

        #region Debug logging.
        /// <summary>
        /// Creates a debug print if NetworkManager.CanLog is true.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="loggingType"></param>
        /// <param name="useStatic">True to use InstanceFinder, false to use base.</param>
        /// <returns></returns>
        internal List<Instruction> CreateDebugWithCanLogInstructions(ILProcessor processor, string message, LoggingType loggingType, bool useStatic, bool useNetworkManagerLog)
        {
            List<Instruction> instructions = new List<Instruction>();
            if (loggingType == LoggingType.Off)
                return instructions;

            List<Instruction> debugPrint = CreateDebugInstructions(processor, message, loggingType, useNetworkManagerLog);
            //Couldn't make debug print.
            if (debugPrint.Count == 0)
                return instructions;

            VariableDefinition networkManagerVd = CreateVariable(processor.Body.Method, typeof(NetworkManager));
            //Using InstanceFinder(static).
            if (useStatic)
            {
                //Store instancefinder to nm variable.
                instructions.Add(processor.Create(OpCodes.Call, InstanceFinder_NetworkManager_MethodRef));
                instructions.Add(processor.Create(OpCodes.Stloc, networkManagerVd));
            }
            //Using networkBehaviour.
            else
            {
                //Store nm reference.
                instructions.Add(processor.Create(OpCodes.Ldarg_0));
                instructions.Add(processor.Create(OpCodes.Call, NetworkBehaviour_NetworkManager_MethodRef));
                instructions.Add(processor.Create(OpCodes.Stloc, networkManagerVd));
                //If was set to null then try to log with instancefinder.
                Instruction skipStaticSetInst = processor.Create(OpCodes.Nop);
                //if (nmVd == null) nmVd = InstanceFinder.NetworkManager.
                instructions.Add(processor.Create(OpCodes.Ldloc, networkManagerVd));
                instructions.Add(processor.Create(OpCodes.Brtrue_S, skipStaticSetInst));
                //Store instancefinder to nm variable.
                instructions.Add(processor.Create(OpCodes.Call, InstanceFinder_NetworkManager_MethodRef));
                instructions.Add(processor.Create(OpCodes.Stloc, networkManagerVd));
                instructions.Add(skipStaticSetInst);
            }

            Instruction skipDebugInst = processor.Create(OpCodes.Nop);
            //null check nm reference. If null then skip logging.
            instructions.Add(processor.Create(OpCodes.Ldloc, networkManagerVd));
            instructions.Add(processor.Create(OpCodes.Brfalse_S, skipDebugInst));

            //Only need to call CanLog if not using networkmanager logging.
            if (!useNetworkManagerLog)
            {
                //Call canlog.
                instructions.Add(processor.Create(OpCodes.Ldarg_0));
                instructions.Add(processor.Create(OpCodes.Ldc_I4, (int)loggingType));
                instructions.Add(processor.Create(OpCodes.Call, NetworkBehaviour_CanLog_MethodRef));
                instructions.Add(processor.Create(OpCodes.Brfalse_S, skipDebugInst));
            }

            instructions.Add(processor.Create(OpCodes.Ldloc, networkManagerVd));
            instructions.AddRange(debugPrint);
            instructions.Add(skipDebugInst);

            return instructions;
        }

        /// <summary>
        /// Creates a debug print if NetworkManager.CanLog is true.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="loggingType"></param>
        /// <param name="useStatic">True to use InstanceFinder, false to use base.</param>
        /// <returns></returns>
        internal void CreateDebugWithCanLog(ILProcessor processor, string message, LoggingType loggingType, bool useStatic, bool useNetworkManagerLog)
        {
            List<Instruction> instructions = CreateDebugWithCanLogInstructions(processor, message, loggingType, useStatic, useNetworkManagerLog);
            if (instructions.Count == 0)
                return;

            processor.Add(instructions);
        }
        /// <summary>
        /// Creates a debug and returns instructions.
        /// </summary>
        /// <param name="processor"></param>
        private List<Instruction> CreateDebugInstructions(ILProcessor processor, string message, LoggingType loggingType, bool useNetworkManagerLog)
        {
            List<Instruction> instructions = new List<Instruction>();
            if (loggingType == LoggingType.Off)
            {
                CodegenSession.LogError($"CreateDebug called with LoggingType.Off.");
                return instructions;
            }

            instructions.Add(processor.Create(OpCodes.Ldstr, message));

            MethodReference methodRef;
            if (loggingType == LoggingType.Common)
                methodRef = (useNetworkManagerLog) ? NetworkManager_LogCommon_MethodRef : Debug_LogCommon_MethodRef;
            else if (loggingType == LoggingType.Warning)
                methodRef = (useNetworkManagerLog) ? NetworkManager_LogWarning_MethodRef : Debug_LogWarning_MethodRef;
            else
                methodRef = (useNetworkManagerLog) ? NetworkManager_LogError_MethodRef : Debug_LogError_MethodRef;

            instructions.Add(processor.Create(OpCodes.Call, methodRef));

            return instructions;
        }
        #endregion

        #region CreateVariable / CreateParameter.
        /// <summary>
        /// Creates a parameter within methodDef and returns it's ParameterDefinition.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="parameterTypeRef"></param>
        /// <returns></returns>
        internal ParameterDefinition CreateParameter(MethodDefinition methodDef, TypeDefinition parameterTypeDef, string name = "", ParameterAttributes attributes = ParameterAttributes.None, int index = -1)
        {
            TypeReference typeRef = methodDef.Module.ImportReference(parameterTypeDef);
            return CreateParameter(methodDef, typeRef, name, attributes, index);
        }
        /// <summary>
        /// Creates a parameter within methodDef and returns it's ParameterDefinition.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="parameterTypeRef"></param>
        /// <returns></returns>
        internal ParameterDefinition CreateParameter(MethodDefinition methodDef, TypeReference parameterTypeRef, string name = "", ParameterAttributes attributes = ParameterAttributes.None, int index = -1)
        {
            int currentCount = methodDef.Parameters.Count;
            if (string.IsNullOrEmpty(name))
                name = (parameterTypeRef.Name + currentCount);
            ParameterDefinition parameterDef = new ParameterDefinition(name, attributes, parameterTypeRef);
            if (index == -1)
                methodDef.Parameters.Add(parameterDef);
            else
                methodDef.Parameters.Insert(index, parameterDef);
            return parameterDef;
        }
        /// <summary>
        /// Creates a parameter within methodDef and returns it's ParameterDefinition.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="parameterTypeRef"></param>
        /// <returns></returns>
        internal ParameterDefinition CreateParameter(MethodDefinition methodDef, Type parameterType, string name = "", ParameterAttributes attributes = ParameterAttributes.None, int index = -1)
        {
            return CreateParameter(methodDef, GetTypeReference(parameterType), name, attributes, index);
        }
        /// <summary>
        /// Creates a variable type within the body and returns it's VariableDef.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="variableTypeRef"></param>
        /// <returns></returns>
        internal VariableDefinition CreateVariable(MethodDefinition methodDef, TypeReference variableTypeRef)
        {
            VariableDefinition variableDef = new VariableDefinition(variableTypeRef);
            methodDef.Body.Variables.Add(variableDef);
            return variableDef;
        }
        /// Creates a variable type within the body and returns it's VariableDef.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="methodDef"></param>
        /// <param name="variableTypeRef"></param>
        /// <returns></returns>
        internal VariableDefinition CreateVariable(MethodDefinition methodDef, Type variableType)
        {
            return CreateVariable(methodDef, GetTypeReference(variableType));
        }
        #endregion

        #region SetVariableDef.
        /// <summary>
        /// Initializes variableDef as a new object or collection of typeDef.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="variableDef"></param>
        /// <param name="typeDef"></param>
        internal void SetVariableDefinitionFromObject(ILProcessor processor, VariableDefinition variableDef, TypeDefinition typeDef)
        {
            TypeReference type = variableDef.VariableType;
            if (type.IsValueType)
            {
                // structs are created with Initobj
                processor.Emit(OpCodes.Ldloca, variableDef);
                processor.Emit(OpCodes.Initobj, type);
            }
            else if (typeDef.InheritsFrom<UnityEngine.ScriptableObject>())
            {
                MethodReference soCreateInstanceMr = processor.Body.Method.Module.ImportReference(() => UnityEngine.ScriptableObject.CreateInstance<UnityEngine.ScriptableObject>());
                GenericInstanceMethod genericInstanceMethod = soCreateInstanceMr.GetElementMethod().MakeGenericMethod(new TypeReference[] { type });
                processor.Emit(OpCodes.Call, genericInstanceMethod);
                processor.Emit(OpCodes.Stloc, variableDef);
            }
            else
            {
                MethodDefinition constructorMethodDef = type.GetConstructor();
                if (constructorMethodDef == null)
                {
                    CodegenSession.LogError($"{type.Name} can't be deserialized because a default constructor could not be found. Create a default constructor or a custom serializer/deserializer.");
                    return;
                }

                MethodReference constructorMethodRef = processor.Body.Method.Module.ImportReference(constructorMethodDef);
                processor.Emit(OpCodes.Newobj, constructorMethodRef);
                processor.Emit(OpCodes.Stloc, variableDef);
            }
        }

        /// <summary>
        /// Assigns value to a VariableDef.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="variableDef"></param>
        /// <param name="value"></param>
        internal void SetVariableDefinitionFromInt(ILProcessor processor, VariableDefinition variableDef, int value)
        {
            processor.Emit(OpCodes.Ldc_I4, value);
            processor.Emit(OpCodes.Stloc, variableDef);
        }
        /// <summary>
        /// Assigns value to a VariableDef.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="variableDef"></param>
        /// <param name="value"></param>
        internal void SetVariableDefinitionFromParameter(ILProcessor processor, VariableDefinition variableDef, ParameterDefinition value)
        {
            processor.Emit(OpCodes.Ldarg, value);
            processor.Emit(OpCodes.Stloc, variableDef);
        }
        #endregion.

        /// <summary>
        /// Returns if an instruction is a call to a method.
        /// </summary>
        /// <param name="instruction"></param>
        /// <param name="calledMethod"></param>
        /// <returns></returns>
        internal bool IsCallToMethod(Instruction instruction, out MethodDefinition calledMethod)
        {
            if (instruction.OpCode == OpCodes.Call && instruction.Operand is MethodDefinition method)
            {
                calledMethod = method;
                return true;
            }
            else
            {
                calledMethod = null;
                return false;
            }
        }

        /// <summary>
        /// Returns if a serializer and deserializer exist for typeRef. 
        /// </summary>
        /// <param name="typeRef"></param>
        /// <param name="create">True to create if missing.</param>
        /// <returns></returns>
        internal bool HasSerializerAndDeserializer(TypeReference typeRef, bool create)
        {
            //Make sure it's imported into current module.
            typeRef = CodegenSession.ImportReference(typeRef);
            //Can be serialized/deserialized.
            bool hasWriter = CodegenSession.WriterHelper.HasSerializer(typeRef, create);
            bool hasReader = CodegenSession.ReaderHelper.HasDeserializer(typeRef, create);

            return (hasWriter && hasReader);
        }

        /// <summary>
        /// Creates a return of default value for methodDef.
        /// </summary>
        /// <returns></returns>
        public List<Instruction> CreateRetDefault(MethodDefinition methodDef, ModuleDefinition importReturnModule = null)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();
            List<Instruction> instructions = new List<Instruction>();
            //If requires a value return.
            if (methodDef.ReturnType != methodDef.Module.TypeSystem.Void)
            {
                //Import type first.
                methodDef.Module.ImportReference(methodDef.ReturnType);
                if (importReturnModule != null)
                    importReturnModule.ImportReference(methodDef.ReturnType);
                VariableDefinition vd = CodegenSession.GeneralHelper.CreateVariable(methodDef, methodDef.ReturnType);
                instructions.Add(processor.Create(OpCodes.Ldloca_S, vd));
                instructions.Add(processor.Create(OpCodes.Initobj, vd.VariableType));
                instructions.Add(processor.Create(OpCodes.Ldloc, vd));
            }
            instructions.Add(processor.Create(OpCodes.Ret));

            return instructions;
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/GenericReaderHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Serializing;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Rocks;
using System;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Helping
{

    internal class GenericReaderHelper
    {

        #region Reflection references.
        private TypeReference _genericReaderTypeRef;
        private TypeReference _readerTypeRef;
        private MethodReference _readGetSetMethodRef;
        private MethodReference _readAutoPackGetSetMethodRef;
        private TypeReference _functionT2TypeRef;
        private TypeReference _functionT3TypeRef;
        private MethodReference _functionT2ConstructorMethodRef;
        private MethodReference _functionT3ConstructorMethodRef;
        private TypeDefinition _generatedReaderWriterClassTypeDef;
        private MethodDefinition _generatedReaderWriterOnLoadMethodDef;
        private TypeReference _autoPackTypeRef;
        #endregion

        #region Misc.
        /// <summary>
        /// TypeReferences which have already had delegates made for.
        /// </summary>
        private HashSet<TypeReference> _delegatedTypes = new HashSet<TypeReference>();
        #endregion

        #region Const.
        internal const string INITIALIZEONCE_METHOD_NAME = GenericWriterHelper.INITIALIZEONCE_METHOD_NAME;
        internal const MethodAttributes INITIALIZEONCE_METHOD_ATTRIBUTES = GenericWriterHelper.INITIALIZEONCE_METHOD_ATTRIBUTES;
        #endregion

        /// <summary>
        /// Imports references needed by this helper.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal bool ImportReferences()
        {
            _genericReaderTypeRef = CodegenSession.ImportReference(typeof(GenericReader<>));
            _readerTypeRef = CodegenSession.ImportReference(typeof(Reader));
            _functionT2TypeRef = CodegenSession.ImportReference(typeof(Func<,>));
            _functionT3TypeRef = CodegenSession.ImportReference(typeof(Func<,,>));
            _functionT2ConstructorMethodRef = CodegenSession.ImportReference(typeof(Func<,>).GetConstructors()[0]);
            _functionT3ConstructorMethodRef = CodegenSession.ImportReference(typeof(Func<,,>).GetConstructors()[0]);

            _autoPackTypeRef = CodegenSession.ImportReference(typeof(AutoPackType));

            System.Reflection.PropertyInfo writePropertyInfo;
            writePropertyInfo = typeof(GenericReader<>).GetProperty(nameof(GenericReader<int>.Read));
            _readGetSetMethodRef = CodegenSession.ImportReference(writePropertyInfo.GetSetMethod());
            writePropertyInfo = typeof(GenericReader<>).GetProperty(nameof(GenericReader<int>.ReadAutoPack));
            _readAutoPackGetSetMethodRef = CodegenSession.ImportReference(writePropertyInfo.GetSetMethod());

            return true;
        }

        /// <summary>
        /// Creates a Read delegate for readMethodRef and places it within the generated reader/writer constructor.
        /// </summary>
        /// <param name="readMethodRef"></param>
        /// <param name="diagnostics"></param>
        internal void CreateReadDelegate(MethodReference readMethodRef)
        {
            bool created;
            /* If class for generated reader/writers isn't known yet.
            * It's possible this is the case if the entry being added
            * now is the first entry. That would mean the class was just
            * generated. */
            if (_generatedReaderWriterClassTypeDef == null)
                _generatedReaderWriterClassTypeDef = CodegenSession.GeneralHelper.GetOrCreateClass(out _, ReaderGenerator.GENERATED_TYPE_ATTRIBUTES, ReaderGenerator.GENERATED_READERS_CLASS_NAME, null);
            /* If constructor isn't set then try to get or create it
             * and also add it to methods if were created. */
            if (_generatedReaderWriterOnLoadMethodDef == null)
            {
                _generatedReaderWriterOnLoadMethodDef = CodegenSession.GeneralHelper.GetOrCreateMethod(_generatedReaderWriterClassTypeDef, out created, INITIALIZEONCE_METHOD_ATTRIBUTES, INITIALIZEONCE_METHOD_NAME, CodegenSession.Module.TypeSystem.Void);
                if (created)
                    CodegenSession.GeneralHelper.CreateRuntimeInitializeOnLoadMethodAttribute(_generatedReaderWriterOnLoadMethodDef);
            }
            //Check if ret already exist, if so remove it; ret will be added on again in this method.
            if (_generatedReaderWriterOnLoadMethodDef.Body.Instructions.Count != 0)
            {
                int lastIndex = (_generatedReaderWriterOnLoadMethodDef.Body.Instructions.Count - 1);
                if (_generatedReaderWriterOnLoadMethodDef.Body.Instructions[lastIndex].OpCode == OpCodes.Ret)
                    _generatedReaderWriterOnLoadMethodDef.Body.Instructions.RemoveAt(lastIndex);
            }
            //Check if already exist.
            ILProcessor processor = _generatedReaderWriterOnLoadMethodDef.Body.GetILProcessor();
            TypeReference dataTypeRef = readMethodRef.ReturnType;
            if (_delegatedTypes.Contains(dataTypeRef))
            {
                CodegenSession.LogError($"Generic read already created for {dataTypeRef.FullName}.");
                return;
            }
            else
            {
                _delegatedTypes.Add(dataTypeRef);
            }

            //Create a Func<Reader, T> delegate 
            processor.Emit(OpCodes.Ldnull);
            processor.Emit(OpCodes.Ldftn, readMethodRef);

            GenericInstanceType functionGenericInstance;
            MethodReference functionConstructorInstanceMethodRef;
            bool isAutoPacked = CodegenSession.ReaderHelper.IsAutoPackedType(dataTypeRef);

            //Generate for autopacktype.
            if (isAutoPacked)
            {
                functionGenericInstance = _functionT3TypeRef.MakeGenericInstanceType(_readerTypeRef, _autoPackTypeRef, dataTypeRef);
                functionConstructorInstanceMethodRef = _functionT3ConstructorMethodRef.MakeHostInstanceGeneric(functionGenericInstance);
            }
            //Not autopacked.
            else
            {
                functionGenericInstance = _functionT2TypeRef.MakeGenericInstanceType(_readerTypeRef, dataTypeRef);
                functionConstructorInstanceMethodRef = _functionT2ConstructorMethodRef.MakeHostInstanceGeneric(functionGenericInstance);
            }

            processor.Emit(OpCodes.Newobj, functionConstructorInstanceMethodRef);

            //Call delegate to GeneratedReader<T>.Read
            GenericInstanceType genericInstance = _genericReaderTypeRef.MakeGenericInstanceType(dataTypeRef);
            MethodReference genericReaderMethodRef = (isAutoPacked) ?
                _readAutoPackGetSetMethodRef.MakeHostInstanceGeneric(genericInstance) :
                _readGetSetMethodRef.MakeHostInstanceGeneric(genericInstance);
            processor.Emit(OpCodes.Call, genericReaderMethodRef);

            processor.Emit(OpCodes.Ret);
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/GenericWriterHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Serializing;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Rocks;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping
{

    internal class GenericWriterHelper
    {

        #region Reflection references.
        private TypeReference _genericWriterTypeRef;
        private TypeReference _writerTypeRef;
        private MethodReference _writeGetSetMethodRef;
        private MethodReference _writeAutoPackGetSetMethodRef;
        internal TypeReference ActionT2TypeRef;
        internal TypeReference ActionT3TypeRef;
        internal MethodReference ActionT2ConstructorMethodRef;
        internal MethodReference ActionT3ConstructorMethodRef;
        private TypeDefinition _generatedReaderWriterClassTypeDef;
        private MethodDefinition _generatedReaderWriterOnLoadMethodDef;
        private TypeReference _autoPackTypeRef;
        #endregion

        #region Misc.
        /// <summary>
        /// TypeReferences which have already had delegates made for.
        /// </summary>
        private HashSet<TypeReference> _delegatedTypes = new HashSet<TypeReference>();
        #endregion

        #region Const.
        internal const string INITIALIZEONCE_METHOD_NAME = "InitializeOnce";
        internal const MethodAttributes INITIALIZEONCE_METHOD_ATTRIBUTES = MethodAttributes.Static;
        #endregion

        /// <summary>
        /// Imports references needed by this helper.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal bool ImportReferences()
        {
            _genericWriterTypeRef = CodegenSession.ImportReference(typeof(GenericWriter<>));
            _writerTypeRef = CodegenSession.ImportReference(typeof(Writer));
            ActionT2TypeRef = CodegenSession.ImportReference(typeof(Action<,>));
            ActionT3TypeRef = CodegenSession.ImportReference(typeof(Action<,,>));
            ActionT2ConstructorMethodRef = CodegenSession.ImportReference(typeof(Action<,>).GetConstructors()[0]);
            ActionT3ConstructorMethodRef = CodegenSession.ImportReference(typeof(Action<,,>).GetConstructors()[0]);

            _autoPackTypeRef = CodegenSession.ImportReference(typeof(AutoPackType));

            System.Reflection.PropertyInfo writePropertyInfo;
            writePropertyInfo = typeof(GenericWriter<>).GetProperty(nameof(GenericWriter<int>.Write));
            _writeGetSetMethodRef = CodegenSession.ImportReference(writePropertyInfo.GetSetMethod());
            writePropertyInfo = typeof(GenericWriter<>).GetProperty(nameof(GenericWriter<int>.WriteAutoPack));
            _writeAutoPackGetSetMethodRef = CodegenSession.ImportReference(writePropertyInfo.GetSetMethod());

            return true;
        }

        /// <summary>
        /// Creates a variant of an instanced write method.
        /// </summary>
        /// <param name="writeMethodRef"></param>
        /// <param name="diagnostics"></param>
        internal void CreateInstancedStaticWrite(MethodReference writeMethodRef)
        {
            if (_generatedReaderWriterClassTypeDef == null)
                _generatedReaderWriterClassTypeDef = CodegenSession.GeneralHelper.GetOrCreateClass(out _, WriterGenerator.GENERATED_TYPE_ATTRIBUTES, WriterGenerator.GENERATED_WRITERS_CLASS_NAME, null);

            MethodDefinition writeMethodDef = writeMethodRef.CachedResolve();
            MethodDefinition createdMethodDef = new MethodDefinition($"Static___{writeMethodRef.Name}",
                (MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig),
                _generatedReaderWriterClassTypeDef.Module.TypeSystem.Void);
            _generatedReaderWriterClassTypeDef.Methods.Add(createdMethodDef);

            TypeReference extensionAttributeTypeRef = CodegenSession.ImportReference(typeof(System.Runtime.CompilerServices.ExtensionAttribute));
            MethodDefinition constructor = extensionAttributeTypeRef.GetConstructor();

            MethodReference extensionAttributeConstructorMethodRef = CodegenSession.ImportReference(constructor);
            CustomAttribute extensionCustomAttribute = new CustomAttribute(extensionAttributeConstructorMethodRef);
            createdMethodDef.CustomAttributes.Add(extensionCustomAttribute);

            /* Add parameters to new method. */
            //First add extension.
            ParameterDefinition extensionParameterDef = CodegenSession.GeneralHelper.CreateParameter(createdMethodDef, typeof(PooledWriter), "pooledWriter", ParameterAttributes.None);
            //Then other types.
            ParameterDefinition[] remainingParameterDefs = new ParameterDefinition[writeMethodDef.Parameters.Count];
            for (int i = 0; i < writeMethodDef.Parameters.Count; i++)
            {
                remainingParameterDefs[i] = CodegenSession.GeneralHelper.CreateParameter(createdMethodDef, writeMethodDef.Parameters[i].ParameterType);
                _generatedReaderWriterClassTypeDef.Module.ImportReference(remainingParameterDefs[i].ParameterType.CachedResolve());
            }

            ILProcessor processor = createdMethodDef.Body.GetILProcessor();
            //Load all parameters.
            foreach (ParameterDefinition pd in remainingParameterDefs)
                processor.Emit(OpCodes.Ldarg, pd);
            //Call instanced method.
            processor.Emit(OpCodes.Ldarg, extensionParameterDef);
            processor.Emit(OpCodes.Call, writeMethodRef);
            processor.Emit(OpCodes.Ret);
        }

        /// <summary>
        /// Creates a Write delegate for writeMethodRef and places it within the generated reader/writer constructor.
        /// </summary>
        /// <param name="writeMethodRef"></param>
        internal void CreateWriteDelegate(MethodReference writeMethodRef, bool isStatic)
        {
            /* If class for generated reader/writers isn't known yet.
            * It's possible this is the case if the entry being added
            * now is the first entry. That would mean the class was just
            * generated. */
            bool created;

            if (_generatedReaderWriterClassTypeDef == null)
                _generatedReaderWriterClassTypeDef = CodegenSession.GeneralHelper.GetOrCreateClass(out created, WriterGenerator.GENERATED_TYPE_ATTRIBUTES, WriterGenerator.GENERATED_WRITERS_CLASS_NAME, null);
            /* If constructor isn't set then try to get or create it
             * and also add it to methods if were created. */
            if (_generatedReaderWriterOnLoadMethodDef == null)
            {
                _generatedReaderWriterOnLoadMethodDef = CodegenSession.GeneralHelper.GetOrCreateMethod(_generatedReaderWriterClassTypeDef, out created, INITIALIZEONCE_METHOD_ATTRIBUTES, INITIALIZEONCE_METHOD_NAME, CodegenSession.Module.TypeSystem.Void);
                if (created)
                    CodegenSession.GeneralHelper.CreateRuntimeInitializeOnLoadMethodAttribute(_generatedReaderWriterOnLoadMethodDef);
            }
            //Check if ret already exist, if so remove it; ret will be added on again in this method.
            if (_generatedReaderWriterOnLoadMethodDef.Body.Instructions.Count != 0)
            {
                int lastIndex = (_generatedReaderWriterOnLoadMethodDef.Body.Instructions.Count - 1);
                if (_generatedReaderWriterOnLoadMethodDef.Body.Instructions[lastIndex].OpCode == OpCodes.Ret)
                    _generatedReaderWriterOnLoadMethodDef.Body.Instructions.RemoveAt(lastIndex);
            }

            ILProcessor processor = _generatedReaderWriterOnLoadMethodDef.Body.GetILProcessor();
            TypeReference dataTypeRef;
            //Static methods will have the data type as the second parameter (1). 
            if (isStatic)
                dataTypeRef = writeMethodRef.Parameters[1].ParameterType;
            else
                dataTypeRef = writeMethodRef.Parameters[0].ParameterType;
            //Check if writer already exist.
            if (_delegatedTypes.Contains(dataTypeRef))
            {
                CodegenSession.LogError($"Generic write already created for {dataTypeRef.FullName}.");
                return;
            }
            else
            {
                _delegatedTypes.Add(dataTypeRef);
            }

            /* Create a Action<Writer, T> delegate.
             * May also be Action<Writer, AutoPackType, T> delegate
             * for packed types. */
            processor.Emit(OpCodes.Ldnull);
            processor.Emit(OpCodes.Ldftn, writeMethodRef);

            GenericInstanceType actionGenericInstance;
            MethodReference actionConstructorInstanceMethodRef;
            bool isAutoPacked = CodegenSession.WriterHelper.IsAutoPackedType(dataTypeRef);

            //Generate for auto pack type.
            if (isAutoPacked)
            {
                actionGenericInstance = ActionT3TypeRef.MakeGenericInstanceType(_writerTypeRef, dataTypeRef, _autoPackTypeRef);
                actionConstructorInstanceMethodRef = ActionT3ConstructorMethodRef.MakeHostInstanceGeneric(actionGenericInstance);
            }
            //Generate for normal type.
            else
            {
                actionGenericInstance = ActionT2TypeRef.MakeGenericInstanceType(_writerTypeRef, dataTypeRef);
                actionConstructorInstanceMethodRef = ActionT2ConstructorMethodRef.MakeHostInstanceGeneric(actionGenericInstance);
            }

            processor.Emit(OpCodes.Newobj, actionConstructorInstanceMethodRef);
            //Call delegate to GenericWriter<T>.Write
            GenericInstanceType genericInstance = _genericWriterTypeRef.MakeGenericInstanceType(dataTypeRef);
            MethodReference genericrWriteMethodRef = (isAutoPacked) ?
                _writeAutoPackGetSetMethodRef.MakeHostInstanceGeneric(genericInstance) :
                _writeGetSetMethodRef.MakeHostInstanceGeneric(genericInstance);
            processor.Emit(OpCodes.Call, genericrWriteMethodRef);

            processor.Emit(OpCodes.Ret);
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/NetworkBehaviourHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.CodeGenerating.Processing;
using FishNet.Component.Prediction;
using FishNet.Configuring;
using FishNet.Managing.Logging;
using FishNet.Object;
using FishNet.Object.Delegating;
using FishNet.Object.Helping;
using FishNet.Object.Prediction.Delegating;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace FishNet.CodeGenerating.Helping
{
    internal class NetworkBehaviourHelper
    {
        #region Reflection references.
        //Names.
        internal string FullName;
        //Prediction.
        internal MethodReference ClearReplicateCache_1P_MethodRef;
        internal MethodReference ClearReplicateCache_0P_MethodRef;
        internal MethodReference SetLastReconcileTick_MethodRef;
        internal MethodReference SetLastReplicateTick_MethodRef;
        internal MethodReference TransformMayChange_MethodRef;
        internal MethodReference SendReplicateRpc_MethodRef;
        internal MethodReference SendReconcileRpc_MethodRef;
        internal MethodReference RegisterReplicateRpc_MethodRef;
        internal MethodReference RegisterReconcileRpc_MethodRef;
        internal MethodReference ReplicateRpcDelegateConstructor_MethodRef;
        internal MethodReference ReconcileRpcDelegateConstructor_MethodRef;
        //RPCs.
        internal MethodReference SendServerRpc_MethodRef;
        internal MethodReference SendObserversRpc_MethodRef;
        internal MethodReference SendTargetRpc_MethodRef;
        internal MethodReference DirtySyncType_MethodRef;
        internal MethodReference RegisterServerRpc_MethodRef;
        internal MethodReference RegisterObserversRpc_MethodRef;
        internal MethodReference RegisterTargetRpc_MethodRef;
        internal MethodReference ServerRpcDelegateConstructor_MethodRef;
        internal MethodReference ClientRpcDelegateConstructor_MethodRef;
        //Is checks.
        internal MethodReference IsClient_MethodRef;
        internal MethodReference IsOwner_MethodRef;
        internal MethodReference IsServer_MethodRef;
        internal MethodReference IsHost_MethodRef;
        //Misc.
        internal TypeReference TypeRef;
        internal MethodReference CompareOwner_MethodRef;
        internal MethodReference LocalConnection_MethodRef;
        internal MethodReference Owner_MethodRef;
        internal MethodReference ReadSyncVar_MethodRef;
        internal MethodReference NetworkInitializeInternal_MethodRef;
        //TimeManager.
        internal MethodReference TimeManager_MethodRef;
        #endregion

        #region Const.
        internal const uint MAX_RPC_ALLOWANCE = ushort.MaxValue;
        internal const string AWAKE_METHOD_NAME = "Awake";
        internal const string DISABLE_LOGGING_TEXT = "This message may be disabled by setting the Logging field in your attribute to LoggingType.Off";
        #endregion

        internal bool ImportReferences()
        {
            Type networkBehaviourType = typeof(NetworkBehaviour);
            TypeRef = CodegenSession.ImportReference(networkBehaviourType);
            FullName = networkBehaviourType.FullName;
            CodegenSession.ImportReference(networkBehaviourType);

            //ServerRpcDelegate and ClientRpcDelegate constructors.
            ServerRpcDelegateConstructor_MethodRef = CodegenSession.ImportReference(typeof(ServerRpcDelegate).GetConstructors().First());
            ClientRpcDelegateConstructor_MethodRef = CodegenSession.ImportReference(typeof(ClientRpcDelegate).GetConstructors().First());
            //Prediction Rpc delegate constructors.
            ReplicateRpcDelegateConstructor_MethodRef = CodegenSession.ImportReference(typeof(ReplicateRpcDelegate).GetConstructors().First());
            ReconcileRpcDelegateConstructor_MethodRef = CodegenSession.ImportReference(typeof(ReconcileRpcDelegate).GetConstructors().First());

            foreach (MethodInfo mi in networkBehaviourType.GetMethods((BindingFlags.Static | BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic)))
            {
                //CreateDelegates.
                if (mi.Name == nameof(NetworkBehaviour.RegisterServerRpc))
                    RegisterServerRpc_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.RegisterObserversRpc))
                    RegisterObserversRpc_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.RegisterTargetRpc))
                    RegisterTargetRpc_MethodRef = CodegenSession.ImportReference(mi);
                //SendPredictions.
                else if (mi.Name == nameof(NetworkBehaviour.SendReplicateRpc))
                    SendReplicateRpc_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.SendReconcileRpc))
                    SendReconcileRpc_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.RegisterReplicateRpc))
                    RegisterReplicateRpc_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.RegisterReconcileRpc))
                    RegisterReconcileRpc_MethodRef = CodegenSession.ImportReference(mi);
                //SendRpcs.
                else if (mi.Name == nameof(NetworkBehaviour.SendServerRpc))
                    SendServerRpc_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.SendObserversRpc))
                    SendObserversRpc_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.SendTargetRpc))
                    SendTargetRpc_MethodRef = CodegenSession.ImportReference(mi);
                //Prediction.
                else if (mi.Name == nameof(NetworkBehaviour.SetLastReconcileTick))
                    SetLastReconcileTick_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.SetLastReplicateTickInternal))
                    SetLastReplicateTick_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.ClearReplicateCache))
                {
                    int pLength = mi.GetParameters().Length;
                    if (pLength == 1)
                        ClearReplicateCache_1P_MethodRef = CodegenSession.ImportReference(mi);
                    else if (pLength == 0)
                        ClearReplicateCache_0P_MethodRef = CodegenSession.ImportReference(mi);
                }                //Misc.
                else if (mi.Name == nameof(NetworkBehaviour.TransformMayChange))
                    TransformMayChange_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.CompareOwner))
                    CompareOwner_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.ReadSyncVar))
                    ReadSyncVar_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.DirtySyncType))
                    DirtySyncType_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(NetworkBehaviour.NetworkInitializeIfDisabledInternal))
                    NetworkInitializeInternal_MethodRef = CodegenSession.ImportReference(mi);
            }

            foreach (PropertyInfo pi in networkBehaviourType.GetProperties((BindingFlags.Static | BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic)))
            {
                //Server/Client states.
                if (pi.Name == nameof(NetworkBehaviour.IsClient))
                    IsClient_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(NetworkBehaviour.IsServer))
                    IsServer_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(NetworkBehaviour.IsHost))
                    IsHost_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(NetworkBehaviour.IsOwner))
                    IsOwner_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                //Owner.
                else if (pi.Name == nameof(NetworkBehaviour.Owner))
                    Owner_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(NetworkBehaviour.LocalConnection))
                    LocalConnection_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                //Misc.
                else if (pi.Name == nameof(NetworkBehaviour.TimeManager))
                    TimeManager_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
            }

            return true;
        }

        /// <summary>
        /// Returnsthe child most Awake by iterating up childMostTypeDef.
        /// </summary>
        /// <param name="childMostTypeDef"></param>
        /// <param name="created"></param>
        /// <returns></returns>
        internal MethodDefinition GetAwakeMethodDefinition(TypeDefinition typeDef)
        {
            return typeDef.GetMethod(AWAKE_METHOD_NAME);
        }

        /// <summary>
        /// Creates a replicate delegate.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="originalMethodDef"></param>
        /// <param name="readerMethodDef"></param>
        /// <param name="rpcType"></param>
        internal void CreateReplicateDelegate(MethodDefinition originalMethodDef, MethodDefinition readerMethodDef, uint methodHash)
        {
            MethodDefinition methodDef = originalMethodDef.DeclaringType.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            ILProcessor processor = methodDef.Body.GetILProcessor();

            List<Instruction> insts = new List<Instruction>();
            insts.Add(processor.Create(OpCodes.Ldarg_0));

            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)methodHash));

            /* Create delegate and call NetworkBehaviour method. */
            insts.Add(processor.Create(OpCodes.Ldnull));
            insts.Add(processor.Create(OpCodes.Ldftn, readerMethodDef));

            /* Has to be done last. This allows the NetworkBehaviour to
             * initialize it's fields first. */
            processor.InsertLast(insts);
        }

        /// <summary>
        /// Creates a RPC delegate for rpcType.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="originalMethodDef"></param>
        /// <param name="readerMethodDef"></param>
        /// <param name="rpcType"></param>
        internal void CreateRpcDelegate(bool runLocally, TypeDefinition typeDef, MethodDefinition readerMethodDef, RpcType rpcType, uint methodHash, CustomAttribute rpcAttribute)
        {
            

            MethodDefinition methodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            ILProcessor processor = methodDef.Body.GetILProcessor();

            List<Instruction> insts = new List<Instruction>();
            insts.Add(processor.Create(OpCodes.Ldarg_0));

            //uint methodHash = originalMethodDef.FullName.GetStableHash32();
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)methodHash));

            /* Create delegate and call NetworkBehaviour method. */
            insts.Add(processor.Create(OpCodes.Ldnull));
            insts.Add(processor.Create(OpCodes.Ldftn, readerMethodDef));
            //Server.
            if (rpcType == RpcType.Server)
            {
                insts.Add(processor.Create(OpCodes.Newobj, ServerRpcDelegateConstructor_MethodRef));
                insts.Add(processor.Create(OpCodes.Call, RegisterServerRpc_MethodRef));
            }
            //Observers.
            else if (rpcType == RpcType.Observers)
            {
                insts.Add(processor.Create(OpCodes.Newobj, ClientRpcDelegateConstructor_MethodRef));
                insts.Add(processor.Create(OpCodes.Call, RegisterObserversRpc_MethodRef));
            }
            //Target
            else if (rpcType == RpcType.Target)
            {
                insts.Add(processor.Create(OpCodes.Newobj, ClientRpcDelegateConstructor_MethodRef));
                insts.Add(processor.Create(OpCodes.Call, RegisterTargetRpc_MethodRef));
            }

            /* Has to be done last. This allows the NetworkBehaviour to
             * initialize it's fields first. */
            processor.InsertLast(insts);
        }

        /// <summary>
        /// Creates exit method condition if local client is not owner.
        /// </summary>
        /// <param name="retIfOwner">True if to ret when owner, false to ret when not owner.</param>
        /// <returns>Returns Ret instruction.</returns>
        internal Instruction CreateLocalClientIsOwnerCheck(MethodDefinition methodDef, LoggingType loggingType, bool canDisableLogging, bool retIfOwner, bool insertFirst)
        {
            List<Instruction> instructions = new List<Instruction>();
            /* This is placed after the if check.
             * Should the if check pass then code
             * jumps to this instruction. */
            ILProcessor processor = methodDef.Body.GetILProcessor();
            Instruction endIf = processor.Create(OpCodes.Nop);

            instructions.Add(processor.Create(OpCodes.Ldarg_0)); //argument: this
            //If !base.IsOwner endIf.
            instructions.Add(processor.Create(OpCodes.Call, IsOwner_MethodRef));
            if (retIfOwner)
                instructions.Add(processor.Create(OpCodes.Brfalse, endIf));
            else
                instructions.Add(processor.Create(OpCodes.Brtrue, endIf));
            //If logging is not disabled.
            if (loggingType != LoggingType.Off)
            {
                string disableLoggingText = (canDisableLogging) ? DISABLE_LOGGING_TEXT : string.Empty;
                string msg = (retIfOwner) ?
                    $"Cannot complete action because you are the owner of this object. {disableLoggingText}." :
                    $"Cannot complete action because you are not the owner of this object. {disableLoggingText}.";

                instructions.AddRange(
                    CodegenSession.GeneralHelper.CreateDebugWithCanLogInstructions(processor, msg, loggingType, false, true)
                    );
            }
            //Return block.
            Instruction retInst = processor.Create(OpCodes.Ret);
            instructions.Add(retInst);
            //After if statement, jumped to when successful check.
            instructions.Add(endIf);

            if (insertFirst)
            {
                processor.InsertFirst(instructions);
            }
            else
            {
                foreach (Instruction inst in instructions)
                    processor.Append(inst);
            }

            return retInst;
        }

        /// <summary>
        /// Creates exit method condition if remote client is not owner.
        /// </summary>
        /// <param name="processor"></param>
        internal Instruction CreateRemoteClientIsOwnerCheck(ILProcessor processor, ParameterDefinition connectionParameterDef)
        {
            /* This is placed after the if check.
             * Should the if check pass then code
             * jumps to this instruction. */
            Instruction endIf = processor.Create(OpCodes.Nop);

            processor.Emit(OpCodes.Ldarg_0); //argument: this
            //If !base.IsOwner endIf.
            processor.Emit(OpCodes.Ldarg, connectionParameterDef);
            processor.Emit(OpCodes.Call, CompareOwner_MethodRef);
            processor.Emit(OpCodes.Brtrue, endIf);
            //Return block.
            Instruction retInst = processor.Create(OpCodes.Ret);
            processor.Append(retInst);

            //After if statement, jumped to when successful check.
            processor.Append(endIf);

            return retInst;
        }

        /// <summary>
        /// Creates exit method condition if not client.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="retInstruction"></param>
        /// <param name="warn"></param>
        internal void CreateIsClientCheck(MethodDefinition methodDef, LoggingType loggingType, bool useStatic, bool insertFirst)
        {
            /* This is placed after the if check.
             * Should the if check pass then code
             * jumps to this instruction. */
            ILProcessor processor = methodDef.Body.GetILProcessor();
            Instruction endIf = processor.Create(OpCodes.Nop);

            List<Instruction> instructions = new List<Instruction>();
            //Checking against the NetworkObject.
            if (!useStatic)
            {
                instructions.Add(processor.Create(OpCodes.Ldarg_0)); //argument: this
                //If (!base.IsClient)
                instructions.Add(processor.Create(OpCodes.Call, IsClient_MethodRef));
            }
            //Checking instanceFinder.
            else
            {
                instructions.Add(processor.Create(OpCodes.Call, CodegenSession.ObjectHelper.InstanceFinder_IsClient_MethodRef));
            }
            instructions.Add(processor.Create(OpCodes.Brtrue, endIf));
            //If warning then also append warning text.
            if (loggingType != LoggingType.Off)
            {
                string msg = $"Cannot complete action because client is not active. This may also occur if the object is not yet initialized or if it does not contain a NetworkObject component. {DISABLE_LOGGING_TEXT}.";
                instructions.AddRange(
                    CodegenSession.GeneralHelper.CreateDebugWithCanLogInstructions(processor, msg, loggingType, useStatic, true)
                    );
            }
            //Add return.
            instructions.AddRange(CreateRetDefault(methodDef));
            //After if statement, jumped to when successful check.
            instructions.Add(endIf);

            if (insertFirst)
            {
                processor.InsertFirst(instructions);
            }
            else
            {
                foreach (Instruction inst in instructions)
                    processor.Append(inst);
            }
        }

        /// <summary>
        /// Creates exit method condition if not server.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="warn"></param>
        internal void CreateIsServerCheck(MethodDefinition methodDef, LoggingType loggingType, bool useStatic, bool insertFirst)
        {
            /* This is placed after the if check.
            * Should the if check pass then code
            * jumps to this instruction. */
            ILProcessor processor = methodDef.Body.GetILProcessor();
            Instruction endIf = processor.Create(OpCodes.Nop);

            List<Instruction> instructions = new List<Instruction>();
            if (!useStatic)
            {
                instructions.Add(processor.Create(OpCodes.Ldarg_0)); //argument: this
                //If (!base.IsServer)
                instructions.Add(processor.Create(OpCodes.Call, IsServer_MethodRef));
            }
            //Checking instanceFinder.
            else
            {
                instructions.Add(processor.Create(OpCodes.Call, CodegenSession.ObjectHelper.InstanceFinder_IsServer_MethodRef));
            }
            instructions.Add(processor.Create(OpCodes.Brtrue, endIf));
            //If warning then also append warning text.
            if (loggingType != LoggingType.Off)
            {
                string msg = $"Cannot complete action because server is not active. This may also occur if the object is not yet initialized or if it does not contain a NetworkObject component. {DISABLE_LOGGING_TEXT}";
                instructions.AddRange(
                    CodegenSession.GeneralHelper.CreateDebugWithCanLogInstructions(processor, msg, loggingType, useStatic, true)
                    );
            }
            //Add return.
            instructions.AddRange(CreateRetDefault(methodDef));
            //After if statement, jumped to when successful check.
            instructions.Add(endIf);

            if (insertFirst)
            {
                processor.InsertFirst(instructions);
            }
            else
            {
                foreach (Instruction inst in instructions)
                    processor.Append(inst);
            }
        }

        /// <summary>
        /// Creates a return using the ReturnType for methodDef.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="methodDef"></param>
        /// <returns></returns>
        public List<Instruction> CreateRetDefault(MethodDefinition methodDef, ModuleDefinition importReturnModule = null)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();
            List<Instruction> instructions = new List<Instruction>();
            //If requires a value return.
            if (methodDef.ReturnType != methodDef.Module.TypeSystem.Void)
            {
                //Import type first.
                methodDef.Module.ImportReference(methodDef.ReturnType);
                if (importReturnModule != null)
                    importReturnModule.ImportReference(methodDef.ReturnType);
                VariableDefinition vd = CodegenSession.GeneralHelper.CreateVariable(methodDef, methodDef.ReturnType);
                instructions.Add(processor.Create(OpCodes.Ldloca_S, vd));
                instructions.Add(processor.Create(OpCodes.Initobj, vd.VariableType));
                instructions.Add(processor.Create(OpCodes.Ldloc, vd));
            }
            instructions.Add(processor.Create(OpCodes.Ret));

            return instructions;
        }
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/NetworkConnectionHelper.cs ---
﻿using FishNet.Connection;
using MonoFN.Cecil;
using System;
using System.Reflection;

namespace FishNet.CodeGenerating.Helping
{
    internal class NetworkConnectionHelper
    {
        #region Reflection references.
        //Names.
        internal string FullName;
        #endregion

        #region Const.
        internal const uint MAX_RPC_ALLOWANCE = ushort.MaxValue;
        internal const string AWAKE_METHOD_NAME = "Awake";
        internal const string DISABLE_LOGGING_TEXT = "This message may be disabled by setting the Logging field in your attribute to LoggingType.Off";
        #endregion

        internal bool ImportReferences()
        {
            Type type = typeof(NetworkConnection);
            CodegenSession.ImportReference(type);

            FullName = type.FullName;

            return true;
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/ObjectHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Connection;
using FishNet.Object.Synchronizing;
using FishNet.Object.Synchronizing.Internal;
using MonoFN.Cecil;
using System;
using System.Collections.Generic;
using System.Reflection;

namespace FishNet.CodeGenerating.Helping
{
    internal class ObjectHelper
    {
        #region Reflection references.
        //Fullnames.
        internal string SyncList_Name;
        internal string SyncDictionary_Name;
        internal string SyncHashSet_Name;
        //Is checks.
        internal MethodReference InstanceFinder_IsServer_MethodRef;
        internal MethodReference InstanceFinder_IsClient_MethodRef;
        //Misc.
        internal MethodReference NetworkConnection_IsValid_MethodRef;
        internal MethodReference NetworkConnection_IsActive_MethodRef;
        internal MethodReference Dictionary_Add_UShort_SyncBase_MethodRef;
        internal MethodReference NetworkConnection_GetIsLocalClient_MethodRef;
        #endregion

        internal bool ImportReferences()
        {
            Type tmpType;
            /* SyncObject names. */
            //SyncList.
            tmpType = typeof(SyncList<>);
            CodegenSession.ImportReference(tmpType);
            SyncList_Name = tmpType.Name;
            //SyncDictionary.
            tmpType = typeof(SyncDictionary<,>);
            CodegenSession.ImportReference(tmpType);
            SyncDictionary_Name = tmpType.Name;
            //SyncHashSet.
            tmpType = typeof(SyncHashSet<>);
            CodegenSession.ImportReference(tmpType);
            SyncHashSet_Name = tmpType.Name;

            tmpType = typeof(NetworkConnection);
            TypeReference networkConnectionTr = CodegenSession.ImportReference(tmpType);
            foreach (PropertyDefinition item in networkConnectionTr.CachedResolve().Properties)
            {
                if (item.Name == nameof(NetworkConnection.IsLocalClient))
                    NetworkConnection_GetIsLocalClient_MethodRef = CodegenSession.ImportReference(item.GetMethod);
            }

            //Dictionary.Add(ushort, SyncBase).
            Type dictType = typeof(Dictionary<ushort, SyncBase>);
            TypeReference dictTypeRef = CodegenSession.ImportReference(dictType);
            //Dictionary_Add_UShort_SyncBase_MethodRef = dictTypeRef.CachedResolve().GetMethod("add_Item", )
            foreach (MethodDefinition item in dictTypeRef.CachedResolve().Methods)
            {
                if (item.Name == nameof(Dictionary<ushort, SyncBase>.Add))
                {
                    Dictionary_Add_UShort_SyncBase_MethodRef = CodegenSession.ImportReference(item);
                    break;
                }
            }

            //InstanceFinder infos.
            Type instanceFinderType = typeof(InstanceFinder);
            foreach (PropertyInfo pi in instanceFinderType.GetProperties())
            {
                if (pi.Name == nameof(InstanceFinder.IsClient))
                    InstanceFinder_IsClient_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(InstanceFinder.IsServer))
                    InstanceFinder_IsServer_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
            }

            //NetworkConnection.
            foreach (PropertyInfo pi in typeof(NetworkConnection).GetProperties((BindingFlags.Static | BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic)))
            {
                if (pi.Name == nameof(NetworkConnection.IsValid))
                    NetworkConnection_IsValid_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(NetworkConnection.IsActive))
                    NetworkConnection_IsActive_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
            }

            return true;
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/PredictedObjectHelper.cs ---
﻿using FishNet.Component.Prediction;
using MonoFN.Cecil;
using System;
using System.Reflection;

namespace FishNet.CodeGenerating.Helping
{
    internal class PredictedObjectHelper
    {
        #region Reflection references.
        //Names.
        internal string FullName;
        //Prediction.
        internal MethodReference SendRigidbodyStatesInternal_MethodRef;
        internal MethodReference InstantiatedRigidbodyCountInternal_Get_MethodRef;
        #endregion

        #region Const.
        internal const uint MAX_RPC_ALLOWANCE = ushort.MaxValue;
        internal const string AWAKE_METHOD_NAME = "Awake";
        internal const string DISABLE_LOGGING_TEXT = "This message may be disabled by setting the Logging field in your attribute to LoggingType.Off";
        #endregion

        internal bool ImportReferences()
        {
            Type predictedObjectType = typeof(PredictedObject);
            FullName = predictedObjectType.FullName;

            //If the same module then do not proceed. These are not used within the same module.
            if (predictedObjectType.Module.Assembly.FullName == CodegenSession.Module.Assembly.FullName)
                return true;

            foreach (MethodInfo mi in predictedObjectType.GetMethods((BindingFlags.Static | BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic)))
            {
                if (mi.Name == nameof(PredictedObject.SendRigidbodyStatesInternal))
                { 
                    SendRigidbodyStatesInternal_MethodRef = CodegenSession.ImportReference(mi);
                    break;
                }
            }

            foreach (PropertyInfo pi in predictedObjectType.GetProperties())
            {
                if (pi.Name == nameof(PredictedObject.InstantiatedRigidbodyCountInternal))
                {
                    InstantiatedRigidbodyCountInternal_Get_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                    break;
                }
            }

            return true;
        }
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/ReaderGenerator.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Object;
using FishNet.Serializing;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping
{
    internal class ReaderGenerator
    {

        #region Const.
        internal const string GENERATED_READERS_CLASS_NAME = "GeneratedReaders___FN";
        public const TypeAttributes GENERATED_TYPE_ATTRIBUTES = WriterGenerator.GENERATED_TYPE_ATTRIBUTES;
        private const string READ_PREFIX = "Read___";
        #endregion

        /// <summary>
        /// Imports references needed by this helper.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal bool ImportReferences()
        {
            return true;
        }

        /// <summary>
        /// Generates a reader for objectTypeReference if one does not already exist. 
        /// </summary>
        /// <param name="objectTr"></param>
        /// <returns></returns>
        internal MethodReference CreateReader(TypeReference objectTr)
        {
            MethodReference resultMr = null;
            TypeDefinition objectTypeDef;

            SerializerType serializerType = GeneratorHelper.GetSerializerType(objectTr, false, out objectTypeDef);
            if (serializerType != SerializerType.Invalid)
            {
                //Array.
                if (serializerType == SerializerType.Array)
                    resultMr = CreateArrayReaderMethodReference(objectTr);
                //Enum.
                else if (serializerType == SerializerType.Enum)
                    resultMr = CreateEnumReaderMethodDefinition(objectTr);
                else if (serializerType == SerializerType.Dictionary)
                    resultMr = CreateDictionaryReaderMethodReference(objectTr);
                //List.                
                else if (serializerType == SerializerType.List)
                    resultMr = CreateListReaderMethodReference(objectTr);
                //NetworkBehaviour.
                else if (serializerType == SerializerType.NetworkBehaviour)
                    resultMr = GetNetworkBehaviourReaderMethodReference(objectTr);
                //Nullable.
                else if (serializerType == SerializerType.Nullable)
                    resultMr = CreateNullableReaderMethodReference(objectTr);
                //Class or struct.
                else if (serializerType == SerializerType.ClassOrStruct)
                    resultMr = CreateClassOrStructReaderMethodReference(objectTr);
            }

            //If was not created.
            if (resultMr == null)
                RemoveFromStaticReaders(objectTr);

            return resultMr;
        }

        /// <summary>
        /// Removes from static writers.
        /// </summary>
        private void RemoveFromStaticReaders(TypeReference tr)
        {
            CodegenSession.ReaderHelper.RemoveReaderMethod(tr, false);
        }
        /// <summary>
        /// Adds to static writers.
        /// </summary>
        private void AddToStaticReaders(TypeReference tr, MethodReference mr)
        {
            CodegenSession.ReaderHelper.AddReaderMethod(tr, mr.CachedResolve(), false, true);
        }

        /// <summary>
        /// Generates a reader for objectTypeReference if one does not already exist.
        /// </summary>
        /// <param name="objectTr"></param>
        /// <returns></returns>
        private MethodReference CreateEnumReaderMethodDefinition(TypeReference objectTr)
        {
            MethodDefinition createdReaderMd = CreateStaticReaderStubMethodDefinition(objectTr);
            AddToStaticReaders(objectTr, createdReaderMd);

            ILProcessor processor = createdReaderMd.Body.GetILProcessor();

            //Get type reference for enum type. eg byte int
            TypeReference underlyingTypeRef = objectTr.CachedResolve().GetEnumUnderlyingTypeReference();
            //Get read method for underlying type.
            MethodReference readMethodRef = CodegenSession.ReaderHelper.GetOrCreateFavoredReadMethodReference(underlyingTypeRef, true);
            if (readMethodRef == null)
                return null;

            ParameterDefinition readerParameterDef = createdReaderMd.Parameters[0];
            //reader.ReadXXX().
            processor.Emit(OpCodes.Ldarg, readerParameterDef);
            if (CodegenSession.WriterHelper.IsAutoPackedType(underlyingTypeRef))
                processor.Emit(OpCodes.Ldc_I4, (int)AutoPackType.Packed);

            processor.Emit(OpCodes.Call, readMethodRef);

            processor.Emit(OpCodes.Ret);
            return CodegenSession.ImportReference(createdReaderMd);
        }

        /// <summary>
        /// Creates a read for a class type which inherits NetworkBehaviour.
        /// </summary>
        /// <param name="objectTr"></param>
        /// <returns></returns>
        private MethodReference GetNetworkBehaviourReaderMethodReference(TypeReference objectTr)
        {
            MethodDefinition createdReaderMd = CreateStaticReaderStubMethodDefinition(objectTr);
            AddToStaticReaders(objectTr, createdReaderMd);

            ILProcessor processor = createdReaderMd.Body.GetILProcessor();
            TypeReference networkBehaviourTypeRef = CodegenSession.GeneralHelper.GetTypeReference(typeof(NetworkBehaviour));

            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.ReaderHelper.GetFavoredReadMethodReference(networkBehaviourTypeRef, true));
            processor.Emit(OpCodes.Castclass, objectTr);
            processor.Emit(OpCodes.Ret);
            return CodegenSession.ImportReference(createdReaderMd);
        }

        /// <summary>
        /// Create a reader for an array or list.
        /// </summary>
        private MethodReference CreateArrayReaderMethodReference(TypeReference objectTr)
        {
            MethodDefinition createdReaderMd = CreateStaticReaderStubMethodDefinition(objectTr);
            AddToStaticReaders(objectTr, createdReaderMd);

            /* Try to get instanced first for collection element type, if it doesn't exist then try to
             * get/or make a one. */
            TypeReference elementTypeRef = objectTr.GetElementType();
            MethodReference readMethodRef = CodegenSession.ReaderHelper.GetOrCreateFavoredReadMethodReference(elementTypeRef, true);
            if (readMethodRef == null)
                return null;

            ILProcessor processor = createdReaderMd.Body.GetILProcessor();

            ParameterDefinition readerParameterDef = createdReaderMd.Parameters[0];
            VariableDefinition sizeVariableDef = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, typeof(int));
            //Load packed whole value into sizeVariableDef, exit if null indicator.
            CodegenSession.ReaderHelper.CreateRetOnNull(processor, readerParameterDef, sizeVariableDef, false);

            //Make local variable of array type.
            VariableDefinition collectionVariableDef = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, objectTr);
            //Create new array/list of size.
            processor.Emit(OpCodes.Ldloc, sizeVariableDef);
            processor.Emit(OpCodes.Newarr, elementTypeRef);
            //Store new object of arr/list into collection variable.
            processor.Emit(OpCodes.Stloc, collectionVariableDef);

            VariableDefinition loopIndex = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, typeof(int));
            Instruction loopComparer = processor.Create(OpCodes.Ldloc, loopIndex);

            //int i = 0
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, loopIndex);
            processor.Emit(OpCodes.Br_S, loopComparer);

            //Loop content.
            //Collection[index]
            Instruction contentStart = processor.Create(OpCodes.Ldloc, collectionVariableDef);
            processor.Append(contentStart);
            /* Only arrays load the index since we are setting to that index.
             * List call lst.Add */
            processor.Emit(OpCodes.Ldloc, loopIndex);
            //Collection[index] = reader.
            processor.Emit(OpCodes.Ldarg, readerParameterDef);
            //Pass in AutoPackType default.
            if (CodegenSession.ReaderHelper.IsAutoPackedType(elementTypeRef))
            {
                AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(elementTypeRef);
                processor.Emit(OpCodes.Ldc_I4, (int)packType);
            }
            //Collection[index] = reader.ReadType().
            processor.Emit(OpCodes.Call, readMethodRef);
            //Set value to collection.
            processor.Emit(OpCodes.Stelem_Any, elementTypeRef);

            //i++
            processor.Emit(OpCodes.Ldloc, loopIndex);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc, loopIndex);
            //if i < length jmp to content start.
            processor.Append(loopComparer); //if i < size
            processor.Emit(OpCodes.Ldloc, sizeVariableDef);
            processor.Emit(OpCodes.Blt_S, contentStart);

            processor.Emit(OpCodes.Ldloc, collectionVariableDef);
            processor.Emit(OpCodes.Ret);

            return CodegenSession.ImportReference(createdReaderMd);
        }

        /// <summary>
        /// Creates a reader for a dictionary.
        /// </summary>
        private MethodReference CreateDictionaryReaderMethodReference(TypeReference objectTr)
        {
            GenericInstanceType genericInstance = (GenericInstanceType)objectTr;
            CodegenSession.ImportReference(genericInstance);
            TypeReference keyTr = genericInstance.GenericArguments[0];
            TypeReference valueTr = genericInstance.GenericArguments[1];

            /* Try to get instanced first for collection element type, if it doesn't exist then try to
             * get/or make a one. */
            MethodReference keyWriteMr = CodegenSession.ReaderHelper.GetOrCreateFavoredReadMethodReference(keyTr, true);
            MethodReference valueWriteMr = CodegenSession.ReaderHelper.GetOrCreateFavoredReadMethodReference(valueTr, true);
            if (keyWriteMr == null || valueWriteMr == null)
                return null;

            MethodDefinition createdReaderMd = CreateStaticReaderStubMethodDefinition(objectTr);
            AddToStaticReaders(objectTr, createdReaderMd);

            ILProcessor processor = createdReaderMd.Body.GetILProcessor();
            GenericInstanceMethod genericInstanceMethod = CodegenSession.ReaderHelper.Reader_ReadDictionary_MethodRef.MakeGenericMethod(new TypeReference[] { keyTr, valueTr });

            ParameterDefinition readerPd = createdReaderMd.Parameters[0];
            processor.Emit(OpCodes.Ldarg, readerPd);
            processor.Emit(OpCodes.Callvirt, genericInstanceMethod);
            processor.Emit(OpCodes.Ret);

            return CodegenSession.ImportReference(createdReaderMd);
        }

        /// <summary>
        /// Create a reader for a list.
        /// </summary>
        private MethodReference CreateListReaderMethodReference(TypeReference objectTr)
        {
            GenericInstanceType genericInstance = (GenericInstanceType)objectTr;
            CodegenSession.ImportReference(genericInstance);
            TypeReference elementTypeRef = genericInstance.GenericArguments[0];

            /* Try to get instanced first for collection element type, if it doesn't exist then try to
             * get/or make a one. */
            MethodReference readMethodRef = CodegenSession.ReaderHelper.GetOrCreateFavoredReadMethodReference(elementTypeRef, true);
            if (readMethodRef == null)
                return null;

            MethodDefinition createdReaderMd = CreateStaticReaderStubMethodDefinition(objectTr);
            AddToStaticReaders(objectTr, createdReaderMd);

            ILProcessor processor = createdReaderMd.Body.GetILProcessor();

            //Find constructor for new list.
            MethodDefinition constructorMd = objectTr.CachedResolve().GetConstructor(new Type[] { typeof(int) });
            MethodReference constructorMr = constructorMd.MakeHostInstanceGeneric(genericInstance);
            //Find add method for list.
            MethodReference lstAddMd = objectTr.CachedResolve().GetMethod("Add");
            MethodReference lstAddMr = lstAddMd.MakeHostInstanceGeneric(genericInstance);

            ParameterDefinition readerParameterDef = createdReaderMd.Parameters[0];
            VariableDefinition sizeVariableDef = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, typeof(int));
            //Load packed whole value into sizeVariableDef, exit if null indicator.
            CodegenSession.ReaderHelper.CreateRetOnNull(processor, readerParameterDef, sizeVariableDef, false);

            //Make variable of new list type, and create list object.
            VariableDefinition collectionVariableDef = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, genericInstance);
            processor.Emit(OpCodes.Ldloc, sizeVariableDef);
            processor.Emit(OpCodes.Newobj, constructorMr);
            processor.Emit(OpCodes.Stloc, collectionVariableDef);

            VariableDefinition loopIndex = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, typeof(int));
            Instruction loopComparer = processor.Create(OpCodes.Ldloc, loopIndex);

            //int i = 0
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, loopIndex);
            processor.Emit(OpCodes.Br_S, loopComparer);

            //Loop content.
            //Collection[index]
            Instruction contentStart = processor.Create(OpCodes.Ldloc, collectionVariableDef);
            processor.Append(contentStart);
            //Collection[index] = reader.
            processor.Emit(OpCodes.Ldarg, readerParameterDef);
            //Pass in AutoPackType default.
            if (CodegenSession.ReaderHelper.IsAutoPackedType(elementTypeRef))
            {
                AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(elementTypeRef);
                processor.Emit(OpCodes.Ldc_I4, (int)packType);
            }
            //Collection[index] = reader.ReadType().
            processor.Emit(OpCodes.Call, readMethodRef);
            //Set value to collection.
            processor.Emit(OpCodes.Callvirt, lstAddMr);

            //i++
            processor.Emit(OpCodes.Ldloc, loopIndex);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc, loopIndex);
            //if i < length jmp to content start.
            processor.Append(loopComparer); //if i < size
            processor.Emit(OpCodes.Ldloc, sizeVariableDef);
            processor.Emit(OpCodes.Blt_S, contentStart);

            processor.Emit(OpCodes.Ldloc, collectionVariableDef);
            processor.Emit(OpCodes.Ret);

            return CodegenSession.ImportReference(createdReaderMd);
        }

        /// <summary>
        /// Creates a reader method for a struct or class objectTypeRef.
        /// </summary>
        /// <param name="objectTr"></param>
        /// <returns></returns>
        private MethodReference CreateNullableReaderMethodReference(TypeReference objectTr)
        {
            GenericInstanceType objectGit = objectTr as GenericInstanceType;
            TypeReference valueTr = objectGit.GenericArguments[0];

            //Make sure object has a ctor.
            MethodDefinition objectCtorMd = objectTr.GetConstructor(1);
            if (objectCtorMd == null)
            {
                CodegenSession.LogError($"{objectTr.Name} can't be deserialized because the nullable type does not have a constructor.");
                return null;
            }

            //Get the reader for the value.
            MethodReference valueReaderMr = CodegenSession.ReaderHelper.GetOrCreateFavoredReadMethodReference(valueTr, true);
            if (valueReaderMr == null)
                return null;

            TypeDefinition objectTd = objectTr.CachedResolve();
            MethodDefinition createdReaderMd = CreateStaticReaderStubMethodDefinition(objectTr);
            AddToStaticReaders(objectTr, createdReaderMd);

            ILProcessor processor = createdReaderMd.Body.GetILProcessor();

            ParameterDefinition readerPd = createdReaderMd.Parameters[0];
            // create local for return value
            VariableDefinition resultVd = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, objectTr);

            //Read if null into boolean.
            VariableDefinition nullBoolVd = createdReaderMd.CreateVariable(typeof(bool));
            CodegenSession.ReaderHelper.CreateReadBool(processor, readerPd, nullBoolVd);

            Instruction afterReturnNullInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldloc, nullBoolVd);
            processor.Emit(OpCodes.Brfalse, afterReturnNullInst);
            //Return a null result.
            CodegenSession.GeneralHelper.SetVariableDefinitionFromObject(processor, resultVd, objectTd);
            processor.Emit(OpCodes.Ldloc, resultVd);
            processor.Emit(OpCodes.Ret);
            processor.Append(afterReturnNullInst);

            MethodReference initMr = objectCtorMd.MakeHostInstanceGeneric(objectGit);
            processor.Emit(OpCodes.Ldarg, readerPd);
            //If an auto pack method then insert default value.
            if (CodegenSession.ReaderHelper.IsAutoPackedType(valueTr))
            {
                AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(valueTr);
                processor.Emit(OpCodes.Ldc_I4, (int)packType);
            }
            processor.Emit(OpCodes.Call, valueReaderMr);
            processor.Emit(OpCodes.Newobj, initMr);
            processor.Emit(OpCodes.Ret);

            return CodegenSession.ImportReference(createdReaderMd);
        }

        /// <summary>
        /// Creates a reader method for a struct or class objectTypeRef.
        /// </summary>
        /// <param name="objectTr"></param>
        /// <returns></returns>
        private MethodReference CreateClassOrStructReaderMethodReference(TypeReference objectTr)
        {
            MethodDefinition createdReaderMd = CreateStaticReaderStubMethodDefinition(objectTr);
            AddToStaticReaders(objectTr, createdReaderMd);

            TypeDefinition objectTypeDef = objectTr.CachedResolve();
            ILProcessor processor = createdReaderMd.Body.GetILProcessor();

            ParameterDefinition readerParameterDef = createdReaderMd.Parameters[0];
            // create local for return value
            VariableDefinition objectVariableDef = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, objectTr);

            //If not a value type create a return null check.
            if (!objectTypeDef.IsValueType)
            {
                VariableDefinition nullVariableDef = CodegenSession.GeneralHelper.CreateVariable(createdReaderMd, typeof(bool));
                //Load packed whole value into sizeVariableDef, exit if null indicator.
                CodegenSession.ReaderHelper.CreateRetOnNull(processor, readerParameterDef, nullVariableDef, true);
            }

            /* If here then not null. */
            //Make a new instance of object type and set to objectVariableDef.
            CodegenSession.GeneralHelper.SetVariableDefinitionFromObject(processor, objectVariableDef, objectTypeDef);
            if (!ReadFieldsAndProperties(createdReaderMd, readerParameterDef, objectVariableDef, objectTr))
                return null;
            /* //codegen scriptableobjects seem to climb too high up to UnityEngine.Object when
             * creating serializers/deserialized. Make sure this is not possible. */

            //Load result and return it.
            processor.Emit(OpCodes.Ldloc, objectVariableDef);
            processor.Emit(OpCodes.Ret);

            return CodegenSession.ImportReference(createdReaderMd);
        }

        /// <summary>
        /// Reads all fields of objectTypeRef.
        /// </summary>  
        private bool ReadFieldsAndProperties(MethodDefinition readerMd, ParameterDefinition readerPd, VariableDefinition objectVd, TypeReference objectTr)
        {
            //This probably isn't needed but I'm too afraid to remove it.
            if (objectTr.Module != CodegenSession.Module)
                objectTr = CodegenSession.ImportReference(objectTr.CachedResolve());

            //Fields.
            foreach (FieldDefinition fieldDef in objectTr.FindAllPublicFields(true, true,
                ReaderHelper.EXCLUDED_AUTO_SERIALIZER_TYPES, ReaderHelper.EXCLUDED_ASSEMBLY_PREFIXES))
            {
                FieldReference importedFr = CodegenSession.ImportReference(fieldDef);
                if (GetReadMethod(fieldDef.FieldType, out MethodReference readMr))
                    CodegenSession.ReaderHelper.CreateReadIntoClassOrStruct(readerMd, readerPd, readMr, objectVd, importedFr);
            }

            //Properties.
            foreach (PropertyDefinition propertyDef in objectTr.FindAllPublicProperties(
                true, ReaderHelper.EXCLUDED_AUTO_SERIALIZER_TYPES, ReaderHelper.EXCLUDED_ASSEMBLY_PREFIXES))
            {
                if (GetReadMethod(propertyDef.PropertyType, out MethodReference readMr))
                {
                    MethodReference setMr = CodegenSession.Module.ImportReference(propertyDef.SetMethod);
                    CodegenSession.ReaderHelper.CreateReadIntoClassOrStruct(readerMd, readerPd, readMr, objectVd, setMr, propertyDef.PropertyType);
                }
            }

            //Gets or creates writer method and outputs it. Returns true if method is found or created.
            bool GetReadMethod(TypeReference tr, out MethodReference readMr)
            {
                tr = CodegenSession.ImportReference(tr);
                readMr = CodegenSession.ReaderHelper.GetOrCreateFavoredReadMethodReference(tr, true);
                return (readMr != null);
            }

            return true;
        }

        /// <summary>
        /// Creates the stub for a new reader method.
        /// </summary>
        /// <param name="objectTypeRef"></param>
        /// <returns></returns>
        private MethodDefinition CreateStaticReaderStubMethodDefinition(TypeReference objectTypeRef, string nameExtension = "")
        {
            string methodName = $"{READ_PREFIX}{objectTypeRef.FullName}{nameExtension}s";
            // create new reader for this type
            TypeDefinition readerTypeDef = CodegenSession.GeneralHelper.GetOrCreateClass(out _, GENERATED_TYPE_ATTRIBUTES, GENERATED_READERS_CLASS_NAME, null);
            MethodDefinition readerMethodDef = readerTypeDef.AddMethod(methodName,
                    MethodAttributes.Public |
                    MethodAttributes.Static |
                    MethodAttributes.HideBySig,
                    objectTypeRef);

            CodegenSession.GeneralHelper.CreateParameter(readerMethodDef, CodegenSession.ReaderHelper.Reader_TypeRef, "reader");
            readerMethodDef.Body.InitLocals = true;

            return readerMethodDef;
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/ReaderHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.CodeGenerating.ILCore;
using FishNet.Connection;
using FishNet.Serializing;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping
{
    internal class ReaderHelper
    {
        #region Reflection references.
        internal TypeReference PooledReader_TypeRef;
        internal TypeReference Reader_TypeRef;
        internal TypeReference NetworkConnection_TypeRef;
        internal MethodReference PooledReader_ReadNetworkBehaviour_MethodRef;
        private readonly Dictionary<TypeReference, MethodReference> _instancedReaderMethods = new Dictionary<TypeReference, MethodReference>(new TypeReferenceComparer());
        private readonly Dictionary<TypeReference, MethodReference> _staticReaderMethods = new Dictionary<TypeReference, MethodReference>(new TypeReferenceComparer());
        private HashSet<TypeReference> _autoPackedMethods = new HashSet<TypeReference>(new TypeReferenceComparer());
        private MethodReference Reader_ReadPackedWhole_MethodRef;
        internal MethodReference Reader_ReadDictionary_MethodRef;
        internal MethodReference Reader_ReadToCollection_MethodRef;
        #endregion

        #region Const.
        internal const string READ_PREFIX = "Read";
        /// <summary>
        /// Types to exclude from being scanned for auto serialization.
        /// </summary>
        public static System.Type[] EXCLUDED_AUTO_SERIALIZER_TYPES => WriterHelper.EXCLUDED_AUTO_SERIALIZER_TYPES;
        /// <summary>
        /// Types to exclude from being scanned for auto serialization.
        /// </summary>
        public static string[] EXCLUDED_ASSEMBLY_PREFIXES => WriterHelper.EXCLUDED_ASSEMBLY_PREFIXES;
        #endregion

        /// <summary>
        /// Imports references needed by this helper.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal bool ImportReferences()
        {
            PooledReader_TypeRef = CodegenSession.ImportReference(typeof(PooledReader));
            Reader_TypeRef = CodegenSession.ImportReference(typeof(Reader));
            NetworkConnection_TypeRef = CodegenSession.ImportReference(typeof(NetworkConnection));

            Type pooledReaderType = typeof(PooledReader);

            foreach (MethodInfo methodInfo in pooledReaderType.GetMethods())
            {
                /* Special methods. */
                //ReadPackedWhole.
                if (methodInfo.Name == nameof(PooledReader.ReadPackedWhole))
                {
                    Reader_ReadPackedWhole_MethodRef = CodegenSession.ImportReference(methodInfo);
                    continue;
                }
                //ReadToCollection.
                else if (methodInfo.Name == nameof(PooledReader.ReadArray))
                {
                    Reader_ReadToCollection_MethodRef = CodegenSession.ImportReference(methodInfo);
                    continue;
                }
                //ReadDictionary.
                else if (methodInfo.Name == nameof(PooledReader.ReadDictionary))
                {
                    Reader_ReadDictionary_MethodRef = CodegenSession.ImportReference(methodInfo);
                    continue;
                }

                else if (CodegenSession.GeneralHelper.CodegenExclude(methodInfo))
                    continue;
                //Generic methods are not supported.
                else if (methodInfo.IsGenericMethod)
                    continue;
                //Not long enough to be a write method.
                else if (methodInfo.Name.Length < READ_PREFIX.Length)
                    continue;
                //Method name doesn't start with writePrefix.
                else if (methodInfo.Name.Substring(0, READ_PREFIX.Length) != READ_PREFIX)
                    continue;
                ParameterInfo[] parameterInfos = methodInfo.GetParameters();
                //Can have at most one parameter for packing.
                if (parameterInfos.Length > 1)
                    continue;
                //If has one parameter make sure it's a packing type.
                bool autoPackMethod = false;
                if (parameterInfos.Length == 1)
                {
                    autoPackMethod = (parameterInfos[0].ParameterType == typeof(AutoPackType));
                    if (!autoPackMethod)
                        continue;
                }

                /* TypeReference for the return type
                 * of the read method. */
                TypeReference typeRef = CodegenSession.ImportReference(methodInfo.ReturnType);
                MethodReference methodRef = CodegenSession.ImportReference(methodInfo);

                /* If here all checks pass. */
                AddReaderMethod(typeRef, methodRef, true, true);
                if (autoPackMethod)
                    _autoPackedMethods.Add(typeRef);
            }

            Type readerExtensionsType = typeof(ReaderExtensions);

            foreach (MethodInfo methodInfo in readerExtensionsType.GetMethods())
            {
                if (CodegenSession.GeneralHelper.CodegenExclude(methodInfo))
                    continue;
                //Generic methods are not supported.
                if (methodInfo.IsGenericMethod)
                    continue;
                //Not static.
                if (!methodInfo.IsStatic)
                    continue;
                //Not long enough to be a write method.
                if (methodInfo.Name.Length < READ_PREFIX.Length)
                    continue;
                //Method name doesn't start with writePrefix.
                if (methodInfo.Name.Substring(0, READ_PREFIX.Length) != READ_PREFIX)
                    continue;
                ParameterInfo[] parameterInfos = methodInfo.GetParameters();
                //Can have at most one parameter for packing.
                if (parameterInfos.Length > 2)
                    continue;
                //If has 2 parameters make sure it's a packing type.
                bool autoPackMethod = false;
                if (parameterInfos.Length == 2)
                {
                    autoPackMethod = (parameterInfos[1].ParameterType == typeof(AutoPackType));
                    if (!autoPackMethod)
                        continue;
                }

                /* TypeReference for the return type
                 * of the read method. */
                TypeReference typeRef = CodegenSession.ImportReference(methodInfo.ReturnType);
                MethodReference methodRef = CodegenSession.ImportReference(methodInfo);

                /* If here all checks pass. */
                AddReaderMethod(typeRef, methodRef, false, true);
            }

            return true;
        }

        /// <summary>
        /// Creates generic write delegates for all currently known write types.
        /// </summary>
        internal bool CreateGenericDelegates()
        {
            bool modified = false;
            /* Only write statics. This will include extensions and generated. */
            foreach (KeyValuePair<TypeReference, MethodReference> item in _staticReaderMethods)
            {
                if (FishNetILPP.CODEGEN_THIS_NAMESPACE.Length == 0 || item.Key.FullName.Contains(FishNetILPP.CODEGEN_THIS_NAMESPACE))
                {
                    CodegenSession.GenericReaderHelper.CreateReadDelegate(item.Value);
                    modified = true;
                }
            }

            return modified;
        }

        /// <summary>
        /// Returns if typeRef has a deserializer.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <param name="createMissing"></param>
        /// <returns></returns>
        internal bool HasDeserializer(TypeReference typeRef, bool createMissing)
        {
            bool result = (GetInstancedReadMethodReference(typeRef) != null) ||
                (GetStaticReadMethodReference(typeRef) != null);

            if (!result && createMissing)
            {
                if (!CodegenSession.GeneralHelper.HasNonSerializableAttribute(typeRef.CachedResolve()))
                {
                    MethodReference methodRef = CodegenSession.ReaderGenerator.CreateReader(typeRef);
                    result = (methodRef != null);
                }
            }

            return result;
        }

        /// <summary>
        /// Returns if typeRef supports auto packing.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal bool IsAutoPackedType(TypeReference typeRef)
        {
            return _autoPackedMethods.Contains(typeRef);
        }
        /// <summary>
        /// Creates a null check on the first argument and returns a null object if result indicates to do so.
        /// </summary>
        internal void CreateRetOnNull(ILProcessor processor, ParameterDefinition readerParameterDef, VariableDefinition resultVariableDef, bool useBool)
        {
            Instruction endIf = processor.Create(OpCodes.Nop);

            if (useBool)
                CreateReadBool(processor, readerParameterDef, resultVariableDef);
            else
                CreateReadPackedWhole(processor, readerParameterDef, resultVariableDef);

            //If (true or == -1) jmp to endIf. True is null.
            processor.Emit(OpCodes.Ldloc, resultVariableDef);
            if (useBool)
            {
                processor.Emit(OpCodes.Brfalse, endIf);
            }
            else
            {
                //-1
                processor.Emit(OpCodes.Ldc_I4_M1);
                processor.Emit(OpCodes.Bne_Un_S, endIf);
            }
            //Insert null.
            processor.Emit(OpCodes.Ldnull);
            //Exit method.
            processor.Emit(OpCodes.Ret);
            //End of if check.
            processor.Append(endIf);
        }

        /// <summary>
        /// Creates a call to WriteBoolean with value.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="writerParameterDef"></param>
        /// <param name="value"></param>
        internal void CreateReadBool(ILProcessor processor, ParameterDefinition readerParameterDef, VariableDefinition localBoolVariableDef)
        {
            MethodReference readBoolMethodRef = GetFavoredReadMethodReference(CodegenSession.GeneralHelper.GetTypeReference(typeof(bool)), true);
            processor.Emit(OpCodes.Ldarg, readerParameterDef);
            processor.Emit(OpCodes.Callvirt, readBoolMethodRef);
            processor.Emit(OpCodes.Stloc, localBoolVariableDef);
        }

        /// <summary>
        /// Creates a call to WritePackWhole with value.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="value"></param>
        internal void CreateReadPackedWhole(ILProcessor processor, ParameterDefinition readerParameterDef, VariableDefinition resultVariableDef)
        {
            //Reader.
            processor.Emit(OpCodes.Ldarg, readerParameterDef);
            //Reader.ReadPackedWhole().
            processor.Emit(OpCodes.Callvirt, Reader_ReadPackedWhole_MethodRef);
            processor.Emit(OpCodes.Conv_I4);
            processor.Emit(OpCodes.Stloc, resultVariableDef);
        }

        #region GetReaderMethodReference.
        /// <summary>
        /// Returns the MethodReference for typeRef.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal MethodReference GetInstancedReadMethodReference(TypeReference typeRef)
        {
            _instancedReaderMethods.TryGetValue(typeRef, out MethodReference methodRef);
            return methodRef;
        }
        /// <summary>
        /// Returns the MethodReference for typeRef.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal MethodReference GetStaticReadMethodReference(TypeReference typeRef)
        {
            _staticReaderMethods.TryGetValue(typeRef, out MethodReference methodRef);
            return methodRef;
        }
        /// <summary>
        /// Returns the MethodReference for typeRef favoring instanced or static. Returns null if not found.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <param name="favorInstanced"></param>
        /// <returns></returns>
        internal MethodReference GetFavoredReadMethodReference(TypeReference typeRef, bool favorInstanced)
        {
            MethodReference result;
            if (favorInstanced)
            {
                result = GetInstancedReadMethodReference(typeRef);
                if (result == null)
                    result = GetStaticReadMethodReference(typeRef);
            }
            else
            {
                result = GetStaticReadMethodReference(typeRef);
                if (result == null)
                    result = GetInstancedReadMethodReference(typeRef);
            }

            return result;
        }
        /// <summary>
        /// Returns the MethodReference for typeRef favoring instanced or static.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <param name="favorInstanced"></param>
        /// <returns></returns>
        internal MethodReference GetOrCreateFavoredReadMethodReference(TypeReference typeRef, bool favorInstanced)
        {
            //Try to get existing writer, if not present make one.
            MethodReference readMethodRef = GetFavoredReadMethodReference(typeRef, favorInstanced);
            if (readMethodRef == null)
                readMethodRef = CodegenSession.ReaderGenerator.CreateReader(typeRef);
            if (readMethodRef == null)
                CodegenSession.LogError($"Could not create deserializer for {typeRef.FullName}.");

            return readMethodRef;
        }
        #endregion

        /// <summary>
        /// Adds typeRef, methodDef to instanced or readerMethods.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <param name="methodRef"></param>
        /// <param name="useAdd"></param>
        internal void AddReaderMethod(TypeReference typeRef, MethodReference methodRef, bool instanced, bool useAdd)
        {
            Dictionary<TypeReference, MethodReference> dict = (instanced) ?
                _instancedReaderMethods : _staticReaderMethods;

            if (useAdd)
                dict.Add(typeRef, methodRef);
            else
                dict[typeRef] = methodRef;
        }

        /// <summary>
        /// Removes typeRef from static/instanced reader methods.
        /// </summary>
        internal void RemoveReaderMethod(TypeReference typeRef, bool instanced)
        {
            Dictionary<TypeReference, MethodReference> dict = (instanced) ?
                _instancedReaderMethods : _staticReaderMethods;

            dict.Remove(typeRef);
        }

        /// <summary>
        /// Creates read instructions returning instructions and outputing variable of read result.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="methodDef"></param>
        /// <param name="readerParameterDef"></param>
        /// <param name="readTypeRef"></param>
        /// <param name="diagnostics"></param>
        /// <returns></returns>
        internal List<Instruction> CreateRead(MethodDefinition methodDef, ParameterDefinition readerParameterDef, TypeReference readTypeRef, out VariableDefinition createdVariableDef)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();
            List<Instruction> insts = new List<Instruction>();
            MethodReference readerMethodRef = GetFavoredReadMethodReference(readTypeRef, true);
            if (readerMethodRef != null)
            {
                //Make a local variable. 
                createdVariableDef = CodegenSession.GeneralHelper.CreateVariable(methodDef, readTypeRef);
                //pooledReader.ReadBool();
                insts.Add(processor.Create(OpCodes.Ldarg, readerParameterDef));
                //If an auto pack method then insert default value.
                if (_autoPackedMethods.Contains(readTypeRef))
                {
                    AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(readTypeRef);
                    insts.Add(processor.Create(OpCodes.Ldc_I4, (int)packType));
                }
                insts.Add(processor.Create(OpCodes.Call, readerMethodRef));
                //Store into local variable.
                insts.Add(processor.Create(OpCodes.Stloc, createdVariableDef));
                return insts;
            }
            else
            {
                CodegenSession.LogError("Reader not found for " + readTypeRef.ToString());
                createdVariableDef = null;
                return null;
            }
        }

        /// <summary>
        /// Creates a read for fieldRef and populates it into a created variable of class or struct type.
        /// </summary> 
        internal bool CreateReadIntoClassOrStruct(MethodDefinition readerMd, ParameterDefinition readerPd, MethodReference readMr, VariableDefinition objectVd, FieldReference valueFr)
        {
            if (readMr != null)
            {
                ILProcessor processor = readerMd.Body.GetILProcessor();
                /* How to load object instance. If it's a structure
                 * then it must be loaded by address. Otherwise if
                 * class Ldloc can be used. */
                OpCode loadOpCode = (objectVd.VariableType.IsValueType) ?
                    OpCodes.Ldloca : OpCodes.Ldloc;

                processor.Emit(loadOpCode, objectVd);
                //reader.
                processor.Emit(OpCodes.Ldarg, readerPd);
                if (IsAutoPackedType(valueFr.FieldType))
                {
                    AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(valueFr.FieldType);
                    processor.Emit(OpCodes.Ldc_I4, (int)packType);
                }
                //reader.ReadXXXX().
                processor.Emit(OpCodes.Call, readMr);
                //obj.Field = result / reader.ReadXXXX().
                processor.Emit(OpCodes.Stfld, valueFr);

                return true;
            }
            else
            {
                CodegenSession.LogError($"Reader not found for {valueFr.FullName}.");
                return false;
            }
        }

        /// <summary>
        /// Creates a read for fieldRef and populates it into a created variable of class or struct type.
        /// </summary>
        internal bool CreateReadIntoClassOrStruct(MethodDefinition methodDef, ParameterDefinition readerPd, MethodReference readMr, VariableDefinition objectVariableDef, MethodReference setMr, TypeReference readTr)
        {
            if (readMr != null)
            {
                ILProcessor processor = methodDef.Body.GetILProcessor();

                /* How to load object instance. If it's a structure
                 * then it must be loaded by address. Otherwise if
                 * class Ldloc can be used. */
                OpCode loadOpCode = (objectVariableDef.VariableType.IsValueType) ?
                    OpCodes.Ldloca : OpCodes.Ldloc;

                processor.Emit(loadOpCode, objectVariableDef);
                //reader.
                processor.Emit(OpCodes.Ldarg, readerPd);
                if (IsAutoPackedType(readTr))
                {
                    AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(readTr);
                    processor.Emit(OpCodes.Ldc_I4, (int)packType);
                }
                //reader.ReadXXXX().
                processor.Emit(OpCodes.Call, readMr);
                //obj.Property = result / reader.ReadXXXX().
                processor.Emit(OpCodes.Call, setMr);

                return true;
            }
            else
            {
                CodegenSession.LogError($"Reader not found for {readTr.FullName}.");
                return false;
            }
        }
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/TimeManagerHelper.cs ---
﻿using FishNet.Managing.Timing;
using MonoFN.Cecil;
using System;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping
{

    internal class TimeManagerHelper
    {

        #region Reflection references.
        internal MethodReference LocalTick_MethodRef;
        internal MethodReference TickDelta_MethodRef;
        internal MethodReference MaximumBufferedInputs_MethodRef;
        internal MethodReference PhysicsMode_MethodRef;
        internal MethodReference InvokeOnReconcile_MethodRef;
        internal MethodReference InvokeOnReplicateReplay_MethodRef;
        #endregion

        internal bool ImportReferences()
        {
            //TimeManager infos.
            Type timeManagerType = typeof(TimeManager);
            foreach (System.Reflection.PropertyInfo pi in timeManagerType.GetProperties())
            {
                if (pi.Name == nameof(TimeManager.LocalTick))
                    LocalTick_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(TimeManager.MaximumBufferedInputs))
                    MaximumBufferedInputs_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(TimeManager.PhysicsMode))
                    PhysicsMode_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
                else if (pi.Name == nameof(TimeManager.TickDelta))
                    TickDelta_MethodRef = CodegenSession.ImportReference(pi.GetMethod);
            }

            foreach (System.Reflection.MethodInfo mi in timeManagerType.GetMethods())
            {
                if (mi.Name == nameof(TimeManager.InvokeOnReconcile))
                    InvokeOnReconcile_MethodRef = CodegenSession.ImportReference(mi);
                else if (mi.Name == nameof(TimeManager.InvokeOnReplicateReplay))
                    InvokeOnReplicateReplay_MethodRef = CodegenSession.ImportReference(mi);
            }

            return true;
        }

    }
}

'''
'''--- Assets/FishNet/CodeGenerating/Helpers/TransportHelper.cs ---
﻿using FishNet.Transporting;
using MonoFN.Cecil;

namespace FishNet.CodeGenerating.Helping
{
    internal class TransportHelper
    {
        #region Reflection references.        
        internal TypeReference Channel_TypeRef;
        #endregion

        /// <summary>
        /// Resets cached values.
        /// </summary>
        private void ResetValues()
        {
            Channel_TypeRef = null;
        }

        /// <summary>
        /// Imports references needed by this helper.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal bool ImportReferences()
        {
            ResetValues();

            Channel_TypeRef = CodegenSession.ImportReference(typeof(Channel));

            return true;
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Typed/Comparers.cs ---
﻿using MonoFN.Cecil;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Helping
{
    internal class TypeDefinitionComparer : IEqualityComparer<TypeDefinition>
    {
        public bool Equals(TypeDefinition a, TypeDefinition b)
        {
            return a.FullName == b.FullName;
        }

        public int GetHashCode(TypeDefinition obj)
        {
            return obj.FullName.GetHashCode();
        }
    }

    internal class TypeReferenceComparer : IEqualityComparer<TypeReference>
    {
        public bool Equals(TypeReference a, TypeReference b)
        {
            return a.FullName == b.FullName;
        }

        public int GetHashCode(TypeReference obj)
        {
            return obj.FullName.GetHashCode();
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Typed/CreatedSyncType.cs ---
﻿using MonoFN.Cecil;

namespace FishNet.CodeGenerating.Helping
{

    internal class CreatedSyncVar
    {
        public readonly TypeDefinition VariableTd;
        public readonly MethodReference GetValueMr;
        public readonly MethodReference SetValueMr;
        public readonly MethodReference SetSyncIndexMr;
        public readonly MethodReference ConstructorMr;
        public readonly GenericInstanceType SyncVarGit;
        public MethodReference HookMr;
        public CreatedSyncVar(GenericInstanceType syncVarGit, TypeDefinition variableTd, MethodReference getValueMr, MethodReference setValueMr, MethodReference setSyncIndexMr,MethodReference hookMr,  MethodReference constructorMr)
        {
            SyncVarGit = syncVarGit;
            VariableTd = variableTd;
            GetValueMr = getValueMr;
            SetValueMr = setValueMr;
            SetSyncIndexMr = setSyncIndexMr;
            HookMr = hookMr;
            ConstructorMr = constructorMr;
        }
    }

    internal class CreatedSyncType
    {
        public TypeDefinition StubClassTypeDefinition;
        public MethodReference GetValueMethodReference;
        public MethodReference SetValueMethodReference;
        public MethodReference GetPreviousClientValueMethodReference;
        public MethodReference ReadMethodReference;
        public MethodReference ConstructorMethodReference;
        public CreatedSyncType(TypeDefinition stubClassTypeDef, MethodReference getMethodRef, MethodReference setMethodRef, MethodReference getPreviousMethodRef, MethodReference readMethodRef, MethodReference constructorMethodRef)
        {
            StubClassTypeDefinition = stubClassTypeDef;
            GetValueMethodReference = getMethodRef;
            SetValueMethodReference = setMethodRef;
            GetPreviousClientValueMethodReference = getPreviousMethodRef;
            ReadMethodReference = readMethodRef;
            ConstructorMethodReference = constructorMethodRef;
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Typed/GeneratorHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Object;
using MonoFN.Cecil;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Helping
{

    internal static class GeneratorHelper
    {
        /// <summary>
        /// Gets what objectTypeRef will be serialized as.
        /// </summary>
        /// <param name="objectTr"></param>
        /// <param name="writer"></param>
        /// <param name="objectTd"></param>
        /// <param name="diagnostics"></param>
        /// <returns></returns>
        internal static SerializerType GetSerializerType(TypeReference objectTr, bool writer, out TypeDefinition objectTd)
        {
            string errorPrefix = (writer) ? "CreateWrite: " : "CreateRead: ";
            objectTd = null;

            /* Check if already has a serializer. */
            if (writer)
            {
                if (CodegenSession.WriterHelper.GetFavoredWriteMethodReference(objectTr, true) != null)
                {
                    CodegenSession.LogError($"Writer already exist for {objectTr.FullName}.");
                    return SerializerType.Invalid;
                }
            }
            else
            {
                if (CodegenSession.ReaderHelper.GetFavoredReadMethodReference(objectTr, true) != null)
                {
                    CodegenSession.LogError($"Reader already exist for {objectTr.FullName}.");
                    return SerializerType.Invalid;
                }
            }

            objectTd = objectTr.CachedResolve();
            //Invalid typeDef.
            if (objectTd == null)
            {
                CodegenSession.LogError($"{errorPrefix}{objectTd.FullName} could not be resolved.");
                return SerializerType.Invalid;
            }
            //By reference.            
            if (objectTr.IsByReference)
            {
                CodegenSession.LogError($"{errorPrefix}Cannot pass {objectTr.Name} by reference");
                return SerializerType.Invalid;
            }
            /* Arrays have to be processed first because it's possible for them to meet other conditions
             * below and be processed wrong. */
            else if (objectTr.IsArray)
            {
                if (objectTr.IsMultidimensionalArray())
                {
                    CodegenSession.LogError($"{errorPrefix}{objectTr.Name} is an unsupported type. Multidimensional arrays are not supported");
                    return SerializerType.Invalid;
                }
                else
                {
                    return SerializerType.Array;
                }
            }
            //Enum.
            else if (objectTd.IsEnum)
            {
                return SerializerType.Enum;
            }
            else if (objectTd.Is(typeof(Dictionary<,>)))
            {
                return SerializerType.Dictionary;
            }
            else if (objectTd.Is(typeof(List<>)))
            {
                return SerializerType.List;
            }
            else if (objectTd.InheritsFrom<NetworkBehaviour>())
            {
                return SerializerType.NetworkBehaviour;
            }
            else if (objectTr.Name == typeof(System.Nullable<>).Name)
            {
                GenericInstanceType git = objectTr as GenericInstanceType;
                if (git == null || git.GenericArguments.Count != 1)
                    return SerializerType.Invalid;
                else
                    return SerializerType.Nullable;
            }
            //Invalid type. This must be called after trying to generate everything but class.
            else if (!GeneratorHelper.IsValidSerializeType(objectTd))
            {
                return SerializerType.Invalid;
            }
            //If here then the only type left is struct or class.
            else if (objectTr.IsClassOrStruct())
            {
                return SerializerType.ClassOrStruct;
            }
            //Unknown type.
            else
            {
                CodegenSession.LogError($"{errorPrefix}{objectTr.Name} is an unsupported type. Mostly because we don't know what the heck it is. Please let us know so we can fix this.");
                return SerializerType.Invalid;
            }
        }

        /// <summary>
        /// Returns if objectTypeRef is an invalid type, which cannot be serialized.
        /// </summary>
        /// <param name="objectTd"></param>
        /// <returns></returns> 
        private static bool IsValidSerializeType(TypeDefinition objectTd) //todo rename. applies only to types which do not have a user made or included serializer.
        {
            string errorText = $"{objectTd.Name} is not a supported type. Use a supported type or provide a custom serializer";

            System.Type unityObjectType = typeof(UnityEngine.Object);
            //Unable to determine type, cannot generate for.
            if (objectTd == null)
            {
                CodegenSession.LogError(errorText);
                return false;
            }
            //Component.
            if (objectTd.InheritsFrom<UnityEngine.Component>())
            {
                CodegenSession.LogError(errorText);
                return false;
            }
            //Unity Object.
            if (objectTd.Is(unityObjectType))
            {
                CodegenSession.LogError(errorText);
                return false;
            }
            //ScriptableObject.
            if (objectTd.Is(typeof(UnityEngine.ScriptableObject)))
            {
                CodegenSession.LogError(errorText);
                return false;
            }
            //Has generic parameters.
            if (objectTd.HasGenericParameters)
            {
                CodegenSession.LogError(errorText);
                return false;
            }
            //Is an interface.
            if (objectTd.IsInterface)
            {
                CodegenSession.LogError(errorText);
                return false;
            }
            //Is abstract.
            if (objectTd.IsAbstract)
            {
                CodegenSession.LogError(errorText);
                return false;
            }
            if (objectTd.InheritsFrom(unityObjectType) && objectTd.IsExcluded(GeneralHelper.UNITYENGINE_ASSEMBLY_PREFIX))
            {
                CodegenSession.LogError(errorText);
                return false;
            }

            //If here type is valid.
            return true;
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Typed/QOLAttributeType.cs ---
namespace FishNet.CodeGenerating.Helping
{

    internal enum QolAttributeType
    {
        None,
        Server,
        Client
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Typed/SerializatierType.cs ---
﻿namespace FishNet.CodeGenerating.Helping
{

    internal enum SerializerType
    {
        Invalid,
        Enum,
        Array,
        List,
        NetworkBehaviour,
        ClassOrStruct,
        Nullable,
        Dictionary,
        Null,
        ByReference,
        MultiDimensionalArray
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Typed/SyncIndexData.cs ---
using MonoFN.Cecil.Cil;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Helping
{

    /// <summary>
    /// Data used to modify an RpcIndex should the class have to be rebuilt.
    /// </summary>
    internal class SyncIndexData
    {
        public uint SyncCount = 0;
        public List<Instruction> DelegateInstructions = new List<Instruction>();
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/Typed/SyncType.cs ---
﻿namespace FishNet.CodeGenerating.Helping
{

    public enum SyncType
    {
        Unset,
        Variable,
        List,
        Dictionary,
        HashSet,
        Custom
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/WriterGenerator.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Object;
using FishNet.Serializing;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping
{
    internal class WriterGenerator
    {

        #region Const.
        internal const string GENERATED_WRITERS_CLASS_NAME = "GeneratedWriters___FN";
        public const TypeAttributes GENERATED_TYPE_ATTRIBUTES = (TypeAttributes.BeforeFieldInit | TypeAttributes.Class | TypeAttributes.AnsiClass |
            TypeAttributes.Public | TypeAttributes.AutoClass | TypeAttributes.Abstract | TypeAttributes.Sealed);
        private const string WRITE_PREFIX = "Write___";
        #endregion

        /// <summary>
        /// Imports references needed by this helper.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal bool ImportReferences()
        {
            return true;
        }

        /// <summary>
        /// Generates a writer for objectTypeReference if one does not already exist.
        /// </summary>
        /// <param name="objectTr"></param>
        /// <returns></returns>
        internal MethodReference CreateWriter(TypeReference objectTr)
        {
            MethodReference methodRefResult = null;
            TypeDefinition objectTd;
            SerializerType serializerType = GeneratorHelper.GetSerializerType(objectTr, true, out objectTd);

            if (serializerType != SerializerType.Invalid)
            {
                //Array.
                if (serializerType == SerializerType.Array)
                    methodRefResult = CreateArrayWriterMethodDefinition(objectTr);
                //Enum.
                else if (serializerType == SerializerType.Enum)
                    methodRefResult = CreateEnumWriterMethodDefinition(objectTr);
                //Dictionary.
                else if (serializerType == SerializerType.Dictionary)
                    methodRefResult = CreateDictionaryWriterMethodReference(objectTr);
                //List.
                else if (serializerType == SerializerType.List)
                    methodRefResult = CreateListWriterMethodReference(objectTr);
                //NetworkBehaviour.
                else if (serializerType == SerializerType.NetworkBehaviour)
                    methodRefResult = CreateNetworkBehaviourWriterMethodReference(objectTd);
                //Nullable type.
                else if (serializerType == SerializerType.Nullable)
                    methodRefResult = CreateNullableWriterMethodReference(objectTr, objectTd);
                //Class or struct.
                else if (serializerType == SerializerType.ClassOrStruct)
                    methodRefResult = CreateClassOrStructWriterMethodDefinition(objectTr);
            }

            //If was not created.
            if (methodRefResult == null)
                RemoveFromStaticWriters(objectTr);

            return methodRefResult;
        }

        /// <summary>
        /// Removes from static writers.
        /// </summary>
        private void RemoveFromStaticWriters(TypeReference tr)
        {
            CodegenSession.WriterHelper.RemoveWriterMethod(tr, false);
        }
        /// <summary>
        /// Adds to static writers.
        /// </summary>
        private void AddToStaticWriters(TypeReference tr, MethodReference mr)
        {
            CodegenSession.WriterHelper.AddWriterMethod(tr, mr.CachedResolve(), false, true);
        }

        /// <summary>
        /// Adds a write for a NetworkBehaviour class type to WriterMethods.
        /// </summary>
        /// <param name="classTypeRef"></param>
        private MethodReference CreateNetworkBehaviourWriterMethodReference(TypeReference objectTr)
        {
            objectTr = CodegenSession.ImportReference(objectTr.Resolve());
            //All NetworkBehaviour types will simply WriteNetworkBehaviour/ReadNetworkBehaviour.
            //Create generated reader/writer class. This class holds all generated reader/writers.
            CodegenSession.GeneralHelper.GetOrCreateClass(out _, GENERATED_TYPE_ATTRIBUTES, GENERATED_WRITERS_CLASS_NAME, null);

            MethodDefinition createdWriterMd = CreateStaticWriterStubMethodDefinition(objectTr);
            AddToStaticWriters(objectTr, createdWriterMd);

            ILProcessor processor = createdWriterMd.Body.GetILProcessor();

            MethodReference writeMethodRef = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(CodegenSession.WriterHelper.NetworkBehaviour_TypeRef, true);
            //Get parameters for method.
            ParameterDefinition writerParameterDef = createdWriterMd.Parameters[0];
            ParameterDefinition classParameterDef = createdWriterMd.Parameters[1];

            //Load parameters as arguments.
            processor.Emit(OpCodes.Ldarg, writerParameterDef);
            processor.Emit(OpCodes.Ldarg, classParameterDef);
            //writer.WriteNetworkBehaviour(arg1);
            processor.Emit(OpCodes.Call, writeMethodRef);

            processor.Emit(OpCodes.Ret);

            return CodegenSession.ImportReference(createdWriterMd);
        }

        /// <summary> 
        /// Gets the length of a collection and writes the value to a variable.
        /// </summary>
        private void CreateCollectionLength(ILProcessor processor, ParameterDefinition collectionParameterDef, VariableDefinition storeVariableDef)
        {
            processor.Emit(OpCodes.Ldarg, collectionParameterDef);
            processor.Emit(OpCodes.Ldlen);
            processor.Emit(OpCodes.Conv_I4);
            processor.Emit(OpCodes.Stloc, storeVariableDef);
        }

        /// <summary>
        /// Creates a writer for a class or struct of objectTypeRef.
        /// </summary>
        /// <param name="objectTr"></param>
        /// <returns></returns>
        private MethodReference CreateNullableWriterMethodReference(TypeReference objectTr, TypeDefinition objectTd)
        {
            GenericInstanceType objectGit = objectTr as GenericInstanceType;
            TypeReference valueTr = objectGit.GenericArguments[0];

            //Get the writer for the value.
            MethodReference valueWriterMr = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(valueTr, true);
            if (valueWriterMr == null)
                return null;

            MethodDefinition tmpMd;
            tmpMd = objectTd.GetMethod("get_Value");
            MethodReference genericGetValueMr = tmpMd.MakeHostInstanceGeneric(objectGit);
            tmpMd = objectTd.GetMethod("get_HasValue");
            MethodReference genericHasValueMr = tmpMd.MakeHostInstanceGeneric(objectGit);

            /* Stubs generate Method(Writer writer, T value). */
            MethodDefinition createdWriterMd = CreateStaticWriterStubMethodDefinition(objectTr);
            ILProcessor processor = createdWriterMd.Body.GetILProcessor();

            //Value parameter.
            ParameterDefinition valuePd = createdWriterMd.Parameters[1];

            ParameterDefinition writerPd = createdWriterMd.Parameters[0];

            //Have to write a new ret on null because nullables use hasValue for null checks.
            Instruction afterNullRetInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldarga, valuePd);
            processor.Emit(OpCodes.Call, genericHasValueMr);
            processor.Emit(OpCodes.Brtrue_S, afterNullRetInst);
            CodegenSession.WriterHelper.CreateWriteBool(processor, writerPd, true);
            processor.Emit(OpCodes.Ret);
            processor.Append(afterNullRetInst);

            //Code will only execute here and below if not null.
            CodegenSession.WriterHelper.CreateWriteBool(processor, writerPd, false);

            processor.Emit(OpCodes.Ldarg, writerPd);
            processor.Emit(OpCodes.Ldarga, valuePd);
            processor.Emit(OpCodes.Call, genericGetValueMr);
            //If an auto pack method then insert default value.
            if (CodegenSession.WriterHelper.IsAutoPackedType(valueTr))
            {
                AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(valueTr);
                processor.Emit(OpCodes.Ldc_I4, (int)packType);
            }
            processor.Emit(OpCodes.Call, valueWriterMr);

            processor.Emit(OpCodes.Ret);
            return CodegenSession.ImportReference(createdWriterMd);
        }

        /// <summary>
        /// Creates a writer for a class or struct of objectTypeRef.
        /// </summary>
        /// <param name="objectTr"></param>
        /// <returns></returns>
        private MethodReference CreateClassOrStructWriterMethodDefinition(TypeReference objectTr)
        {
            /*Stubs generate Method(Writer writer, T value). */
            MethodDefinition createdWriterMd = CreateStaticWriterStubMethodDefinition(objectTr);
            AddToStaticWriters(objectTr, createdWriterMd);

            ILProcessor processor = createdWriterMd.Body.GetILProcessor();

            //If not a value type then add a null check.
            if (!objectTr.CachedResolve().IsValueType)
            {
                ParameterDefinition writerPd = createdWriterMd.Parameters[0];
                CodegenSession.WriterHelper.CreateRetOnNull(processor, writerPd, createdWriterMd.Parameters[1], true);
                //Code will only execute here and below if not null.
                CodegenSession.WriterHelper.CreateWriteBool(processor, writerPd, false);
            }

            //Write all fields for the class or struct.
            ParameterDefinition valueParameterDef = createdWriterMd.Parameters[1];
            if (!WriteFieldsAndProperties(createdWriterMd, valueParameterDef, objectTr))
                return null;

            processor.Emit(OpCodes.Ret);
            return CodegenSession.ImportReference(createdWriterMd);
        }

        /// <summary>
        /// Find all fields in type and write them
        /// </summary>
        /// <param name="objectTr"></param>
        /// <param name="processor"></param>
        /// <returns>false if fail</returns>
        private bool WriteFieldsAndProperties(MethodDefinition writerMd, ParameterDefinition valuePd, TypeReference objectTr)
        {
            //This probably isn't needed but I'm too afraid to remove it.
            if (objectTr.Module != CodegenSession.Module)
                objectTr = CodegenSession.ImportReference(objectTr.CachedResolve());

            //Fields
            foreach (FieldDefinition fieldDef in objectTr.FindAllPublicFields(true, true))//, WriterHelper.EXCLUDED_AUTO_SERIALIZER_TYPES))
            {
                if (GetWriteMethod(fieldDef.FieldType, out MethodReference writeMr))
                    CodegenSession.WriterHelper.CreateWrite(writerMd, valuePd, fieldDef, writeMr);
            }

            //Properties.
            foreach (PropertyDefinition propertyDef in objectTr.FindAllPublicProperties(
                true, WriterHelper.EXCLUDED_AUTO_SERIALIZER_TYPES, WriterHelper.EXCLUDED_ASSEMBLY_PREFIXES))
            {
                if (GetWriteMethod(propertyDef.PropertyType, out MethodReference writerMr))
                {
                    MethodReference getMr = CodegenSession.Module.ImportReference(propertyDef.GetMethod);
                    CodegenSession.WriterHelper.CreateWrite(writerMd, valuePd, getMr, writerMr);
                }
            }

            //Gets or creates writer method and outputs it. Returns true if method is found or created.
            bool GetWriteMethod(TypeReference tr, out MethodReference writeMr)
            {
                tr = CodegenSession.ImportReference(tr);
                writeMr = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(tr, true);
                return (writeMr != null);
            }

            return true;
        }

        /// <summary>
        /// Creates a writer for an enum.
        /// </summary>
        /// <param name="enumTr"></param>
        /// <returns></returns>
        private MethodReference CreateEnumWriterMethodDefinition(TypeReference enumTr)
        {
            MethodDefinition createdWriterMd = CreateStaticWriterStubMethodDefinition(enumTr);
            AddToStaticWriters(enumTr, createdWriterMd);

            ILProcessor processor = createdWriterMd.Body.GetILProcessor();

            //Element type for enum. EG: byte int ect
            TypeReference underlyingTypeRef = enumTr.CachedResolve().GetEnumUnderlyingTypeReference();
            //Method to write that type.
            MethodReference underlyingWriterMethodRef = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(underlyingTypeRef, true);
            if (underlyingWriterMethodRef == null)
                return null;

            ParameterDefinition writerParameterDef = createdWriterMd.Parameters[0];
            ParameterDefinition valueParameterDef = createdWriterMd.Parameters[1];
            //Push writer and value into call.
            processor.Emit(OpCodes.Ldarg, writerParameterDef);
            processor.Emit(OpCodes.Ldarg, valueParameterDef);
            if (CodegenSession.WriterHelper.IsAutoPackedType(underlyingTypeRef))
                processor.Emit(OpCodes.Ldc_I4, (int)AutoPackType.Packed);

            //writer.WriteXXX(value)
            processor.Emit(OpCodes.Call, underlyingWriterMethodRef);

            processor.Emit(OpCodes.Ret);
            return CodegenSession.ImportReference(createdWriterMd);
        }

        /// <summary>
        /// Creates a writer for an array.
        /// </summary>
        private MethodReference CreateArrayWriterMethodDefinition(TypeReference objectTr)
        {
            /* Try to get instanced first for collection element type, if it doesn't exist then try to
             * get/or make a one. */
            TypeReference elementTypeRef = objectTr.GetElementType();
            MethodReference writeMethodRef = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(elementTypeRef, true);
            if (writeMethodRef == null)
                return null;

            MethodDefinition createdWriterMd = CreateStaticWriterStubMethodDefinition(objectTr);
            AddToStaticWriters(objectTr, createdWriterMd);

            ILProcessor processor = createdWriterMd.Body.GetILProcessor();

            //Null instructions.
            CodegenSession.WriterHelper.CreateRetOnNull(processor, createdWriterMd.Parameters[0], createdWriterMd.Parameters[1], false);

            //Write length. It only makes it this far if not null.
            //int length = arr[].Length.
            VariableDefinition sizeVariableDef = CodegenSession.GeneralHelper.CreateVariable(createdWriterMd, typeof(int));
            CreateCollectionLength(processor, createdWriterMd.Parameters[1], sizeVariableDef);
            //writer.WritePackedWhole(length).
            CodegenSession.WriterHelper.CreateWritePackedWhole(processor, createdWriterMd.Parameters[0], sizeVariableDef);

            VariableDefinition loopIndex = CodegenSession.GeneralHelper.CreateVariable(createdWriterMd, typeof(int));
            Instruction loopComparer = processor.Create(OpCodes.Ldloc, loopIndex);

            //int i = 0
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, loopIndex);
            processor.Emit(OpCodes.Br_S, loopComparer);

            //Loop content.
            Instruction contentStart = processor.Create(OpCodes.Ldarg_0);
            processor.Append(contentStart);
            processor.Emit(OpCodes.Ldarg_1);
            processor.Emit(OpCodes.Ldloc, loopIndex);

            if (elementTypeRef.IsValueType)
                processor.Emit(OpCodes.Ldelem_Any, elementTypeRef);
            else
                processor.Emit(OpCodes.Ldelem_Ref);
            //If auto pack type then write default auto pack.
            if (CodegenSession.WriterHelper.IsAutoPackedType(elementTypeRef))
            {
                AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(elementTypeRef);
                processor.Emit(OpCodes.Ldc_I4, (int)packType);
            }
            //writer.Write
            processor.Emit(OpCodes.Call, writeMethodRef);

            //i++
            processor.Emit(OpCodes.Ldloc, loopIndex);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc, loopIndex);
            //if i < length jmp to content start.
            processor.Append(loopComparer);  //if i < obj(size).
            processor.Emit(OpCodes.Ldloc, sizeVariableDef);
            processor.Emit(OpCodes.Blt_S, contentStart);

            processor.Emit(OpCodes.Ret);
            return CodegenSession.ImportReference(createdWriterMd);
        }

        /// <summary>
        /// Creates a writer for a dictionary collection.
        /// </summary>
        private MethodReference CreateDictionaryWriterMethodReference(TypeReference objectTr)
        {
            GenericInstanceType genericInstance = (GenericInstanceType)objectTr;
            CodegenSession.ImportReference(genericInstance);
            TypeReference keyTr = genericInstance.GenericArguments[0];
            TypeReference valueTr = genericInstance.GenericArguments[1];

            /* Try to get instanced first for collection element type, if it doesn't exist then try to
             * get/or make a one. */
            MethodReference keyWriteMr = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(keyTr, true);
            MethodReference valueWriteMr = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(valueTr, true);
            if (keyWriteMr == null || valueWriteMr == null)
                return null;

            MethodDefinition createdWriterMd = CreateStaticWriterStubMethodDefinition(objectTr);
            AddToStaticWriters(objectTr, createdWriterMd);

            ILProcessor processor = createdWriterMd.Body.GetILProcessor();
            GenericInstanceMethod genericInstanceMethod = CodegenSession.WriterHelper.Writer_WriteDictionary_MethodRef.MakeGenericMethod(new TypeReference[] { keyTr, valueTr });

            ParameterDefinition writerPd = createdWriterMd.Parameters[0];
            ParameterDefinition valuePd = createdWriterMd.Parameters[1];
            processor.Emit(OpCodes.Ldarg, writerPd);
            processor.Emit(OpCodes.Ldarg, valuePd);
            processor.Emit(OpCodes.Callvirt, genericInstanceMethod);
            processor.Emit(OpCodes.Ret);

            return CodegenSession.ImportReference(createdWriterMd);
        }

        /// <summary>
        /// Creates a writer for a list.
        /// </summary>
        private MethodReference CreateListWriterMethodReference(TypeReference objectTr)
        {
            GenericInstanceType genericInstance = (GenericInstanceType)objectTr;
            CodegenSession.ImportReference(genericInstance);
            TypeReference elementTypeRef = genericInstance.GenericArguments[0];

            /* Try to get instanced first for collection element type, if it doesn't exist then try to
             * get/or make a one. */
            MethodReference writeMethodRef = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(elementTypeRef, true);
            if (writeMethodRef == null)
                return null;

            MethodDefinition createdWriterMd = CreateStaticWriterStubMethodDefinition(objectTr);
            AddToStaticWriters(objectTr, createdWriterMd);

            ILProcessor processor = createdWriterMd.Body.GetILProcessor();

            //Find add method for list.
            MethodReference lstGetItemMd = objectTr.CachedResolve().GetMethod("get_Item");
            MethodReference lstGetItemMr = lstGetItemMd.MakeHostInstanceGeneric(genericInstance);

            //Null instructions.
            CodegenSession.WriterHelper.CreateRetOnNull(processor, createdWriterMd.Parameters[0], createdWriterMd.Parameters[1], false);

            //Write length. It only makes it this far if not null.
            //int length = List<T>.Count.
            VariableDefinition sizeVariableDef = CodegenSession.GeneralHelper.CreateVariable(createdWriterMd, typeof(int));
            CreateCollectionLength(processor, createdWriterMd.Parameters[1], sizeVariableDef);
            //writer.WritePackedWhole(length).
            CodegenSession.WriterHelper.CreateWritePackedWhole(processor, createdWriterMd.Parameters[0], sizeVariableDef);

            VariableDefinition loopIndex = CodegenSession.GeneralHelper.CreateVariable(createdWriterMd, typeof(int));
            Instruction loopComparer = processor.Create(OpCodes.Ldloc, loopIndex);

            //int i = 0
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, loopIndex);
            processor.Emit(OpCodes.Br_S, loopComparer);

            //Loop content.
            Instruction contentStart = processor.Create(OpCodes.Ldarg_0);
            processor.Append(contentStart);
            processor.Emit(OpCodes.Ldarg_1);
            processor.Emit(OpCodes.Ldloc, loopIndex);

            processor.Emit(OpCodes.Callvirt, lstGetItemMr);
            //If auto pack type then write default auto pack.
            if (CodegenSession.WriterHelper.IsAutoPackedType(elementTypeRef))
            {
                AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(elementTypeRef);
                processor.Emit(OpCodes.Ldc_I4, (int)packType);
            }
            //writer.Write
            processor.Emit(OpCodes.Call, writeMethodRef);

            //i++
            processor.Emit(OpCodes.Ldloc, loopIndex);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc, loopIndex);
            //if i < length jmp to content start.
            processor.Append(loopComparer);  //if i < obj(size).
            processor.Emit(OpCodes.Ldloc, sizeVariableDef);
            processor.Emit(OpCodes.Blt_S, contentStart);

            processor.Emit(OpCodes.Ret);
            return CodegenSession.ImportReference(createdWriterMd);
        }

        /// <summary>
        /// Creates a method definition stub for objectTypeRef.
        /// </summary>
        /// <param name="objectTypeRef"></param>
        /// <returns></returns>
        private MethodDefinition CreateStaticWriterStubMethodDefinition(TypeReference objectTypeRef, string nameExtension = "")
        {
            string methodName = $"{WRITE_PREFIX}{objectTypeRef.FullName}{nameExtension}";
            // create new writer for this type
            TypeDefinition writerTypeDef = CodegenSession.GeneralHelper.GetOrCreateClass(out _, GENERATED_TYPE_ATTRIBUTES, GENERATED_WRITERS_CLASS_NAME, null);

            MethodDefinition writerMethodDef = writerTypeDef.AddMethod(methodName,
                    MethodAttributes.Public |
                    MethodAttributes.Static |
                    MethodAttributes.HideBySig);

            CodegenSession.GeneralHelper.CreateParameter(writerMethodDef, CodegenSession.WriterHelper.Writer_TypeRef, "writer");
            CodegenSession.GeneralHelper.CreateParameter(writerMethodDef, objectTypeRef, "value");
            writerMethodDef.Body.InitLocals = true;

            return writerMethodDef;
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Helpers/WriterHelper.cs ---
﻿using FishNet.CodeGenerating.Helping.Extension;
using FishNet.CodeGenerating.ILCore;
using FishNet.Object;
using FishNet.Serializing;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace FishNet.CodeGenerating.Helping
{
    internal class WriterHelper
    {
        #region Reflection references.
        private MethodReference WriterPool_GetWriter_MethodRef;
        private MethodReference WriterPool_GetWriterLength_MethodRef;
        private MethodReference Writer_WritePackedWhole_MethodRef;
        internal TypeReference PooledWriter_TypeRef;
        internal TypeReference Writer_TypeRef;
        internal readonly Dictionary<TypeReference, MethodReference> _instancedWriterMethods = new Dictionary<TypeReference, MethodReference>(new TypeReferenceComparer());
        private readonly Dictionary<TypeReference, MethodReference> _staticWriterMethods = new Dictionary<TypeReference, MethodReference>(new TypeReferenceComparer());
        private HashSet<TypeReference> _autoPackedMethods = new HashSet<TypeReference>(new TypeReferenceComparer());
        private MethodReference PooledWriter_Dispose_MethodRef;
        internal MethodReference Writer_WriteDictionary_MethodRef;
        internal TypeReference NetworkBehaviour_TypeRef;
        #endregion

        #region Const.
        internal const string WRITE_PREFIX = "Write";
        /// <summary>
        /// Types to exclude from being scanned for auto serialization.
        /// </summary>
        public static readonly System.Type[] EXCLUDED_AUTO_SERIALIZER_TYPES = new System.Type[]
        {
            typeof(NetworkBehaviour)
        };
        /// <summary>
        /// Types within assemblies which begin with these prefixes will not have serializers created for them.
        /// </summary>
        public static readonly string[] EXCLUDED_ASSEMBLY_PREFIXES = new string[]
        {
            "UnityEngine."
        };
        #endregion

        /// <summary>
        /// Imports references needed by this helper.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <returns></returns>
        internal bool ImportReferences()
        {
            PooledWriter_TypeRef = CodegenSession.ImportReference(typeof(PooledWriter));
            Writer_TypeRef = CodegenSession.ImportReference(typeof(Writer));
            NetworkBehaviour_TypeRef = CodegenSession.ImportReference(typeof(NetworkBehaviour));

            //WriterPool.GetWriter
            Type writerPoolType = typeof(WriterPool);
            foreach (var methodInfo in writerPoolType.GetMethods())
            {
                if (methodInfo.Name == nameof(WriterPool.GetWriter))
                {
                    //GetWriter().
                    if (methodInfo.GetParameters().Length == 0)
                    {
                        WriterPool_GetWriter_MethodRef = CodegenSession.ImportReference(methodInfo);
                    }
                    //GetWriter(?).
                    else if (methodInfo.GetParameters().Length == 1)
                    {
                        ParameterInfo pi = methodInfo.GetParameters()[0];
                        //GetWriter(int).
                        if (pi.ParameterType == typeof(int))
                            WriterPool_GetWriterLength_MethodRef = CodegenSession.ImportReference(methodInfo);
                    }
                }
            }

            Type pooledWriterType = typeof(PooledWriter);
            foreach (MethodInfo methodInfo in pooledWriterType.GetMethods())
            {
                /* Special methods. */
                //Write.Dispose.
                if (methodInfo.Name == nameof(PooledWriter.Dispose))
                {
                    PooledWriter_Dispose_MethodRef = CodegenSession.ImportReference(methodInfo);
                    continue;
                }
                //WritePackedWhole.
                else if (methodInfo.Name == nameof(PooledWriter.WritePackedWhole))
                {
                    Writer_WritePackedWhole_MethodRef = CodegenSession.ImportReference(methodInfo);
                    continue;
                }
                //WriteDictionary.
                else if (methodInfo.Name == nameof(PooledWriter.WriteDictionary))
                {
                    Writer_WriteDictionary_MethodRef = CodegenSession.ImportReference(methodInfo);
                    continue;
                }

                else if (CodegenSession.GeneralHelper.CodegenExclude(methodInfo))
                    continue;
                //Generic methods are not supported.
                else if (methodInfo.IsGenericMethod)
                    continue;
                //Not long enough to be a write method.
                else if (methodInfo.Name.Length < WRITE_PREFIX.Length)
                    continue;
                //Method name doesn't start with writePrefix.
                else if (methodInfo.Name.Substring(0, WRITE_PREFIX.Length) != WRITE_PREFIX)
                    continue;

                ParameterInfo[] parameterInfos = methodInfo.GetParameters();
                /* No parameters or more than 2 parameters. Most Write methods
                * will have only 1 parameter but some will have 2 if
                * there is a pack option. */
                if (parameterInfos.Length < 1 || parameterInfos.Length > 2)
                    continue;
                /* If two parameters make sure the second parameter
                 * is a pack parameter. */
                bool autoPackMethod = false;
                if (parameterInfos.Length == 2)
                {
                    autoPackMethod = (parameterInfos[1].ParameterType == typeof(AutoPackType));
                    if (!autoPackMethod)
                        continue;
                }
                //First parameter is generic; these are not supported.
                if (parameterInfos[0].ParameterType.IsGenericParameter)
                    continue;

                /* TypeReference for the first parameter in the write method. 
                 * The first parameter will always be the type written. */
                TypeReference typeRef = CodegenSession.ImportReference(parameterInfos[0].ParameterType);
                /* If here all checks pass. */
                MethodReference methodRef = CodegenSession.ImportReference(methodInfo);
                AddWriterMethod(typeRef, methodRef, true, true);
                if (autoPackMethod)
                    _autoPackedMethods.Add(typeRef);
            }

            Type writerExtensionsType = typeof(WriterExtensions);
            foreach (MethodInfo methodInfo in writerExtensionsType.GetMethods())
            {
                if (CodegenSession.GeneralHelper.CodegenExclude(methodInfo))
                    continue;
                //Generic methods are not supported.
                if (methodInfo.IsGenericMethod)
                    continue;
                //Not static.
                if (!methodInfo.IsStatic)
                    continue;
                //Not long enough to be a write method.
                if (methodInfo.Name.Length < WRITE_PREFIX.Length)
                    continue;
                //Method name doesn't start with writePrefix.
                if (methodInfo.Name.Substring(0, WRITE_PREFIX.Length) != WRITE_PREFIX)
                    continue;
                ParameterInfo[] parameterInfos = methodInfo.GetParameters();
                /* No parameters or more than 3 parameters. Most extension Write methods
                 * will have only 2 parameter but some will have 3 if
                 * there is a pack option. */
                if (parameterInfos.Length < 2 || parameterInfos.Length > 3)
                    continue;
                /* If 3 parameters make sure the 3rd parameter
                 * is a pack parameter. */
                bool autoPackMethod = false;
                if (parameterInfos.Length == 3)
                {
                    autoPackMethod = (parameterInfos[2].ParameterType == typeof(AutoPackType));
                    if (!autoPackMethod)
                        continue;
                }
                //First parameter is generic; these are not supported.
                if (parameterInfos[1].ParameterType.IsGenericParameter)
                    continue;

                /* TypeReference for the second parameter in the write method.
                 * The first parameter will always be the type written. */
                TypeReference typeRef = CodegenSession.ImportReference(parameterInfos[1].ParameterType);
                /* If here all checks pass. */
                MethodReference methodRef = CodegenSession.ImportReference(methodInfo);
                AddWriterMethod(typeRef, methodRef, false, true);
            }

            return true;
        }

        /// <summary>
        /// Creates generic write delegates for all currently known write types.
        /// </summary>
        internal bool CreateGenericDelegates()
        {
            bool modified = false;
            /* Only write statics. This will include extensions and generated. */
            foreach (KeyValuePair<TypeReference, MethodReference> item in _staticWriterMethods)
            {
                if (FishNetILPP.CODEGEN_THIS_NAMESPACE.Length == 0 || item.Key.FullName.Contains(FishNetILPP.CODEGEN_THIS_NAMESPACE))
                {
                    CodegenSession.GenericWriterHelper.CreateWriteDelegate(item.Value, true);
                    modified = true;
                }
            }

            return modified;
        }

        /// <summary>
        /// Returns if typeRef has a serializer.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal bool HasSerializer(TypeReference typeRef, bool createMissing)
        {
            bool result = (GetInstancedWriteMethodReference(typeRef) != null) ||
                (GetStaticWriteMethodReference(typeRef) != null);

            if (!result && createMissing)
            {
                if (!CodegenSession.GeneralHelper.HasNonSerializableAttribute(typeRef.CachedResolve()))
                {
                    MethodReference methodRef = CodegenSession.WriterGenerator.CreateWriter(typeRef);
                    result = (methodRef != null);
                }
            }

            return result;
        }

        #region GetWriterMethodReference.
        /// <summary>
        /// Returns the MethodReference for typeRef.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal MethodReference GetInstancedWriteMethodReference(TypeReference typeRef)
        {
            _instancedWriterMethods.TryGetValue(typeRef, out MethodReference methodRef);
            return methodRef;
        }
        /// <summary>
        /// Returns the MethodReference for typeRef.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal MethodReference GetStaticWriteMethodReference(TypeReference typeRef)
        {
            _staticWriterMethods.TryGetValue(typeRef, out MethodReference methodRef);
            return methodRef;
        }
        /// <summary>
        /// Returns the MethodReference for typeRef favoring instanced or static.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <param name="favorInstanced"></param>
        /// <returns></returns>
        internal MethodReference GetFavoredWriteMethodReference(TypeReference typeRef, bool favorInstanced)
        {
            MethodReference result;
            if (favorInstanced)
            {
                result = GetInstancedWriteMethodReference(typeRef);
                if (result == null)
                    result = GetStaticWriteMethodReference(typeRef);
            }
            else
            {
                result = GetStaticWriteMethodReference(typeRef);
                if (result == null)
                    result = GetInstancedWriteMethodReference(typeRef);
            }

            return result;
        }
        /// <summary>
        /// Gets the write MethodRef for typeRef, or tries to create it if not present.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal MethodReference GetOrCreateFavoredWriteMethodReference(TypeReference typeRef, bool favorInstanced)
        {
            //Try to get existing writer, if not present make one.
            MethodReference writeMethodRef = GetFavoredWriteMethodReference(typeRef, favorInstanced);

            if (writeMethodRef == null)
                writeMethodRef = CodegenSession.WriterGenerator.CreateWriter(typeRef);
            if (writeMethodRef == null)
                CodegenSession.LogError($"Could not create serializer for {typeRef.FullName}.");

            return writeMethodRef;
        }
        #endregion

        /// <summary>
        /// Adds typeRef, methodDef to InstancedWriterMethods.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <param name="methodRef"></param>
        /// <param name="useAdd"></param>
        internal void AddWriterMethod(TypeReference typeRef, MethodReference methodRef, bool instanced, bool useAdd)
        {
            Dictionary<TypeReference, MethodReference> dict = (instanced) ?
            _instancedWriterMethods : _staticWriterMethods;

            if (useAdd)
                dict.Add(typeRef, methodRef);
            else
                dict[typeRef] = methodRef;
        }

        /// <summary>
        /// Removes typeRef from Static or InstancedWriterMethods.
        /// </summary>
        internal void RemoveWriterMethod(TypeReference typeRef, bool instanced)
        {
            Dictionary<TypeReference, MethodReference> dict = (instanced) ?
            _instancedWriterMethods : _staticWriterMethods;

            dict.Remove(typeRef);
        }

        /// <summary>
        /// Creates a PooledWriter within the body/ and returns its variable index.
        /// EG: PooledWriter writer = WriterPool.GetWriter();
        /// </summary>
        internal VariableDefinition CreatePooledWriter(MethodDefinition methodDef, int length)
        {
            VariableDefinition resultVd;
            List<Instruction> insts = CreatePooledWriter(methodDef, length, out resultVd);

            ILProcessor processor = methodDef.Body.GetILProcessor();
            processor.Add(insts);
            return resultVd;
        }
        /// <summary>
        /// Creates a PooledWriter within the body/ and returns its variable index.
        /// EG: PooledWriter writer = WriterPool.GetWriter();
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="methodDef"></param>
        /// <returns></returns>
        internal List<Instruction> CreatePooledWriter(MethodDefinition methodDef, int length, out VariableDefinition resultVd)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            resultVd = CodegenSession.GeneralHelper.CreateVariable(methodDef, PooledWriter_TypeRef);
            //If length is specified then pass in length.
            if (length > 0)
            {
                insts.Add(processor.Create(OpCodes.Ldc_I4, length));
                insts.Add(processor.Create(OpCodes.Call, WriterPool_GetWriterLength_MethodRef));
            }
            //Use parameter-less method if no length.
            else
            {
                insts.Add(processor.Create(OpCodes.Call, WriterPool_GetWriter_MethodRef));
            }
            //Set value to variable definition.
            insts.Add(processor.Create(OpCodes.Stloc, resultVd));
            return insts;
        }

        /// <summary>
        /// Calls Dispose on a PooledWriter.
        /// EG: writer.Dispose();
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="writerDefinition"></param>
        internal List<Instruction> DisposePooledWriter(MethodDefinition methodDef, VariableDefinition writerDefinition)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            insts.Add(processor.Create(OpCodes.Ldloc, writerDefinition));
            insts.Add(processor.Create(OpCodes.Callvirt, PooledWriter_Dispose_MethodRef));

            return insts;
        }

        /// <summary>
        /// Returns if typeRef supports auto packing.
        /// </summary>
        /// <param name="typeRef"></param>
        /// <returns></returns>
        internal bool IsAutoPackedType(TypeReference typeRef)
        {
            return _autoPackedMethods.Contains(typeRef);
        }

        /// <summary>
        /// Creates a null check on the second argument using a boolean.
        /// </summary>
        internal void CreateRetOnNull(ILProcessor processor, ParameterDefinition writerParameterDef, ParameterDefinition checkedParameterDef, bool useBool)
        {
            Instruction endIf = processor.Create(OpCodes.Nop);
            //If (value) jmp to endIf.
            processor.Emit(OpCodes.Ldarg, checkedParameterDef);
            processor.Emit(OpCodes.Brtrue, endIf);
            //writer.WriteBool / writer.WritePackedWhole
            if (useBool)
                CreateWriteBool(processor, writerParameterDef, true);
            else
                CreateWritePackedWhole(processor, writerParameterDef, -1);
            //Exit method.
            processor.Emit(OpCodes.Ret);
            //End of if check.
            processor.Append(endIf);
        }

        #region CreateWritePackWhole
        /// <summary>
        /// Creates a call to WritePackWhole with value.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="value"></param>
        internal void CreateWritePackedWhole(ILProcessor processor, ParameterDefinition writerParameterDef, int value)
        {
            //Create local int and set it to value.
            VariableDefinition intVariableDef = CodegenSession.GeneralHelper.CreateVariable(processor.Body.Method, typeof(int));
            CodegenSession.GeneralHelper.SetVariableDefinitionFromInt(processor, intVariableDef, value);
            //Writer.
            processor.Emit(OpCodes.Ldarg, writerParameterDef);
            //Writer.WritePackedWhole(value).
            processor.Emit(OpCodes.Ldloc, intVariableDef);
            processor.Emit(OpCodes.Conv_U8);
            processor.Emit(OpCodes.Callvirt, Writer_WritePackedWhole_MethodRef);
        }
        /// <summary>
        /// Creates a call to WritePackWhole with value.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="value"></param>
        internal void CreateWritePackedWhole(ILProcessor processor, ParameterDefinition writerParameterDef, VariableDefinition value)
        {
            //Writer.
            processor.Emit(OpCodes.Ldarg, writerParameterDef);
            //Writer.WritePackedWhole(value).
            processor.Emit(OpCodes.Ldloc, value);
            processor.Emit(OpCodes.Conv_U8);
            processor.Emit(OpCodes.Callvirt, Writer_WritePackedWhole_MethodRef);
        }
        #endregion

        /// <summary>
        /// Creates a call to WriteBoolean with value.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="writerParameterDef"></param>
        /// <param name="value"></param>
        internal void CreateWriteBool(ILProcessor processor, ParameterDefinition writerParameterDef, bool value)
        {
            MethodReference writeBoolMethodRef = GetFavoredWriteMethodReference(CodegenSession.GeneralHelper.GetTypeReference(typeof(bool)), true);
            processor.Emit(OpCodes.Ldarg, writerParameterDef);
            int intValue = (value) ? 1 : 0;
            processor.Emit(OpCodes.Ldc_I4, intValue);
            processor.Emit(OpCodes.Callvirt, writeBoolMethodRef);
        }

        /// <summary>
        /// Creates a Write call on a PooledWriter variable for parameterDef.
        /// EG: writer.WriteBool(xxxxx);
        /// </summary>
        internal List<Instruction> CreateWriteInstructions(MethodDefinition methodDef, object pooledWriterDef, ParameterDefinition valueParameterDef, MethodReference writeMethodRef)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            if (writeMethodRef != null)
            {
                if (pooledWriterDef is VariableDefinition)
                {
                    insts.Add(processor.Create(OpCodes.Ldloc, (VariableDefinition)pooledWriterDef));
                }
                else if (pooledWriterDef is ParameterDefinition)
                {
                    insts.Add(processor.Create(OpCodes.Ldarg, (ParameterDefinition)pooledWriterDef));
                }
                else
                {
                    CodegenSession.LogError($"{pooledWriterDef.GetType().FullName} is not a valid writerDef. Type must be VariableDefinition or ParameterDefinition.");
                    return new List<Instruction>();
                }
                insts.Add(processor.Create(OpCodes.Ldarg, valueParameterDef));
                //If an auto pack method then insert default value.
                if (_autoPackedMethods.Contains(valueParameterDef.ParameterType))
                {
                    AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(valueParameterDef.ParameterType);
                    insts.Add(processor.Create(OpCodes.Ldc_I4, (int)packType));
                }
                insts.Add(processor.Create(OpCodes.Call, writeMethodRef));
                return insts;
            }
            else
            {
                CodegenSession.LogError($"Writer not found for {valueParameterDef.ParameterType.FullName}.");
                return new List<Instruction>();
            }
        }
        /// <summary>
        /// Creates a Write call on a PooledWriter variable for parameterDef.
        /// EG: writer.WriteBool(xxxxx);
        /// </summary>
        internal void CreateWrite(MethodDefinition methodDef, object writerDef, ParameterDefinition valuePd, MethodReference writeMr)
        {
            List<Instruction> insts = CreateWriteInstructions(methodDef, writerDef, valuePd, writeMr);
            ILProcessor processor = methodDef.Body.GetILProcessor();
            processor.Add(insts);
        }
        /// <summary>
        /// Creates a Write call to a writer.
        /// EG: StaticClass.WriteBool(xxxxx);
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="fieldDef"></param>
        internal void CreateWrite(MethodDefinition writerMd, ParameterDefinition valuePd, FieldDefinition fieldDef, MethodReference writeMr)
        {
            if (writeMr != null)
            {
                ILProcessor processor = writerMd.Body.GetILProcessor();
                ParameterDefinition writerPd = writerMd.Parameters[0];

                FieldReference fieldRef = CodegenSession.GeneralHelper.GetFieldReference(fieldDef);
                processor.Emit(OpCodes.Ldarg, writerPd);
                processor.Emit(OpCodes.Ldarg, valuePd);
                processor.Emit(OpCodes.Ldfld, fieldRef);
                //If an auto pack method then insert default value.
                if (_autoPackedMethods.Contains(fieldDef.FieldType))
                {
                    AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(fieldDef.FieldType);
                    processor.Emit(OpCodes.Ldc_I4, (int)packType);
                }
                processor.Emit(OpCodes.Call, writeMr);
            }
            else
            {
                CodegenSession.LogError($"Writer not found for {fieldDef.FieldType.FullName}.");
            }
        }

        /// <summary>
        /// Creates a Write call to a writer.
        /// EG: StaticClass.WriteBool(xxxxx);
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="propertyDef"></param>
        internal void CreateWrite(MethodDefinition writerMd, ParameterDefinition valuePd, MethodReference getMr, MethodReference writeMr)
        {
            TypeReference returnTr = getMr.ReturnType;

            if (writeMr != null)
            {
                ILProcessor processor = writerMd.Body.GetILProcessor();
                ParameterDefinition writerPd = writerMd.Parameters[0];

                processor.Emit(OpCodes.Ldarg, writerPd);
                OpCode ldArgOC0 = (valuePd.ParameterType.IsValueType) ? OpCodes.Ldarga : OpCodes.Ldarg;
                processor.Emit(ldArgOC0, valuePd);
                processor.Emit(OpCodes.Call, getMr);
                //If an auto pack method then insert default value.
                if (_autoPackedMethods.Contains(returnTr))
                {
                    AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(returnTr);
                    processor.Emit(OpCodes.Ldc_I4, (int)packType);
                }
                processor.Emit(OpCodes.Call, writeMr);
            }
            else
            {
                CodegenSession.LogError($"Writer not found for {returnTr.FullName}.");
            }
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/ILCore/FishNetILPP.cs ---
﻿using FishNet.Broadcast;
using FishNet.CodeGenerating.Extension;
using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using FishNet.CodeGenerating.Processing;
using FishNet.Configuring;
using FishNet.Serializing.Helping;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Unity.CompilationPipeline.Common.ILPostProcessing;

namespace FishNet.CodeGenerating.ILCore
{
    public class FishNetILPP : ILPostProcessor
    {
        #region Const.
        internal const string RUNTIME_ASSEMBLY_NAME = "FishNet.Runtime";
        /// <summary>
        /// If not empty codegen will only include types within this Namespace while iterating RUNTIME_ASSEMBLY_NAME>
        /// </summary>
        //internal const string CODEGEN_THIS_NAMESPACE = "FishNet.Managing.Scened";
        internal const string CODEGEN_THIS_NAMESPACE = "";
        #endregion

        public override bool WillProcess(ICompiledAssembly compiledAssembly)
        {
            if (compiledAssembly.Name.StartsWith("Unity."))
                return false;
            if (compiledAssembly.Name.StartsWith("UnityEngine."))
                return false;
            if (compiledAssembly.Name.StartsWith("UnityEditor."))
                return false;
            if (compiledAssembly.Name.Contains("Editor"))
                return false;

            /* This line contradicts the one below where referencesFishNet
             * becomes true if the assembly is FishNetAssembly. This is here
             * intentionally to stop codegen from running on the runtime
             * fishnet assembly, but the option below is for debugging. I would
             * comment out this check if I wanted to compile fishnet runtime. */
            if (CODEGEN_THIS_NAMESPACE.Length == 0)
            {
                if (compiledAssembly.Name == RUNTIME_ASSEMBLY_NAME)
                    return false;
            }
            bool referencesFishNet = FishNetILPP.IsFishNetAssembly(compiledAssembly) || compiledAssembly.References.Any(filePath => Path.GetFileNameWithoutExtension(filePath) == RUNTIME_ASSEMBLY_NAME);
            return referencesFishNet;
        }
        public override ILPostProcessor GetInstance() => this;

        public override ILPostProcessResult Process(ICompiledAssembly compiledAssembly)
        {
            AssemblyDefinition assemblyDef = ILCoreHelper.GetAssemblyDefinition(compiledAssembly);
            if (assemblyDef == null)
                return null;
            //Check WillProcess again; somehow certain editor scripts skip the WillProcess check.
            if (!WillProcess(compiledAssembly))
                return null;
            //Resets instances of helpers and populates data needed by all helpers.
            if (!CodegenSession.Reset(assemblyDef.MainModule))
                return null;

            bool modified = false;

            if (IsFishNetAssembly(compiledAssembly))
            {
                //Not used...
                modified |= ModifyMakePublicMethods();
            }
            else
            {
                /* If one or more scripts use RPCs but don't inherit NetworkBehaviours
                 * then don't bother processing the rest. */
                if (CodegenSession.NetworkBehaviourProcessor.NonNetworkBehaviourHasInvalidAttributes(CodegenSession.Module.Types))
                    return new ILPostProcessResult(null, CodegenSession.Diagnostics);
                //before 226ms, after 17ms                   
                modified |= CreateDeclaredDelegates();
                //before 5ms, after 5ms
                modified |= CreateDeclaredSerializers();
                //before 30ms, after 26ms
                modified |= CreateIBroadcast();
                //before 140ms, after 10ms
                modified |= CreateQOLAttributes();
                //before 75ms, after 6ms
                modified |= CreateNetworkBehaviours();
                //before 260ms, after 215ms 
                modified |= CreateGenericReadWriteDelegates();
                //before 52ms, after 27ms

                //Total at once
                //before 761, after 236ms

                /* If there are warnings about SyncVars being in different assemblies.
                 * This is awful ... codegen would need to be reworked to save
                 * syncvars across all assemblies so that scripts referencing them from
                 * another assembly can have it's instructions changed. This however is an immense
                 * amount of work so it will have to be put on hold, for... a long.. long while. */
                if (CodegenSession.DifferentAssemblySyncVars.Count > 0)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.AppendLine($"Assembly {CodegenSession.Module.Name} has inherited access to SyncVars in different assemblies. When accessing SyncVars across assemblies be sure to use Get/Set methods withinin the inherited assembly script to change SyncVars. Accessible fields are:");
      
                    foreach (FieldDefinition item in CodegenSession.DifferentAssemblySyncVars)
                        sb.AppendLine($"Field {item.Name} within {item.DeclaringType.FullName} in assembly {item.Module.Name}.");

                    CodegenSession.LogWarning("v------- IMPORTANT -------v");
                    CodegenSession.LogWarning(sb.ToString());
                    CodegenSession.DifferentAssemblySyncVars.Clear();
                }
            }

            //CodegenSession.LogWarning($"Assembly {compiledAssembly.Name} took {stopwatch.ElapsedMilliseconds}.");

            if (!modified)
            {
                return null;
            }
            else
            {
                MemoryStream pe = new MemoryStream();
                MemoryStream pdb = new MemoryStream();
                WriterParameters writerParameters = new WriterParameters
                {
                    SymbolWriterProvider = new PortablePdbWriterProvider(),
                    SymbolStream = pdb,
                    WriteSymbols = true
                };
                assemblyDef.Write(pe, writerParameters);
                return new ILPostProcessResult(new InMemoryAssembly(pe.ToArray(), pdb.ToArray()), CodegenSession.Diagnostics);
            }
        }

        /// <summary>
        /// Makees methods public scope which use CodegenMakePublic attribute.
        /// </summary>
        /// <returns></returns>
        private bool ModifyMakePublicMethods()
        {
            string makePublicTypeFullName = typeof(CodegenMakePublicAttribute).FullName;
            foreach (TypeDefinition td in CodegenSession.Module.Types)
            {
                foreach (MethodDefinition md in td.Methods)
                {
                    foreach (CustomAttribute ca in md.CustomAttributes)
                    {
                        if (ca.AttributeType.FullName == makePublicTypeFullName)
                        {
                            md.Attributes &= ~MethodAttributes.Assembly;
                            md.Attributes |= MethodAttributes.Public;
                        }
                    }
                }
            }

            //There is always at least one modified.
            return true;
        }
        /// <summary>
        /// Creates delegates for user declared serializers.
        /// </summary>
        public bool CreateDeclaredDelegates()
        {
            bool modified = false;

            TypeAttributes readWriteExtensionTypeAttr = (TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Abstract);
            List<TypeDefinition> allTypeDefs = CodegenSession.Module.Types.ToList();
            foreach (TypeDefinition td in allTypeDefs)
            {
                if (CodegenSession.GeneralHelper.IgnoreTypeDefinition(td))
                    continue;

                if (td.Attributes.HasFlag(readWriteExtensionTypeAttr))
                    modified |= CodegenSession.CustomSerializerProcessor.CreateDelegates(td);
            }

            return modified;
        }

        /// <summary>
        /// Creates serializers for custom types within user declared serializers.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <param name="diagnostics"></param>
        private bool CreateDeclaredSerializers()
        {
            bool modified = false;

            TypeAttributes readWriteExtensionTypeAttr = (TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Abstract);
            List<TypeDefinition> allTypeDefs = CodegenSession.Module.Types.ToList();
            foreach (TypeDefinition td in allTypeDefs)
            {
                if (CodegenSession.GeneralHelper.IgnoreTypeDefinition(td))
                    continue;

                if (td.Attributes.HasFlag(readWriteExtensionTypeAttr))
                    modified |= CodegenSession.CustomSerializerProcessor.CreateSerializers(td);
            }

            return modified;
        }

        /// <summary>
        /// Creaters serializers and calls for IBroadcast.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <param name="diagnostics"></param>
        private bool CreateIBroadcast()
        {
            bool modified = false;

            string networkBehaviourFullName = CodegenSession.NetworkBehaviourHelper.FullName;

            HashSet<TypeDefinition> typeDefs = new HashSet<TypeDefinition>();
            foreach (TypeDefinition td in CodegenSession.Module.Types)
            {
                TypeDefinition climbTd = td;
                do
                {
                    //Reached NetworkBehaviour class.
                    if (climbTd.FullName == networkBehaviourFullName)
                        break;

                    ///* Check initial class as well all types within
                    // * the class. Then check all of it's base classes. */
                    if (climbTd.ImplementsInterface<IBroadcast>())
                        typeDefs.Add(climbTd);
                    //7ms

                    //Add nested. Only going to go a single layer deep.
                    foreach (TypeDefinition nestedTypeDef in td.NestedTypes)
                    {
                        if (nestedTypeDef.ImplementsInterface<IBroadcast>())
                            typeDefs.Add(nestedTypeDef);
                    }
                    //0ms

                    climbTd = climbTd.GetNextBaseTypeDefinition();
                    //this + name check 40ms
                } while (climbTd != null);

            }

            //Create reader/writers for found typeDefs.
            foreach (TypeDefinition td in typeDefs)
            {
                TypeReference typeRef = CodegenSession.ImportReference(td);

                bool canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(typeRef, true);
                if (!canSerialize)
                    CodegenSession.LogError($"Broadcast {td.Name} does not support serialization. Use a supported type or create a custom serializer.");
                else
                    modified = true;
            }

            return modified;
        }

        /// <summary>
        /// Handles QOLAttributes such as [Server].
        /// </summary>
        /// <returns></returns>
        private bool CreateQOLAttributes()
        {
            bool modified = false;

            bool codeStripping = false;
            
            List<TypeDefinition> allTypeDefs = CodegenSession.Module.Types.ToList();

            /* First pass, potentially only pass.
             * If code stripping them this will be run again. The first iteration
             * is to ensure things are removed in the proper order. */
            foreach (TypeDefinition td in allTypeDefs)
            {
                if (CodegenSession.GeneralHelper.IgnoreTypeDefinition(td))
                    continue;

                modified |= CodegenSession.QolAttributeProcessor.Process(td, codeStripping);
            }

            

            return modified;
        }

        /// <summary>
        /// Creates NetworkBehaviour changes.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <param name="diagnostics"></param>
        private bool CreateNetworkBehaviours()
        {
            bool modified = false;
            //Get all network behaviours to process.
            List<TypeDefinition> networkBehaviourTypeDefs = CodegenSession.Module.Types
                .Where(td => td.IsSubclassOf(CodegenSession.NetworkBehaviourHelper.FullName))
                .ToList();

            //Moment a NetworkBehaviour exist the assembly is considered modified.
            if (networkBehaviourTypeDefs.Count > 0)
                modified = true;

            /* Remove types which are inherited. This gets the child most networkbehaviours.
             * Since processing iterates all parent classes there's no reason to include them */
            RemoveInheritedTypeDefinitions(networkBehaviourTypeDefs);
            //Set how many rpcs are in children classes for each typedef.
            Dictionary<TypeDefinition, uint> inheritedRpcCounts = new Dictionary<TypeDefinition, uint>();
            SetChildRpcCounts(inheritedRpcCounts, networkBehaviourTypeDefs);
            //Set how many synctypes are in children classes for each typedef.
            Dictionary<TypeDefinition, uint> inheritedSyncTypeCounts = new Dictionary<TypeDefinition, uint>();
            SetChildSyncTypeCounts(inheritedSyncTypeCounts, networkBehaviourTypeDefs);

            /* This holds all sync types created, synclist, dictionary, var
             * and so on. This data is used after all syncvars are made so
             * other methods can look for references to created synctypes and
             * replace accessors accordingly. */
            List<(SyncType, ProcessedSync)> allProcessedSyncs = new List<(SyncType, ProcessedSync)>();
            HashSet<string> allProcessedCallbacks = new HashSet<string>();
            List<TypeDefinition> processedClasses = new List<TypeDefinition>();

            foreach (TypeDefinition typeDef in networkBehaviourTypeDefs)
            {
                CodegenSession.ImportReference(typeDef);
                //Synctypes processed for this nb and it's inherited classes.
                List<(SyncType, ProcessedSync)> processedSyncs = new List<(SyncType, ProcessedSync)>();
                CodegenSession.NetworkBehaviourProcessor.Process(typeDef, processedSyncs,
                    inheritedSyncTypeCounts, inheritedRpcCounts);
                //Add to all processed.
                allProcessedSyncs.AddRange(processedSyncs);
            }

            /* Must run through all scripts should user change syncvar
             * from outside the networkbehaviour. */
            if (allProcessedSyncs.Count > 0)
            {
                foreach (TypeDefinition td in CodegenSession.Module.Types)
                {
                    CodegenSession.NetworkBehaviourSyncProcessor.ReplaceGetSets(td, allProcessedSyncs);
                    CodegenSession.RpcProcessor.RedirectBaseCalls();
                }
            }

            /* Removes typedefinitions which are inherited by
             * another within tds. For example, if the collection
             * td contains A, B, C and our structure is
             * A : B : C then B and C will be removed from the collection
             *  Since they are both inherited by A. */
            void RemoveInheritedTypeDefinitions(List<TypeDefinition> tds)
            {
                HashSet<TypeDefinition> inheritedTds = new HashSet<TypeDefinition>();
                /* Remove any networkbehaviour typedefs which are inherited by
                 * another networkbehaviour typedef. When a networkbehaviour typedef
                 * is processed so are all of the inherited types. */
                for (int i = 0; i < tds.Count; i++)
                {
                    /* Iterates all base types and
                     * adds them to inheritedTds so long
                     * as the base type is not a NetworkBehaviour. */
                    TypeDefinition copyTd = tds[i].GetNextBaseTypeDefinition();
                    while (copyTd != null)
                    {
                        //Class is NB.
                        if (copyTd.FullName == CodegenSession.NetworkBehaviourHelper.FullName)
                            break;

                        inheritedTds.Add(copyTd);
                        copyTd = copyTd.GetNextBaseTypeDefinition();
                    }
                }

                //Remove all inherited types.
                foreach (TypeDefinition item in inheritedTds)
                    tds.Remove(item);
            }

            /* Sets how many Rpcs are within the children
             * of each typedefinition. EG: if our structure is
             * A : B : C, with the following RPC counts...
             * A 3
             * B 1
             * C 2
             * then B child rpc counts will be 3, and C will be 4. */
            void SetChildRpcCounts(Dictionary<TypeDefinition, uint> typeDefCounts, List<TypeDefinition> tds)
            {
                foreach (TypeDefinition typeDef in tds)
                {
                    //Number of RPCs found while climbing typeDef.
                    uint childCount = 0;

                    TypeDefinition copyTd = typeDef;
                    do
                    {
                        //How many RPCs are in copyTd.
                        uint copyCount = CodegenSession.RpcProcessor.GetRpcCount(copyTd);

                        /* If not found it this is the first time being
                         * processed. When this occurs set the value
                         * to 0. It will be overwritten below if baseCount
                         * is higher. */
                        uint previousCopyChildCount = 0;
                        if (!typeDefCounts.TryGetValue(copyTd, out previousCopyChildCount))
                            typeDefCounts[copyTd] = 0;
                        /* If baseCount is higher then replace count for copyTd.
                         * This can occur when a class is inherited by several types
                         * and the first processed type might only have 1 rpc, while
                         * the next has 2. This could be better optimized but to keep
                         * the code easier to read, it will stay like this. */
                        if (childCount > previousCopyChildCount)
                            typeDefCounts[copyTd] = childCount;

                        //Increase baseCount with RPCs found here.
                        childCount += copyCount;

                        copyTd = copyTd.GetNextBaseClassToProcess();
                    } while (copyTd != null);
                }

            }

            /* This performs the same functionality as SetChildRpcCounts
             * but for SyncTypes. */
            void SetChildSyncTypeCounts(Dictionary<TypeDefinition, uint> typeDefCounts, List<TypeDefinition> tds)
            {
                foreach (TypeDefinition typeDef in tds)
                {
                    //Number of RPCs found while climbing typeDef.
                    uint childCount = 0;

                    TypeDefinition copyTd = typeDef;
                    /* Iterate up to the parent script and then reverse
                     * the order. This is so that the topmost is 0
                     * and each inerhiting script adds onto that.
                     * Setting child types this way makes it so parent
                     * types don't need to have their synctype/rpc counts
                     * rebuilt when scripts are later to be found
                     * inheriting from them. */
                    List<TypeDefinition> reversedTypeDefs = new List<TypeDefinition>();
                    do
                    {
                        reversedTypeDefs.Add(copyTd);
                        copyTd = copyTd.GetNextBaseClassToProcess();
                    } while (copyTd != null);
                    reversedTypeDefs.Reverse();

                    foreach (TypeDefinition td in reversedTypeDefs)
                    {
                        //How many RPCs are in copyTd.
                        uint copyCount = CodegenSession.NetworkBehaviourSyncProcessor.GetSyncTypeCount(td);
                        /* If not found it this is the first time being
                         * processed. When this occurs set the value
                         * to 0. It will be overwritten below if baseCount
                         * is higher. */
                        uint previousCopyChildCount = 0;
                        if (!typeDefCounts.TryGetValue(td, out previousCopyChildCount))
                            typeDefCounts[td] = 0;
                        /* If baseCount is higher then replace count for copyTd.
                         * This can occur when a class is inherited by several types
                         * and the first processed type might only have 1 rpc, while
                         * the next has 2. This could be better optimized but to keep
                         * the code easier to read, it will stay like this. */
                        if (childCount > previousCopyChildCount)
                            typeDefCounts[td] = childCount;
                        //Increase baseCount with RPCs found here.
                        childCount += copyCount;
                    }
                }
            }

            return modified;
        }

        /// <summary>
        /// Creates generic delegates for all read and write methods.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <param name="diagnostics"></param>
        private bool CreateGenericReadWriteDelegates()
        {
            bool modified = false;
            modified |= CodegenSession.WriterHelper.CreateGenericDelegates();
            modified |= CodegenSession.ReaderHelper.CreateGenericDelegates();

            return modified;
        }

        internal static bool IsFishNetAssembly(ICompiledAssembly assembly) => (assembly.Name == FishNetILPP.RUNTIME_ASSEMBLY_NAME);
        internal static bool IsFishNetAssembly() => (CodegenSession.Module.Assembly.Name.Name == FishNetILPP.RUNTIME_ASSEMBLY_NAME);
        internal static bool IsFishNetAssembly(ModuleDefinition moduleDef) => (moduleDef.Assembly.Name.Name == FishNetILPP.RUNTIME_ASSEMBLY_NAME);

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/ILCore/ILCoreHelper.cs ---
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System.IO;
using Unity.CompilationPipeline.Common.ILPostProcessing;

namespace FishNet.CodeGenerating.ILCore
{
    internal static class ILCoreHelper
    {

        /// <summary>
        /// Returns AssembleDefinition for compiledAssembly.
        /// </summary>
        /// <param name="compiledAssembly"></param>
        /// <returns></returns>
        internal static AssemblyDefinition GetAssemblyDefinition(ICompiledAssembly compiledAssembly)
        {
            PostProcessorAssemblyResolver assemblyResolver = new PostProcessorAssemblyResolver(compiledAssembly);
            ReaderParameters readerParameters = new ReaderParameters
            {
                SymbolStream = new MemoryStream(compiledAssembly.InMemoryAssembly.PdbData),
                SymbolReaderProvider = new PortablePdbReaderProvider(),
                AssemblyResolver = assemblyResolver,
                ReflectionImporterProvider = new PostProcessorReflectionImporterProvider(),
                ReadingMode = ReadingMode.Immediate
            };

            AssemblyDefinition assemblyDefinition = AssemblyDefinition.ReadAssembly(new MemoryStream(compiledAssembly.InMemoryAssembly.PeData), readerParameters);
            //Allows us to resolve inside FishNet assembly, such as for components.
            assemblyResolver.AddAssemblyDefinitionBeingOperatedOn(assemblyDefinition);

            return assemblyDefinition;
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/ILCore/PostProcessorAssemblyResolver.cs ---
using MonoFN.Cecil;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using Unity.CompilationPipeline.Common.ILPostProcessing;

namespace FishNet.CodeGenerating
{
    internal class PostProcessorAssemblyResolver : IAssemblyResolver
    {
        private readonly string[] m_AssemblyReferences;
        private readonly Dictionary<string, AssemblyDefinition> m_AssemblyCache = new Dictionary<string, AssemblyDefinition>();
        private readonly ICompiledAssembly m_CompiledAssembly;
        private AssemblyDefinition m_SelfAssembly;

        public PostProcessorAssemblyResolver(ICompiledAssembly compiledAssembly)
        {
            m_CompiledAssembly = compiledAssembly;
            m_AssemblyReferences = compiledAssembly.References;
        }

        public void Dispose() { }

        public AssemblyDefinition Resolve(AssemblyNameReference name) => Resolve(name, new ReaderParameters(ReadingMode.Deferred));

        public AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
        {
            lock (m_AssemblyCache)
            {
                if (name.Name == m_CompiledAssembly.Name)
                {
                    return m_SelfAssembly;
                }

                var fileName = FindFile(name);
                if (fileName == null)
                {
                    return null;
                }

                var lastWriteTime = File.GetLastWriteTime(fileName);
                var cacheKey = $"{fileName}{lastWriteTime}";
                if (m_AssemblyCache.TryGetValue(cacheKey, out var result))
                {
                    return result;
                }

                parameters.AssemblyResolver = this;

                var ms = MemoryStreamFor(fileName);
                var pdb = $"{fileName}.pdb";
                if (File.Exists(pdb))
                {
                    parameters.SymbolStream = MemoryStreamFor(pdb);
                }

                var assemblyDefinition = AssemblyDefinition.ReadAssembly(ms, parameters);
                m_AssemblyCache.Add(cacheKey, assemblyDefinition);

                return assemblyDefinition;
            }
        }

        private string FindFile(AssemblyNameReference name)
        {
            var fileName = m_AssemblyReferences.FirstOrDefault(r => Path.GetFileName(r) == $"{name.Name}.dll");
            if (fileName != null)
            {
                return fileName;
            }

            // perhaps the type comes from an exe instead
            fileName = m_AssemblyReferences.FirstOrDefault(r => Path.GetFileName(r) == $"{name.Name}.exe");
            if (fileName != null)
            {
                return fileName;
            }

            //Unfortunately the current ICompiledAssembly API only provides direct references.
            //It is very much possible that a postprocessor ends up investigating a type in a directly
            //referenced assembly, that contains a field that is not in a directly referenced assembly.
            //if we don't do anything special for that situation, it will fail to resolve.  We should fix this
            //in the ILPostProcessing API. As a workaround, we rely on the fact here that the indirect references
            //are always located next to direct references, so we search in all directories of direct references we
            //got passed, and if we find the file in there, we resolve to it.
            return m_AssemblyReferences
                .Select(Path.GetDirectoryName)
                .Distinct()
                .Select(parentDir => Path.Combine(parentDir, $"{name.Name}.dll"))
                .FirstOrDefault(File.Exists);
        }

        private static MemoryStream MemoryStreamFor(string fileName)
        {
            return Retry(10, TimeSpan.FromSeconds(1), () =>
            {
                byte[] byteArray;
                using (var fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    byteArray = new byte[fs.Length];
                    var readLength = fs.Read(byteArray, 0, (int)fs.Length);
                    if (readLength != fs.Length)
                    {
                        throw new InvalidOperationException("File read length is not full length of file.");
                    }
                }

                return new MemoryStream(byteArray);
            });
        }

        private static MemoryStream Retry(int retryCount, TimeSpan waitTime, Func<MemoryStream> func)
        {
            try
            {
                return func();
            }
            catch (IOException)
            {
                if (retryCount == 0)
                {
                    throw;
                }

                Console.WriteLine($"Caught IO Exception, trying {retryCount} more times");
                Thread.Sleep(waitTime);

                return Retry(retryCount - 1, waitTime, func);
            }
        }

        public void AddAssemblyDefinitionBeingOperatedOn(AssemblyDefinition assemblyDefinition)
        {
            m_SelfAssembly = assemblyDefinition;
        }
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/ILCore/PostProcessorReflectionImporter.cs ---
﻿using MonoFN.Cecil;
using System.Linq;
using System.Reflection;

namespace FishNet.CodeGenerating.ILCore
{
    internal class PostProcessorReflectionImporter : DefaultReflectionImporter
    {
        private const string k_SystemPrivateCoreLib = "System.Private.CoreLib";
        private readonly AssemblyNameReference m_CorrectCorlib;

        public PostProcessorReflectionImporter(ModuleDefinition module) : base(module)
        {
            m_CorrectCorlib = module.AssemblyReferences.FirstOrDefault(a => a.Name == "mscorlib" || a.Name == "netstandard" || a.Name == k_SystemPrivateCoreLib);
        }

        public override AssemblyNameReference ImportReference(AssemblyName reference)
        {
            return m_CorrectCorlib != null && reference.Name == k_SystemPrivateCoreLib ? m_CorrectCorlib : base.ImportReference(reference);
        }
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/ILCore/PostProcessorReflectionImporterProvider.cs ---
﻿using MonoFN.Cecil;

namespace FishNet.CodeGenerating.ILCore
{
    internal class PostProcessorReflectionImporterProvider : IReflectionImporterProvider
    {
        public IReflectionImporter GetReflectionImporter(ModuleDefinition moduleDef)
        {
            return new PostProcessorReflectionImporter(moduleDef);
        }
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/CustomSerializerProcessor.cs ---
﻿
using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Serializing;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.CodeGenerating.Processing
{
    internal class CustomSerializerProcessor
    {

        #region Types.
        internal enum ExtensionType
        {
            None,
            Write,
            Read
        }

        #endregion

        internal bool CreateDelegates(TypeDefinition typeDef)
        {
            bool modified = false;

            /* Find all declared methods and register delegates to them.
             * After they are all registered create any custom writers
             * needed to complete the declared methods. It's important to
             * make generated writers after so that a generated method
             * isn't made for a type when the user has already made a declared one. */
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                ExtensionType extensionType = GetExtensionType(methodDef);
                if (extensionType == ExtensionType.None)
                    continue;
                if (CodegenSession.GeneralHelper.CodegenExclude(methodDef))
                    continue;

                MethodReference methodRef = CodegenSession.ImportReference(methodDef);
                if (extensionType == ExtensionType.Write)
                {
                    CodegenSession.WriterHelper.AddWriterMethod(methodRef.Parameters[1].ParameterType, methodRef, false, true);
                    modified = true;
                }
                else if (extensionType == ExtensionType.Read)
                {
                    CodegenSession.ReaderHelper.AddReaderMethod(methodRef.ReturnType, methodRef, false, true);
                    modified = true;
                }
            }

            return modified;
        }

        /// <summary>
        /// Creates serializers for any custom types for declared methods.
        /// </summary>
        /// <param name="declaredMethods"></param>
        /// <param name="moduleDef"></param>
        internal bool CreateSerializers(TypeDefinition typeDef)
        {
            bool modified = false;

            List<(MethodDefinition, ExtensionType)> declaredMethods = new List<(MethodDefinition, ExtensionType)>();
            /* Go through all custom serializers again and see if 
             * they use any types that the user didn't make a serializer for
             * and that there isn't a built-in type for. Create serializers
             * for these types. */
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                ExtensionType extensionType = GetExtensionType(methodDef);
                if (extensionType == ExtensionType.None)
                    continue;
                if (CodegenSession.GeneralHelper.CodegenExclude(methodDef))
                    continue;
                 
                declaredMethods.Add((methodDef, extensionType));
                modified = true;
            }
            //Now that all declared are loaded see if any of them need generated serializers.
            foreach ((MethodDefinition methodDef, ExtensionType extensionType) in declaredMethods)
                CreateSerializers(extensionType, methodDef);

            return modified;
        }

        /// <summary>
        /// Creates a custom serializer for any types not handled within users declared.
        /// </summary>
        /// <param name="extensionType"></param>
        /// <param name="moduleDef"></param>
        /// <param name="methodDef"></param>
        /// <param name="diagnostics"></param>
        private void CreateSerializers(ExtensionType extensionType, MethodDefinition methodDef)
        {
            for (int i = 0; i < methodDef.Body.Instructions.Count; i++)
                CheckToModifyInstructions(extensionType, methodDef, ref i);
        }

        /// <summary>
        /// Checks if instructions need to be modified and does so.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="instructionIndex"></param>
        private void CheckToModifyInstructions(ExtensionType extensionType, MethodDefinition methodDef, ref int instructionIndex)
        {
            Instruction instruction = methodDef.Body.Instructions[instructionIndex];
            //Fields.
            if (instruction.OpCode == OpCodes.Ldsfld || instruction.OpCode == OpCodes.Ldfld)
                CheckFieldReferenceInstruction(extensionType, methodDef, ref instructionIndex);
            //Method calls.
            else if (instruction.OpCode == OpCodes.Call || instruction.OpCode == OpCodes.Callvirt)
                CheckCallInstruction(extensionType, methodDef, ref instructionIndex, (MethodReference)instruction.Operand);
        }

        /// <summary>
        /// Checks if a reader or writer must be generated for a field type.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="instructionIndex"></param>
        private void CheckFieldReferenceInstruction(ExtensionType extensionType, MethodDefinition methodDef, ref int instructionIndex)
        {
            Instruction instruction = methodDef.Body.Instructions[instructionIndex];
            FieldReference field = (FieldReference)instruction.Operand;
            TypeReference type = field.DeclaringType;

            if (type.IsType(typeof(GenericWriter<>)) || type.IsType(typeof(GenericReader<>)) && type.IsGenericInstance)
            {
                GenericInstanceType typeGenericInst = (GenericInstanceType)type;
                TypeReference parameterType = typeGenericInst.GenericArguments[0];
                CreateReaderOrWriter(extensionType, methodDef, ref instructionIndex, parameterType);
            }
        }

        /// <summary>
        /// Checks if a reader or writer must be generated for a call type.
        /// </summary>
        /// <param name="extensionType"></param>
        /// <param name="moduleDef"></param>
        /// <param name="methodDef"></param>
        /// <param name="instructionIndex"></param>
        /// <param name="method"></param>
        private void CheckCallInstruction(ExtensionType extensionType, MethodDefinition methodDef, ref int instructionIndex, MethodReference method)
        {
            if (!method.IsGenericInstance)
                return;

            //True if call is to read/write.
            bool canCreate = (
                method.Is<Writer>(nameof(Writer.Write)) ||
                method.Is<Reader>(nameof(Reader.Read))
                );

            if (canCreate)
            {
                GenericInstanceMethod instanceMethod = (GenericInstanceMethod)method;
                TypeReference parameterType = instanceMethod.GenericArguments[0];
                if (parameterType.IsGenericParameter)
                    return;

                CreateReaderOrWriter(extensionType, methodDef, ref instructionIndex, parameterType);
            }
        }

        /// <summary>
        /// Creates a reader or writer for parameterType.
        /// </summary>
        /// <param name="extensionType"></param>
        /// <param name="methodDef"></param>
        /// <param name="instructionIndex"></param>
        /// <param name="parameterType"></param>
        private void CreateReaderOrWriter(ExtensionType extensionType, MethodDefinition methodDef, ref int instructionIndex, TypeReference parameterType)
        {
            if (!parameterType.IsGenericParameter && parameterType.CanBeResolved())
            {
                TypeDefinition typeDefinition = parameterType.CachedResolve();
                //If class and not value type check for accessible constructor.
                if (typeDefinition.IsClass && !typeDefinition.IsValueType)
                {
                    MethodDefinition constructor = typeDefinition.GetMethod(".ctor");
                    //Constructor is inaccessible, cannot create serializer for type.
                    if (!constructor.IsPublic)
                    {
                        CodegenSession.LogError($"Unable to generator serializers for {typeDefinition.FullName} because it's constructor is not public.");
                        return;
                    }
                }

                ILProcessor processor = methodDef.Body.GetILProcessor();

                //Find already existing read or write method.
                MethodReference createdMethodRef = (extensionType == ExtensionType.Write) ?
                    CodegenSession.WriterHelper.GetFavoredWriteMethodReference(parameterType, true) :
                    CodegenSession.ReaderHelper.GetFavoredReadMethodReference(parameterType, true);
                //If a created method already exist nothing further is required.
                if (createdMethodRef != null)
                {
                    //Replace call to generic with already made serializer.
                    Instruction newInstruction = processor.Create(OpCodes.Call, createdMethodRef);
                    methodDef.Body.Instructions[instructionIndex] = newInstruction;
                    return;
                }
                else
                {
                    createdMethodRef = (extensionType == ExtensionType.Write) ?
                        CodegenSession.WriterGenerator.CreateWriter(parameterType) :
                        CodegenSession.ReaderGenerator.CreateReader(parameterType);
                }

                //If method was created.
                if (createdMethodRef != null)
                {
                    /* If an autopack type then we have to inject the
                     * autopack above the new instruction. */
                    if (CodegenSession.WriterHelper.IsAutoPackedType(parameterType))
                    {
                        AutoPackType packType = CodegenSession.GeneralHelper.GetDefaultAutoPackType(parameterType);
                        Instruction autoPack = processor.Create(OpCodes.Ldc_I4, (int)packType);
                        methodDef.Body.Instructions.Insert(instructionIndex, autoPack);
                        instructionIndex++;
                    }
                    Instruction newInstruction = processor.Create(OpCodes.Call, createdMethodRef);
                    methodDef.Body.Instructions[instructionIndex] = newInstruction;
                }
            }
        }

        /// <summary>
        /// Returns the RPC attribute on a method, if one exist. Otherwise returns null.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <returns></returns>
        private ExtensionType GetExtensionType(MethodDefinition methodDef)
        {
            bool hasExtensionAttribute = methodDef.HasCustomAttribute<System.Runtime.CompilerServices.ExtensionAttribute>();
            if (!hasExtensionAttribute)
                return ExtensionType.None;

            bool write = (methodDef.ReturnType == methodDef.Module.TypeSystem.Void);

            //Return None for Mirror types.
#if MIRROR
            if (write)
            {
                if (methodDef.Parameters.Count > 0 && methodDef.Parameters[0].ParameterType.FullName == "Mirror.NetworkWriter")
                    return ExtensionType.None;                    
            }
            else
            {
                if (methodDef.Parameters.Count > 0 && methodDef.Parameters[0].ParameterType.FullName == "Mirror.NetworkReader")
                    return ExtensionType.None;
            }
#endif

            string prefix = (write) ?
                WriterHelper.WRITE_PREFIX : ReaderHelper.READ_PREFIX;

            //Does not contain prefix.
            if (methodDef.Name.Length < prefix.Length || methodDef.Name.Substring(0, prefix.Length) != prefix)
                return ExtensionType.None;

            //Make sure first parameter is right.
            if (methodDef.Parameters.Count >= 1)
            {
                TypeReference tr = methodDef.Parameters[0].ParameterType;
                if (tr.FullName != CodegenSession.WriterHelper.Writer_TypeRef.FullName &&
                    tr.FullName != CodegenSession.ReaderHelper.Reader_TypeRef.FullName)
                    return ExtensionType.None;
            }

            if (write && methodDef.Parameters.Count < 2)
            {
                CodegenSession.LogError($"{methodDef.FullName} must have at least two parameters, the first being PooledWriter, and second value to write.");
                return ExtensionType.None;
            }
            else if (!write && methodDef.Parameters.Count < 1)
            {
                CodegenSession.LogError($"{methodDef.FullName} must have at least one parameters, the first being PooledReader.");
                return ExtensionType.None;
            }

            return (write) ? ExtensionType.Write : ExtensionType.Read;
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/NetworkBehaviourPredictionProcessor.cs ---
﻿using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Rocks;
using System.Collections.Generic;
using UnityEngine;
using SR = System.Reflection;

namespace FishNet.CodeGenerating.Processing
{
    internal class NetworkBehaviourPredictionProcessor
    {

        #region Types.
        private enum InsertType
        {
            First,
            Last,
            Current
        }

        private class CreatedPredictionFields
        {
            /// <summary>
            /// Replicate data buffered on the server.
            /// </summary>
            public readonly FieldReference ServerReplicateDatas;
            /// <summary>
            /// Replicate data buffered on the client.
            /// </summary>
            public readonly FieldReference ClientReplicateDatas;
            /// <summary>
            /// Last reconcile data received from the server.
            /// </summary>
            public readonly FieldReference ReconcileData;
            /// <summary>
            /// Last tick on data server replicated.
            /// </summary>
            public readonly FieldReference ServerReplicateTick;
            /// <summary>
            /// How many remaining ticks server can resend reconcile.
            /// </summary>
            public readonly FieldReference ServerReconcileResends;
            /// <summary>
            /// How many remaining ticks client can resend input.
            /// </summary>
            public readonly FieldReference ClientReplicateResends;
            /// <summary>
            /// True if client has data to reconcile with.
            /// </summary>
            public readonly FieldReference ClientHasReconcileData;
            /// <summary>
            /// True if client is replaying data.
            /// </summary>
            public readonly FieldReference ClientReplayingData;
            /// <summary>
            /// Last tick on a reconcile client received.
            /// </summary>
            public readonly FieldReference ClientReconcileTick;
            /// <summary>
            /// Last tick client sent new data.
            /// </summary>
            public readonly FieldReference ClientReplicateTick;
            /// <summary>
            /// Last tick on data received from client.
            /// </summary>
            public readonly FieldReference ServerReceivedTick;
            /// <summary>
            /// A buffer to read replicates into.
            /// </summary>
            public readonly FieldReference ServerReplicateReaderBuffer;

            public CreatedPredictionFields(FieldReference serverReplicateDatas, FieldReference clientReplicateDatas, FieldReference reconcileData, FieldReference serverReplicateTick,
                FieldReference serverReconcileResends, FieldReference clientReplicateResends, FieldReference clientHasReconcileData, FieldReference clientReplayingData,
                FieldReference clientReconcileTick, FieldReference clientReplicateTick, FieldReference serverReceivedTick, FieldReference serverReplicateReaderBuffer)
            {
                ServerReplicateDatas = serverReplicateDatas;
                ClientReplicateDatas = clientReplicateDatas;
                ReconcileData = reconcileData;
                ServerReplicateTick = serverReplicateTick;
                ServerReconcileResends = serverReconcileResends;
                ClientReplicateResends = clientReplicateResends;
                ClientHasReconcileData = clientHasReconcileData;
                ClientReplayingData = clientReplayingData;
                ClientReconcileTick = clientReconcileTick;
                ClientReplicateTick = clientReplicateTick;
                ServerReceivedTick = serverReceivedTick;
                ServerReplicateReaderBuffer = serverReplicateReaderBuffer;
            }
        }

        private class PredictionReaders
        {
            public MethodReference ReplicateReader;
            public MethodReference ReconcileReader;

            public PredictionReaders(MethodReference replicateReader, MethodReference reconcileReader)
            {
                ReplicateReader = replicateReader;
                ReconcileReader = reconcileReader;
            }
        }

        #endregion

        #region Private
        private MethodReference Unity_GetGameObject_MethodRef;
        private MethodReference Unity_GetScene_MethodRef;
        private MethodReference Unity_GetPhysicsScene2D_MethodRef;
        private MethodReference Unity_GetPhysicsScene3D_MethodRef;
        private MethodReference Physics3D_Simulate_MethodRef;
        private MethodReference Physics2D_Simulate_MethodRef;
        private MethodReference Physics3D_SyncTransforms_MethodRef;
        private MethodReference Physics2D_SyncTransforms_MethodRef;

        private FieldReference ReplicateData_Tick_FieldRef;
        private FieldReference ReconcileData_Tick_FieldRef;

        private string ClearReplicateCache_Method_Name;
        #endregion

        #region Const.
        private const string REPLICATE_LOGIC_PREFIX = "ReplicateLogic___";
        private const string REPLICATE_READER_PREFIX = "ReplicateReader___";
        private const string RECONCILE_LOGIC_PREFIX = "ReconcileLogic___";
        private const string RECONCILE_READER_PREFIX = "ReconcileReader___";
        private const string DATA_TICK_FIELD_NAME = "Generated___Tick";
        private static readonly OpCode RESEND_COUNT_OPCODE = OpCodes.Ldc_I4_3;
        #endregion

        internal bool ImportReferences()
        {
            SR.MethodInfo locMi;

            ClearReplicateCache_Method_Name = nameof(NetworkBehaviour.InternalClearReplicateCache);

            //GetGameObject.
            locMi = typeof(UnityEngine.Component).GetMethod("get_gameObject");
            Unity_GetGameObject_MethodRef = CodegenSession.ImportReference(locMi);
            //GetScene.
            locMi = typeof(UnityEngine.GameObject).GetMethod("get_scene");
            Unity_GetScene_MethodRef = CodegenSession.ImportReference(locMi);

            //Physics.SyncTransform.
            foreach (SR.MethodInfo mi in typeof(Physics).GetMethods())
            {
                if (mi.Name == nameof(Physics.SyncTransforms))
                {
                    Physics3D_SyncTransforms_MethodRef = CodegenSession.ImportReference(mi);
                    break;
                }
            }
            foreach (SR.MethodInfo mi in typeof(Physics2D).GetMethods())
            {
                if (mi.Name == nameof(Physics2D.SyncTransforms))
                {
                    Physics2D_SyncTransforms_MethodRef = CodegenSession.ImportReference(mi);
                    break;
                }
            }

            //PhysicsScene.Simulate.
            foreach (SR.MethodInfo mi in typeof(PhysicsScene).GetMethods())
            {
                if (mi.Name == nameof(PhysicsScene.Simulate))
                {
                    Physics3D_Simulate_MethodRef = CodegenSession.ImportReference(mi);
                    break;
                }
            }
            foreach (SR.MethodInfo mi in typeof(PhysicsScene2D).GetMethods())
            {
                if (mi.Name == nameof(PhysicsScene2D.Simulate))
                {
                    Physics2D_Simulate_MethodRef = CodegenSession.ImportReference(mi);
                    break;
                }
            }

            //GetPhysicsScene.
            foreach (SR.MethodInfo mi in typeof(PhysicsSceneExtensions).GetMethods())
            {
                if (mi.Name == nameof(PhysicsSceneExtensions.GetPhysicsScene))
                {
                    Unity_GetPhysicsScene3D_MethodRef = CodegenSession.ImportReference(mi);
                    break;
                }
            }
            foreach (SR.MethodInfo mi in typeof(PhysicsSceneExtensions2D).GetMethods())
            {
                if (mi.Name == nameof(PhysicsSceneExtensions2D.GetPhysicsScene2D))
                {
                    Unity_GetPhysicsScene2D_MethodRef = CodegenSession.ImportReference(mi);
                    break;
                }
            }

            return true;
        }

        internal bool Process(TypeDefinition typeDef, ref uint rpcCount)
        {
            bool modified = false;
            modified |= ProcessLocal(typeDef, ref rpcCount);

            return modified;
        }

        #region Setup and checks.
        /// <summary>
        /// Gets number of predictions by checking for prediction attributes. This does not perform error checking.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal uint GetPredictionCount(TypeDefinition typeDef)
        {
            /* Currently only one prediction method is allowed per typeDef.
             * Return 1 soon as a method is found. */
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                foreach (CustomAttribute customAttribute in methodDef.CustomAttributes)
                {
                    if (customAttribute.Is(CodegenSession.AttributeHelper.ReplicateAttribute_FullName))
                        return 1;
                }
            }

            return 0;
        }

        /// <summary>
        /// Ensures only one prediction and reconile method exist per typeDef, and outputs finding.
        /// </summary>
        /// <returns>True if there is only one set of prediction methods. False if none, or more than one set.</returns>
        internal bool GetPredictionMethods(TypeDefinition typeDef, out MethodDefinition replicateMd, out MethodDefinition reconcileMd)
        {
            replicateMd = null;
            reconcileMd = null;

            bool error = false;
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                foreach (CustomAttribute customAttribute in methodDef.CustomAttributes)
                {
                    if (customAttribute.Is(CodegenSession.AttributeHelper.ReplicateAttribute_FullName))
                    {
                        if (!MethodIsPrivate(methodDef) || AlreadyFound(replicateMd))
                            error = true;
                        else
                            replicateMd = methodDef;
                    }
                    else if (customAttribute.Is(CodegenSession.AttributeHelper.ReconcileAttribute_FullName))
                    {
                        if (!MethodIsPrivate(methodDef) || AlreadyFound(reconcileMd))
                            error = true;
                        else
                            reconcileMd = methodDef;
                    }
                    if (error)
                        break;
                }
                if (error)
                    break;
            }

            bool MethodIsPrivate(MethodDefinition md)
            {
                bool isPrivate = md.Attributes.HasFlag(MethodAttributes.Private);
                if (!isPrivate)
                    CodegenSession.LogError($"Method {md.Name} within {typeDef.Name} is a prediction method and must be private.");
                return isPrivate;
            }

            bool AlreadyFound(MethodDefinition md)
            {
                bool alreadyFound = (md != null);
                if (alreadyFound)
                    CodegenSession.LogError($"{typeDef.Name} contains multiple prediction sets; currently only one set is allowed.");

                return alreadyFound;
            }

            if (!error && ((replicateMd == null) != (reconcileMd == null)))
            {
                CodegenSession.LogError($"{typeDef.Name} must contain both a [Replicate] and [Reconcile] method when using prediction.");
                error = true;
            }

            if (error || (replicateMd == null) || (reconcileMd == null))
                return false;
            else
                return true;
        }
        #endregion

        private bool ProcessLocal(TypeDefinition typeDef, ref uint rpcCount)
        {
            MethodDefinition replicateMd;
            MethodDefinition reconcileMd;

            //Not using prediction methods.
            if (!GetPredictionMethods(typeDef, out replicateMd, out reconcileMd))
                return false;

            //If replication methods found but this hierarchy already has max.
            if (rpcCount >= NetworkBehaviourHelper.MAX_RPC_ALLOWANCE)
            {
                CodegenSession.LogError($"{typeDef.FullName} and inherited types exceed {NetworkBehaviourHelper.MAX_RPC_ALLOWANCE} replicated methods. Only {NetworkBehaviourHelper.MAX_RPC_ALLOWANCE} replicated methods are supported per inheritance hierarchy.");
                return false;
            }

            bool parameterError = false;
            parameterError |= HasParameterError(replicateMd, typeDef, true);
            parameterError |= HasParameterError(reconcileMd, typeDef, false);
            if (parameterError)
                return false;

            //Add field to replicate/reconcile datas, which stores tick of data.
            TypeDefinition replicateDataTd = replicateMd.Parameters[0].ParameterType.CachedResolve();
            TypeDefinition reconcileDataTd = reconcileMd.Parameters[0].ParameterType.CachedResolve();
            AddTickFieldToDatas(replicateMd.Parameters[0].ParameterType.CachedResolve(), reconcileMd.Parameters[0].ParameterType.CachedResolve());
            /* Make sure data can serialize. Use array type, this will
             * generate a serializer for element type as well. */
            bool canSerialize;
            //Make sure replicate data can serialize.
            canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(replicateDataTd.MakeArrayType(), true);
            if (!canSerialize)
            {
                CodegenSession.LogError($"Replicate data type {replicateDataTd.Name} does not support serialization. Use a supported type or create a custom serializer.");
                return false;
            }
            //Make sure reconcile data can serialize.
            canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(reconcileDataTd, true);
            if (!canSerialize)
            {
                CodegenSession.LogError($"Reconcile data type {reconcileDataTd.Name} does not support serialization. Use a supported type or create a custom serializer.");
                return false;
            }
            //Creates fields for buffers.
            CreatedPredictionFields predictionFields;
            CreateFields(typeDef, replicateMd, reconcileMd, out predictionFields);

            PredictionReaders predictionReaders;
            CreatePredictionMethods(typeDef, replicateMd, reconcileMd, predictionFields, rpcCount, out predictionReaders);

            InitializeCollections(typeDef, replicateMd, predictionFields);
            RegisterRpcs(typeDef, rpcCount, predictionReaders);

            rpcCount++;
            return true;
        }

        /// <summary>
        /// Registers RPCs that prediction uses.
        /// </summary>
        private void RegisterRpcs(TypeDefinition typeDef, uint hash, PredictionReaders readers)
        {
            MethodDefinition injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            ILProcessor processor = injectionMethodDef.Body.GetILProcessor();
            List<Instruction> insts = new List<Instruction>();

            Register(readers.ReplicateReader.CachedResolve(), true);
            Register(readers.ReconcileReader.CachedResolve(), false);

            void Register(MethodDefinition readerMd, bool replicate)
            {
                insts.Add(processor.Create(OpCodes.Ldarg_0));
                insts.Add(processor.Create(OpCodes.Ldc_I4, (int)hash));
                /* Create delegate and call NetworkBehaviour method. */
                insts.Add(processor.Create(OpCodes.Ldnull));
                insts.Add(processor.Create(OpCodes.Ldftn, readerMd));

                MethodReference ctorMr;
                MethodReference callMr;
                if (replicate)
                {
                    ctorMr = CodegenSession.NetworkBehaviourHelper.ReplicateRpcDelegateConstructor_MethodRef;
                    callMr = CodegenSession.NetworkBehaviourHelper.RegisterReplicateRpc_MethodRef;
                }
                else
                {
                    ctorMr = CodegenSession.NetworkBehaviourHelper.ReconcileRpcDelegateConstructor_MethodRef;
                    callMr = CodegenSession.NetworkBehaviourHelper.RegisterReconcileRpc_MethodRef;
                }

                insts.Add(processor.Create(OpCodes.Newobj, ctorMr));
                insts.Add(processor.Create(OpCodes.Call, callMr));
            }

            processor.InsertLast(insts);

        }

        /// <summary>
        /// Initializes collection fields made during this process.
        /// </summary>
        /// <param name="predictionFields"></param>
        private void InitializeCollections(TypeDefinition typeDef, MethodDefinition replicateMd, CreatedPredictionFields predictionFields)
        {
            TypeReference replicateDataTr = replicateMd.Parameters[0].ParameterType;
            MethodDefinition injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            ILProcessor processor = injectionMethodDef.Body.GetILProcessor();

            Generate(predictionFields.ClientReplicateDatas, true);
            Generate(predictionFields.ServerReplicateDatas, false);

            void Generate(FieldReference fr, bool isList)
            {
                MethodDefinition ctorMd = CodegenSession.GeneralHelper.List_TypeRef.CachedResolve().GetConstructor();
                GenericInstanceType collectionGit;
                if (isList)
                    GetGenericLists(replicateDataTr, out collectionGit);
                else
                    GetGenericQueues(replicateDataTr, out collectionGit);
                MethodReference ctorMr = ctorMd.MakeHostInstanceGeneric(collectionGit);

                List<Instruction> insts = new List<Instruction>();

                insts.Add(processor.Create(OpCodes.Ldarg_0));
                insts.Add(processor.Create(OpCodes.Newobj, ctorMr));
                insts.Add(processor.Create(OpCodes.Stfld, fr));
                processor.InsertFirst(insts);
            }

        }

        /// <summary>
        /// Creates field buffers for replicate datas.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="replicateMd"></param>
        /// <param name=""></param>
        /// <returns></returns>
        private void CreateFields(TypeDefinition typeDef, MethodDefinition replicateMd, MethodDefinition reconcileMd, out CreatedPredictionFields predictionFields)
        {
            TypeReference replicateDataTr = replicateMd.Parameters[0].ParameterType;
            TypeReference replicateDataArrTr = replicateDataTr.MakeArrayType();
            TypeReference reconcileDataTr = reconcileMd.Parameters[0].ParameterType;
            TypeReference uintTr = CodegenSession.GeneralHelper.GetTypeReference(typeof(uint));
            TypeReference boolTr = CodegenSession.GeneralHelper.GetTypeReference(typeof(bool));

            GenericInstanceType lstDataGit;
            GenericInstanceType queueDataGit;
            GetGenericLists(replicateDataTr, out lstDataGit);
            GetGenericQueues(replicateDataTr, out queueDataGit);

            /* Data buffer. */
            FieldDefinition serverReplicatesFd = new FieldDefinition($"{replicateMd.Name}___serverReplicates", FieldAttributes.Private, queueDataGit);
            FieldDefinition clientReplicatesFd = new FieldDefinition($"{replicateMd.Name}___clientReplicates", FieldAttributes.Private, lstDataGit);
            FieldDefinition clientReconcileFd = new FieldDefinition($"{replicateMd.Name}___clientReconcile", FieldAttributes.Private, reconcileDataTr);
            FieldDefinition serverReplicateTickFd = new FieldDefinition($"{replicateMd.Name}___serverReplicateTick", FieldAttributes.Private, uintTr);
            FieldDefinition serverReconcileResendsFd = new FieldDefinition($"{replicateMd.Name}___serverReconcileResends", FieldAttributes.Private, uintTr);
            FieldDefinition clientReplicateResendsFd = new FieldDefinition($"{replicateMd.Name}___clientReplicateResends", FieldAttributes.Private, uintTr);
            FieldDefinition clientHasReconcileDataFd = new FieldDefinition($"{replicateMd.Name}___clientHasReconcileData", FieldAttributes.Private, boolTr);
            FieldDefinition clientReplayingDataaFd = new FieldDefinition($"{replicateMd.Name}___clientReplayingData", FieldAttributes.Private, boolTr);
            FieldDefinition clientReconcileTickFd = new FieldDefinition($"{replicateMd.Name}___clientReconcileTick", FieldAttributes.Private, uintTr);
            FieldDefinition clientReplicateTickFd = new FieldDefinition($"{replicateMd.Name}___clientReplicateTick", FieldAttributes.Private, uintTr);
            FieldDefinition serverReceivedTickFd = new FieldDefinition($"{replicateMd.Name}___serverReceivedTick", FieldAttributes.Private, uintTr);
            FieldDefinition serverReplicatesReadBufferFd = new FieldDefinition($"{replicateMd.Name}___serverReplicateReadBuffer", FieldAttributes.Private, replicateDataArrTr);

            typeDef.Fields.Add(serverReplicatesFd);
            typeDef.Fields.Add(clientReplicatesFd);
            typeDef.Fields.Add(clientReconcileFd);
            typeDef.Fields.Add(serverReplicateTickFd);
            typeDef.Fields.Add(serverReconcileResendsFd);
            typeDef.Fields.Add(clientReplicateResendsFd);
            typeDef.Fields.Add(clientHasReconcileDataFd);
            typeDef.Fields.Add(clientReplayingDataaFd);
            typeDef.Fields.Add(clientReconcileTickFd);
            typeDef.Fields.Add(clientReplicateTickFd);
            typeDef.Fields.Add(serverReceivedTickFd);
            typeDef.Fields.Add(serverReplicatesReadBufferFd);

            predictionFields = new CreatedPredictionFields(serverReplicatesFd, clientReplicatesFd, clientReconcileFd, serverReplicateTickFd, serverReconcileResendsFd,
                clientReplicateResendsFd, clientHasReconcileDataFd, clientReplayingDataaFd, clientReconcileTickFd, clientReplicateTickFd,
                serverReceivedTickFd, serverReplicatesReadBufferFd);
        }

        /// <summary>
        /// Returns if there are any errors with the prediction methods parameters and will print if so.
        /// </summary>
        private bool HasParameterError(MethodDefinition methodDef, TypeDefinition typeDef, bool replicateMethod)
        {
            int count = (replicateMethod) ? 3 : 2;

            //Check parameter count.
            if (methodDef.Parameters.Count != count)
            {
                PrintParameterExpectations();
                return true;
            }

            //Make sure first parameter is class or struct.
            if (!methodDef.Parameters[0].ParameterType.IsClassOrStruct())
            {
                CodegenSession.LogError($"Prediction methods must use a class or structure as the first parameter type. Structures are recommended to avoid allocations.");
                return true;
            }

            //Make sure remaining parameters are booleans.
            for (int i = 1; i < count; i++)
            {
                ParameterDefinition pd = methodDef.Parameters[i];
                if (pd.ParameterType.Name != typeof(bool).Name)
                {
                    PrintParameterExpectations();
                    return true;
                }

            }

            void PrintParameterExpectations()
            {
                if (replicateMethod)
                    CodegenSession.LogError($"Replicate method {methodDef.Name} within {typeDef.Name} requires exactly 3 parameters. The first parameter must be the data to replicate, second a boolean indicating if being run asServer, and third a boolean indicating if data is being replayed.");
                else
                    CodegenSession.LogError($"Reconcile method {methodDef.Name} within {typeDef.Name} requires exactly 2 parameters. The first parameter must be the data to reconcile with, and the second a boolean indicating if being run asServer.");
            }

            //No errors with parameters.
            return false;
        }

        /// <summary>
        /// Creates all methods needed for a RPC.
        /// </summary>
        /// <param name="originalMethodDef"></param>
        /// <param name="rpcAttribute"></param>
        /// <returns></returns>
        private bool CreatePredictionMethods(TypeDefinition typeDef, MethodDefinition replicateMd, MethodDefinition reconcileMd, CreatedPredictionFields predictionFields, uint rpcCount, out PredictionReaders predictionReaders)
        {
            predictionReaders = null;

            string copySuffix = "___UserLogic";
            MethodDefinition replicateUserMd = CodegenSession.GeneralHelper.CopyMethod(replicateMd, $"{replicateMd.Name}{copySuffix}", out _);
            MethodDefinition reconcileUserMd = CodegenSession.GeneralHelper.CopyMethod(reconcileMd, $"{reconcileMd.Name}{copySuffix}", out _);
            replicateMd.Body.Instructions.Clear();
            reconcileMd.Body.Instructions.Clear();

            MethodDefinition replicateReader;
            MethodDefinition reconcileReader;

            if (!CreateReplicate())
                return false;
            if (!CreateReconcile())
                return false;

            CreateClearReplicateCacheMethod(typeDef, replicateMd.Parameters[0].ParameterType, predictionFields);
            ServerCreateReplicateReader(typeDef, replicateMd, predictionFields, out replicateReader);
            ClientCreateReconcileReader(typeDef, reconcileMd, predictionFields, out reconcileReader);
            predictionReaders = new PredictionReaders(replicateReader, reconcileReader);

            bool CreateReplicate()
            {
                ILProcessor processor = replicateMd.Body.GetILProcessor();
                ParameterDefinition asServerPd = replicateMd.Parameters[1];

                //Universal conditions.
                CreateReplicateConditions(replicateMd, predictionFields);

                //Wrap server content in an asServer if statement.
                Instruction afterAsServerInst = processor.Create(OpCodes.Nop);
                processor.Emit(OpCodes.Ldarg, asServerPd);
                processor.Emit(OpCodes.Brfalse, afterAsServerInst);
                /***************************/
                ServerCreateReplicate(replicateMd, predictionFields);
                /***************************/
                processor.Append(afterAsServerInst);

                //Wrap client content in an !asServer if statement.
                Instruction afterNotAsServerInst = processor.Create(OpCodes.Nop);
                processor.Emit(OpCodes.Ldarg, asServerPd);
                processor.Emit(OpCodes.Brtrue, afterNotAsServerInst);
                /***************************/
                ClientCreateReplicate(replicateMd, predictionFields, rpcCount);
                /***************************/
                processor.Append(afterNotAsServerInst);

                //Call user instr method.
                CodegenSession.GeneralHelper.CallCopiedMethod(replicateMd, replicateUserMd);
                processor.Emit(OpCodes.Ret);

                return true;
            }

            bool CreateReconcile()
            {
                ILProcessor processor = reconcileMd.Body.GetILProcessor();
                ParameterDefinition asServerPd = reconcileMd.Parameters[1];

                //Wrap server content in an asServer if statement.
                Instruction afterAsServerInst = processor.Create(OpCodes.Nop);
                processor.Emit(OpCodes.Ldarg, asServerPd);
                processor.Emit(OpCodes.Brfalse, afterAsServerInst);
                /***************************/
                ServerCreateReconcile(reconcileMd, predictionFields, ref rpcCount);
                /***************************/
                processor.Emit(OpCodes.Ret);
                processor.Append(afterAsServerInst);

                ClientRetIfNoReconcile(reconcileMd, predictionFields);
                //      _clientHasReconcileData = false;
                processor.Add(ClientSetHasReconcileData(reconcileMd, false, predictionFields));

                //      if (base.IsServer) invoke reconciles, but do not reconcile.
                /* ClientHost does not reconcile but script may be dependent on the
                 * pre/post reconcile events so invoke those anyway. */
                Instruction afterClearReconcileInst = processor.Create(OpCodes.Nop);
                processor.Emit(OpCodes.Ldarg_0);
                processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.IsServer_MethodRef);
                processor.Emit(OpCodes.Brfalse, afterClearReconcileInst);
                //Invoke OnPre/PostReconcile.
                processor.Add(InvokeOnReconcile(reconcileMd, true));
                processor.Add(InvokeOnReconcile(reconcileMd, false));
                //Exit method.
                processor.Emit(OpCodes.Ret);
                processor.Append(afterClearReconcileInst);

                //Set data received to the reconcile parameter so that clients access the right data.
                SetReconcileData(reconcileMd, predictionFields);
                //      uint reconcileTick = r.Generated___Tick.
                VariableDefinition reconcileTickVd = reconcileMd.CreateVariable(typeof(uint));
                processor.Emit(OpCodes.Ldarg, reconcileMd.Parameters[0]); //the data.
                processor.Emit(OpCodes.Ldfld, ReconcileData_Tick_FieldRef); //Generated___Tick field.
                processor.Emit(OpCodes.Stloc, reconcileTickVd);
                //      base.SetLastReconcileTick(reconcileTick).
                processor.Emit(OpCodes.Ldarg_0);
                processor.Emit(OpCodes.Ldloc, reconcileTickVd);
                processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.SetLastReconcileTick_MethodRef);
                //Invoke reconciling start. 
                processor.Add(InvokeOnReconcile(reconcileMd, true));

                //Call user instr method.
                CodegenSession.GeneralHelper.CallCopiedMethod(reconcileMd, reconcileUserMd);

                ClientCreateReconcile(reconcileMd, replicateMd, predictionFields, reconcileTickVd);

                processor.Emit(OpCodes.Ret);
                return true;
            }

            return true;
        }

        #region Universal prediction.
        /// <summary>
        /// Creates an override for the method responsible for resetting replicates.
        /// </summary>
        /// <param name=""></param>
        /// <param name=""></param>
        private void CreateClearReplicateCacheMethod(TypeDefinition typeDef, TypeReference dataTr, CreatedPredictionFields predictionFields)
        {
            MethodDefinition md = typeDef.GetMethod(ClearReplicateCache_Method_Name);
            //Already exist when it shouldn't.
            if (md != null)
            {
                CodegenSession.LogWarning($"{typeDef.Name} overrides method {md.Name} when it should not. Logic within {md.Name} will be replaced by code generation.");
                md.Body.Instructions.Clear();
            }
            else
            {
                md = new MethodDefinition(ClearReplicateCache_Method_Name, (MethodAttributes.Public | MethodAttributes.Virtual), CodegenSession.Module.TypeSystem.Void);
                CodegenSession.GeneralHelper.CreateParameter(md, typeof(bool), "asServer");
                typeDef.Methods.Add(md);
                CodegenSession.ImportReference(md);
            }
             
            ILProcessor processor = md.Body.GetILProcessor();

            GenericInstanceType genericDataLst;
            GetGenericLists(dataTr, out genericDataLst);
            GenericInstanceType genericDataQueue;
            GetGenericQueues(dataTr, out genericDataQueue);
            //Get clear method.
            MethodReference lstClearMr = CodegenSession.GeneralHelper.List_Clear_MethodRef.MakeHostInstanceGeneric(genericDataLst);
            MethodReference queueClearMr = CodegenSession.GeneralHelper.Queue_Clear_MethodRef.MakeHostInstanceGeneric(genericDataQueue);

            ParameterDefinition asServerPd = md.Parameters[0];

            Instruction afterAsServerInst = processor.Create(OpCodes.Nop);
            Instruction resetTicksInst = processor.Create(OpCodes.Nop);

            processor.Emit(OpCodes.Ldarg, asServerPd);
            processor.Emit(OpCodes.Brfalse_S, afterAsServerInst);
            //Clear on server replicates.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateDatas);
            processor.Emit(OpCodes.Callvirt, queueClearMr);
            processor.Emit(OpCodes.Br_S, resetTicksInst);
            processor.Append(afterAsServerInst);
            //Clear on client replicates.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateDatas);
            processor.Emit(OpCodes.Callvirt, lstClearMr);

            processor.Append(resetTicksInst);
            /* Reset last ticks. */
            //
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stfld, predictionFields.ClientReconcileTick);
            //
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stfld, predictionFields.ClientReplicateTick);
            //
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stfld, predictionFields.ServerReceivedTick);
            //
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stfld, predictionFields.ServerReplicateTick);
            processor.Emit(OpCodes.Ret);
        }
        /// <summary>
        /// Adds DATA_TICK_FIELD_NAME to dataTd.
        /// </summary>
        /// <param name="replicateDataTd"></param>
        private void AddTickFieldToDatas(TypeDefinition replicateDataTd, TypeDefinition reconcileDataTd)
        {
            Add(replicateDataTd, true);
            Add(reconcileDataTd, false);

            void Add(TypeDefinition td, bool replicate)
            {
                FieldReference fr = td.GetField(DATA_TICK_FIELD_NAME);
                if (fr == null)
                {
                    FieldDefinition fd = new FieldDefinition(DATA_TICK_FIELD_NAME, FieldAttributes.Public,
                        CodegenSession.GeneralHelper.GetTypeReference(typeof(uint)));
                    td.Fields.Add(fd);
                    fr = CodegenSession.ImportReference(fd);
                }

                if (replicate)
                    ReplicateData_Tick_FieldRef = fr;
                else
                    ReconcileData_Tick_FieldRef = fr;
            }
        }

        /// <summary>
        /// Creates general conditions for replicate to run for server or client.
        /// </summary>
        private void CreateReplicateConditions(MethodDefinition replicateMd, CreatedPredictionFields predictionFields)
        {
            ILProcessor processor = replicateMd.Body.GetILProcessor();

            ParameterDefinition asServerPd = replicateMd.Parameters[1];

            //      if (asServer && !base.Owner.IsActive) return;
            Instruction afterNoOwnerCheckInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldarg, asServerPd);
            processor.Emit(OpCodes.Brfalse_S, afterNoOwnerCheckInst);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.Owner_MethodRef);
            processor.Emit(OpCodes.Callvirt, CodegenSession.ObjectHelper.NetworkConnection_IsActive_MethodRef);
            processor.Emit(OpCodes.Brtrue_S, afterNoOwnerCheckInst);
            ClearReplicateCache(true, false);
            processor.Emit(OpCodes.Ret);
            processor.Append(afterNoOwnerCheckInst);

            //      if (!asServer && !base.IsOwner) return;
            Instruction afterClientCheckInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldarg, asServerPd);
            processor.Emit(OpCodes.Brtrue_S, afterClientCheckInst);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.IsOwner_MethodRef);
            processor.Emit(OpCodes.Brtrue_S, afterClientCheckInst);
            ClearReplicateCache(false, true);
            processor.Emit(OpCodes.Ret);
            processor.Append(afterClientCheckInst);

            //      if (asServer && base.IsOwner) 
            //clientHost does not replicate.
            Instruction afterAsServerIsClientInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldarg, asServerPd);
            processor.Emit(OpCodes.Brfalse_S, afterAsServerIsClientInst);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.IsOwner_MethodRef);
            processor.Emit(OpCodes.Brfalse_S, afterAsServerIsClientInst);
            ClearReplicateCache(true, true);
            processor.Emit(OpCodes.Ret);
            processor.Append(afterAsServerIsClientInst);

            void ClearReplicateCache(bool server, bool client)
            {
                if (server && client)
                {
                    processor.Emit(OpCodes.Ldarg_0);
                    processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.ClearReplicateCache_0P_MethodRef);
                }
                else
                {
                    processor.Emit(OpCodes.Ldarg_0);
                    OpCode opC = (server) ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0;
                    processor.Emit(opC);
                    processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.ClearReplicateCache_1P_MethodRef);
                }
            }
        }

        /// <summary>
        /// Outputs generic lists for dataTr and uint.
        /// </summary>
        private void GetGenericLists(TypeReference dataTr, out GenericInstanceType lstData)
        {
            TypeReference listDataTr = CodegenSession.ImportReference(typeof(List<>));
            lstData = listDataTr.MakeGenericInstanceType(new TypeReference[] { dataTr });
        }
        /// <summary>
        /// Outputs generic lists for dataTr and uint.
        /// </summary>
        private void GetGenericQueues(TypeReference dataTr, out GenericInstanceType queueData)
        {
            TypeReference queueDataTr = CodegenSession.ImportReference(typeof(Queue<>));
            queueData = queueDataTr.MakeGenericInstanceType(new TypeReference[] { dataTr });
        }
        /// <summary>
        /// Adds to buffer at the front of methodDef.
        /// </summary>
        /// <param name=""></param>
        /// <param name="dataPd"></param>
        /// <param name="tickFd"></param>
        /// <param name="dataFd"></param>
        private void AddToReplicateBuffer(MethodDefinition methodDef, object dataDef, FieldDefinition dataFd)
        {
            TypeReference dataTr = null;
            if (dataDef is ParameterDefinition pd)
                dataTr = pd.ParameterType;
            else if (dataDef is VariableDefinition vd)
                dataTr = vd.VariableType;

            GenericInstanceType lstDataGit;
            GetGenericLists(dataTr, out lstDataGit);
            MethodReference dataAddMr = CodegenSession.GeneralHelper.List_Add_MethodRef.MakeHostInstanceGeneric(lstDataGit);

            ILProcessor processor = methodDef.Body.GetILProcessor();

            //_dataLst.Add(dataPd);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, dataFd);

            if (dataDef is ParameterDefinition pd2)
                processor.Emit(OpCodes.Ldarg, pd2);
            else if (dataDef is VariableDefinition vd2)
                processor.Emit(OpCodes.Ldloc, vd2);
            processor.Emit(OpCodes.Callvirt, dataAddMr);
        }
        /// <summary>
        /// Removes countVd from list of dataFd starting at index 0.
        /// </summary>
        private List<Instruction> ListRemoveRange(MethodDefinition methodDef, FieldDefinition dataFd, TypeReference dataTr, VariableDefinition countVd)
        {
            /* Remove entries which exceed maximum buffer. */
            //Method references for uint/data list:
            //get_count, RemoveRange. */
            GenericInstanceType lstDataGit;
            GetGenericLists(dataTr, out lstDataGit);
            MethodReference lstDataRemoveRangeMr = CodegenSession.GeneralHelper.List_RemoveRange_MethodRef.MakeHostInstanceGeneric(lstDataGit);

            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            //Index 1 is the uint, 0 is the data.
            insts.Add(processor.Create(OpCodes.Ldarg_0));//this.
            insts.Add(processor.Create(OpCodes.Ldfld, dataFd));
            insts.Add(processor.Create(OpCodes.Ldc_I4_0));
            insts.Add(processor.Create(OpCodes.Ldloc, countVd));
            insts.Add(processor.Create(OpCodes.Callvirt, lstDataRemoveRangeMr));

            return insts;
        }
        /// <summary>
        /// Subtracts 1 from a field.
        /// </summary>
        private List<Instruction> SubtractFromField(MethodDefinition methodDef, FieldDefinition fieldDef)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            //      _field--;
            insts.Add(processor.Create(OpCodes.Ldarg_0));
            insts.Add(processor.Create(OpCodes.Ldarg_0));
            insts.Add(processor.Create(OpCodes.Ldfld, fieldDef));
            insts.Add(processor.Create(OpCodes.Ldc_I4_1));
            insts.Add(processor.Create(OpCodes.Sub));
            insts.Add(processor.Create(OpCodes.Stfld, fieldDef));

            return insts;
        }
        /// <summary>
        /// Subtracts 1 from a variable.
        /// </summary>
        private List<Instruction> SubtractFromVariable(MethodDefinition methodDef, VariableDefinition variableDef)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            //      variable--;
            insts.Add(processor.Create(OpCodes.Ldloc, variableDef));
            insts.Add(processor.Create(OpCodes.Ldc_I4_1));
            insts.Add(processor.Create(OpCodes.Sub));
            insts.Add(processor.Create(OpCodes.Stloc, variableDef));

            return insts;
        }

        /// <summary>
        /// Subtracts 1 from a variable.
        /// </summary>
        private List<Instruction> SubtractOneVariableFromAnother(MethodDefinition methodDef, VariableDefinition srcVd, VariableDefinition modifierVd)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            //      variable -= v2;
            insts.Add(processor.Create(OpCodes.Ldloc, srcVd));
            insts.Add(processor.Create(OpCodes.Ldloc, modifierVd));
            insts.Add(processor.Create(OpCodes.Sub));
            insts.Add(processor.Create(OpCodes.Stloc, srcVd));

            return insts;
        }
        #endregion

        #region Server side.
        /// <summary>
        /// Creates replicate code for client.
        /// </summary>
        private void ServerCreateReplicate(MethodDefinition replicateMd, CreatedPredictionFields predictionFields)
        {
            //data.DATA_TICK_FIELD_NAME.
            ParameterDefinition replicateDataPd = replicateMd.Parameters[0];
            TypeReference replicateDataTr = replicateDataPd.ParameterType;

            ILProcessor processor = replicateMd.Body.GetILProcessor();

            /* If there is nothing buffered exit. */
            //Get count in buffered.
            GenericInstanceType queueDataGit;
            GetGenericQueues(replicateDataTr, out queueDataGit);
            MethodReference queueDataGetCountMr = CodegenSession.GeneralHelper.Queue_get_Count_MethodRef.MakeHostInstanceGeneric(queueDataGit);
            MethodReference queueDataGetItemMr = CodegenSession.GeneralHelper.Queue_Dequeue_MethodRef.MakeHostInstanceGeneric(queueDataGit);

            //      int queueCount = _buffered.Count.
            VariableDefinition queueCountVd = CodegenSession.GeneralHelper.CreateVariable(replicateMd, typeof(int));
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateDatas);
            processor.Emit(OpCodes.Callvirt, queueDataGetCountMr);
            processor.Emit(OpCodes.Stloc, queueCountVd);
            /* If the queue count is 2 more than maximum
             * buffered then dequeue an extra one. Currently
             * the input will be lost. */
            //If (queueCount > 3)
            Instruction afterDequeueInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldloc, queueCountVd);
            processor.Emit(OpCodes.Ldc_I4_3);
            processor.Emit(OpCodes.Ble_S, afterDequeueInst);
            //_buffer.Dequeue();
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateDatas);
            processor.Emit(OpCodes.Callvirt, queueDataGetItemMr);
            processor.Emit(OpCodes.Pop);
            processor.Append(afterDequeueInst);

            //Replace with data from buffer.
            //      if (queueCount > 0)
            Instruction afterReplaceDataInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldloc, queueCountVd);
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Ble, afterReplaceDataInst);

            /* Set the data parameter to a dequeued entry. */
            //      dataPd = _buffered.Dequeue();
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateDatas);
            processor.Emit(OpCodes.Callvirt, queueDataGetItemMr);
            processor.Emit(OpCodes.Starg, replicateDataPd);

            /* Set last replicate tick. */
            //      _serverReplicateTick = dataPd.DATA_TICK_FIELD_NAME.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldarg, replicateDataPd);
            processor.Emit(OpCodes.Ldfld, ReplicateData_Tick_FieldRef);
            processor.Emit(OpCodes.Stfld, predictionFields.ServerReplicateTick.CachedResolve());
            //Update last replicate tick.
            //      base.SetLastReplicateTick(tick);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldarg, replicateDataPd);
            processor.Emit(OpCodes.Ldfld, ReplicateData_Tick_FieldRef);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.SetLastReplicateTick_MethodRef);

            //Reset reconcile ticks.
            //      _serverReconcileTicks = 3;
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(RESEND_COUNT_OPCODE);
            processor.Emit(OpCodes.Stfld, predictionFields.ServerReconcileResends.CachedResolve());

            processor.Append(afterReplaceDataInst);
        }

        /// <summary>
        /// Creates a reader for replicate data received from clients.
        /// </summary>
        private bool ServerCreateReplicateReader(TypeDefinition typeDef, MethodDefinition replicateMd, CreatedPredictionFields predictionFields, out MethodDefinition result)
        {
            string methodName = $"{REPLICATE_READER_PREFIX}{replicateMd.Name}";
            MethodDefinition createdMd = new MethodDefinition(methodName,
                    MethodAttributes.Private,
                    replicateMd.Module.TypeSystem.Void);
            typeDef.Methods.Add(createdMd);
            createdMd.Body.InitLocals = true;

            TypeReference replicateDataTr = replicateMd.Parameters[0].ParameterType;
            ILProcessor processor = createdMd.Body.GetILProcessor();

            //Create pooledreader parameter.
            ParameterDefinition readerPd = CodegenSession.GeneralHelper.CreateParameter(createdMd, typeof(PooledReader));

            //Read into cache.
            //      int readCount = pooledReader.ReadToCollection(_serverReplicateReadBuffer);
            MethodReference genericReadMr = CodegenSession.ReaderHelper.Reader_ReadToCollection_MethodRef.MakeGenericMethod(replicateDataTr);
            VariableDefinition readCountVd = createdMd.CreateVariable(typeof(int));
            processor.Emit(OpCodes.Ldarg, readerPd);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldflda, predictionFields.ServerReplicateReaderBuffer);
            //processor.Emit(OpCodes.Ldloca, replicateDataArrVd);
            processor.Emit(OpCodes.Callvirt, genericReadMr);
            processor.Emit(OpCodes.Stloc, readCountVd);

            //Create NetworkConnection parameter to compare owner.
            ParameterDefinition networkConnectionPd = CodegenSession.GeneralHelper.CreateParameter(createdMd, typeof(NetworkConnection));
            //      if (base.ComparerOwner(networkConnectionPd) return;
            CodegenSession.NetworkBehaviourHelper.CreateRemoteClientIsOwnerCheck(processor, networkConnectionPd);

            //Make a local array of same type for easier handling and set it's reference to field.
            VariableDefinition replicateDataArrVd = createdMd.CreateVariable(predictionFields.ServerReplicateReaderBuffer.FieldType);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateReaderBuffer);
            processor.Emit(OpCodes.Stloc, replicateDataArrVd);

            /* Store queue count into queueCount. */
            //START //Method references for uint get_Count.
            GenericInstanceType queueDataGit;
            GetGenericQueues(replicateDataTr, out queueDataGit);
            MethodReference queueDataGetCountMr = CodegenSession.GeneralHelper.Queue_get_Count_MethodRef.MakeHostInstanceGeneric(queueDataGit);
            MethodReference queueDataEnqueueMr = CodegenSession.GeneralHelper.Queue_Enqueue_MethodRef.MakeHostInstanceGeneric(queueDataGit);
            MethodReference queueDataDequeueMr = CodegenSession.GeneralHelper.Queue_Dequeue_MethodRef.MakeHostInstanceGeneric(queueDataGit);
            //END //Method references for uint get_Count.

            /* Add array entries to buffered. */
            //      for (int i = 0; i < dataArr.Length; i++)
            //      {
            //          Data d = dataArr[i];
            //          if (d.Tick > this.lastTick)
            //            _serverReplicateDatas.Add(d);
            //            this.lastTick = d.Tick;
            //      }

            VariableDefinition iteratorVd = CodegenSession.GeneralHelper.CreateVariable(createdMd, typeof(int));
            Instruction iteratorComparerInst = processor.Create(OpCodes.Ldloc, iteratorVd);
            Instruction iteratorLogicInst = processor.Create(OpCodes.Nop);
            Instruction iteratorIncreaseComparerInst = processor.Create(OpCodes.Ldloc, iteratorVd);
            //      for (int i = 0
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, iteratorVd);
            processor.Emit(OpCodes.Br_S, iteratorComparerInst);
            //Logic.
            processor.Append(iteratorLogicInst);

            //Store the data tick.
            VariableDefinition dataTickVd = CodegenSession.GeneralHelper.CreateVariable(createdMd, typeof(int));
            processor.Emit(OpCodes.Ldloc, replicateDataArrVd);
            processor.Emit(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Ldelema, replicateDataTr);
            processor.Emit(OpCodes.Ldfld, ReplicateData_Tick_FieldRef);
            processor.Emit(OpCodes.Stloc, dataTickVd);

            processor.Emit(OpCodes.Ldloc, dataTickVd);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReceivedTick);
            processor.Emit(OpCodes.Ble_S, iteratorIncreaseComparerInst);
            //Add to buffer.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateDatas);
            processor.Emit(OpCodes.Ldloc, replicateDataArrVd);
            processor.Emit(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Ldelem_Any, replicateDataTr);
            processor.Emit(OpCodes.Callvirt, queueDataEnqueueMr);

            //Set serverReceivedTick.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldloc, dataTickVd);
            processor.Emit(OpCodes.Stfld, predictionFields.ServerReceivedTick);
            //      ; i++)
            processor.Append(iteratorIncreaseComparerInst); //(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc_S, iteratorVd);
            //      ;i < arr.Length
            processor.Append(iteratorComparerInst); //(OpCodes.Ldloc, iterator);
            processor.Emit(OpCodes.Ldloc, readCountVd);
            processor.Emit(OpCodes.Conv_I4);
            processor.Emit(OpCodes.Blt_S, iteratorLogicInst);

            /* Remove entries which exceed maximum buffer. */
            VariableDefinition queueCountVd = CodegenSession.GeneralHelper.CreateVariable(createdMd, typeof(int));
            //Get maximum buffered.
            //      byte maximumBufferdInputs = base.TimeManager.MaximumBufferedInputs.
            VariableDefinition maximumBufferedVd = CodegenSession.GeneralHelper.CreateVariable(createdMd, typeof(byte));
            processor.Emit(OpCodes.Ldarg_0); //base.
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.TimeManager_MethodRef);
            processor.Emit(OpCodes.Callvirt, CodegenSession.TimeManagerHelper.MaximumBufferedInputs_MethodRef);
            processor.Emit(OpCodes.Stloc, maximumBufferedVd);
            //Set queueCountVd to new count.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateDatas);
            processor.Emit(OpCodes.Callvirt, queueDataGetCountMr);
            processor.Emit(OpCodes.Stloc, queueCountVd);

            //Get number of inputs to remove. Will be positive if there are too many buffered inputs.
            //      int queueCount -= maximumBuffered.
            processor.Emit(OpCodes.Ldloc, queueCountVd);
            processor.Emit(OpCodes.Ldloc, maximumBufferedVd);
            processor.Emit(OpCodes.Sub);
            processor.Emit(OpCodes.Stloc, queueCountVd);
            //If remove count is positive.
            //      if (queueCount > 0)
            Instruction afterRemoveRangeInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldloc, queueCountVd);
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Ble_S, afterRemoveRangeInst);

            Instruction dequeueComparerInst = processor.Create(OpCodes.Nop);
            Instruction dequeueLogicInst = processor.Create(OpCodes.Nop);
            //Reuse iteratorVd
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, iteratorVd);
            processor.Emit(OpCodes.Br_S, dequeueComparerInst);

            //Logic.
            processor.Append(dequeueLogicInst);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateDatas);
            processor.Emit(OpCodes.Callvirt, queueDataDequeueMr);
            processor.Emit(OpCodes.Pop);

            //Increase iterator.
            processor.Emit(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc, iteratorVd);

            //ComparerJmp.
            processor.Append(dequeueComparerInst);
            processor.Emit(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Ldloc, queueCountVd);
            processor.Emit(OpCodes.Blt_S, dequeueLogicInst);

            processor.Append(afterRemoveRangeInst);

            //Add end of method.
            processor.Emit(OpCodes.Ret);

            result = createdMd;
            return true;
        }

        /// <summary>
        /// Creates server side code for reconcileMd.
        /// </summary>
        /// <param name="reconcileMd"></param>
        /// <returns></returns>
        private void ServerCreateReconcile(MethodDefinition reconcileMd, CreatedPredictionFields predictionFields, ref uint rpcHash)
        {
            ParameterDefinition reconcileDataPd = reconcileMd.Parameters[0];
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = reconcileMd.Body.GetILProcessor();

            GenericInstanceMethod sendReconcileRpcdMr = CodegenSession.NetworkBehaviourHelper.SendReconcileRpc_MethodRef.MakeGenericMethod(new TypeReference[] { reconcileDataPd.ParameterType });

            Instruction afterRetInst = processor.Create(OpCodes.Nop);
            //      if (serverReconcileResends == 0)
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReconcileResends);
            processor.Emit(OpCodes.Brtrue_S, afterRetInst);
            processor.Emit(OpCodes.Ret);
            processor.Append(afterRetInst);

            //      bool firstSend = (_serverReconcileResends == 3);
            VariableDefinition firstSendVd = reconcileMd.CreateVariable(typeof(bool));
            Instruction afterFirstSendSetInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReconcileResends);
            processor.Emit(RESEND_COUNT_OPCODE);
            processor.Emit(OpCodes.Bne_Un_S, afterFirstSendSetInst);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Stloc, firstSendVd);
            processor.Append(afterFirstSendSetInst);

            //processor.Emit(OpCodes.Ceq);
            //      _serverReconcileResends--;
            processor.Add(SubtractFromField(reconcileMd, predictionFields.ServerReconcileResends.CachedResolve()));

            //Set channel based on if last resend.
            VariableDefinition channelVd = reconcileMd.CreateVariable(typeof(Channel));
            //Default channel to unreliable.
            processor.Emit(OpCodes.Ldc_I4, (int)Channel.Unreliable);
            processor.Emit(OpCodes.Stloc, channelVd);
            //Update channel to reliable if last reconcile.
            Instruction afterChannelReliableInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReconcileResends);
            processor.Emit(OpCodes.Brtrue_S, afterChannelReliableInst);
            processor.Emit(OpCodes.Ldc_I4, (int)Channel.Reliable);
            processor.Emit(OpCodes.Stloc, channelVd);
            processor.Append(afterChannelReliableInst);

            //      Replace data.DATA_TICK_FIELD_NAME with last tick replicated.
            OpCode ldArgOC0 = (reconcileDataPd.ParameterType.IsValueType) ? OpCodes.Ldarga : OpCodes.Ldarg;
            processor.Emit(ldArgOC0, reconcileDataPd);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateTick);
            processor.Emit(OpCodes.Stfld, ReconcileData_Tick_FieldRef);

            //      base.SetlastReconcileTick(
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ServerReplicateTick);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.SetLastReconcileTick_MethodRef);

            Instruction afterSendRigidbodyStatesInst = processor.Create(OpCodes.Nop);
            //      if (firstSend)
            //          PredictedObject.SendRigidbodyStatesInternal(this).
            processor.Emit(OpCodes.Ldloc, firstSendVd);
            processor.Emit(OpCodes.Brfalse_S, afterSendRigidbodyStatesInst);
            //SendRigidbodyStatesInternal.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.PredictedObjectHelper.SendRigidbodyStatesInternal_MethodRef);
            processor.Append(afterSendRigidbodyStatesInst);
            //      base.SendReconcileRpc(hash, data, channel);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4, (int)rpcHash);
            processor.Emit(OpCodes.Ldarg, reconcileDataPd);
            processor.Emit(OpCodes.Ldloc, channelVd); 
            processor.Emit(OpCodes.Call, sendReconcileRpcdMr);

            processor.Add(insts);
        }
        #endregion

        #region Client side.
        /// <summary>
        /// Creates replicate code for client.
        /// </summary>
        private void ClientCreateReplicate(MethodDefinition replicateMd, CreatedPredictionFields predictionFields, uint rpcCount)
        {
            ParameterDefinition replicateDataPd = replicateMd.Parameters[0];

            ILProcessor processor = replicateMd.Body.GetILProcessor();

            Instruction afterNetworkLogicInst = processor.Create(OpCodes.Nop);
            //      if (_replaying) skip sending logic.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplayingData);
            processor.Emit(OpCodes.Brtrue, afterNetworkLogicInst);
            //      if (base.IsServer) skip sending, host doesn't need to send.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.IsServer_MethodRef);
            processor.Emit(OpCodes.Brtrue, afterNetworkLogicInst);

            //Sets isDefault to if dataPd is default value.
            VariableDefinition isDefaultVd;
            ClientIsDefault(replicateMd, replicateDataPd, out isDefaultVd);
            //Resets clientReplicateResends if dataPd is not default.
            ClientResetResends(replicateMd, predictionFields, isDefaultVd);
            //Exits method if client has no resends remaining.
            ClientSkipIfNoResends(replicateMd, predictionFields, afterNetworkLogicInst);
            //Decreases clientReplicateResends.
            processor.Add(SubtractFromField(replicateMd, predictionFields.ClientReplicateResends.CachedResolve()));
            //Sets TimeManager.LocalTick to data.
            ClientSetReplicateDataTick(replicateMd, replicateDataPd, predictionFields, isDefaultVd);
            //Adds data to client buffer.

            //      if (!isDefaultData) _replicateDatas.Add....
            Instruction afterAddToBufferInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldloc, isDefaultVd);
            processor.Emit(OpCodes.Brtrue_S, afterAddToBufferInst);
            AddToReplicateBuffer(replicateMd, replicateDataPd, predictionFields.ClientReplicateDatas.CachedResolve());
            processor.Append(afterAddToBufferInst);
            //Calls to send buffer to server.
            ClientSendInput(replicateMd, rpcCount, predictionFields);
            //Add instructions to beginning of method.
            processor.Append(afterNetworkLogicInst);
        }

        /// <summary>
        /// Exits method if no more client replicate resends are available.
        /// </summary>
        private void ClientSkipIfNoResends(MethodDefinition methodDef, CreatedPredictionFields predictionFields, Instruction skipInst)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();

            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateResends);
            processor.Emit(OpCodes.Brfalse_S, skipInst);
        }

        /// <summary>
        /// Resets clientReplicateResends if isDefaultVd is false.
        /// </summary>
        private void ClientResetResends(MethodDefinition methodDef, CreatedPredictionFields predictionFields, VariableDefinition isDefaultVd)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();

            Instruction afterResetInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldloc, isDefaultVd);
            processor.Emit(OpCodes.Brtrue_S, afterResetInst);
            //      _clientReplicateResends = 3.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(RESEND_COUNT_OPCODE);
            processor.Emit(OpCodes.Stfld, predictionFields.ClientReplicateResends);
            processor.Append(afterResetInst);
        }

        /// <summary>
        /// Creates an IsDefault check on dataPd and returns instructions, also outputting boolean variable.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="dataPd"></param>
        /// <returns></returns>
        private void ClientIsDefault(MethodDefinition methodDef, ParameterDefinition dataPd, out VariableDefinition boolVd)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();

            boolVd = CodegenSession.GeneralHelper.CreateVariable(methodDef, typeof(bool));
            //If client has no more resends and passedin default for data.
            //      if (!asServer && _clientReplicateResends == 0 && dataPd == default) return;
            MethodReference genericIsDefaultMr = CodegenSession.GeneralHelper.Comparers_IsDefault_MethodRef.MakeGenericMethod(
                new TypeReference[] { dataPd.ParameterType });

            //Set to not default by ....default.
            //      default = false;
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, boolVd);

            Instruction afterSetDefaultInst = processor.Create(OpCodes.Nop);
            /* If PredictedObject.InstantiatedRigidbodyCount is greater than
             * 0 then states must be updated regularly due to potential changes
             * on server-side physics. When the count is larger than 0
             * do not check setting isDefault; this will force client to replicate
             * with default input, and in result the server will reconcile with the
             * rigidbody states of PredictedObjects. This will be optimized later
             * to use less bandwidth but for the time being PredictedObject states
             * must be regularly updated using this technique. */
            //      if (PredictedObject.InstantiatedRigidbodyCount == 0 && !base.TransformMayChange() && Comparers.IsDefault<T>())
            //          default = true;
            processor.Emit(OpCodes.Call, CodegenSession.PredictedObjectHelper.InstantiatedRigidbodyCountInternal_Get_MethodRef);
            processor.Emit(OpCodes.Brtrue, afterSetDefaultInst);

            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.TransformMayChange_MethodRef);
            processor.Emit(OpCodes.Brtrue_S, afterSetDefaultInst);
            processor.Emit(OpCodes.Ldarg, dataPd);
            processor.Emit(OpCodes.Call, genericIsDefaultMr);
            processor.Emit(OpCodes.Brfalse_S, afterSetDefaultInst);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Stloc, boolVd);
            processor.Append(afterSetDefaultInst);
        }
        /// <summary>
        /// Sets data.DATA_TICK_FIELD_NAME to TimeManager.LocalTick.
        /// </summary>
        private void ClientSetReplicateDataTick(MethodDefinition methodDef, ParameterDefinition dataPd, CreatedPredictionFields predictionFields, VariableDefinition isDefaultVd)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();

            VariableDefinition tickVd = CodegenSession.GeneralHelper.CreateVariable(methodDef, typeof(uint));
            Instruction afterCallLocalTickInst = processor.Create(OpCodes.Nop);
            Instruction afterUseClientReplicateTickInst = processor.Create(OpCodes.Nop);
            /*      uint localTIck;
            /*      if (!isDefaultData)
             *          localTick = base.TimeManager.LocalTick; 
             *          _clientReplicateTick = localTick;   
             *      else
             *          localTick = _clientReplicateTick;   */
            //      if (!isDefault) localTick = base.TimeManager.LocalTick;
            processor.Emit(OpCodes.Ldloc, isDefaultVd);
            processor.Emit(OpCodes.Brtrue_S, afterCallLocalTickInst);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.TimeManager_MethodRef);
            processor.Emit(OpCodes.Callvirt, CodegenSession.TimeManagerHelper.LocalTick_MethodRef);
            processor.Emit(OpCodes.Stloc, tickVd);
            //      _clientReplicateTick = localTick;
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldloc, tickVd);
            processor.Emit(OpCodes.Stfld, predictionFields.ClientReplicateTick);
            processor.Emit(OpCodes.Br_S, afterUseClientReplicateTickInst);
            //ELSE
            //      localTick = _clientReplicateTick;
            processor.Append(afterCallLocalTickInst);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateTick);
            processor.Emit(OpCodes.Stloc, tickVd);
            processor.Append(afterUseClientReplicateTickInst);

            //      data.DATA_TICK_FIELD_NAME = tick.
            OpCode ldArgOC = (dataPd.ParameterType.IsValueType) ? OpCodes.Ldarga : OpCodes.Ldarg;
            processor.Emit(ldArgOC, dataPd);
            processor.Emit(OpCodes.Ldloc, tickVd);
            processor.Emit(OpCodes.Stfld, ReplicateData_Tick_FieldRef.CachedResolve());

            //      base.SetLastReplicateTick(tick);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldloc, tickVd);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.SetLastReplicateTick_MethodRef);
        }
        /// <summary>
        /// Sends clients inputs to server.
        /// </summary>
        private void ClientSendInput(MethodDefinition replicateMd, uint hash, CreatedPredictionFields predictionFields)
        {
            ParameterDefinition dataPd = replicateMd.Parameters[0];
            TypeReference dataTr = dataPd.ParameterType;

            ILProcessor processor = replicateMd.Body.GetILProcessor();

            //Make method reference NB.SendReplicateRpc<dataTr>
            GenericInstanceMethod sendReplicateRpcdMr = CodegenSession.NetworkBehaviourHelper.SendReplicateRpc_MethodRef.MakeGenericMethod(new TypeReference[] { dataTr });

            //Call WriteBufferedInput.
            //      base.WriteBufferedInput<dataTd>(hash, _clientBuffered, count);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4, (int)hash);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateDatas);
            processor.Emit(OpCodes.Ldc_I4_5); //past inputs, hardcoded for now.
            processor.Emit(OpCodes.Call, sendReplicateRpcdMr);
        }

        /// <summary>
        /// Creates a return if client does not have reconcile data.
        /// </summary>
        private bool ClientRetIfNoReconcile(MethodDefinition reconcileMd, CreatedPredictionFields predictionFields)
        {
            ILProcessor processor = reconcileMd.Body.GetILProcessor();

            Instruction afterHasDataCheckInst = processor.Create(OpCodes.Nop);
            //      if (!hasReconcileData) return;
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientHasReconcileData);
            processor.Emit(OpCodes.Brtrue_S, afterHasDataCheckInst);
            processor.Emit(OpCodes.Ret);
            processor.Append(afterHasDataCheckInst);

            return true;
        }

        /// <summary>
        /// Sets stored reconcile data to the parameter of reconcileMd if !asServer.
        /// </summary>
        private void SetReconcileData(MethodDefinition reconcileMd, CreatedPredictionFields predictionFields)
        {
            ILProcessor processor = reconcileMd.Body.GetILProcessor();

            ParameterDefinition reconcileDataPd = reconcileMd.Parameters[0];

            //      reconcileDataPd = _clientReconcileData.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ReconcileData);
            processor.Emit(OpCodes.Starg, reconcileDataPd);
        }

        /// <summary>
        /// Syncs transforms if simulateVd is true.
        /// </summary>
        private void ClientSyncTransforms(MethodDefinition methodDef)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();
            processor.Emit(OpCodes.Call, Physics2D_SyncTransforms_MethodRef);
            processor.Emit(OpCodes.Call, Physics3D_SyncTransforms_MethodRef);
        }

        /// <summary>
        /// Simulates physics if simulateVd is true. Use null on simulateVd to skip check.
        /// </summary>
        private List<Instruction> ClientTrySimulatePhysics(MethodDefinition methodDef, VariableDefinition simulateVd, VariableDefinition tickDeltaVd, VariableDefinition physicsScene3DVd, VariableDefinition physicsScene2DVd)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            Instruction afterSimulateInst = null;
            if (simulateVd != null)
            {
                //      if (simulate) {
                afterSimulateInst = processor.Create(OpCodes.Nop);
                insts.Add(processor.Create(OpCodes.Ldloc, simulateVd));
                insts.Add(processor.Create(OpCodes.Brfalse_S, afterSimulateInst));
            }

            AddSimulate(physicsScene3DVd, Physics3D_Simulate_MethodRef);
            AddSimulate(physicsScene2DVd, Physics2D_Simulate_MethodRef);

            void AddSimulate(VariableDefinition physicsSceneVd, MethodReference simulateMr)
            {
                insts.Add(processor.Create(OpCodes.Ldloca_S, physicsSceneVd));
                insts.Add(processor.Create(OpCodes.Ldloc, tickDeltaVd));
                insts.Add(processor.Create(OpCodes.Conv_R4));
                insts.Add(processor.Create(OpCodes.Call, simulateMr));
                //If is 2d simulate then pop result. 2D uses a bool return while 3D uses a void.
                if (simulateMr == Physics2D_Simulate_MethodRef)
                    insts.Add(processor.Create(OpCodes.Pop));
            }

            if (simulateVd != null)
                insts.Add(afterSimulateInst);

            return insts;
        }

        /// <summary>
        /// Creates and outputs a bool to indicate if physics must be simulated manually.
        /// </summary>
        private void ClientCreateSimulatePhysicsBool(MethodDefinition methodDef, out VariableDefinition simulateVd)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();

            simulateVd = CodegenSession.GeneralHelper.CreateVariable(methodDef, typeof(bool));

            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.TimeManager_MethodRef);
            processor.Emit(OpCodes.Call, CodegenSession.TimeManagerHelper.PhysicsMode_MethodRef);
            processor.Emit(OpCodes.Ldc_I4, (int)PhysicsMode.TimeManager);
            processor.Emit(OpCodes.Ceq);
            processor.Emit(OpCodes.Stloc, simulateVd);

        }

        /// <summary>
        /// Sets ClientHasReconcileData.
        /// </summary>
        private List<Instruction> ClientSetHasReconcileData(MethodDefinition methodDef, bool hasData, CreatedPredictionFields predictionFields)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            int boolValue = (hasData) ? 1 : 0;
            insts.Add(processor.Create(OpCodes.Ldarg_0));
            insts.Add(processor.Create(OpCodes.Ldc_I4, boolValue));
            insts.Add(processor.Create(OpCodes.Stfld, predictionFields.ClientHasReconcileData));

            return insts;
        }

        /// <summary>
        /// Removes replicates prior and at index.
        /// </summary>
        private void ClientRemoveFromCache(MethodDefinition reconcileMd, MethodDefinition replicateMd,
            CreatedPredictionFields predictionFields, VariableDefinition reconcileTickVd)
        {
            ParameterDefinition reconcileDataPd = reconcileMd.Parameters[0];
            TypeReference replicateDataTr = replicateMd.Parameters[0].ParameterType;
            ILProcessor processor = reconcileMd.Body.GetILProcessor();

            VariableDefinition foundIndexVd = CodegenSession.GeneralHelper.CreateVariable(reconcileMd, typeof(int));
            //      index = -1;
            processor.Emit(OpCodes.Ldc_I4_M1);
            processor.Emit(OpCodes.Stloc, foundIndexVd);

            VariableDefinition iteratorVd = CodegenSession.GeneralHelper.CreateVariable(reconcileMd, typeof(int));

            GenericInstanceType lstDataGit;
            GetGenericLists(replicateDataTr, out lstDataGit);
            MethodReference replicateGetCountMr = CodegenSession.GeneralHelper.List_get_Count_MethodRef.MakeHostInstanceGeneric(lstDataGit);
            MethodReference replicateGetItemMr = CodegenSession.GeneralHelper.List_get_Item_MethodRef.MakeHostInstanceGeneric(lstDataGit);
            MethodReference replicateClearMr = CodegenSession.GeneralHelper.List_Clear_MethodRef.MakeHostInstanceGeneric(lstDataGit);

            Instruction iteratorIncreaseInst = processor.Create(OpCodes.Ldloc, iteratorVd);
            Instruction iteratorComparerInst = processor.Create(OpCodes.Ldloc, iteratorVd);
            Instruction iteratorLogicInst = processor.Create(OpCodes.Ldarg_0);
            Instruction afterLoopInst = processor.Create(OpCodes.Nop);
            //      for (int i = 0
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, iteratorVd);
            processor.Emit(OpCodes.Br, iteratorComparerInst);
            //Logic.
            //      if (replicateTick(replaying).Tick == reconcileTick(fromServer))
            processor.Append(iteratorLogicInst); //Ldarg_0.
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateDatas);
            processor.Emit(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Callvirt, replicateGetItemMr);
            processor.Emit(OpCodes.Ldfld, ReplicateData_Tick_FieldRef);
            processor.Emit(OpCodes.Ldloc, reconcileTickVd);
            processor.Emit(OpCodes.Bne_Un, iteratorIncreaseInst);

            processor.Emit(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Stloc, foundIndexVd);
            processor.Emit(OpCodes.Br, afterLoopInst);
            //      i++;
            processor.Append(iteratorIncreaseInst); //Ldloc iteratorVd.
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc, iteratorVd);
            //Conditional.
            processor.Append(iteratorComparerInst); //Ldloc iteratorVd.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateDatas);
            processor.Emit(OpCodes.Callvirt, replicateGetCountMr);
            processor.Emit(OpCodes.Blt, iteratorLogicInst);

            processor.Append(afterLoopInst);

            /* Remove entries that server processed. */
            //      if (index == -1) //Entry not found, shouldn't happen.
            Instruction afterClearInst = processor.Create(OpCodes.Nop);
            Instruction afterRemoveRangeInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldloc, foundIndexVd);
            processor.Emit(OpCodes.Ldc_I4_M1);
            processor.Emit(OpCodes.Bne_Un, afterClearInst);
            //            replicates.Clear();
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateDatas);
            processor.Emit(OpCodes.Callvirt, replicateClearMr);
            processor.Emit(OpCodes.Br, afterRemoveRangeInst);

            //      index++; This is for RemoveRange. If index is 0 then remove count needs to be 1.
            processor.Append(afterClearInst);
            processor.Emit(OpCodes.Ldloc, foundIndexVd);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc, foundIndexVd);

            processor.Add(ListRemoveRange(reconcileMd, predictionFields.ClientReplicateDatas.CachedResolve(), replicateDataTr, foundIndexVd));
            processor.Append(afterRemoveRangeInst);
        }

        private void ClientGetPhysicsScenes(MethodDefinition reconcileMd, out VariableDefinition objectSceneVd, out VariableDefinition physicsScene3DVd, out VariableDefinition physicsScene2DVd)
        {
            ILProcessor processor = reconcileMd.Body.GetILProcessor();
            objectSceneVd = reconcileMd.CreateVariable(typeof(UnityEngine.SceneManagement.Scene));
            physicsScene3DVd = reconcileMd.CreateVariable(typeof(PhysicsScene));
            physicsScene2DVd = reconcileMd.CreateVariable(typeof(PhysicsScene2D));

            //Scene objectScene = gameObject.scene;
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, Unity_GetGameObject_MethodRef);
            processor.Emit(OpCodes.Callvirt, Unity_GetScene_MethodRef);
            processor.Emit(OpCodes.Stloc, objectSceneVd);

            //      PhysicsScene ps3d = objectScene.GetPhysicsScene();
            processor.Emit(OpCodes.Ldloc, objectSceneVd);
            processor.Emit(OpCodes.Call, Unity_GetPhysicsScene3D_MethodRef);
            processor.Emit(OpCodes.Stloc, physicsScene3DVd);

            //      PhysicsScene2D ps2d = objectScene.GetPhysicsScene();
            processor.Emit(OpCodes.Ldloc, objectSceneVd);
            processor.Emit(OpCodes.Call, Unity_GetPhysicsScene2D_MethodRef);
            processor.Emit(OpCodes.Stloc, physicsScene2DVd);
        }
        /// <summary>
        /// Replays all cached client datas.
        /// </summary>
        private void ClientReplayBuffered(MethodDefinition reconcileMd, MethodDefinition replicateMd, CreatedPredictionFields predictionFields,
            VariableDefinition simulateVd, VariableDefinition sceneVd, VariableDefinition physicsSceneVd, VariableDefinition physicsScene2DVd)
        {
            MethodReference replicateMr = CodegenSession.ImportReference(replicateMd);
            TypeReference replicateDataTr = replicateMd.Parameters[0].ParameterType;

            ILProcessor processor = reconcileMd.Body.GetILProcessor();

            VariableDefinition iteratorVd = CodegenSession.GeneralHelper.CreateVariable(reconcileMd, typeof(int));

            GenericInstanceType lstDataGit;
            GetGenericLists(replicateDataTr, out lstDataGit);
            MethodReference dataCollectionGetCountMr = CodegenSession.GeneralHelper.List_get_Count_MethodRef.MakeHostInstanceGeneric(lstDataGit);
            MethodReference dataCollectionGetItemMr = CodegenSession.GeneralHelper.List_get_Item_MethodRef.MakeHostInstanceGeneric(lstDataGit);

            Instruction iteratorComparerInst = processor.Create(OpCodes.Ldloc, iteratorVd);
            Instruction iteratorLogicInst = processor.Create(OpCodes.Nop);

            //Set as replaying before iterating.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Stfld, predictionFields.ClientReplayingData);

            //      double tickDelta = base.TimeManager.TickDelta;
            VariableDefinition tickDeltaVd = CodegenSession.GeneralHelper.CreateVariable(reconcileMd, typeof(double));
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.TimeManager_MethodRef);
            processor.Emit(OpCodes.Callvirt, CodegenSession.TimeManagerHelper.TickDelta_MethodRef);
            processor.Emit(OpCodes.Stloc, tickDeltaVd);

            //      int count = _replicateBuffer.Count.
            VariableDefinition lstCountVd = CodegenSession.GeneralHelper.CreateVariable(reconcileMd, typeof(int));
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateDatas);
            processor.Emit(OpCodes.Callvirt, dataCollectionGetCountMr);
            processor.Emit(OpCodes.Stloc, lstCountVd);

            //      for (int i = 0
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stloc, iteratorVd);
            processor.Emit(OpCodes.Br, iteratorComparerInst);
            //Logic.
            processor.Append(iteratorLogicInst);
            processor.Add(InvokeOnReplicateReplay(replicateMd, sceneVd, physicsSceneVd, physicsScene2DVd, true));
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateDatas);
            processor.Emit(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Callvirt, dataCollectionGetItemMr);
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Ldc_I4_1); //true for replaying.
            processor.Emit(OpCodes.Call, replicateMr);
            processor.Add(ClientTrySimulatePhysics(reconcileMd, simulateVd, tickDeltaVd, physicsSceneVd, physicsScene2DVd));
            processor.Add(InvokeOnReplicateReplay(replicateMd, sceneVd, physicsSceneVd, physicsScene2DVd, false));
            //      i++;
            processor.Emit(OpCodes.Ldloc, iteratorVd);
            processor.Emit(OpCodes.Ldc_I4_1);
            processor.Emit(OpCodes.Add);
            processor.Emit(OpCodes.Stloc, iteratorVd);
            //Conditional.
            processor.Append(iteratorComparerInst);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReplicateDatas);
            processor.Emit(OpCodes.Callvirt, dataCollectionGetCountMr);
            processor.Emit(OpCodes.Blt, iteratorLogicInst);

            //Invokes reconcile end.
            processor.Add(InvokeOnReconcile(reconcileMd, false));

            //Unset replaying.
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4_0);
            processor.Emit(OpCodes.Stfld, predictionFields.ClientReplayingData);

        }

        /// <summary>
        /// Invokes OnReplicateReplay.
        /// </summary>
        private List<Instruction> InvokeOnReplicateReplay(MethodDefinition methodDef, VariableDefinition sceneVd, VariableDefinition physicsSceneVd, VariableDefinition physicsScene2DVd, bool start)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            insts.Add(processor.Create(OpCodes.Ldarg_0));
            insts.Add(processor.Create(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.TimeManager_MethodRef));
            insts.Add(processor.Create(OpCodes.Ldloc, sceneVd));
            insts.Add(processor.Create(OpCodes.Ldloc, physicsSceneVd));
            insts.Add(processor.Create(OpCodes.Ldloc, physicsScene2DVd));
            if (start)
                insts.Add(processor.Create(OpCodes.Ldc_I4_1));
            else
                insts.Add(processor.Create(OpCodes.Ldc_I4_0));
            insts.Add(processor.Create(OpCodes.Callvirt, CodegenSession.TimeManagerHelper.InvokeOnReplicateReplay_MethodRef));

            return insts;
        }

        /// <summary>
        /// Invokes OnReconcile. Uses lstCountVd > 0 as a requirement if not null.
        /// </summary>
        private List<Instruction> InvokeOnReconcile(MethodDefinition methodDef, bool start)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            insts.Add(processor.Create(OpCodes.Ldarg_0));
            insts.Add(processor.Create(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.TimeManager_MethodRef));
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this for NB.
            if (start)
                insts.Add(processor.Create(OpCodes.Ldc_I4_1));
            else
                insts.Add(processor.Create(OpCodes.Ldc_I4_0));
            insts.Add(processor.Create(OpCodes.Callvirt, CodegenSession.TimeManagerHelper.InvokeOnReconcile_MethodRef));

            return insts;
        }

        /// <summary>
        /// Creates a reader for replicate data received from clients.
        /// </summary>
        private void ClientCreateReconcileReader(TypeDefinition typeDef, MethodDefinition reconcileMd, CreatedPredictionFields predictionFields, out MethodDefinition result)
        {
            string methodName = $"{RECONCILE_READER_PREFIX}{reconcileMd.Name}";
            /* If method already exist then clear it. This
             * can occur when a method needs to be rebuilt due to
             * inheritence, and renumbering the start counts.  */
            MethodDefinition createdMd = createdMd = new MethodDefinition(methodName,
                    MethodAttributes.Private,
                    reconcileMd.Module.TypeSystem.Void);
            typeDef.Methods.Add(createdMd);
            createdMd.Body.InitLocals = true;

            //Create pooledreader parameter.
            ParameterDefinition readerPd = CodegenSession.GeneralHelper.CreateParameter(createdMd, typeof(PooledReader));
            TypeReference reconcileDataTr = reconcileMd.Parameters[0].ParameterType;
            //data.DATA_TICK_FIELD_NAME.
            ILProcessor processor = createdMd.Body.GetILProcessor();

            VariableDefinition reconcileVr;
            processor.Add(CodegenSession.ReaderHelper.CreateRead(createdMd, readerPd, reconcileDataTr, out reconcileVr));

            /* Make sure is owner. This is always sent to owner, but
             * unreliably. It's possible they will arrive after
             * an owner change. */
            //      if (!base.IsOwner) return;
            CodegenSession.NetworkBehaviourHelper.CreateLocalClientIsOwnerCheck(createdMd, LoggingType.Off, true, false, false);

            //uint receivedTick = data.DATA_TICK_FIELD_NAME.
            VariableDefinition receivedTickVd = CodegenSession.GeneralHelper.CreateVariable(createdMd, typeof(uint));
            processor.Emit(OpCodes.Ldloc, reconcileVr);
            processor.Emit(OpCodes.Ldfld, ReconcileData_Tick_FieldRef);
            processor.Emit(OpCodes.Stloc, receivedTickVd);

            /* If tick is less than last received tick then exit method.
             * Already reconciled to a more recent tick. */
            //      if (receivedTick <= _clientReconcileTick) return;
            Instruction afterOldTickCheckInst = processor.Create(OpCodes.Nop);
            processor.Emit(OpCodes.Ldloc, receivedTickVd);
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldfld, predictionFields.ClientReconcileTick);
            processor.Emit(OpCodes.Bgt_Un_S, afterOldTickCheckInst);
            processor.Emit(OpCodes.Ret);
            processor.Append(afterOldTickCheckInst);

            //      _clientReconcileTick = receivedTick;
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldloc, receivedTickVd);
            processor.Emit(OpCodes.Stfld, predictionFields.ClientReconcileTick);
            //      _clientHasReconcileData = true;
            processor.Add(ClientSetHasReconcileData(createdMd, true, predictionFields));
            //      _clientReconcileData = reconcileData;
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldloc, reconcileVr);
            processor.Emit(OpCodes.Stfld, predictionFields.ReconcileData);

            //Add end of method.
            processor.Emit(OpCodes.Ret);

            result = createdMd;
        }

        /// <summary>
        /// Creates client side code for reconcileMd.
        /// </summary>
        /// <param name="reconcileMd"></param>
        /// <returns></returns>
        private void ClientCreateReconcile(MethodDefinition reconcileMd, MethodDefinition replicateMd
            , CreatedPredictionFields predictionFields, VariableDefinition reconcileTickVd)
        {
            ILProcessor reconcileProcessor = reconcileMd.Body.GetILProcessor();

            //      bool simulate = (base.TimeManager.PhysicsMode == PhysicsMode.TimeManager);
            VariableDefinition simulateVd;
            /* Simulations to run after replaying inputs. Needed because
            * even though there may not be inputs the ticks ran after
            * the last input should re-simulate. EG: if inputs are performed
            * on ticks 0, 1, 2, 3, 4 but ticks 5, 6, 7, 8 are run before the
            * the client can reconcile then only 0-4 simulations will run, and the
            * remaining will not causing a desync. */
            VariableDefinition extraSimulationsVd = CodegenSession.GeneralHelper.CreateVariable(reconcileMd, typeof(uint));
            //      extraSimulations = 0; //default.
            reconcileProcessor.Emit(OpCodes.Ldc_I4_0);
            reconcileProcessor.Emit(OpCodes.Stloc, extraSimulationsVd);

            ClientCreateSimulatePhysicsBool(reconcileMd, out simulateVd);
            //      Physics/2D.SyncTransforms.
            ClientSyncTransforms(reconcileMd);
            //Remove data server processed.
            ClientRemoveFromCache(reconcileMd, replicateMd, predictionFields, reconcileTickVd);
            //Gets physics scenes.
            VariableDefinition objectSceneVd;
            VariableDefinition physicsScenDVd;
            VariableDefinition physicsScene2DVd;
            ClientGetPhysicsScenes(reconcileMd, out objectSceneVd, out physicsScenDVd, out physicsScene2DVd);
            //Replays buffered inputs.
            ClientReplayBuffered(reconcileMd, replicateMd, predictionFields, simulateVd, objectSceneVd, physicsScenDVd, physicsScene2DVd);
        }
        #endregion

        #region CreateSend...
        /// <summary>
        /// Emits common values into Send call that all prediction methods use.
        /// </summary>
        private void CreateSendPredictionCommon(ILProcessor processor, uint hash, VariableDefinition writerVd)
        {
            processor.Emit(OpCodes.Ldarg_0);
            processor.Emit(OpCodes.Ldc_I4, (int)hash);
            processor.Emit(OpCodes.Ldloc, writerVd);
        }
        /// <summary>
        /// Calls SendReplicate.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="hash"></param>
        /// <param name="writerVd"></param>
        private void CreateSendReplicate(ILProcessor processor, uint hash, VariableDefinition writerVd)
        {
            CreateSendPredictionCommon(processor, hash, writerVd);
            //Call NetworkBehaviour.SendReplicate.
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.SendReplicateRpc_MethodRef);
        }
        #endregion
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/NetworkBehaviourProcessor.cs ---
﻿using FishNet.CodeGenerating.Extension;
using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Configuring;
using FishNet.Object;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using MonoFN.Collections.Generic;
using System.Collections.Generic;
using System.Linq;
using DebugX = UnityEngine.Debug;

namespace FishNet.CodeGenerating.Processing
{
    internal class NetworkBehaviourProcessor
    {
        #region Types.
        private class NetworkInitializeMethodData
        {
            public MethodDefinition MethodDefinition;
            public FieldDefinition CalledFieldDef;
            public bool CalledFromAwake;

            public NetworkInitializeMethodData(MethodDefinition methodDefinition, FieldDefinition calledFieldDef)
            {
                MethodDefinition = methodDefinition;
                CalledFieldDef = calledFieldDef;
                CalledFromAwake = false;
            }
        }
        private class AwakeMethodData
        {
            public MethodDefinition AwakeMethodDef;
            public MethodDefinition UserLogicMethodDef;
            public bool Created;

            public AwakeMethodData(MethodDefinition awakeMd, MethodDefinition userLogicMd, bool created)
            {
                AwakeMethodDef = awakeMd;
                UserLogicMethodDef = userLogicMd;
                Created = created;
            }
        }
        #endregion

        #region Misc.
        private Dictionary<TypeDefinition, NetworkInitializeMethodData> _earlyNetworkInitializeDatas = new Dictionary<TypeDefinition, NetworkInitializeMethodData>();
        private Dictionary<TypeDefinition, NetworkInitializeMethodData> _lateNetworkInitializeDatas = new Dictionary<TypeDefinition, NetworkInitializeMethodData>();
        /// <summary>
        /// Methods modified or iterated during weaving.
        /// </summary>
        internal List<MethodDefinition> ModifiedMethodDefinitions = new List<MethodDefinition>();
        /// <summary>
        /// Classes which have been processed for all NetworkBehaviour features.
        /// </summary>
        private HashSet<TypeDefinition> _processedClasses = new HashSet<TypeDefinition>();
        #endregion

        #region Const.
        internal const string EARLY_INITIALIZED_NAME = "NetworkInitializeEarly_";
        internal const string LATE_INITIALIZED_NAME = "NetworkInitializeLate_";
        internal const string NETWORKINITIALIZE_EARLY_INTERNAL_NAME = "NetworkInitialize___Early";
        internal const string NETWORKINITIALIZE_LATE_INTERNAL_NAME = "NetworkInitialize__Late";
        private MethodAttributes PUBLIC_VIRTUAL_ATTRIBUTES = (MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig);
#pragma warning disable CS0414
        private MethodAttributes PROTECTED_VIRTUAL_ATTRIBUTES = (MethodAttributes.Family | MethodAttributes.Virtual | MethodAttributes.HideBySig);
#pragma warning restore CS0414
        #endregion

        internal bool Process(TypeDefinition typeDef, List<(SyncType, ProcessedSync)> allProcessedSyncs, Dictionary<TypeDefinition, uint> childSyncTypeCounts, Dictionary<TypeDefinition, uint> childRpcCounts)
        {
            bool modified = false;
            TypeDefinition copyTypeDef = typeDef;
            TypeDefinition firstTypeDef = typeDef;

            //Make collection of NBs to processor.
            List<TypeDefinition> typeDefs = new List<TypeDefinition>();
            do
            {
                typeDefs.Add(copyTypeDef);
                copyTypeDef = TypeDefinitionExtensionsOld.GetNextBaseClassToProcess(copyTypeDef);
            } while (copyTypeDef != null);

            /* Iterate from child-most to parent first
             * while creating network initialize methods.
             * This is because the child-most must call the parents
             * base awake methods. */
            foreach (TypeDefinition td in typeDefs)
            {
                /* Class was already processed. Since child most is processed first
                 * this can occur if a class is inherited by multiple types. If a class
                 * has already been processed then there is no reason to scale up the hierarchy
                 * because it would have already been done. */
                if (HasClassBeenProcessed(td))
                    continue;

                //Disallow nested network behaviours.
                ICollection<TypeDefinition> nestedTds = td.NestedTypes;
                foreach (TypeDefinition item in nestedTds)
                {
                    if (item.InheritsNetworkBehaviour())
                    {
                        CodegenSession.LogError($"{td.FullName} contains nested NetworkBehaviours. These are not supported.");
                        return modified;
                    }
                }

                /* Create NetworkInitialize before-hand so the other procesors
                 * can use it. */
                MethodDefinition networkInitializeInternalMd;
                CreateNetworkInitializeMethods(td, out networkInitializeInternalMd);
                CallNetworkInitializeMethods(networkInitializeInternalMd);
            }

            /* Reverse and do RPCs/SyncTypes.
             * This counts up on children instead of the
             * parent, so we do not have to rewrite
             * parent numbers. */
            typeDefs.Reverse();

            foreach (TypeDefinition td in typeDefs)
            {
                /* Class was already processed. Since child most is processed first
                 * this can occur if a class is inherited by multiple types. If a class
                 * has already been processed then there is no reason to scale up the hierarchy
                 * because it would have already been done. */
                if (HasClassBeenProcessed(td))
                    continue;

                //No longer used...remove in rework.
                uint rpcCount = 0;
                childRpcCounts.TryGetValue(td, out rpcCount);
                /* Prediction. */
                /* Run prediction first since prediction will modify
                 * user data passed into prediction methods. Because of this
                 * other RPCs should use the modified version and reader/writers
                 * made for prediction. */
                modified |= CodegenSession.NetworkBehaviourPredictionProcessor.Process(td, ref rpcCount);
                //25ms 

                /* RPCs. */
                modified |= CodegenSession.RpcProcessor.Process(td, ref rpcCount);
                //30ms
                /* //perf rpcCounts can be optimized by having different counts
                 * for target, observers, server, replicate, and reoncile rpcs. Since
                 * each registers to their own delegates this is possible. */

                

                /* SyncTypes. */
                uint syncTypeStartCount;
                childSyncTypeCounts.TryGetValue(td, out syncTypeStartCount);
                modified |= CodegenSession.NetworkBehaviourSyncProcessor.Process(td, allProcessedSyncs, ref syncTypeStartCount);
                //70ms
                _processedClasses.Add(td);
            }

            int maxAllowSyncTypes = 256;
            if (allProcessedSyncs.Count > maxAllowSyncTypes)
            {
                CodegenSession.LogError($"Found {allProcessedSyncs.Count} SyncTypes within {firstTypeDef.FullName}. The maximum number of allowed SyncTypes within type and inherited types is {maxAllowSyncTypes}. Remove SyncTypes or condense them using data containers, or a custom SyncObject.");
                return false;
            }

            /* If here then all inerited classes for firstTypeDef have
             * been processed. */
            PrepareNetworkInitializeMethods(firstTypeDef);

            /* Make awake methods for all inherited classes
            * public and virtual. This is so I can add logic
            * to the firstTypeDef awake and still execute
            * user awake methods. */
            List<AwakeMethodData> awakeDatas = new List<AwakeMethodData>();
            if (!CreateOrModifyAwakeMethods(firstTypeDef, ref awakeDatas))
            {
                CodegenSession.LogError($"Was unable to make Awake methods public virtual starting on type {firstTypeDef.FullName}.");
                return modified;
            }

            //NetworkInitializeEarly.
            CallNetworkInitializeFromAwake(awakeDatas, true);
            //Call base awake, then call user logic methods.
            CallBaseAwakeOnCreatedMethods(awakeDatas);
            CallAwakeUserLogic(awakeDatas);
            //NetworkInitializeLate
            CallNetworkInitializeFromAwake(awakeDatas, false);
            //Since awake methods are erased ret has to be added at the end.
            AddReturnsToAwake(awakeDatas);

            CodegenSession.NetworkBehaviourSyncProcessor.CallBaseReadSyncVar(firstTypeDef);

            return modified;
        }

        /// <summary>
        /// Returns if a class has been processed.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        private bool HasClassBeenProcessed(TypeDefinition typeDef)
        {
            return _processedClasses.Contains(typeDef);
        }

        /// <summary>
        /// Returns if any typeDefs have attributes which are not allowed to be used outside NetworkBehaviour.
        /// </summary>
        /// <param name="typeDefs"></param>
        /// <returns></returns>
        internal bool NonNetworkBehaviourHasInvalidAttributes(Collection<TypeDefinition> typeDefs)
        {
            bool error = false;
            foreach (TypeDefinition typeDef in typeDefs)
            {
                //Inherits, don't need to check.
                if (typeDef.InheritsNetworkBehaviour())
                    continue;

                //Check each method for attribute.
                foreach (MethodDefinition md in typeDef.Methods)
                {
                    //Has RPC attribute but doesn't inherit from NB.
                    if (CodegenSession.RpcProcessor.Attributes.HasRpcAttributes(md))
                    {
                        CodegenSession.LogError($"{typeDef.FullName} has one or more RPC attributes but does not inherit from NetworkBehaviour.");
                        error = true;
                    }
                }
                //Check fields for attribute.
                foreach (FieldDefinition fd in typeDef.Fields)
                {
                    if (CodegenSession.NetworkBehaviourSyncProcessor.GetSyncType(fd, false, out _) != SyncType.Unset)
                    {
                        CodegenSession.LogError($"{typeDef.FullName} has one or more SyncType attributes but does not inherit from NetworkBehaviour.");
                        error = true;
                    }
                }
            }

            return error;
        }

        

        /// <summary>
        /// Calls the next awake method if the nested awake was created by codegen.
        /// </summary>
        /// <returns></returns>
        private void CallBaseAwakeOnCreatedMethods(List<AwakeMethodData> datas)
        {
            /* Method definitions are added from child most
             * so they will always be going up the hierarchy. */
            for (int i = 0; i < datas.Count; i++)
            {
                AwakeMethodData amd = datas[i];
                /* If the awake already existed
                 * then let the user code be the final say
                 * if base is called. */
                if (!amd.Created)
                    continue;

                TypeDefinition copyTypeDef = amd.AwakeMethodDef.DeclaringType;

                /* Get next base awake first.
                 * If it doesn't exist then nothing can be called. */
                MethodReference baseAwakeMethodRef = copyTypeDef.GetMethodReferenceInBase(NetworkBehaviourHelper.AWAKE_METHOD_NAME);// GetNextAwake(i);
                if (baseAwakeMethodRef == null)
                    return;
                //MethodReference baseAwakeMethodRef = CodegenSession.ImportReference(baseAwakeMd);
                /* Awake will always exist because it was added previously.
                 * Get awake for the current declaring type. */
                MethodDefinition copyAwakeMd = copyTypeDef.GetMethod(NetworkBehaviourHelper.AWAKE_METHOD_NAME);

                //Check if they already call base.
                ILProcessor processor = copyAwakeMd.Body.GetILProcessor();
                bool alreadyHasBaseCall = false;
                //Check if already calls baseAwake.
                foreach (var item in copyAwakeMd.Body.Instructions)
                {

                    //If a call or call virt. Although, callvirt should never occur.
                    if (item.OpCode == OpCodes.Call || item.OpCode == OpCodes.Callvirt)
                    {
                        if (item.Operand != null && item.Operand.GetType().Name == nameof(MethodDefinition))
                        {
                            MethodDefinition md = (MethodDefinition)item.Operand;
                            if (md == baseAwakeMethodRef.Resolve())
                            {
                                alreadyHasBaseCall = true;
                                break;
                            }
                        }
                    }
                }

                if (!alreadyHasBaseCall)
                {
                    //Create instructions for base call.
                    processor.Emit(OpCodes.Ldarg_0); //base.
                    processor.Emit(OpCodes.Call, baseAwakeMethodRef);
                }
            }
        }

        /// <summary>
        /// Calls the next awake method if the nested awake was created by codegen.
        /// </summary>
        /// <returns></returns>
        private void CallAwakeUserLogic(List<AwakeMethodData> datas)
        {
            /* Method definitions are added from child most
             * so they will always be going up the hierarchy. */
            for (int i = 0; i < datas.Count; i++)
            {
                AwakeMethodData amd = datas[i];
                //If was created then there is no user logic.
                if (amd.Created)
                    continue;
                //If logic method is null. Should never be the case.
                if (amd.UserLogicMethodDef == null)
                    continue;

                MethodDefinition awakeMd = amd.AwakeMethodDef;
                CodegenSession.GeneralHelper.CallCopiedMethod(awakeMd, amd.UserLogicMethodDef);
            }

        }

        /// <summary>
        /// Adds a check to NetworkInitialize to see if it has already run.
        /// </summary>
        /// <param name="typeDef"></param>
        private void AddNetworkInitializeExecutedCheck(TypeDefinition firstTypeDef, bool initializeEarly, bool checkForExisting)
        {

            TypeDefinition copyTypeDef = firstTypeDef;
            AddCheck(copyTypeDef, initializeEarly);

            void AddCheck(TypeDefinition td, bool early)
            {
                string methodName;
                string fieldName;
                if (early)
                {
                    methodName = NETWORKINITIALIZE_EARLY_INTERNAL_NAME;
                    fieldName = $"{EARLY_INITIALIZED_NAME}{td.FullName}_{td.Module.Name}";
                }
                else
                {
                    methodName = NETWORKINITIALIZE_LATE_INTERNAL_NAME;
                    fieldName = $"{LATE_INITIALIZED_NAME}{td.FullName}_{td.Module.Name}";
                }

                MethodDefinition md = td.GetMethod(methodName);
                if (md == null)
                    return;

                FieldDefinition fd = copyTypeDef.GetField(fieldName)?.Resolve();
                if (fd == null)
                {
                    TypeReference boolTr = CodegenSession.GeneralHelper.GetTypeReference(typeof(bool));
                    //Add fields to see if it already ran.
                    fd = new FieldDefinition(fieldName, FieldAttributes.Private, boolTr);
                    td.Fields.Add(fd);
                }

                if (checkForExisting)
                {
                    bool alreadyChecked = false;
                    //Check if already calls baseAwake.
                    foreach (Instruction item in md.Body.Instructions)
                    {
                        //If a call or call virt. Although, callvirt should never occur.
                        if (item.OpCode == OpCodes.Ldfld && item.Operand != null && item.Operand is FieldDefinition opFd)
                        {
                            if (opFd == fd)
                            {
                                alreadyChecked = true;
                                break;
                            }
                        }
                    }

                    if (alreadyChecked)
                        return;
                }

                List<Instruction> insts = new List<Instruction>();
                ILProcessor processor = md.Body.GetILProcessor();
                //Add check if already called.
                //if (alreadyInitialized) return;
                Instruction skipFirstRetInst = processor.Create(OpCodes.Nop);
                insts.Add(processor.Create(OpCodes.Ldarg_0));
                insts.Add(processor.Create(OpCodes.Ldfld, fd));
                insts.Add(processor.Create(OpCodes.Brfalse_S, skipFirstRetInst));
                insts.Add(processor.Create(OpCodes.Ret));
                insts.Add(skipFirstRetInst);
                //Set field to true.
                insts.Add(processor.Create(OpCodes.Ldarg_0));
                insts.Add(processor.Create(OpCodes.Ldc_I4_1));
                insts.Add(processor.Create(OpCodes.Stfld, fd));
                processor.InsertFirst(insts);
            }

        }
        /// <summary>
        /// Gets the top-most parent away method.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        private void PrepareNetworkInitializeMethods(TypeDefinition firstTypeDef)
        {
            TypeDefinition thisTypeDef = firstTypeDef;

            string[] initializeMethodNames = new string[] { NETWORKINITIALIZE_EARLY_INTERNAL_NAME, NETWORKINITIALIZE_LATE_INTERNAL_NAME };

            do
            {
                bool canCallBase = thisTypeDef.CanProcessBaseType();

                foreach (string mdName in initializeMethodNames)
                {
                    /* There are no more base calls to make but we still
                    * need to check if the initialize methods have already ran, so do that
                    * here. */
                    if (!canCallBase)
                    {
                        AddNetworkInitializeExecutedCheck(thisTypeDef, (mdName == NETWORKINITIALIZE_EARLY_INTERNAL_NAME), true);
                        continue;
                    }

                    /* Awake will always exist because it was added previously.
                     * Get awake for copy and base of copy. */
                    MethodDefinition thisMd = thisTypeDef.GetMethod(mdName);
                    MethodDefinition baseMd = thisTypeDef.BaseType.CachedResolve().GetMethod(mdName);
                    MethodReference baseMr = thisTypeDef.GetMethodReferenceInBase(mdName);
                    ILProcessor processor = thisMd.Body.GetILProcessor();

                    bool alreadyHasBaseCall = false;
                    //Check if already calls baseAwake.
                    foreach (Instruction item in thisMd.Body.Instructions)
                    {

                        //If a call or call virt. Although, callvirt should never occur.
                        if (item.OpCode == OpCodes.Call || item.OpCode == OpCodes.Callvirt)
                        {
                            if (item.Operand != null && item.Operand.GetType().Name == nameof(MethodDefinition))
                            {
                                MethodDefinition md = (MethodDefinition)item.Operand;
                                if (md == baseMd)
                                {
                                    alreadyHasBaseCall = true;
                                    break;
                                }
                            }
                        }
                    }

                    if (!alreadyHasBaseCall)
                    {
                        //Create instructions for base call.
                        List<Instruction> instructions = new List<Instruction>();
                        instructions.Add(processor.Create(OpCodes.Ldarg_0)); //this.
                        instructions.Add(processor.Create(OpCodes.Call, baseMr));
                        processor.InsertFirst(instructions);

                        AddNetworkInitializeExecutedCheck(thisTypeDef, (mdName == NETWORKINITIALIZE_EARLY_INTERNAL_NAME), false);
                    }
                }

                thisTypeDef = TypeDefinitionExtensionsOld.GetNextBaseClassToProcess(thisTypeDef);
            } while (thisTypeDef != null);

        }

        /// <summary>
        /// Adds returns awake method definitions within awakeDatas.
        /// </summary>
        private void AddReturnsToAwake(List<AwakeMethodData> awakeDatas)
        {
            foreach (AwakeMethodData amd in awakeDatas)
            {
                ILProcessor processor = amd.AwakeMethodDef.Body.GetILProcessor();
                //If no instructions or the last instruction isnt ret.
                if (processor.Body.Instructions.Count == 0
                    || processor.Body.Instructions[processor.Body.Instructions.Count - 1].OpCode != OpCodes.Ret)
                {
                    processor.Emit(OpCodes.Ret);
                }
            }
        }

        /// <summary>
        /// Calls NetworKInitializeLate method on the typeDef.
        /// </summary>
        /// <param name="copyTypeDef"></param>
        private void CallNetworkInitializeFromAwake(List<AwakeMethodData> awakeDatas, bool callEarly)
        {
            /* InitializeLate should be called after the user runs
             * all their Awake logic. This is so the user can configure
             * sync types on Awake and it won't trigger those values
             * as needing to be sent over the network, since both
             * server and client will be assigning them on Awake. */
            foreach (AwakeMethodData amd in awakeDatas)
            {
                string methodName = (callEarly) ? NETWORKINITIALIZE_EARLY_INTERNAL_NAME :
                    NETWORKINITIALIZE_LATE_INTERNAL_NAME;

                TypeDefinition td = amd.AwakeMethodDef.DeclaringType;
                MethodDefinition initializeMd = td.GetMethod(methodName);
                MethodReference initializeMr = CodegenSession.ImportReference(initializeMd);

                ILProcessor processor = amd.AwakeMethodDef.Body.GetILProcessor();
                processor.Emit(OpCodes.Ldarg_0);
                processor.Emit(OpCodes.Call, initializeMr);
            }
        }

        /// <summary>
        /// Creates an 'NetworkInitialize' method which is called by the childmost class to initialize scripts on Awake.
        /// </summary>
        private void CreateNetworkInitializeMethods(TypeDefinition typeDef, out MethodDefinition networkInitializeInternalMd)
        {
            CreateMethod(NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            CreateMethod(NETWORKINITIALIZE_LATE_INTERNAL_NAME);
            networkInitializeInternalMd = CreateMethod(CodegenSession.NetworkBehaviourHelper.NetworkInitializeInternal_MethodRef.Name);

            MethodDefinition CreateMethod(string name)
            {
                MethodDefinition md = typeDef.GetMethod(name);
                //Already made.
                if (md != null)
                    return md;

                //Create new public virtual method and add it to typedef.
                md = new MethodDefinition(name,
                    PUBLIC_VIRTUAL_ATTRIBUTES,
                    typeDef.Module.TypeSystem.Void);
                typeDef.Methods.Add(md);

                //Emit ret into new method.
                ILProcessor processor = md.Body.GetILProcessor();
                //End of method return.
                processor.Emit(OpCodes.Ret);
                return md;
            }
        }

        /// <summary>
        /// Creates an 'NetworkInitialize' method which is called by the childmost class to initialize scripts on Awake.
        /// </summary>
        private void CallNetworkInitializeMethods(MethodDefinition networkInitializeInternalMd)
        {
            ILProcessor processor = networkInitializeInternalMd.Body.GetILProcessor();

            networkInitializeInternalMd.Body.Instructions.Clear();
            CallMethod(NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            CallMethod(NETWORKINITIALIZE_LATE_INTERNAL_NAME);
            processor.Emit(OpCodes.Ret);

            void CallMethod(string name)
            {
                MethodDefinition md = networkInitializeInternalMd.DeclaringType.GetMethod(name);
                MethodReference mr = CodegenSession.ImportReference(md);

                processor.Emit(OpCodes.Ldarg_0);
                processor.Emit(OpCodes.Callvirt, mr);
            }
        }

        /// <summary>
        /// Creates Awake method for and all parents of typeDef using the parentMostAwakeMethodDef as a template.
        /// </summary>
        /// <returns>True if successful.</returns>
        private bool CreateOrModifyAwakeMethods(TypeDefinition typeDef, ref List<AwakeMethodData> datas)
        {
            //Now update all scopes/create methods.
            TypeDefinition copyTypeDef = typeDef;
            do
            {
                MethodDefinition tmpMd = copyTypeDef.GetMethod(NetworkBehaviourHelper.AWAKE_METHOD_NAME);
                string logicMethodName = $"{NetworkBehaviourHelper.AWAKE_METHOD_NAME}___UserLogic";
                bool create = (tmpMd == null);

                //Awake is found.
                if (!create)
                {
                    if (tmpMd.ReturnType != copyTypeDef.Module.TypeSystem.Void)
                    {
                        CodegenSession.LogError($"IEnumerator Awake methods are not supported within NetworkBehaviours.");
                        return false;
                    }
                    tmpMd.Attributes = PUBLIC_VIRTUAL_ATTRIBUTES;
                }
                //No awake yet.
                else
                {
                    //Make awake.
                    tmpMd = new MethodDefinition(NetworkBehaviourHelper.AWAKE_METHOD_NAME, PUBLIC_VIRTUAL_ATTRIBUTES, copyTypeDef.Module.TypeSystem.Void);
                    copyTypeDef.Methods.Add(tmpMd);
                    ILProcessor processor = tmpMd.Body.GetILProcessor();
                    processor.Emit(OpCodes.Ret);
                }

                //If logic already exist then awake has been processed already.
                MethodDefinition logicMd = copyTypeDef.GetMethod(logicMethodName);
                if (logicMd == null)
                {
                    logicMd = CodegenSession.GeneralHelper.CopyMethod(tmpMd, logicMethodName, out _);
                    //Clear awakeMethod.
                    tmpMd.Body.Instructions.Clear();
                }
                datas.Add(new AwakeMethodData(tmpMd, logicMd, create));

                copyTypeDef = TypeDefinitionExtensionsOld.GetNextBaseClassToProcess(copyTypeDef);

            } while (copyTypeDef != null);

            return true;
        }

        /// <summary>
        /// Makes all Awake methods within typeDef and base classes public and virtual.
        /// </summary>
        /// <param name="typeDef"></param>
        internal void CreateFirstNetworkInitializeCall(TypeDefinition typeDef, MethodDefinition firstUserAwakeMethodDef, MethodDefinition firstNetworkInitializeMethodDef)
        {
            ILProcessor processor;
            //Get awake for current method.
            MethodDefinition thisAwakeMethodDef = typeDef.GetMethod(NetworkBehaviourHelper.AWAKE_METHOD_NAME);
            bool created = false;

            //If no awake then make one.
            if (thisAwakeMethodDef == null)
            {
                created = true;

                thisAwakeMethodDef = new MethodDefinition(NetworkBehaviourHelper.AWAKE_METHOD_NAME, PUBLIC_VIRTUAL_ATTRIBUTES,
                    typeDef.Module.TypeSystem.Void);
                thisAwakeMethodDef.Body.InitLocals = true;
                typeDef.Methods.Add(thisAwakeMethodDef);

                processor = thisAwakeMethodDef.Body.GetILProcessor();
                processor.Emit(OpCodes.Ret);
            }

            //MethodRefs for networkinitialize and awake.
            MethodReference networkInitializeMethodRef = typeDef.Module.ImportReference(firstNetworkInitializeMethodDef);

            processor = thisAwakeMethodDef.Body.GetILProcessor();
            //Create instructions for base call.
            List<Instruction> instructions = new List<Instruction>();
            instructions.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            instructions.Add(processor.Create(OpCodes.Call, networkInitializeMethodRef));

            /* If awake was created then make a call to the users
             * first awake. There's no reason to do this if awake
             * already existed because the user would have control
             * over making that call. */
            if (created && firstUserAwakeMethodDef != null)
            {
                MethodReference baseAwakeMethodRef = typeDef.Module.ImportReference(firstUserAwakeMethodDef);
                instructions.Add(processor.Create(OpCodes.Ldarg_0));//this.
                instructions.Add(processor.Create(OpCodes.Call, baseAwakeMethodRef));
            }

            processor.InsertFirst(instructions);
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/NetworkBehaviourSyncProcessor.cs ---
﻿using FishNet.CodeGenerating.Extension;
using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Configuring;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using FishNet.Transporting;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Rocks;
using MonoFN.Collections.Generic;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.CodeGenerating.Processing
{
    internal class NetworkBehaviourSyncProcessor
    {
        #region Reflection references.
        private TypeDefinition SyncBase_TypeDef;
        #endregion

        #region Private.
        /// <summary>
        /// Last instruction to read a sync type.
        /// </summary>
        private Instruction _lastReadInstruction;
        /// <summary>
        /// Sync objects, such as get and set, created during this process. Used to skip modifying created methods.
        /// </summary>
        private List<object> _createdSyncTypeMethodDefinitions = new List<object>();
        /// <summary>
        /// ReadSyncVar methods which have had their base call already made.
        /// </summary>
        private HashSet<MethodDefinition> _baseCalledReadSyncVars = new HashSet<MethodDefinition>();
        #endregion

        #region Const.
        private const string SYNCVAR_PREFIX = "syncVar___";
        private const string ACCESSOR_PREFIX = "sync___";
        private const string SETREGISTERED_METHOD_NAME = "SetRegistered";
        private const string INITIALIZEINSTANCE_METHOD_NAME = "InitializeInstance";
        private const string GETSERIALIZEDTYPE_METHOD_NAME = "GetSerializedType";
        #endregion

        internal bool ImportReferences()
        {
            System.Type syncBaseType = typeof(SyncBase);
            SyncBase_TypeDef = CodegenSession.ImportReference(syncBaseType).Resolve();

            return true;
        }

        /// <summary>
        /// Processes SyncVars and Objects.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="diagnostics"></param>
        internal bool Process(TypeDefinition typeDef, List<(SyncType, ProcessedSync)> allProcessedSyncs, ref uint syncTypeStartCount)
        {
            bool modified = false;
            _createdSyncTypeMethodDefinitions.Clear();
            _lastReadInstruction = null;

            FieldDefinition[] fieldDefs = typeDef.Fields.ToArray();
            foreach (FieldDefinition fd in fieldDefs)
            {
                CustomAttribute syncAttribute;
                SyncType st = GetSyncType(fd, true, out syncAttribute);
                //Not a sync type field.
                if (st == SyncType.Unset)
                    continue;

                if (st == SyncType.Variable)
                {
                    if (TryCreateSyncVar(syncTypeStartCount, allProcessedSyncs, typeDef, fd, syncAttribute))
                        syncTypeStartCount++;
                }
                else if (st == SyncType.List || st == SyncType.HashSet)
                {
                    if (TryCreateSyncList_SyncHashSet(syncTypeStartCount, allProcessedSyncs, typeDef, fd, syncAttribute, st))
                        syncTypeStartCount++;
                }
                else if (st == SyncType.Dictionary)
                {
                    if (TryCreateSyncDictionary(syncTypeStartCount, allProcessedSyncs, typeDef, fd, syncAttribute))
                        syncTypeStartCount++;
                }
                else if (st == SyncType.Custom)
                {
                    if (TryCreateCustom(syncTypeStartCount, allProcessedSyncs, typeDef, fd, syncAttribute))
                        syncTypeStartCount++;
                }

                modified = true;
            }

            return modified;
        }

        /// <summary>
        /// Gets number of SyncTypes by checking for SyncVar/Object attributes. This does not perform error checking.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal uint GetSyncTypeCount(TypeDefinition typeDef)
        {
            uint count = 0;
            foreach (FieldDefinition fd in typeDef.Fields)
            {
                if (HasSyncTypeAttributeUnchecked(fd))
                    count++;
            }

            return count;
        }

        /// <summary>
        /// Replaces GetSets for methods which may use a SyncType.
        /// </summary>
        internal bool ReplaceGetSets(TypeDefinition typeDef, List<(SyncType, ProcessedSync)> allProcessedSyncs)
        {
            bool modified = false;

            List<MethodDefinition> modifiableMethods = GetModifiableMethods(typeDef);
            modified |= ReplaceGetSetDirties(modifiableMethods, allProcessedSyncs);

            return modified;
        }

        /// <summary>
        /// Gets SyncType fieldDef is.
        /// </summary>
        /// <param name="fieldDef"></param>
        /// <param name="diagnostics"></param>
        /// <returns></returns>
        internal SyncType GetSyncType(FieldDefinition fieldDef, bool validate, out CustomAttribute syncAttribute)
        {
            syncAttribute = null;
            //If the generated field for syncvars ignore it.
            if (fieldDef.Name.StartsWith(SYNCVAR_PREFIX))
                return SyncType.Unset;

            bool syncObject;
            bool error;
            syncAttribute = GetSyncTypeAttribute(fieldDef, out syncObject, out error);
            //Do not perform further checks if an error occurred.
            if (error)
                return SyncType.Unset;
            /* If if attribute is null the code must progress
             * to throw errors when user creates a sync type
             * without using the attribute. */
            if (!validate)
            {
                return (syncAttribute == null) ? SyncType.Unset : SyncType.Custom;
            }
            else
            {
                /* If no attribute make sure the field does not implement
                 * ISyncType. If it does then a SyncObject or SyncVar attribute
                 * should exist. */
                if (syncAttribute == null)
                {
                    TypeDefinition foundSyncBaseTd = fieldDef.FieldType.CachedResolve().GetClassInInheritance(SyncBase_TypeDef);
                    if (foundSyncBaseTd != null && foundSyncBaseTd.ImplementsInterface<ISyncType>())
                        CodegenSession.LogError($"{fieldDef.Name} within {fieldDef.DeclaringType.Name} is a SyncType but is missing the [SyncVar] or [SyncObject] attribute.");

                    return SyncType.Unset;
                }

                /* If the attribute is not [SyncObject] then the attribute
                 * is [SyncVar]. Only checks that need to be made is to make sure
                 * the user is not using a SyncVar attribute when they should be using a SyncObject attribute. */
                if (syncAttribute != null && !syncObject)
                {
                    //Make sure syncvar attribute isnt on a sync object.
                    if (GetSyncObjectSyncType(syncAttribute) != SyncType.Unset)
                    {
                        CodegenSession.LogError($"{fieldDef.Name} within {fieldDef.DeclaringType.Name} uses a [SyncVar] attribute but should be using [SyncObject].");
                        return SyncType.Unset;
                    }
                    else
                        return SyncType.Variable;
                }

                /* If here could be syncObject
                 * or attribute might be null. */
                if (fieldDef.FieldType.CachedResolve().ImplementsInterfaceRecursive<ISyncType>())
                    return GetSyncObjectSyncType(syncAttribute);

                SyncType GetSyncObjectSyncType(CustomAttribute sa)
                {
                    //If attribute is null then throw error.
                    if (sa == null)
                    {
                        CodegenSession.LogError($"{fieldDef.Name} within {fieldDef.DeclaringType.Name} is a SyncType but [SyncObject] attribute was not found.");
                        return SyncType.Unset;
                    }

                    if (fieldDef.FieldType.Name == CodegenSession.ObjectHelper.SyncList_Name)
                    {
                        return SyncType.List;
                    }
                    else if (fieldDef.FieldType.Name == CodegenSession.ObjectHelper.SyncDictionary_Name)
                    {
                        return SyncType.Dictionary;
                    }
                    else if (fieldDef.FieldType.Name == CodegenSession.ObjectHelper.SyncHashSet_Name)
                    {
                        return SyncType.HashSet;
                    }
                    //Custom types must also implement ICustomSync.
                    else if (fieldDef.FieldType.CachedResolve().ImplementsInterfaceRecursive<ICustomSync>())
                    {
                        return SyncType.Custom;
                    }
                    else
                    {
                        return SyncType.Unset;
                    }
                }

                //Fall through.
                if (syncAttribute != null)
                    CodegenSession.LogError($"SyncObject attribute found on {fieldDef.Name} within {fieldDef.DeclaringType.Name} but type {fieldDef.FieldType.Name} does not inherit from SyncBase, or if a custom type does not implement ICustomSync.");

                return SyncType.Unset;
            }

        }

        /// <summary>
        /// Tries to create a SyncList.
        /// </summary>
        private bool TryCreateCustom(uint syncTypeCount, List<(SyncType, ProcessedSync)> allProcessedSyncs, TypeDefinition typeDef, FieldDefinition originalFieldDef, CustomAttribute syncAttribute)
        {
            //Get the serialized type.
            MethodDefinition getSerialziedTypeMd = originalFieldDef.FieldType.CachedResolve().GetMethod(GETSERIALIZEDTYPE_METHOD_NAME);
            MethodReference getSerialziedTypeMr = CodegenSession.ImportReference(getSerialziedTypeMd);
            Collection<Instruction> instructions = getSerialziedTypeMr.CachedResolve().Body.Instructions;

            bool canSerialize = false;
            TypeReference serializedDataTypeRef = null;
            /* If the user is returning null then
             * they are indicating a custom serializer does not
             * have to be implemented. */
            if (instructions.Count == 2 && instructions[0].OpCode == OpCodes.Ldnull && instructions[1].OpCode == OpCodes.Ret)
            {
                canSerialize = true;
            }
            //If not returning null then make a serializer for return type.
            else
            {
                foreach (Instruction item in instructions)
                {
                    //This token references the type.
                    if (item.OpCode == OpCodes.Ldtoken)
                    {
                        TypeReference importedTr = null;
                        if (item.Operand is TypeDefinition td)
                            importedTr = CodegenSession.ImportReference(td);
                        else if (item.Operand is TypeReference tr)
                            importedTr = CodegenSession.ImportReference(tr);

                        if (importedTr != null)
                        {
                            serializedDataTypeRef = importedTr;
                            canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(serializedDataTypeRef, true);
                        }
                    }
                }
            }

            //Wasn't able to determine serialized type, or create it.
            if (!canSerialize)
            {
                CodegenSession.LogError($"Custom SyncObject {originalFieldDef.Name} data type {serializedDataTypeRef.FullName} does not support serialization. Use a supported type or create a custom serializer.");
                return false;
            }

            bool result = InitializeCustom(syncTypeCount, typeDef, originalFieldDef, syncAttribute);
            if (result)
                allProcessedSyncs.Add((SyncType.Custom, null));
            return result;
        }

        /// <summary>
        /// Tries to create a SyncList.
        /// </summary>
        private bool TryCreateSyncList_SyncHashSet(uint syncTypeCount, List<(SyncType, ProcessedSync)> allProcessedSyncs, TypeDefinition typeDef, FieldDefinition originalFieldDef, CustomAttribute syncAttribute, SyncType syncType)
        {
            //Import fieldType to module.
            TypeReference fieldTypeTr = CodegenSession.ImportReference(originalFieldDef.FieldType);
            //Make sure type can be serialized.
            GenericInstanceType tmpGenerinstanceType = fieldTypeTr as GenericInstanceType;
            //this returns the correct data type, eg SyncList<int> would return int.
            TypeReference dataTypeRef = CodegenSession.ImportReference(tmpGenerinstanceType.GenericArguments[0]);

            bool canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(dataTypeRef, true);
            if (!canSerialize)
            {
                CodegenSession.LogError($"SyncObject {originalFieldDef.Name} data type {dataTypeRef.FullName} does not support serialization. Use a supported type or create a custom serializer.");
                return false;
            }

            bool result = InitializeSyncList_SyncHashSet(syncTypeCount, typeDef, originalFieldDef, syncAttribute);
            if (result)
                allProcessedSyncs.Add((syncType, null));
            return result;
        }

        /// <summary>
        /// Tries to create a SyncDictionary.
        /// </summary>
        private bool TryCreateSyncDictionary(uint syncTypeCount, List<(SyncType, ProcessedSync)> allProcessedSyncs, TypeDefinition typeDef, FieldDefinition originalFieldDef, CustomAttribute syncAttribute)
        {
            //Make sure type can be serialized.
            GenericInstanceType tmpGenerinstanceType = originalFieldDef.FieldType as GenericInstanceType;
            //this returns the correct data type, eg SyncList<int> would return int.
            TypeReference keyTypeRef = tmpGenerinstanceType.GenericArguments[0];
            TypeReference valueTypeRef = tmpGenerinstanceType.GenericArguments[1];

            bool canSerialize;
            //Check key serializer.
            canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(keyTypeRef, true);
            if (!canSerialize)
            {
                CodegenSession.LogError($"SyncObject {originalFieldDef.Name} key type {keyTypeRef.FullName} does not support serialization. Use a supported type or create a custom serializer.");
                return false;
            }
            //Check value serializer.
            canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(valueTypeRef, true);
            if (!canSerialize)
            {
                CodegenSession.LogError($"SyncObject {originalFieldDef.Name} value type {valueTypeRef.FullName} does not support serialization. Use a supported type or create a custom serializer.");
                return false;
            }

            bool result = InitializeSyncDictionary(syncTypeCount, typeDef, originalFieldDef, syncAttribute);
            if (result)
                allProcessedSyncs.Add((SyncType.Dictionary, null));
            return result;
        }

        /// <summary>
        /// Tries to create a SyncVar.
        /// </summary>
        private bool TryCreateSyncVar(uint syncCount, List<(SyncType, ProcessedSync)> allProcessedSyncs, TypeDefinition typeDef, FieldDefinition fieldDef, CustomAttribute syncAttribute)
        {
            bool canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(fieldDef.FieldType, true);
            if (!canSerialize)
            {
                CodegenSession.LogError($"SyncVar {fieldDef.FullName} field type {fieldDef.FieldType.FullName} does not support serialization. Use a supported type or create a custom serializer.");
                return false;
            }

            if (CodegenSession.Module != typeDef.Module)
            {
                //Only display warning if field is exposed.
                if (!fieldDef.Attributes.HasFlag(FieldAttributes.Private))
                    CodegenSession.DifferentAssemblySyncVars.Add(fieldDef);
                return false;
            }

            FieldDefinition syncVarFd;
            MethodReference accessorSetValueMr;
            MethodReference accessorGetValueMr;
            bool created = CreateSyncVar(syncCount, typeDef, fieldDef, syncAttribute, out syncVarFd, out accessorSetValueMr, out accessorGetValueMr);
            if (created)
            {
                FieldReference originalFr = CodegenSession.ImportReference(fieldDef);
                allProcessedSyncs.Add((SyncType.Variable, new ProcessedSync(originalFr, syncVarFd, accessorSetValueMr, accessorGetValueMr)));
            }

            return created;
        }

        /// <summary>
        /// Returns if fieldDef has a SyncType attribute. No error checking is performed.
        /// </summary>
        /// <param name="fieldDef"></param>
        /// <returns></returns>
        private bool HasSyncTypeAttributeUnchecked(FieldDefinition fieldDef)
        {
            foreach (CustomAttribute customAttribute in fieldDef.CustomAttributes)
            {
                if (CodegenSession.AttributeHelper.IsSyncVarAttribute(customAttribute.AttributeType.FullName))
                    return true;
                else if (CodegenSession.AttributeHelper.IsSyncObjectAttribute(customAttribute.AttributeType.FullName))
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns the syncvar attribute on a method, if one exist. Otherwise returns null.
        /// </summary>
        /// <param name="fieldDef"></param>
        /// <returns></returns>
        private CustomAttribute GetSyncTypeAttribute(FieldDefinition fieldDef, out bool syncObject, out bool error)
        {
            CustomAttribute foundAttribute = null;
            //Becomes true if an error occurred during this process.
            error = false;
            syncObject = false;

            foreach (CustomAttribute customAttribute in fieldDef.CustomAttributes)
            {
                if (CodegenSession.AttributeHelper.IsSyncVarAttribute(customAttribute.AttributeType.FullName))
                    syncObject = false;
                else if (CodegenSession.AttributeHelper.IsSyncObjectAttribute(customAttribute.AttributeType.FullName))
                    syncObject = true;
                else
                    continue;

                //A syncvar attribute already exist.
                if (foundAttribute != null)
                {
                    CodegenSession.LogError($"{fieldDef.Name} cannot have multiple SyncType attributes.");
                    error = true;
                }
                //Static.
                if (fieldDef.IsStatic)
                {
                    CodegenSession.LogError($"{fieldDef.Name} SyncType cannot be static.");
                    error = true;
                }
                //Generic.
                if (fieldDef.FieldType.IsGenericParameter)
                {
                    CodegenSession.LogError($"{fieldDef.Name} SyncType cannot be be generic.");
                    error = true;
                }
                //SyncObject readonly check.
                if (syncObject && !fieldDef.Attributes.HasFlag(FieldAttributes.InitOnly))
                {
                    CodegenSession.LogError($"{fieldDef.Name} SyncObject must be readonly.");
                    error = true;
                }

                //If all checks passed.
                if (!error)
                    foundAttribute = customAttribute;
            }

            //If an error occurred then reset results.
            if (error)
                foundAttribute = null;

            return foundAttribute;
        }

        /// <summary>
        /// Creates a syncVar class for the user's syncvar.
        /// </summary>
        /// <param name="originalFieldDef"></param>
        /// <param name="syncTypeAttribute"></param>
        /// <returns></returns>
        private bool CreateSyncVar(uint syncCount, TypeDefinition typeDef, FieldDefinition originalFieldDef, CustomAttribute syncTypeAttribute, out FieldDefinition createdSyncVarFd, out MethodReference accessorSetValueMethodRef, out MethodReference accessorGetValueMethodRef)
        {
            accessorGetValueMethodRef = null;
            accessorSetValueMethodRef = null;
            CreatedSyncVar createdSyncVar;
            createdSyncVarFd = CreateSyncVarFieldDefinition(typeDef, originalFieldDef, out createdSyncVar);

            if (createdSyncVarFd != null)
            {
                MethodReference hookMr = GetSyncVarHookMethodReference(typeDef, originalFieldDef, syncTypeAttribute);
                createdSyncVar.HookMr = hookMr;

                //If accessor was made add it's methods to createdSyncTypeObjects.
                if (CreateSyncVarAccessor(originalFieldDef, createdSyncVarFd, createdSyncVar, out accessorGetValueMethodRef,
                    out accessorSetValueMethodRef, hookMr) != null)
                {
                    _createdSyncTypeMethodDefinitions.Add(accessorGetValueMethodRef.CachedResolve());
                    _createdSyncTypeMethodDefinitions.Add(accessorSetValueMethodRef.CachedResolve());
                }

                InitializeSyncVar(syncCount, createdSyncVarFd, typeDef, originalFieldDef, syncTypeAttribute, createdSyncVar);

                MethodDefinition syncVarReadMd = CreateSyncVarRead(typeDef, syncCount, originalFieldDef, accessorSetValueMethodRef);
                if (syncVarReadMd != null)
                    _createdSyncTypeMethodDefinitions.Add(syncVarReadMd);

                return true;
            }
            else
            {
                return false;
            }

        }

        /// <summary>
        /// Creates or gets a SyncType class for originalFieldDef.
        /// </summary>
        /// <returns></returns>  
        private FieldDefinition CreateSyncVarFieldDefinition(TypeDefinition typeDef, FieldDefinition originalFieldDef, out CreatedSyncVar createdSyncVar)
        {
            createdSyncVar = CodegenSession.CreatedSyncVarGenerator.GetCreatedSyncVar(originalFieldDef, true);
            if (createdSyncVar == null)
                return null;

            FieldDefinition createdFieldDef = new FieldDefinition($"{SYNCVAR_PREFIX}{originalFieldDef.Name}", originalFieldDef.Attributes, createdSyncVar.SyncVarGit);
            if (createdFieldDef == null)
            {
                CodegenSession.LogError($"Could not create field for Sync type {originalFieldDef.FieldType.FullName}, name of {originalFieldDef.Name}.");
                return null;
            }

            typeDef.Fields.Add(createdFieldDef);
            return createdFieldDef;
        }

        /// <summary>
        /// Validates and gets the hook MethodReference for a SyncVar if available.
        /// </summary>
        /// <param name="moduleDef"></param>
        /// <param name="typeDef"></param>
        /// <param name="attribute"></param>
        /// <returns></returns>
        private MethodReference GetSyncVarHookMethodReference(TypeDefinition typeDef, FieldDefinition originalFieldDef, CustomAttribute attribute)
        {
            string hook = attribute.GetField("OnChange", string.Empty);
            //No hook is specified.
            if (string.IsNullOrEmpty(hook))
                return null;

            MethodDefinition md = typeDef.GetMethod(hook);

            if (md != null)
            {
                string incorrectParametersMsg = $"OnChange method for {originalFieldDef.FullName} must contain 3 parameters in order of {originalFieldDef.FieldType.Name} oldValue, {originalFieldDef.FieldType.Name} newValue, {CodegenSession.Module.TypeSystem.Boolean} asServer.";
                //Not correct number of parameters.
                if (md.Parameters.Count != 3)
                {
                    CodegenSession.LogError(incorrectParametersMsg);
                    return null;
                }
                /* Check if any parameters are not
                 * the expected type. */
                if (md.Parameters[0].ParameterType.CachedResolve() != originalFieldDef.FieldType.CachedResolve() ||
                    md.Parameters[1].ParameterType.CachedResolve() != originalFieldDef.FieldType.CachedResolve() ||
                    md.Parameters[2].ParameterType.CachedResolve() != CodegenSession.Module.TypeSystem.Boolean.CachedResolve())
                {
                    CodegenSession.LogError(incorrectParametersMsg);
                    return null;
                }

                //If here everything checks out, return a method reference to hook method.
                return CodegenSession.ImportReference(md);
            }
            //Hook specified but no method found.
            else
            {
                CodegenSession.LogError($"Could not find method name {hook} for SyncType {originalFieldDef.FullName}.");
                return null;
            }
        }

        /// <summary>
        /// Creates accessor for a SyncVar.
        /// </summary>
        /// <returns></returns>
        private FieldDefinition CreateSyncVarAccessor(FieldDefinition originalFd, FieldDefinition createdSyncVarFd, CreatedSyncVar createdSyncVar, out MethodReference accessorGetValueMr, out MethodReference accessorSetValueMr, MethodReference hookMr)
        {
            /* Create and add property definition. */
            PropertyDefinition createdPropertyDef = new PropertyDefinition($"SyncAccessor_{originalFd.Name}", PropertyAttributes.None, originalFd.FieldType);
            createdPropertyDef.DeclaringType = originalFd.DeclaringType;
            //add the methods and property to the type.
            originalFd.DeclaringType.Properties.Add(createdPropertyDef);

            ILProcessor processor;

            /* Get method for property definition. */
            MethodDefinition createdGetMethodDef = originalFd.DeclaringType.AddMethod($"{ACCESSOR_PREFIX}get_value_{originalFd.Name}", MethodAttributes.Public |
                    MethodAttributes.SpecialName | MethodAttributes.HideBySig,
                    originalFd.FieldType);
            createdGetMethodDef.SemanticsAttributes = MethodSemanticsAttributes.Getter;

            processor = createdGetMethodDef.Body.GetILProcessor();
            processor.Emit(OpCodes.Ldarg_0); //this.
            processor.Emit(OpCodes.Ldfld, originalFd);
            processor.Emit(OpCodes.Ret);
            accessorGetValueMr = CodegenSession.ImportReference(createdGetMethodDef);
            //Add getter to properties.
            createdPropertyDef.GetMethod = createdGetMethodDef;

            /* Set method. */
            //Create the set method
            MethodDefinition createdSetMethodDef = originalFd.DeclaringType.AddMethod($"{ACCESSOR_PREFIX}set_value_{originalFd.Name}", MethodAttributes.Public |
                    MethodAttributes.SpecialName |
                    MethodAttributes.HideBySig);
            createdSetMethodDef.SemanticsAttributes = MethodSemanticsAttributes.Setter;

            ParameterDefinition valueParameterDef = CodegenSession.GeneralHelper.CreateParameter(createdSetMethodDef, originalFd.FieldType, "value");
            ParameterDefinition calledByUserParameterDef = CodegenSession.GeneralHelper.CreateParameter(createdSetMethodDef, typeof(bool), "asServer");
            processor = createdSetMethodDef.Body.GetILProcessor();

            /* Assign to new value. Do this first because SyncVar<T> calls hook 
             * and value needs to be updated before hook. Only update
             * value if calledByUser(asServer) or (!calledByUser && !base.IsServer).
             * This ensures clientHost will not overwrite server value. */

            Instruction afterChangeFieldInst = processor.Create(OpCodes.Nop);
            Instruction beforeChangeFieldInst = processor.Create(OpCodes.Nop);
            //if (calledByUser || !base.IsServer)
            processor.Emit(OpCodes.Ldarg, calledByUserParameterDef);
            processor.Emit(OpCodes.Brtrue, beforeChangeFieldInst);
            processor.Emit(OpCodes.Ldarg_0); //this.            
            processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.IsServer_MethodRef);
            processor.Emit(OpCodes.Brtrue, afterChangeFieldInst);

            //      _originalField = value;
            processor.Append(beforeChangeFieldInst);
            processor.Emit(OpCodes.Ldarg_0); //this.
            processor.Emit(OpCodes.Ldarg, valueParameterDef);
            processor.Emit(OpCodes.Stfld, originalFd);
            processor.Append(afterChangeFieldInst);

            Instruction retInst = processor.Create(OpCodes.Ret);

            if (!Configuration.ConfigurationData.IsBuilding)
            {
                processor.Emit(OpCodes.Call, CodegenSession.GeneralHelper.Application_IsPlaying_MethodRef);
                processor.Emit(OpCodes.Brfalse_S, retInst);
            }
            //      SyncVar<>.SetValue(....);
            processor.Emit(OpCodes.Ldarg_0); //this.
            processor.Emit(OpCodes.Ldfld, createdSyncVarFd);
            processor.Emit(OpCodes.Ldarg, valueParameterDef);
            processor.Emit(OpCodes.Ldarg, calledByUserParameterDef);
            processor.Emit(OpCodes.Callvirt, createdSyncVar.SetValueMr);

            processor.Append(retInst);
            accessorSetValueMr = CodegenSession.ImportReference(createdSetMethodDef);
            //Add setter to properties.
            createdPropertyDef.SetMethod = createdSetMethodDef;

            return originalFd;
        }

        /// <summary>
        /// Sets methods used from SyncBase for typeDef.
        /// </summary>
        /// <returns></returns>
        internal bool SetSyncBaseMethods(TypeDefinition typeDef, out MethodReference setRegisteredMr, out MethodReference initializeInstanceMr)
        {
            setRegisteredMr = null;
            initializeInstanceMr = null;
            //Find the SyncBase class.
            TypeDefinition syncBaseTd = null;
            TypeDefinition copyTd = typeDef;
            do
            {
                if (copyTd.Name == nameof(SyncBase))
                {
                    syncBaseTd = copyTd;
                    break;
                }
                copyTd = copyTd.GetNextBaseTypeDefinition();
            } while (copyTd != null);

            //If SyncBase isn't found.
            if (syncBaseTd == null)
            {
                CodegenSession.LogError($"Could not find SyncBase within type {typeDef.FullName}.");
                return false;
            }
            else
            {
                MethodDefinition tmpMd;
                //InitializeInstance.
                tmpMd = syncBaseTd.GetMethod(INITIALIZEINSTANCE_METHOD_NAME);
                initializeInstanceMr = CodegenSession.ImportReference(tmpMd);
                //SetSyncIndex.
                tmpMd = syncBaseTd.GetMethod(SETREGISTERED_METHOD_NAME);
                setRegisteredMr = CodegenSession.ImportReference(tmpMd);
                return true;
            }

        }

        /// <summary>
        /// Initializes a custom SyncObject.
        /// </summary>
        internal bool InitializeCustom(uint syncCount, TypeDefinition typeDef, FieldDefinition originalFieldDef, CustomAttribute attribute)
        {
            float sendRate = 0.1f;
            WritePermission writePermissions = WritePermission.ServerOnly;
            ReadPermission readPermissions = ReadPermission.Observers;
            Channel channel = Channel.Reliable;
            //If attribute isn't null then override values.
            if (attribute != null)
            {
                sendRate = attribute.GetField("SendRate", 0.1f);
                writePermissions = WritePermission.ServerOnly;
                readPermissions = attribute.GetField("ReadPermissions", ReadPermission.Observers);
                channel = Channel.Reliable; //attribute.GetField("Channel", Channel.Reliable);
            }

            //Set needed methods from syncbase.
            MethodReference setSyncIndexMr;
            MethodReference initializeInstanceMr;
            if (!SetSyncBaseMethods(originalFieldDef.FieldType.CachedResolve(), out setSyncIndexMr, out initializeInstanceMr))
                return false;

            MethodDefinition injectionMethodDef;
            ILProcessor processor;

            uint hash = (uint)syncCount;
            List<Instruction> insts = new List<Instruction>();

            /* Initialize with attribute settings. */
            injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            processor = injectionMethodDef.Body.GetILProcessor();
            //

            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldfld, originalFieldDef));
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this again for NetworkBehaviour.
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)hash));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)writePermissions));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)readPermissions));
            insts.Add(processor.Create(OpCodes.Ldc_R4, sendRate));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)channel));
            insts.Add(processor.Create(OpCodes.Ldc_I4_1)); //true for syncObject.
            insts.Add(processor.Create(OpCodes.Call, initializeInstanceMr));
            processor.InsertFirst(insts);

            insts.Clear();
            /* Set NetworkBehaviour and SyncIndex to use. */
            injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_LATE_INTERNAL_NAME);
            processor = injectionMethodDef.Body.GetILProcessor();
            //
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldfld, originalFieldDef));
            insts.Add(processor.Create(OpCodes.Callvirt, setSyncIndexMr));

            processor.InsertLast(insts);

            return true;
        }

        /// <summary>
        /// Initializes a SyncList.
        /// </summary>
        internal bool InitializeSyncList_SyncHashSet(uint syncCount, TypeDefinition typeDef, FieldDefinition originalFieldDef, CustomAttribute attribute)
        {
            float sendRate = 0.1f;
            WritePermission writePermissions = WritePermission.ServerOnly;
            ReadPermission readPermissions = ReadPermission.Observers;
            Channel channel = Channel.Reliable;
            //If attribute isn't null then override values.
            if (attribute != null)
            {
                sendRate = attribute.GetField("SendRate", 0.1f);
                writePermissions = WritePermission.ServerOnly;
                readPermissions = attribute.GetField("ReadPermissions", ReadPermission.Observers);
                channel = Channel.Reliable; //attribute.GetField("Channel", Channel.Reliable);
            }

            //This import shouldn't be needed but cecil is stingy so rather be safe than sorry.
            CodegenSession.ImportReference(originalFieldDef);

            //Set needed methods from syncbase.
            MethodReference setSyncIndexMr;
            MethodReference initializeInstanceMr;
            if (!SetSyncBaseMethods(originalFieldDef.FieldType.CachedResolve(), out setSyncIndexMr, out initializeInstanceMr))
                return false;

            MethodDefinition injectionMethodDef;
            ILProcessor processor;

            uint hash = (uint)syncCount;
            List<Instruction> insts = new List<Instruction>();

            /* Initialize with attribute settings. */
            injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            processor = injectionMethodDef.Body.GetILProcessor();

            //InitializeInstance.
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldfld, originalFieldDef));
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this again for NetworkBehaviour.
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)hash));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)writePermissions));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)readPermissions));
            insts.Add(processor.Create(OpCodes.Ldc_R4, sendRate));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)channel));
            insts.Add(processor.Create(OpCodes.Ldc_I4_1)); //true for syncObject.
            insts.Add(processor.Create(OpCodes.Call, initializeInstanceMr));
            processor.InsertFirst(insts);

            insts.Clear();
            /* Set NetworkBehaviour and SyncIndex to use. */
            injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_LATE_INTERNAL_NAME);
            processor = injectionMethodDef.Body.GetILProcessor();

            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldfld, originalFieldDef));
            insts.Add(processor.Create(OpCodes.Callvirt, setSyncIndexMr));

            processor.InsertLast(insts);

            return true;
        }

        /// <summary>
        /// Initializes a SyncDictionary.
        /// </summary>
        internal bool InitializeSyncDictionary(uint syncCount, TypeDefinition typeDef, FieldDefinition originalFieldDef, CustomAttribute attribute)
        {
            float sendRate = 0.1f;
            WritePermission writePermissions = WritePermission.ServerOnly;
            ReadPermission readPermissions = ReadPermission.Observers;
            Channel channel = Channel.Reliable;
            //If attribute isn't null then override values.
            if (attribute != null)
            {
                sendRate = attribute.GetField("SendRate", 0.1f);
                writePermissions = WritePermission.ServerOnly;
                readPermissions = attribute.GetField("ReadPermissions", ReadPermission.Observers);
                channel = Channel.Reliable; //attribute.GetField("Channel", Channel.Reliable);
            }

            //This import shouldn't be needed but cecil is stingy so rather be safe than sorry.
            CodegenSession.ImportReference(originalFieldDef);

            //Set needed methods from syncbase.
            MethodReference setRegisteredMr;
            MethodReference initializeInstanceMr;
            if (!SetSyncBaseMethods(originalFieldDef.FieldType.CachedResolve(), out setRegisteredMr, out initializeInstanceMr))
                return false;

            MethodDefinition injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            ILProcessor processor = injectionMethodDef.Body.GetILProcessor();

            uint hash = (uint)syncCount;
            List<Instruction> insts = new List<Instruction>();

            /* Initialize with attribute settings. */
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldfld, originalFieldDef));
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this again for NetworkBehaviour.
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)hash));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)writePermissions));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)readPermissions));
            insts.Add(processor.Create(OpCodes.Ldc_R4, sendRate));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)channel));
            insts.Add(processor.Create(OpCodes.Ldc_I4_1)); //true for syncObject.
            insts.Add(processor.Create(OpCodes.Call, initializeInstanceMr));
            processor.InsertFirst(insts);

            insts.Clear();
            /* Set NetworkBehaviour and SyncIndex to use. */
            injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_LATE_INTERNAL_NAME);
            processor = injectionMethodDef.Body.GetILProcessor();

            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldfld, originalFieldDef));
            insts.Add(processor.Create(OpCodes.Callvirt, setRegisteredMr));

            processor.InsertFirst(insts);

            return true;
        }

        /// <summary>
        /// Initializes a SyncVar<>.
        /// </summary>
        internal void InitializeSyncVar(uint syncCount, FieldDefinition createdFd, TypeDefinition typeDef, FieldDefinition originalFd, CustomAttribute attribute, CreatedSyncVar createdSyncVar)
        {
            //Get all possible attributes.
            float sendRate = attribute.GetField("SendRate", 0.1f);
            WritePermission writePermissions = WritePermission.ServerOnly;
            ReadPermission readPermissions = attribute.GetField("ReadPermissions", ReadPermission.Observers);
            Channel channel = attribute.GetField("Channel", Channel.Reliable);

            MethodDefinition injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME);
            ILProcessor processor = injectionMethodDef.Body.GetILProcessor();

            uint hash = (uint)syncCount;
            List<Instruction> insts = new List<Instruction>();
            //Initialize fieldDef with values from attribute.
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this again for NetworkBehaviour.
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)hash));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)writePermissions));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)readPermissions));
            insts.Add(processor.Create(OpCodes.Ldc_R4, sendRate));
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)channel));
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldfld, originalFd)); //initial value.
            insts.Add(processor.Create(OpCodes.Newobj, createdSyncVar.ConstructorMr));
            insts.Add(processor.Create(OpCodes.Stfld, createdFd));

            //If there is a hook method.
            if (createdSyncVar.HookMr != null)
            {
                //SyncVar<dataType>.add_OnChanged (event).
                TypeDefinition svTd = CodegenSession.CreatedSyncVarGenerator.SyncVar_TypeRef.CachedResolve();
                GenericInstanceType svGit = svTd.MakeGenericInstanceType(new TypeReference[] { originalFd.FieldType });
                MethodDefinition addMd = svTd.GetMethod("add_OnChange");
                MethodReference genericAddMr = addMd.MakeHostInstanceGeneric(svGit);

                //Action<dataType, dataType, bool> constructor.
                GenericInstanceType actionGit = CodegenSession.GenericWriterHelper.ActionT3TypeRef.MakeGenericInstanceType(
                    originalFd.FieldType, originalFd.FieldType,
                    CodegenSession.GeneralHelper.GetTypeReference(typeof(bool)));
                MethodReference gitActionCtorMr = CodegenSession.GenericWriterHelper.ActionT3ConstructorMethodRef.MakeHostInstanceGeneric(actionGit);

                //      syncVar___field.OnChanged += UserHookMethod;
                insts.Add(processor.Create(OpCodes.Ldarg_0));
                insts.Add(processor.Create(OpCodes.Ldfld, createdFd));
                insts.Add(processor.Create(OpCodes.Ldarg_0));
                insts.Add(processor.Create(OpCodes.Ldftn, createdSyncVar.HookMr.CachedResolve()));
                insts.Add(processor.Create(OpCodes.Newobj, gitActionCtorMr));
                insts.Add(processor.Create(OpCodes.Callvirt, genericAddMr));
            }
            processor.InsertFirst(insts);

            insts.Clear();
            /* Set NetworkBehaviour and SyncIndex to use. */
            injectionMethodDef = typeDef.GetMethod(NetworkBehaviourProcessor.NETWORKINITIALIZE_LATE_INTERNAL_NAME);
            processor = injectionMethodDef.Body.GetILProcessor();

            //uint hash = originalFieldDef.FullName.GetStableHash32();
            //Set NB and SyncIndex to SyncVar<>.
            insts.Add(processor.Create(OpCodes.Ldarg_0)); //this.
            insts.Add(processor.Create(OpCodes.Ldfld, createdFd));
            insts.Add(processor.Create(OpCodes.Callvirt, createdSyncVar.SetSyncIndexMr));

            processor.InsertFirst(insts);
        }

        /// <summary>
        /// Replaces GetSets for methods which may use a SyncType.
        /// </summary>
        /// <param name="modifiableMethods"></param>
        /// <param name="processedSyncs"></param>
        internal bool ReplaceGetSetDirties(List<MethodDefinition> modifiableMethods, List<(SyncType, ProcessedSync)> processedSyncs)
        {
            //Build processed syncs into dictionary for quicker loookups.
            Dictionary<FieldReference, List<ProcessedSync>> processedLookup = new Dictionary<FieldReference, List<ProcessedSync>>();
            foreach ((SyncType st, ProcessedSync ps) in processedSyncs)
            {
                if (st != SyncType.Variable)
                    continue;

                List<ProcessedSync> result;
                if (!processedLookup.TryGetValue(ps.OriginalFieldRef, out result))
                {
                    result = new List<ProcessedSync>() { ps };
                    processedLookup.Add(ps.OriginalFieldRef, result);
                }

                result.Add(ps);
            }

            bool modified = false;
            foreach (MethodDefinition methodDef in modifiableMethods)
                modified |= ReplaceGetSetDirty(methodDef, processedLookup);

            return modified;
        }

        /// <summary>
        /// Replaces GetSets for a method which may use a SyncType.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="processedLookup"></param>
        private bool ReplaceGetSetDirty(MethodDefinition methodDef, Dictionary<FieldReference, List<ProcessedSync>> processedLookup)
        {
            if (methodDef == null)
            {
                CodegenSession.LogError($"An object expecting value was null. Please try saving your script again.");
                return false;
            }
            if (methodDef.IsAbstract)
                return false;
            if (_createdSyncTypeMethodDefinitions.Contains(methodDef))
                return false;
            if (methodDef.Name == NetworkBehaviourProcessor.NETWORKINITIALIZE_EARLY_INTERNAL_NAME)
                return false;

            bool modified = false;

            for (int i = 0; i < methodDef.Body.Instructions.Count; i++)
            {
                Instruction inst = methodDef.Body.Instructions[i];

                /* Loading a field. (Getter) */
                if (inst.OpCode == OpCodes.Ldfld && inst.Operand is FieldReference opFieldld)
                {
                    FieldReference resolvedOpField = opFieldld.CachedResolve();
                    if (resolvedOpField == null)
                        resolvedOpField = opFieldld.DeclaringType.CachedResolve().GetField(opFieldld.Name);

                    modified |= ProcessGetField(methodDef, i, resolvedOpField, processedLookup);
                }
                /* Load address, reference field. */
                else if (inst.OpCode == OpCodes.Ldflda && inst.Operand is FieldReference opFieldlda)
                {
                    FieldReference resolvedOpField = opFieldlda.CachedResolve();
                    if (resolvedOpField == null)
                        resolvedOpField = opFieldlda.DeclaringType.CachedResolve().GetField(opFieldlda.Name);

                    modified |= ProcessAddressField(methodDef, i, resolvedOpField, processedLookup);
                }
                /* Setting a field. (Setter) */
                else if (inst.OpCode == OpCodes.Stfld && inst.Operand is FieldReference opFieldst)
                {
                    FieldReference resolvedOpField = opFieldst.CachedResolve();
                    if (resolvedOpField == null)
                        resolvedOpField = opFieldst.DeclaringType.CachedResolve().GetField(opFieldst.Name);

                    modified |= ProcessSetField(methodDef, i, resolvedOpField, processedLookup);
                }

            }

            return modified;
        }

        /// <summary>
        /// Replaces Gets for a method which may use a SyncType.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="instructionIndex"></param>
        /// <param name="resolvedOpField"></param>
        /// <param name="processedLookup"></param>
        private bool ProcessGetField(MethodDefinition methodDef, int instructionIndex, FieldReference resolvedOpField, Dictionary<FieldReference, List<ProcessedSync>> processedLookup)
        {
            Instruction inst = methodDef.Body.Instructions[instructionIndex];

            //If was a replaced field.
            if (processedLookup.TryGetValue(resolvedOpField, out List<ProcessedSync> psLst))
            {
                ProcessedSync ps = GetProcessedSync(resolvedOpField, psLst);
                if (ps == null)
                    return false;
                //Don't modify the accessor method.
                if (ps.GetMethodRef.CachedResolve() == methodDef)
                    return false;

                //Generic type.
                if (resolvedOpField.DeclaringType.IsGenericInstance || resolvedOpField.DeclaringType.HasGenericParameters)
                {
                    FieldReference newField = inst.Operand as FieldReference;
                    GenericInstanceType genericType = (GenericInstanceType)newField.DeclaringType;
                    inst.OpCode = OpCodes.Callvirt;
                    inst.Operand = ps.GetMethodRef.MakeHostInstanceGeneric(genericType);
                }
                //Strong type.
                else
                {
                    inst.OpCode = OpCodes.Call;
                    inst.Operand = ps.GetMethodRef;
                }

                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Replaces Sets for a method which may use a SyncType.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="instructionIndex"></param>
        /// <param name="resolvedOpField"></param>
        /// <param name="processedLookup"></param>
        private bool ProcessSetField(MethodDefinition methodDef, int instructionIndex, FieldReference resolvedOpField, Dictionary<FieldReference, List<ProcessedSync>> processedLookup)
        {
            Instruction inst = methodDef.Body.Instructions[instructionIndex];

            /* Find any instructions that are jmp/breaking to the one we are modifying.
             * These need to be modified to call changed instruction. */
            HashSet<Instruction> brInstructions = new HashSet<Instruction>();
            foreach (Instruction item in methodDef.Body.Instructions)
            {
                bool canJmp = (item.OpCode == OpCodes.Br || item.OpCode == OpCodes.Brfalse || item.OpCode == OpCodes.Brfalse_S || item.OpCode == OpCodes.Brtrue || item.OpCode == OpCodes.Brtrue_S || item.OpCode == OpCodes.Br_S);
                if (!canJmp)
                    continue;
                if (item.Operand == null)
                    continue;
                if (item.Operand is Instruction jmpInst && jmpInst == inst)
                    brInstructions.Add(item);
            }

            //If was a replaced field.
            if (processedLookup.TryGetValue(resolvedOpField, out List<ProcessedSync> psLst))
            {
                ProcessedSync ps = GetProcessedSync(resolvedOpField, psLst);
                if (ps == null)
                    return false;
                //Don't modify the accessor method.
                if (ps.SetMethodRef.CachedResolve() == methodDef)
                    return false;
                ILProcessor processor = methodDef.Body.GetILProcessor();
                //Generic type.
                if (resolvedOpField.DeclaringType.IsGenericInstance || resolvedOpField.DeclaringType.HasGenericParameters)
                {
                    //Pass in true for as server.
                    Instruction boolTrueInst = processor.Create(OpCodes.Ldc_I4_1);
                    methodDef.Body.Instructions.Insert(instructionIndex, boolTrueInst);

                    FieldReference newField = inst.Operand as FieldReference;
                    GenericInstanceType genericType = (GenericInstanceType)newField.DeclaringType;
                    inst.OpCode = OpCodes.Callvirt;
                    inst.Operand = ps.SetMethodRef.MakeHostInstanceGeneric(genericType);
                }
                //Strong typed.
                else
                {
                    //Pass in true for as server.
                    Instruction boolTrueInst = processor.Create(OpCodes.Ldc_I4_1);
                    methodDef.Body.Instructions.Insert(instructionIndex, boolTrueInst);

                    inst.OpCode = OpCodes.Call;
                    inst.Operand = ps.SetMethodRef;
                }

                /* If any instructions are still pointing
                 * to modified value then they need to be
                 * redirected to the instruction right above it.
                 * This is because the boolTrueInst, to indicate
                 * value is being set as server. */
                foreach (Instruction item in brInstructions)
                {
                    if (item.Operand is Instruction jmpInst && jmpInst == inst)
                    {
                        //Use the same index that was passed in, which is now one before modified instruction.
                        Instruction newInst = methodDef.Body.Instructions[instructionIndex];
                        item.Operand = newInst;
                    }
                }

                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Replaces address Sets for a method which may use a SyncType.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="instructionIndex"></param>
        /// <param name="resolvedOpField"></param>
        /// <param name="processedLookup"></param>
        private bool ProcessAddressField(MethodDefinition methodDef, int instructionIndex, FieldReference resolvedOpField, Dictionary<FieldReference, List<ProcessedSync>> processedLookup)
        {
            Instruction inst = methodDef.Body.Instructions[instructionIndex];
            //Check if next instruction is Initobj, which would be setting a new instance.
            Instruction nextInstr = inst.Next;
            if (nextInstr.OpCode != OpCodes.Initobj)
                return false;

            //If was a replaced field.
            if (processedLookup.TryGetValue(resolvedOpField, out List<ProcessedSync> psLst))
            {
                ProcessedSync ps = GetProcessedSync(resolvedOpField, psLst);
                if (ps == null)
                    return false;
                //Don't modify the accessor method.
                if (ps.GetMethodRef.CachedResolve() == methodDef || ps.SetMethodRef.CachedResolve() == methodDef)
                    return false;

                ILProcessor processor = methodDef.Body.GetILProcessor();

                VariableDefinition tmpVariableDef = CodegenSession.GeneralHelper.CreateVariable(methodDef, resolvedOpField.FieldType);
                processor.InsertBefore(inst, processor.Create(OpCodes.Ldloca, tmpVariableDef));
                processor.InsertBefore(inst, processor.Create(OpCodes.Initobj, resolvedOpField.FieldType));
                processor.InsertBefore(inst, processor.Create(OpCodes.Ldloc, tmpVariableDef));
                Instruction newInstr = processor.Create(OpCodes.Call, ps.SetMethodRef);
                processor.InsertBefore(inst, newInstr);

                /* Pass in true for as server.
                 * The instruction index is 3 past ld. */
                Instruction boolTrueInst = processor.Create(OpCodes.Ldc_I4_1);
                methodDef.Body.Instructions.Insert(instructionIndex + 3, boolTrueInst);

                processor.Remove(inst);
                processor.Remove(nextInstr);

                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Calls ReadSyncVar going up the hierarchy.
        /// </summary>
        /// <param name="firstTypeDef"></param>
        internal void CallBaseReadSyncVar(TypeDefinition firstTypeDef)
        {
            //TypeDef which needs to make the base call.
            MethodDefinition callerMd = null;
            TypeDefinition copyTd = firstTypeDef;
            do
            {
                MethodDefinition readMd;

                readMd = copyTd.GetMethod(CodegenSession.NetworkBehaviourHelper.ReadSyncVar_MethodRef.Name);
                if (readMd != null)
                    callerMd = readMd;

                /* If baseType exist and it's not networkbehaviour
                 * look into calling the ReadSyncVar method. */
                if (copyTd.BaseType != null && copyTd.BaseType.FullName != CodegenSession.NetworkBehaviourHelper.FullName)
                {
                    readMd = copyTd.BaseType.CachedResolve().GetMethod(CodegenSession.NetworkBehaviourHelper.ReadSyncVar_MethodRef.Name);
                    //Not all classes will have syncvars to read.
                    if (!_baseCalledReadSyncVars.Contains(callerMd) && readMd != null && callerMd != null)
                    {
                        MethodReference baseReadMr = CodegenSession.ImportReference(readMd);
                        ILProcessor processor = callerMd.Body.GetILProcessor();
                        /* Calls base.ReadSyncVar and if result is true
                         * then exit methods. This is because a true return means the base
                         * was able to process the syncvar. */
                        List<Instruction> baseCallInsts = new List<Instruction>();
                        Instruction skipBaseReturn = processor.Create(OpCodes.Nop);
                        baseCallInsts.Add(processor.Create(OpCodes.Ldarg_0));
                        baseCallInsts.Add(processor.Create(OpCodes.Ldarg_1));
                        baseCallInsts.Add(processor.Create(OpCodes.Ldarg_2));
                        baseCallInsts.Add(processor.Create(OpCodes.Call, baseReadMr));
                        baseCallInsts.Add(processor.Create(OpCodes.Brfalse_S, skipBaseReturn));
                        baseCallInsts.Add(processor.Create(OpCodes.Ldc_I4_1));
                        baseCallInsts.Add(processor.Create(OpCodes.Ret));
                        baseCallInsts.Add(skipBaseReturn);
                        processor.InsertFirst(baseCallInsts);

                        _baseCalledReadSyncVars.Add(callerMd);
                    }
                }

                copyTd = TypeDefinitionExtensionsOld.GetNextBaseClassToProcess(copyTd);

            } while (copyTd != null);

        }

        /// <summary>
        /// Reads a PooledReader locally then sets value to the SyncVars accessor.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <param name="syncIndex"></param>
        /// <param name="originalFieldDef"></param>
        private MethodDefinition CreateSyncVarRead(TypeDefinition typeDef, uint syncIndex, FieldDefinition originalFieldDef, MethodReference accessorSetMethodRef)
        {
            Instruction jmpGoalInst;
            ILProcessor processor;

            //Get the read sync method, or create it if not present.
            MethodDefinition readSyncMethodDef = typeDef.GetMethod(CodegenSession.NetworkBehaviourHelper.ReadSyncVar_MethodRef.Name);
            if (readSyncMethodDef == null)
            {
                readSyncMethodDef = new MethodDefinition(CodegenSession.NetworkBehaviourHelper.ReadSyncVar_MethodRef.Name,
                (MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.Virtual),
                    typeDef.Module.TypeSystem.Void);
                readSyncMethodDef.ReturnType = CodegenSession.GeneralHelper.GetTypeReference(typeof(bool));

                CodegenSession.GeneralHelper.CreateParameter(readSyncMethodDef, typeof(PooledReader));
                CodegenSession.GeneralHelper.CreateParameter(readSyncMethodDef, typeof(uint));
                readSyncMethodDef.Body.InitLocals = true;

                processor = readSyncMethodDef.Body.GetILProcessor();
                //Return false as fall through.
                processor.Emit(OpCodes.Ldc_I4_0);
                processor.Emit(OpCodes.Ret);

                typeDef.Methods.Add(readSyncMethodDef);
            }
            //Already created. 
            else
            {
                processor = readSyncMethodDef.Body.GetILProcessor();
            }

            ParameterDefinition pooledReaderParameterDef = readSyncMethodDef.Parameters[0];
            ParameterDefinition indexParameterDef = readSyncMethodDef.Parameters[1];
            VariableDefinition nextValueVariableDef;
            List<Instruction> readInsts;

            /* Create a nop instruction placed at the first index of the method.
             * All instructions will be added before this, then the nop will be
             * removed afterwards. This ensures the newer instructions will
             * be above the previous. This let's the IL jump to a previously
             * created read instruction when the latest one fails conditions. */
            Instruction nopPlaceHolderInst = processor.Create(OpCodes.Nop);

            readSyncMethodDef.Body.Instructions.Insert(0, nopPlaceHolderInst);

            /* If there was a previously made read then set jmp goal to the first
             * condition for it. Otherwise set it to the last instruction, which would
             * be a ret. Keep in mind if ret has a value we must go back 2 index
             * rather than one. */
            jmpGoalInst = (_lastReadInstruction != null) ? _lastReadInstruction :
                readSyncMethodDef.Body.Instructions[readSyncMethodDef.Body.Instructions.Count - 2];

            //Check index first. if (index != syncIndex) return
            Instruction nextLastReadInstruction = processor.Create(OpCodes.Ldarg, indexParameterDef);
            processor.InsertBefore(jmpGoalInst, nextLastReadInstruction);

            uint hash = (uint)syncIndex;
            //uint hash = originalFieldDef.FullName.GetStableHash32();
            processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Ldc_I4, (int)hash));
            //processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Ldc_I4, syncIndex));
            processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Bne_Un, jmpGoalInst));
            //PooledReader.ReadXXXX()
            readInsts = CodegenSession.ReaderHelper.CreateRead(readSyncMethodDef, pooledReaderParameterDef,
                 originalFieldDef.FieldType, out nextValueVariableDef);
            if (readInsts == null)
                return null;
            //Add each instruction from CreateRead.
            foreach (Instruction i in readInsts)
                processor.InsertBefore(jmpGoalInst, i);

            //Call accessor with new value and false for asServer
            processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Ldarg_0)); //this.
            processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Ldloc, nextValueVariableDef));
            processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Ldc_I4_0));
            processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Call, accessorSetMethodRef));
            //Return true when able to process.
            processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Ldc_I4_1));
            processor.InsertBefore(jmpGoalInst, processor.Create(OpCodes.Ret));

            _lastReadInstruction = nextLastReadInstruction;
            processor.Remove(nopPlaceHolderInst);

            return readSyncMethodDef;
        }

        /// <summary>
        /// Returns methods which may be modified by code generation.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        private List<MethodDefinition> GetModifiableMethods(TypeDefinition typeDef)
        {
            List<MethodDefinition> results = new List<MethodDefinition>();

            CheckTypeDefinition(typeDef);
            //Have to add nested types because this are where courotines are stored.
            foreach (TypeDefinition nestedTd in typeDef.NestedTypes)
                CheckTypeDefinition(nestedTd);

            void CheckTypeDefinition(TypeDefinition td)
            {
                foreach (MethodDefinition methodDef in td.Methods)
                {
                    if (methodDef.Name == ".cctor")
                        continue;
                    if (methodDef.IsConstructor)
                        continue;
                    if (methodDef.Body == null)
                        continue;

                    results.Add(methodDef);
                }

                foreach (PropertyDefinition propertyDef in td.Properties)
                {
                    if (propertyDef.GetMethod != null)
                        results.Add(propertyDef.GetMethod);
                    if (propertyDef.SetMethod != null)
                        results.Add(propertyDef.SetMethod);
                }
            }

            return results;
        }

        /// <summary>
        /// Returns the ProcessedSync entry for resolvedOpField.
        /// </summary>
        /// <param name="resolvedOpField"></param>
        /// <param name="psLst"></param>
        /// <returns></returns>
        private ProcessedSync GetProcessedSync(FieldReference resolvedOpField, List<ProcessedSync> psLst)
        {
            for (int i = 0; i < psLst.Count; i++)
            {
                if (psLst[i].OriginalFieldRef == resolvedOpField)
                    return psLst[i];
            }

            /* Fall through, not found. */
            CodegenSession.LogError($"Unable to find user referenced field for {resolvedOpField.Name}.");
            return null;
        }
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/QOLAttributeProcessor.cs ---
﻿using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using FishNet.CodeGenerating.Processing.Rpc;
using FishNet.Configuring;
using FishNet.Managing.Logging;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System.Collections.Generic;
using System.Linq;

namespace FishNet.CodeGenerating.Processing
{
    internal class QolAttributeProcessor
    {

        internal bool Process(TypeDefinition typeDef, bool moveStrippedCalls)
        {
            bool modified = false;
            List<MethodDefinition> methods = typeDef.Methods.ToList();

            

            foreach (MethodDefinition md in methods)
            {
                //Has RPC attribute, doesn't quality for a quality of life attribute.
                if (CodegenSession.RpcProcessor.Attributes.HasRpcAttributes(md))
                    continue;

                QolAttributeType qolType;
                CustomAttribute qolAttribute = GetQOLAttribute(md, out qolType);
                if (qolAttribute == null)
                    continue;

                /* This is a one time check to make sure the qolType is
                 * a supported value. Multiple methods beyond this rely on the
                 * value being supported. Rather than check in each method a
                 * single check is performed here. */
                if (qolType != QolAttributeType.Server && qolType != QolAttributeType.Client)
                {
                    CodegenSession.LogError($"QolAttributeType of {qolType.ToString()} is unhandled.");
                    continue;
                }

                CreateAttributeMethod(md, qolAttribute, qolType);
                modified = true;
            }

            return modified;
        }

        /// <summary>
        /// Returns the RPC attribute on a method, if one exist. Otherwise returns null.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="rpcType"></param>
        /// <returns></returns>
        private CustomAttribute GetQOLAttribute(MethodDefinition methodDef, out QolAttributeType qolType)
        {
            CustomAttribute foundAttribute = null;
            qolType = QolAttributeType.None;
            //Becomes true if an error occurred during this process.
            bool error = false;
            //Nothing to check.
            if (methodDef == null || methodDef.CustomAttributes == null)
                return null;

            foreach (CustomAttribute customAttribute in methodDef.CustomAttributes)
            {
                QolAttributeType thisQolType = CodegenSession.AttributeHelper.GetQolAttributeType(customAttribute.AttributeType.FullName);
                if (thisQolType != QolAttributeType.None)
                {
                    //A qol attribute already exist.
                    if (foundAttribute != null)
                    {
                        CodegenSession.LogError($"{methodDef.Name} {thisQolType.ToString()} method cannot have multiple quality of life attributes.");
                        error = true;
                    }
                    ////Static method.
                    //if (methodDef.IsStatic)
                    //{
                    //    CodegenSession.AddError($"{methodDef.Name} {thisQolType.ToString()} method cannot be static.");
                    //    error = true;
                    //}
                    //Abstract method.
                    if (methodDef.IsAbstract)
                    {
                        CodegenSession.LogError($"{methodDef.Name} {thisQolType.ToString()} method cannot be abstract.");
                        error = true;
                    }

                    //If all checks passed.
                    if (!error)
                    {
                        foundAttribute = customAttribute;
                        qolType = thisQolType;
                    }
                }
            }

            //If an error occurred then reset results.
            if (error)
            {
                foundAttribute = null;
                qolType = QolAttributeType.None;
            }

            return foundAttribute;
        }

        /// <summary>
        /// Modifies the specified method to use QolType.
        /// </summary>
        private void CreateAttributeMethod(MethodDefinition methodDef, CustomAttribute qolAttribute, QolAttributeType qolType)
        {
            bool inheritsNetworkBehaviour = methodDef.DeclaringType.InheritsNetworkBehaviour();

            //True to use InstanceFInder.
            bool useStatic = (methodDef.IsStatic || !inheritsNetworkBehaviour);

            if (qolType == QolAttributeType.Client)
            {
                if (!StripMethod(methodDef))
                {
                    LoggingType logging = qolAttribute.GetField("Logging", LoggingType.Warning);
                    /* Since isClient also uses insert first
                     * it will be put ahead of the IsOwner check, since the
                     * codegen processes it after IsOwner. EG... 
                     * IsOwner will be added first, then IsClient will be added first over IsOwner. */
                    bool requireOwnership = qolAttribute.GetField("RequireOwnership", false);
                    if (requireOwnership && useStatic)
                    {
                        CodegenSession.LogError($"Method {methodDef.Name} has a [Client] attribute which requires ownership but the method may not use this attribute. Either the method is static, or the script does not inherit from NetworkBehaviour.");
                        return;
                    }
                    //If (!base.IsOwner);
                    if (requireOwnership)
                        CodegenSession.NetworkBehaviourHelper.CreateLocalClientIsOwnerCheck(methodDef, logging, true, false, true);
                    //Otherwise normal IsClient check.
                    else
                        CodegenSession.NetworkBehaviourHelper.CreateIsClientCheck(methodDef, logging, useStatic, true);
                }
            }
            else if (qolType == QolAttributeType.Server)
            {
                if (!StripMethod(methodDef))
                {
                    LoggingType logging = qolAttribute.GetField("Logging", LoggingType.Warning);
                    CodegenSession.NetworkBehaviourHelper.CreateIsServerCheck(methodDef, logging, useStatic, true);
                }
            }

            bool StripMethod(MethodDefinition md)
            {
                

                //Fall through.
                return false;
            }
        }

        
    }

}

'''
'''--- Assets/FishNet/CodeGenerating/Processing/Rpc/AttributeData.cs ---
﻿using FishNet.CodeGenerating.Helping;
using FishNet.Object.Helping;
using MonoFN.Cecil;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Processing.Rpc
{
    internal static class AttributeDataExtensions
    {

        /// <summary>
        /// Returns RpcTypes in datas.
        /// </summary>
        public static List<RpcType> GetRpcTypes(this List<AttributeData> datas)
        {
            //RpcTypes for originalMd.
            List<RpcType> rpcTypes = new List<RpcType>();
            foreach (AttributeData ad in datas)
                rpcTypes.Add(ad.RpcType);

            return rpcTypes;
        }

        /// <summary>
        /// Gets CustomAttribute for rpcType
        /// </summary>
        public static CustomAttribute GetAttribute(this List<AttributeData> datas, RpcType rpcType)
        {
            for (int i = 0; i < datas.Count; i++)
            {
                if (datas[i].RpcType == rpcType)
                    return datas[i].Attribute;
            }

            CodegenSession.LogError($"RpcType {rpcType} not found in datas.");
            return null;
        }

        /// <summary>
        /// Returns RpcType as flag through combining datas.
        /// </summary>
        /// <param name="datas"></param>
        /// <returns></returns>
        public static RpcType GetCombinedRpcType(this List<AttributeData> datas)
        {
            RpcType result = RpcType.None;
            for (int i = 0; i < datas.Count; i++)
                result |= datas[i].RpcType;

            return result;
        }
    }

    internal class AttributeData
    {
        public readonly CustomAttribute Attribute;
        public readonly RpcType RpcType;

        public AttributeData(CustomAttribute attribute, RpcType rpcType)
        {
            Attribute = attribute;
            RpcType = rpcType;
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/Rpc/Attributes.cs ---
﻿using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Connection;
using FishNet.Object.Helping;
using MonoFN.Cecil;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace FishNet.CodeGenerating.Processing.Rpc
{
    internal class Attributes
    {

        /// <summary>
        /// Returns if methodDef has any Rpc attribute.
        /// </summary>
        public bool HasRpcAttributes(MethodDefinition methodDef)
        {
            foreach (CustomAttribute customAttribute in methodDef.CustomAttributes)
            {
                RpcType rt = CodegenSession.AttributeHelper.GetRpcAttributeType(customAttribute);
                if (rt != RpcType.None)
                    return true;
            }

            //Fall through, nothing found.
            return false;
        }

        /// <summary>
        /// Returns a collection of RpcAttribute for methodDef.
        /// </summary>
        public List<AttributeData> GetRpcAttributes(MethodDefinition methodDef)
        {
            List<AttributeData> results = new List<AttributeData>();
            string asyncAttributeFullName = typeof(AsyncStateMachineAttribute).FullName;
            bool isAsync = false;

            foreach (CustomAttribute customAttribute in methodDef.CustomAttributes)
            {
                RpcType rt = CodegenSession.AttributeHelper.GetRpcAttributeType(customAttribute);
                if (rt != RpcType.None)
                {
                    results.Add(new AttributeData(customAttribute, rt));
                }
                //Not a rpc attribute.
                else
                {
                    //Check if async.
                    if (customAttribute.Is(asyncAttributeFullName))
                        isAsync = true;
                }
            }

            //Nothing found, exit early.
            if (results.Count == 0)
            {
                return results;
            }
            //If has at least one RPC attrivbute and is an async method.
            else if (isAsync)
            {
                CodegenSession.LogError($"{methodDef.Name} is an async RPC. This feature is not currently supported. You may instead run an async method from this RPC.");
                return new List<AttributeData>();
            }
            //If more than one attribute make sure the combination is allowed.
            else if (results.Count >= 2)
            {
                RpcType allRpcTypes = results.GetCombinedRpcType();
                if (allRpcTypes != (RpcType.Observers | RpcType.Target))
                {
                    CodegenSession.LogError($"{methodDef.Name} contains multiple RPC attributes. Only ObserversRpc and TargetRpc attributes may be combined.");
                    return new List<AttributeData>();
                }
            }

            //Next validate that the method is setup properly for each rpcType.
            foreach (AttributeData ad in results)
            {
                //If not valid then return empty list.
                if (!IsRpcMethodValid(methodDef, ad.RpcType))
                    return new List<AttributeData>();
            }

            return results;
        }

        /// <summary>
        /// Returns if a RpcMethod can be serialized and has a proper signature.
        /// </summary>
        private bool IsRpcMethodValid(MethodDefinition methodDef, RpcType rpcType)
        {
            //Static method.
            if (methodDef.IsStatic)
            {
                CodegenSession.LogError($"{methodDef.Name} RPC method cannot be static.");
                return false;
            }
            //Is generic type.
            else if (methodDef.HasGenericParameters)
            {
                CodegenSession.LogError($"{methodDef.Name} RPC method cannot contain generic parameters.");
                return false;
            }
            //Abstract method.
            else if (methodDef.IsAbstract)
            {
                CodegenSession.LogError($"{methodDef.Name} RPC method cannot be abstract.");
                return false;
            }
            //Non void return.
            else if (methodDef.ReturnType != methodDef.Module.TypeSystem.Void)
            {
                CodegenSession.LogError($"{methodDef.Name} RPC method must return void.");
                return false;
            }
            //Misc failing conditions.
            else
            {
                //Check for async attribute.
                foreach (CustomAttribute ca in methodDef.CustomAttributes)
                {

                }
            }
            //TargetRpc but missing correct parameters.
            if (rpcType == RpcType.Target)
            {
                if (methodDef.Parameters.Count == 0 || !methodDef.Parameters[0].Is(typeof(NetworkConnection)))
                {
                    CodegenSession.LogError($"Target RPC {methodDef.Name} must have a NetworkConnection as the first parameter.");
                    return false;
                }
            }

            //Make sure all parameters can be serialized.
            for (int i = 0; i < methodDef.Parameters.Count; i++)
            {
                ParameterDefinition parameterDef = methodDef.Parameters[i];

                //If NetworkConnection, TargetRpc, and first parameter.
                if ((i == 0) && (rpcType == RpcType.Target) && parameterDef.Is(typeof(NetworkConnection)))
                    continue;

                if (parameterDef.ParameterType.IsGenericParameter)
                {
                    CodegenSession.LogError($"RPC method{methodDef.Name} contains a generic parameter. This is currently not supported.");
                    return false;
                }

                //Can be serialized/deserialized.
                bool canSerialize = CodegenSession.GeneralHelper.HasSerializerAndDeserializer(parameterDef.ParameterType, true);
                if (!canSerialize)
                {
                    CodegenSession.LogError($"RPC method {methodDef.Name} parameter type {parameterDef.ParameterType.FullName} does not support serialization. Use a supported type or create a custom serializer.");
                    return false;
                }

            }

            //Fall through, success.
            return true;
        }

    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/Rpc/CreatedRpc.cs ---
﻿using FishNet.Object.Helping;
using MonoFN.Cecil;
using System.Collections.Generic;

namespace FishNet.CodeGenerating.Processing.Rpc
{

    internal class CreatedRpc
    {
        public MethodDefinition OriginalMethodDef;
        public uint MethodHash;
        public AttributeData AttributeData;
        public MethodDefinition WriterMethodDef;
        public MethodDefinition ReaderMethodDef;
        public MethodDefinition LogicMethodDef;
        public MethodDefinition RedirectMethodDef;
        public bool RunLocally;

        public RpcType RpcType => AttributeData.RpcType;
        public CustomAttribute Attribute => AttributeData.Attribute;
        public TypeDefinition TypeDef => OriginalMethodDef.DeclaringType;
        public ModuleDefinition Module => OriginalMethodDef.Module;
    }

    internal static class CreatedRpcExtensions
    {
        /// <summary>
        /// Returns CreatedRpc for rpcType.
        /// </summary>
        /// <returns></returns>
        public static CreatedRpc GetCreatedRpc(this List<CreatedRpc> lst, RpcType rpcType)
        {
            for (int i = 0; i < lst.Count; i++)
            {
                if (lst[i].RpcType == rpcType)
                    return lst[i];
            }
            //Fall through.
            return null;
        }

        /// <summary>
        /// Returns combined RpcType for all entries.
        /// </summary>
        /// <returns></returns>
        public static RpcType GetCombinedRpcType(this List<CreatedRpc> lst)
        {
            RpcType result = RpcType.None;
            for (int i = 0; i < lst.Count; i++)
                result |= lst[i].RpcType;

            return result;
        }
    }

}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/Rpc/RpcProcessor.cs ---
﻿
using FishNet.CodeGenerating.Extension;
using FishNet.CodeGenerating.Helping;
using FishNet.CodeGenerating.Helping.Extension;
using FishNet.Configuring;
using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Object.Helping;
using FishNet.Transporting;
using MonoFN.Cecil;
using MonoFN.Cecil.Cil;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace FishNet.CodeGenerating.Processing.Rpc
{
    internal class RpcProcessor
    {

        #region Types.
        private struct DelegateData
        {
            public RpcType RpcType;
            public bool RunLocally;
            public MethodDefinition OriginalMethodDef;
            public MethodDefinition ReaderMethodDef;
            public uint MethodHash;
            public CustomAttribute RpcAttribute;

            public DelegateData(RpcType rpcType, bool runLocally, MethodDefinition originalMethodDef, MethodDefinition readerMethodDef, uint methodHash, CustomAttribute rpcAttribute)
            {
                RpcType = rpcType;
                RunLocally = runLocally;
                OriginalMethodDef = originalMethodDef;
                ReaderMethodDef = readerMethodDef;
                MethodHash = methodHash;
                RpcAttribute = rpcAttribute;
            }
        }

        #endregion

        #region Public.
        /// <summary>
        /// Attribute helper.
        /// </summary>
        public Attributes Attributes = new Attributes();
        #endregion

        private List<(MethodDefinition, MethodDefinition)> _virtualRpcs = new List<(MethodDefinition createdLogicMd, MethodDefinition originalRpcMd)>();

        #region Const.
        private const string LOGIC_PREFIX = "RpcLogic___";
        private const string WRITER_PREFIX = "RpcWriter___";
        private const string READER_PREFIX = "RpcReader___";
        private const string REQUIREOWNERSHIP_NAME = "RequireOwnership";
        private const string RUNLOCALLY_NAME = "RunLocally";
        private const string INCLUDEOWNER_NAME = "IncludeOwner";
        private const string BUFFERLAST_NAME = "BufferLast";
        private const string DATALENGTH_NAME = "DataLength";
        private const string VALIDATETARGET_NAME = "ValidateTarget";
        #endregion

        internal bool Process(TypeDefinition typeDef, ref uint rpcCount)
        {
            bool modified = false;

            //All createdRpcs for typeDef.
            List<CreatedRpc> typeDefCeatedRpcs = new List<CreatedRpc>();
            List<MethodDefinition> methodDefs = typeDef.Methods.ToList();
            foreach (MethodDefinition md in methodDefs)
            {
                if (rpcCount >= NetworkBehaviourHelper.MAX_RPC_ALLOWANCE)
                {
                    CodegenSession.LogError($"{typeDef.FullName} and inherited types exceed {NetworkBehaviourHelper.MAX_RPC_ALLOWANCE} RPC methods. Only {NetworkBehaviourHelper.MAX_RPC_ALLOWANCE} RPC methods are supported per inheritance hierarchy.");
                    return false;
                }

                //Rpcs created for this method.
                List<CreatedRpc> createdRpcs = new List<CreatedRpc>();
                List<AttributeData> attributeDatas = Attributes.GetRpcAttributes(md);
                bool success = true;
                foreach (AttributeData ad in attributeDatas)
                {
                    CreatedRpc cr = new CreatedRpc();
                    cr.OriginalMethodDef = md;
                    cr.AttributeData = ad;
                    cr.MethodHash = rpcCount;

                    /* This is a one time check to make sure the rpcType is
                     * a supported value. Multiple methods beyond this rely on the
                     * value being supported. Rather than check in each method a
                     * single check is performed here. */
                    if (cr.RpcType != RpcType.Observers && cr.RpcType != RpcType.Server && cr.RpcType != RpcType.Target)
                    {
                        CodegenSession.LogError($"RpcType of {cr.RpcType.ToString()} is unhandled.");
                        break;
                    }

                    bool created = CreateRpcMethods(attributeDatas, cr);
                    if (created)
                    {
                        modified = true;

                        typeDefCeatedRpcs.Add(cr);
                        createdRpcs.Add(cr);

                        if (cr.LogicMethodDef != null && cr.LogicMethodDef.IsVirtual)
                            _virtualRpcs.Add((cr.LogicMethodDef, md));

                        rpcCount++;
                    }
                    else
                    {
                        success = false;
                    }
                }

                //If at least one attribute was found and all rpc methods were made.   
                if (createdRpcs.Count > 0 && success)
                    RedirectOriginalToWriter(createdRpcs);

            }

            if (modified)
            {
                foreach (CreatedRpc cr in typeDefCeatedRpcs)
                {
                    CodegenSession.NetworkBehaviourHelper.CreateRpcDelegate(cr.RunLocally, cr.TypeDef,
                        cr.ReaderMethodDef, cr.RpcType, cr.MethodHash,
                        cr.Attribute);
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Returns the name to use for a RpcMethod.
        /// </summary>
        private string GetRpcMethodName(CreatedRpc cr)
        {
            return GetRpcMethodName(cr.RpcType, cr.OriginalMethodDef);
        }

        /// <summary>
        /// Returns the name to use for a RpcMethod.
        /// </summary>
        private string GetRpcMethodName(RpcType rpcType, MethodDefinition originalMd)
        {
            return $"{rpcType}_{GetMethodNameAsParameters(originalMd)}";
        }

        /// <summary>
        /// Returns the method name with parameter types included within the name.
        /// </summary>
        public static string GetMethodNameAsParameters(MethodDefinition methodDef)
        {
            StringBuilder sb = new StringBuilder();
            foreach (ParameterDefinition pd in methodDef.Parameters)
                sb.Append(pd.ParameterType.FullName);

            return $"{methodDef.Name}_{sb.ToString().GetStableHash32()}";
        }

        /// <summary>
        /// Redirects base calls for overriden RPCs.
        /// </summary>
        internal void RedirectBaseCalls()
        {
            foreach ((MethodDefinition logicMd, MethodDefinition originalMd) in _virtualRpcs)
                RedirectBaseCall(logicMd, originalMd);
        }

        /// <summary>
        /// Gets number of RPCs by checking for RPC attributes. This does not perform error checking.
        /// </summary>
        /// <param name="typeDef"></param>
        /// <returns></returns>
        internal uint GetRpcCount(TypeDefinition typeDef)
        {
            uint count = 0;
            foreach (MethodDefinition methodDef in typeDef.Methods)
            {
                foreach (CustomAttribute customAttribute in methodDef.CustomAttributes)
                {
                    RpcType rpcType = CodegenSession.AttributeHelper.GetRpcAttributeType(customAttribute);
                    if (rpcType != RpcType.None)
                    {
                        count++;
                        break;
                    }
                }
            }

            return count;
        }

        /// <summary>
        /// Creates all methods needed for a RPC.
        /// </summary>
        /// <param name="originalMd"></param>
        /// <param name="rpcAttribute"></param>
        /// <returns>True if successful.</returns>
        private bool CreateRpcMethods(List<AttributeData> datas, CreatedRpc cr)
        {
            cr.RunLocally = cr.Attribute.GetField(RUNLOCALLY_NAME, false);
            bool intentionallyNull;

            List<ParameterDefinition> serializedParameters = GetSerializedParamters(cr.RpcType, datas, cr);

            cr.WriterMethodDef = CreateRpcWriterMethod(serializedParameters, datas, cr, out intentionallyNull);
            if (!intentionallyNull && cr.WriterMethodDef == null)
                return false;

            cr.LogicMethodDef = CreateRpcLogicMethod(datas, cr, out intentionallyNull);
            if (!intentionallyNull && cr.LogicMethodDef == null)
                return false;

            cr.ReaderMethodDef = CreateRpcReaderMethod(serializedParameters, datas, cr, out intentionallyNull);
            if (!intentionallyNull && cr.ReaderMethodDef == null)
                return false;

            return true;
        }

        /// <summary>
        /// Creates a writer for a RPC.
        /// </summary>
        /// <param name="originalMd"></param>
        /// <param name="rpcAttribute"></param>
        /// <returns></returns>
        private MethodDefinition CreateRpcWriterMethod(List<ParameterDefinition> serializedParameters, List<AttributeData> datas, CreatedRpc cr, out bool intentionallyNull)
        {
            intentionallyNull = false;

            

            string methodName = $"{WRITER_PREFIX}{GetRpcMethodName(cr)}";
            /* If method already exist then clear it. This
             * can occur when a method needs to be rebuilt due to
             * inheritence, and renumbering the RPC method names. */
            MethodDefinition createdMd = cr.TypeDef.GetMethod(methodName);
            //If found.
            if (createdMd != null)
            {
                createdMd.Parameters.Clear();
                createdMd.Body.Instructions.Clear();
            }
            //Doesn't exist, create it.
            else
            {
                //Create the method body.
                createdMd = new MethodDefinition(methodName,
                    MethodAttributes.Private,
                    cr.Module.TypeSystem.Void);
                cr.TypeDef.Methods.Add(createdMd);
                createdMd.Body.InitLocals = true;
            }
            cr.WriterMethodDef = createdMd;

            bool result;
            if (cr.RpcType == RpcType.Server)
                result = CreateServerRpcWriterMethod(serializedParameters, cr);
            else if (cr.RpcType == RpcType.Target || cr.RpcType == RpcType.Observers)
                result = CreateClientRpcWriterMethod(serializedParameters, datas, cr);
            else
                result = false;

            return (result) ? cr.WriterMethodDef : null;
        }

        /// <summary>
        /// Returns serializable parameters for originalMd.
        /// </summary>
        private List<ParameterDefinition> GetSerializedParamters(RpcType rpcType, List<AttributeData> attributeDatas, CreatedRpc cr)
        {
            MethodDefinition originalMd = cr.OriginalMethodDef;

            //RpcTypes for originalMd.
            List<RpcType> attributeRpcTypes = attributeDatas.GetRpcTypes();

            //Parameters to be serialized.
            List<ParameterDefinition> serializedParameters = new List<ParameterDefinition>();
            /* Parameters which won't be serialized, such as channel.
             * It's safe to add parameters which are null or
             * not used. */
            HashSet<ParameterDefinition> nonserializedParameters = new HashSet<ParameterDefinition>();

            //Get channel if it exist, and get target parameter.
            ParameterDefinition channelParameterDef = GetChannelParameter(originalMd, rpcType);

            /* RpcType specific parameters. */
            ParameterDefinition targetConnectionParameterDef = null;
            if (attributeRpcTypes.Contains(RpcType.Target))
                targetConnectionParameterDef = originalMd.Parameters[0];

            if (rpcType == RpcType.Server)
            {
                //The network connection parameter might be added as null, this is okay.
                nonserializedParameters.Add(GetNetworkConnectionParameter(originalMd));
                nonserializedParameters.Add(channelParameterDef);
            }
            else
            {
                nonserializedParameters.Add(channelParameterDef);
                nonserializedParameters.Add(targetConnectionParameterDef);
            }

            //Add all parameters which are NOT nonserialized to serializedParameters.
            foreach (ParameterDefinition pd in originalMd.Parameters)
            {
                if (!nonserializedParameters.Contains(pd))
                    serializedParameters.Add(pd);
            }

            return serializedParameters;
        }

        /// <summary>
        /// Creates Writer method for a TargetRpc.
        /// </summary>
        private bool CreateClientRpcWriterMethod(List<ParameterDefinition> serializedParameters, List<AttributeData> attributeDatas, CreatedRpc cr)
        {
            MethodDefinition writerMd = cr.WriterMethodDef;
            MethodDefinition originalMd = cr.OriginalMethodDef;

            ILProcessor processor = writerMd.Body.GetILProcessor();
            //Add all parameters from the original.
            for (int i = 0; i < originalMd.Parameters.Count; i++)
                writerMd.Parameters.Add(originalMd.Parameters[i]);
            //Get channel if it exist, and get target parameter.
            ParameterDefinition channelParameterDef = GetChannelParameter(writerMd, RpcType.None);

            List<RpcType> rpcTypes = attributeDatas.GetRpcTypes();

            /* RpcType specific parameters. */
            ParameterDefinition targetConnectionParameterDef = null;
            if (rpcTypes.Contains(RpcType.Target))
                targetConnectionParameterDef = writerMd.Parameters[0];

            /* Creates basic ServerRpc and ClientRpc
             * conditions such as if requireOwnership ect..
             * or if (!base.isClient) */
            
                CreateClientRpcConditionsForServer(writerMd);
           
            VariableDefinition channelVariableDef = CreateAndPopulateChannelVariable(writerMd, channelParameterDef);
            /* Create a local PooledWriter variable. */
            //Default value for data lenght.
            int dataLength = -1;
            //Go through each attribute and see if a larger data length is specified.
            foreach (AttributeData ad in attributeDatas)
            {
                int dl = ad.Attribute.GetField(DATALENGTH_NAME, -1);
                if (dl > dataLength)
                    dataLength = dl;
            }
            VariableDefinition pooledWriterVariableDef = CodegenSession.WriterHelper.CreatePooledWriter(writerMd, dataLength);
            //Create all writer.WriteType() calls. 
            for (int i = 0; i < serializedParameters.Count; i++)
            {
                MethodReference writeMethodRef = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(serializedParameters[i].ParameterType, true);
                if (writeMethodRef == null)
                    return false;

                CodegenSession.WriterHelper.CreateWrite(writerMd, pooledWriterVariableDef, serializedParameters[i], writeMethodRef);
            }

            /* Call the method on NetworkBehaviour responsible for sending out the rpc. */
            if (cr.RpcType == RpcType.Observers)
                processor.Add(CreateSendObserversRpc(writerMd, cr.MethodHash, pooledWriterVariableDef, channelVariableDef, cr.Attribute));
            else if (cr.RpcType == RpcType.Target)
                processor.Add(CreateSendTargetRpc(writerMd, cr.MethodHash, pooledWriterVariableDef, channelVariableDef, targetConnectionParameterDef, attributeDatas));
            //Dispose of writer.
            processor.Add(CodegenSession.WriterHelper.DisposePooledWriter(writerMd, pooledWriterVariableDef));
            //Add end of method.
            processor.Emit(OpCodes.Ret);

            return true;
        }

        /// <summary>
        /// Creates Writer method for a ServerRpc.
        /// </summary>
        private bool CreateServerRpcWriterMethod(List<ParameterDefinition> serializedParameters, CreatedRpc cr)
        {
            MethodDefinition writerMd = cr.WriterMethodDef;
            MethodDefinition originalMd = cr.OriginalMethodDef;
            ILProcessor processor = writerMd.Body.GetILProcessor();

            //Add all parameters from the original.
            for (int i = 0; i < originalMd.Parameters.Count; i++)
                writerMd.Parameters.Add(originalMd.Parameters[i]);
            //Add in channel if it doesnt exist.
            ParameterDefinition channelParameterDef = GetChannelParameter(writerMd, RpcType.Server);

            /* Creates basic ServerRpc
             * conditions such as if requireOwnership ect..
             * or if (!base.isClient) */
            
                CreateServerRpcConditionsForClient(writerMd, cr.Attribute);
            
            VariableDefinition channelVariableDef = CreateAndPopulateChannelVariable(writerMd, channelParameterDef);
            //Create a local PooledWriter variable.
            int dataLength = cr.Attribute.GetField(DATALENGTH_NAME, -1);
            VariableDefinition pooledWriterVariableDef = CodegenSession.WriterHelper.CreatePooledWriter(writerMd, dataLength);
            //Create all writer.WriteType() calls. 
            for (int i = 0; i < serializedParameters.Count; i++)
            {
                MethodReference writeMethodRef = CodegenSession.WriterHelper.GetOrCreateFavoredWriteMethodReference(serializedParameters[i].ParameterType, true);
                if (writeMethodRef == null)
                    return false;

                CodegenSession.WriterHelper.CreateWrite(writerMd, pooledWriterVariableDef, serializedParameters[i], writeMethodRef);
            }

            //uint methodHash = originalMethodDef.FullName.GetStableHash32();
            //Call the method on NetworkBehaviour responsible for sending out the rpc.
            processor.Add(CreateSendServerRpc(writerMd, cr.MethodHash, pooledWriterVariableDef, channelVariableDef));
            //Dispose of writer.
            processor.Add(CodegenSession.WriterHelper.DisposePooledWriter(writerMd, pooledWriterVariableDef));
            //Add end of method.
            processor.Emit(OpCodes.Ret);

            return true;
        }

        /// <summary>
        /// Creates a Channel VariableDefinition and populates it with parameterDef value if available, otherwise uses Channel.Reliable.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <param name="parameterDef"></param>
        /// <returns></returns>
        private VariableDefinition CreateAndPopulateChannelVariable(MethodDefinition methodDef, ParameterDefinition parameterDef)
        {
            ILProcessor processor = methodDef.Body.GetILProcessor();

            VariableDefinition localChannelVariableDef = CodegenSession.GeneralHelper.CreateVariable(methodDef, typeof(Channel));
            if (parameterDef != null)
                processor.Emit(OpCodes.Ldarg, parameterDef);
            else
                processor.Emit(OpCodes.Ldc_I4, (int)Channel.Reliable);

            //Set to local value.
            processor.Emit(OpCodes.Stloc, localChannelVariableDef);
            return localChannelVariableDef;
        }

        /// <summary>
        /// Creates a reader for a RPC.
        /// </summary>
        /// <param name="originalMd"></param>
        /// <param name="rpcAttribute"></param>
        /// <returns></returns>
        private MethodDefinition CreateRpcReaderMethod(List<ParameterDefinition> serializedParameters, List<AttributeData> datas, CreatedRpc cr, out bool intentionallyNull)
        {
            intentionallyNull = false;

            RpcType rpcType = cr.RpcType;
            MethodDefinition originalMd = cr.OriginalMethodDef;
            TypeDefinition typeDef = cr.TypeDef;
            bool runLocally = cr.RunLocally;
            MethodDefinition logicMd = cr.LogicMethodDef;
            CustomAttribute rpcAttribute = cr.Attribute;

            

            string methodName = $"{READER_PREFIX}{GetRpcMethodName(cr)}";
            /* If method already exist then just return it. This
             * can occur when a method needs to be rebuilt due to
             * inheritence, and renumbering the RPC method names. 
             * The reader method however does not need to be rewritten. */
            MethodDefinition createdMd = typeDef.GetMethod(methodName);
            //If found.
            if (createdMd != null)
            {
                cr.ReaderMethodDef = createdMd;
                return createdMd;
            }
            else
            {
                //Create the method body.
                createdMd = new MethodDefinition(
                    methodName,
                    MethodAttributes.Private,
                    originalMd.Module.TypeSystem.Void);
                typeDef.Methods.Add(createdMd);
                createdMd.Body.InitLocals = true;
                cr.ReaderMethodDef = createdMd;
            }

            if (rpcType == RpcType.Server)
                return CreateServerRpcReaderMethod(typeDef, runLocally, originalMd, createdMd, serializedParameters, logicMd, rpcAttribute);
            else if (rpcType == RpcType.Target || rpcType == RpcType.Observers)
                return CreateClientRpcReaderMethod(serializedParameters, datas, cr);
            else
                return null;
        }

        /// <summary>
        /// Creates a reader for ServerRpc.
        /// </summary>
        /// <param name="originalMd"></param>
        /// <param name="rpcAttribute"></param>
        /// <returns></returns>
        private MethodDefinition CreateServerRpcReaderMethod(TypeDefinition typeDef, bool runLocally, MethodDefinition originalMd, MethodDefinition createdMd, List<ParameterDefinition> serializedParameters, MethodDefinition logicMd, CustomAttribute rpcAttribute)
        {
            ILProcessor processor = createdMd.Body.GetILProcessor();

            bool requireOwnership = rpcAttribute.GetField(REQUIREOWNERSHIP_NAME, true);
            //Create PooledReader parameter.
            ParameterDefinition readerParameterDef = CodegenSession.GeneralHelper.CreateParameter(createdMd, CodegenSession.ReaderHelper.PooledReader_TypeRef);

            //Add connection parameter to the read method. Internals pass the connection into this.
            ParameterDefinition channelParameterDef = GetOrCreateChannelParameter(createdMd, RpcType.Server);
            ParameterDefinition connectionParameterDef = GetOrCreateNetworkConnectionParameter(createdMd);

            /* It's very important to read everything
             * from the PooledReader before applying any
             * exit logic. Should the method return before
             * reading the data then anything after the rpc
             * packet will be malformed due to invalid index. */
            VariableDefinition[] readVariableDefs;
            List<Instruction> allReadInsts;
            CreateRpcReadInstructions(createdMd, readerParameterDef, serializedParameters, out readVariableDefs, out allReadInsts);

            //Read to clear pooledreader.
            processor.Add(allReadInsts);

            /* Don't continue if server is not active.
             * This can happen if an object is deinitializing
             * as a RPC arrives. When separate server and client
             * this should not occur but there's a chance as host
             * because deinitializations are slightly delayed to support
             * the clientHost deinitializing the object as well. */
            CodegenSession.NetworkBehaviourHelper.CreateIsServerCheck(createdMd, LoggingType.Off, false, false);
            //
            CreateServerRpcConditionsForServer(processor, requireOwnership, connectionParameterDef);

            //Block from running twice as host.
            if (runLocally)
            {
                //The connection calling is always passed into the reader method as the last parameter.
                ParameterDefinition ncPd = createdMd.Parameters[createdMd.Parameters.Count - 1];
                Instruction afterConnectionRet = processor.Create(OpCodes.Nop);
                processor.Emit(OpCodes.Ldarg, ncPd);
                processor.Emit(OpCodes.Callvirt, CodegenSession.ObjectHelper.NetworkConnection_GetIsLocalClient_MethodRef);
                processor.Emit(OpCodes.Brfalse_S, afterConnectionRet);
                processor.Emit(OpCodes.Ret);
                processor.Append(afterConnectionRet);
            }

            //this.Logic
            processor.Emit(OpCodes.Ldarg_0);
            //Add each read variable as an argument. 
            foreach (VariableDefinition vd in readVariableDefs)
                processor.Emit(OpCodes.Ldloc, vd);

            /* Pass in channel and connection if original
             * method supports them. */
            ParameterDefinition originalChannelParameterDef = GetChannelParameter(originalMd, RpcType.Server);
            ParameterDefinition originalConnectionParameterDef = GetNetworkConnectionParameter(originalMd);
            if (originalChannelParameterDef != null)
                processor.Emit(OpCodes.Ldarg, channelParameterDef);
            if (originalConnectionParameterDef != null)
                processor.Emit(OpCodes.Ldarg, connectionParameterDef);
            //Call __Logic method.
            processor.Emit(OpCodes.Call, logicMd);
            processor.Emit(OpCodes.Ret);

            return createdMd;
        }

        /// <summary>
        /// Creates a reader for ObserversRpc.
        /// </summary>
        /// <param name="originalMd"></param>
        /// <param name="rpcAttribute"></param>
        /// <returns></returns>
        private MethodDefinition CreateClientRpcReaderMethod(List<ParameterDefinition> serializedParameters, List<AttributeData> attributeDatas, CreatedRpc cr)
        {
            MethodDefinition originalMd = cr.OriginalMethodDef;
            MethodDefinition createdMd = cr.ReaderMethodDef;
            RpcType rpcType = cr.RpcType;
            CustomAttribute rpcAttribute = cr.Attribute;
            bool runLocally = cr.RunLocally;

            ILProcessor processor = createdMd.Body.GetILProcessor();

            //Create PooledReader parameter.
            ParameterDefinition readerParameterDef = CodegenSession.GeneralHelper.CreateParameter(createdMd, CodegenSession.ReaderHelper.PooledReader_TypeRef);
            ParameterDefinition channelParameterDef = GetOrCreateChannelParameter(createdMd, rpcType);
            /* It's very important to read everything
             * from the PooledReader before applying any
             * exit logic. Should the method return before
             * reading the data then anything after the rpc
             * packet will be malformed due to invalid index. */
            VariableDefinition[] readVariableDefs;
            List<Instruction> allReadInsts;
            CreateRpcReadInstructions(createdMd, readerParameterDef, serializedParameters, out readVariableDefs, out allReadInsts);
            //Read instructions even if not to include owner.
            processor.Add(allReadInsts);

            /* Don't continue if client is not active.
            * This can happen if an object is deinitializing
            * as a RPC arrives. When separate server and client
            * this should not occur but there's a chance as host
            * because deinitializations are slightly delayed to support
            * the clientHost deinitializing the object as well. */
            CodegenSession.NetworkBehaviourHelper.CreateIsClientCheck(createdMd, LoggingType.Off, false, false);

            /* ObserversRpc IncludeOwnerCheck. */
            if (rpcType == RpcType.Observers)
            {
                //If to not include owner then don't call logic if owner.
                bool includeOwner = rpcAttribute.GetField(INCLUDEOWNER_NAME, true);
                if (!includeOwner)
                {
                    //Create return if owner.
                    Instruction retInst = CodegenSession.NetworkBehaviourHelper.CreateLocalClientIsOwnerCheck(createdMd, LoggingType.Off, true, true, true);
                    processor.InsertBefore(retInst, allReadInsts);
                }
            }

            //Block from running twice as host.
            if (runLocally)
                processor.Add(CreateIsHostBlock(createdMd));

            processor.Emit(OpCodes.Ldarg_0); //this.
            /* TargetRpc passes in localconnection
            * as receiver for connection. */
            if (rpcType == RpcType.Target)
            {
                processor.Emit(OpCodes.Ldarg_0); //this.
                processor.Emit(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.LocalConnection_MethodRef);
            }
            else
            {
                //If this method uses target/observerRpc combined then load null for the connection.
                RpcType allRpcTypes = attributeDatas.GetCombinedRpcType();
                if (allRpcTypes == (RpcType.Observers | RpcType.Target))
                    processor.Emit(OpCodes.Ldnull);
            }
            //Add each read variable as an argument. 
            foreach (VariableDefinition vd in readVariableDefs)
                processor.Emit(OpCodes.Ldloc, vd);
            //Channel.
            ParameterDefinition originalChannelParameterDef = GetChannelParameter(originalMd, rpcType);
            if (originalChannelParameterDef != null)
                processor.Emit(OpCodes.Ldarg, channelParameterDef);
            //Call __Logic method.
            processor.Emit(OpCodes.Call, cr.LogicMethodDef);
            processor.Emit(OpCodes.Ret);

            return createdMd;
        }

        /// <summary>
        /// Appends a block to the method if running as host.
        /// </summary>
        /// <param name="md"></param>
        private List<Instruction> CreateIsHostBlock(MethodDefinition md)
        {
            List<Instruction> ints = new List<Instruction>();
            ILProcessor processor = md.Body.GetILProcessor();

            Instruction endIfInst = processor.Create(OpCodes.Nop);
            ints.Add(processor.Create(OpCodes.Ldarg_0));
            ints.Add(processor.Create(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.IsHost_MethodRef));
            ints.Add(processor.Create(OpCodes.Brfalse_S, endIfInst));
            ints.Add(processor.Create(OpCodes.Ret));
            ints.Add(endIfInst);

            return ints;
        }

        /// <summary>
        /// Gets the optional NetworkConnection parameter for ServerRpc, if it exists.
        /// </summary>
        /// <param name="methodDef"></param>
        /// <returns></returns>
        private ParameterDefinition GetNetworkConnectionParameter(MethodDefinition methodDef)
        {

            ParameterDefinition result = methodDef.GetEndParameter(0);
            //Is null, not networkconnection, or doesn't have default.
            if (result == null || !result.Is(typeof(NetworkConnection)) || !result.HasDefault)
                return null;

            return result;
        }

        /// <summary>
        /// Creates a NetworkConnection parameter if it's not the last or second to last parameter.
        /// </summary>
        /// <param name="methodDef"></param>
        private ParameterDefinition GetOrCreateNetworkConnectionParameter(MethodDefinition methodDef)
        {
            ParameterDefinition result = GetNetworkConnectionParameter(methodDef);
            if (result == null)
                return CodegenSession.GeneralHelper.CreateParameter(methodDef, typeof(NetworkConnection), "conn");
            else
                return result;
        }

        /// <summary>
        /// Returns the Channel parameter if it exist.
        /// </summary>
        /// <param name="originalMethodDef"></param>
        private ParameterDefinition GetChannelParameter(MethodDefinition methodDef, RpcType rpcType)
        {
            ParameterDefinition result = null;
            ParameterDefinition pd = methodDef.GetEndParameter(0);
            if (pd != null)
            {
                //Last parameter is channel.
                if (pd.Is(typeof(Channel)))
                {
                    result = pd;
                }
                /* Only other end parameter may be networkconnection.
                 * This can only be checked if a ServerRpc. */
                else if (rpcType == RpcType.Server)
                {
                    //If last parameter is networkconnection and its default then can check second to last.
                    if (pd.Is(typeof(NetworkConnection)) && pd.HasDefault)
                    {
                        pd = methodDef.GetEndParameter(1);
                        if (pd != null && pd.Is(typeof(Channel)))
                            result = pd;
                    }
                }
                else
                {
                    result = null;
                }
            }

            return result;
        }

        /// <summary>
        /// Creates a channel parameter if missing.
        /// </summary>
        /// <param name="originalMethodDef"></param>
        private ParameterDefinition GetOrCreateChannelParameter(MethodDefinition methodDef, RpcType rpcType)
        {
            ParameterDefinition result = GetChannelParameter(methodDef, rpcType);
            //Add channel parameter if not included.
            if (result == null)
            {
                ParameterDefinition connParameter = GetNetworkConnectionParameter(methodDef);
                //If the connection parameter is specified then channel has to go before it.
                if (connParameter != null)
                    return CodegenSession.GeneralHelper.CreateParameter(methodDef, typeof(Channel), "channel", ParameterAttributes.None, connParameter.Index);
                //Not specified, add channel at end.
                else
                    return CodegenSession.GeneralHelper.CreateParameter(methodDef, typeof(Channel), "channel");
            }
            else
            {
                return result;
            }
        }

        /// <summary>
        /// Creates a read for every writtenParameters and outputs variables read into, and instructions.
        /// </summary>
        /// <param name="processor"></param>
        /// <param name="methodDef"></param>
        /// <param name="readerParameterDef"></param>
        /// <param name="serializedParameters"></param>
        /// <param name="readVariableDefs"></param>
        /// <param name="allReadInsts"></param>
        private void CreateRpcReadInstructions(MethodDefinition methodDef, ParameterDefinition readerParameterDef, List<ParameterDefinition> serializedParameters, out VariableDefinition[] readVariableDefs, out List<Instruction> allReadInsts)
        {
            /* It's very important to read everything
            * from the PooledReader before applying any
            * exit logic. Should the method return before
            * reading the data then anything after the rpc
            * packet will be malformed due to invalid index. */
            readVariableDefs = new VariableDefinition[serializedParameters.Count];
            allReadInsts = new List<Instruction>();

            //True if last parameter is a connection and a server rpc.
            for (int i = 0; i < serializedParameters.Count; i++)
            {
                //Get read instructions and insert it before the return.
                List<Instruction> insts = CodegenSession.ReaderHelper.CreateRead(methodDef, readerParameterDef, serializedParameters[i].ParameterType, out readVariableDefs[i]);
                allReadInsts.AddRange(insts);
            }

        }
        /// <summary>
        /// Creates conditions that clients must pass to send a ServerRpc.
        /// </summary>
        /// <param name="createdProcessor"></param>
        /// <param name="rpcAttribute"></param>
        private void CreateServerRpcConditionsForClient(MethodDefinition methodDef, CustomAttribute rpcAttribute)
        {
            bool requireOwnership = rpcAttribute.GetField(REQUIREOWNERSHIP_NAME, true);
            //If (!base.IsOwner);
            if (requireOwnership)
                CodegenSession.NetworkBehaviourHelper.CreateLocalClientIsOwnerCheck(methodDef, LoggingType.Warning, false, false, true);
            //If (!base.IsClient)
            CodegenSession.NetworkBehaviourHelper.CreateIsClientCheck(methodDef, LoggingType.Warning, false, true);
        }

        /// <summary>
        /// Creates conditions that server must pass to process a ServerRpc.
        /// </summary>
        /// <param name="createdProcessor"></param>
        /// <param name="rpcAttribute"></param>
        /// <returns>Ret instruction.</returns>
        private Instruction CreateServerRpcConditionsForServer(ILProcessor createdProcessor, bool requireOwnership, ParameterDefinition connectionParametereDef)
        {
            /* Don't need to check if server on receiving end.
             * Next compare connection with owner. */
            //If (!base.CompareOwner);
            if (requireOwnership)
                return CodegenSession.NetworkBehaviourHelper.CreateRemoteClientIsOwnerCheck(createdProcessor, connectionParametereDef);
            else
                return null;
        }

        /// <summary>
        /// Creates conditions that server must pass to process a ClientRpc.
        /// </summary>
        /// <param name="createdProcessor"></param>
        private void CreateClientRpcConditionsForServer(MethodDefinition methodDef)
        {
            //If (!base.IsServer)
            CodegenSession.NetworkBehaviourHelper.CreateIsServerCheck(methodDef, LoggingType.Warning, false, false);
        }

        /// <summary>
        /// Creates a method containing the logic which will run when receiving the Rpc.
        /// </summary>
        /// <param name="originalMd"></param>
        /// <returns></returns>
        private MethodDefinition CreateRpcLogicMethod(List<AttributeData> datas, CreatedRpc cr, out bool intentionallyNull)
        {
            intentionallyNull = false;

            RpcType rpcType = cr.RpcType;
            TypeDefinition typeDef = cr.TypeDef;
            MethodDefinition originalMd = cr.OriginalMethodDef;

            

            //Methodname for logic methods do not use prefixes because there can be only one.
            string methodName = $"{LOGIC_PREFIX}{GetMethodNameAsParameters(originalMd)}";
            /* If method already exist then just return it. This
             * can occur when a method needs to be rebuilt due to
             * inheritence, and renumbering the RPC method names. 
             * The logic method however does not need to be rewritten. */
            MethodDefinition logicMd = CodegenSession.GeneralHelper.CopyMethod(originalMd, methodName, out _);

            cr.LogicMethodDef = logicMd;
            return logicMd;
        }

        /// <summary>
        /// Finds and fixes call to base methods within remote calls
        /// <para>For example, changes `base.CmdDoSomething` to `base.UserCode_CmdDoSomething` within `this.UserCode_CmdDoSomething`</para>
        /// </summary>
        /// <param name="type"></param>
        /// <param name="createdMethodDef"></param>
        private void RedirectBaseCall(MethodDefinition createdMethodDef, MethodDefinition originalMethodDef)
        {
            //All logic RPCs end with the logic suffix.
            if (!createdMethodDef.Name.StartsWith(LOGIC_PREFIX))
                return;
            //Not virtual, no need to check.
            if (!createdMethodDef.IsVirtual)
                return;

            foreach (Instruction instruction in createdMethodDef.Body.Instructions)
            {
                // if call to base.RpcDoSomething within this.RpcDoSOmething.
                if (CodegenSession.GeneralHelper.IsCallToMethod(instruction, out MethodDefinition calledMethod) && calledMethod.Name == originalMethodDef.Name)
                {
                    MethodReference baseLogicMd = createdMethodDef.DeclaringType.GetMethodDefinitionInAnyBase(createdMethodDef.Name);
                    if (baseLogicMd == null)
                    {
                        CodegenSession.LogError($"Could not find base method for {createdMethodDef.Name}.");
                        return;
                    }

                    instruction.Operand = CodegenSession.ImportReference(baseLogicMd);
                }
            }
        }

        /// <summary> 
        /// Redirects calls from the original Rpc method to the writer method.
        /// </summary>
        private void RedirectOriginalToWriter(List<CreatedRpc> createdRpcs)
        {
            /* If there are multiple attributes/createdRpcs they will
            * share the same originalMd so it's fine to take the first
            * entry. */
            MethodDefinition originalMd = createdRpcs[0].OriginalMethodDef;

            

            ILProcessor processor = originalMd.Body.GetILProcessor();
            originalMd.Body.Instructions.Clear();

            //If only one rpc type.
            if (createdRpcs.Count == 1)
            {
                processor.Emit(OpCodes.Ldarg_0); //this.
                                                 //Parameters.
                foreach (ParameterDefinition pd in originalMd.Parameters)
                    processor.Emit(OpCodes.Ldarg, pd);

                //Call method.
                MethodReference writerMr = CodegenSession.ImportReference(createdRpcs[0].WriterMethodDef);
                processor.Emit(OpCodes.Call, writerMr);
            }
            //More than one which means it's an observer/targetRpc combo.
            else
            {
                MethodReference observerWriterMr = CodegenSession.ImportReference(createdRpcs.GetCreatedRpc(RpcType.Observers).WriterMethodDef);
                MethodReference targetWriterMr = CodegenSession.ImportReference(createdRpcs.GetCreatedRpc(RpcType.Target).WriterMethodDef);

                Instruction targetRpcInst = processor.Create(OpCodes.Nop);
                Instruction afterTargetRpcInst = processor.Create(OpCodes.Nop);
                /* if (targetConn == null)
                 *      WriteObserverRpc
                 * else
                 *      WriteTargetRpc */
                processor.Emit(OpCodes.Ldarg, originalMd.Parameters[0]);
                processor.Emit(OpCodes.Brtrue_S, targetRpcInst);
                //Insert parameters.
                processor.Emit(OpCodes.Ldarg_0);
                foreach (ParameterDefinition pd in originalMd.Parameters)
                    processor.Emit(OpCodes.Ldarg, pd);
                processor.Emit(OpCodes.Call, observerWriterMr);
                //else (target).
                processor.Emit(OpCodes.Br_S, afterTargetRpcInst);
                processor.Append(targetRpcInst);
                //Insert parameters.
                processor.Emit(OpCodes.Ldarg_0);
                foreach (ParameterDefinition pd in originalMd.Parameters)
                    processor.Emit(OpCodes.Ldarg, pd);
                processor.Emit(OpCodes.Call, targetWriterMr);
                processor.Append(afterTargetRpcInst);
            }

            //Runlocally.
            if (createdRpcs[0].RunLocally)
            {
                processor.Emit(OpCodes.Ldarg_0); //this.
                                                 //Parameters.
                foreach (ParameterDefinition pd in originalMd.Parameters)
                    processor.Emit(OpCodes.Ldarg, pd);
                processor.Emit(OpCodes.Call, createdRpcs[0].LogicMethodDef);
            }

            processor.Emit(OpCodes.Ret);
        }

        #region CreateSend
        /// <summary>
        /// Creates a call to SendServerRpc on NetworkBehaviour.
        /// </summary>
        /// <param name="writerVariableDef"></param>
        /// <param name="channel"></param>
        private List<Instruction> CreateSendServerRpc(MethodDefinition methodDef, uint methodHash, VariableDefinition writerVariableDef, VariableDefinition channelVariableDef)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            insts.AddRange(CreateSendRpcCommon(processor, methodHash, writerVariableDef, channelVariableDef));
            //Call NetworkBehaviour.
            insts.Add(processor.Create(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.SendServerRpc_MethodRef));

            return insts;
        }

        /// <summary>
        /// Creates a call to SendObserversRpc on NetworkBehaviour.
        /// </summary>
        private List<Instruction> CreateSendObserversRpc(MethodDefinition methodDef, uint methodHash, VariableDefinition writerVariableDef, VariableDefinition channelVariableDef, CustomAttribute rpcAttribute)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            insts.AddRange(CreateSendRpcCommon(processor, methodHash, writerVariableDef, channelVariableDef));
            //Also add if buffered.
            bool bufferLast = rpcAttribute.GetField(BUFFERLAST_NAME, false);
            int buffered = (bufferLast) ? 1 : 0;

            //Warn user if any values are byref.
            bool usedByref = false;
            foreach (ParameterDefinition item in methodDef.Parameters)
            {
                if (item.IsIn)
                {
                    usedByref = true;
                    break;
                }
            }
            if (usedByref)
                CodegenSession.LogWarning($"Method {methodDef.FullName} takes an argument by reference. While this is supported, using BufferLast in addition to by reference arguements will buffer the value as it was serialized, not as it is when sending buffered.");

            insts.Add(processor.Create(OpCodes.Ldc_I4, buffered));
            //Call NetworkBehaviour.
            insts.Add(processor.Create(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.SendObserversRpc_MethodRef));

            return insts;
        }
        /// <summary>
        /// Creates a call to SendTargetRpc on NetworkBehaviour.
        /// </summary>
        private List<Instruction> CreateSendTargetRpc(MethodDefinition methodDef, uint methodHash, VariableDefinition writerVariableDef, VariableDefinition channelVariableDef, ParameterDefinition targetConnectionParameterDef, List<AttributeData> attributeDatas)
        {
            List<Instruction> insts = new List<Instruction>();
            ILProcessor processor = methodDef.Body.GetILProcessor();

            CustomAttribute rpcAttribute = attributeDatas.GetAttribute(RpcType.Target);
            bool validateTarget = rpcAttribute.GetField(VALIDATETARGET_NAME, true);
            int validate = (validateTarget) ? 1 : 0;

            insts.AddRange(CreateSendRpcCommon(processor, methodHash, writerVariableDef, channelVariableDef));
            //Reference to NetworkConnection that RPC is going to.
            insts.Add(processor.Create(OpCodes.Ldarg, targetConnectionParameterDef));
            //Validate target receiving the rpc.
            insts.Add(processor.Create(OpCodes.Ldc_I4, validate));
            //Call NetworkBehaviour.
            insts.Add(processor.Create(OpCodes.Call, CodegenSession.NetworkBehaviourHelper.SendTargetRpc_MethodRef));

            return insts;
        }

        /// <summary>
        /// Writes common properties that all SendRpc methods use.
        /// </summary>
        private List<Instruction> CreateSendRpcCommon(ILProcessor processor, uint methodHash, VariableDefinition writerVariableDef, VariableDefinition channelVariableDef)
        {
            List<Instruction> insts = new List<Instruction>();

            insts.Add(processor.Create(OpCodes.Ldarg_0)); // argument: this
            insts.Add(processor.Create(OpCodes.Ldc_I4, (int)methodHash));
            //reference to PooledWriter.
            insts.Add(processor.Create(OpCodes.Ldloc, writerVariableDef));
            //reference to Channel.
            insts.Add(processor.Create(OpCodes.Ldloc, channelVariableDef));

            return insts;
        }
        #endregion
    }
}
'''
'''--- Assets/FishNet/CodeGenerating/Processing/Typed/ProcessedSync.cs ---
﻿using MonoFN.Cecil;

namespace FishNet.CodeGenerating.Processing
{

    public class ProcessedSync
    {
        public FieldReference OriginalFieldRef;
        public FieldReference GeneratedFieldRef;
        public MethodReference SetMethodRef;
        public MethodReference GetMethodRef;

        public ProcessedSync(FieldReference originalFieldRef,FieldReference generatedFieldRef,  MethodReference setMethodRef, MethodReference getMethodRef)
        {
            OriginalFieldRef = originalFieldRef;
            GeneratedFieldRef = generatedFieldRef;
            SetMethodRef = setMethodRef;
            GetMethodRef = getMethodRef;
        }

    }

}
'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/LICENSE.txt ---
Copyright (c) 2008 - 2015 Jb Evain
Copyright (c) 2008 - 2011 Novell, Inc.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/Code.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Cil {

	public enum Code {
		Nop,
		Break,
		Ldarg_0,
		Ldarg_1,
		Ldarg_2,
		Ldarg_3,
		Ldloc_0,
		Ldloc_1,
		Ldloc_2,
		Ldloc_3,
		Stloc_0,
		Stloc_1,
		Stloc_2,
		Stloc_3,
		Ldarg_S,
		Ldarga_S,
		Starg_S,
		Ldloc_S,
		Ldloca_S,
		Stloc_S,
		Ldnull,
		Ldc_I4_M1,
		Ldc_I4_0,
		Ldc_I4_1,
		Ldc_I4_2,
		Ldc_I4_3,
		Ldc_I4_4,
		Ldc_I4_5,
		Ldc_I4_6,
		Ldc_I4_7,
		Ldc_I4_8,
		Ldc_I4_S,
		Ldc_I4,
		Ldc_I8,
		Ldc_R4,
		Ldc_R8,
		Dup,
		Pop,
		Jmp,
		Call,
		Calli,
		Ret,
		Br_S,
		Brfalse_S,
		Brtrue_S,
		Beq_S,
		Bge_S,
		Bgt_S,
		Ble_S,
		Blt_S,
		Bne_Un_S,
		Bge_Un_S,
		Bgt_Un_S,
		Ble_Un_S,
		Blt_Un_S,
		Br,
		Brfalse,
		Brtrue,
		Beq,
		Bge,
		Bgt,
		Ble,
		Blt,
		Bne_Un,
		Bge_Un,
		Bgt_Un,
		Ble_Un,
		Blt_Un,
		Switch,
		Ldind_I1,
		Ldind_U1,
		Ldind_I2,
		Ldind_U2,
		Ldind_I4,
		Ldind_U4,
		Ldind_I8,
		Ldind_I,
		Ldind_R4,
		Ldind_R8,
		Ldind_Ref,
		Stind_Ref,
		Stind_I1,
		Stind_I2,
		Stind_I4,
		Stind_I8,
		Stind_R4,
		Stind_R8,
		Add,
		Sub,
		Mul,
		Div,
		Div_Un,
		Rem,
		Rem_Un,
		And,
		Or,
		Xor,
		Shl,
		Shr,
		Shr_Un,
		Neg,
		Not,
		Conv_I1,
		Conv_I2,
		Conv_I4,
		Conv_I8,
		Conv_R4,
		Conv_R8,
		Conv_U4,
		Conv_U8,
		Callvirt,
		Cpobj,
		Ldobj,
		Ldstr,
		Newobj,
		Castclass,
		Isinst,
		Conv_R_Un,
		Unbox,
		Throw,
		Ldfld,
		Ldflda,
		Stfld,
		Ldsfld,
		Ldsflda,
		Stsfld,
		Stobj,
		Conv_Ovf_I1_Un,
		Conv_Ovf_I2_Un,
		Conv_Ovf_I4_Un,
		Conv_Ovf_I8_Un,
		Conv_Ovf_U1_Un,
		Conv_Ovf_U2_Un,
		Conv_Ovf_U4_Un,
		Conv_Ovf_U8_Un,
		Conv_Ovf_I_Un,
		Conv_Ovf_U_Un,
		Box,
		Newarr,
		Ldlen,
		Ldelema,
		Ldelem_I1,
		Ldelem_U1,
		Ldelem_I2,
		Ldelem_U2,
		Ldelem_I4,
		Ldelem_U4,
		Ldelem_I8,
		Ldelem_I,
		Ldelem_R4,
		Ldelem_R8,
		Ldelem_Ref,
		Stelem_I,
		Stelem_I1,
		Stelem_I2,
		Stelem_I4,
		Stelem_I8,
		Stelem_R4,
		Stelem_R8,
		Stelem_Ref,
		Ldelem_Any,
		Stelem_Any,
		Unbox_Any,
		Conv_Ovf_I1,
		Conv_Ovf_U1,
		Conv_Ovf_I2,
		Conv_Ovf_U2,
		Conv_Ovf_I4,
		Conv_Ovf_U4,
		Conv_Ovf_I8,
		Conv_Ovf_U8,
		Refanyval,
		Ckfinite,
		Mkrefany,
		Ldtoken,
		Conv_U2,
		Conv_U1,
		Conv_I,
		Conv_Ovf_I,
		Conv_Ovf_U,
		Add_Ovf,
		Add_Ovf_Un,
		Mul_Ovf,
		Mul_Ovf_Un,
		Sub_Ovf,
		Sub_Ovf_Un,
		Endfinally,
		Leave,
		Leave_S,
		Stind_I,
		Conv_U,
		Arglist,
		Ceq,
		Cgt,
		Cgt_Un,
		Clt,
		Clt_Un,
		Ldftn,
		Ldvirtftn,
		Ldarg,
		Ldarga,
		Starg,
		Ldloc,
		Ldloca,
		Stloc,
		Localloc,
		Endfilter,
		Unaligned,
		Volatile,
		Tail,
		Initobj,
		Constrained,
		Cpblk,
		Initblk,
		No,
		Rethrow,
		Sizeof,
		Refanytype,
		Readonly,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/CodeReader.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.PE;
using MonoFN.Collections.Generic;
using System;

namespace MonoFN.Cecil.Cil {

	sealed class CodeReader : BinaryStreamReader {

		readonly internal MetadataReader reader;

		int start;

		MethodDefinition method;
		MethodBody body;

		int Offset {
			get { return Position - start; }
		}

		public CodeReader (MetadataReader reader)
			: base (reader.image.Stream.value)
		{
			this.reader = reader;
		}

		public int MoveTo (MethodDefinition method)
		{
			this.method = method;
			this.reader.context = method;
			var position = this.Position;
			this.Position = (int)reader.image.ResolveVirtualAddress ((uint)method.RVA);
			return position;
		}

		public void MoveBackTo (int position)
		{
			this.reader.context = null;
			this.Position = position;
		}

		public MethodBody ReadMethodBody (MethodDefinition method)
		{
			var position = MoveTo (method);
			this.body = new MethodBody (method);

			ReadMethodBody ();

			MoveBackTo (position);
			return this.body;
		}

		public int ReadCodeSize (MethodDefinition method)
		{
			var position = MoveTo (method);

			var code_size = ReadCodeSize ();

			MoveBackTo (position);
			return code_size;
		}

		int ReadCodeSize ()
		{
			var flags = ReadByte ();
			switch (flags & 0x3) {
			case 0x2: // tiny
				return flags >> 2;
			case 0x3: // fat
				Advance (-1 + 2 + 2); // go back, 2 bytes flags, 2 bytes stack size
				return (int)ReadUInt32 ();
			default:
				throw new InvalidOperationException ();
			}
		}

		void ReadMethodBody ()
		{
			var flags = ReadByte ();
			switch (flags & 0x3) {
			case 0x2: // tiny
				body.code_size = flags >> 2;
				body.MaxStackSize = 8;
				ReadCode ();
				break;
			case 0x3: // fat
				Advance (-1);
				ReadFatMethod ();
				break;
			default:
				throw new InvalidOperationException ();
			}

			var symbol_reader = reader.module.symbol_reader;

			if (symbol_reader != null && method.debug_info == null)
				method.debug_info = symbol_reader.Read (method);

			if (method.debug_info != null)
				ReadDebugInfo ();
		}

		void ReadFatMethod ()
		{
			var flags = ReadUInt16 ();
			body.max_stack_size = ReadUInt16 ();
			body.code_size = (int)ReadUInt32 ();
			body.local_var_token = new MetadataToken (ReadUInt32 ());
			body.init_locals = (flags & 0x10) != 0;

			if (body.local_var_token.RID != 0)
				body.variables = ReadVariables (body.local_var_token);

			ReadCode ();

			if ((flags & 0x8) != 0)
				ReadSection ();
		}

		public VariableDefinitionCollection ReadVariables (MetadataToken local_var_token)
		{
			var position = reader.position;
			var variables = reader.ReadVariables (local_var_token, method);
			reader.position = position;

			return variables;
		}

		void ReadCode ()
		{
			start = Position;
			var code_size = body.code_size;

			if (code_size < 0 || Length <= (uint)(code_size + Position))
				code_size = 0;

			var end = start + code_size;
			var instructions = body.instructions = new InstructionCollection (method, (code_size + 1) / 2);

			while (Position < end) {
				var offset = Position - start;
				var opcode = ReadOpCode ();
				var current = new Instruction (offset, opcode);

				if (opcode.OperandType != OperandType.InlineNone)
					current.operand = ReadOperand (current);

				instructions.Add (current);
			}

			ResolveBranches (instructions);
		}

		OpCode ReadOpCode ()
		{
			var il_opcode = ReadByte ();
			return il_opcode != 0xfe
				? OpCodes.OneByteOpCode [il_opcode]
				: OpCodes.TwoBytesOpCode [ReadByte ()];
		}

		object ReadOperand (Instruction instruction)
		{
			switch (instruction.opcode.OperandType) {
			case OperandType.InlineSwitch:
				var length = ReadInt32 ();
				var base_offset = Offset + (4 * length);
				var branches = new int [length];
				for (int i = 0; i < length; i++)
					branches [i] = base_offset + ReadInt32 ();
				return branches;
			case OperandType.ShortInlineBrTarget:
				return ReadSByte () + Offset;
			case OperandType.InlineBrTarget:
				return ReadInt32 () + Offset;
			case OperandType.ShortInlineI:
				if (instruction.opcode == OpCodes.Ldc_I4_S)
					return ReadSByte ();

				return ReadByte ();
			case OperandType.InlineI:
				return ReadInt32 ();
			case OperandType.ShortInlineR:
				return ReadSingle ();
			case OperandType.InlineR:
				return ReadDouble ();
			case OperandType.InlineI8:
				return ReadInt64 ();
			case OperandType.ShortInlineVar:
				return GetVariable (ReadByte ());
			case OperandType.InlineVar:
				return GetVariable (ReadUInt16 ());
			case OperandType.ShortInlineArg:
				return GetParameter (ReadByte ());
			case OperandType.InlineArg:
				return GetParameter (ReadUInt16 ());
			case OperandType.InlineSig:
				return GetCallSite (ReadToken ());
			case OperandType.InlineString:
				return GetString (ReadToken ());
			case OperandType.InlineTok:
			case OperandType.InlineType:
			case OperandType.InlineMethod:
			case OperandType.InlineField:
				return reader.LookupToken (ReadToken ());
			default:
				throw new NotSupportedException ();
			}
		}

		public string GetString (MetadataToken token)
		{
			return reader.image.UserStringHeap.Read (token.RID);
		}

		public ParameterDefinition GetParameter (int index)
		{
			return body.GetParameter (index);
		}

		public VariableDefinition GetVariable (int index)
		{
			return body.GetVariable (index);
		}

		public CallSite GetCallSite (MetadataToken token)
		{
			return reader.ReadCallSite (token);
		}

		void ResolveBranches (Collection<Instruction> instructions)
		{
			var items = instructions.items;
			var size = instructions.size;

			for (int i = 0; i < size; i++) {
				var instruction = items [i];
				switch (instruction.opcode.OperandType) {
				case OperandType.ShortInlineBrTarget:
				case OperandType.InlineBrTarget:
					instruction.operand = GetInstruction ((int)instruction.operand);
					break;
				case OperandType.InlineSwitch:
					var offsets = (int [])instruction.operand;
					var branches = new Instruction [offsets.Length];
					for (int j = 0; j < offsets.Length; j++)
						branches [j] = GetInstruction (offsets [j]);

					instruction.operand = branches;
					break;
				}
			}
		}

		Instruction GetInstruction (int offset)
		{
			return GetInstruction (body.Instructions, offset);
		}

		static Instruction GetInstruction (Collection<Instruction> instructions, int offset)
		{
			var size = instructions.size;
			var items = instructions.items;
			if (offset < 0 || offset > items [size - 1].offset)
				return null;

			int min = 0;
			int max = size - 1;
			while (min <= max) {
				int mid = min + ((max - min) / 2);
				var instruction = items [mid];
				var instruction_offset = instruction.offset;

				if (offset == instruction_offset)
					return instruction;

				if (offset < instruction_offset)
					max = mid - 1;
				else
					min = mid + 1;
			}

			return null;
		}

		void ReadSection ()
		{
			Align (4);

			const byte fat_format = 0x40;
			const byte more_sects = 0x80;

			var flags = ReadByte ();
			if ((flags & fat_format) == 0)
				ReadSmallSection ();
			else
				ReadFatSection ();

			if ((flags & more_sects) != 0)
				ReadSection ();
		}

		void ReadSmallSection ()
		{
			var count = ReadByte () / 12;
			Advance (2);

			ReadExceptionHandlers (
				count,
				() => (int)ReadUInt16 (),
				() => (int)ReadByte ());
		}

		void ReadFatSection ()
		{
			Advance (-1);
			var count = (ReadInt32 () >> 8) / 24;

			ReadExceptionHandlers (
				count,
				ReadInt32,
				ReadInt32);
		}

		// inline ?
		void ReadExceptionHandlers (int count, Func<int> read_entry, Func<int> read_length)
		{
			for (int i = 0; i < count; i++) {
				var handler = new ExceptionHandler (
					(ExceptionHandlerType)(read_entry () & 0x7));

				handler.TryStart = GetInstruction (read_entry ());
				handler.TryEnd = GetInstruction (handler.TryStart.Offset + read_length ());

				handler.HandlerStart = GetInstruction (read_entry ());
				handler.HandlerEnd = GetInstruction (handler.HandlerStart.Offset + read_length ());

				ReadExceptionHandlerSpecific (handler);

				this.body.ExceptionHandlers.Add (handler);
			}
		}

		void ReadExceptionHandlerSpecific (ExceptionHandler handler)
		{
			switch (handler.HandlerType) {
			case ExceptionHandlerType.Catch:
				handler.CatchType = (TypeReference)reader.LookupToken (ReadToken ());
				break;
			case ExceptionHandlerType.Filter:
				handler.FilterStart = GetInstruction (ReadInt32 ());
				break;
			default:
				Advance (4);
				break;
			}
		}

		public MetadataToken ReadToken ()
		{
			return new MetadataToken (ReadUInt32 ());
		}

		void ReadDebugInfo ()
		{
			if (method.debug_info.sequence_points != null)
				ReadSequencePoints ();

			if (method.debug_info.scope != null)
				ReadScope (method.debug_info.scope);

			if (method.custom_infos != null)
				ReadCustomDebugInformations (method);
		}

		void ReadCustomDebugInformations (MethodDefinition method)
		{
			var custom_infos = method.custom_infos;

			for (int i = 0; i < custom_infos.Count; i++) {
				var state_machine_scope = custom_infos [i] as StateMachineScopeDebugInformation;
				if (state_machine_scope != null)
					ReadStateMachineScope (state_machine_scope);

				var async_method = custom_infos [i] as AsyncMethodBodyDebugInformation;
				if (async_method != null)
					ReadAsyncMethodBody (async_method);
			}
		}

		void ReadAsyncMethodBody (AsyncMethodBodyDebugInformation async_method)
		{
			if (async_method.catch_handler.Offset > -1)
				async_method.catch_handler = new InstructionOffset (GetInstruction (async_method.catch_handler.Offset));

			if (!async_method.yields.IsNullOrEmpty ())
				for (int i = 0; i < async_method.yields.Count; i++)
					async_method.yields [i] = new InstructionOffset (GetInstruction (async_method.yields [i].Offset));

			if (!async_method.resumes.IsNullOrEmpty ())
				for (int i = 0; i < async_method.resumes.Count; i++)
					async_method.resumes [i] = new InstructionOffset (GetInstruction (async_method.resumes [i].Offset));
		}

		void ReadStateMachineScope (StateMachineScopeDebugInformation state_machine_scope)
		{
			if (state_machine_scope.scopes.IsNullOrEmpty ())
				return;

			foreach (var scope in state_machine_scope.scopes) {
				scope.start = new InstructionOffset (GetInstruction (scope.start.Offset));

				var end_instruction = GetInstruction (scope.end.Offset);
				scope.end = end_instruction == null
					? new InstructionOffset ()
					: new InstructionOffset (end_instruction);
			}
		}

		void ReadSequencePoints ()
		{
			var symbol = method.debug_info;

			for (int i = 0; i < symbol.sequence_points.Count; i++) {
				var sequence_point = symbol.sequence_points [i];
				var instruction = GetInstruction (sequence_point.Offset);
				if (instruction != null)
					sequence_point.offset = new InstructionOffset (instruction);
			}
		}

		void ReadScopes (Collection<ScopeDebugInformation> scopes)
		{
			for (int i = 0; i < scopes.Count; i++)
				ReadScope (scopes [i]);
		}

		void ReadScope (ScopeDebugInformation scope)
		{
			var start_instruction = GetInstruction (scope.Start.Offset);
			if (start_instruction != null)
				scope.Start = new InstructionOffset (start_instruction);

			var end_instruction = GetInstruction (scope.End.Offset);
			scope.End = end_instruction != null
				? new InstructionOffset (end_instruction)
				: new InstructionOffset ();

			if (!scope.variables.IsNullOrEmpty ()) {
				for (int i = 0; i < scope.variables.Count; i++) {
					var variable_info = scope.variables [i];
					var variable = GetVariable (variable_info.Index);
					if (variable != null)
						variable_info.index = new VariableIndex (variable);
				}
			}

			if (!scope.scopes.IsNullOrEmpty ())
				ReadScopes (scope.scopes);
		}

		public ByteBuffer PatchRawMethodBody (MethodDefinition method, CodeWriter writer, out int code_size, out MetadataToken local_var_token)
		{
			var position = MoveTo (method);

			var buffer = new ByteBuffer ();

			var flags = ReadByte ();

			switch (flags & 0x3) {
			case 0x2: // tiny
				buffer.WriteByte (flags);
				local_var_token = MetadataToken.Zero;
				code_size = flags >> 2;
				PatchRawCode (buffer, code_size, writer);
				break;
			case 0x3: // fat
				Advance (-1);
				PatchRawFatMethod (buffer, writer, out code_size, out local_var_token);
				break;
			default:
				throw new NotSupportedException ();
			}

			MoveBackTo (position);

			return buffer;
		}

		void PatchRawFatMethod (ByteBuffer buffer, CodeWriter writer, out int code_size, out MetadataToken local_var_token)
		{
			var flags = ReadUInt16 ();
			buffer.WriteUInt16 (flags);
			buffer.WriteUInt16 (ReadUInt16 ());
			code_size = ReadInt32 ();
			buffer.WriteInt32 (code_size);
			local_var_token = ReadToken ();

			if (local_var_token.RID > 0) {
				var variables = ReadVariables (local_var_token);
				buffer.WriteUInt32 (variables != null
					? writer.GetStandAloneSignature (variables).ToUInt32 ()
					: 0);
			} else
				buffer.WriteUInt32 (0);

			PatchRawCode (buffer, code_size, writer);

			if ((flags & 0x8) != 0)
				PatchRawSection (buffer, writer.metadata);
		}

		void PatchRawCode (ByteBuffer buffer, int code_size, CodeWriter writer)
		{
			var metadata = writer.metadata;
			buffer.WriteBytes (ReadBytes (code_size));
			var end = buffer.position;
			buffer.position -= code_size;

			while (buffer.position < end) {
				OpCode opcode;
				var il_opcode = buffer.ReadByte ();
				if (il_opcode != 0xfe) {
					opcode = OpCodes.OneByteOpCode [il_opcode];
				} else {
					var il_opcode2 = buffer.ReadByte ();
					opcode = OpCodes.TwoBytesOpCode [il_opcode2];
				}

				switch (opcode.OperandType) {
				case OperandType.ShortInlineI:
				case OperandType.ShortInlineBrTarget:
				case OperandType.ShortInlineVar:
				case OperandType.ShortInlineArg:
					buffer.position += 1;
					break;
				case OperandType.InlineVar:
				case OperandType.InlineArg:
					buffer.position += 2;
					break;
				case OperandType.InlineBrTarget:
				case OperandType.ShortInlineR:
				case OperandType.InlineI:
					buffer.position += 4;
					break;
				case OperandType.InlineI8:
				case OperandType.InlineR:
					buffer.position += 8;
					break;
				case OperandType.InlineSwitch:
					var length = buffer.ReadInt32 ();
					buffer.position += length * 4;
					break;
				case OperandType.InlineString:
					var @string = GetString (new MetadataToken (buffer.ReadUInt32 ()));
					buffer.position -= 4;
					buffer.WriteUInt32 (
						new MetadataToken (
							TokenType.String,
							metadata.user_string_heap.GetStringIndex (@string)).ToUInt32 ());
					break;
				case OperandType.InlineSig:
					var call_site = GetCallSite (new MetadataToken (buffer.ReadUInt32 ()));
					buffer.position -= 4;
					buffer.WriteUInt32 (writer.GetStandAloneSignature (call_site).ToUInt32 ());
					break;
				case OperandType.InlineTok:
				case OperandType.InlineType:
				case OperandType.InlineMethod:
				case OperandType.InlineField:
					var provider = reader.LookupToken (new MetadataToken (buffer.ReadUInt32 ()));
					buffer.position -= 4;
					buffer.WriteUInt32 (metadata.LookupToken (provider).ToUInt32 ());
					break;
				}
			}
		}

		void PatchRawSection (ByteBuffer buffer, MetadataBuilder metadata)
		{
			var position = Position;
			Align (4);
			buffer.WriteBytes (Position - position);

			const byte fat_format = 0x40;
			const byte more_sects = 0x80;

			var flags = ReadByte ();
			if ((flags & fat_format) == 0) {
				buffer.WriteByte (flags);
				PatchRawSmallSection (buffer, metadata);
			} else
				PatchRawFatSection (buffer, metadata);

			if ((flags & more_sects) != 0)
				PatchRawSection (buffer, metadata);
		}

		void PatchRawSmallSection (ByteBuffer buffer, MetadataBuilder metadata)
		{
			var length = ReadByte ();
			buffer.WriteByte (length);
			Advance (2);

			buffer.WriteUInt16 (0);

			var count = length / 12;

			PatchRawExceptionHandlers (buffer, metadata, count, false);
		}

		void PatchRawFatSection (ByteBuffer buffer, MetadataBuilder metadata)
		{
			Advance (-1);
			var length = ReadInt32 ();
			buffer.WriteInt32 (length);

			var count = (length >> 8) / 24;

			PatchRawExceptionHandlers (buffer, metadata, count, true);
		}

		void PatchRawExceptionHandlers (ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry)
		{
			const int fat_entry_size = 16;
			const int small_entry_size = 6;

			for (int i = 0; i < count; i++) {
				ExceptionHandlerType handler_type;
				if (fat_entry) {
					var type = ReadUInt32 ();
					handler_type = (ExceptionHandlerType)(type & 0x7);
					buffer.WriteUInt32 (type);
				} else {
					var type = ReadUInt16 ();
					handler_type = (ExceptionHandlerType)(type & 0x7);
					buffer.WriteUInt16 (type);
				}

				buffer.WriteBytes (ReadBytes (fat_entry ? fat_entry_size : small_entry_size));

				switch (handler_type) {
				case ExceptionHandlerType.Catch:
					var exception = reader.LookupToken (ReadToken ());
					buffer.WriteUInt32 (metadata.LookupToken (exception).ToUInt32 ());
					break;
				default:
					buffer.WriteUInt32 (ReadUInt32 ());
					break;
				}
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/CodeWriter.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using MonoFN.Cecil.PE;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using RVA = System.UInt32;

namespace MonoFN.Cecil.Cil {

	sealed class CodeWriter : ByteBuffer {

		readonly RVA code_base;
		internal readonly MetadataBuilder metadata;
		readonly Dictionary<uint, MetadataToken> standalone_signatures;
		readonly Dictionary<ByteBuffer, RVA> tiny_method_bodies;

		MethodBody body;

		public CodeWriter (MetadataBuilder metadata)
			: base (0)
		{
			this.code_base = metadata.text_map.GetNextRVA (TextSegment.CLIHeader);
			this.metadata = metadata;
			this.standalone_signatures = new Dictionary<uint, MetadataToken> ();
			this.tiny_method_bodies = new Dictionary<ByteBuffer, RVA> (new ByteBufferEqualityComparer ());
		}

		public RVA WriteMethodBody (MethodDefinition method)
		{
			RVA rva;

			if (IsUnresolved (method)) {
				if (method.rva == 0)
					return 0;

				rva = WriteUnresolvedMethodBody (method);
			} else {
				if (IsEmptyMethodBody (method.Body))
					return 0;

				rva = WriteResolvedMethodBody (method);
			}

			return rva;
		}

		static bool IsEmptyMethodBody (MethodBody body)
		{
			return body.instructions.IsNullOrEmpty ()
				&& body.variables.IsNullOrEmpty ();
		}

		static bool IsUnresolved (MethodDefinition method)
		{
			return method.HasBody && method.HasImage && method.body == null;
		}

		RVA WriteUnresolvedMethodBody (MethodDefinition method)
		{
			var code_reader = metadata.module.reader.code;

			int code_size;
			MetadataToken local_var_token;
			var raw_body = code_reader.PatchRawMethodBody (method, this, out code_size, out local_var_token);
			var fat_header = (raw_body.buffer [0] & 0x3) == 0x3;
			if (fat_header)
				Align (4);

			var rva = BeginMethod ();

			if (fat_header || !GetOrMapTinyMethodBody (raw_body, ref rva)) {
				WriteBytes (raw_body);
			}

			if (method.debug_info == null)
				return rva;

			var symbol_writer = metadata.symbol_writer;
			if (symbol_writer != null) {
				method.debug_info.code_size = code_size;
				method.debug_info.local_var_token = local_var_token;
				symbol_writer.Write (method.debug_info);
			}

			return rva;
		}

		RVA WriteResolvedMethodBody (MethodDefinition method)
		{
			RVA rva;

			body = method.Body;
			ComputeHeader ();
			if (RequiresFatHeader ()) {
				Align (4);
				rva = BeginMethod ();
				WriteFatHeader ();
				WriteInstructions ();

				if (body.HasExceptionHandlers)
					WriteExceptionHandlers ();
			} else {
				rva = BeginMethod ();
				WriteByte ((byte)(0x2 | (body.CodeSize << 2))); // tiny
				WriteInstructions ();

				var start_position = (int)(rva - code_base);
				var body_size = position - start_position;
				var body_bytes = new byte [body_size];

				Array.Copy (buffer, start_position, body_bytes, 0, body_size);

				if (GetOrMapTinyMethodBody (new ByteBuffer (body_bytes), ref rva))
					position = start_position;
			}

			var symbol_writer = metadata.symbol_writer;
			if (symbol_writer != null && method.debug_info != null) {
				method.debug_info.code_size = body.CodeSize;
				method.debug_info.local_var_token = body.local_var_token;
				symbol_writer.Write (method.debug_info);
			}

			return rva;
		}

		bool GetOrMapTinyMethodBody (ByteBuffer body, ref RVA rva)
		{
			RVA existing_rva;
			if (tiny_method_bodies.TryGetValue (body, out existing_rva)) {
				rva = existing_rva;
				return true;
			}

			tiny_method_bodies.Add (body, rva);
			return false;
		}

		void WriteFatHeader ()
		{
			var body = this.body;
			byte flags = 0x3;   // fat
			if (body.InitLocals)
				flags |= 0x10;  // init locals
			if (body.HasExceptionHandlers)
				flags |= 0x8;   // more sections

			WriteByte (flags);
			WriteByte (0x30);
			WriteInt16 ((short)body.max_stack_size);
			WriteInt32 (body.code_size);
			body.local_var_token = body.HasVariables
				? GetStandAloneSignature (body.Variables)
				: MetadataToken.Zero;
			WriteMetadataToken (body.local_var_token);
		}

		void WriteInstructions ()
		{
			var instructions = body.Instructions;
			var items = instructions.items;
			var size = instructions.size;

			for (int i = 0; i < size; i++) {
				var instruction = items [i];
				WriteOpCode (instruction.opcode);
				WriteOperand (instruction);
			}
		}

		void WriteOpCode (OpCode opcode)
		{
			if (opcode.Size == 1) {
				WriteByte (opcode.Op2);
			} else {
				WriteByte (opcode.Op1);
				WriteByte (opcode.Op2);
			}
		}

		void WriteOperand (Instruction instruction)
		{
			var opcode = instruction.opcode;
			var operand_type = opcode.OperandType;
			if (operand_type == OperandType.InlineNone)
				return;

			var operand = instruction.operand;
			if (operand == null && !(operand_type == OperandType.InlineBrTarget || operand_type == OperandType.ShortInlineBrTarget)) {
				throw new ArgumentException ();
			}

			switch (operand_type) {
			case OperandType.InlineSwitch: {
					var targets = (Instruction [])operand;
					WriteInt32 (targets.Length);
					var diff = instruction.Offset + opcode.Size + (4 * (targets.Length + 1));
					for (int i = 0; i < targets.Length; i++)
						WriteInt32 (GetTargetOffset (targets [i]) - diff);
					break;
				}
			case OperandType.ShortInlineBrTarget: {
					var target = (Instruction)operand;
					var offset = target != null ? GetTargetOffset (target) : body.code_size;
					WriteSByte ((sbyte)(offset - (instruction.Offset + opcode.Size + 1)));
					break;
				}
			case OperandType.InlineBrTarget: {
					var target = (Instruction)operand;
					var offset = target != null ? GetTargetOffset (target) : body.code_size;
					WriteInt32 (offset - (instruction.Offset + opcode.Size + 4));
					break;
				}
			case OperandType.ShortInlineVar:
				WriteByte ((byte)GetVariableIndex ((VariableDefinition)operand));
				break;
			case OperandType.ShortInlineArg:
				WriteByte ((byte)GetParameterIndex ((ParameterDefinition)operand));
				break;
			case OperandType.InlineVar:
				WriteInt16 ((short)GetVariableIndex ((VariableDefinition)operand));
				break;
			case OperandType.InlineArg:
				WriteInt16 ((short)GetParameterIndex ((ParameterDefinition)operand));
				break;
			case OperandType.InlineSig:
				WriteMetadataToken (GetStandAloneSignature ((CallSite)operand));
				break;
			case OperandType.ShortInlineI:
				if (opcode == OpCodes.Ldc_I4_S)
					WriteSByte ((sbyte)operand);
				else
					WriteByte ((byte)operand);
				break;
			case OperandType.InlineI:
				WriteInt32 ((int)operand);
				break;
			case OperandType.InlineI8:
				WriteInt64 ((long)operand);
				break;
			case OperandType.ShortInlineR:
				WriteSingle ((float)operand);
				break;
			case OperandType.InlineR:
				WriteDouble ((double)operand);
				break;
			case OperandType.InlineString:
				WriteMetadataToken (
					new MetadataToken (
						TokenType.String,
						GetUserStringIndex ((string)operand)));
				break;
			case OperandType.InlineType:
			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
				WriteMetadataToken (metadata.LookupToken ((IMetadataTokenProvider)operand));
				break;
			default:
				throw new ArgumentException ();
			}
		}

		int GetTargetOffset (Instruction instruction)
		{
			if (instruction == null) {
				var last = body.instructions [body.instructions.size - 1];
				return last.offset + last.GetSize ();
			}

			return instruction.offset;
		}

		uint GetUserStringIndex (string @string)
		{
			if (@string == null)
				return 0;

			return metadata.user_string_heap.GetStringIndex (@string);
		}

		static int GetVariableIndex (VariableDefinition variable)
		{
			return variable.Index;
		}

		int GetParameterIndex (ParameterDefinition parameter)
		{
			if (body.method.HasThis) {
				if (parameter == body.this_parameter)
					return 0;

				return parameter.Index + 1;
			}

			return parameter.Index;
		}

		bool RequiresFatHeader ()
		{
			var body = this.body;
			return body.CodeSize >= 64
				|| body.InitLocals
				|| body.HasVariables
				|| body.HasExceptionHandlers
				|| body.MaxStackSize > 8;
		}

		void ComputeHeader ()
		{
			int offset = 0;
			var instructions = body.instructions;
			var items = instructions.items;
			var count = instructions.size;
			var stack_size = 0;
			var max_stack = 0;
			Dictionary<Instruction, int> stack_sizes = null;

			if (body.HasExceptionHandlers)
				ComputeExceptionHandlerStackSize (ref stack_sizes);

			for (int i = 0; i < count; i++) {
				var instruction = items [i];
				instruction.offset = offset;
				offset += instruction.GetSize ();

				ComputeStackSize (instruction, ref stack_sizes, ref stack_size, ref max_stack);
			}

			body.code_size = offset;
			body.max_stack_size = max_stack;
		}

		void ComputeExceptionHandlerStackSize (ref Dictionary<Instruction, int> stack_sizes)
		{
			var exception_handlers = body.ExceptionHandlers;

			for (int i = 0; i < exception_handlers.Count; i++) {
				var exception_handler = exception_handlers [i];

				switch (exception_handler.HandlerType) {
				case ExceptionHandlerType.Catch:
					AddExceptionStackSize (exception_handler.HandlerStart, ref stack_sizes);
					break;
				case ExceptionHandlerType.Filter:
					AddExceptionStackSize (exception_handler.FilterStart, ref stack_sizes);
					AddExceptionStackSize (exception_handler.HandlerStart, ref stack_sizes);
					break;
				}
			}
		}

		static void AddExceptionStackSize (Instruction handler_start, ref Dictionary<Instruction, int> stack_sizes)
		{
			if (handler_start == null)
				return;

			if (stack_sizes == null)
				stack_sizes = new Dictionary<Instruction, int> ();

			stack_sizes [handler_start] = 1;
		}

		static void ComputeStackSize (Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, ref int stack_size, ref int max_stack)
		{
			int computed_size;
			if (stack_sizes != null && stack_sizes.TryGetValue (instruction, out computed_size))
				stack_size = computed_size;

			max_stack = System.Math.Max (max_stack, stack_size);
			ComputeStackDelta (instruction, ref stack_size);
			max_stack = System.Math.Max (max_stack, stack_size);

			CopyBranchStackSize (instruction, ref stack_sizes, stack_size);
			ComputeStackSize (instruction, ref stack_size);
		}

		static void CopyBranchStackSize (Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, int stack_size)
		{
			if (stack_size == 0)
				return;

			switch (instruction.opcode.OperandType) {
			case OperandType.ShortInlineBrTarget:
			case OperandType.InlineBrTarget:
				CopyBranchStackSize (ref stack_sizes, (Instruction)instruction.operand, stack_size);
				break;
			case OperandType.InlineSwitch:
				var targets = (Instruction [])instruction.operand;
				for (int i = 0; i < targets.Length; i++)
					CopyBranchStackSize (ref stack_sizes, targets [i], stack_size);
				break;
			}
		}

		static void CopyBranchStackSize (ref Dictionary<Instruction, int> stack_sizes, Instruction target, int stack_size)
		{
			if (stack_sizes == null)
				stack_sizes = new Dictionary<Instruction, int> ();

			int branch_stack_size = stack_size;

			int computed_size;
			if (stack_sizes.TryGetValue (target, out computed_size))
				branch_stack_size = System.Math.Max (branch_stack_size, computed_size);

			stack_sizes [target] = branch_stack_size;
		}

		static void ComputeStackSize (Instruction instruction, ref int stack_size)
		{
			switch (instruction.opcode.FlowControl) {
			case FlowControl.Branch:
			case FlowControl.Throw:
			case FlowControl.Return:
				stack_size = 0;
				break;
			}
		}

		static void ComputeStackDelta (Instruction instruction, ref int stack_size)
		{
			switch (instruction.opcode.FlowControl) {
			case FlowControl.Call: {
					var method = (IMethodSignature)instruction.operand;
					// pop 'this' argument
					if (method.HasImplicitThis () && instruction.opcode.Code != Code.Newobj)
						stack_size--;
					// pop normal arguments
					if (method.HasParameters)
						stack_size -= method.Parameters.Count;
					// pop function pointer
					if (instruction.opcode.Code == Code.Calli)
						stack_size--;
					// push return value
					if (method.ReturnType.etype != ElementType.Void || instruction.opcode.Code == Code.Newobj)
						stack_size++;
					break;
				}
			default:
				ComputePopDelta (instruction.opcode.StackBehaviourPop, ref stack_size);
				ComputePushDelta (instruction.opcode.StackBehaviourPush, ref stack_size);
				break;
			}
		}

		static void ComputePopDelta (StackBehaviour pop_behavior, ref int stack_size)
		{
			switch (pop_behavior) {
			case StackBehaviour.Popi:
			case StackBehaviour.Popref:
			case StackBehaviour.Pop1:
				stack_size--;
				break;
			case StackBehaviour.Pop1_pop1:
			case StackBehaviour.Popi_pop1:
			case StackBehaviour.Popi_popi:
			case StackBehaviour.Popi_popi8:
			case StackBehaviour.Popi_popr4:
			case StackBehaviour.Popi_popr8:
			case StackBehaviour.Popref_pop1:
			case StackBehaviour.Popref_popi:
				stack_size -= 2;
				break;
			case StackBehaviour.Popi_popi_popi:
			case StackBehaviour.Popref_popi_popi:
			case StackBehaviour.Popref_popi_popi8:
			case StackBehaviour.Popref_popi_popr4:
			case StackBehaviour.Popref_popi_popr8:
			case StackBehaviour.Popref_popi_popref:
				stack_size -= 3;
				break;
			case StackBehaviour.PopAll:
				stack_size = 0;
				break;
			}
		}

		static void ComputePushDelta (StackBehaviour push_behaviour, ref int stack_size)
		{
			switch (push_behaviour) {
			case StackBehaviour.Push1:
			case StackBehaviour.Pushi:
			case StackBehaviour.Pushi8:
			case StackBehaviour.Pushr4:
			case StackBehaviour.Pushr8:
			case StackBehaviour.Pushref:
				stack_size++;
				break;
			case StackBehaviour.Push1_push1:
				stack_size += 2;
				break;
			}
		}

		void WriteExceptionHandlers ()
		{
			Align (4);

			var handlers = body.ExceptionHandlers;

			if (handlers.Count < 0x15 && !RequiresFatSection (handlers))
				WriteSmallSection (handlers);
			else
				WriteFatSection (handlers);
		}

		static bool RequiresFatSection (Collection<ExceptionHandler> handlers)
		{
			for (int i = 0; i < handlers.Count; i++) {
				var handler = handlers [i];

				if (IsFatRange (handler.TryStart, handler.TryEnd))
					return true;

				if (IsFatRange (handler.HandlerStart, handler.HandlerEnd))
					return true;

				if (handler.HandlerType == ExceptionHandlerType.Filter
					&& IsFatRange (handler.FilterStart, handler.HandlerStart))
					return true;
			}

			return false;
		}

		static bool IsFatRange (Instruction start, Instruction end)
		{
			if (start == null)
				throw new ArgumentException ();

			if (end == null)
				return true;

			return end.Offset - start.Offset > 255 || start.Offset > 65535;
		}

		void WriteSmallSection (Collection<ExceptionHandler> handlers)
		{
			const byte eh_table = 0x1;

			WriteByte (eh_table);
			WriteByte ((byte)(handlers.Count * 12 + 4));
			WriteBytes (2);

			WriteExceptionHandlers (
				handlers,
				i => WriteUInt16 ((ushort)i),
				i => WriteByte ((byte)i));
		}

		void WriteFatSection (Collection<ExceptionHandler> handlers)
		{
			const byte eh_table = 0x1;
			const byte fat_format = 0x40;

			WriteByte (eh_table | fat_format);

			int size = handlers.Count * 24 + 4;
			WriteByte ((byte)(size & 0xff));
			WriteByte ((byte)((size >> 8) & 0xff));
			WriteByte ((byte)((size >> 16) & 0xff));

			WriteExceptionHandlers (handlers, WriteInt32, WriteInt32);
		}

		void WriteExceptionHandlers (Collection<ExceptionHandler> handlers, Action<int> write_entry, Action<int> write_length)
		{
			for (int i = 0; i < handlers.Count; i++) {
				var handler = handlers [i];

				write_entry ((int)handler.HandlerType);

				write_entry (handler.TryStart.Offset);
				write_length (GetTargetOffset (handler.TryEnd) - handler.TryStart.Offset);

				write_entry (handler.HandlerStart.Offset);
				write_length (GetTargetOffset (handler.HandlerEnd) - handler.HandlerStart.Offset);

				WriteExceptionHandlerSpecific (handler);
			}
		}

		void WriteExceptionHandlerSpecific (ExceptionHandler handler)
		{
			switch (handler.HandlerType) {
			case ExceptionHandlerType.Catch:
				WriteMetadataToken (metadata.LookupToken (handler.CatchType));
				break;
			case ExceptionHandlerType.Filter:
				WriteInt32 (handler.FilterStart.Offset);
				break;
			default:
				WriteInt32 (0);
				break;
			}
		}

		public MetadataToken GetStandAloneSignature (Collection<VariableDefinition> variables)
		{
			var signature = metadata.GetLocalVariableBlobIndex (variables);

			return GetStandAloneSignatureToken (signature);
		}

		public MetadataToken GetStandAloneSignature (CallSite call_site)
		{
			var signature = metadata.GetCallSiteBlobIndex (call_site);
			var token = GetStandAloneSignatureToken (signature);
			call_site.MetadataToken = token;
			return token;
		}

		MetadataToken GetStandAloneSignatureToken (uint signature)
		{
			MetadataToken token;
			if (standalone_signatures.TryGetValue (signature, out token))
				return token;

			token = new MetadataToken (TokenType.Signature, metadata.AddStandAloneSignature (signature));
			standalone_signatures.Add (signature, token);
			return token;
		}

		RVA BeginMethod ()
		{
			return (RVA)(code_base + position);
		}

		void WriteMetadataToken (MetadataToken token)
		{
			WriteUInt32 (token.ToUInt32 ());
		}

		void Align (int align)
		{
			align--;
			WriteBytes (((position + align) & ~align) - position);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/Document.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil.Cil {

	public enum DocumentType {
		Other,
		Text,
	}

	public enum DocumentHashAlgorithm {
		None,
		MD5,
		SHA1,
		SHA256,
	}

	public enum DocumentLanguage {
		Other,
		C,
		Cpp,
		CSharp,
		Basic,
		Java,
		Cobol,
		Pascal,
		Cil,
		JScript,
		Smc,
		MCpp,
		FSharp,
	}

	public enum DocumentLanguageVendor {
		Other,
		Microsoft,
	}

	public sealed class Document : DebugInformation {

		string url;

		Guid type;
		Guid hash_algorithm;
		Guid language;
		Guid language_vendor;

		byte [] hash;
		byte [] embedded_source;

		public string Url {
			get { return url; }
			set { url = value; }
		}

		public DocumentType Type {
			get { return type.ToType (); }
			set { type = value.ToGuid (); }
		}

		public Guid TypeGuid {
			get { return type; }
			set { type = value; }
		}

		public DocumentHashAlgorithm HashAlgorithm {
			get { return hash_algorithm.ToHashAlgorithm (); }
			set { hash_algorithm = value.ToGuid (); }
		}

		public Guid HashAlgorithmGuid {
			get { return hash_algorithm; }
			set { hash_algorithm = value; }
		}

		public DocumentLanguage Language {
			get { return language.ToLanguage (); }
			set { language = value.ToGuid (); }
		}

		public Guid LanguageGuid {
			get { return language; }
			set { language = value; }
		}

		public DocumentLanguageVendor LanguageVendor {
			get { return language_vendor.ToVendor (); }
			set { language_vendor = value.ToGuid (); }
		}

		public Guid LanguageVendorGuid {
			get { return language_vendor; }
			set { language_vendor = value; }
		}

		public byte [] Hash {
			get { return hash; }
			set { hash = value; }
		}

		public byte [] EmbeddedSource {
			get { return embedded_source; }
			set { embedded_source = value; }
		}

		public Document (string url)
		{
			this.url = url;
			this.hash = Empty<byte>.Array;
			this.embedded_source = Empty<byte>.Array;
			this.token = new MetadataToken (TokenType.Document);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/ExceptionHandler.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Cil {

	public enum ExceptionHandlerType {
		Catch = 0,
		Filter = 1,
		Finally = 2,
		Fault = 4,
	}

	public sealed class ExceptionHandler {

		Instruction try_start;
		Instruction try_end;
		Instruction filter_start;
		Instruction handler_start;
		Instruction handler_end;

		TypeReference catch_type;
		ExceptionHandlerType handler_type;

		public Instruction TryStart {
			get { return try_start; }
			set { try_start = value; }
		}

		public Instruction TryEnd {
			get { return try_end; }
			set { try_end = value; }
		}

		public Instruction FilterStart {
			get { return filter_start; }
			set { filter_start = value; }
		}

		public Instruction HandlerStart {
			get { return handler_start; }
			set { handler_start = value; }
		}

		public Instruction HandlerEnd {
			get { return handler_end; }
			set { handler_end = value; }
		}

		public TypeReference CatchType {
			get { return catch_type; }
			set { catch_type = value; }
		}

		public ExceptionHandlerType HandlerType {
			get { return handler_type; }
			set { handler_type = value; }
		}

		public ExceptionHandler (ExceptionHandlerType handlerType)
		{
			this.handler_type = handlerType;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/ILProcessor.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;

namespace MonoFN.Cecil.Cil {

	public sealed class ILProcessor {

		readonly MethodBody body;
		readonly Collection<Instruction> instructions;

		public MethodBody Body {
			get { return body; }
		}

		internal ILProcessor (MethodBody body)
		{
			this.body = body;
			this.instructions = body.Instructions;
		}

		public Instruction Create (OpCode opcode)
		{
			return Instruction.Create (opcode);
		}

		public Instruction Create (OpCode opcode, TypeReference type)
		{
			return Instruction.Create (opcode, type);
		}

		public Instruction Create (OpCode opcode, CallSite site)
		{
			return Instruction.Create (opcode, site);
		}

		public Instruction Create (OpCode opcode, MethodReference method)
		{
			return Instruction.Create (opcode, method);
		}

		public Instruction Create (OpCode opcode, FieldReference field)
		{
			return Instruction.Create (opcode, field);
		}

		public Instruction Create (OpCode opcode, string value)
		{
			return Instruction.Create (opcode, value);
		}

		public Instruction Create (OpCode opcode, sbyte value)
		{
			return Instruction.Create (opcode, value);
		}

		public Instruction Create (OpCode opcode, byte value)
		{
			if (opcode.OperandType == OperandType.ShortInlineVar)
				return Instruction.Create (opcode, body.Variables [value]);

			if (opcode.OperandType == OperandType.ShortInlineArg)
				return Instruction.Create (opcode, body.GetParameter (value));

			return Instruction.Create (opcode, value);
		}

		public Instruction Create (OpCode opcode, int value)
		{
			if (opcode.OperandType == OperandType.InlineVar)
				return Instruction.Create (opcode, body.Variables [value]);

			if (opcode.OperandType == OperandType.InlineArg)
				return Instruction.Create (opcode, body.GetParameter (value));

			return Instruction.Create (opcode, value);
		}

		public Instruction Create (OpCode opcode, long value)
		{
			return Instruction.Create (opcode, value);
		}

		public Instruction Create (OpCode opcode, float value)
		{
			return Instruction.Create (opcode, value);
		}

		public Instruction Create (OpCode opcode, double value)
		{
			return Instruction.Create (opcode, value);
		}

		public Instruction Create (OpCode opcode, Instruction target)
		{
			return Instruction.Create (opcode, target);
		}

		public Instruction Create (OpCode opcode, Instruction [] targets)
		{
			return Instruction.Create (opcode, targets);
		}

		public Instruction Create (OpCode opcode, VariableDefinition variable)
		{
			return Instruction.Create (opcode, variable);
		}

		public Instruction Create (OpCode opcode, ParameterDefinition parameter)
		{
			return Instruction.Create (opcode, parameter);
		}

		public void Emit (OpCode opcode)
		{
			Append (Create (opcode));
		}

		public void Emit (OpCode opcode, TypeReference type)
		{
			Append (Create (opcode, type));
		}

		public void Emit (OpCode opcode, MethodReference method)
		{
			Append (Create (opcode, method));
		}

		public void Emit (OpCode opcode, CallSite site)
		{
			Append (Create (opcode, site));
		}

		public void Emit (OpCode opcode, FieldReference field)
		{
			Append (Create (opcode, field));
		}

		public void Emit (OpCode opcode, string value)
		{
			Append (Create (opcode, value));
		}

		public void Emit (OpCode opcode, byte value)
		{
			Append (Create (opcode, value));
		}

		public void Emit (OpCode opcode, sbyte value)
		{
			Append (Create (opcode, value));
		}

		public void Emit (OpCode opcode, int value)
		{
			Append (Create (opcode, value));
		}

		public void Emit (OpCode opcode, long value)
		{
			Append (Create (opcode, value));
		}

		public void Emit (OpCode opcode, float value)
		{
			Append (Create (opcode, value));
		}

		public void Emit (OpCode opcode, double value)
		{
			Append (Create (opcode, value));
		}

		public void Emit (OpCode opcode, Instruction target)
		{
			Append (Create (opcode, target));
		}

		public void Emit (OpCode opcode, Instruction [] targets)
		{
			Append (Create (opcode, targets));
		}

		public void Emit (OpCode opcode, VariableDefinition variable)
		{
			Append (Create (opcode, variable));
		}

		public void Emit (OpCode opcode, ParameterDefinition parameter)
		{
			Append (Create (opcode, parameter));
		}

		public void InsertBefore (Instruction target, Instruction instruction)
		{
			if (target == null)
				throw new ArgumentNullException ("target");
			if (instruction == null)
				throw new ArgumentNullException ("instruction");

			var index = instructions.IndexOf (target);
			if (index == -1)
				throw new ArgumentOutOfRangeException ("target");

			instructions.Insert (index, instruction);
		}

		public void InsertAfter (Instruction target, Instruction instruction)
		{
			if (target == null)
				throw new ArgumentNullException ("target");
			if (instruction == null)
				throw new ArgumentNullException ("instruction");

			var index = instructions.IndexOf (target);
			if (index == -1)
				throw new ArgumentOutOfRangeException ("target");

			instructions.Insert (index + 1, instruction);
		}

		public void InsertAfter (int index, Instruction instruction)
		{
			if (index < 0 || index >= instructions.Count)
				throw new ArgumentOutOfRangeException ("index");
			if (instruction == null)
				throw new ArgumentNullException ("instruction");

			instructions.Insert (index + 1, instruction);
		}

		public void Append (Instruction instruction)
		{
			if (instruction == null)
				throw new ArgumentNullException ("instruction");

			instructions.Add (instruction);
		}

		public void Replace (Instruction target, Instruction instruction)
		{
			if (target == null)
				throw new ArgumentNullException ("target");
			if (instruction == null)
				throw new ArgumentNullException ("instruction");

			InsertAfter (target, instruction);
			Remove (target);
		}

		public void Replace (int index, Instruction instruction)
		{
			if (instruction == null)
				throw new ArgumentNullException ("instruction");

			InsertAfter (index, instruction);
			RemoveAt (index);
		}

		public void Remove (Instruction instruction)
		{
			if (instruction == null)
				throw new ArgumentNullException ("instruction");

			if (!instructions.Remove (instruction))
				throw new ArgumentOutOfRangeException ("instruction");
		}

		public void RemoveAt (int index)
		{
			if (index < 0 || index >= instructions.Count)
				throw new ArgumentOutOfRangeException ("index");

			instructions.RemoveAt (index);
		}

		public void Clear ()
		{
			instructions.Clear ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/Instruction.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Text;

namespace MonoFN.Cecil.Cil {

	public sealed class Instruction {

		internal int offset;
		internal OpCode opcode;
		internal object operand;

		internal Instruction previous;
		internal Instruction next;

		public int Offset {
			get { return offset; }
			set { offset = value; }
		}

		public OpCode OpCode {
			get { return opcode; }
			set { opcode = value; }
		}

		public object Operand {
			get { return operand; }
			set { operand = value; }
		}

		public Instruction Previous {
			get { return previous; }
			set { previous = value; }
		}

		public Instruction Next {
			get { return next; }
			set { next = value; }
		}

		internal Instruction (int offset, OpCode opCode)
		{
			this.offset = offset;
			this.opcode = opCode;
		}

		internal Instruction (OpCode opcode, object operand)
		{
			this.opcode = opcode;
			this.operand = operand;
		}

		public int GetSize ()
		{
			int size = opcode.Size;

			switch (opcode.OperandType) {
			case OperandType.InlineSwitch:
				return size + (1 + ((Instruction [])operand).Length) * 4;
			case OperandType.InlineI8:
			case OperandType.InlineR:
				return size + 8;
			case OperandType.InlineBrTarget:
			case OperandType.InlineField:
			case OperandType.InlineI:
			case OperandType.InlineMethod:
			case OperandType.InlineString:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			case OperandType.ShortInlineR:
			case OperandType.InlineSig:
				return size + 4;
			case OperandType.InlineArg:
			case OperandType.InlineVar:
				return size + 2;
			case OperandType.ShortInlineBrTarget:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineArg:
			case OperandType.ShortInlineVar:
				return size + 1;
			default:
				return size;
			}
		}

		public override string ToString ()
		{
			var instruction = new StringBuilder ();

			AppendLabel (instruction, this);
			instruction.Append (':');
			instruction.Append (' ');
			instruction.Append (opcode.Name);

			if (operand == null)
				return instruction.ToString ();

			instruction.Append (' ');

			switch (opcode.OperandType) {
			case OperandType.ShortInlineBrTarget:
			case OperandType.InlineBrTarget:
				AppendLabel (instruction, (Instruction)operand);
				break;
			case OperandType.InlineSwitch:
				var labels = (Instruction [])operand;
				for (int i = 0; i < labels.Length; i++) {
					if (i > 0)
						instruction.Append (',');

					AppendLabel (instruction, labels [i]);
				}
				break;
			case OperandType.InlineString:
				instruction.Append ('\"');
				instruction.Append (operand);
				instruction.Append ('\"');
				break;
			default:
				instruction.Append (operand);
				break;
			}

			return instruction.ToString ();
		}

		static void AppendLabel (StringBuilder builder, Instruction instruction)
		{
			builder.Append ("IL_");
			builder.Append (instruction.offset.ToString ("x4"));
		}

		public static Instruction Create (OpCode opcode)
		{
			if (opcode.OperandType != OperandType.InlineNone)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, null);
		}

		public static Instruction Create (OpCode opcode, TypeReference type)
		{
			if (type == null)
				throw new ArgumentNullException ("type");
			if (opcode.OperandType != OperandType.InlineType &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, type);
		}

		public static Instruction Create (OpCode opcode, CallSite site)
		{
			if (site == null)
				throw new ArgumentNullException ("site");
			if (opcode.Code != Code.Calli)
				throw new ArgumentException ("code");

			return new Instruction (opcode, site);
		}

		public static Instruction Create (OpCode opcode, MethodReference method)
		{
			if (method == null)
				throw new ArgumentNullException ("method");
			if (opcode.OperandType != OperandType.InlineMethod &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, method);
		}

		public static Instruction Create (OpCode opcode, FieldReference field)
		{
			if (field == null)
				throw new ArgumentNullException ("field");
			if (opcode.OperandType != OperandType.InlineField &&
				opcode.OperandType != OperandType.InlineTok)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, field);
		}

		public static Instruction Create (OpCode opcode, string value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");
			if (opcode.OperandType != OperandType.InlineString)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, value);
		}

		public static Instruction Create (OpCode opcode, sbyte value)
		{
			if (opcode.OperandType != OperandType.ShortInlineI &&
				opcode != OpCodes.Ldc_I4_S)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, value);
		}

		public static Instruction Create (OpCode opcode, byte value)
		{
			if (opcode.OperandType != OperandType.ShortInlineI ||
				opcode == OpCodes.Ldc_I4_S)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, value);
		}

		public static Instruction Create (OpCode opcode, int value)
		{
			if (opcode.OperandType != OperandType.InlineI)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, value);
		}

		public static Instruction Create (OpCode opcode, long value)
		{
			if (opcode.OperandType != OperandType.InlineI8)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, value);
		}

		public static Instruction Create (OpCode opcode, float value)
		{
			if (opcode.OperandType != OperandType.ShortInlineR)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, value);
		}

		public static Instruction Create (OpCode opcode, double value)
		{
			if (opcode.OperandType != OperandType.InlineR)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, value);
		}

		public static Instruction Create (OpCode opcode, Instruction target)
		{
			if (target == null)
				throw new ArgumentNullException ("target");
			if (opcode.OperandType != OperandType.InlineBrTarget &&
				opcode.OperandType != OperandType.ShortInlineBrTarget)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, target);
		}

		public static Instruction Create (OpCode opcode, Instruction [] targets)
		{
			if (targets == null)
				throw new ArgumentNullException ("targets");
			if (opcode.OperandType != OperandType.InlineSwitch)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, targets);
		}

		public static Instruction Create (OpCode opcode, VariableDefinition variable)
		{
			if (variable == null)
				throw new ArgumentNullException ("variable");
			if (opcode.OperandType != OperandType.ShortInlineVar &&
				opcode.OperandType != OperandType.InlineVar)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, variable);
		}

		public static Instruction Create (OpCode opcode, ParameterDefinition parameter)
		{
			if (parameter == null)
				throw new ArgumentNullException ("parameter");
			if (opcode.OperandType != OperandType.ShortInlineArg &&
				opcode.OperandType != OperandType.InlineArg)
				throw new ArgumentException ("opcode");

			return new Instruction (opcode, parameter);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/MethodBody.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Threading;

namespace MonoFN.Cecil.Cil {

	public sealed class MethodBody {

		readonly internal MethodDefinition method;

		internal ParameterDefinition this_parameter;
		internal int max_stack_size;
		internal int code_size;
		internal bool init_locals;
		internal MetadataToken local_var_token;

		internal Collection<Instruction> instructions;
		internal Collection<ExceptionHandler> exceptions;
		internal Collection<VariableDefinition> variables;

		public MethodDefinition Method {
			get { return method; }
		}

		public int MaxStackSize {
			get { return max_stack_size; }
			set { max_stack_size = value; }
		}

		public int CodeSize {
			get { return code_size; }
		}

		public bool InitLocals {
			get { return init_locals; }
			set { init_locals = value; }
		}

		public MetadataToken LocalVarToken {
			get { return local_var_token; }
			set { local_var_token = value; }
		}

		public Collection<Instruction> Instructions {
			get {
				if (instructions == null)
					Interlocked.CompareExchange (ref instructions, new InstructionCollection (method), null);

				return instructions;
			}
		}

		public bool HasExceptionHandlers {
			get { return !exceptions.IsNullOrEmpty (); }
		}

		public Collection<ExceptionHandler> ExceptionHandlers {
			get {
				if (exceptions == null)
					Interlocked.CompareExchange (ref exceptions, new Collection<ExceptionHandler> (), null);

				return exceptions;
			}
		}

		public bool HasVariables {
			get { return !variables.IsNullOrEmpty (); }
		}

		public Collection<VariableDefinition> Variables {
			get {
				if (variables == null)
					Interlocked.CompareExchange (ref variables, new VariableDefinitionCollection (this.method), null);

				return variables;
			}
		}

		public ParameterDefinition ThisParameter {
			get {
				if (method == null || method.DeclaringType == null)
					throw new NotSupportedException ();

				if (!method.HasThis)
					return null;

				if (this_parameter == null)
					Interlocked.CompareExchange (ref this_parameter, CreateThisParameter (method), null);

				return this_parameter;
			}
		}

		static ParameterDefinition CreateThisParameter (MethodDefinition method)
		{
			var parameter_type = method.DeclaringType as TypeReference;

			if (parameter_type.HasGenericParameters) {
				var instance = new GenericInstanceType (parameter_type, parameter_type.GenericParameters.Count);
				for (int i = 0; i < parameter_type.GenericParameters.Count; i++)
					instance.GenericArguments.Add (parameter_type.GenericParameters [i]);

				parameter_type = instance;

			}

			if (parameter_type.IsValueType || parameter_type.IsPrimitive)
				parameter_type = new ByReferenceType (parameter_type);

			return new ParameterDefinition (parameter_type, method);
		}

		public MethodBody (MethodDefinition method)
		{
			this.method = method;
		}

		public ILProcessor GetILProcessor ()
		{
			return new ILProcessor (this);
		}
	}

	sealed class VariableDefinitionCollection : Collection<VariableDefinition> {

		readonly MethodDefinition method;

		internal VariableDefinitionCollection (MethodDefinition method)
		{
			this.method = method;
		}

		internal VariableDefinitionCollection (MethodDefinition method, int capacity)
			: base (capacity)
		{
			this.method = method;
		}

		protected override void OnAdd (VariableDefinition item, int index)
		{
			item.index = index;
		}

		protected override void OnInsert (VariableDefinition item, int index)
		{
			item.index = index;
			UpdateVariableIndices (index, 1);
		}

		protected override void OnSet (VariableDefinition item, int index)
		{
			item.index = index;
		}

		protected override void OnRemove (VariableDefinition item, int index)
		{
			UpdateVariableIndices (index + 1, -1, item);
			item.index = -1;
		}

		void UpdateVariableIndices (int startIndex, int offset, VariableDefinition variableToRemove = null)
		{
			for (int i = startIndex; i < size; i++)
				items [i].index = i + offset;

			var debug_info = method == null ? null : method.debug_info;
			if (debug_info == null || debug_info.Scope == null)
				return;

			foreach (var scope in debug_info.GetScopes ()) {
				if (!scope.HasVariables)
					continue;

				var variables = scope.Variables;
				int variableDebugInfoIndexToRemove = -1;
				for (int i = 0; i < variables.Count; i++) {
					var variable = variables [i];

					// If a variable is being removed detect if it has debug info counterpart, if so remove that as well.
					// Note that the debug info can be either resolved (has direct reference to the VariableDefinition)
					// or unresolved (has only the number index of the variable) - this needs to handle both cases.
					if (variableToRemove != null &&
						((variable.index.IsResolved && variable.index.ResolvedVariable == variableToRemove) ||
							(!variable.index.IsResolved && variable.Index == variableToRemove.Index))) {
						variableDebugInfoIndexToRemove = i;
						continue;
					}

					// For unresolved debug info updates indeces to keep them pointing to the same variable.
					if (!variable.index.IsResolved && variable.Index >= startIndex) {
						variable.index = new VariableIndex (variable.Index + offset);
					}
				}

				if (variableDebugInfoIndexToRemove >= 0)
					variables.RemoveAt (variableDebugInfoIndexToRemove);
			}
		}
	}

	class InstructionCollection : Collection<Instruction> {

		readonly MethodDefinition method;

		internal InstructionCollection (MethodDefinition method)
		{
			this.method = method;
		}

		internal InstructionCollection (MethodDefinition method, int capacity)
			: base (capacity)
		{
			this.method = method;
		}

		protected override void OnAdd (Instruction item, int index)
		{
			if (index == 0)
				return;

			var previous = items [index - 1];
			previous.next = item;
			item.previous = previous;
		}

		protected override void OnInsert (Instruction item, int index)
		{
			int startOffset = 0;
			if (size != 0) {
				var current = items [index];
				if (current == null) {
					var last = items [index - 1];
					last.next = item;
					item.previous = last;
					return;
				}

				startOffset = current.Offset;

				var previous = current.previous;
				if (previous != null) {
					previous.next = item;
					item.previous = previous;
				}

				current.previous = item;
				item.next = current;
			}

			UpdateLocalScopes (null, null);
		}

		protected override void OnSet (Instruction item, int index)
		{
			var current = items [index];

			item.previous = current.previous;
			item.next = current.next;

			current.previous = null;
			current.next = null;

			UpdateLocalScopes (item, current);
		}

		protected override void OnRemove (Instruction item, int index)
		{
			var previous = item.previous;
			if (previous != null)
				previous.next = item.next;

			var next = item.next;
			if (next != null)
				next.previous = item.previous;

			RemoveSequencePoint (item);
			UpdateLocalScopes (item, next ?? previous);

			item.previous = null;
			item.next = null;
		}

		void RemoveSequencePoint (Instruction instruction)
		{
			var debug_info = method.debug_info;
			if (debug_info == null || !debug_info.HasSequencePoints)
				return;

			var sequence_points = debug_info.sequence_points;
			for (int i = 0; i < sequence_points.Count; i++) {
				if (sequence_points [i].Offset == instruction.offset) {
					sequence_points.RemoveAt (i);
					return;
				}
			}
		}

		void UpdateLocalScopes (Instruction removedInstruction, Instruction existingInstruction)
		{
			var debug_info = method.debug_info;
			if (debug_info == null)
				return;

			// Local scopes store start/end pair of "instruction offsets". Instruction offset can be either resolved, in which case it 
			// has a reference to Instruction, or unresolved in which case it stores numerical offset (instruction offset in the body).
			// Typically local scopes loaded from PE/PDB files will be resolved, but it's not a requirement.
			// Each instruction has its own offset, which is populated on load, but never updated (this would be pretty expensive to do).
			// Instructions created during the editting will typically have offset 0 (so incorrect).
			// Local scopes created during editing will also likely be resolved (so no numerical offsets).
			// So while local scopes which are unresolved are relatively rare if they appear, manipulating them based
			// on the offsets allone is pretty hard (since we can't rely on correct offsets of instructions).
			// On the other hand resolved local scopes are easy to maintain, since they point to instructions and thus inserting
			// instructions is basically a no-op and removing instructions is as easy as changing the pointer.
			// For this reason the algorithm here is:
			//  - First make sure that all instruction offsets are resolved - if not - resolve them
			//     - First time this will be relatively expensinve as it will walk the entire method body to convert offsets to instruction pointers
			//       Almost all local scopes are stored in the "right" order (sequentially per start offsets), so the code uses a simple one-item
			//       cache instruction<->offset to avoid walking instructions multiple times (that would only happen for scopes which are out of order).
			//     - Subsequent calls should be cheap as it will only walk all local scopes without doing anything
			//     - If there was an edit on local scope which makes some of them unresolved, the cost is proportional
			//  - Then update as necessary by manipulaitng instruction references alone

			InstructionOffsetCache cache = new InstructionOffsetCache () {
				Offset = 0,
				Index = 0,
				Instruction = items [0]
			};

			UpdateLocalScope (debug_info.Scope, removedInstruction, existingInstruction, ref cache);
		}

		void UpdateLocalScope (ScopeDebugInformation scope, Instruction removedInstruction, Instruction existingInstruction, ref InstructionOffsetCache cache)
		{
			if (scope == null)
				return;

			if (!scope.Start.IsResolved)
				scope.Start = ResolveInstructionOffset (scope.Start, ref cache);

			if (!scope.Start.IsEndOfMethod && scope.Start.ResolvedInstruction == removedInstruction)
				scope.Start = new InstructionOffset (existingInstruction);

			if (scope.HasScopes) {
				foreach (var subScope in scope.Scopes)
					UpdateLocalScope (subScope, removedInstruction, existingInstruction, ref cache);
			}

			if (!scope.End.IsResolved)
				scope.End = ResolveInstructionOffset (scope.End, ref cache);

			if (!scope.End.IsEndOfMethod && scope.End.ResolvedInstruction == removedInstruction)
				scope.End = new InstructionOffset (existingInstruction);
		}

		struct InstructionOffsetCache {
			public int Offset;
			public int Index;
			public Instruction Instruction;
		}

		InstructionOffset ResolveInstructionOffset (InstructionOffset inputOffset, ref InstructionOffsetCache cache)
		{
			if (inputOffset.IsResolved)
				return inputOffset;

			int offset = inputOffset.Offset;

			if (cache.Offset == offset)
				return new InstructionOffset (cache.Instruction);

			if (cache.Offset > offset) {
				// This should be rare - we're resolving offset pointing to a place before the current cache position
				// resolve by walking the instructions from start and don't cache the result.
				int size = 0;
				for (int i = 0; i < items.Length; i++) {
					if (size == offset)
						return new InstructionOffset (items [i]);

					if (size > offset)
						return new InstructionOffset (items [i - 1]);

					size += items [i].GetSize ();
				}

				// Offset is larger than the size of the body - so it points after the end
				return new InstructionOffset ();
			} else {
				// The offset points after the current cache position - so continue counting and update the cache
				int size = cache.Offset;
				for (int i = cache.Index; i < items.Length; i++) {
					cache.Index = i;
					cache.Offset = size;

					var item = items [i];

					// Allow for trailing null values in the case of
					// instructions.Size < instructions.Capacity
					if (item == null)
						break;

					cache.Instruction = item;

					if (cache.Offset == offset)
						return new InstructionOffset (cache.Instruction);

					if (cache.Offset > offset)
						return new InstructionOffset (items [i - 1]);

					size += item.GetSize ();
				}

				return new InstructionOffset ();
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/OpCode.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil.Cil {

	public enum FlowControl {
		Branch,
		Break,
		Call,
		Cond_Branch,
		Meta,
		Next,
		Phi,
		Return,
		Throw,
	}

	public enum OpCodeType {
		Annotation,
		Macro,
		Nternal,
		Objmodel,
		Prefix,
		Primitive,
	}

	public enum OperandType {
		InlineBrTarget,
		InlineField,
		InlineI,
		InlineI8,
		InlineMethod,
		InlineNone,
		InlinePhi,
		InlineR,
		InlineSig,
		InlineString,
		InlineSwitch,
		InlineTok,
		InlineType,
		InlineVar,
		InlineArg,
		ShortInlineBrTarget,
		ShortInlineI,
		ShortInlineR,
		ShortInlineVar,
		ShortInlineArg,
	}

	public enum StackBehaviour {
		Pop0,
		Pop1,
		Pop1_pop1,
		Popi,
		Popi_pop1,
		Popi_popi,
		Popi_popi8,
		Popi_popi_popi,
		Popi_popr4,
		Popi_popr8,
		Popref,
		Popref_pop1,
		Popref_popi,
		Popref_popi_popi,
		Popref_popi_popi8,
		Popref_popi_popr4,
		Popref_popi_popr8,
		Popref_popi_popref,
		PopAll,
		Push0,
		Push1,
		Push1_push1,
		Pushi,
		Pushi8,
		Pushr4,
		Pushr8,
		Pushref,
		Varpop,
		Varpush,
	}

	public struct OpCode : IEquatable<OpCode> {

		readonly byte op1;
		readonly byte op2;
		readonly byte code;
		readonly byte flow_control;
		readonly byte opcode_type;
		readonly byte operand_type;
		readonly byte stack_behavior_pop;
		readonly byte stack_behavior_push;

		public string Name {
			get { return OpCodeNames.names [(int)Code]; }
		}

		public int Size {
			get { return op1 == 0xff ? 1 : 2; }
		}

		public byte Op1 {
			get { return op1; }
		}

		public byte Op2 {
			get { return op2; }
		}

		public short Value {
			get { return op1 == 0xff ? op2 : (short)((op1 << 8) | op2); }
		}

		public Code Code {
			get { return (Code)code; }
		}

		public FlowControl FlowControl {
			get { return (FlowControl)flow_control; }
		}

		public OpCodeType OpCodeType {
			get { return (OpCodeType)opcode_type; }
		}

		public OperandType OperandType {
			get { return (OperandType)operand_type; }
		}

		public StackBehaviour StackBehaviourPop {
			get { return (StackBehaviour)stack_behavior_pop; }
		}

		public StackBehaviour StackBehaviourPush {
			get { return (StackBehaviour)stack_behavior_push; }
		}

		internal OpCode (int x, int y)
		{
			this.op1 = (byte)((x >> 0) & 0xff);
			this.op2 = (byte)((x >> 8) & 0xff);
			this.code = (byte)((x >> 16) & 0xff);
			this.flow_control = (byte)((x >> 24) & 0xff);

			this.opcode_type = (byte)((y >> 0) & 0xff);
			this.operand_type = (byte)((y >> 8) & 0xff);
			this.stack_behavior_pop = (byte)((y >> 16) & 0xff);
			this.stack_behavior_push = (byte)((y >> 24) & 0xff);

			if (op1 == 0xff)
				OpCodes.OneByteOpCode [op2] = this;
			else
				OpCodes.TwoBytesOpCode [op2] = this;
		}

		public override int GetHashCode ()
		{
			return Value;
		}

		public override bool Equals (object obj)
		{
			if (!(obj is OpCode))
				return false;

			var opcode = (OpCode)obj;
			return op1 == opcode.op1 && op2 == opcode.op2;
		}

		public bool Equals (OpCode opcode)
		{
			return op1 == opcode.op1 && op2 == opcode.op2;
		}

		public static bool operator == (OpCode one, OpCode other)
		{
			return one.op1 == other.op1 && one.op2 == other.op2;
		}

		public static bool operator != (OpCode one, OpCode other)
		{
			return one.op1 != other.op1 || one.op2 != other.op2;
		}

		public override string ToString ()
		{
			return Name;
		}
	}

	static class OpCodeNames {

		internal static readonly string [] names;

		static OpCodeNames ()
		{
			var table = new byte [] {
				3, 110, 111, 112,
				5, 98, 114, 101, 97, 107,
				7, 108, 100, 97, 114, 103, 46, 48,
				7, 108, 100, 97, 114, 103, 46, 49,
				7, 108, 100, 97, 114, 103, 46, 50,
				7, 108, 100, 97, 114, 103, 46, 51,
				7, 108, 100, 108, 111, 99, 46, 48,
				7, 108, 100, 108, 111, 99, 46, 49,
				7, 108, 100, 108, 111, 99, 46, 50,
				7, 108, 100, 108, 111, 99, 46, 51,
				7, 115, 116, 108, 111, 99, 46, 48,
				7, 115, 116, 108, 111, 99, 46, 49,
				7, 115, 116, 108, 111, 99, 46, 50,
				7, 115, 116, 108, 111, 99, 46, 51,
				7, 108, 100, 97, 114, 103, 46, 115,
				8, 108, 100, 97, 114, 103, 97, 46, 115,
				7, 115, 116, 97, 114, 103, 46, 115,
				7, 108, 100, 108, 111, 99, 46, 115,
				8, 108, 100, 108, 111, 99, 97, 46, 115,
				7, 115, 116, 108, 111, 99, 46, 115,
				6, 108, 100, 110, 117, 108, 108,
				9, 108, 100, 99, 46, 105, 52, 46, 109, 49,
				8, 108, 100, 99, 46, 105, 52, 46, 48,
				8, 108, 100, 99, 46, 105, 52, 46, 49,
				8, 108, 100, 99, 46, 105, 52, 46, 50,
				8, 108, 100, 99, 46, 105, 52, 46, 51,
				8, 108, 100, 99, 46, 105, 52, 46, 52,
				8, 108, 100, 99, 46, 105, 52, 46, 53,
				8, 108, 100, 99, 46, 105, 52, 46, 54,
				8, 108, 100, 99, 46, 105, 52, 46, 55,
				8, 108, 100, 99, 46, 105, 52, 46, 56,
				8, 108, 100, 99, 46, 105, 52, 46, 115,
				6, 108, 100, 99, 46, 105, 52,
				6, 108, 100, 99, 46, 105, 56,
				6, 108, 100, 99, 46, 114, 52,
				6, 108, 100, 99, 46, 114, 56,
				3, 100, 117, 112,
				3, 112, 111, 112,
				3, 106, 109, 112,
				4, 99, 97, 108, 108,
				5, 99, 97, 108, 108, 105,
				3, 114, 101, 116,
				4, 98, 114, 46, 115,
				9, 98, 114, 102, 97, 108, 115, 101, 46, 115,
				8, 98, 114, 116, 114, 117, 101, 46, 115,
				5, 98, 101, 113, 46, 115,
				5, 98, 103, 101, 46, 115,
				5, 98, 103, 116, 46, 115,
				5, 98, 108, 101, 46, 115,
				5, 98, 108, 116, 46, 115,
				8, 98, 110, 101, 46, 117, 110, 46, 115,
				8, 98, 103, 101, 46, 117, 110, 46, 115,
				8, 98, 103, 116, 46, 117, 110, 46, 115,
				8, 98, 108, 101, 46, 117, 110, 46, 115,
				8, 98, 108, 116, 46, 117, 110, 46, 115,
				2, 98, 114,
				7, 98, 114, 102, 97, 108, 115, 101,
				6, 98, 114, 116, 114, 117, 101,
				3, 98, 101, 113,
				3, 98, 103, 101,
				3, 98, 103, 116,
				3, 98, 108, 101,
				3, 98, 108, 116,
				6, 98, 110, 101, 46, 117, 110,
				6, 98, 103, 101, 46, 117, 110,
				6, 98, 103, 116, 46, 117, 110,
				6, 98, 108, 101, 46, 117, 110,
				6, 98, 108, 116, 46, 117, 110,
				6, 115, 119, 105, 116, 99, 104,
				8, 108, 100, 105, 110, 100, 46, 105, 49,
				8, 108, 100, 105, 110, 100, 46, 117, 49,
				8, 108, 100, 105, 110, 100, 46, 105, 50,
				8, 108, 100, 105, 110, 100, 46, 117, 50,
				8, 108, 100, 105, 110, 100, 46, 105, 52,
				8, 108, 100, 105, 110, 100, 46, 117, 52,
				8, 108, 100, 105, 110, 100, 46, 105, 56,
				7, 108, 100, 105, 110, 100, 46, 105,
				8, 108, 100, 105, 110, 100, 46, 114, 52,
				8, 108, 100, 105, 110, 100, 46, 114, 56,
				9, 108, 100, 105, 110, 100, 46, 114, 101, 102,
				9, 115, 116, 105, 110, 100, 46, 114, 101, 102,
				8, 115, 116, 105, 110, 100, 46, 105, 49,
				8, 115, 116, 105, 110, 100, 46, 105, 50,
				8, 115, 116, 105, 110, 100, 46, 105, 52,
				8, 115, 116, 105, 110, 100, 46, 105, 56,
				8, 115, 116, 105, 110, 100, 46, 114, 52,
				8, 115, 116, 105, 110, 100, 46, 114, 56,
				3, 97, 100, 100,
				3, 115, 117, 98,
				3, 109, 117, 108,
				3, 100, 105, 118,
				6, 100, 105, 118, 46, 117, 110,
				3, 114, 101, 109,
				6, 114, 101, 109, 46, 117, 110,
				3, 97, 110, 100,
				2, 111, 114,
				3, 120, 111, 114,
				3, 115, 104, 108,
				3, 115, 104, 114,
				6, 115, 104, 114, 46, 117, 110,
				3, 110, 101, 103,
				3, 110, 111, 116,
				7, 99, 111, 110, 118, 46, 105, 49,
				7, 99, 111, 110, 118, 46, 105, 50,
				7, 99, 111, 110, 118, 46, 105, 52,
				7, 99, 111, 110, 118, 46, 105, 56,
				7, 99, 111, 110, 118, 46, 114, 52,
				7, 99, 111, 110, 118, 46, 114, 56,
				7, 99, 111, 110, 118, 46, 117, 52,
				7, 99, 111, 110, 118, 46, 117, 56,
				8, 99, 97, 108, 108, 118, 105, 114, 116,
				5, 99, 112, 111, 98, 106,
				5, 108, 100, 111, 98, 106,
				5, 108, 100, 115, 116, 114,
				6, 110, 101, 119, 111, 98, 106,
				9, 99, 97, 115, 116, 99, 108, 97, 115, 115,
				6, 105, 115, 105, 110, 115, 116,
				9, 99, 111, 110, 118, 46, 114, 46, 117, 110,
				5, 117, 110, 98, 111, 120,
				5, 116, 104, 114, 111, 119,
				5, 108, 100, 102, 108, 100,
				6, 108, 100, 102, 108, 100, 97,
				5, 115, 116, 102, 108, 100,
				6, 108, 100, 115, 102, 108, 100,
				7, 108, 100, 115, 102, 108, 100, 97,
				6, 115, 116, 115, 102, 108, 100,
				5, 115, 116, 111, 98, 106,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 49, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 50, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 52, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 56, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 49, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 50, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 52, 46, 117, 110,
				14, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 56, 46, 117, 110,
				13, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 46, 117, 110,
				13, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 46, 117, 110,
				3, 98, 111, 120,
				6, 110, 101, 119, 97, 114, 114,
				5, 108, 100, 108, 101, 110,
				7, 108, 100, 101, 108, 101, 109, 97,
				9, 108, 100, 101, 108, 101, 109, 46, 105, 49,
				9, 108, 100, 101, 108, 101, 109, 46, 117, 49,
				9, 108, 100, 101, 108, 101, 109, 46, 105, 50,
				9, 108, 100, 101, 108, 101, 109, 46, 117, 50,
				9, 108, 100, 101, 108, 101, 109, 46, 105, 52,
				9, 108, 100, 101, 108, 101, 109, 46, 117, 52,
				9, 108, 100, 101, 108, 101, 109, 46, 105, 56,
				8, 108, 100, 101, 108, 101, 109, 46, 105,
				9, 108, 100, 101, 108, 101, 109, 46, 114, 52,
				9, 108, 100, 101, 108, 101, 109, 46, 114, 56,
				10, 108, 100, 101, 108, 101, 109, 46, 114, 101, 102,
				8, 115, 116, 101, 108, 101, 109, 46, 105,
				9, 115, 116, 101, 108, 101, 109, 46, 105, 49,
				9, 115, 116, 101, 108, 101, 109, 46, 105, 50,
				9, 115, 116, 101, 108, 101, 109, 46, 105, 52,
				9, 115, 116, 101, 108, 101, 109, 46, 105, 56,
				9, 115, 116, 101, 108, 101, 109, 46, 114, 52,
				9, 115, 116, 101, 108, 101, 109, 46, 114, 56,
				10, 115, 116, 101, 108, 101, 109, 46, 114, 101, 102,
				10, 108, 100, 101, 108, 101, 109, 46, 97, 110, 121,
				10, 115, 116, 101, 108, 101, 109, 46, 97, 110, 121,
				9, 117, 110, 98, 111, 120, 46, 97, 110, 121,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 49,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 49,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 50,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 50,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 52,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 52,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105, 56,
				11, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117, 56,
				9, 114, 101, 102, 97, 110, 121, 118, 97, 108,
				8, 99, 107, 102, 105, 110, 105, 116, 101,
				8, 109, 107, 114, 101, 102, 97, 110, 121,
				7, 108, 100, 116, 111, 107, 101, 110,
				7, 99, 111, 110, 118, 46, 117, 50,
				7, 99, 111, 110, 118, 46, 117, 49,
				6, 99, 111, 110, 118, 46, 105,
				10, 99, 111, 110, 118, 46, 111, 118, 102, 46, 105,
				10, 99, 111, 110, 118, 46, 111, 118, 102, 46, 117,
				7, 97, 100, 100, 46, 111, 118, 102,
				10, 97, 100, 100, 46, 111, 118, 102, 46, 117, 110,
				7, 109, 117, 108, 46, 111, 118, 102,
				10, 109, 117, 108, 46, 111, 118, 102, 46, 117, 110,
				7, 115, 117, 98, 46, 111, 118, 102,
				10, 115, 117, 98, 46, 111, 118, 102, 46, 117, 110,
				10, 101, 110, 100, 102, 105, 110, 97, 108, 108, 121,
				5, 108, 101, 97, 118, 101,
				7, 108, 101, 97, 118, 101, 46, 115,
				7, 115, 116, 105, 110, 100, 46, 105,
				6, 99, 111, 110, 118, 46, 117,
				7, 97, 114, 103, 108, 105, 115, 116,
				3, 99, 101, 113,
				3, 99, 103, 116,
				6, 99, 103, 116, 46, 117, 110,
				3, 99, 108, 116,
				6, 99, 108, 116, 46, 117, 110,
				5, 108, 100, 102, 116, 110,
				9, 108, 100, 118, 105, 114, 116, 102, 116, 110,
				5, 108, 100, 97, 114, 103,
				6, 108, 100, 97, 114, 103, 97,
				5, 115, 116, 97, 114, 103,
				5, 108, 100, 108, 111, 99,
				6, 108, 100, 108, 111, 99, 97,
				5, 115, 116, 108, 111, 99,
				8, 108, 111, 99, 97, 108, 108, 111, 99,
				9, 101, 110, 100, 102, 105, 108, 116, 101, 114,
				10, 117, 110, 97, 108, 105, 103, 110, 101, 100, 46,
				9, 118, 111, 108, 97, 116, 105, 108, 101, 46,
				5, 116, 97, 105, 108, 46,
				7, 105, 110, 105, 116, 111, 98, 106,
				12, 99, 111, 110, 115, 116, 114, 97, 105, 110, 101, 100, 46,
				5, 99, 112, 98, 108, 107,
				7, 105, 110, 105, 116, 98, 108, 107,
				3, 110, 111, 46,
				7, 114, 101, 116, 104, 114, 111, 119,
				6, 115, 105, 122, 101, 111, 102,
				10, 114, 101, 102, 97, 110, 121, 116, 121, 112, 101,
				9, 114, 101, 97, 100, 111, 110, 108, 121, 46,
			};

			names = new string [219];

			for (int i = 0, p = 0; i < names.Length; i++) {
				var buffer = new char [table [p++]];

				for (int j = 0; j < buffer.Length; j++)
					buffer [j] = (char)table [p++];

				names [i] = new string (buffer);
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/OpCodes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Cil {

	public static class OpCodes {

		internal static readonly OpCode [] OneByteOpCode = new OpCode [0xe0 + 1];
		internal static readonly OpCode [] TwoBytesOpCode = new OpCode [0x1e + 1];

		public static readonly OpCode Nop = new OpCode (
			0xff << 0 | 0x00 << 8 | (byte)Code.Nop << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Break = new OpCode (
			0xff << 0 | 0x01 << 8 | (byte)Code.Break << 16 | (byte)FlowControl.Break << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldarg_0 = new OpCode (
			0xff << 0 | 0x02 << 8 | (byte)Code.Ldarg_0 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarg_1 = new OpCode (
			0xff << 0 | 0x03 << 8 | (byte)Code.Ldarg_1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarg_2 = new OpCode (
			0xff << 0 | 0x04 << 8 | (byte)Code.Ldarg_2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarg_3 = new OpCode (
			0xff << 0 | 0x05 << 8 | (byte)Code.Ldarg_3 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloc_0 = new OpCode (
			0xff << 0 | 0x06 << 8 | (byte)Code.Ldloc_0 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloc_1 = new OpCode (
			0xff << 0 | 0x07 << 8 | (byte)Code.Ldloc_1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloc_2 = new OpCode (
			0xff << 0 | 0x08 << 8 | (byte)Code.Ldloc_2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloc_3 = new OpCode (
			0xff << 0 | 0x09 << 8 | (byte)Code.Ldloc_3 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Stloc_0 = new OpCode (
			0xff << 0 | 0x0a << 8 | (byte)Code.Stloc_0 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stloc_1 = new OpCode (
			0xff << 0 | 0x0b << 8 | (byte)Code.Stloc_1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stloc_2 = new OpCode (
			0xff << 0 | 0x0c << 8 | (byte)Code.Stloc_2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stloc_3 = new OpCode (
			0xff << 0 | 0x0d << 8 | (byte)Code.Stloc_3 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldarg_S = new OpCode (
			0xff << 0 | 0x0e << 8 | (byte)Code.Ldarg_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineArg << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarga_S = new OpCode (
			0xff << 0 | 0x0f << 8 | (byte)Code.Ldarga_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineArg << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Starg_S = new OpCode (
			0xff << 0 | 0x10 << 8 | (byte)Code.Starg_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineArg << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldloc_S = new OpCode (
			0xff << 0 | 0x11 << 8 | (byte)Code.Ldloc_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineVar << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloca_S = new OpCode (
			0xff << 0 | 0x12 << 8 | (byte)Code.Ldloca_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineVar << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Stloc_S = new OpCode (
			0xff << 0 | 0x13 << 8 | (byte)Code.Stloc_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineVar << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldnull = new OpCode (
			0xff << 0 | 0x14 << 8 | (byte)Code.Ldnull << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Ldc_I4_M1 = new OpCode (
			0xff << 0 | 0x15 << 8 | (byte)Code.Ldc_I4_M1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_0 = new OpCode (
			0xff << 0 | 0x16 << 8 | (byte)Code.Ldc_I4_0 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_1 = new OpCode (
			0xff << 0 | 0x17 << 8 | (byte)Code.Ldc_I4_1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_2 = new OpCode (
			0xff << 0 | 0x18 << 8 | (byte)Code.Ldc_I4_2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_3 = new OpCode (
			0xff << 0 | 0x19 << 8 | (byte)Code.Ldc_I4_3 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_4 = new OpCode (
			0xff << 0 | 0x1a << 8 | (byte)Code.Ldc_I4_4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_5 = new OpCode (
			0xff << 0 | 0x1b << 8 | (byte)Code.Ldc_I4_5 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_6 = new OpCode (
			0xff << 0 | 0x1c << 8 | (byte)Code.Ldc_I4_6 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_7 = new OpCode (
			0xff << 0 | 0x1d << 8 | (byte)Code.Ldc_I4_7 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_8 = new OpCode (
			0xff << 0 | 0x1e << 8 | (byte)Code.Ldc_I4_8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4_S = new OpCode (
			0xff << 0 | 0x1f << 8 | (byte)Code.Ldc_I4_S << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineI << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I4 = new OpCode (
			0xff << 0 | 0x20 << 8 | (byte)Code.Ldc_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineI << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldc_I8 = new OpCode (
			0xff << 0 | 0x21 << 8 | (byte)Code.Ldc_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineI8 << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Ldc_R4 = new OpCode (
			0xff << 0 | 0x22 << 8 | (byte)Code.Ldc_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.ShortInlineR << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushr4 << 24);

		public static readonly OpCode Ldc_R8 = new OpCode (
			0xff << 0 | 0x23 << 8 | (byte)Code.Ldc_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineR << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Dup = new OpCode (
			0xff << 0 | 0x25 << 8 | (byte)Code.Dup << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push1_push1 << 24);

		public static readonly OpCode Pop = new OpCode (
			0xff << 0 | 0x26 << 8 | (byte)Code.Pop << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Jmp = new OpCode (
			0xff << 0 | 0x27 << 8 | (byte)Code.Jmp << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Call = new OpCode (
			0xff << 0 | 0x28 << 8 | (byte)Code.Call << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Varpush << 24);

		public static readonly OpCode Calli = new OpCode (
			0xff << 0 | 0x29 << 8 | (byte)Code.Calli << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineSig << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Varpush << 24);

		public static readonly OpCode Ret = new OpCode (
			0xff << 0 | 0x2a << 8 | (byte)Code.Ret << 16 | (byte)FlowControl.Return << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Br_S = new OpCode (
			0xff << 0 | 0x2b << 8 | (byte)Code.Br_S << 16 | (byte)FlowControl.Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Brfalse_S = new OpCode (
			0xff << 0 | 0x2c << 8 | (byte)Code.Brfalse_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Brtrue_S = new OpCode (
			0xff << 0 | 0x2d << 8 | (byte)Code.Brtrue_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Beq_S = new OpCode (
			0xff << 0 | 0x2e << 8 | (byte)Code.Beq_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bge_S = new OpCode (
			0xff << 0 | 0x2f << 8 | (byte)Code.Bge_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bgt_S = new OpCode (
			0xff << 0 | 0x30 << 8 | (byte)Code.Bgt_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ble_S = new OpCode (
			0xff << 0 | 0x31 << 8 | (byte)Code.Ble_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Blt_S = new OpCode (
			0xff << 0 | 0x32 << 8 | (byte)Code.Blt_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bne_Un_S = new OpCode (
			0xff << 0 | 0x33 << 8 | (byte)Code.Bne_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bge_Un_S = new OpCode (
			0xff << 0 | 0x34 << 8 | (byte)Code.Bge_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bgt_Un_S = new OpCode (
			0xff << 0 | 0x35 << 8 | (byte)Code.Bgt_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ble_Un_S = new OpCode (
			0xff << 0 | 0x36 << 8 | (byte)Code.Ble_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Blt_Un_S = new OpCode (
			0xff << 0 | 0x37 << 8 | (byte)Code.Blt_Un_S << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Br = new OpCode (
			0xff << 0 | 0x38 << 8 | (byte)Code.Br << 16 | (byte)FlowControl.Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Brfalse = new OpCode (
			0xff << 0 | 0x39 << 8 | (byte)Code.Brfalse << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Brtrue = new OpCode (
			0xff << 0 | 0x3a << 8 | (byte)Code.Brtrue << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Beq = new OpCode (
			0xff << 0 | 0x3b << 8 | (byte)Code.Beq << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bge = new OpCode (
			0xff << 0 | 0x3c << 8 | (byte)Code.Bge << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bgt = new OpCode (
			0xff << 0 | 0x3d << 8 | (byte)Code.Bgt << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ble = new OpCode (
			0xff << 0 | 0x3e << 8 | (byte)Code.Ble << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Blt = new OpCode (
			0xff << 0 | 0x3f << 8 | (byte)Code.Blt << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bne_Un = new OpCode (
			0xff << 0 | 0x40 << 8 | (byte)Code.Bne_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bge_Un = new OpCode (
			0xff << 0 | 0x41 << 8 | (byte)Code.Bge_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Bgt_Un = new OpCode (
			0xff << 0 | 0x42 << 8 | (byte)Code.Bgt_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ble_Un = new OpCode (
			0xff << 0 | 0x43 << 8 | (byte)Code.Ble_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Blt_Un = new OpCode (
			0xff << 0 | 0x44 << 8 | (byte)Code.Blt_Un << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Switch = new OpCode (
			0xff << 0 | 0x45 << 8 | (byte)Code.Switch << 16 | (byte)FlowControl.Cond_Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineSwitch << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldind_I1 = new OpCode (
			0xff << 0 | 0x46 << 8 | (byte)Code.Ldind_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_U1 = new OpCode (
			0xff << 0 | 0x47 << 8 | (byte)Code.Ldind_U1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_I2 = new OpCode (
			0xff << 0 | 0x48 << 8 | (byte)Code.Ldind_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_U2 = new OpCode (
			0xff << 0 | 0x49 << 8 | (byte)Code.Ldind_U2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_I4 = new OpCode (
			0xff << 0 | 0x4a << 8 | (byte)Code.Ldind_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_U4 = new OpCode (
			0xff << 0 | 0x4b << 8 | (byte)Code.Ldind_U4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_I8 = new OpCode (
			0xff << 0 | 0x4c << 8 | (byte)Code.Ldind_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Ldind_I = new OpCode (
			0xff << 0 | 0x4d << 8 | (byte)Code.Ldind_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldind_R4 = new OpCode (
			0xff << 0 | 0x4e << 8 | (byte)Code.Ldind_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushr4 << 24);

		public static readonly OpCode Ldind_R8 = new OpCode (
			0xff << 0 | 0x4f << 8 | (byte)Code.Ldind_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Ldind_Ref = new OpCode (
			0xff << 0 | 0x50 << 8 | (byte)Code.Ldind_Ref << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Stind_Ref = new OpCode (
			0xff << 0 | 0x51 << 8 | (byte)Code.Stind_Ref << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I1 = new OpCode (
			0xff << 0 | 0x52 << 8 | (byte)Code.Stind_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I2 = new OpCode (
			0xff << 0 | 0x53 << 8 | (byte)Code.Stind_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I4 = new OpCode (
			0xff << 0 | 0x54 << 8 | (byte)Code.Stind_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I8 = new OpCode (
			0xff << 0 | 0x55 << 8 | (byte)Code.Stind_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi8 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_R4 = new OpCode (
			0xff << 0 | 0x56 << 8 | (byte)Code.Stind_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popr4 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_R8 = new OpCode (
			0xff << 0 | 0x57 << 8 | (byte)Code.Stind_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popr8 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Add = new OpCode (
			0xff << 0 | 0x58 << 8 | (byte)Code.Add << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Sub = new OpCode (
			0xff << 0 | 0x59 << 8 | (byte)Code.Sub << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Mul = new OpCode (
			0xff << 0 | 0x5a << 8 | (byte)Code.Mul << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Div = new OpCode (
			0xff << 0 | 0x5b << 8 | (byte)Code.Div << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Div_Un = new OpCode (
			0xff << 0 | 0x5c << 8 | (byte)Code.Div_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Rem = new OpCode (
			0xff << 0 | 0x5d << 8 | (byte)Code.Rem << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Rem_Un = new OpCode (
			0xff << 0 | 0x5e << 8 | (byte)Code.Rem_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode And = new OpCode (
			0xff << 0 | 0x5f << 8 | (byte)Code.And << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Or = new OpCode (
			0xff << 0 | 0x60 << 8 | (byte)Code.Or << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Xor = new OpCode (
			0xff << 0 | 0x61 << 8 | (byte)Code.Xor << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Shl = new OpCode (
			0xff << 0 | 0x62 << 8 | (byte)Code.Shl << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Shr = new OpCode (
			0xff << 0 | 0x63 << 8 | (byte)Code.Shr << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Shr_Un = new OpCode (
			0xff << 0 | 0x64 << 8 | (byte)Code.Shr_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Neg = new OpCode (
			0xff << 0 | 0x65 << 8 | (byte)Code.Neg << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Not = new OpCode (
			0xff << 0 | 0x66 << 8 | (byte)Code.Not << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Conv_I1 = new OpCode (
			0xff << 0 | 0x67 << 8 | (byte)Code.Conv_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_I2 = new OpCode (
			0xff << 0 | 0x68 << 8 | (byte)Code.Conv_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_I4 = new OpCode (
			0xff << 0 | 0x69 << 8 | (byte)Code.Conv_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_I8 = new OpCode (
			0xff << 0 | 0x6a << 8 | (byte)Code.Conv_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Conv_R4 = new OpCode (
			0xff << 0 | 0x6b << 8 | (byte)Code.Conv_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushr4 << 24);

		public static readonly OpCode Conv_R8 = new OpCode (
			0xff << 0 | 0x6c << 8 | (byte)Code.Conv_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Conv_U4 = new OpCode (
			0xff << 0 | 0x6d << 8 | (byte)Code.Conv_U4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_U8 = new OpCode (
			0xff << 0 | 0x6e << 8 | (byte)Code.Conv_U8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Callvirt = new OpCode (
			0xff << 0 | 0x6f << 8 | (byte)Code.Callvirt << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Varpush << 24);

		public static readonly OpCode Cpobj = new OpCode (
			0xff << 0 | 0x70 << 8 | (byte)Code.Cpobj << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldobj = new OpCode (
			0xff << 0 | 0x71 << 8 | (byte)Code.Ldobj << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldstr = new OpCode (
			0xff << 0 | 0x72 << 8 | (byte)Code.Ldstr << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineString << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Newobj = new OpCode (
			0xff << 0 | 0x73 << 8 | (byte)Code.Newobj << 16 | (byte)FlowControl.Call << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Varpop << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Castclass = new OpCode (
			0xff << 0 | 0x74 << 8 | (byte)Code.Castclass << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Isinst = new OpCode (
			0xff << 0 | 0x75 << 8 | (byte)Code.Isinst << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_R_Un = new OpCode (
			0xff << 0 | 0x76 << 8 | (byte)Code.Conv_R_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Unbox = new OpCode (
			0xff << 0 | 0x79 << 8 | (byte)Code.Unbox << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Throw = new OpCode (
			0xff << 0 | 0x7a << 8 | (byte)Code.Throw << 16 | (byte)FlowControl.Throw << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldfld = new OpCode (
			0xff << 0 | 0x7b << 8 | (byte)Code.Ldfld << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldflda = new OpCode (
			0xff << 0 | 0x7c << 8 | (byte)Code.Ldflda << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Stfld = new OpCode (
			0xff << 0 | 0x7d << 8 | (byte)Code.Stfld << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Popref_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldsfld = new OpCode (
			0xff << 0 | 0x7e << 8 | (byte)Code.Ldsfld << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldsflda = new OpCode (
			0xff << 0 | 0x7f << 8 | (byte)Code.Ldsflda << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Stsfld = new OpCode (
			0xff << 0 | 0x80 << 8 | (byte)Code.Stsfld << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineField << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stobj = new OpCode (
			0xff << 0 | 0x81 << 8 | (byte)Code.Stobj << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi_pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Conv_Ovf_I1_Un = new OpCode (
			0xff << 0 | 0x82 << 8 | (byte)Code.Conv_Ovf_I1_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I2_Un = new OpCode (
			0xff << 0 | 0x83 << 8 | (byte)Code.Conv_Ovf_I2_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I4_Un = new OpCode (
			0xff << 0 | 0x84 << 8 | (byte)Code.Conv_Ovf_I4_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I8_Un = new OpCode (
			0xff << 0 | 0x85 << 8 | (byte)Code.Conv_Ovf_I8_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Conv_Ovf_U1_Un = new OpCode (
			0xff << 0 | 0x86 << 8 | (byte)Code.Conv_Ovf_U1_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U2_Un = new OpCode (
			0xff << 0 | 0x87 << 8 | (byte)Code.Conv_Ovf_U2_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U4_Un = new OpCode (
			0xff << 0 | 0x88 << 8 | (byte)Code.Conv_Ovf_U4_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U8_Un = new OpCode (
			0xff << 0 | 0x89 << 8 | (byte)Code.Conv_Ovf_U8_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Conv_Ovf_I_Un = new OpCode (
			0xff << 0 | 0x8a << 8 | (byte)Code.Conv_Ovf_I_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U_Un = new OpCode (
			0xff << 0 | 0x8b << 8 | (byte)Code.Conv_Ovf_U_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Box = new OpCode (
			0xff << 0 | 0x8c << 8 | (byte)Code.Box << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Newarr = new OpCode (
			0xff << 0 | 0x8d << 8 | (byte)Code.Newarr << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Ldlen = new OpCode (
			0xff << 0 | 0x8e << 8 | (byte)Code.Ldlen << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelema = new OpCode (
			0xff << 0 | 0x8f << 8 | (byte)Code.Ldelema << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_I1 = new OpCode (
			0xff << 0 | 0x90 << 8 | (byte)Code.Ldelem_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_U1 = new OpCode (
			0xff << 0 | 0x91 << 8 | (byte)Code.Ldelem_U1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_I2 = new OpCode (
			0xff << 0 | 0x92 << 8 | (byte)Code.Ldelem_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_U2 = new OpCode (
			0xff << 0 | 0x93 << 8 | (byte)Code.Ldelem_U2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_I4 = new OpCode (
			0xff << 0 | 0x94 << 8 | (byte)Code.Ldelem_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_U4 = new OpCode (
			0xff << 0 | 0x95 << 8 | (byte)Code.Ldelem_U4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_I8 = new OpCode (
			0xff << 0 | 0x96 << 8 | (byte)Code.Ldelem_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Ldelem_I = new OpCode (
			0xff << 0 | 0x97 << 8 | (byte)Code.Ldelem_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldelem_R4 = new OpCode (
			0xff << 0 | 0x98 << 8 | (byte)Code.Ldelem_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushr4 << 24);

		public static readonly OpCode Ldelem_R8 = new OpCode (
			0xff << 0 | 0x99 << 8 | (byte)Code.Ldelem_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Ldelem_Ref = new OpCode (
			0xff << 0 | 0x9a << 8 | (byte)Code.Ldelem_Ref << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Pushref << 24);

		public static readonly OpCode Stelem_I = new OpCode (
			0xff << 0 | 0x9b << 8 | (byte)Code.Stelem_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_I1 = new OpCode (
			0xff << 0 | 0x9c << 8 | (byte)Code.Stelem_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_I2 = new OpCode (
			0xff << 0 | 0x9d << 8 | (byte)Code.Stelem_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_I4 = new OpCode (
			0xff << 0 | 0x9e << 8 | (byte)Code.Stelem_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_I8 = new OpCode (
			0xff << 0 | 0x9f << 8 | (byte)Code.Stelem_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popi8 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_R4 = new OpCode (
			0xff << 0 | 0xa0 << 8 | (byte)Code.Stelem_R4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popr4 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_R8 = new OpCode (
			0xff << 0 | 0xa1 << 8 | (byte)Code.Stelem_R8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popr8 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stelem_Ref = new OpCode (
			0xff << 0 | 0xa2 << 8 | (byte)Code.Stelem_Ref << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popref_popi_popref << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldelem_Any = new OpCode (
			0xff << 0 | 0xa3 << 8 | (byte)Code.Ldelem_Any << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref_popi << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Stelem_Any = new OpCode (
			0xff << 0 | 0xa4 << 8 | (byte)Code.Stelem_Any << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref_popi_popref << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Unbox_Any = new OpCode (
			0xff << 0 | 0xa5 << 8 | (byte)Code.Unbox_Any << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Conv_Ovf_I1 = new OpCode (
			0xff << 0 | 0xb3 << 8 | (byte)Code.Conv_Ovf_I1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U1 = new OpCode (
			0xff << 0 | 0xb4 << 8 | (byte)Code.Conv_Ovf_U1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I2 = new OpCode (
			0xff << 0 | 0xb5 << 8 | (byte)Code.Conv_Ovf_I2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U2 = new OpCode (
			0xff << 0 | 0xb6 << 8 | (byte)Code.Conv_Ovf_U2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I4 = new OpCode (
			0xff << 0 | 0xb7 << 8 | (byte)Code.Conv_Ovf_I4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U4 = new OpCode (
			0xff << 0 | 0xb8 << 8 | (byte)Code.Conv_Ovf_U4 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I8 = new OpCode (
			0xff << 0 | 0xb9 << 8 | (byte)Code.Conv_Ovf_I8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Conv_Ovf_U8 = new OpCode (
			0xff << 0 | 0xba << 8 | (byte)Code.Conv_Ovf_U8 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi8 << 24);

		public static readonly OpCode Refanyval = new OpCode (
			0xff << 0 | 0xc2 << 8 | (byte)Code.Refanyval << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ckfinite = new OpCode (
			0xff << 0 | 0xc3 << 8 | (byte)Code.Ckfinite << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushr8 << 24);

		public static readonly OpCode Mkrefany = new OpCode (
			0xff << 0 | 0xc6 << 8 | (byte)Code.Mkrefany << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldtoken = new OpCode (
			0xff << 0 | 0xd0 << 8 | (byte)Code.Ldtoken << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineTok << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_U2 = new OpCode (
			0xff << 0 | 0xd1 << 8 | (byte)Code.Conv_U2 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_U1 = new OpCode (
			0xff << 0 | 0xd2 << 8 | (byte)Code.Conv_U1 << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_I = new OpCode (
			0xff << 0 | 0xd3 << 8 | (byte)Code.Conv_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_I = new OpCode (
			0xff << 0 | 0xd4 << 8 | (byte)Code.Conv_Ovf_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Conv_Ovf_U = new OpCode (
			0xff << 0 | 0xd5 << 8 | (byte)Code.Conv_Ovf_U << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Add_Ovf = new OpCode (
			0xff << 0 | 0xd6 << 8 | (byte)Code.Add_Ovf << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Add_Ovf_Un = new OpCode (
			0xff << 0 | 0xd7 << 8 | (byte)Code.Add_Ovf_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Mul_Ovf = new OpCode (
			0xff << 0 | 0xd8 << 8 | (byte)Code.Mul_Ovf << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Mul_Ovf_Un = new OpCode (
			0xff << 0 | 0xd9 << 8 | (byte)Code.Mul_Ovf_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Sub_Ovf = new OpCode (
			0xff << 0 | 0xda << 8 | (byte)Code.Sub_Ovf << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Sub_Ovf_Un = new OpCode (
			0xff << 0 | 0xdb << 8 | (byte)Code.Sub_Ovf_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Endfinally = new OpCode (
			0xff << 0 | 0xdc << 8 | (byte)Code.Endfinally << 16 | (byte)FlowControl.Return << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Leave = new OpCode (
			0xff << 0 | 0xdd << 8 | (byte)Code.Leave << 16 | (byte)FlowControl.Branch << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineBrTarget << 8 | (byte)StackBehaviour.PopAll << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Leave_S = new OpCode (
			0xff << 0 | 0xde << 8 | (byte)Code.Leave_S << 16 | (byte)FlowControl.Branch << 24,
			(byte)OpCodeType.Macro << 0 | (byte)OperandType.ShortInlineBrTarget << 8 | (byte)StackBehaviour.PopAll << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Stind_I = new OpCode (
			0xff << 0 | 0xdf << 8 | (byte)Code.Stind_I << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Conv_U = new OpCode (
			0xff << 0 | 0xe0 << 8 | (byte)Code.Conv_U << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Arglist = new OpCode (
			0xfe << 0 | 0x00 << 8 | (byte)Code.Arglist << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ceq = new OpCode (
			0xfe << 0 | 0x01 << 8 | (byte)Code.Ceq << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Cgt = new OpCode (
			0xfe << 0 | 0x02 << 8 | (byte)Code.Cgt << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Cgt_Un = new OpCode (
			0xfe << 0 | 0x03 << 8 | (byte)Code.Cgt_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Clt = new OpCode (
			0xfe << 0 | 0x04 << 8 | (byte)Code.Clt << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Clt_Un = new OpCode (
			0xfe << 0 | 0x05 << 8 | (byte)Code.Clt_Un << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1_pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldftn = new OpCode (
			0xfe << 0 | 0x06 << 8 | (byte)Code.Ldftn << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldvirtftn = new OpCode (
			0xfe << 0 | 0x07 << 8 | (byte)Code.Ldvirtftn << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineMethod << 8 | (byte)StackBehaviour.Popref << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Ldarg = new OpCode (
			0xfe << 0 | 0x09 << 8 | (byte)Code.Ldarg << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineArg << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldarga = new OpCode (
			0xfe << 0 | 0x0a << 8 | (byte)Code.Ldarga << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineArg << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Starg = new OpCode (
			0xfe << 0 | 0x0b << 8 | (byte)Code.Starg << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineArg << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Ldloc = new OpCode (
			0xfe << 0 | 0x0c << 8 | (byte)Code.Ldloc << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineVar << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push1 << 24);

		public static readonly OpCode Ldloca = new OpCode (
			0xfe << 0 | 0x0d << 8 | (byte)Code.Ldloca << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineVar << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Stloc = new OpCode (
			0xfe << 0 | 0x0e << 8 | (byte)Code.Stloc << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineVar << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Localloc = new OpCode (
			0xfe << 0 | 0x0f << 8 | (byte)Code.Localloc << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Endfilter = new OpCode (
			0xfe << 0 | 0x11 << 8 | (byte)Code.Endfilter << 16 | (byte)FlowControl.Return << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Unaligned = new OpCode (
			0xfe << 0 | 0x12 << 8 | (byte)Code.Unaligned << 16 | (byte)FlowControl.Meta << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.ShortInlineI << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Volatile = new OpCode (
			0xfe << 0 | 0x13 << 8 | (byte)Code.Volatile << 16 | (byte)FlowControl.Meta << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Tail = new OpCode (
			0xfe << 0 | 0x14 << 8 | (byte)Code.Tail << 16 | (byte)FlowControl.Meta << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Initobj = new OpCode (
			0xfe << 0 | 0x15 << 8 | (byte)Code.Initobj << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Constrained = new OpCode (
			0xfe << 0 | 0x16 << 8 | (byte)Code.Constrained << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Cpblk = new OpCode (
			0xfe << 0 | 0x17 << 8 | (byte)Code.Cpblk << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Initblk = new OpCode (
			0xfe << 0 | 0x18 << 8 | (byte)Code.Initblk << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Popi_popi_popi << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode No = new OpCode (
			0xfe << 0 | 0x19 << 8 | (byte)Code.No << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.ShortInlineI << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Rethrow = new OpCode (
			0xfe << 0 | 0x1a << 8 | (byte)Code.Rethrow << 16 | (byte)FlowControl.Throw << 24,
			(byte)OpCodeType.Objmodel << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);

		public static readonly OpCode Sizeof = new OpCode (
			0xfe << 0 | 0x1c << 8 | (byte)Code.Sizeof << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineType << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Refanytype = new OpCode (
			0xfe << 0 | 0x1d << 8 | (byte)Code.Refanytype << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Primitive << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop1 << 16 | (byte)StackBehaviour.Pushi << 24);

		public static readonly OpCode Readonly = new OpCode (
			0xfe << 0 | 0x1e << 8 | (byte)Code.Readonly << 16 | (byte)FlowControl.Next << 24,
			(byte)OpCodeType.Prefix << 0 | (byte)OperandType.InlineNone << 8 | (byte)StackBehaviour.Pop0 << 16 | (byte)StackBehaviour.Push0 << 24);
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/PortablePdb.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using MonoFN.Cecil.PE;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;

namespace MonoFN.Cecil.Cil {

	public sealed class PortablePdbReaderProvider : ISymbolReaderProvider {

		public ISymbolReader GetSymbolReader (ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule (module);
			Mixin.CheckFileName (fileName);

			var file = File.OpenRead (Mixin.GetPdbFileName (fileName));
			return GetSymbolReader (module, Disposable.Owned (file as Stream), file.Name);
		}

		public ISymbolReader GetSymbolReader (ModuleDefinition module, Stream symbolStream)
		{
			Mixin.CheckModule (module);
			Mixin.CheckStream (symbolStream);

			return GetSymbolReader (module, Disposable.NotOwned (symbolStream), symbolStream.GetFileName ());
		}

		ISymbolReader GetSymbolReader (ModuleDefinition module, Disposable<Stream> symbolStream, string fileName)
		{
			return new PortablePdbReader (ImageReader.ReadPortablePdb (symbolStream, fileName), module);
		}
	}

	public sealed class PortablePdbReader : ISymbolReader {

		readonly Image image;
		readonly ModuleDefinition module;
		readonly MetadataReader reader;
		readonly MetadataReader debug_reader;

		bool IsEmbedded { get { return reader.image == debug_reader.image; } }

		internal PortablePdbReader (Image image, ModuleDefinition module)
		{
			this.image = image;
			this.module = module;
			this.reader = module.reader;
			this.debug_reader = new MetadataReader (image, module, this.reader);
		}

		public ISymbolWriterProvider GetWriterProvider ()
		{
			return new PortablePdbWriterProvider ();
		}

		public bool ProcessDebugHeader (ImageDebugHeader header)
		{
			if (image == module.Image)
				return true;

			foreach (var entry in header.Entries) {
				if (!IsMatchingEntry (image.PdbHeap, entry))
					continue;

				ReadModule ();
				return true;
			}

			return false;
		}

		static bool IsMatchingEntry (PdbHeap heap, ImageDebugHeaderEntry entry)
		{
			if (entry.Directory.Type != ImageDebugType.CodeView)
				return false;

			var data = entry.Data;

			if (data.Length < 24)
				return false;

			var magic = ReadInt32 (data, 0);
			if (magic != 0x53445352)
				return false;

			var buffer = new byte [16];
			Buffer.BlockCopy (data, 4, buffer, 0, 16);

			var module_guid = new Guid (buffer);

			Buffer.BlockCopy (heap.Id, 0, buffer, 0, 16);

			var pdb_guid = new Guid (buffer);

			return module_guid == pdb_guid;
		}

		static int ReadInt32 (byte [] bytes, int start)
		{
			return (bytes [start]
				| (bytes [start + 1] << 8)
				| (bytes [start + 2] << 16)
				| (bytes [start + 3] << 24));
		}

		void ReadModule ()
		{
			module.custom_infos = debug_reader.GetCustomDebugInformation (module);
		}

		public MethodDebugInformation Read (MethodDefinition method)
		{
			var info = new MethodDebugInformation (method);
			ReadSequencePoints (info);
			ReadScope (info);
			ReadStateMachineKickOffMethod (info);
			ReadCustomDebugInformations (info);
			return info;
		}

		void ReadSequencePoints (MethodDebugInformation method_info)
		{
			method_info.sequence_points = debug_reader.ReadSequencePoints (method_info.method);
		}

		void ReadScope (MethodDebugInformation method_info)
		{
			method_info.scope = debug_reader.ReadScope (method_info.method);
		}

		void ReadStateMachineKickOffMethod (MethodDebugInformation method_info)
		{
			method_info.kickoff_method = debug_reader.ReadStateMachineKickoffMethod (method_info.method);
		}

		void ReadCustomDebugInformations (MethodDebugInformation info)
		{
			info.method.custom_infos = debug_reader.GetCustomDebugInformation (info.method);
		}

		public void Dispose ()
		{
			if (IsEmbedded)
				return;

			image.Dispose ();
		}
	}

	public sealed class EmbeddedPortablePdbReaderProvider : ISymbolReaderProvider {

		public ISymbolReader GetSymbolReader (ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule (module);

			var header = module.GetDebugHeader ();
			var entry = header.GetEmbeddedPortablePdbEntry ();
			if (entry == null)
				throw new InvalidOperationException ();

			return new EmbeddedPortablePdbReader (
				(PortablePdbReader)new PortablePdbReaderProvider ().GetSymbolReader (module, GetPortablePdbStream (entry)));
		}

		static Stream GetPortablePdbStream (ImageDebugHeaderEntry entry)
		{
			var compressed_stream = new MemoryStream (entry.Data);
			var reader = new BinaryStreamReader (compressed_stream);
			reader.ReadInt32 (); // signature
			var length = reader.ReadInt32 ();
			var decompressed_stream = new MemoryStream (length);

			using (var deflate_stream = new DeflateStream (compressed_stream, CompressionMode.Decompress, leaveOpen: true))
				deflate_stream.CopyTo (decompressed_stream);

			return decompressed_stream;
		}

		public ISymbolReader GetSymbolReader (ModuleDefinition module, Stream symbolStream)
		{
			throw new NotSupportedException ();
		}
	}

	public sealed class EmbeddedPortablePdbReader : ISymbolReader {
		private readonly PortablePdbReader reader;

		internal EmbeddedPortablePdbReader (PortablePdbReader reader)
		{
			if (reader == null)
				throw new ArgumentNullException ();

			this.reader = reader;
		}

		public ISymbolWriterProvider GetWriterProvider ()
		{
			return new EmbeddedPortablePdbWriterProvider ();
		}

		public bool ProcessDebugHeader (ImageDebugHeader header)
		{
			return reader.ProcessDebugHeader (header);
		}

		public MethodDebugInformation Read (MethodDefinition method)
		{
			return reader.Read (method);
		}

		public void Dispose ()
		{
			reader.Dispose ();
		}
	}

	public sealed class PortablePdbWriterProvider : ISymbolWriterProvider {
		public ISymbolWriter GetSymbolWriter (ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule (module);
			Mixin.CheckFileName (fileName);

			var file = File.OpenWrite (Mixin.GetPdbFileName (fileName));
			return GetSymbolWriter (module, Disposable.Owned (file as Stream));
		}

		public ISymbolWriter GetSymbolWriter (ModuleDefinition module, Stream symbolStream)
		{
			Mixin.CheckModule (module);
			Mixin.CheckStream (symbolStream);

			return GetSymbolWriter (module, Disposable.NotOwned (symbolStream));
		}

		ISymbolWriter GetSymbolWriter (ModuleDefinition module, Disposable<Stream> stream)
		{
			var metadata = new MetadataBuilder (module, this);
			var writer = ImageWriter.CreateDebugWriter (module, metadata, stream);

			return new PortablePdbWriter (metadata, module, writer);
		}
	}

	public sealed class PortablePdbWriter : ISymbolWriter {

		readonly MetadataBuilder pdb_metadata;
		readonly ModuleDefinition module;
		readonly ImageWriter writer;

		MetadataBuilder module_metadata;

		bool IsEmbedded { get { return writer == null; } }

		internal PortablePdbWriter (MetadataBuilder pdb_metadata, ModuleDefinition module)
		{
			this.pdb_metadata = pdb_metadata;
			this.module = module;

			this.module_metadata = module.metadata_builder;

			if (module_metadata != pdb_metadata)
				this.pdb_metadata.metadata_builder = this.module_metadata;

			pdb_metadata.AddCustomDebugInformations (module);
		}

		internal PortablePdbWriter (MetadataBuilder pdb_metadata, ModuleDefinition module, ImageWriter writer)
			: this (pdb_metadata, module)
		{
			this.writer = writer;
		}

		public ISymbolReaderProvider GetReaderProvider ()
		{
			return new PortablePdbReaderProvider ();
		}

		public ImageDebugHeader GetDebugHeader ()
		{
			if (IsEmbedded)
				return new ImageDebugHeader ();

			var directory = new ImageDebugDirectory () {
				MajorVersion = 256,
				MinorVersion = 20557,
				Type = ImageDebugType.CodeView,
				TimeDateStamp = (int)module.timestamp,
			};

			var buffer = new ByteBuffer ();
			// RSDS
			buffer.WriteUInt32 (0x53445352);
			// Module ID
			buffer.WriteBytes (module.Mvid.ToByteArray ());
			// PDB Age
			buffer.WriteUInt32 (1);
			// PDB Path
			var fileName = writer.BaseStream.GetFileName ();
			if (string.IsNullOrEmpty (fileName)) {
				fileName = module.Assembly.Name.Name + ".pdb";
			}
			buffer.WriteBytes (System.Text.Encoding.UTF8.GetBytes (fileName));
			buffer.WriteByte (0);

			var data = new byte [buffer.length];
			Buffer.BlockCopy (buffer.buffer, 0, data, 0, buffer.length);
			directory.SizeOfData = data.Length;

			return new ImageDebugHeader (new ImageDebugHeaderEntry (directory, data));
		}

		public void Write (MethodDebugInformation info)
		{
			CheckMethodDebugInformationTable ();

			pdb_metadata.AddMethodDebugInformation (info);
		}

		void CheckMethodDebugInformationTable ()
		{
			var mdi = pdb_metadata.table_heap.GetTable<MethodDebugInformationTable> (Table.MethodDebugInformation);
			if (mdi.length > 0)
				return;

			// The MethodDebugInformation table has the same length as the Method table
			mdi.rows = new Row<uint, uint> [module_metadata.method_rid - 1];
			mdi.length = mdi.rows.Length;
		}

		public void Dispose ()
		{
			if (IsEmbedded)
				return;

			WritePdbFile ();
		}

		void WritePdbFile ()
		{
			WritePdbHeap ();

			WriteTableHeap ();

			writer.BuildMetadataTextMap ();
			writer.WriteMetadataHeader ();
			writer.WriteMetadata ();

			writer.Flush ();
			writer.stream.Dispose ();
		}

		void WritePdbHeap ()
		{
			var pdb_heap = pdb_metadata.pdb_heap;

			pdb_heap.WriteBytes (module.Mvid.ToByteArray ());
			pdb_heap.WriteUInt32 (module_metadata.timestamp);

			pdb_heap.WriteUInt32 (module_metadata.entry_point.ToUInt32 ());

			var table_heap = module_metadata.table_heap;
			var tables = table_heap.tables;

			ulong valid = 0;
			for (int i = 0; i < tables.Length; i++) {
				if (tables [i] == null || tables [i].Length == 0)
					continue;

				valid |= (1UL << i);
			}

			pdb_heap.WriteUInt64 (valid);

			for (int i = 0; i < tables.Length; i++) {
				if (tables [i] == null || tables [i].Length == 0)
					continue;

				pdb_heap.WriteUInt32 ((uint)tables [i].Length);
			}
		}

		void WriteTableHeap ()
		{
			pdb_metadata.table_heap.string_offsets = pdb_metadata.string_heap.WriteStrings ();
			pdb_metadata.table_heap.ComputeTableInformations ();
			pdb_metadata.table_heap.WriteTableHeap ();
		}
	}

	public sealed class EmbeddedPortablePdbWriterProvider : ISymbolWriterProvider {

		public ISymbolWriter GetSymbolWriter (ModuleDefinition module, string fileName)
		{
			Mixin.CheckModule (module);
			Mixin.CheckFileName (fileName);

			var stream = new MemoryStream ();
			var pdb_writer = (PortablePdbWriter)new PortablePdbWriterProvider ().GetSymbolWriter (module, stream);
			return new EmbeddedPortablePdbWriter (stream, pdb_writer);
		}

		public ISymbolWriter GetSymbolWriter (ModuleDefinition module, Stream symbolStream)
		{
			throw new NotSupportedException ();
		}
	}

	public sealed class EmbeddedPortablePdbWriter : ISymbolWriter {

		readonly Stream stream;
		readonly PortablePdbWriter writer;

		internal EmbeddedPortablePdbWriter (Stream stream, PortablePdbWriter writer)
		{
			this.stream = stream;
			this.writer = writer;
		}

		public ISymbolReaderProvider GetReaderProvider ()
		{
			return new EmbeddedPortablePdbReaderProvider ();
		}

		public ImageDebugHeader GetDebugHeader ()
		{
			writer.Dispose ();

			var directory = new ImageDebugDirectory {
				Type = ImageDebugType.EmbeddedPortablePdb,
				MajorVersion = 0x0100,
				MinorVersion = 0x0100,
			};

			var data = new MemoryStream ();

			var w = new BinaryStreamWriter (data);
			w.WriteByte (0x4d);
			w.WriteByte (0x50);
			w.WriteByte (0x44);
			w.WriteByte (0x42);

			w.WriteInt32 ((int)stream.Length);

			stream.Position = 0;

			using (var compress_stream = new DeflateStream (data, CompressionMode.Compress, leaveOpen: true))
				stream.CopyTo (compress_stream);

			directory.SizeOfData = (int)data.Length;

			return new ImageDebugHeader (new [] {
				writer.GetDebugHeader ().Entries [0],
				new ImageDebugHeaderEntry (directory, data.ToArray ())
			});
		}

		public void Write (MethodDebugInformation info)
		{
			writer.Write (info);
		}

		public void Dispose ()
		{
		}
	}

	static class PdbGuidMapping {

		static readonly Dictionary<Guid, DocumentLanguage> guid_language = new Dictionary<Guid, DocumentLanguage> ();
		static readonly Dictionary<DocumentLanguage, Guid> language_guid = new Dictionary<DocumentLanguage, Guid> ();

		static PdbGuidMapping ()
		{
			AddMapping (DocumentLanguage.C, new Guid ("63a08714-fc37-11d2-904c-00c04fa302a1"));
			AddMapping (DocumentLanguage.Cpp, new Guid ("3a12d0b7-c26c-11d0-b442-00a0244a1dd2"));
			AddMapping (DocumentLanguage.CSharp, new Guid ("3f5162f8-07c6-11d3-9053-00c04fa302a1"));
			AddMapping (DocumentLanguage.Basic, new Guid ("3a12d0b8-c26c-11d0-b442-00a0244a1dd2"));
			AddMapping (DocumentLanguage.Java, new Guid ("3a12d0b4-c26c-11d0-b442-00a0244a1dd2"));
			AddMapping (DocumentLanguage.Cobol, new Guid ("af046cd1-d0e1-11d2-977c-00a0c9b4d50c"));
			AddMapping (DocumentLanguage.Pascal, new Guid ("af046cd2-d0e1-11d2-977c-00a0c9b4d50c"));
			AddMapping (DocumentLanguage.Cil, new Guid ("af046cd3-d0e1-11d2-977c-00a0c9b4d50c"));
			AddMapping (DocumentLanguage.JScript, new Guid ("3a12d0b6-c26c-11d0-b442-00a0244a1dd2"));
			AddMapping (DocumentLanguage.Smc, new Guid ("0d9b9f7b-6611-11d3-bd2a-0000f80849bd"));
			AddMapping (DocumentLanguage.MCpp, new Guid ("4b35fde8-07c6-11d3-9053-00c04fa302a1"));
			AddMapping (DocumentLanguage.FSharp, new Guid ("ab4f38c9-b6e6-43ba-be3b-58080b2ccce3"));
		}

		static void AddMapping (DocumentLanguage language, Guid guid)
		{
			guid_language.Add (guid, language);
			language_guid.Add (language, guid);
		}

		static readonly Guid type_text = new Guid ("5a869d0b-6611-11d3-bd2a-0000f80849bd");

		public static DocumentType ToType (this Guid guid)
		{
			if (guid == type_text)
				return DocumentType.Text;

			return DocumentType.Other;
		}

		public static Guid ToGuid (this DocumentType type)
		{
			if (type == DocumentType.Text)
				return type_text;

			return new Guid ();
		}

		static readonly Guid hash_md5 = new Guid ("406ea660-64cf-4c82-b6f0-42d48172a799");
		static readonly Guid hash_sha1 = new Guid ("ff1816ec-aa5e-4d10-87f7-6f4963833460");
		static readonly Guid hash_sha256 = new Guid ("8829d00f-11b8-4213-878b-770e8597ac16");

		public static DocumentHashAlgorithm ToHashAlgorithm (this Guid guid)
		{
			if (guid == hash_md5)
				return DocumentHashAlgorithm.MD5;

			if (guid == hash_sha1)
				return DocumentHashAlgorithm.SHA1;

			if (guid == hash_sha256)
				return DocumentHashAlgorithm.SHA256;

			return DocumentHashAlgorithm.None;
		}

		public static Guid ToGuid (this DocumentHashAlgorithm hash_algo)
		{
			if (hash_algo == DocumentHashAlgorithm.MD5)
				return hash_md5;

			if (hash_algo == DocumentHashAlgorithm.SHA1)
				return hash_sha1;

			if (hash_algo == DocumentHashAlgorithm.SHA256)
				return hash_sha256;

			return new Guid ();
		}

		public static DocumentLanguage ToLanguage (this Guid guid)
		{
			DocumentLanguage language;
			if (!guid_language.TryGetValue (guid, out language))
				return DocumentLanguage.Other;

			return language;
		}

		public static Guid ToGuid (this DocumentLanguage language)
		{
			Guid guid;
			if (!language_guid.TryGetValue (language, out guid))
				return new Guid ();

			return guid;
		}

		static readonly Guid vendor_ms = new Guid ("994b45c4-e6e9-11d2-903f-00c04fa302a1");

		public static DocumentLanguageVendor ToVendor (this Guid guid)
		{
			if (guid == vendor_ms)
				return DocumentLanguageVendor.Microsoft;

			return DocumentLanguageVendor.Other;
		}

		public static Guid ToGuid (this DocumentLanguageVendor vendor)
		{
			if (vendor == DocumentLanguageVendor.Microsoft)
				return vendor_ms;

			return new Guid ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/SequencePoint.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil.Cil {

	public sealed class SequencePoint {

		internal InstructionOffset offset;
		Document document;

		int start_line;
		int start_column;
		int end_line;
		int end_column;

		public int Offset {
			get { return offset.Offset; }
		}

		public int StartLine {
			get { return start_line; }
			set { start_line = value; }
		}

		public int StartColumn {
			get { return start_column; }
			set { start_column = value; }
		}

		public int EndLine {
			get { return end_line; }
			set { end_line = value; }
		}

		public int EndColumn {
			get { return end_column; }
			set { end_column = value; }
		}

		public bool IsHidden {
			get { return start_line == 0xfeefee && start_line == end_line; }
		}

		public Document Document {
			get { return document; }
			set { document = value; }
		}

		internal SequencePoint (int offset, Document document)
		{
			if (document == null)
				throw new ArgumentNullException ("document");

			this.offset = new InstructionOffset (offset);
			this.document = document;
		}

		public SequencePoint (Instruction instruction, Document document)
		{
			if (document == null)
				throw new ArgumentNullException ("document");

			this.offset = new InstructionOffset (instruction);
			this.document = document;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/Symbols.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Cecil.PE;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using SR = System.Reflection;

namespace MonoFN.Cecil.Cil {

	[StructLayout (LayoutKind.Sequential)]
	public struct ImageDebugDirectory {
		public const int Size = 28;

		public int Characteristics;
		public int TimeDateStamp;
		public short MajorVersion;
		public short MinorVersion;
		public ImageDebugType Type;
		public int SizeOfData;
		public int AddressOfRawData;
		public int PointerToRawData;
	}

	public enum ImageDebugType {
		CodeView = 2,
		Deterministic = 16,
		EmbeddedPortablePdb = 17,
	}

	public sealed class ImageDebugHeader {

		readonly ImageDebugHeaderEntry [] entries;

		public bool HasEntries {
			get { return !entries.IsNullOrEmpty (); }
		}

		public ImageDebugHeaderEntry [] Entries {
			get { return entries; }
		}

		public ImageDebugHeader (ImageDebugHeaderEntry [] entries)
		{
			this.entries = entries ?? Empty<ImageDebugHeaderEntry>.Array;
		}

		public ImageDebugHeader ()
			: this (Empty<ImageDebugHeaderEntry>.Array)
		{
		}

		public ImageDebugHeader (ImageDebugHeaderEntry entry)
			: this (new [] { entry })
		{
		}
	}

	public sealed class ImageDebugHeaderEntry {

		ImageDebugDirectory directory;
		readonly byte [] data;

		public ImageDebugDirectory Directory {
			get { return directory; }
			internal set { directory = value; }
		}

		public byte [] Data {
			get { return data; }
		}

		public ImageDebugHeaderEntry (ImageDebugDirectory directory, byte [] data)
		{
			this.directory = directory;
			this.data = data ?? Empty<byte>.Array;
		}
	}

	public sealed class ScopeDebugInformation : DebugInformation {

		internal InstructionOffset start;
		internal InstructionOffset end;
		internal ImportDebugInformation import;
		internal Collection<ScopeDebugInformation> scopes;
		internal Collection<VariableDebugInformation> variables;
		internal Collection<ConstantDebugInformation> constants;

		public InstructionOffset Start {
			get { return start; }
			set { start = value; }
		}

		public InstructionOffset End {
			get { return end; }
			set { end = value; }
		}

		public ImportDebugInformation Import {
			get { return import; }
			set { import = value; }
		}

		public bool HasScopes {
			get { return !scopes.IsNullOrEmpty (); }
		}

		public Collection<ScopeDebugInformation> Scopes {
			get {
				if (scopes == null)
					Interlocked.CompareExchange (ref scopes, new Collection<ScopeDebugInformation> (), null);

				return scopes;
			}
		}

		public bool HasVariables {
			get { return !variables.IsNullOrEmpty (); }
		}

		public Collection<VariableDebugInformation> Variables {
			get {
				if (variables == null)
					Interlocked.CompareExchange (ref variables, new Collection<VariableDebugInformation> (), null);

				return variables;
			}
		}

		public bool HasConstants {
			get { return !constants.IsNullOrEmpty (); }
		}

		public Collection<ConstantDebugInformation> Constants {
			get {
				if (constants == null)
					Interlocked.CompareExchange (ref constants, new Collection<ConstantDebugInformation> (), null);

				return constants;
			}
		}

		internal ScopeDebugInformation ()
		{
			this.token = new MetadataToken (TokenType.LocalScope);
		}

		public ScopeDebugInformation (Instruction start, Instruction end)
			: this ()
		{
			if (start == null)
				throw new ArgumentNullException ("start");

			this.start = new InstructionOffset (start);

			if (end != null)
				this.end = new InstructionOffset (end);
		}

		public bool TryGetName (VariableDefinition variable, out string name)
		{
			name = null;
			if (variables == null || variables.Count == 0)
				return false;

			for (int i = 0; i < variables.Count; i++) {
				if (variables [i].Index == variable.Index) {
					name = variables [i].Name;
					return true;
				}
			}

			return false;
		}
	}

	public struct InstructionOffset {

		readonly Instruction instruction;
		readonly int? offset;

		public int Offset {
			get {
				if (instruction != null)
					return instruction.Offset;
				if (offset.HasValue)
					return offset.Value;

				throw new NotSupportedException ();
			}
		}

		public bool IsEndOfMethod {
			get { return instruction == null && !offset.HasValue; }
		}

		internal bool IsResolved => instruction != null || !offset.HasValue;

		internal Instruction ResolvedInstruction => instruction;

		public InstructionOffset (Instruction instruction)
		{
			if (instruction == null)
				throw new ArgumentNullException ("instruction");

			this.instruction = instruction;
			this.offset = null;
		}

		public InstructionOffset (int offset)
		{
			this.instruction = null;
			this.offset = offset;
		}
	}

	[Flags]
	public enum VariableAttributes : ushort {
		None = 0,
		DebuggerHidden = 1,
	}

	public struct VariableIndex {
		readonly VariableDefinition variable;
		readonly int? index;

		public int Index {
			get {
				if (variable != null)
					return variable.Index;
				if (index.HasValue)
					return index.Value;

				throw new NotSupportedException ();
			}
		}

		internal bool IsResolved => variable != null;

		internal VariableDefinition ResolvedVariable => variable;

		public VariableIndex (VariableDefinition variable)
		{
			if (variable == null)
				throw new ArgumentNullException ("variable");

			this.variable = variable;
			this.index = null;
		}

		public VariableIndex (int index)
		{
			this.variable = null;
			this.index = index;
		}
	}

	public abstract class DebugInformation : ICustomDebugInformationProvider {

		internal MetadataToken token;
		internal Collection<CustomDebugInformation> custom_infos;

		public MetadataToken MetadataToken {
			get { return token; }
			set { token = value; }
		}

		public bool HasCustomDebugInformations {
			get { return !custom_infos.IsNullOrEmpty (); }
		}

		public Collection<CustomDebugInformation> CustomDebugInformations {
			get {
				if (custom_infos == null)
					Interlocked.CompareExchange (ref custom_infos, new Collection<CustomDebugInformation> (), null);

				return custom_infos;
			}
		}

		internal DebugInformation ()
		{
		}
	}

	public sealed class VariableDebugInformation : DebugInformation {

		string name;
		ushort attributes;
		internal VariableIndex index;

		public int Index {
			get { return index.Index; }
		}

		public string Name {
			get { return name; }
			set { name = value; }
		}

		public VariableAttributes Attributes {
			get { return (VariableAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public bool IsDebuggerHidden {
			get { return attributes.GetAttributes ((ushort)VariableAttributes.DebuggerHidden); }
			set { attributes = attributes.SetAttributes ((ushort)VariableAttributes.DebuggerHidden, value); }
		}

		internal VariableDebugInformation (int index, string name)
		{
			if (name == null)
				throw new ArgumentNullException ("name");

			this.index = new VariableIndex (index);
			this.name = name;
		}

		public VariableDebugInformation (VariableDefinition variable, string name)
		{
			if (variable == null)
				throw new ArgumentNullException ("variable");
			if (name == null)
				throw new ArgumentNullException ("name");

			this.index = new VariableIndex (variable);
			this.name = name;
			this.token = new MetadataToken (TokenType.LocalVariable);
		}
	}

	public sealed class ConstantDebugInformation : DebugInformation {

		string name;
		TypeReference constant_type;
		object value;

		public string Name {
			get { return name; }
			set { name = value; }
		}

		public TypeReference ConstantType {
			get { return constant_type; }
			set { constant_type = value; }
		}

		public object Value {
			get { return value; }
			set { this.value = value; }
		}

		public ConstantDebugInformation (string name, TypeReference constant_type, object value)
		{
			if (name == null)
				throw new ArgumentNullException ("name");

			this.name = name;
			this.constant_type = constant_type;
			this.value = value;
			this.token = new MetadataToken (TokenType.LocalConstant);
		}
	}

	public enum ImportTargetKind : byte {
		ImportNamespace = 1,
		ImportNamespaceInAssembly = 2,
		ImportType = 3,
		ImportXmlNamespaceWithAlias = 4,
		ImportAlias = 5,
		DefineAssemblyAlias = 6,
		DefineNamespaceAlias = 7,
		DefineNamespaceInAssemblyAlias = 8,
		DefineTypeAlias = 9,
	}

	public sealed class ImportTarget {

		internal ImportTargetKind kind;

		internal string @namespace;
		internal TypeReference type;
		internal AssemblyNameReference reference;
		internal string alias;

		public string Namespace {
			get { return @namespace; }
			set { @namespace = value; }
		}

		public TypeReference Type {
			get { return type; }
			set { type = value; }
		}

		public AssemblyNameReference AssemblyReference {
			get { return reference; }
			set { reference = value; }
		}

		public string Alias {
			get { return alias; }
			set { alias = value; }
		}

		public ImportTargetKind Kind {
			get { return kind; }
			set { kind = value; }
		}

		public ImportTarget (ImportTargetKind kind)
		{
			this.kind = kind;
		}
	}

	public sealed class ImportDebugInformation : DebugInformation {

		internal ImportDebugInformation parent;
		internal Collection<ImportTarget> targets;

		public bool HasTargets {
			get { return !targets.IsNullOrEmpty (); }
		}

		public Collection<ImportTarget> Targets {
			get {
				if (targets == null)
					Interlocked.CompareExchange (ref targets, new Collection<ImportTarget> (), null);

				return targets;
			}
		}

		public ImportDebugInformation Parent {
			get { return parent; }
			set { parent = value; }
		}

		public ImportDebugInformation ()
		{
			this.token = new MetadataToken (TokenType.ImportScope);
		}
	}

	public interface ICustomDebugInformationProvider : IMetadataTokenProvider {
		bool HasCustomDebugInformations { get; }
		Collection<CustomDebugInformation> CustomDebugInformations { get; }
	}

	public enum CustomDebugInformationKind {
		Binary,
		StateMachineScope,
		DynamicVariable,
		DefaultNamespace,
		AsyncMethodBody,
		EmbeddedSource,
		SourceLink,
	}

	public abstract class CustomDebugInformation : DebugInformation {

		Guid identifier;

		public Guid Identifier {
			get { return identifier; }
		}

		public abstract CustomDebugInformationKind Kind { get; }

		internal CustomDebugInformation (Guid identifier)
		{
			this.identifier = identifier;
			this.token = new MetadataToken (TokenType.CustomDebugInformation);
		}
	}

	public sealed class BinaryCustomDebugInformation : CustomDebugInformation {

		byte [] data;

		public byte [] Data {
			get { return data; }
			set { data = value; }
		}

		public override CustomDebugInformationKind Kind {
			get { return CustomDebugInformationKind.Binary; }
		}

		public BinaryCustomDebugInformation (Guid identifier, byte [] data)
			: base (identifier)
		{
			this.data = data;
		}
	}

	public sealed class AsyncMethodBodyDebugInformation : CustomDebugInformation {

		internal InstructionOffset catch_handler;
		internal Collection<InstructionOffset> yields;
		internal Collection<InstructionOffset> resumes;
		internal Collection<MethodDefinition> resume_methods;

		public InstructionOffset CatchHandler {
			get { return catch_handler; }
			set { catch_handler = value; }
		}

		public Collection<InstructionOffset> Yields {
			get {
				if (yields == null)
					Interlocked.CompareExchange (ref yields, new Collection<InstructionOffset> (), null);

				return yields;
			}
		}

		public Collection<InstructionOffset> Resumes {
			get {
				if (resumes == null)
					Interlocked.CompareExchange (ref resumes, new Collection<InstructionOffset> (), null);

				return resumes;
			}
		}

		public Collection<MethodDefinition> ResumeMethods {
			get { return resume_methods ?? (resume_methods = new Collection<MethodDefinition> ()); }
		}

		public override CustomDebugInformationKind Kind {
			get { return CustomDebugInformationKind.AsyncMethodBody; }
		}

		public static Guid KindIdentifier = new Guid ("{54FD2AC5-E925-401A-9C2A-F94F171072F8}");

		internal AsyncMethodBodyDebugInformation (int catchHandler)
			: base (KindIdentifier)
		{
			this.catch_handler = new InstructionOffset (catchHandler);
		}

		public AsyncMethodBodyDebugInformation (Instruction catchHandler)
			: base (KindIdentifier)
		{
			this.catch_handler = new InstructionOffset (catchHandler);
		}

		public AsyncMethodBodyDebugInformation ()
			: base (KindIdentifier)
		{
			this.catch_handler = new InstructionOffset (-1);
		}
	}

	public sealed class StateMachineScope {

		internal InstructionOffset start;
		internal InstructionOffset end;

		public InstructionOffset Start {
			get { return start; }
			set { start = value; }
		}

		public InstructionOffset End {
			get { return end; }
			set { end = value; }
		}

		internal StateMachineScope (int start, int end)
		{
			this.start = new InstructionOffset (start);
			this.end = new InstructionOffset (end);
		}

		public StateMachineScope (Instruction start, Instruction end)
		{
			this.start = new InstructionOffset (start);
			this.end = end != null ? new InstructionOffset (end) : new InstructionOffset ();
		}
	}

	public sealed class StateMachineScopeDebugInformation : CustomDebugInformation {

		internal Collection<StateMachineScope> scopes;

		public Collection<StateMachineScope> Scopes {
			get { return scopes ?? (scopes = new Collection<StateMachineScope> ()); }
		}

		public override CustomDebugInformationKind Kind {
			get { return CustomDebugInformationKind.StateMachineScope; }
		}

		public static Guid KindIdentifier = new Guid ("{6DA9A61E-F8C7-4874-BE62-68BC5630DF71}");

		public StateMachineScopeDebugInformation ()
			: base (KindIdentifier)
		{
		}
	}

	public sealed class EmbeddedSourceDebugInformation : CustomDebugInformation {

		internal uint index;
		internal MetadataReader debug_reader;
		internal bool resolved;
		internal byte [] content;
		internal bool compress;

		public byte [] Content {
			get {
				if (!resolved)
					Resolve ();

				return content;
			}
			set {
				content = value;
				resolved = true;
			}
		}

		public bool Compress {
			get {
				if (!resolved)
					Resolve ();

				return compress;
			}
			set {
				compress = value;
				resolved = true;
			}
		}

		public override CustomDebugInformationKind Kind {
			get { return CustomDebugInformationKind.EmbeddedSource; }
		}

		public static Guid KindIdentifier = new Guid ("{0E8A571B-6926-466E-B4AD-8AB04611F5FE}");

		internal EmbeddedSourceDebugInformation (uint index, MetadataReader debug_reader)
			: base (KindIdentifier)
		{
			this.index = index;
			this.debug_reader = debug_reader;
		}

		public EmbeddedSourceDebugInformation (byte [] content, bool compress)
			: base (KindIdentifier)
		{
			this.resolved = true;
			this.content = content;
			this.compress = compress;
		}

		internal byte [] ReadRawEmbeddedSourceDebugInformation ()
		{
			if (debug_reader == null)
				throw new InvalidOperationException ();

			return debug_reader.ReadRawEmbeddedSourceDebugInformation (index);
		}

		void Resolve ()
		{
			if (resolved)
				return;

			if (debug_reader == null)
				throw new InvalidOperationException ();

			var row = debug_reader.ReadEmbeddedSourceDebugInformation (index);
			content = row.Col1;
			compress = row.Col2;
			resolved = true;
		}
	}

	public sealed class SourceLinkDebugInformation : CustomDebugInformation {

		internal string content;

		public string Content {
			get { return content; }
			set { content = value; }
		}

		public override CustomDebugInformationKind Kind {
			get { return CustomDebugInformationKind.SourceLink; }
		}

		public static Guid KindIdentifier = new Guid ("{CC110556-A091-4D38-9FEC-25AB9A351A6A}");

		public SourceLinkDebugInformation (string content)
			: base (KindIdentifier)
		{
			this.content = content;
		}
	}

	public sealed class MethodDebugInformation : DebugInformation {

		internal MethodDefinition method;
		internal Collection<SequencePoint> sequence_points;
		internal ScopeDebugInformation scope;
		internal MethodDefinition kickoff_method;
		internal int code_size;
		internal MetadataToken local_var_token;

		public MethodDefinition Method {
			get { return method; }
		}

		public bool HasSequencePoints {
			get { return !sequence_points.IsNullOrEmpty (); }
		}

		public Collection<SequencePoint> SequencePoints {
			get {
				if (sequence_points == null)
					Interlocked.CompareExchange (ref sequence_points, new Collection<SequencePoint> (), null);

				return sequence_points;
			}
		}

		public ScopeDebugInformation Scope {
			get { return scope; }
			set { scope = value; }
		}

		public MethodDefinition StateMachineKickOffMethod {
			get { return kickoff_method; }
			set { kickoff_method = value; }
		}

		internal MethodDebugInformation (MethodDefinition method)
		{
			if (method == null)
				throw new ArgumentNullException ("method");

			this.method = method;
			this.token = new MetadataToken (TokenType.MethodDebugInformation, method.MetadataToken.RID);
		}

		public SequencePoint GetSequencePoint (Instruction instruction)
		{
			if (!HasSequencePoints)
				return null;

			for (int i = 0; i < sequence_points.Count; i++)
				if (sequence_points [i].Offset == instruction.Offset)
					return sequence_points [i];

			return null;
		}

		public IDictionary<Instruction, SequencePoint> GetSequencePointMapping ()
		{
			var instruction_mapping = new Dictionary<Instruction, SequencePoint> ();
			if (!HasSequencePoints || !method.HasBody)
				return instruction_mapping;

			var offset_mapping = new Dictionary<int, SequencePoint> (sequence_points.Count);

			for (int i = 0; i < sequence_points.Count; i++) {
				if (!offset_mapping.ContainsKey (sequence_points [i].Offset))
					offset_mapping.Add (sequence_points [i].Offset, sequence_points [i]);
			}

			var instructions = method.Body.Instructions;

			for (int i = 0; i < instructions.Count; i++) {
				SequencePoint sequence_point;
				if (offset_mapping.TryGetValue (instructions [i].Offset, out sequence_point))
					instruction_mapping.Add (instructions [i], sequence_point);
			}

			return instruction_mapping;
		}

		public IEnumerable<ScopeDebugInformation> GetScopes ()
		{
			if (scope == null)
				return Empty<ScopeDebugInformation>.Array;

			return GetScopes (new [] { scope });
		}

		static IEnumerable<ScopeDebugInformation> GetScopes (IList<ScopeDebugInformation> scopes)
		{
			for (int i = 0; i < scopes.Count; i++) {
				var scope = scopes [i];

				yield return scope;

				if (!scope.HasScopes)
					continue;

				foreach (var sub_scope in GetScopes (scope.Scopes))
					yield return sub_scope;
			}
		}

		public bool TryGetName (VariableDefinition variable, out string name)
		{
			name = null;

			var has_name = false;
			var unique_name = "";

			foreach (var scope in GetScopes ()) {
				string slot_name;
				if (!scope.TryGetName (variable, out slot_name))
					continue;

				if (!has_name) {
					has_name = true;
					unique_name = slot_name;
					continue;
				}

				if (unique_name != slot_name)
					return false;
			}

			name = unique_name;
			return has_name;
		}
	}

	public interface ISymbolReader : IDisposable {

		ISymbolWriterProvider GetWriterProvider ();
		bool ProcessDebugHeader (ImageDebugHeader header);
		MethodDebugInformation Read (MethodDefinition method);
	}

	public interface ISymbolReaderProvider {
		ISymbolReader GetSymbolReader (ModuleDefinition module, string fileName);
		ISymbolReader GetSymbolReader (ModuleDefinition module, Stream symbolStream);
	}

#if !NET_CORE
	[Serializable]
#endif
	public sealed class SymbolsNotFoundException : FileNotFoundException {

		public SymbolsNotFoundException (string message) : base (message)
		{
		}

#if !NET_CORE
		SymbolsNotFoundException (
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
			: base (info, context)
		{
		}
#endif
	}

#if !NET_CORE
	[Serializable]
#endif
	public sealed class SymbolsNotMatchingException : InvalidOperationException {

		public SymbolsNotMatchingException (string message) : base (message)
		{
		}

#if !NET_CORE
		SymbolsNotMatchingException (
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
			: base (info, context)
		{
		}
#endif
	}

	public class DefaultSymbolReaderProvider : ISymbolReaderProvider {

		readonly bool throw_if_no_symbol;

		public DefaultSymbolReaderProvider ()
			: this (throwIfNoSymbol: true)
		{
		}

		public DefaultSymbolReaderProvider (bool throwIfNoSymbol)
		{
			throw_if_no_symbol = throwIfNoSymbol;
		}

		public ISymbolReader GetSymbolReader (ModuleDefinition module, string fileName)
		{
			if (module.Image.HasDebugTables ())
				return null;

			if (module.HasDebugHeader) {
				var header = module.GetDebugHeader ();
				var entry = header.GetEmbeddedPortablePdbEntry ();
				if (entry != null)
					return new EmbeddedPortablePdbReaderProvider ().GetSymbolReader (module, fileName);
			}

			var pdb_file_name = Mixin.GetPdbFileName (fileName);

			if (File.Exists (pdb_file_name)) {
				if (Mixin.IsPortablePdb (Mixin.GetPdbFileName (fileName)))
					return new PortablePdbReaderProvider ().GetSymbolReader (module, fileName);

				try {
					return SymbolProvider.GetReaderProvider (SymbolKind.NativePdb).GetSymbolReader (module, fileName);
				}
				catch (Exception) {
					// We might not include support for native pdbs.
				}
			}

			var mdb_file_name = Mixin.GetMdbFileName (fileName);
			if (File.Exists (mdb_file_name)) {
				try {
					return SymbolProvider.GetReaderProvider (SymbolKind.Mdb).GetSymbolReader (module, fileName);
				}
				catch (Exception) {
					// We might not include support for mdbs.
				}
			}

			if (throw_if_no_symbol)
				throw new SymbolsNotFoundException (string.Format ("No symbol found for file: {0}", fileName));

			return null;
		}

		public ISymbolReader GetSymbolReader (ModuleDefinition module, Stream symbolStream)
		{
			if (module.Image.HasDebugTables ())
				return null;

			if (module.HasDebugHeader) {
				var header = module.GetDebugHeader ();
				var entry = header.GetEmbeddedPortablePdbEntry ();
				if (entry != null)
					return new EmbeddedPortablePdbReaderProvider ().GetSymbolReader (module, "");
			}

			Mixin.CheckStream (symbolStream);
			Mixin.CheckReadSeek (symbolStream);

			var position = symbolStream.Position;

			const int portablePdbHeader = 0x424a5342;

			var reader = new BinaryStreamReader (symbolStream);
			var intHeader = reader.ReadInt32 ();
			symbolStream.Position = position;

			if (intHeader == portablePdbHeader) {
				return new PortablePdbReaderProvider ().GetSymbolReader (module, symbolStream);
			}

			const string nativePdbHeader = "Microsoft C/C++ MSF 7.00";

			var bytesHeader = reader.ReadBytes (nativePdbHeader.Length);
			symbolStream.Position = position;
			var isNativePdb = true;

			for (var i = 0; i < bytesHeader.Length; i++) {
				if (bytesHeader [i] != (byte)nativePdbHeader [i]) {
					isNativePdb = false;
					break;
				}
			}

			if (isNativePdb) {
				try {
					return SymbolProvider.GetReaderProvider (SymbolKind.NativePdb).GetSymbolReader (module, symbolStream);
				}
				catch (Exception) {
					// We might not include support for native pdbs.
				}
			}

			const long mdbHeader = 0x45e82623fd7fa614;

			var longHeader = reader.ReadInt64 ();
			symbolStream.Position = position;

			if (longHeader == mdbHeader) {
				try {
					return SymbolProvider.GetReaderProvider (SymbolKind.Mdb).GetSymbolReader (module, symbolStream);
				}
				catch (Exception) {
					// We might not include support for mdbs.
				}
			}

			if (throw_if_no_symbol)
				throw new SymbolsNotFoundException (string.Format ("No symbols found in stream"));

			return null;
		}
	}

	enum SymbolKind {
		NativePdb,
		PortablePdb,
		EmbeddedPortablePdb,
		Mdb,
	}

	static class SymbolProvider {

		static SR.AssemblyName GetSymbolAssemblyName (SymbolKind kind)
		{
			if (kind == SymbolKind.PortablePdb)
				throw new ArgumentException ();

			var suffix = GetSymbolNamespace (kind);

			var cecil_name = typeof (SymbolProvider).Assembly.GetName ();

			var name = new SR.AssemblyName {
				Name = cecil_name.Name + "." + suffix,
				Version = cecil_name.Version,
#if NET_CORE
				CultureName = cecil_name.CultureName,
#else
				CultureInfo = cecil_name.CultureInfo,
#endif
			};

			name.SetPublicKeyToken (cecil_name.GetPublicKeyToken ());

			return name;
		}

		static Type GetSymbolType (SymbolKind kind, string fullname)
		{
			var type = Type.GetType (fullname);
			if (type != null)
				return type;

			var assembly_name = GetSymbolAssemblyName (kind);

			type = Type.GetType (fullname + ", " + assembly_name.FullName);
			if (type != null)
				return type;

			try {
				var assembly = SR.Assembly.Load (assembly_name);
				if (assembly != null)
					return assembly.GetType (fullname);
			}
			catch (FileNotFoundException) {
			}
			catch (FileLoadException) {
			}

			return null;
		}

		public static ISymbolReaderProvider GetReaderProvider (SymbolKind kind)
		{
			if (kind == SymbolKind.PortablePdb)
				return new PortablePdbReaderProvider ();
			if (kind == SymbolKind.EmbeddedPortablePdb)
				return new EmbeddedPortablePdbReaderProvider ();

			var provider_name = GetSymbolTypeName (kind, "ReaderProvider");
			var type = GetSymbolType (kind, provider_name);
			if (type == null)
				throw new TypeLoadException ("Could not find symbol provider type " + provider_name);

			return (ISymbolReaderProvider)Activator.CreateInstance (type);
		}

		static string GetSymbolTypeName (SymbolKind kind, string name)
		{
			return "MonoFN.Cecil" + "." + GetSymbolNamespace (kind) + "." + kind + name;
		}

		static string GetSymbolNamespace (SymbolKind kind)
		{
			if (kind == SymbolKind.PortablePdb || kind == SymbolKind.EmbeddedPortablePdb)
				return "Cil";
			if (kind == SymbolKind.NativePdb)
				return "Pdb";
			if (kind == SymbolKind.Mdb)
				return "Mdb";

			throw new ArgumentException ();
		}
	}

	public interface ISymbolWriter : IDisposable {

		ISymbolReaderProvider GetReaderProvider ();
		ImageDebugHeader GetDebugHeader ();
		void Write (MethodDebugInformation info);
	}

	public interface ISymbolWriterProvider {

		ISymbolWriter GetSymbolWriter (ModuleDefinition module, string fileName);
		ISymbolWriter GetSymbolWriter (ModuleDefinition module, Stream symbolStream);
	}

	public class DefaultSymbolWriterProvider : ISymbolWriterProvider {

		public ISymbolWriter GetSymbolWriter (ModuleDefinition module, string fileName)
		{
			var reader = module.SymbolReader;
			if (reader == null)
				throw new InvalidOperationException ();

			if (module.Image != null && module.Image.HasDebugTables ())
				return null;

			return reader.GetWriterProvider ().GetSymbolWriter (module, fileName);
		}

		public ISymbolWriter GetSymbolWriter (ModuleDefinition module, Stream symbolStream)
		{
			throw new NotSupportedException ();
		}
	}
}

namespace MonoFN.Cecil {

	static partial class Mixin {

		public static ImageDebugHeaderEntry GetCodeViewEntry (this ImageDebugHeader header)
		{
			return GetEntry (header, ImageDebugType.CodeView);
		}

		public static ImageDebugHeaderEntry GetDeterministicEntry (this ImageDebugHeader header)
		{
			return GetEntry (header, ImageDebugType.Deterministic);
		}

		public static ImageDebugHeader AddDeterministicEntry (this ImageDebugHeader header)
		{
			var entry = new ImageDebugHeaderEntry (new ImageDebugDirectory { Type = ImageDebugType.Deterministic }, Empty<byte>.Array);
			if (header == null)
				return new ImageDebugHeader (entry);

			var entries = new ImageDebugHeaderEntry [header.Entries.Length + 1];
			Array.Copy (header.Entries, entries, header.Entries.Length);
			entries [entries.Length - 1] = entry;
			return new ImageDebugHeader (entries);
		}

		public static ImageDebugHeaderEntry GetEmbeddedPortablePdbEntry (this ImageDebugHeader header)
		{
			return GetEntry (header, ImageDebugType.EmbeddedPortablePdb);
		}

		private static ImageDebugHeaderEntry GetEntry (this ImageDebugHeader header, ImageDebugType type)
		{
			if (!header.HasEntries)
				return null;

			for (var i = 0; i < header.Entries.Length; i++) {
				var entry = header.Entries [i];
				if (entry.Directory.Type == type)
					return entry;
			}

			return null;
		}

		public static string GetPdbFileName (string assemblyFileName)
		{
			return Path.ChangeExtension (assemblyFileName, ".pdb");
		}

		public static string GetMdbFileName (string assemblyFileName)
		{
			return assemblyFileName + ".mdb";
		}

		public static bool IsPortablePdb (string fileName)
		{
			using (var file = new FileStream (fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
				return IsPortablePdb (file);
		}

		public static bool IsPortablePdb (Stream stream)
		{
			const uint ppdb_signature = 0x424a5342;

			if (stream.Length < 4) return false;
			var position = stream.Position;
			try {
				var reader = new BinaryReader (stream);
				return reader.ReadUInt32 () == ppdb_signature;
			}
			finally {
				stream.Position = position;
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/VariableDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Cil {

	public sealed class VariableDefinition : VariableReference {

		public bool IsPinned {
			get { return variable_type.IsPinned; }
		}

		public VariableDefinition (TypeReference variableType)
			: base (variableType)
		{
		}

		public override VariableDefinition Resolve ()
		{
			return this;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Cil/VariableReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Cil {

	public abstract class VariableReference {

		internal int index = -1;
		protected TypeReference variable_type;

		public TypeReference VariableType {
			get { return variable_type; }
			set { variable_type = value; }
		}

		public int Index {
			get { return index; }
		}

		internal VariableReference (TypeReference variable_type)
		{
			this.variable_type = variable_type;
		}

		public abstract VariableDefinition Resolve ();

		public override string ToString ()
		{
			if (index >= 0)
				return "V_" + index;

			return string.Empty;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/BlobHeap.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil.Metadata {

	sealed class BlobHeap : Heap {

		public BlobHeap (byte [] data)
			: base (data)
		{
		}

		public byte [] Read (uint index)
		{
			if (index == 0 || index > this.data.Length - 1)
				return Empty<byte>.Array;

			int position = (int)index;
			int length = (int)data.ReadCompressedUInt32 (ref position);

			if (length > data.Length - position)
				return Empty<byte>.Array;

			var buffer = new byte [length];

			Buffer.BlockCopy (data, position, buffer, 0, length);

			return buffer;
		}

		public void GetView (uint signature, out byte [] buffer, out int index, out int length)
		{
			if (signature == 0 || signature > data.Length - 1) {
				buffer = null;
				index = length = 0;
				return;
			}

			buffer = data;

			index = (int)signature;
			length = (int)buffer.ReadCompressedUInt32 (ref index);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/Buffers.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.PE;
using System;
using System.Collections.Generic;
using System.Text;
using RVA = System.UInt32;

namespace MonoFN.Cecil.Metadata {

	sealed class TableHeapBuffer : HeapBuffer {

		readonly ModuleDefinition module;
		readonly MetadataBuilder metadata;

		readonly internal TableInformation [] table_infos = new TableInformation [Mixin.TableCount];
		readonly internal MetadataTable [] tables = new MetadataTable [Mixin.TableCount];

		bool large_string;
		bool large_blob;
		bool large_guid;

		readonly int [] coded_index_sizes = new int [Mixin.CodedIndexCount];
		readonly Func<Table, int> counter;

		internal uint [] string_offsets;

		public override bool IsEmpty {
			get { return false; }
		}

		public TableHeapBuffer (ModuleDefinition module, MetadataBuilder metadata)
			: base (24)
		{
			this.module = module;
			this.metadata = metadata;
			this.counter = GetTableLength;
		}

		int GetTableLength (Table table)
		{
			return (int)table_infos [(int)table].Length;
		}

		public TTable GetTable<TTable> (Table table) where TTable : MetadataTable, new()
		{
			var md_table = (TTable)tables [(int)table];
			if (md_table != null)
				return md_table;

			md_table = new TTable ();
			tables [(int)table] = md_table;
			return md_table;
		}

		public void WriteBySize (uint value, int size)
		{
			if (size == 4)
				WriteUInt32 (value);
			else
				WriteUInt16 ((ushort)value);
		}

		public void WriteBySize (uint value, bool large)
		{
			if (large)
				WriteUInt32 (value);
			else
				WriteUInt16 ((ushort)value);
		}

		public void WriteString (uint @string)
		{
			WriteBySize (string_offsets [@string], large_string);
		}

		public void WriteBlob (uint blob)
		{
			WriteBySize (blob, large_blob);
		}

		public void WriteGuid (uint guid)
		{
			WriteBySize (guid, large_guid);
		}

		public void WriteRID (uint rid, Table table)
		{
			WriteBySize (rid, table_infos [(int)table].IsLarge);
		}

		int GetCodedIndexSize (CodedIndex coded_index)
		{
			var index = (int)coded_index;
			var size = coded_index_sizes [index];
			if (size != 0)
				return size;

			return coded_index_sizes [index] = coded_index.GetSize (counter);
		}

		public void WriteCodedRID (uint rid, CodedIndex coded_index)
		{
			WriteBySize (rid, GetCodedIndexSize (coded_index));
		}

		public void WriteTableHeap ()
		{
			WriteUInt32 (0);                    // Reserved
			WriteByte (GetTableHeapVersion ()); // MajorVersion
			WriteByte (0);                      // MinorVersion
			WriteByte (GetHeapSizes ());        // HeapSizes
			WriteByte (10);                     // Reserved2
			WriteUInt64 (GetValid ());          // Valid
			WriteUInt64 (0xc416003301fa00);     // Sorted

			WriteRowCount ();
			WriteTables ();
		}

		void WriteRowCount ()
		{
			for (int i = 0; i < tables.Length; i++) {
				var table = tables [i];
				if (table == null || table.Length == 0)
					continue;

				WriteUInt32 ((uint)table.Length);
			}
		}

		void WriteTables ()
		{
			for (int i = 0; i < tables.Length; i++) {
				var table = tables [i];
				if (table == null || table.Length == 0)
					continue;

				table.Write (this);
			}
		}

		ulong GetValid ()
		{
			ulong valid = 0;

			for (int i = 0; i < tables.Length; i++) {
				var table = tables [i];
				if (table == null || table.Length == 0)
					continue;

				table.Sort ();
				valid |= (1UL << i);
			}

			return valid;
		}

		public void ComputeTableInformations ()
		{
			if (metadata.metadata_builder != null)
				ComputeTableInformations (metadata.metadata_builder.table_heap);

			ComputeTableInformations (metadata.table_heap);
		}

		void ComputeTableInformations (TableHeapBuffer table_heap)
		{
			var tables = table_heap.tables;
			for (int i = 0; i < tables.Length; i++) {
				var table = tables [i];
				if (table != null && table.Length > 0)
					table_infos [i].Length = (uint)table.Length;
			}
		}

		byte GetHeapSizes ()
		{
			byte heap_sizes = 0;

			if (metadata.string_heap.IsLarge) {
				large_string = true;
				heap_sizes |= 0x01;
			}

			if (metadata.guid_heap.IsLarge) {
				large_guid = true;
				heap_sizes |= 0x02;
			}

			if (metadata.blob_heap.IsLarge) {
				large_blob = true;
				heap_sizes |= 0x04;
			}

			return heap_sizes;
		}

		byte GetTableHeapVersion ()
		{
			switch (module.Runtime) {
			case TargetRuntime.Net_1_0:
			case TargetRuntime.Net_1_1:
				return 1;
			default:
				return 2;
			}
		}

		public void FixupData (RVA data_rva)
		{
			var table = GetTable<FieldRVATable> (Table.FieldRVA);
			if (table.length == 0)
				return;

			var field_idx_size = GetTable<FieldTable> (Table.Field).IsLarge ? 4 : 2;
			var previous = this.position;

			base.position = table.position;
			for (int i = 0; i < table.length; i++) {
				var rva = ReadUInt32 ();
				base.position -= 4;
				WriteUInt32 (rva + data_rva);
				base.position += field_idx_size;
			}

			base.position = previous;
		}
	}

	sealed class ResourceBuffer : ByteBuffer {

		public ResourceBuffer ()
			: base (0)
		{
		}

		public uint AddResource (byte [] resource)
		{
			var offset = (uint)this.position;
			WriteInt32 (resource.Length);
			WriteBytes (resource);
			return offset;
		}
	}

	sealed class DataBuffer : ByteBuffer {

		public DataBuffer ()
			: base (0)
		{
		}

		public RVA AddData (byte [] data)
		{
			var rva = (RVA)position;
			WriteBytes (data);
			return rva;
		}
	}

	abstract class HeapBuffer : ByteBuffer {

		public bool IsLarge {
			get { return base.length > 65535; }
		}

		public abstract bool IsEmpty { get; }

		protected HeapBuffer (int length)
			: base (length)
		{
		}
	}

	sealed class GuidHeapBuffer : HeapBuffer {

		readonly Dictionary<Guid, uint> guids = new Dictionary<Guid, uint> ();

		public override bool IsEmpty {
			get { return length == 0; }
		}

		public GuidHeapBuffer ()
			: base (16)
		{
		}

		public uint GetGuidIndex (Guid guid)
		{
			uint index;
			if (guids.TryGetValue (guid, out index))
				return index;

			index = (uint)guids.Count + 1;
			WriteGuid (guid);
			guids.Add (guid, index);
			return index;
		}

		void WriteGuid (Guid guid)
		{
			WriteBytes (guid.ToByteArray ());
		}
	}

	class StringHeapBuffer : HeapBuffer {

		protected Dictionary<string, uint> strings = new Dictionary<string, uint> (StringComparer.Ordinal);

		public sealed override bool IsEmpty {
			get { return length <= 1; }
		}

		public StringHeapBuffer ()
			: base (1)
		{
			WriteByte (0);
		}

		public virtual uint GetStringIndex (string @string)
		{
			uint index;
			if (strings.TryGetValue (@string, out index))
				return index;

			index = (uint)strings.Count + 1;
			strings.Add (@string, index);
			return index;
		}

		public uint [] WriteStrings ()
		{
			var sorted = SortStrings (strings);
			strings = null;

			// Add 1 for empty string whose index and offset are both 0
			var string_offsets = new uint [sorted.Count + 1];
			string_offsets [0] = 0;

			// Find strings that can be folded
			var previous = string.Empty;
			foreach (var entry in sorted) {
				var @string = entry.Key;
				var index = entry.Value;
				var position = base.position;

				if (previous.EndsWith (@string, StringComparison.Ordinal) && !IsLowSurrogateChar (entry.Key [0])) {
					// Map over the tail of prev string. Watch for null-terminator of prev string.
					string_offsets [index] = (uint)(position - (Encoding.UTF8.GetByteCount (entry.Key) + 1));
				} else {
					string_offsets [index] = (uint)position;
					WriteString (@string);
				}

				previous = entry.Key;
			}

			return string_offsets;
		}

		static List<KeyValuePair<string, uint>> SortStrings (Dictionary<string, uint> strings)
		{
			var sorted = new List<KeyValuePair<string, uint>> (strings);
			sorted.Sort (new SuffixSort ());
			return sorted;
		}

		static bool IsLowSurrogateChar (int c)
		{
			return unchecked((uint)(c - 0xDC00)) <= 0xDFFF - 0xDC00;
		}

		protected virtual void WriteString (string @string)
		{
			WriteBytes (Encoding.UTF8.GetBytes (@string));
			WriteByte (0);
		}

		// Sorts strings such that a string is followed immediately by all strings
		// that are a suffix of it.  
		private class SuffixSort : IComparer<KeyValuePair<string, uint>> {

			public int Compare (KeyValuePair<string, uint> xPair, KeyValuePair<string, uint> yPair)
			{
				var x = xPair.Key;
				var y = yPair.Key;

				for (int i = x.Length - 1, j = y.Length - 1; i >= 0 & j >= 0; i--, j--) {
					if (x [i] < y [j]) {
						return -1;
					}

					if (x [i] > y [j]) {
						return +1;
					}
				}

				return y.Length.CompareTo (x.Length);
			}
		}
	}

	sealed class BlobHeapBuffer : HeapBuffer {

		readonly Dictionary<ByteBuffer, uint> blobs = new Dictionary<ByteBuffer, uint> (new ByteBufferEqualityComparer ());

		public override bool IsEmpty {
			get { return length <= 1; }
		}

		public BlobHeapBuffer ()
			: base (1)
		{
			WriteByte (0);
		}

		public uint GetBlobIndex (ByteBuffer blob)
		{
			uint index;
			if (blobs.TryGetValue (blob, out index))
				return index;

			index = (uint)base.position;
			WriteBlob (blob);
			blobs.Add (blob, index);
			return index;
		}

		void WriteBlob (ByteBuffer blob)
		{
			WriteCompressedUInt32 ((uint)blob.length);
			WriteBytes (blob);
		}
	}

	sealed class UserStringHeapBuffer : StringHeapBuffer {

		public override uint GetStringIndex (string @string)
		{
			uint index;
			if (strings.TryGetValue (@string, out index))
				return index;

			index = (uint)base.position;
			WriteString (@string);
			strings.Add (@string, index);
			return index;
		}

		protected override void WriteString (string @string)
		{
			WriteCompressedUInt32 ((uint)@string.Length * 2 + 1);

			byte special = 0;

			for (int i = 0; i < @string.Length; i++) {
				var @char = @string [i];
				WriteUInt16 (@char);

				if (special == 1)
					continue;

				if (@char < 0x20 || @char > 0x7e) {
					if (@char > 0x7e
						|| (@char >= 0x01 && @char <= 0x08)
						|| (@char >= 0x0e && @char <= 0x1f)
						|| @char == 0x27
						|| @char == 0x2d) {

						special = 1;
					}
				}
			}

			WriteByte (special);
		}
	}

	sealed class PdbHeapBuffer : HeapBuffer {

		public override bool IsEmpty {
			get { return false; }
		}

		public PdbHeapBuffer ()
			: base (0)
		{
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/CodedIndex.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Metadata {

	enum CodedIndex {
		TypeDefOrRef,
		HasConstant,
		HasCustomAttribute,
		HasFieldMarshal,
		HasDeclSecurity,
		MemberRefParent,
		HasSemantics,
		MethodDefOrRef,
		MemberForwarded,
		Implementation,
		CustomAttributeType,
		ResolutionScope,
		TypeOrMethodDef,
		HasCustomDebugInformation,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/ElementType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Metadata {

	enum ElementType : byte {
		None = 0x00,
		Void = 0x01,
		Boolean = 0x02,
		Char = 0x03,
		I1 = 0x04,
		U1 = 0x05,
		I2 = 0x06,
		U2 = 0x07,
		I4 = 0x08,
		U4 = 0x09,
		I8 = 0x0a,
		U8 = 0x0b,
		R4 = 0x0c,
		R8 = 0x0d,
		String = 0x0e,
		Ptr = 0x0f,   // Followed by <type> token
		ByRef = 0x10,   // Followed by <type> token
		ValueType = 0x11,   // Followed by <type> token
		Class = 0x12,   // Followed by <type> token
		Var = 0x13,   // Followed by generic parameter number
		Array = 0x14,   // <type> <rank> <boundsCount> <bound1>  <loCount> <lo1>
		GenericInst = 0x15,   // <type> <type-arg-count> <type-1> ... <type-n> */
		TypedByRef = 0x16,
		I = 0x18,   // System.IntPtr
		U = 0x19,   // System.UIntPtr
		FnPtr = 0x1b,   // Followed by full method signature
		Object = 0x1c,   // System.Object
		SzArray = 0x1d,   // Single-dim array with 0 lower bound
		MVar = 0x1e,   // Followed by generic parameter number
		CModReqD = 0x1f,   // Required modifier : followed by a TypeDef or TypeRef token
		CModOpt = 0x20,   // Optional modifier : followed by a TypeDef or TypeRef token
		Internal = 0x21,   // Implemented within the CLI
		Modifier = 0x40,   // Or'd with following element types
		Sentinel = 0x41,   // Sentinel for varargs method signature
		Pinned = 0x45,   // Denotes a local variable that points at a pinned object

		// special undocumented constants
		Type = 0x50,
		Boxed = 0x51,
		Enum = 0x55
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/GuidHeap.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil.Metadata {

	sealed class GuidHeap : Heap {

		public GuidHeap (byte [] data)
			: base (data)
		{
		}

		public Guid Read (uint index)
		{
			const int guid_size = 16;

			if (index == 0 || ((index - 1) + guid_size) > data.Length)
				return new Guid ();

			var buffer = new byte [guid_size];

			Buffer.BlockCopy (this.data, (int)((index - 1) * guid_size), buffer, 0, guid_size);

			return new Guid (buffer);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/Heap.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Metadata {

	abstract class Heap {

		public int IndexSize;

		readonly internal byte [] data;

		protected Heap (byte [] data)
		{
			this.data = data;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/MetadataToken.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	public struct MetadataToken : IEquatable<MetadataToken> {

		readonly uint token;

		public uint RID {
			get { return token & 0x00ffffff; }
		}

		public TokenType TokenType {
			get { return (TokenType)(token & 0xff000000); }
		}

		public static readonly MetadataToken Zero = new MetadataToken ((uint)0);

		public MetadataToken (uint token)
		{
			this.token = token;
		}

		public MetadataToken (TokenType type)
			: this (type, 0)
		{
		}

		public MetadataToken (TokenType type, uint rid)
		{
			token = (uint)type | rid;
		}

		public MetadataToken (TokenType type, int rid)
		{
			token = (uint)type | (uint)rid;
		}

		public int ToInt32 ()
		{
			return (int)token;
		}

		public uint ToUInt32 ()
		{
			return token;
		}

		public override int GetHashCode ()
		{
			return (int)token;
		}

		public bool Equals (MetadataToken other)
		{
			return other.token == token;
		}

		public override bool Equals (object obj)
		{
			if (obj is MetadataToken) {
				var other = (MetadataToken)obj;
				return other.token == token;
			}

			return false;
		}

		public static bool operator == (MetadataToken one, MetadataToken other)
		{
			return one.token == other.token;
		}

		public static bool operator != (MetadataToken one, MetadataToken other)
		{
			return one.token != other.token;
		}

		public override string ToString ()
		{
			return string.Format ("[{0}:0x{1}]", TokenType, RID.ToString ("x4"));
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/PdbHeap.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using RID = System.UInt32;

namespace MonoFN.Cecil.Metadata {

	sealed class PdbHeap : Heap {

		public byte [] Id;
		public RID EntryPoint;
		public long TypeSystemTables;
		public uint [] TypeSystemTableRows;

		public PdbHeap (byte [] data)
			: base (data)
		{
		}

		public bool HasTable (Table table)
		{
			return (TypeSystemTables & (1L << (int)table)) != 0;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/Row.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System.Collections.Generic;

namespace MonoFN.Cecil.Metadata {

	struct Row<T1, T2> {
		internal T1 Col1;
		internal T2 Col2;

		public Row (T1 col1, T2 col2)
		{
			Col1 = col1;
			Col2 = col2;
		}
	}

	struct Row<T1, T2, T3> {
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;

		public Row (T1 col1, T2 col2, T3 col3)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
		}
	}

	struct Row<T1, T2, T3, T4> {
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;
		internal T4 Col4;

		public Row (T1 col1, T2 col2, T3 col3, T4 col4)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
		}
	}

	struct Row<T1, T2, T3, T4, T5> {
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;
		internal T4 Col4;
		internal T5 Col5;

		public Row (T1 col1, T2 col2, T3 col3, T4 col4, T5 col5)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
		}
	}

	struct Row<T1, T2, T3, T4, T5, T6> {
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;
		internal T4 Col4;
		internal T5 Col5;
		internal T6 Col6;

		public Row (T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
			Col6 = col6;
		}
	}

	struct Row<T1, T2, T3, T4, T5, T6, T7, T8, T9> {
		internal T1 Col1;
		internal T2 Col2;
		internal T3 Col3;
		internal T4 Col4;
		internal T5 Col5;
		internal T6 Col6;
		internal T7 Col7;
		internal T8 Col8;
		internal T9 Col9;

		public Row (T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
			Col6 = col6;
			Col7 = col7;
			Col8 = col8;
			Col9 = col9;
		}
	}

	sealed class RowEqualityComparer : IEqualityComparer<Row<string, string>>, IEqualityComparer<Row<uint, uint>>, IEqualityComparer<Row<uint, uint, uint>> {

		public bool Equals (Row<string, string> x, Row<string, string> y)
		{
			return x.Col1 == y.Col1
				&& x.Col2 == y.Col2;
		}

		public int GetHashCode (Row<string, string> obj)
		{
			string x = obj.Col1, y = obj.Col2;
			return (x != null ? x.GetHashCode () : 0) ^ (y != null ? y.GetHashCode () : 0);
		}

		public bool Equals (Row<uint, uint> x, Row<uint, uint> y)
		{
			return x.Col1 == y.Col1
				&& x.Col2 == y.Col2;
		}

		public int GetHashCode (Row<uint, uint> obj)
		{
			return (int)(obj.Col1 ^ obj.Col2);
		}

		public bool Equals (Row<uint, uint, uint> x, Row<uint, uint, uint> y)
		{
			return x.Col1 == y.Col1
				&& x.Col2 == y.Col2
				&& x.Col3 == y.Col3;
		}

		public int GetHashCode (Row<uint, uint, uint> obj)
		{
			return (int)(obj.Col1 ^ obj.Col2 ^ obj.Col3);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/StringHeap.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System.Collections.Generic;
using System.Text;

namespace MonoFN.Cecil.Metadata {

	class StringHeap : Heap {

		readonly Dictionary<uint, string> strings = new Dictionary<uint, string> ();

		public StringHeap (byte [] data)
			: base (data)
		{
		}

		public string Read (uint index)
		{
			if (index == 0)
				return string.Empty;

			string @string;
			if (strings.TryGetValue (index, out @string))
				return @string;

			if (index > data.Length - 1)
				return string.Empty;

			@string = ReadStringAt (index);
			if (@string.Length != 0)
				strings.Add (index, @string);

			return @string;
		}

		protected virtual string ReadStringAt (uint index)
		{
			int length = 0;
			int start = (int)index;

			for (int i = start; ; i++) {
				if (data [i] == 0)
					break;

				length++;
			}

			return Encoding.UTF8.GetString (data, start, length);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/TableHeap.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Metadata {

	enum Table : byte {
		Module = 0x00,
		TypeRef = 0x01,
		TypeDef = 0x02,
		FieldPtr = 0x03,
		Field = 0x04,
		MethodPtr = 0x05,
		Method = 0x06,
		ParamPtr = 0x07,
		Param = 0x08,
		InterfaceImpl = 0x09,
		MemberRef = 0x0a,
		Constant = 0x0b,
		CustomAttribute = 0x0c,
		FieldMarshal = 0x0d,
		DeclSecurity = 0x0e,
		ClassLayout = 0x0f,
		FieldLayout = 0x10,
		StandAloneSig = 0x11,
		EventMap = 0x12,
		EventPtr = 0x13,
		Event = 0x14,
		PropertyMap = 0x15,
		PropertyPtr = 0x16,
		Property = 0x17,
		MethodSemantics = 0x18,
		MethodImpl = 0x19,
		ModuleRef = 0x1a,
		TypeSpec = 0x1b,
		ImplMap = 0x1c,
		FieldRVA = 0x1d,
		EncLog = 0x1e,
		EncMap = 0x1f,
		Assembly = 0x20,
		AssemblyProcessor = 0x21,
		AssemblyOS = 0x22,
		AssemblyRef = 0x23,
		AssemblyRefProcessor = 0x24,
		AssemblyRefOS = 0x25,
		File = 0x26,
		ExportedType = 0x27,
		ManifestResource = 0x28,
		NestedClass = 0x29,
		GenericParam = 0x2a,
		MethodSpec = 0x2b,
		GenericParamConstraint = 0x2c,

		Document = 0x30,
		MethodDebugInformation = 0x31,
		LocalScope = 0x32,
		LocalVariable = 0x33,
		LocalConstant = 0x34,
		ImportScope = 0x35,
		StateMachineMethod = 0x36,
		CustomDebugInformation = 0x37,
	}

	struct TableInformation {
		public uint Offset;
		public uint Length;
		public uint RowSize;

		public bool IsLarge {
			get { return Length > ushort.MaxValue; }
		}
	}

	sealed class TableHeap : Heap {

		public long Valid;
		public long Sorted;

		public readonly TableInformation [] Tables = new TableInformation [Mixin.TableCount];

		public TableInformation this [Table table] {
			get { return Tables [(int)table]; }
		}

		public TableHeap (byte [] data)
			: base (data)
		{
		}

		public bool HasTable (Table table)
		{
			return (Valid & (1L << (int)table)) != 0;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/TokenType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public enum TokenType : uint {
		Module = 0x00000000,
		TypeRef = 0x01000000,
		TypeDef = 0x02000000,
		Field = 0x04000000,
		Method = 0x06000000,
		Param = 0x08000000,
		InterfaceImpl = 0x09000000,
		MemberRef = 0x0a000000,
		CustomAttribute = 0x0c000000,
		Permission = 0x0e000000,
		Signature = 0x11000000,
		Event = 0x14000000,
		Property = 0x17000000,
		ModuleRef = 0x1a000000,
		TypeSpec = 0x1b000000,
		Assembly = 0x20000000,
		AssemblyRef = 0x23000000,
		File = 0x26000000,
		ExportedType = 0x27000000,
		ManifestResource = 0x28000000,
		GenericParam = 0x2a000000,
		MethodSpec = 0x2b000000,
		GenericParamConstraint = 0x2c000000,

		Document = 0x30000000,
		MethodDebugInformation = 0x31000000,
		LocalScope = 0x32000000,
		LocalVariable = 0x33000000,
		LocalConstant = 0x34000000,
		ImportScope = 0x35000000,
		StateMachineMethod = 0x36000000,
		CustomDebugInformation = 0x37000000,

		String = 0x70000000,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/UserStringHeap.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil.Metadata {

	sealed class UserStringHeap : StringHeap {

		public UserStringHeap (byte [] data)
			: base (data)
		{
		}

		protected override string ReadStringAt (uint index)
		{
			int start = (int)index;

			uint length = (uint)(data.ReadCompressedUInt32 (ref start) & ~1);
			if (length < 1)
				return string.Empty;

			var chars = new char [length / 2];

			for (int i = start, j = 0; i < start + length; i += 2)
				chars [j++] = (char)(data [i] | (data [i + 1] << 8));

			return new string (chars);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.Metadata/Utilities.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using System;

namespace MonoFN.Cecil {

	static partial class Mixin {

		public const int TableCount = 58;
		public const int CodedIndexCount = 14;

		public static uint ReadCompressedUInt32 (this byte [] data, ref int position)
		{
			uint integer;
			if ((data [position] & 0x80) == 0) {
				integer = data [position];
				position++;
			} else if ((data [position] & 0x40) == 0) {
				integer = (uint)(data [position] & ~0x80) << 8;
				integer |= data [position + 1];
				position += 2;
			} else {
				integer = (uint)(data [position] & ~0xc0) << 24;
				integer |= (uint)data [position + 1] << 16;
				integer |= (uint)data [position + 2] << 8;
				integer |= (uint)data [position + 3];
				position += 4;
			}
			return integer;
		}

		public static MetadataToken GetMetadataToken (this CodedIndex self, uint data)
		{
			uint rid;
			TokenType token_type;
			switch (self) {
			case CodedIndex.TypeDefOrRef:
				rid = data >> 2;
				switch (data & 3) {
				case 0:
					token_type = TokenType.TypeDef; goto ret;
				case 1:
					token_type = TokenType.TypeRef; goto ret;
				case 2:
					token_type = TokenType.TypeSpec; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.HasConstant:
				rid = data >> 2;
				switch (data & 3) {
				case 0:
					token_type = TokenType.Field; goto ret;
				case 1:
					token_type = TokenType.Param; goto ret;
				case 2:
					token_type = TokenType.Property; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.HasCustomAttribute:
				rid = data >> 5;
				switch (data & 31) {
				case 0:
					token_type = TokenType.Method; goto ret;
				case 1:
					token_type = TokenType.Field; goto ret;
				case 2:
					token_type = TokenType.TypeRef; goto ret;
				case 3:
					token_type = TokenType.TypeDef; goto ret;
				case 4:
					token_type = TokenType.Param; goto ret;
				case 5:
					token_type = TokenType.InterfaceImpl; goto ret;
				case 6:
					token_type = TokenType.MemberRef; goto ret;
				case 7:
					token_type = TokenType.Module; goto ret;
				case 8:
					token_type = TokenType.Permission; goto ret;
				case 9:
					token_type = TokenType.Property; goto ret;
				case 10:
					token_type = TokenType.Event; goto ret;
				case 11:
					token_type = TokenType.Signature; goto ret;
				case 12:
					token_type = TokenType.ModuleRef; goto ret;
				case 13:
					token_type = TokenType.TypeSpec; goto ret;
				case 14:
					token_type = TokenType.Assembly; goto ret;
				case 15:
					token_type = TokenType.AssemblyRef; goto ret;
				case 16:
					token_type = TokenType.File; goto ret;
				case 17:
					token_type = TokenType.ExportedType; goto ret;
				case 18:
					token_type = TokenType.ManifestResource; goto ret;
				case 19:
					token_type = TokenType.GenericParam; goto ret;
				case 20:
					token_type = TokenType.GenericParamConstraint; goto ret;
				case 21:
					token_type = TokenType.MethodSpec; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.HasFieldMarshal:
				rid = data >> 1;
				switch (data & 1) {
				case 0:
					token_type = TokenType.Field; goto ret;
				case 1:
					token_type = TokenType.Param; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.HasDeclSecurity:
				rid = data >> 2;
				switch (data & 3) {
				case 0:
					token_type = TokenType.TypeDef; goto ret;
				case 1:
					token_type = TokenType.Method; goto ret;
				case 2:
					token_type = TokenType.Assembly; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.MemberRefParent:
				rid = data >> 3;
				switch (data & 7) {
				case 0:
					token_type = TokenType.TypeDef; goto ret;
				case 1:
					token_type = TokenType.TypeRef; goto ret;
				case 2:
					token_type = TokenType.ModuleRef; goto ret;
				case 3:
					token_type = TokenType.Method; goto ret;
				case 4:
					token_type = TokenType.TypeSpec; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.HasSemantics:
				rid = data >> 1;
				switch (data & 1) {
				case 0:
					token_type = TokenType.Event; goto ret;
				case 1:
					token_type = TokenType.Property; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.MethodDefOrRef:
				rid = data >> 1;
				switch (data & 1) {
				case 0:
					token_type = TokenType.Method; goto ret;
				case 1:
					token_type = TokenType.MemberRef; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.MemberForwarded:
				rid = data >> 1;
				switch (data & 1) {
				case 0:
					token_type = TokenType.Field; goto ret;
				case 1:
					token_type = TokenType.Method; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.Implementation:
				rid = data >> 2;
				switch (data & 3) {
				case 0:
					token_type = TokenType.File; goto ret;
				case 1:
					token_type = TokenType.AssemblyRef; goto ret;
				case 2:
					token_type = TokenType.ExportedType; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.CustomAttributeType:
				rid = data >> 3;
				switch (data & 7) {
				case 2:
					token_type = TokenType.Method; goto ret;
				case 3:
					token_type = TokenType.MemberRef; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.ResolutionScope:
				rid = data >> 2;
				switch (data & 3) {
				case 0:
					token_type = TokenType.Module; goto ret;
				case 1:
					token_type = TokenType.ModuleRef; goto ret;
				case 2:
					token_type = TokenType.AssemblyRef; goto ret;
				case 3:
					token_type = TokenType.TypeRef; goto ret;
				default:
					goto exit;
				}
			case CodedIndex.TypeOrMethodDef:
				rid = data >> 1;
				switch (data & 1) {
				case 0:
					token_type = TokenType.TypeDef; goto ret;
				case 1:
					token_type = TokenType.Method; goto ret;
				default: goto exit;
				}
			case CodedIndex.HasCustomDebugInformation:
				rid = data >> 5;
				switch (data & 31) {
				case 0:
					token_type = TokenType.Method; goto ret;
				case 1:
					token_type = TokenType.Field; goto ret;
				case 2:
					token_type = TokenType.TypeRef; goto ret;
				case 3:
					token_type = TokenType.TypeDef; goto ret;
				case 4:
					token_type = TokenType.Param; goto ret;
				case 5:
					token_type = TokenType.InterfaceImpl; goto ret;
				case 6:
					token_type = TokenType.MemberRef; goto ret;
				case 7:
					token_type = TokenType.Module; goto ret;
				case 8:
					token_type = TokenType.Permission; goto ret;
				case 9:
					token_type = TokenType.Property; goto ret;
				case 10:
					token_type = TokenType.Event; goto ret;
				case 11:
					token_type = TokenType.Signature; goto ret;
				case 12:
					token_type = TokenType.ModuleRef; goto ret;
				case 13:
					token_type = TokenType.TypeSpec; goto ret;
				case 14:
					token_type = TokenType.Assembly; goto ret;
				case 15:
					token_type = TokenType.AssemblyRef; goto ret;
				case 16:
					token_type = TokenType.File; goto ret;
				case 17:
					token_type = TokenType.ExportedType; goto ret;
				case 18:
					token_type = TokenType.ManifestResource; goto ret;
				case 19:
					token_type = TokenType.GenericParam; goto ret;
				case 20:
					token_type = TokenType.GenericParamConstraint; goto ret;
				case 21:
					token_type = TokenType.MethodSpec; goto ret;
				case 22:
					token_type = TokenType.Document; goto ret;
				case 23:
					token_type = TokenType.LocalScope; goto ret;
				case 24:
					token_type = TokenType.LocalVariable; goto ret;
				case 25:
					token_type = TokenType.LocalConstant; goto ret;
				case 26:
					token_type = TokenType.ImportScope; goto ret;
				default:
					goto exit;
				}
			default:
				goto exit;
			}
		ret:
			return new MetadataToken (token_type, rid);
		exit:
			return MetadataToken.Zero;
		}

		public static uint CompressMetadataToken (this CodedIndex self, MetadataToken token)
		{
			uint ret = 0;
			if (token.RID == 0)
				return ret;
			switch (self) {
			case CodedIndex.TypeDefOrRef:
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.TypeDef:
					return ret | 0;
				case TokenType.TypeRef:
					return ret | 1;
				case TokenType.TypeSpec:
					return ret | 2;
				default:
					goto exit;
				}
			case CodedIndex.HasConstant:
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.Field:
					return ret | 0;
				case TokenType.Param:
					return ret | 1;
				case TokenType.Property:
					return ret | 2;
				default:
					goto exit;
				}
			case CodedIndex.HasCustomAttribute:
				ret = token.RID << 5;
				switch (token.TokenType) {
				case TokenType.Method:
					return ret | 0;
				case TokenType.Field:
					return ret | 1;
				case TokenType.TypeRef:
					return ret | 2;
				case TokenType.TypeDef:
					return ret | 3;
				case TokenType.Param:
					return ret | 4;
				case TokenType.InterfaceImpl:
					return ret | 5;
				case TokenType.MemberRef:
					return ret | 6;
				case TokenType.Module:
					return ret | 7;
				case TokenType.Permission:
					return ret | 8;
				case TokenType.Property:
					return ret | 9;
				case TokenType.Event:
					return ret | 10;
				case TokenType.Signature:
					return ret | 11;
				case TokenType.ModuleRef:
					return ret | 12;
				case TokenType.TypeSpec:
					return ret | 13;
				case TokenType.Assembly:
					return ret | 14;
				case TokenType.AssemblyRef:
					return ret | 15;
				case TokenType.File:
					return ret | 16;
				case TokenType.ExportedType:
					return ret | 17;
				case TokenType.ManifestResource:
					return ret | 18;
				case TokenType.GenericParam:
					return ret | 19;
				case TokenType.GenericParamConstraint:
					return ret | 20;
				case TokenType.MethodSpec:
					return ret | 21;
				default:
					goto exit;
				}
			case CodedIndex.HasFieldMarshal:
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.Field:
					return ret | 0;
				case TokenType.Param:
					return ret | 1;
				default:
					goto exit;
				}
			case CodedIndex.HasDeclSecurity:
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.TypeDef:
					return ret | 0;
				case TokenType.Method:
					return ret | 1;
				case TokenType.Assembly:
					return ret | 2;
				default:
					goto exit;
				}
			case CodedIndex.MemberRefParent:
				ret = token.RID << 3;
				switch (token.TokenType) {
				case TokenType.TypeDef:
					return ret | 0;
				case TokenType.TypeRef:
					return ret | 1;
				case TokenType.ModuleRef:
					return ret | 2;
				case TokenType.Method:
					return ret | 3;
				case TokenType.TypeSpec:
					return ret | 4;
				default:
					goto exit;
				}
			case CodedIndex.HasSemantics:
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.Event:
					return ret | 0;
				case TokenType.Property:
					return ret | 1;
				default:
					goto exit;
				}
			case CodedIndex.MethodDefOrRef:
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.Method:
					return ret | 0;
				case TokenType.MemberRef:
					return ret | 1;
				default:
					goto exit;
				}
			case CodedIndex.MemberForwarded:
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.Field:
					return ret | 0;
				case TokenType.Method:
					return ret | 1;
				default:
					goto exit;
				}
			case CodedIndex.Implementation:
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.File:
					return ret | 0;
				case TokenType.AssemblyRef:
					return ret | 1;
				case TokenType.ExportedType:
					return ret | 2;
				default:
					goto exit;
				}
			case CodedIndex.CustomAttributeType:
				ret = token.RID << 3;
				switch (token.TokenType) {
				case TokenType.Method:
					return ret | 2;
				case TokenType.MemberRef:
					return ret | 3;
				default:
					goto exit;
				}
			case CodedIndex.ResolutionScope:
				ret = token.RID << 2;
				switch (token.TokenType) {
				case TokenType.Module:
					return ret | 0;
				case TokenType.ModuleRef:
					return ret | 1;
				case TokenType.AssemblyRef:
					return ret | 2;
				case TokenType.TypeRef:
					return ret | 3;
				default:
					goto exit;
				}
			case CodedIndex.TypeOrMethodDef:
				ret = token.RID << 1;
				switch (token.TokenType) {
				case TokenType.TypeDef:
					return ret | 0;
				case TokenType.Method:
					return ret | 1;
				default:
					goto exit;
				}
			case CodedIndex.HasCustomDebugInformation:
				ret = token.RID << 5;
				switch (token.TokenType) {
				case TokenType.Method:
					return ret | 0;
				case TokenType.Field:
					return ret | 1;
				case TokenType.TypeRef:
					return ret | 2;
				case TokenType.TypeDef:
					return ret | 3;
				case TokenType.Param:
					return ret | 4;
				case TokenType.InterfaceImpl:
					return ret | 5;
				case TokenType.MemberRef:
					return ret | 6;
				case TokenType.Module:
					return ret | 7;
				case TokenType.Permission:
					return ret | 8;
				case TokenType.Property:
					return ret | 9;
				case TokenType.Event:
					return ret | 10;
				case TokenType.Signature:
					return ret | 11;
				case TokenType.ModuleRef:
					return ret | 12;
				case TokenType.TypeSpec:
					return ret | 13;
				case TokenType.Assembly:
					return ret | 14;
				case TokenType.AssemblyRef:
					return ret | 15;
				case TokenType.File:
					return ret | 16;
				case TokenType.ExportedType:
					return ret | 17;
				case TokenType.ManifestResource:
					return ret | 18;
				case TokenType.GenericParam:
					return ret | 19;
				case TokenType.GenericParamConstraint:
					return ret | 20;
				case TokenType.MethodSpec:
					return ret | 21;
				case TokenType.Document:
					return ret | 22;
				case TokenType.LocalScope:
					return ret | 23;
				case TokenType.LocalVariable:
					return ret | 24;
				case TokenType.LocalConstant:
					return ret | 25;
				case TokenType.ImportScope:
					return ret | 26;
				default:
					goto exit;
				}
			default:
				goto exit;
			}
		exit:
			throw new ArgumentException ();
		}

		public static int GetSize (this CodedIndex self, Func<Table, int> counter)
		{
			int bits;
			Table [] tables;

			switch (self) {
			case CodedIndex.TypeDefOrRef:
				bits = 2;
				tables = new [] { Table.TypeDef, Table.TypeRef, Table.TypeSpec };
				break;
			case CodedIndex.HasConstant:
				bits = 2;
				tables = new [] { Table.Field, Table.Param, Table.Property };
				break;
			case CodedIndex.HasCustomAttribute:
				bits = 5;
				tables = new [] {
					Table.Method, Table.Field, Table.TypeRef, Table.TypeDef, Table.Param, Table.InterfaceImpl, Table.MemberRef,
					Table.Module, Table.DeclSecurity, Table.Property, Table.Event, Table.StandAloneSig, Table.ModuleRef,
					Table.TypeSpec, Table.Assembly, Table.AssemblyRef, Table.File, Table.ExportedType,
					Table.ManifestResource, Table.GenericParam, Table.GenericParamConstraint, Table.MethodSpec,
				};
				break;
			case CodedIndex.HasFieldMarshal:
				bits = 1;
				tables = new [] { Table.Field, Table.Param };
				break;
			case CodedIndex.HasDeclSecurity:
				bits = 2;
				tables = new [] { Table.TypeDef, Table.Method, Table.Assembly };
				break;
			case CodedIndex.MemberRefParent:
				bits = 3;
				tables = new [] { Table.TypeDef, Table.TypeRef, Table.ModuleRef, Table.Method, Table.TypeSpec };
				break;
			case CodedIndex.HasSemantics:
				bits = 1;
				tables = new [] { Table.Event, Table.Property };
				break;
			case CodedIndex.MethodDefOrRef:
				bits = 1;
				tables = new [] { Table.Method, Table.MemberRef };
				break;
			case CodedIndex.MemberForwarded:
				bits = 1;
				tables = new [] { Table.Field, Table.Method };
				break;
			case CodedIndex.Implementation:
				bits = 2;
				tables = new [] { Table.File, Table.AssemblyRef, Table.ExportedType };
				break;
			case CodedIndex.CustomAttributeType:
				bits = 3;
				tables = new [] { Table.Method, Table.MemberRef };
				break;
			case CodedIndex.ResolutionScope:
				bits = 2;
				tables = new [] { Table.Module, Table.ModuleRef, Table.AssemblyRef, Table.TypeRef };
				break;
			case CodedIndex.TypeOrMethodDef:
				bits = 1;
				tables = new [] { Table.TypeDef, Table.Method };
				break;
			case CodedIndex.HasCustomDebugInformation:
				bits = 5;
				tables = new [] {
					Table.Method, Table.Field, Table.TypeRef, Table.TypeDef, Table.Param, Table.InterfaceImpl, Table.MemberRef,
					Table.Module, Table.DeclSecurity, Table.Property, Table.Event, Table.StandAloneSig, Table.ModuleRef,
					Table.TypeSpec, Table.Assembly, Table.AssemblyRef, Table.File, Table.ExportedType,
					Table.ManifestResource, Table.GenericParam, Table.GenericParamConstraint, Table.MethodSpec,
					Table.Document, Table.LocalScope, Table.LocalVariable, Table.LocalConstant, Table.ImportScope,
				};
				break;
			default:
				throw new ArgumentException ();
			}

			int max = 0;

			for (int i = 0; i < tables.Length; i++) {
				max = System.Math.Max (counter (tables [i]), max);
			}

			return max < (1 << (16 - bits)) ? 2 : 4;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/BinaryStreamReader.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System.IO;

namespace MonoFN.Cecil.PE {

	class BinaryStreamReader : BinaryReader {

		public int Position {
			get { return (int)BaseStream.Position; }
			set { BaseStream.Position = value; }
		}

		public int Length {
			get { return (int)BaseStream.Length; }
		}

		public BinaryStreamReader (Stream stream)
			: base (stream)
		{
		}

		public void Advance (int bytes)
		{
			BaseStream.Seek (bytes, SeekOrigin.Current);
		}

		public void MoveTo (uint position)
		{
			BaseStream.Seek (position, SeekOrigin.Begin);
		}

		public void Align (int align)
		{
			align--;
			var position = Position;
			Advance (((position + align) & ~align) - position);
		}

		public DataDirectory ReadDataDirectory ()
		{
			return new DataDirectory (ReadUInt32 (), ReadUInt32 ());
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/BinaryStreamWriter.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System.IO;

namespace MonoFN.Cecil.PE {

	class BinaryStreamWriter : BinaryWriter {

		public int Position {
			get { return (int)BaseStream.Position; }
			set { BaseStream.Position = value; }
		}

		public BinaryStreamWriter (Stream stream)
			: base (stream)
		{
		}

		public void WriteByte (byte value)
		{
			Write (value);
		}

		public void WriteUInt16 (ushort value)
		{
			Write (value);
		}

		public void WriteInt16 (short value)
		{
			Write (value);
		}

		public void WriteUInt32 (uint value)
		{
			Write (value);
		}

		public void WriteInt32 (int value)
		{
			Write (value);
		}

		public void WriteUInt64 (ulong value)
		{
			Write (value);
		}

		public void WriteBytes (byte [] bytes)
		{
			Write (bytes);
		}

		public void WriteDataDirectory (DataDirectory directory)
		{
			Write (directory.VirtualAddress);
			Write (directory.Size);
		}

		public void WriteBuffer (ByteBuffer buffer)
		{
			Write (buffer.buffer, 0, buffer.length);
		}

		protected void Advance (int bytes)
		{
			BaseStream.Seek (bytes, SeekOrigin.Current);
		}

		public void Align (int align)
		{
			align--;
			var position = Position;
			var bytes = ((position + align) & ~align) - position;

			for (int i = 0; i < bytes; i++)
				WriteByte (0);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/ByteBuffer.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil.PE {

	class ByteBuffer {

		internal byte [] buffer;
		internal int length;
		internal int position;

		public ByteBuffer ()
		{
			this.buffer = Empty<byte>.Array;
		}

		public ByteBuffer (int length)
		{
			this.buffer = new byte [length];
		}

		public ByteBuffer (byte [] buffer)
		{
			this.buffer = buffer ?? Empty<byte>.Array;
			this.length = this.buffer.Length;
		}

		public void Advance (int length)
		{
			position += length;
		}

		public byte ReadByte ()
		{
			return buffer [position++];
		}

		public sbyte ReadSByte ()
		{
			return (sbyte)ReadByte ();
		}

		public byte [] ReadBytes (int length)
		{
			var bytes = new byte [length];
			Buffer.BlockCopy (buffer, position, bytes, 0, length);
			position += length;
			return bytes;
		}

		public ushort ReadUInt16 ()
		{
			ushort value = (ushort)(buffer [position]
				| (buffer [position + 1] << 8));
			position += 2;
			return value;
		}

		public short ReadInt16 ()
		{
			return (short)ReadUInt16 ();
		}

		public uint ReadUInt32 ()
		{
			uint value = (uint)(buffer [position]
				| (buffer [position + 1] << 8)
				| (buffer [position + 2] << 16)
				| (buffer [position + 3] << 24));
			position += 4;
			return value;
		}

		public int ReadInt32 ()
		{
			return (int)ReadUInt32 ();
		}

		public ulong ReadUInt64 ()
		{
			uint low = ReadUInt32 ();
			uint high = ReadUInt32 ();

			return (((ulong)high) << 32) | low;
		}

		public long ReadInt64 ()
		{
			return (long)ReadUInt64 ();
		}

		public uint ReadCompressedUInt32 ()
		{
			byte first = ReadByte ();
			if ((first & 0x80) == 0)
				return first;

			if ((first & 0x40) == 0)
				return ((uint)(first & ~0x80) << 8)
					| ReadByte ();

			return ((uint)(first & ~0xc0) << 24)
				| (uint)ReadByte () << 16
				| (uint)ReadByte () << 8
				| ReadByte ();
		}

		public int ReadCompressedInt32 ()
		{
			var b = buffer [position];
			var u = (int)ReadCompressedUInt32 ();
			var v = u >> 1;
			if ((u & 1) == 0)
				return v;

			switch (b & 0xc0) {
			case 0:
			case 0x40:
				return v - 0x40;
			case 0x80:
				return v - 0x2000;
			default:
				return v - 0x10000000;
			}
		}

		public float ReadSingle ()
		{
			if (!BitConverter.IsLittleEndian) {
				var bytes = ReadBytes (4);
				Array.Reverse (bytes);
				return BitConverter.ToSingle (bytes, 0);
			}

			float value = BitConverter.ToSingle (buffer, position);
			position += 4;
			return value;
		}

		public double ReadDouble ()
		{
			if (!BitConverter.IsLittleEndian) {
				var bytes = ReadBytes (8);
				Array.Reverse (bytes);
				return BitConverter.ToDouble (bytes, 0);
			}

			double value = BitConverter.ToDouble (buffer, position);
			position += 8;
			return value;
		}

		public void WriteByte (byte value)
		{
			if (position == buffer.Length)
				Grow (1);

			buffer [position++] = value;

			if (position > length)
				length = position;
		}

		public void WriteSByte (sbyte value)
		{
			WriteByte ((byte)value);
		}

		public void WriteUInt16 (ushort value)
		{
			if (position + 2 > buffer.Length)
				Grow (2);

			buffer [position++] = (byte)value;
			buffer [position++] = (byte)(value >> 8);

			if (position > length)
				length = position;
		}

		public void WriteInt16 (short value)
		{
			WriteUInt16 ((ushort)value);
		}

		public void WriteUInt32 (uint value)
		{
			if (position + 4 > buffer.Length)
				Grow (4);

			buffer [position++] = (byte)value;
			buffer [position++] = (byte)(value >> 8);
			buffer [position++] = (byte)(value >> 16);
			buffer [position++] = (byte)(value >> 24);

			if (position > length)
				length = position;
		}

		public void WriteInt32 (int value)
		{
			WriteUInt32 ((uint)value);
		}

		public void WriteUInt64 (ulong value)
		{
			if (position + 8 > buffer.Length)
				Grow (8);

			buffer [position++] = (byte)value;
			buffer [position++] = (byte)(value >> 8);
			buffer [position++] = (byte)(value >> 16);
			buffer [position++] = (byte)(value >> 24);
			buffer [position++] = (byte)(value >> 32);
			buffer [position++] = (byte)(value >> 40);
			buffer [position++] = (byte)(value >> 48);
			buffer [position++] = (byte)(value >> 56);

			if (position > length)
				length = position;
		}

		public void WriteInt64 (long value)
		{
			WriteUInt64 ((ulong)value);
		}

		public void WriteCompressedUInt32 (uint value)
		{
			if (value < 0x80)
				WriteByte ((byte)value);
			else if (value < 0x4000) {
				WriteByte ((byte)(0x80 | (value >> 8)));
				WriteByte ((byte)(value & 0xff));
			} else {
				WriteByte ((byte)((value >> 24) | 0xc0));
				WriteByte ((byte)((value >> 16) & 0xff));
				WriteByte ((byte)((value >> 8) & 0xff));
				WriteByte ((byte)(value & 0xff));
			}
		}

		public void WriteCompressedInt32 (int value)
		{
			if (value >= 0) {
				WriteCompressedUInt32 ((uint)(value << 1));
				return;
			}

			if (value > -0x40)
				value = 0x40 + value;
			else if (value >= -0x2000)
				value = 0x2000 + value;
			else if (value >= -0x20000000)
				value = 0x20000000 + value;

			WriteCompressedUInt32 ((uint)((value << 1) | 1));
		}

		public void WriteBytes (byte [] bytes)
		{
			var length = bytes.Length;
			if (position + length > buffer.Length)
				Grow (length);

			Buffer.BlockCopy (bytes, 0, buffer, position, length);
			position += length;

			if (position > this.length)
				this.length = position;
		}

		public void WriteBytes (int length)
		{
			if (position + length > buffer.Length)
				Grow (length);

			position += length;

			if (position > this.length)
				this.length = position;
		}

		public void WriteBytes (ByteBuffer buffer)
		{
			if (position + buffer.length > this.buffer.Length)
				Grow (buffer.length);

			Buffer.BlockCopy (buffer.buffer, 0, this.buffer, position, buffer.length);
			position += buffer.length;

			if (position > this.length)
				this.length = position;
		}

		public void WriteSingle (float value)
		{
			var bytes = BitConverter.GetBytes (value);

			if (!BitConverter.IsLittleEndian)
				Array.Reverse (bytes);

			WriteBytes (bytes);
		}

		public void WriteDouble (double value)
		{
			var bytes = BitConverter.GetBytes (value);

			if (!BitConverter.IsLittleEndian)
				Array.Reverse (bytes);

			WriteBytes (bytes);
		}

		void Grow (int desired)
		{
			var current = this.buffer;
			var current_length = current.Length;

			var buffer = new byte [System.Math.Max (current_length + desired, current_length * 2)];
			Buffer.BlockCopy (current, 0, buffer, 0, current_length);
			this.buffer = buffer;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/ByteBufferEqualityComparer.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System.Collections.Generic;

namespace MonoFN.Cecil.PE {

	sealed class ByteBufferEqualityComparer : IEqualityComparer<ByteBuffer> {

		public bool Equals (ByteBuffer x, ByteBuffer y)
		{
			if (x.length != y.length)
				return false;

			var x_buffer = x.buffer;
			var y_buffer = y.buffer;

			for (int i = 0; i < x.length; i++)
				if (x_buffer [i] != y_buffer [i])
					return false;

			return true;
		}

		public int GetHashCode (ByteBuffer buffer)
		{
			// See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
			const int fnv_offset_bias = unchecked((int)2166136261);
			const int fnv_prime = 16777619;

			var hash_code = fnv_offset_bias;
			var bytes = buffer.buffer;

			for (int i = 0; i < buffer.length; i++)
				hash_code = unchecked((hash_code ^ bytes [i]) * fnv_prime);

			return hash_code;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/DataDirectory.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using RVA = System.UInt32;

namespace MonoFN.Cecil.PE {

	struct DataDirectory {

		public readonly RVA VirtualAddress;
		public readonly uint Size;

		public bool IsZero {
			get { return VirtualAddress == 0 && Size == 0; }
		}

		public DataDirectory (RVA rva, uint size)
		{
			this.VirtualAddress = rva;
			this.Size = size;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/Image.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Metadata;
using System;
using System.IO;
using RVA = System.UInt32;

namespace MonoFN.Cecil.PE {

	sealed class Image : IDisposable {

		public Disposable<Stream> Stream;
		public string FileName;

		public ModuleKind Kind;
		public uint Characteristics;
		public string RuntimeVersion;
		public TargetArchitecture Architecture;
		public ModuleCharacteristics DllCharacteristics;
		public ushort LinkerVersion;
		public ushort SubSystemMajor;
		public ushort SubSystemMinor;

		public ImageDebugHeader DebugHeader;

		public Section [] Sections;

		public Section MetadataSection;

		public uint EntryPointToken;
		public uint Timestamp;
		public ModuleAttributes Attributes;

		public DataDirectory Win32Resources;
		public DataDirectory Debug;
		public DataDirectory Resources;
		public DataDirectory StrongName;

		public StringHeap StringHeap;
		public BlobHeap BlobHeap;
		public UserStringHeap UserStringHeap;
		public GuidHeap GuidHeap;
		public TableHeap TableHeap;
		public PdbHeap PdbHeap;

		readonly int [] coded_index_sizes = new int [14];

		readonly Func<Table, int> counter;

		public Image ()
		{
			counter = GetTableLength;
		}

		public bool HasTable (Table table)
		{
			return GetTableLength (table) > 0;
		}

		public int GetTableLength (Table table)
		{
			return (int)TableHeap [table].Length;
		}

		public int GetTableIndexSize (Table table)
		{
			return GetTableLength (table) < 65536 ? 2 : 4;
		}

		public int GetCodedIndexSize (CodedIndex coded_index)
		{
			var index = (int)coded_index;
			var size = coded_index_sizes [index];
			if (size != 0)
				return size;

			return coded_index_sizes [index] = coded_index.GetSize (counter);
		}

		public uint ResolveVirtualAddress (RVA rva)
		{
			var section = GetSectionAtVirtualAddress (rva);
			if (section == null)
				throw new ArgumentOutOfRangeException ();

			return ResolveVirtualAddressInSection (rva, section);
		}

		public uint ResolveVirtualAddressInSection (RVA rva, Section section)
		{
			return rva + section.PointerToRawData - section.VirtualAddress;
		}

		public Section GetSection (string name)
		{
			var sections = this.Sections;
			for (int i = 0; i < sections.Length; i++) {
				var section = sections [i];
				if (section.Name == name)
					return section;
			}

			return null;
		}

		public Section GetSectionAtVirtualAddress (RVA rva)
		{
			var sections = this.Sections;
			for (int i = 0; i < sections.Length; i++) {
				var section = sections [i];
				if (rva >= section.VirtualAddress && rva < section.VirtualAddress + section.SizeOfRawData)
					return section;
			}

			return null;
		}

		BinaryStreamReader GetReaderAt (RVA rva)
		{
			var section = GetSectionAtVirtualAddress (rva);
			if (section == null)
				return null;

			var reader = new BinaryStreamReader (Stream.value);
			reader.MoveTo (ResolveVirtualAddressInSection (rva, section));
			return reader;
		}

		public TRet GetReaderAt<TItem, TRet> (RVA rva, TItem item, Func<TItem, BinaryStreamReader, TRet> read) where TRet : class
		{
			var position = Stream.value.Position;
			try {
				var reader = GetReaderAt (rva);
				if (reader == null)
					return null;

				return read (item, reader);
			}
			finally {
				Stream.value.Position = position;
			}
		}

		public bool HasDebugTables ()
		{
			return HasTable (Table.Document)
				|| HasTable (Table.MethodDebugInformation)
				|| HasTable (Table.LocalScope)
				|| HasTable (Table.LocalVariable)
				|| HasTable (Table.LocalConstant)
				|| HasTable (Table.StateMachineMethod)
				|| HasTable (Table.CustomDebugInformation);
		}

		public void Dispose ()
		{
			Stream.Dispose ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/ImageReader.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Metadata;
using System;
using System.IO;

namespace MonoFN.Cecil.PE {

	sealed class ImageReader : BinaryStreamReader {

		readonly Image image;

		DataDirectory cli;
		DataDirectory metadata;

		uint table_heap_offset;

		public ImageReader (Disposable<Stream> stream, string file_name)
			: base (stream.value)
		{
			image = new Image ();
			image.Stream = stream;
			image.FileName = file_name;
		}

		void MoveTo (DataDirectory directory)
		{
			BaseStream.Position = image.ResolveVirtualAddress (directory.VirtualAddress);
		}

		void ReadImage ()
		{
			if (BaseStream.Length < 128)
				throw new BadImageFormatException ();

			// - DOSHeader

			// PE					2
			// Start				58
			// Lfanew				4
			// End					64

			if (ReadUInt16 () != 0x5a4d)
				throw new BadImageFormatException ();

			Advance (58);

			MoveTo (ReadUInt32 ());

			if (ReadUInt32 () != 0x00004550)
				throw new BadImageFormatException ();

			// - PEFileHeader

			// Machine				2
			image.Architecture = ReadArchitecture ();

			// NumberOfSections		2
			ushort sections = ReadUInt16 ();

			// TimeDateStamp		4
			image.Timestamp = ReadUInt32 ();
			// PointerToSymbolTable	4
			// NumberOfSymbols		4
			// OptionalHeaderSize	2
			Advance (10);

			// Characteristics		2
			ushort characteristics = ReadUInt16 ();

			ushort subsystem, dll_characteristics;
			ReadOptionalHeaders (out subsystem, out dll_characteristics);
			ReadSections (sections);
			ReadCLIHeader ();
			ReadMetadata ();
			ReadDebugHeader ();

			image.Characteristics = characteristics;
			image.Kind = GetModuleKind (characteristics, subsystem);
			image.DllCharacteristics = (ModuleCharacteristics)dll_characteristics;
		}

		TargetArchitecture ReadArchitecture ()
		{
			return (TargetArchitecture)ReadUInt16 ();
		}

		static ModuleKind GetModuleKind (ushort characteristics, ushort subsystem)
		{
			if ((characteristics & 0x2000) != 0) // ImageCharacteristics.Dll
				return ModuleKind.Dll;

			if (subsystem == 0x2 || subsystem == 0x9) // SubSystem.WindowsGui || SubSystem.WindowsCeGui
				return ModuleKind.Windows;

			return ModuleKind.Console;
		}

		void ReadOptionalHeaders (out ushort subsystem, out ushort dll_characteristics)
		{
			// - PEOptionalHeader
			//   - StandardFieldsHeader

			// Magic				2
			bool pe64 = ReadUInt16 () == 0x20b;

			//						pe32 || pe64

			image.LinkerVersion = ReadUInt16 ();
			// CodeSize				4
			// InitializedDataSize	4
			// UninitializedDataSize4
			// EntryPointRVA		4
			// BaseOfCode			4
			// BaseOfData			4 || 0

			//   - NTSpecificFieldsHeader

			// ImageBase			4 || 8
			// SectionAlignment		4
			// FileAlignement		4
			// OSMajor				2
			// OSMinor				2
			// UserMajor			2
			// UserMinor			2
			// SubSysMajor			2
			// SubSysMinor			2
			Advance (44);

			image.SubSystemMajor = ReadUInt16 ();
			image.SubSystemMinor = ReadUInt16 ();

			// Reserved				4
			// ImageSize			4
			// HeaderSize			4
			// FileChecksum			4
			Advance (16);

			// SubSystem			2
			subsystem = ReadUInt16 ();

			// DLLFlags				2
			dll_characteristics = ReadUInt16 ();
			// StackReserveSize		4 || 8
			// StackCommitSize		4 || 8
			// HeapReserveSize		4 || 8
			// HeapCommitSize		4 || 8
			// LoaderFlags			4
			// NumberOfDataDir		4

			//   - DataDirectoriesHeader

			// ExportTable			8
			// ImportTable			8

			Advance (pe64 ? 56 : 40);

			// ResourceTable		8

			image.Win32Resources = ReadDataDirectory ();

			// ExceptionTable		8
			// CertificateTable		8
			// BaseRelocationTable	8

			Advance (24);

			// Debug				8
			image.Debug = ReadDataDirectory ();

			// Copyright			8
			// GlobalPtr			8
			// TLSTable				8
			// LoadConfigTable		8
			// BoundImport			8
			// IAT					8
			// DelayImportDescriptor8
			Advance (56);

			// CLIHeader			8
			cli = ReadDataDirectory ();

			if (cli.IsZero)
				throw new BadImageFormatException ();

			// Reserved				8
			Advance (8);
		}

		string ReadAlignedString (int length)
		{
			int read = 0;
			var buffer = new char [length];
			while (read < length) {
				var current = ReadByte ();
				if (current == 0)
					break;

				buffer [read++] = (char)current;
			}

			Advance (-1 + ((read + 4) & ~3) - read);

			return new string (buffer, 0, read);
		}

		string ReadZeroTerminatedString (int length)
		{
			int read = 0;
			var buffer = new char [length];
			var bytes = ReadBytes (length);
			while (read < length) {
				var current = bytes [read];
				if (current == 0)
					break;

				buffer [read++] = (char)current;
			}

			return new string (buffer, 0, read);
		}

		void ReadSections (ushort count)
		{
			var sections = new Section [count];

			for (int i = 0; i < count; i++) {
				var section = new Section ();

				// Name
				section.Name = ReadZeroTerminatedString (8);

				// VirtualSize		4
				Advance (4);

				// VirtualAddress	4
				section.VirtualAddress = ReadUInt32 ();
				// SizeOfRawData	4
				section.SizeOfRawData = ReadUInt32 ();
				// PointerToRawData	4
				section.PointerToRawData = ReadUInt32 ();

				// PointerToRelocations		4
				// PointerToLineNumbers		4
				// NumberOfRelocations		2
				// NumberOfLineNumbers		2
				// Characteristics			4
				Advance (16);

				sections [i] = section;
			}

			image.Sections = sections;
		}

		void ReadCLIHeader ()
		{
			MoveTo (cli);

			// - CLIHeader

			// Cb						4
			// MajorRuntimeVersion		2
			// MinorRuntimeVersion		2
			Advance (8);

			// Metadata					8
			metadata = ReadDataDirectory ();
			// Flags					4
			image.Attributes = (ModuleAttributes)ReadUInt32 ();
			// EntryPointToken			4
			image.EntryPointToken = ReadUInt32 ();
			// Resources				8
			image.Resources = ReadDataDirectory ();
			// StrongNameSignature		8
			image.StrongName = ReadDataDirectory ();
			// CodeManagerTable			8
			// VTableFixups				8
			// ExportAddressTableJumps	8
			// ManagedNativeHeader		8
		}

		void ReadMetadata ()
		{
			MoveTo (metadata);

			if (ReadUInt32 () != 0x424a5342)
				throw new BadImageFormatException ();

			// MajorVersion			2
			// MinorVersion			2
			// Reserved				4
			Advance (8);

			image.RuntimeVersion = ReadZeroTerminatedString (ReadInt32 ());

			// Flags		2
			Advance (2);

			var streams = ReadUInt16 ();

			var section = image.GetSectionAtVirtualAddress (metadata.VirtualAddress);
			if (section == null)
				throw new BadImageFormatException ();

			image.MetadataSection = section;

			for (int i = 0; i < streams; i++)
				ReadMetadataStream (section);

			if (image.PdbHeap != null)
				ReadPdbHeap ();

			if (image.TableHeap != null)
				ReadTableHeap ();
		}

		void ReadDebugHeader ()
		{
			if (image.Debug.IsZero) {
				image.DebugHeader = new ImageDebugHeader (Empty<ImageDebugHeaderEntry>.Array);
				return;
			}

			MoveTo (image.Debug);

			var entries = new ImageDebugHeaderEntry [(int)image.Debug.Size / ImageDebugDirectory.Size];

			for (int i = 0; i < entries.Length; i++) {
				var directory = new ImageDebugDirectory {
					Characteristics = ReadInt32 (),
					TimeDateStamp = ReadInt32 (),
					MajorVersion = ReadInt16 (),
					MinorVersion = ReadInt16 (),
					Type = (ImageDebugType)ReadInt32 (),
					SizeOfData = ReadInt32 (),
					AddressOfRawData = ReadInt32 (),
					PointerToRawData = ReadInt32 (),
				};

				if (directory.PointerToRawData == 0 || directory.SizeOfData < 0) {
					entries [i] = new ImageDebugHeaderEntry (directory, Empty<byte>.Array);
					continue;
				}

				var position = Position;
				try {
					MoveTo ((uint)directory.PointerToRawData);
					var data = ReadBytes (directory.SizeOfData);
					entries [i] = new ImageDebugHeaderEntry (directory, data);
				}
				finally {
					Position = position;
				}
			}

			image.DebugHeader = new ImageDebugHeader (entries);
		}

		void ReadMetadataStream (Section section)
		{
			// Offset		4
			uint offset = metadata.VirtualAddress - section.VirtualAddress + ReadUInt32 (); // relative to the section start

			// Size			4
			uint size = ReadUInt32 ();

			var data = ReadHeapData (offset, size);

			var name = ReadAlignedString (16);
			switch (name) {
			case "#~":
			case "#-":
				image.TableHeap = new TableHeap (data);
				table_heap_offset = offset;
				break;
			case "#Strings":
				image.StringHeap = new StringHeap (data);
				break;
			case "#Blob":
				image.BlobHeap = new BlobHeap (data);
				break;
			case "#GUID":
				image.GuidHeap = new GuidHeap (data);
				break;
			case "#US":
				image.UserStringHeap = new UserStringHeap (data);
				break;
			case "#Pdb":
				image.PdbHeap = new PdbHeap (data);
				break;
			}
		}

		byte [] ReadHeapData (uint offset, uint size)
		{
			var position = BaseStream.Position;
			MoveTo (offset + image.MetadataSection.PointerToRawData);
			var data = ReadBytes ((int)size);
			BaseStream.Position = position;

			return data;
		}

		void ReadTableHeap ()
		{
			var heap = image.TableHeap;

			MoveTo (table_heap_offset + image.MetadataSection.PointerToRawData);

			// Reserved			4
			// MajorVersion		1
			// MinorVersion		1
			Advance (6);

			// HeapSizes		1
			var sizes = ReadByte ();

			// Reserved2		1
			Advance (1);

			// Valid			8
			heap.Valid = ReadInt64 ();

			// Sorted			8
			heap.Sorted = ReadInt64 ();

			if (image.PdbHeap != null) {
				for (int i = 0; i < Mixin.TableCount; i++) {
					if (!image.PdbHeap.HasTable ((Table)i))
						continue;

					heap.Tables [i].Length = image.PdbHeap.TypeSystemTableRows [i];
				}
			}

			for (int i = 0; i < Mixin.TableCount; i++) {
				if (!heap.HasTable ((Table)i))
					continue;

				heap.Tables [i].Length = ReadUInt32 ();
			}

			SetIndexSize (image.StringHeap, sizes, 0x1);
			SetIndexSize (image.GuidHeap, sizes, 0x2);
			SetIndexSize (image.BlobHeap, sizes, 0x4);

			ComputeTableInformations ();
		}

		static void SetIndexSize (Heap heap, uint sizes, byte flag)
		{
			if (heap == null)
				return;

			heap.IndexSize = (sizes & flag) > 0 ? 4 : 2;
		}

		int GetTableIndexSize (Table table)
		{
			return image.GetTableIndexSize (table);
		}

		int GetCodedIndexSize (CodedIndex index)
		{
			return image.GetCodedIndexSize (index);
		}

		void ComputeTableInformations ()
		{
			uint offset = (uint)BaseStream.Position - table_heap_offset - image.MetadataSection.PointerToRawData; // header

			int stridx_size = image.StringHeap != null ? image.StringHeap.IndexSize : 2;
			int guididx_size = image.GuidHeap != null ? image.GuidHeap.IndexSize : 2;
			int blobidx_size = image.BlobHeap != null ? image.BlobHeap.IndexSize : 2;

			var heap = image.TableHeap;
			var tables = heap.Tables;

			for (int i = 0; i < Mixin.TableCount; i++) {
				var table = (Table)i;
				if (!heap.HasTable (table))
					continue;

				int size;
				switch (table) {
				case Table.Module:
					size = 2    // Generation
						+ stridx_size   // Name
						+ (guididx_size * 3);   // Mvid, EncId, EncBaseId
					break;
				case Table.TypeRef:
					size = GetCodedIndexSize (CodedIndex.ResolutionScope)   // ResolutionScope
						+ (stridx_size * 2);    // Name, Namespace
					break;
				case Table.TypeDef:
					size = 4    // Flags
						+ (stridx_size * 2) // Name, Namespace
						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef)   // BaseType
						+ GetTableIndexSize (Table.Field)   // FieldList
						+ GetTableIndexSize (Table.Method); // MethodList
					break;
				case Table.FieldPtr:
					size = GetTableIndexSize (Table.Field); // Field
					break;
				case Table.Field:
					size = 2    // Flags
						+ stridx_size   // Name
						+ blobidx_size; // Signature
					break;
				case Table.MethodPtr:
					size = GetTableIndexSize (Table.Method);    // Method
					break;
				case Table.Method:
					size = 8    // Rva 4, ImplFlags 2, Flags 2
						+ stridx_size   // Name
						+ blobidx_size  // Signature
						+ GetTableIndexSize (Table.Param); // ParamList
					break;
				case Table.ParamPtr:
					size = GetTableIndexSize (Table.Param); // Param
					break;
				case Table.Param:
					size = 4    // Flags 2, Sequence 2
						+ stridx_size;  // Name
					break;
				case Table.InterfaceImpl:
					size = GetTableIndexSize (Table.TypeDef)    // Class
						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  // Interface
					break;
				case Table.MemberRef:
					size = GetCodedIndexSize (CodedIndex.MemberRefParent)   // Class
						+ stridx_size   // Name
						+ blobidx_size; // Signature
					break;
				case Table.Constant:
					size = 2    // Type
						+ GetCodedIndexSize (CodedIndex.HasConstant)    // Parent
						+ blobidx_size; // Value
					break;
				case Table.CustomAttribute:
					size = GetCodedIndexSize (CodedIndex.HasCustomAttribute)    // Parent
						+ GetCodedIndexSize (CodedIndex.CustomAttributeType)    // Type
						+ blobidx_size; // Value
					break;
				case Table.FieldMarshal:
					size = GetCodedIndexSize (CodedIndex.HasFieldMarshal)   // Parent
						+ blobidx_size; // NativeType
					break;
				case Table.DeclSecurity:
					size = 2    // Action
						+ GetCodedIndexSize (CodedIndex.HasDeclSecurity)    // Parent
						+ blobidx_size; // PermissionSet
					break;
				case Table.ClassLayout:
					size = 6    // PackingSize 2, ClassSize 4
						+ GetTableIndexSize (Table.TypeDef);    // Parent
					break;
				case Table.FieldLayout:
					size = 4    // Offset
						+ GetTableIndexSize (Table.Field);  // Field
					break;
				case Table.StandAloneSig:
					size = blobidx_size;    // Signature
					break;
				case Table.EventMap:
					size = GetTableIndexSize (Table.TypeDef)    // Parent
						+ GetTableIndexSize (Table.Event);  // EventList
					break;
				case Table.EventPtr:
					size = GetTableIndexSize (Table.Event); // Event
					break;
				case Table.Event:
					size = 2    // Flags
						+ stridx_size // Name
						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  // EventType
					break;
				case Table.PropertyMap:
					size = GetTableIndexSize (Table.TypeDef)    // Parent
						+ GetTableIndexSize (Table.Property);   // PropertyList
					break;
				case Table.PropertyPtr:
					size = GetTableIndexSize (Table.Property);  // Property
					break;
				case Table.Property:
					size = 2    // Flags
						+ stridx_size   // Name
						+ blobidx_size; // Type
					break;
				case Table.MethodSemantics:
					size = 2    // Semantics
						+ GetTableIndexSize (Table.Method)  // Method
						+ GetCodedIndexSize (CodedIndex.HasSemantics);  // Association
					break;
				case Table.MethodImpl:
					size = GetTableIndexSize (Table.TypeDef)    // Class
						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef) // MethodBody
						+ GetCodedIndexSize (CodedIndex.MethodDefOrRef);    // MethodDeclaration
					break;
				case Table.ModuleRef:
					size = stridx_size; // Name
					break;
				case Table.TypeSpec:
					size = blobidx_size;    // Signature
					break;
				case Table.ImplMap:
					size = 2    // MappingFlags
						+ GetCodedIndexSize (CodedIndex.MemberForwarded)    // MemberForwarded
						+ stridx_size   // ImportName
						+ GetTableIndexSize (Table.ModuleRef);  // ImportScope
					break;
				case Table.FieldRVA:
					size = 4    // RVA
						+ GetTableIndexSize (Table.Field);  // Field
					break;
				case Table.EncLog:
					size = 8;
					break;
				case Table.EncMap:
					size = 4;
					break;
				case Table.Assembly:
					size = 16 // HashAlgId 4, Version 4 * 2, Flags 4
						+ blobidx_size  // PublicKey
						+ (stridx_size * 2);    // Name, Culture
					break;
				case Table.AssemblyProcessor:
					size = 4;   // Processor
					break;
				case Table.AssemblyOS:
					size = 12;  // Platform 4, Version 2 * 4
					break;
				case Table.AssemblyRef:
					size = 12   // Version 2 * 4 + Flags 4
						+ (blobidx_size * 2)    // PublicKeyOrToken, HashValue
						+ (stridx_size * 2);    // Name, Culture
					break;
				case Table.AssemblyRefProcessor:
					size = 4    // Processor
						+ GetTableIndexSize (Table.AssemblyRef);    // AssemblyRef
					break;
				case Table.AssemblyRefOS:
					size = 12   // Platform 4, Version 2 * 4
						+ GetTableIndexSize (Table.AssemblyRef);    // AssemblyRef
					break;
				case Table.File:
					size = 4    // Flags
						+ stridx_size   // Name
						+ blobidx_size; // HashValue
					break;
				case Table.ExportedType:
					size = 8    // Flags 4, TypeDefId 4
						+ (stridx_size * 2) // Name, Namespace
						+ GetCodedIndexSize (CodedIndex.Implementation);    // Implementation
					break;
				case Table.ManifestResource:
					size = 8    // Offset, Flags
						+ stridx_size   // Name
						+ GetCodedIndexSize (CodedIndex.Implementation);    // Implementation
					break;
				case Table.NestedClass:
					size = GetTableIndexSize (Table.TypeDef)    // NestedClass
						+ GetTableIndexSize (Table.TypeDef);    // EnclosingClass
					break;
				case Table.GenericParam:
					size = 4    // Number, Flags
						+ GetCodedIndexSize (CodedIndex.TypeOrMethodDef)    // Owner
						+ stridx_size;  // Name
					break;
				case Table.MethodSpec:
					size = GetCodedIndexSize (CodedIndex.MethodDefOrRef)    // Method
						+ blobidx_size; // Instantiation
					break;
				case Table.GenericParamConstraint:
					size = GetTableIndexSize (Table.GenericParam)   // Owner
						+ GetCodedIndexSize (CodedIndex.TypeDefOrRef);  // Constraint
					break;
				case Table.Document:
					size = blobidx_size // Name
						+ guididx_size  // HashAlgorithm
						+ blobidx_size  // Hash
						+ guididx_size; // Language
					break;
				case Table.MethodDebugInformation:
					size = GetTableIndexSize (Table.Document)  // Document
						+ blobidx_size; // SequencePoints
					break;
				case Table.LocalScope:
					size = GetTableIndexSize (Table.Method) // Method
						+ GetTableIndexSize (Table.ImportScope) // ImportScope
						+ GetTableIndexSize (Table.LocalVariable)   // VariableList
						+ GetTableIndexSize (Table.LocalConstant)   // ConstantList
						+ 4 * 2;    // StartOffset, Length
					break;
				case Table.LocalVariable:
					size = 2    // Attributes
						+ 2     // Index
						+ stridx_size;  // Name
					break;
				case Table.LocalConstant:
					size = stridx_size  // Name
						+ blobidx_size; // Signature
					break;
				case Table.ImportScope:
					size = GetTableIndexSize (Table.ImportScope)    // Parent
						+ blobidx_size;
					break;
				case Table.StateMachineMethod:
					size = GetTableIndexSize (Table.Method) // MoveNextMethod
						+ GetTableIndexSize (Table.Method); // KickOffMethod
					break;
				case Table.CustomDebugInformation:
					size = GetCodedIndexSize (CodedIndex.HasCustomDebugInformation) // Parent
						+ guididx_size  // Kind
						+ blobidx_size; // Value
					break;
				default:
					throw new NotSupportedException ();
				}

				tables [i].RowSize = (uint)size;
				tables [i].Offset = offset;

				offset += (uint)size * tables [i].Length;
			}
		}

		void ReadPdbHeap ()
		{
			var heap = image.PdbHeap;

			var buffer = new ByteBuffer (heap.data);

			heap.Id = buffer.ReadBytes (20);
			heap.EntryPoint = buffer.ReadUInt32 ();
			heap.TypeSystemTables = buffer.ReadInt64 ();
			heap.TypeSystemTableRows = new uint [Mixin.TableCount];

			for (int i = 0; i < Mixin.TableCount; i++) {
				var table = (Table)i;
				if (!heap.HasTable (table))
					continue;

				heap.TypeSystemTableRows [i] = buffer.ReadUInt32 ();
			}
		}

		public static Image ReadImage (Disposable<Stream> stream, string file_name)
		{
			try {
				var reader = new ImageReader (stream, file_name);
				reader.ReadImage ();
				return reader.image;
			}
			catch (EndOfStreamException e) {
				throw new BadImageFormatException (stream.value.GetFileName (), e);
			}
		}

		public static Image ReadPortablePdb (Disposable<Stream> stream, string file_name)
		{
			try {
				var reader = new ImageReader (stream, file_name);
				var length = (uint)stream.value.Length;

				reader.image.Sections = new [] {
					new Section {
						PointerToRawData = 0,
						SizeOfRawData = length,
						VirtualAddress = 0,
						VirtualSize = length,
					}
				};

				reader.metadata = new DataDirectory (0, length);
				reader.ReadMetadata ();
				return reader.image;
			}
			catch (EndOfStreamException e) {
				throw new BadImageFormatException (stream.value.GetFileName (), e);
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/ImageWriter.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Metadata;
using System;
using System.IO;
using RVA = System.UInt32;

namespace MonoFN.Cecil.PE {

	sealed class ImageWriter : BinaryStreamWriter {

		readonly ModuleDefinition module;
		readonly MetadataBuilder metadata;
		readonly TextMap text_map;
		readonly internal Disposable<Stream> stream;

		readonly string runtime_version;

		ImageDebugHeader debug_header;

		ByteBuffer win32_resources;

		const uint pe_header_size = 0x98u;
		const uint section_header_size = 0x28u;
		const uint file_alignment = 0x200;
		const uint section_alignment = 0x2000;
		const ulong image_base = 0x00400000;

		internal const RVA text_rva = 0x2000;

		readonly bool pe64;
		readonly bool has_reloc;

		internal Section text;
		internal Section rsrc;
		internal Section reloc;

		ushort sections;

		ImageWriter (ModuleDefinition module, string runtime_version, MetadataBuilder metadata, Disposable<Stream> stream, bool metadataOnly = false)
			: base (stream.value)
		{
			this.module = module;
			this.runtime_version = runtime_version;
			this.text_map = metadata.text_map;
			this.stream = stream;
			this.metadata = metadata;
			if (metadataOnly)
				return;

			this.pe64 = module.Architecture == TargetArchitecture.AMD64 || module.Architecture == TargetArchitecture.IA64 || module.Architecture == TargetArchitecture.ARM64;
			this.has_reloc = module.Architecture == TargetArchitecture.I386;
			this.GetDebugHeader ();
			this.GetWin32Resources ();
			this.BuildTextMap ();
			this.sections = (ushort)(has_reloc ? 2 : 1); // text + reloc?
		}

		void GetDebugHeader ()
		{
			var symbol_writer = metadata.symbol_writer;
			if (symbol_writer != null)
				debug_header = symbol_writer.GetDebugHeader ();

			if (module.HasDebugHeader) {
				var header = module.GetDebugHeader ();
				var deterministic = header.GetDeterministicEntry ();
				if (deterministic == null)
					return;

				debug_header = debug_header.AddDeterministicEntry ();
			}
		}

		void GetWin32Resources ()
		{
			if (!module.HasImage)
				return;

			DataDirectory win32_resources_directory = module.Image.Win32Resources;
			var size = win32_resources_directory.Size;

			if (size > 0) {
				win32_resources = module.Image.GetReaderAt (win32_resources_directory.VirtualAddress, size, (s, reader) => new ByteBuffer (reader.ReadBytes ((int)s)));
			}
		}

		public static ImageWriter CreateWriter (ModuleDefinition module, MetadataBuilder metadata, Disposable<Stream> stream)
		{
			var writer = new ImageWriter (module, module.runtime_version, metadata, stream);
			writer.BuildSections ();
			return writer;
		}

		public static ImageWriter CreateDebugWriter (ModuleDefinition module, MetadataBuilder metadata, Disposable<Stream> stream)
		{
			var writer = new ImageWriter (module, "PDB v1.0", metadata, stream, metadataOnly: true);
			var length = metadata.text_map.GetLength ();
			writer.text = new Section { SizeOfRawData = length, VirtualSize = length };
			return writer;
		}

		void BuildSections ()
		{
			var has_win32_resources = win32_resources != null;
			if (has_win32_resources)
				sections++;

			text = CreateSection (".text", text_map.GetLength (), null);
			var previous = text;

			if (has_win32_resources) {
				rsrc = CreateSection (".rsrc", (uint)win32_resources.length, previous);

				PatchWin32Resources (win32_resources);
				previous = rsrc;
			}

			if (has_reloc)
				reloc = CreateSection (".reloc", 12u, previous);
		}

		Section CreateSection (string name, uint size, Section previous)
		{
			return new Section {
				Name = name,
				VirtualAddress = previous != null
					? previous.VirtualAddress + Align (previous.VirtualSize, section_alignment)
					: text_rva,
				VirtualSize = size,
				PointerToRawData = previous != null
					? previous.PointerToRawData + previous.SizeOfRawData
					: Align (GetHeaderSize (), file_alignment),
				SizeOfRawData = Align (size, file_alignment)
			};
		}

		static uint Align (uint value, uint align)
		{
			align--;
			return (value + align) & ~align;
		}

		void WriteDOSHeader ()
		{
			Write (new byte [] {
				// dos header start
				0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00,
				0x00, 0x04, 0x00, 0x00, 0x00, 0xff, 0xff,
				0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				// lfanew
				0x80, 0x00, 0x00, 0x00,
				// dos header end
				0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09,
				0xcd, 0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21,
				0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72,
				0x6f, 0x67, 0x72, 0x61, 0x6d, 0x20, 0x63,
				0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x62,
				0x65, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x69,
				0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20, 0x6d,
				0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a,
				0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00
			});
		}

		ushort SizeOfOptionalHeader ()
		{
			return (ushort)(!pe64 ? 0xe0 : 0xf0);
		}

		void WritePEFileHeader ()
		{
			WriteUInt32 (0x00004550);       // Magic
			WriteUInt16 ((ushort)module.Architecture);  // Machine
			WriteUInt16 (sections);         // NumberOfSections
			WriteUInt32 (metadata.timestamp);
			WriteUInt32 (0);    // PointerToSymbolTable
			WriteUInt32 (0);    // NumberOfSymbols
			WriteUInt16 (SizeOfOptionalHeader ());  // SizeOfOptionalHeader

			const ushort LargeAddressAware = 0x0020;

			// ExecutableImage | (!pe64 ? 32BitsMachine : LargeAddressAware)
			var characteristics = (ushort)(0x0002 | (!pe64 ? 0x0100 : LargeAddressAware));
			if (module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule)
				characteristics |= 0x2000;

			if (module.Image != null && (module.Image.Characteristics & LargeAddressAware) != 0)
				characteristics |= LargeAddressAware;

			WriteUInt16 (characteristics);  // Characteristics
		}

		Section LastSection ()
		{
			if (reloc != null)
				return reloc;

			if (rsrc != null)
				return rsrc;

			return text;
		}

		void WriteOptionalHeaders ()
		{
			WriteUInt16 ((ushort)(!pe64 ? 0x10b : 0x20b)); // Magic
			WriteUInt16 (module.linker_version);
			WriteUInt32 (text.SizeOfRawData);   // CodeSize
			WriteUInt32 ((reloc != null ? reloc.SizeOfRawData : 0)
				+ (rsrc != null ? rsrc.SizeOfRawData : 0)); // InitializedDataSize
			WriteUInt32 (0);    // UninitializedDataSize

			var startub_stub = text_map.GetRange (TextSegment.StartupStub);
			WriteUInt32 (startub_stub.Length > 0 ? startub_stub.Start : 0);  // EntryPointRVA
			WriteUInt32 (text_rva); // BaseOfCode

			if (!pe64) {
				WriteUInt32 (0);    // BaseOfData
				WriteUInt32 ((uint)image_base); // ImageBase
			} else {
				WriteUInt64 (image_base);   // ImageBase
			}

			WriteUInt32 (section_alignment);    // SectionAlignment
			WriteUInt32 (file_alignment);       // FileAlignment

			WriteUInt16 (4);    // OSMajor
			WriteUInt16 (0);    // OSMinor
			WriteUInt16 (0);    // UserMajor
			WriteUInt16 (0);    // UserMinor
			WriteUInt16 (module.subsystem_major);   // SubSysMajor
			WriteUInt16 (module.subsystem_minor);   // SubSysMinor
			WriteUInt32 (0);    // Reserved

			var last_section = LastSection ();
			WriteUInt32 (last_section.VirtualAddress + Align (last_section.VirtualSize, section_alignment));    // ImageSize
			WriteUInt32 (text.PointerToRawData);    // HeaderSize

			WriteUInt32 (0);    // Checksum
			WriteUInt16 (GetSubSystem ());  // SubSystem
			WriteUInt16 ((ushort)module.Characteristics);   // DLLFlags

			if (!pe64) {
				const uint stack_reserve = 0x100000;
				const uint stack_commit = 0x1000;
				const uint heap_reserve = 0x100000;
				const uint heap_commit = 0x1000;

				WriteUInt32 (stack_reserve);
				WriteUInt32 (stack_commit);
				WriteUInt32 (heap_reserve);
				WriteUInt32 (heap_commit);
			} else {
				const ulong stack_reserve = 0x400000;
				const ulong stack_commit = 0x4000;
				const ulong heap_reserve = 0x100000;
				const ulong heap_commit = 0x2000;

				WriteUInt64 (stack_reserve);
				WriteUInt64 (stack_commit);
				WriteUInt64 (heap_reserve);
				WriteUInt64 (heap_commit);
			}

			WriteUInt32 (0);    // LoaderFlags
			WriteUInt32 (16);   // NumberOfDataDir

			WriteZeroDataDirectory ();  // ExportTable
			WriteDataDirectory (text_map.GetDataDirectory (TextSegment.ImportDirectory));   // ImportTable
			if (rsrc != null) {                         // ResourceTable
				WriteUInt32 (rsrc.VirtualAddress);
				WriteUInt32 (rsrc.VirtualSize);
			} else
				WriteZeroDataDirectory ();

			WriteZeroDataDirectory ();  // ExceptionTable
			WriteZeroDataDirectory ();  // CertificateTable
			WriteUInt32 (reloc != null ? reloc.VirtualAddress : 0);         // BaseRelocationTable
			WriteUInt32 (reloc != null ? reloc.VirtualSize : 0);

			if (text_map.GetLength (TextSegment.DebugDirectory) > 0) {
				WriteUInt32 (text_map.GetRVA (TextSegment.DebugDirectory));
				WriteUInt32 ((uint)(debug_header.Entries.Length * ImageDebugDirectory.Size));
			} else
				WriteZeroDataDirectory ();

			WriteZeroDataDirectory ();  // Copyright
			WriteZeroDataDirectory ();  // GlobalPtr
			WriteZeroDataDirectory ();  // TLSTable
			WriteZeroDataDirectory ();  // LoadConfigTable
			WriteZeroDataDirectory ();  // BoundImport
			WriteDataDirectory (text_map.GetDataDirectory (TextSegment.ImportAddressTable));    // IAT
			WriteZeroDataDirectory ();  // DelayImportDesc
			WriteDataDirectory (text_map.GetDataDirectory (TextSegment.CLIHeader)); // CLIHeader
			WriteZeroDataDirectory ();  // Reserved
		}

		void WriteZeroDataDirectory ()
		{
			WriteUInt32 (0);
			WriteUInt32 (0);
		}

		ushort GetSubSystem ()
		{
			switch (module.Kind) {
			case ModuleKind.Console:
			case ModuleKind.Dll:
			case ModuleKind.NetModule:
				return 0x3;
			case ModuleKind.Windows:
				return 0x2;
			default:
				throw new ArgumentOutOfRangeException ();
			}
		}

		void WriteSectionHeaders ()
		{
			WriteSection (text, 0x60000020);

			if (rsrc != null)
				WriteSection (rsrc, 0x40000040);

			if (reloc != null)
				WriteSection (reloc, 0x42000040);
		}

		void WriteSection (Section section, uint characteristics)
		{
			var name = new byte [8];
			var sect_name = section.Name;
			for (int i = 0; i < sect_name.Length; i++)
				name [i] = (byte)sect_name [i];

			WriteBytes (name);
			WriteUInt32 (section.VirtualSize);
			WriteUInt32 (section.VirtualAddress);
			WriteUInt32 (section.SizeOfRawData);
			WriteUInt32 (section.PointerToRawData);
			WriteUInt32 (0);    // PointerToRelocations
			WriteUInt32 (0);    // PointerToLineNumbers
			WriteUInt16 (0);    // NumberOfRelocations
			WriteUInt16 (0);    // NumberOfLineNumbers
			WriteUInt32 (characteristics);
		}

		uint GetRVAFileOffset (Section section, RVA rva)
		{
			return section.PointerToRawData + rva - section.VirtualAddress;
		}

		void MoveTo (uint pointer)
		{
			BaseStream.Seek (pointer, SeekOrigin.Begin);
		}

		void MoveToRVA (Section section, RVA rva)
		{
			BaseStream.Seek (GetRVAFileOffset (section, rva), SeekOrigin.Begin);
		}

		void MoveToRVA (TextSegment segment)
		{
			MoveToRVA (text, text_map.GetRVA (segment));
		}

		void WriteRVA (RVA rva)
		{
			if (!pe64)
				WriteUInt32 (rva);
			else
				WriteUInt64 (rva);
		}

		void PrepareSection (Section section)
		{
			MoveTo (section.PointerToRawData);

			const int buffer_size = 4096;

			if (section.SizeOfRawData <= buffer_size) {
				Write (new byte [section.SizeOfRawData]);
				MoveTo (section.PointerToRawData);
				return;
			}

			var written = 0;
			var buffer = new byte [buffer_size];
			while (written != section.SizeOfRawData) {
				var write_size = System.Math.Min ((int)section.SizeOfRawData - written, buffer_size);
				Write (buffer, 0, write_size);
				written += write_size;
			}

			MoveTo (section.PointerToRawData);
		}

		void WriteText ()
		{
			PrepareSection (text);

			// ImportAddressTable

			if (has_reloc) {
				WriteRVA (text_map.GetRVA (TextSegment.ImportHintNameTable));
				WriteRVA (0);
			}

			// CLIHeader

			WriteUInt32 (0x48);
			WriteUInt16 (2);
			WriteUInt16 ((ushort)((module.Runtime <= TargetRuntime.Net_1_1) ? 0 : 5));

			WriteUInt32 (text_map.GetRVA (TextSegment.MetadataHeader));
			WriteUInt32 (GetMetadataLength ());
			WriteUInt32 ((uint)module.Attributes);
			WriteUInt32 (metadata.entry_point.ToUInt32 ());
			WriteDataDirectory (text_map.GetDataDirectory (TextSegment.Resources));
			WriteDataDirectory (text_map.GetDataDirectory (TextSegment.StrongNameSignature));
			WriteZeroDataDirectory ();  // CodeManagerTable
			WriteZeroDataDirectory ();  // VTableFixups
			WriteZeroDataDirectory ();  // ExportAddressTableJumps
			WriteZeroDataDirectory ();  // ManagedNativeHeader

			// Code

			MoveToRVA (TextSegment.Code);
			WriteBuffer (metadata.code);

			// Resources

			MoveToRVA (TextSegment.Resources);
			WriteBuffer (metadata.resources);

			// Data

			if (metadata.data.length > 0) {
				MoveToRVA (TextSegment.Data);
				WriteBuffer (metadata.data);
			}

			// StrongNameSignature
			// stays blank

			// MetadataHeader

			MoveToRVA (TextSegment.MetadataHeader);
			WriteMetadataHeader ();

			WriteMetadata ();

			// DebugDirectory
			if (text_map.GetLength (TextSegment.DebugDirectory) > 0) {
				MoveToRVA (TextSegment.DebugDirectory);
				WriteDebugDirectory ();
			}

			if (!has_reloc)
				return;

			// ImportDirectory
			MoveToRVA (TextSegment.ImportDirectory);
			WriteImportDirectory ();

			// StartupStub
			MoveToRVA (TextSegment.StartupStub);
			WriteStartupStub ();
		}

		uint GetMetadataLength ()
		{
			return text_map.GetRVA (TextSegment.DebugDirectory) - text_map.GetRVA (TextSegment.MetadataHeader);
		}

		public void WriteMetadataHeader ()
		{
			WriteUInt32 (0x424a5342);   // Signature
			WriteUInt16 (1);    // MajorVersion
			WriteUInt16 (1);    // MinorVersion
			WriteUInt32 (0);    // Reserved

			var version = GetZeroTerminatedString (runtime_version);
			WriteUInt32 ((uint)version.Length);
			WriteBytes (version);
			WriteUInt16 (0);    // Flags
			WriteUInt16 (GetStreamCount ());

			uint offset = text_map.GetRVA (TextSegment.TableHeap) - text_map.GetRVA (TextSegment.MetadataHeader);

			WriteStreamHeader (ref offset, TextSegment.TableHeap, "#~");
			WriteStreamHeader (ref offset, TextSegment.StringHeap, "#Strings");
			WriteStreamHeader (ref offset, TextSegment.UserStringHeap, "#US");
			WriteStreamHeader (ref offset, TextSegment.GuidHeap, "#GUID");
			WriteStreamHeader (ref offset, TextSegment.BlobHeap, "#Blob");
			WriteStreamHeader (ref offset, TextSegment.PdbHeap, "#Pdb");
		}

		ushort GetStreamCount ()
		{
			return (ushort)(
				1   // #~
				+ 1 // #Strings
				+ (metadata.user_string_heap.IsEmpty ? 0 : 1)   // #US
				+ (metadata.guid_heap.IsEmpty ? 0 : 1)  // GUID
				+ (metadata.blob_heap.IsEmpty ? 0 : 1)
				+ (metadata.pdb_heap == null ? 0 : 1)); // #Blob
		}

		void WriteStreamHeader (ref uint offset, TextSegment heap, string name)
		{
			var length = (uint)text_map.GetLength (heap);
			if (length == 0)
				return;

			WriteUInt32 (offset);
			WriteUInt32 (length);
			WriteBytes (GetZeroTerminatedString (name));
			offset += length;
		}

		static int GetZeroTerminatedStringLength (string @string)
		{
			return (@string.Length + 1 + 3) & ~3;
		}

		static byte [] GetZeroTerminatedString (string @string)
		{
			return GetString (@string, GetZeroTerminatedStringLength (@string));
		}

		static byte [] GetSimpleString (string @string)
		{
			return GetString (@string, @string.Length);
		}

		static byte [] GetString (string @string, int length)
		{
			var bytes = new byte [length];
			for (int i = 0; i < @string.Length; i++)
				bytes [i] = (byte)@string [i];

			return bytes;
		}

		public void WriteMetadata ()
		{
			WriteHeap (TextSegment.TableHeap, metadata.table_heap);
			WriteHeap (TextSegment.StringHeap, metadata.string_heap);
			WriteHeap (TextSegment.UserStringHeap, metadata.user_string_heap);
			WriteHeap (TextSegment.GuidHeap, metadata.guid_heap);
			WriteHeap (TextSegment.BlobHeap, metadata.blob_heap);
			WriteHeap (TextSegment.PdbHeap, metadata.pdb_heap);
		}

		void WriteHeap (TextSegment heap, HeapBuffer buffer)
		{
			if (buffer == null || buffer.IsEmpty)
				return;

			MoveToRVA (heap);
			WriteBuffer (buffer);
		}

		void WriteDebugDirectory ()
		{
			var data_start = (int)BaseStream.Position + (debug_header.Entries.Length * ImageDebugDirectory.Size);

			for (var i = 0; i < debug_header.Entries.Length; i++) {
				var entry = debug_header.Entries [i];
				var directory = entry.Directory;
				WriteInt32 (directory.Characteristics);
				WriteInt32 (directory.TimeDateStamp);
				WriteInt16 (directory.MajorVersion);
				WriteInt16 (directory.MinorVersion);
				WriteInt32 ((int)directory.Type);
				WriteInt32 (directory.SizeOfData);
				WriteInt32 (directory.AddressOfRawData);
				WriteInt32 (data_start);

				data_start += entry.Data.Length;
			}

			for (var i = 0; i < debug_header.Entries.Length; i++) {
				var entry = debug_header.Entries [i];
				WriteBytes (entry.Data);
			}
		}

		void WriteImportDirectory ()
		{
			WriteUInt32 (text_map.GetRVA (TextSegment.ImportDirectory) + 40);   // ImportLookupTable
			WriteUInt32 (0);    // DateTimeStamp
			WriteUInt32 (0);    // ForwarderChain
			WriteUInt32 (text_map.GetRVA (TextSegment.ImportHintNameTable) + 14);
			WriteUInt32 (text_map.GetRVA (TextSegment.ImportAddressTable));
			Advance (20);

			// ImportLookupTable
			WriteUInt32 (text_map.GetRVA (TextSegment.ImportHintNameTable));

			// ImportHintNameTable
			MoveToRVA (TextSegment.ImportHintNameTable);

			WriteUInt16 (0);    // Hint
			WriteBytes (GetRuntimeMain ());
			WriteByte (0);
			WriteBytes (GetSimpleString ("mscoree.dll"));
			WriteUInt16 (0);
		}

		byte [] GetRuntimeMain ()
		{
			return module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule
				? GetSimpleString ("_CorDllMain")
				: GetSimpleString ("_CorExeMain");
		}

		void WriteStartupStub ()
		{
			switch (module.Architecture) {
			case TargetArchitecture.I386:
				WriteUInt16 (0x25ff);
				WriteUInt32 ((uint)image_base + text_map.GetRVA (TextSegment.ImportAddressTable));
				return;
			default:
				throw new NotSupportedException ();
			}
		}

		void WriteRsrc ()
		{
			PrepareSection (rsrc);
			WriteBuffer (win32_resources);
		}

		void WriteReloc ()
		{
			PrepareSection (reloc);

			var reloc_rva = text_map.GetRVA (TextSegment.StartupStub);
			reloc_rva += module.Architecture == TargetArchitecture.IA64 ? 0x20u : 2;
			var page_rva = reloc_rva & ~0xfffu;

			WriteUInt32 (page_rva); // PageRVA
			WriteUInt32 (0x000c);   // Block Size

			switch (module.Architecture) {
			case TargetArchitecture.I386:
				WriteUInt32 (0x3000 + reloc_rva - page_rva);
				break;
			default:
				throw new NotSupportedException ();
			}
		}

		public void WriteImage ()
		{
			WriteDOSHeader ();
			WritePEFileHeader ();
			WriteOptionalHeaders ();
			WriteSectionHeaders ();
			WriteText ();
			if (rsrc != null)
				WriteRsrc ();
			if (reloc != null)
				WriteReloc ();
			Flush ();
		}

		void BuildTextMap ()
		{
			var map = text_map;

			map.AddMap (TextSegment.Code, metadata.code.length, !pe64 ? 4 : 16);
			map.AddMap (TextSegment.Resources, metadata.resources.length, 8);
			map.AddMap (TextSegment.Data, metadata.data.length, 4);
			if (metadata.data.length > 0)
				metadata.table_heap.FixupData (map.GetRVA (TextSegment.Data));
			map.AddMap (TextSegment.StrongNameSignature, GetStrongNameLength (), 4);

			BuildMetadataTextMap ();

			int debug_dir_len = 0;
			if (debug_header != null && debug_header.HasEntries) {
				var directories_len = debug_header.Entries.Length * ImageDebugDirectory.Size;
				var data_address = (int)map.GetNextRVA (TextSegment.BlobHeap) + directories_len;
				var data_len = 0;

				for (var i = 0; i < debug_header.Entries.Length; i++) {
					var entry = debug_header.Entries [i];
					var directory = entry.Directory;

					directory.AddressOfRawData = entry.Data.Length == 0 ? 0 : data_address;
					entry.Directory = directory;

					data_len += entry.Data.Length;
					data_address += data_len;
				}

				debug_dir_len = directories_len + data_len;
			}

			map.AddMap (TextSegment.DebugDirectory, debug_dir_len, 4);

			if (!has_reloc) {
				var start = map.GetNextRVA (TextSegment.DebugDirectory);
				map.AddMap (TextSegment.ImportDirectory, new Range (start, 0));
				map.AddMap (TextSegment.ImportHintNameTable, new Range (start, 0));
				map.AddMap (TextSegment.StartupStub, new Range (start, 0));
				return;
			}

			RVA import_dir_rva = map.GetNextRVA (TextSegment.DebugDirectory);
			RVA import_hnt_rva = import_dir_rva + 48u;
			import_hnt_rva = (import_hnt_rva + 15u) & ~15u;
			uint import_dir_len = (import_hnt_rva - import_dir_rva) + 27u;

			RVA startup_stub_rva = import_dir_rva + import_dir_len;
			startup_stub_rva = module.Architecture == TargetArchitecture.IA64
				? (startup_stub_rva + 15u) & ~15u
				: 2 + ((startup_stub_rva + 3u) & ~3u);

			map.AddMap (TextSegment.ImportDirectory, new Range (import_dir_rva, import_dir_len));
			map.AddMap (TextSegment.ImportHintNameTable, new Range (import_hnt_rva, 0));
			map.AddMap (TextSegment.StartupStub, new Range (startup_stub_rva, GetStartupStubLength ()));
		}

		public void BuildMetadataTextMap ()
		{
			var map = text_map;

			map.AddMap (TextSegment.MetadataHeader, GetMetadataHeaderLength (module.RuntimeVersion));
			map.AddMap (TextSegment.TableHeap, metadata.table_heap.length, 4);
			map.AddMap (TextSegment.StringHeap, metadata.string_heap.length, 4);
			map.AddMap (TextSegment.UserStringHeap, metadata.user_string_heap.IsEmpty ? 0 : metadata.user_string_heap.length, 4);
			map.AddMap (TextSegment.GuidHeap, metadata.guid_heap.length, 4);
			map.AddMap (TextSegment.BlobHeap, metadata.blob_heap.IsEmpty ? 0 : metadata.blob_heap.length, 4);
			map.AddMap (TextSegment.PdbHeap, metadata.pdb_heap == null ? 0 : metadata.pdb_heap.length, 4);
		}

		uint GetStartupStubLength ()
		{
			switch (module.Architecture) {
			case TargetArchitecture.I386:
				return 6;
			default:
				throw new NotSupportedException ();
			}
		}

		int GetMetadataHeaderLength (string runtimeVersion)
		{
			return
				// MetadataHeader
				20 + GetZeroTerminatedStringLength (runtimeVersion)
				// #~ header
				+ 12
				// #Strings header
				+ 20
				// #US header
				+ (metadata.user_string_heap.IsEmpty ? 0 : 12)
				// #GUID header
				+ 16
				// #Blob header
				+ (metadata.blob_heap.IsEmpty ? 0 : 16)
				//
				+ (metadata.pdb_heap == null ? 0 : 16);
		}

		int GetStrongNameLength ()
		{
			if (module.kind == ModuleKind.NetModule || module.Assembly == null)
				return 0;

			var public_key = module.Assembly.Name.PublicKey;
			if (public_key.IsNullOrEmpty ())
				return 0;

			// in fx 2.0 the key may be from 384 to 16384 bits
			// so we must calculate the signature size based on
			// the size of the public key (minus the 32 byte header)
			int size = public_key.Length;
			if (size > 32)
				return size - 32;

			// note: size == 16 for the ECMA "key" which is replaced
			// by the runtime with a 1024 bits key (128 bytes)

			return 128; // default strongname signature size
		}

		public DataDirectory GetStrongNameSignatureDirectory ()
		{
			return text_map.GetDataDirectory (TextSegment.StrongNameSignature);
		}

		public uint GetHeaderSize ()
		{
			return pe_header_size + SizeOfOptionalHeader () + (sections * section_header_size);
		}

		void PatchWin32Resources (ByteBuffer resources)
		{
			PatchResourceDirectoryTable (resources);
		}

		void PatchResourceDirectoryTable (ByteBuffer resources)
		{
			resources.Advance (12);

			var entries = resources.ReadUInt16 () + resources.ReadUInt16 ();

			for (int i = 0; i < entries; i++)
				PatchResourceDirectoryEntry (resources);
		}

		void PatchResourceDirectoryEntry (ByteBuffer resources)
		{
			resources.Advance (4);
			var child = resources.ReadUInt32 ();

			var position = resources.position;
			resources.position = (int)child & 0x7fffffff;

			if ((child & 0x80000000) != 0)
				PatchResourceDirectoryTable (resources);
			else
				PatchResourceDataEntry (resources);

			resources.position = position;
		}

		void PatchResourceDataEntry (ByteBuffer resources)
		{
			var rva = resources.ReadUInt32 ();
			resources.position -= 4;

			resources.WriteUInt32 (rva - module.Image.Win32Resources.VirtualAddress + rsrc.VirtualAddress);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/Section.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using RVA = System.UInt32;

namespace MonoFN.Cecil.PE {

	sealed class Section {
		public string Name;
		public RVA VirtualAddress;
		public uint VirtualSize;
		public uint SizeOfRawData;
		public uint PointerToRawData;
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil.PE/TextMap.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using RVA = System.UInt32;

namespace MonoFN.Cecil.PE {

	enum TextSegment {
		ImportAddressTable,
		CLIHeader,
		Code,
		Resources,
		Data,
		StrongNameSignature,

		// Metadata
		MetadataHeader,
		TableHeap,
		StringHeap,
		UserStringHeap,
		GuidHeap,
		BlobHeap,
		PdbHeap,
		// End Metadata

		DebugDirectory,
		ImportDirectory,
		ImportHintNameTable,
		StartupStub,
	}

	sealed class TextMap {

		readonly Range [] map = new Range [17 /*Enum.GetValues (typeof (TextSegment)).Length*/];

		public void AddMap (TextSegment segment, int length)
		{
			map [(int)segment] = new Range (GetStart (segment), (uint)length);
		}

		public void AddMap (TextSegment segment, int length, int align)
		{
			align--;

			AddMap (segment, (length + align) & ~align);
		}

		public void AddMap (TextSegment segment, Range range)
		{
			map [(int)segment] = range;
		}

		public Range GetRange (TextSegment segment)
		{
			return map [(int)segment];
		}

		public DataDirectory GetDataDirectory (TextSegment segment)
		{
			var range = map [(int)segment];

			return new DataDirectory (range.Length == 0 ? 0 : range.Start, range.Length);
		}

		public RVA GetRVA (TextSegment segment)
		{
			return map [(int)segment].Start;
		}

		public RVA GetNextRVA (TextSegment segment)
		{
			var i = (int)segment;
			return map [i].Start + map [i].Length;
		}

		public int GetLength (TextSegment segment)
		{
			return (int)map [(int)segment].Length;
		}

		RVA GetStart (TextSegment segment)
		{
			var index = (int)segment;
			return index == 0 ? ImageWriter.text_rva : ComputeStart (index);
		}

		RVA ComputeStart (int index)
		{
			index--;
			return map [index].Start + map [index].Length;
		}

		public uint GetLength ()
		{
			var range = map [(int)TextSegment.StartupStub];
			return range.Start - ImageWriter.text_rva + range.Length;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ArrayType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Text;
using System.Threading;
using MD = MonoFN.Cecil.Metadata;

namespace MonoFN.Cecil {

	public struct ArrayDimension {

		int? lower_bound;
		int? upper_bound;

		public int? LowerBound {
			get { return lower_bound; }
			set { lower_bound = value; }
		}

		public int? UpperBound {
			get { return upper_bound; }
			set { upper_bound = value; }
		}

		public bool IsSized {
			get { return lower_bound.HasValue || upper_bound.HasValue; }
		}

		public ArrayDimension (int? lowerBound, int? upperBound)
		{
			this.lower_bound = lowerBound;
			this.upper_bound = upperBound;
		}

		public override string ToString ()
		{
			return !IsSized
				? string.Empty
				: lower_bound + "..." + upper_bound;
		}
	}

	public sealed class ArrayType : TypeSpecification {

		Collection<ArrayDimension> dimensions;

		public Collection<ArrayDimension> Dimensions {
			get {
				if (dimensions != null)
					return dimensions;

				var empty_dimensions = new Collection<ArrayDimension> ();
				empty_dimensions.Add (new ArrayDimension ());

				Interlocked.CompareExchange (ref dimensions, empty_dimensions, null);

				return dimensions;
			}
		}

		public int Rank {
			get { return dimensions == null ? 1 : dimensions.Count; }
		}

		public bool IsVector {
			get {
				if (dimensions == null)
					return true;

				if (dimensions.Count > 1)
					return false;

				var dimension = dimensions [0];

				return !dimension.IsSized;
			}
		}

		public override bool IsValueType {
			get { return false; }
			set { throw new InvalidOperationException (); }
		}

		public override string Name {
			get { return base.Name + Suffix; }
		}

		public override string FullName {
			get { return base.FullName + Suffix; }
		}

		string Suffix {
			get {
				if (IsVector)
					return "[]";

				var suffix = new StringBuilder ();
				suffix.Append ("[");
				for (int i = 0; i < dimensions.Count; i++) {
					if (i > 0)
						suffix.Append (",");

					suffix.Append (dimensions [i].ToString ());
				}
				suffix.Append ("]");

				return suffix.ToString ();
			}
		}

		public override bool IsArray {
			get { return true; }
		}

		public ArrayType (TypeReference type)
			: base (type)
		{
			Mixin.CheckType (type);
			this.etype = MD.ElementType.Array;
		}

		public ArrayType (TypeReference type, int rank)
			: this (type)
		{
			Mixin.CheckType (type);

			if (rank == 1)
				return;

			dimensions = new Collection<ArrayDimension> (rank);
			for (int i = 0; i < rank; i++)
				dimensions.Add (new ArrayDimension ());
			this.etype = MD.ElementType.Array;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.IO;
using System.Threading;

namespace MonoFN.Cecil {

	public sealed class AssemblyDefinition : ICustomAttributeProvider, ISecurityDeclarationProvider, IDisposable {

		AssemblyNameDefinition name;

		internal ModuleDefinition main_module;
		Collection<ModuleDefinition> modules;
		Collection<CustomAttribute> custom_attributes;
		Collection<SecurityDeclaration> security_declarations;

		public AssemblyNameDefinition Name {
			get { return name; }
			set { name = value; }
		}

		public string FullName {
			get { return name != null ? name.FullName : string.Empty; }
		}

		public MetadataToken MetadataToken {
			get { return new MetadataToken (TokenType.Assembly, 1); }
			set { }
		}

		public Collection<ModuleDefinition> Modules {
			get {
				if (modules != null)
					return modules;

				if (main_module.HasImage)
					return main_module.Read (ref modules, this, (_, reader) => reader.ReadModules ());

				Interlocked.CompareExchange (ref modules, new Collection<ModuleDefinition> (1) { main_module }, null);
				return modules;
			}
		}

		public ModuleDefinition MainModule {
			get { return main_module; }
		}

		public MethodDefinition EntryPoint {
			get { return main_module.EntryPoint; }
			set { main_module.EntryPoint = value; }
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (main_module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, main_module)); }
		}

		public bool HasSecurityDeclarations {
			get {
				if (security_declarations != null)
					return security_declarations.Count > 0;

				return this.GetHasSecurityDeclarations (main_module);
			}
		}

		public Collection<SecurityDeclaration> SecurityDeclarations {
			get { return security_declarations ?? (this.GetSecurityDeclarations (ref security_declarations, main_module)); }
		}

		internal AssemblyDefinition ()
		{
		}

		public void Dispose ()
		{
			if (this.modules == null) {
				main_module.Dispose ();
				return;
			}

			var modules = this.Modules;
			for (int i = 0; i < modules.Count; i++)
				modules [i].Dispose ();
		}
		public static AssemblyDefinition CreateAssembly (AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind)
		{
			return CreateAssembly (assemblyName, moduleName, new ModuleParameters { Kind = kind });
		}

		public static AssemblyDefinition CreateAssembly (AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters)
		{
			if (assemblyName == null)
				throw new ArgumentNullException ("assemblyName");
			if (moduleName == null)
				throw new ArgumentNullException ("moduleName");
			Mixin.CheckParameters (parameters);
			if (parameters.Kind == ModuleKind.NetModule)
				throw new ArgumentException ("kind");

			var assembly = ModuleDefinition.CreateModule (moduleName, parameters).Assembly;
			assembly.Name = assemblyName;

			return assembly;
		}

		public static AssemblyDefinition ReadAssembly (string fileName)
		{
			return ReadAssembly (ModuleDefinition.ReadModule (fileName));
		}

		public static AssemblyDefinition ReadAssembly (string fileName, ReaderParameters parameters)
		{
			return ReadAssembly (ModuleDefinition.ReadModule (fileName, parameters));
		}

		public static AssemblyDefinition ReadAssembly (Stream stream)
		{
			return ReadAssembly (ModuleDefinition.ReadModule (stream));
		}

		public static AssemblyDefinition ReadAssembly (Stream stream, ReaderParameters parameters)
		{
			return ReadAssembly (ModuleDefinition.ReadModule (stream, parameters));
		}

		static AssemblyDefinition ReadAssembly (ModuleDefinition module)
		{
			var assembly = module.Assembly;
			if (assembly == null)
				throw new ArgumentException ();

			return assembly;
		}

		public void Write (string fileName)
		{
			Write (fileName, new WriterParameters ());
		}

		public void Write (string fileName, WriterParameters parameters)
		{
			main_module.Write (fileName, parameters);
		}

		public void Write ()
		{
			main_module.Write ();
		}

		public void Write (WriterParameters parameters)
		{
			main_module.Write (parameters);
		}

		public void Write (Stream stream)
		{
			Write (stream, new WriterParameters ());
		}

		public void Write (Stream stream, WriterParameters parameters)
		{
			main_module.Write (stream, parameters);
		}

		public override string ToString ()
		{
			return this.FullName;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyFlags.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum AssemblyAttributes : uint {
		PublicKey = 0x0001,
		SideBySideCompatible = 0x0000,
		Retargetable = 0x0100,
		WindowsRuntime = 0x0200,
		DisableJITCompileOptimizer = 0x4000,
		EnableJITCompileTracking = 0x8000,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyHashAlgorithm.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public enum AssemblyHashAlgorithm : uint {
		None = 0x0000,
		MD5 = 0x8003,
		SHA1 = 0x8004,
		SHA256 = 0x800C,
		SHA384 = 0x800D,
		SHA512 = 0x800E,
		Reserved = 0x8003, // MD5
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyInfo.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle (Consts.AssemblyName)]

[assembly: Guid ("fd225bb4-fa53-44b2-a6db-85f5e48dcb54")]

[assembly: InternalsVisibleTo ("MonoFN.Cecil.Tests, PublicKey=" + Consts.PublicKey)]
[assembly: InternalsVisibleTo ("MonoFN.Cecil.Pdb, PublicKey=" + Consts.PublicKey)]
[assembly: InternalsVisibleTo ("MonoFN.Cecil.Mdb, PublicKey=" + Consts.PublicKey)]
[assembly: InternalsVisibleTo ("MonoFN.Cecil.Rocks, PublicKey=" + Consts.PublicKey)]

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyLinkedResource.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public sealed class AssemblyLinkedResource : Resource {

		AssemblyNameReference reference;

		public AssemblyNameReference Assembly {
			get { return reference; }
			set { reference = value; }
		}

		public override ResourceType ResourceType {
			get { return ResourceType.AssemblyLinked; }
		}

		public AssemblyLinkedResource (string name, ManifestResourceAttributes flags)
			: base (name, flags)
		{
		}

		public AssemblyLinkedResource (string name, ManifestResourceAttributes flags, AssemblyNameReference reference)
			: base (name, flags)
		{
			this.reference = reference;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyNameDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	public sealed class AssemblyNameDefinition : AssemblyNameReference {

		public override byte [] Hash {
			get { return Empty<byte>.Array; }
		}

		internal AssemblyNameDefinition ()
		{
			this.token = new MetadataToken (TokenType.Assembly, 1);
		}

		public AssemblyNameDefinition (string name, Version version)
			: base (name, version)
		{
			this.token = new MetadataToken (TokenType.Assembly, 1);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyNameReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace MonoFN.Cecil {

	public class AssemblyNameReference : IMetadataScope {

		string name;
		string culture;
		Version version;
		uint attributes;
		byte [] public_key;
		byte [] public_key_token;
		AssemblyHashAlgorithm hash_algorithm;
		byte [] hash;

		internal MetadataToken token;

		string full_name;

		public string Name {
			get { return name; }
			set {
				name = value;
				full_name = null;
			}
		}

		public string Culture {
			get { return culture; }
			set {
				culture = value;
				full_name = null;
			}
		}

		public Version Version {
			get { return version; }
			set {
				version = Mixin.CheckVersion (value);
				full_name = null;
			}
		}

		public AssemblyAttributes Attributes {
			get { return (AssemblyAttributes)attributes; }
			set { attributes = (uint)value; }
		}

		public bool HasPublicKey {
			get { return attributes.GetAttributes ((uint)AssemblyAttributes.PublicKey); }
			set { attributes = attributes.SetAttributes ((uint)AssemblyAttributes.PublicKey, value); }
		}

		public bool IsSideBySideCompatible {
			get { return attributes.GetAttributes ((uint)AssemblyAttributes.SideBySideCompatible); }
			set { attributes = attributes.SetAttributes ((uint)AssemblyAttributes.SideBySideCompatible, value); }
		}

		public bool IsRetargetable {
			get { return attributes.GetAttributes ((uint)AssemblyAttributes.Retargetable); }
			set { attributes = attributes.SetAttributes ((uint)AssemblyAttributes.Retargetable, value); }
		}

		public bool IsWindowsRuntime {
			get { return attributes.GetAttributes ((uint)AssemblyAttributes.WindowsRuntime); }
			set { attributes = attributes.SetAttributes ((uint)AssemblyAttributes.WindowsRuntime, value); }
		}

		public byte [] PublicKey {
			get { return public_key ?? Empty<byte>.Array; }
			set {
				public_key = value;
				HasPublicKey = !public_key.IsNullOrEmpty ();
				public_key_token = null;
				full_name = null;
			}
		}

		public byte [] PublicKeyToken {
			get {
				if (public_key_token == null && !public_key.IsNullOrEmpty ()) {
					var hash = HashPublicKey ();
					// we need the last 8 bytes in reverse order
					var local_public_key_token = new byte [8];
					Array.Copy (hash, (hash.Length - 8), local_public_key_token, 0, 8);
					Array.Reverse (local_public_key_token, 0, 8);
					Interlocked.CompareExchange (ref public_key_token, local_public_key_token, null); // publish only once finished (required for thread-safety)
				}
				return public_key_token ?? Empty<byte>.Array;
			}
			set {
				public_key_token = value;
				full_name = null;
			}
		}

		byte [] HashPublicKey ()
		{
			HashAlgorithm algorithm;

			switch (hash_algorithm) {
			case AssemblyHashAlgorithm.Reserved:
				algorithm = MD5.Create ();
				break;
			default:
				// None default to SHA1
				algorithm = SHA1.Create ();
				break;
			}

			using (algorithm)
				return algorithm.ComputeHash (public_key);
		}

		public virtual MetadataScopeType MetadataScopeType {
			get { return MetadataScopeType.AssemblyNameReference; }
		}

		public string FullName {
			get {
				if (full_name != null)
					return full_name;

				const string sep = ", ";

				var builder = new StringBuilder ();
				builder.Append (name);
				builder.Append (sep);
				builder.Append ("Version=");
				builder.Append (version.ToString (fieldCount: 4));
				builder.Append (sep);
				builder.Append ("Culture=");
				builder.Append (string.IsNullOrEmpty (culture) ? "neutral" : culture);
				builder.Append (sep);
				builder.Append ("PublicKeyToken=");

				var pk_token = PublicKeyToken;
				if (!pk_token.IsNullOrEmpty () && pk_token.Length > 0) {
					for (int i = 0; i < pk_token.Length; i++) {
						builder.Append (pk_token [i].ToString ("x2"));
					}
				} else
					builder.Append ("null");

				if (IsRetargetable) {
					builder.Append (sep);
					builder.Append ("Retargetable=Yes");
				}

				Interlocked.CompareExchange (ref full_name, builder.ToString (), null);

				return full_name;
			}
		}

		public static AssemblyNameReference Parse (string fullName)
		{
			if (fullName == null)
				throw new ArgumentNullException ("fullName");
			if (fullName.Length == 0)
				throw new ArgumentException ("Name can not be empty");

			var name = new AssemblyNameReference ();
			var tokens = fullName.Split (',');
			for (int i = 0; i < tokens.Length; i++) {
				var token = tokens [i].Trim ();

				if (i == 0) {
					name.Name = token;
					continue;
				}

				var parts = token.Split ('=');
				if (parts.Length != 2)
					throw new ArgumentException ("Malformed name");

				switch (parts [0].ToLowerInvariant ()) {
				case "version":
					name.Version = new Version (parts [1]);
					break;
				case "culture":
					name.Culture = parts [1] == "neutral" ? "" : parts [1];
					break;
				case "publickeytoken":
					var pk_token = parts [1];
					if (pk_token == "null")
						break;

					name.PublicKeyToken = new byte [pk_token.Length / 2];
					for (int j = 0; j < name.PublicKeyToken.Length; j++)
						name.PublicKeyToken [j] = Byte.Parse (pk_token.Substring (j * 2, 2), NumberStyles.HexNumber);

					break;
				}
			}

			return name;
		}

		public AssemblyHashAlgorithm HashAlgorithm {
			get { return hash_algorithm; }
			set { hash_algorithm = value; }
		}

		public virtual byte [] Hash {
			get { return hash; }
			set { hash = value; }
		}

		public MetadataToken MetadataToken {
			get { return token; }
			set { token = value; }
		}

		internal AssemblyNameReference ()
		{
			this.version = Mixin.ZeroVersion;
			this.token = new MetadataToken (TokenType.AssemblyRef);
		}

		public AssemblyNameReference (string name, Version version)
		{
			Mixin.CheckName (name);

			this.name = name;
			this.version = Mixin.CheckVersion (version);
			this.hash_algorithm = AssemblyHashAlgorithm.None;
			this.token = new MetadataToken (TokenType.AssemblyRef);
		}

		public override string ToString ()
		{
			return this.FullName;
		}
	}

	partial class Mixin {

		public static Version ZeroVersion = new Version (0, 0, 0, 0);

		public static Version CheckVersion (Version version)
		{
			if (version == null)
				return ZeroVersion;

			if (version.Build == -1)
				return new Version (version.Major, version.Minor, 0, 0);

			if (version.Revision == -1)
				return new Version (version.Major, version.Minor, version.Build, 0);

			return version;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyReader.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Metadata;
using MonoFN.Cecil.PE;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;
using RVA = System.UInt32;

namespace MonoFN.Cecil {

	abstract class ModuleReader {

		readonly protected ModuleDefinition module;

		protected ModuleReader (Image image, ReadingMode mode)
		{
			this.module = new ModuleDefinition (image);
			this.module.ReadingMode = mode;
		}

		protected abstract void ReadModule ();
		public abstract void ReadSymbols (ModuleDefinition module);

		protected void ReadModuleManifest (MetadataReader reader)
		{
			reader.Populate (module);

			ReadAssembly (reader);
		}

		void ReadAssembly (MetadataReader reader)
		{
			var name = reader.ReadAssemblyNameDefinition ();
			if (name == null) {
				module.kind = ModuleKind.NetModule;
				return;
			}

			var assembly = new AssemblyDefinition ();
			assembly.Name = name;

			module.assembly = assembly;
			assembly.main_module = module;
		}

		public static ModuleDefinition CreateModule (Image image, ReaderParameters parameters)
		{
			var reader = CreateModuleReader (image, parameters.ReadingMode);
			var module = reader.module;

			if (parameters.assembly_resolver != null)
				module.assembly_resolver = Disposable.NotOwned (parameters.assembly_resolver);

			if (parameters.metadata_resolver != null)
				module.metadata_resolver = parameters.metadata_resolver;

			if (parameters.metadata_importer_provider != null)
				module.metadata_importer = parameters.metadata_importer_provider.GetMetadataImporter (module);

			if (parameters.reflection_importer_provider != null)
				module.reflection_importer = parameters.reflection_importer_provider.GetReflectionImporter (module);

			GetMetadataKind (module, parameters);

			reader.ReadModule ();

			ReadSymbols (module, parameters);

			reader.ReadSymbols (module);

			if (parameters.ReadingMode == ReadingMode.Immediate)
				module.MetadataSystem.Clear ();

			return module;
		}

		static void ReadSymbols (ModuleDefinition module, ReaderParameters parameters)
		{
			var symbol_reader_provider = parameters.SymbolReaderProvider;

			if (symbol_reader_provider == null && parameters.ReadSymbols)
				symbol_reader_provider = new DefaultSymbolReaderProvider ();

			if (symbol_reader_provider != null) {
				module.SymbolReaderProvider = symbol_reader_provider;

				var reader = parameters.SymbolStream != null
					? symbol_reader_provider.GetSymbolReader (module, parameters.SymbolStream)
					: symbol_reader_provider.GetSymbolReader (module, module.FileName);

				if (reader != null) {
					try {
						module.ReadSymbols (reader, parameters.ThrowIfSymbolsAreNotMatching);
					}
					catch (Exception) {
						reader.Dispose ();
						throw;
					}
				}
			}

			if (module.Image.HasDebugTables ())
				module.ReadSymbols (new PortablePdbReader (module.Image, module));
		}

		static void GetMetadataKind (ModuleDefinition module, ReaderParameters parameters)
		{
			if (!parameters.ApplyWindowsRuntimeProjections) {
				module.MetadataKind = MetadataKind.Ecma335;
				return;
			}

			var runtime_version = module.RuntimeVersion;

			if (!runtime_version.Contains ("WindowsRuntime"))
				module.MetadataKind = MetadataKind.Ecma335;
			else if (runtime_version.Contains ("CLR"))
				module.MetadataKind = MetadataKind.ManagedWindowsMetadata;
			else
				module.MetadataKind = MetadataKind.WindowsMetadata;
		}

		static ModuleReader CreateModuleReader (Image image, ReadingMode mode)
		{
			switch (mode) {
			case ReadingMode.Immediate:
				return new ImmediateModuleReader (image);
			case ReadingMode.Deferred:
				return new DeferredModuleReader (image);
			default:
				throw new ArgumentException ();
			}
		}
	}

	sealed class ImmediateModuleReader : ModuleReader {

		bool resolve_attributes;

		public ImmediateModuleReader (Image image)
			: base (image, ReadingMode.Immediate)
		{
		}

		protected override void ReadModule ()
		{
			this.module.Read (this.module, (module, reader) => {
				ReadModuleManifest (reader);
				ReadModule (module, resolve_attributes: true);
			});
		}

		public void ReadModule (ModuleDefinition module, bool resolve_attributes)
		{
			this.resolve_attributes = resolve_attributes;

			if (module.HasAssemblyReferences)
				Mixin.Read (module.AssemblyReferences);
			if (module.HasResources)
				Mixin.Read (module.Resources);
			if (module.HasModuleReferences)
				Mixin.Read (module.ModuleReferences);
			if (module.HasTypes)
				ReadTypes (module.Types);
			if (module.HasExportedTypes)
				Mixin.Read (module.ExportedTypes);

			ReadCustomAttributes (module);

			var assembly = module.Assembly;
			if (module.kind == ModuleKind.NetModule || assembly == null)
				return;

			ReadCustomAttributes (assembly);
			ReadSecurityDeclarations (assembly);
		}

		void ReadTypes (Collection<TypeDefinition> types)
		{
			for (int i = 0; i < types.Count; i++)
				ReadType (types [i]);
		}

		void ReadType (TypeDefinition type)
		{
			ReadGenericParameters (type);

			if (type.HasInterfaces)
				ReadInterfaces (type);

			if (type.HasNestedTypes)
				ReadTypes (type.NestedTypes);

			if (type.HasLayoutInfo)
				Mixin.Read (type.ClassSize);

			if (type.HasFields)
				ReadFields (type);

			if (type.HasMethods)
				ReadMethods (type);

			if (type.HasProperties)
				ReadProperties (type);

			if (type.HasEvents)
				ReadEvents (type);

			ReadSecurityDeclarations (type);
			ReadCustomAttributes (type);
		}

		void ReadInterfaces (TypeDefinition type)
		{
			var interfaces = type.Interfaces;

			for (int i = 0; i < interfaces.Count; i++)
				ReadCustomAttributes (interfaces [i]);
		}

		void ReadGenericParameters (IGenericParameterProvider provider)
		{
			if (!provider.HasGenericParameters)
				return;

			var parameters = provider.GenericParameters;

			for (int i = 0; i < parameters.Count; i++) {
				var parameter = parameters [i];

				if (parameter.HasConstraints)
					ReadGenericParameterConstraints (parameter);

				ReadCustomAttributes (parameter);
			}
		}

		void ReadGenericParameterConstraints (GenericParameter parameter)
		{
			var constraints = parameter.Constraints;

			for (int i = 0; i < constraints.Count; i++)
				ReadCustomAttributes (constraints [i]);
		}

		void ReadSecurityDeclarations (ISecurityDeclarationProvider provider)
		{
			if (!provider.HasSecurityDeclarations)
				return;

			var security_declarations = provider.SecurityDeclarations;

			if (!resolve_attributes)
				return;

			for (int i = 0; i < security_declarations.Count; i++) {
				var security_declaration = security_declarations [i];

				Mixin.Read (security_declaration.SecurityAttributes);
			}
		}

		void ReadCustomAttributes (ICustomAttributeProvider provider)
		{
			if (!provider.HasCustomAttributes)
				return;

			var custom_attributes = provider.CustomAttributes;

			if (!resolve_attributes)
				return;

			for (int i = 0; i < custom_attributes.Count; i++) {
				var custom_attribute = custom_attributes [i];

				Mixin.Read (custom_attribute.ConstructorArguments);
			}
		}

		void ReadFields (TypeDefinition type)
		{
			var fields = type.Fields;

			for (int i = 0; i < fields.Count; i++) {
				var field = fields [i];

				if (field.HasConstant)
					Mixin.Read (field.Constant);

				if (field.HasLayoutInfo)
					Mixin.Read (field.Offset);

				if (field.RVA > 0)
					Mixin.Read (field.InitialValue);

				if (field.HasMarshalInfo)
					Mixin.Read (field.MarshalInfo);

				ReadCustomAttributes (field);
			}
		}

		void ReadMethods (TypeDefinition type)
		{
			var methods = type.Methods;

			for (int i = 0; i < methods.Count; i++) {
				var method = methods [i];

				ReadGenericParameters (method);

				if (method.HasParameters)
					ReadParameters (method);

				if (method.HasOverrides)
					Mixin.Read (method.Overrides);

				if (method.IsPInvokeImpl)
					Mixin.Read (method.PInvokeInfo);

				ReadSecurityDeclarations (method);
				ReadCustomAttributes (method);

				var return_type = method.MethodReturnType;
				if (return_type.HasConstant)
					Mixin.Read (return_type.Constant);

				if (return_type.HasMarshalInfo)
					Mixin.Read (return_type.MarshalInfo);

				ReadCustomAttributes (return_type);
			}
		}

		void ReadParameters (MethodDefinition method)
		{
			var parameters = method.Parameters;

			for (int i = 0; i < parameters.Count; i++) {
				var parameter = parameters [i];

				if (parameter.HasConstant)
					Mixin.Read (parameter.Constant);

				if (parameter.HasMarshalInfo)
					Mixin.Read (parameter.MarshalInfo);

				ReadCustomAttributes (parameter);
			}
		}

		void ReadProperties (TypeDefinition type)
		{
			var properties = type.Properties;

			for (int i = 0; i < properties.Count; i++) {
				var property = properties [i];

				Mixin.Read (property.GetMethod);

				if (property.HasConstant)
					Mixin.Read (property.Constant);

				ReadCustomAttributes (property);
			}
		}

		void ReadEvents (TypeDefinition type)
		{
			var events = type.Events;

			for (int i = 0; i < events.Count; i++) {
				var @event = events [i];

				Mixin.Read (@event.AddMethod);

				ReadCustomAttributes (@event);
			}
		}

		public override void ReadSymbols (ModuleDefinition module)
		{
			if (module.symbol_reader == null)
				return;

			ReadTypesSymbols (module.Types, module.symbol_reader);
		}

		void ReadTypesSymbols (Collection<TypeDefinition> types, ISymbolReader symbol_reader)
		{
			for (int i = 0; i < types.Count; i++) {
				var type = types [i];

				if (type.HasNestedTypes)
					ReadTypesSymbols (type.NestedTypes, symbol_reader);

				if (type.HasMethods)
					ReadMethodsSymbols (type, symbol_reader);
			}
		}

		void ReadMethodsSymbols (TypeDefinition type, ISymbolReader symbol_reader)
		{
			var methods = type.Methods;
			for (int i = 0; i < methods.Count; i++) {
				var method = methods [i];

				if (method.HasBody && method.token.RID != 0 && method.debug_info == null)
					method.debug_info = symbol_reader.Read (method);
			}
		}
	}

	sealed class DeferredModuleReader : ModuleReader {

		public DeferredModuleReader (Image image)
			: base (image, ReadingMode.Deferred)
		{
		}

		protected override void ReadModule ()
		{
			this.module.Read (this.module, (_, reader) => ReadModuleManifest (reader));
		}

		public override void ReadSymbols (ModuleDefinition module)
		{
		}
	}

	sealed class MetadataReader : ByteBuffer {

		readonly internal Image image;
		readonly internal ModuleDefinition module;
		readonly internal MetadataSystem metadata;

		internal CodeReader code;
		internal IGenericContext context;

		readonly MetadataReader metadata_reader;

		public MetadataReader (ModuleDefinition module)
			: base (module.Image.TableHeap.data)
		{
			this.image = module.Image;
			this.module = module;
			this.metadata = module.MetadataSystem;
			this.code = new CodeReader (this);
		}

		public MetadataReader (Image image, ModuleDefinition module, MetadataReader metadata_reader)
			: base (image.TableHeap.data)
		{
			this.image = image;
			this.module = module;
			this.metadata = module.MetadataSystem;
			this.metadata_reader = metadata_reader;
		}

		int GetCodedIndexSize (CodedIndex index)
		{
			return image.GetCodedIndexSize (index);
		}

		uint ReadByIndexSize (int size)
		{
			if (size == 4)
				return ReadUInt32 ();
			else
				return ReadUInt16 ();
		}

		byte [] ReadBlob ()
		{
			var blob_heap = image.BlobHeap;
			if (blob_heap == null) {
				position += 2;
				return Empty<byte>.Array;
			}

			return blob_heap.Read (ReadBlobIndex ());
		}

		byte [] ReadBlob (uint signature)
		{
			var blob_heap = image.BlobHeap;
			if (blob_heap == null)
				return Empty<byte>.Array;

			return blob_heap.Read (signature);
		}

		uint ReadBlobIndex ()
		{
			var blob_heap = image.BlobHeap;
			return ReadByIndexSize (blob_heap != null ? blob_heap.IndexSize : 2);
		}

		void GetBlobView (uint signature, out byte [] blob, out int index, out int count)
		{
			var blob_heap = image.BlobHeap;
			if (blob_heap == null) {
				blob = null;
				index = count = 0;
				return;
			}

			blob_heap.GetView (signature, out blob, out index, out count);
		}

		string ReadString ()
		{
			return image.StringHeap.Read (ReadByIndexSize (image.StringHeap.IndexSize));
		}

		uint ReadStringIndex ()
		{
			return ReadByIndexSize (image.StringHeap.IndexSize);
		}

		Guid ReadGuid ()
		{
			return image.GuidHeap.Read (ReadByIndexSize (image.GuidHeap.IndexSize));
		}

		uint ReadTableIndex (Table table)
		{
			return ReadByIndexSize (image.GetTableIndexSize (table));
		}

		MetadataToken ReadMetadataToken (CodedIndex index)
		{
			return index.GetMetadataToken (ReadByIndexSize (GetCodedIndexSize (index)));
		}

		int MoveTo (Table table)
		{
			var info = image.TableHeap [table];
			if (info.Length != 0)
				this.position = (int)info.Offset;

			return (int)info.Length;
		}

		bool MoveTo (Table table, uint row)
		{
			var info = image.TableHeap [table];
			var length = info.Length;
			if (length == 0 || row > length)
				return false;

			this.position = (int)(info.Offset + (info.RowSize * (row - 1)));
			return true;
		}

		public AssemblyNameDefinition ReadAssemblyNameDefinition ()
		{
			if (MoveTo (Table.Assembly) == 0)
				return null;

			var name = new AssemblyNameDefinition ();

			name.HashAlgorithm = (AssemblyHashAlgorithm)ReadUInt32 ();

			PopulateVersionAndFlags (name);

			name.PublicKey = ReadBlob ();

			PopulateNameAndCulture (name);

			return name;
		}

		public ModuleDefinition Populate (ModuleDefinition module)
		{
			if (MoveTo (Table.Module) == 0)
				return module;

			Advance (2); // Generation

			module.Name = ReadString ();
			module.Mvid = ReadGuid ();

			return module;
		}

		void InitializeAssemblyReferences ()
		{
			if (metadata.AssemblyReferences != null)
				return;

			int length = MoveTo (Table.AssemblyRef);
			var references = metadata.AssemblyReferences = new AssemblyNameReference [length];

			for (uint i = 0; i < length; i++) {
				var reference = new AssemblyNameReference ();
				reference.token = new MetadataToken (TokenType.AssemblyRef, i + 1);

				PopulateVersionAndFlags (reference);

				var key_or_token = ReadBlob ();

				if (reference.HasPublicKey)
					reference.PublicKey = key_or_token;
				else
					reference.PublicKeyToken = key_or_token;

				PopulateNameAndCulture (reference);

				reference.Hash = ReadBlob ();

				references [i] = reference;
			}
		}

		public Collection<AssemblyNameReference> ReadAssemblyReferences ()
		{
			InitializeAssemblyReferences ();

			var references = new Collection<AssemblyNameReference> (metadata.AssemblyReferences);
			if (module.IsWindowsMetadata ())
				module.Projections.AddVirtualReferences (references);

			return references;
		}

		public MethodDefinition ReadEntryPoint ()
		{
			if (module.Image.EntryPointToken == 0)
				return null;

			var token = new MetadataToken (module.Image.EntryPointToken);
			return GetMethodDefinition (token.RID);
		}

		public Collection<ModuleDefinition> ReadModules ()
		{
			var modules = new Collection<ModuleDefinition> (1);
			modules.Add (this.module);

			int length = MoveTo (Table.File);
			for (uint i = 1; i <= length; i++) {
				var attributes = (FileAttributes)ReadUInt32 ();
				var name = ReadString ();
				ReadBlobIndex ();

				if (attributes != FileAttributes.ContainsMetaData)
					continue;

				var parameters = new ReaderParameters {
					ReadingMode = module.ReadingMode,
					SymbolReaderProvider = module.SymbolReaderProvider,
					AssemblyResolver = module.AssemblyResolver
				};

				var netmodule = ModuleDefinition.ReadModule (GetModuleFileName (name), parameters);
				netmodule.assembly = this.module.assembly;

				modules.Add (netmodule);
			}

			return modules;
		}

		string GetModuleFileName (string name)
		{
			if (module.FileName == null)
				throw new NotSupportedException ();

			var path = Path.GetDirectoryName (module.FileName);
			return Path.Combine (path, name);
		}

		void InitializeModuleReferences ()
		{
			if (metadata.ModuleReferences != null)
				return;

			int length = MoveTo (Table.ModuleRef);
			var references = metadata.ModuleReferences = new ModuleReference [length];

			for (uint i = 0; i < length; i++) {
				var reference = new ModuleReference (ReadString ());
				reference.token = new MetadataToken (TokenType.ModuleRef, i + 1);

				references [i] = reference;
			}
		}

		public Collection<ModuleReference> ReadModuleReferences ()
		{
			InitializeModuleReferences ();

			return new Collection<ModuleReference> (metadata.ModuleReferences);
		}

		public bool HasFileResource ()
		{
			int length = MoveTo (Table.File);
			if (length == 0)
				return false;

			for (uint i = 1; i <= length; i++)
				if (ReadFileRecord (i).Col1 == FileAttributes.ContainsNoMetaData)
					return true;

			return false;
		}

		public Collection<Resource> ReadResources ()
		{
			int length = MoveTo (Table.ManifestResource);
			var resources = new Collection<Resource> (length);

			for (int i = 1; i <= length; i++) {
				var offset = ReadUInt32 ();
				var flags = (ManifestResourceAttributes)ReadUInt32 ();
				var name = ReadString ();
				var implementation = ReadMetadataToken (CodedIndex.Implementation);

				Resource resource;

				if (implementation.RID == 0) {
					resource = new EmbeddedResource (name, flags, offset, this);
				} else if (implementation.TokenType == TokenType.AssemblyRef) {
					resource = new AssemblyLinkedResource (name, flags) {
						Assembly = (AssemblyNameReference)GetTypeReferenceScope (implementation),
					};
				} else if (implementation.TokenType == TokenType.File) {
					var file_record = ReadFileRecord (implementation.RID);

					resource = new LinkedResource (name, flags) {
						File = file_record.Col2,
						hash = ReadBlob (file_record.Col3)
					};
				} else
					continue;

				resources.Add (resource);
			}

			return resources;
		}

		Row<FileAttributes, string, uint> ReadFileRecord (uint rid)
		{
			var position = this.position;

			if (!MoveTo (Table.File, rid))
				throw new ArgumentException ();

			var record = new Row<FileAttributes, string, uint> (
				(FileAttributes)ReadUInt32 (),
				ReadString (),
				ReadBlobIndex ());

			this.position = position;

			return record;
		}

		public byte [] GetManagedResource (uint offset)
		{
			return image.GetReaderAt (image.Resources.VirtualAddress, offset, (o, reader) => {
				reader.Advance ((int)o);
				return reader.ReadBytes (reader.ReadInt32 ());
			}) ?? Empty<byte>.Array;
		}

		void PopulateVersionAndFlags (AssemblyNameReference name)
		{
			name.Version = new Version (
				ReadUInt16 (),
				ReadUInt16 (),
				ReadUInt16 (),
				ReadUInt16 ());

			name.Attributes = (AssemblyAttributes)ReadUInt32 ();
		}

		void PopulateNameAndCulture (AssemblyNameReference name)
		{
			name.Name = ReadString ();
			name.Culture = ReadString ();
		}

		public TypeDefinitionCollection ReadTypes ()
		{
			InitializeTypeDefinitions ();
			var mtypes = metadata.Types;
			var type_count = mtypes.Length - metadata.NestedTypes.Count;
			var types = new TypeDefinitionCollection (module, type_count);

			for (int i = 0; i < mtypes.Length; i++) {
				var type = mtypes [i];
				if (IsNested (type.Attributes))
					continue;

				types.Add (type);
			}

			if (image.HasTable (Table.MethodPtr) || image.HasTable (Table.FieldPtr))
				CompleteTypes ();

			return types;
		}

		void CompleteTypes ()
		{
			var types = metadata.Types;

			for (int i = 0; i < types.Length; i++) {
				var type = types [i];

				Mixin.Read (type.Fields);
				Mixin.Read (type.Methods);
			}
		}

		void InitializeTypeDefinitions ()
		{
			if (metadata.Types != null)
				return;

			InitializeNestedTypes ();
			InitializeFields ();
			InitializeMethods ();

			int length = MoveTo (Table.TypeDef);
			var types = metadata.Types = new TypeDefinition [length];

			for (uint i = 0; i < length; i++) {
				if (types [i] != null)
					continue;

				types [i] = ReadType (i + 1);
			}

			if (module.IsWindowsMetadata ()) {
				for (uint i = 0; i < length; i++) {
					WindowsRuntimeProjections.Project (types [i]);
				}
			}
		}

		static bool IsNested (TypeAttributes attributes)
		{
			switch (attributes & TypeAttributes.VisibilityMask) {
			case TypeAttributes.NestedAssembly:
			case TypeAttributes.NestedFamANDAssem:
			case TypeAttributes.NestedFamily:
			case TypeAttributes.NestedFamORAssem:
			case TypeAttributes.NestedPrivate:
			case TypeAttributes.NestedPublic:
				return true;
			default:
				return false;
			}
		}

		public bool HasNestedTypes (TypeDefinition type)
		{
			Collection<uint> mapping;
			InitializeNestedTypes ();

			if (!metadata.TryGetNestedTypeMapping (type, out mapping))
				return false;

			return mapping.Count > 0;
		}

		public Collection<TypeDefinition> ReadNestedTypes (TypeDefinition type)
		{
			InitializeNestedTypes ();
			Collection<uint> mapping;
			if (!metadata.TryGetNestedTypeMapping (type, out mapping))
				return new MemberDefinitionCollection<TypeDefinition> (type);

			var nested_types = new MemberDefinitionCollection<TypeDefinition> (type, mapping.Count);

			for (int i = 0; i < mapping.Count; i++) {
				var nested_type = GetTypeDefinition (mapping [i]);

				if (nested_type != null)
					nested_types.Add (nested_type);
			}

			metadata.RemoveNestedTypeMapping (type);

			return nested_types;
		}

		void InitializeNestedTypes ()
		{
			if (metadata.NestedTypes != null)
				return;

			var length = MoveTo (Table.NestedClass);

			metadata.NestedTypes = new Dictionary<uint, Collection<uint>> (length);
			metadata.ReverseNestedTypes = new Dictionary<uint, uint> (length);

			if (length == 0)
				return;

			for (int i = 1; i <= length; i++) {
				var nested = ReadTableIndex (Table.TypeDef);
				var declaring = ReadTableIndex (Table.TypeDef);

				AddNestedMapping (declaring, nested);
			}
		}

		void AddNestedMapping (uint declaring, uint nested)
		{
			metadata.SetNestedTypeMapping (declaring, AddMapping (metadata.NestedTypes, declaring, nested));
			metadata.SetReverseNestedTypeMapping (nested, declaring);
		}

		static Collection<TValue> AddMapping<TKey, TValue> (Dictionary<TKey, Collection<TValue>> cache, TKey key, TValue value)
		{
			Collection<TValue> mapped;
			if (!cache.TryGetValue (key, out mapped)) {
				mapped = new Collection<TValue> ();
			}
			mapped.Add (value);
			return mapped;
		}

		TypeDefinition ReadType (uint rid)
		{
			if (!MoveTo (Table.TypeDef, rid))
				return null;

			var attributes = (TypeAttributes)ReadUInt32 ();
			var name = ReadString ();
			var @namespace = ReadString ();
			var type = new TypeDefinition (@namespace, name, attributes);
			type.token = new MetadataToken (TokenType.TypeDef, rid);
			type.scope = module;
			type.module = module;

			metadata.AddTypeDefinition (type);

			this.context = type;

			type.BaseType = GetTypeDefOrRef (ReadMetadataToken (CodedIndex.TypeDefOrRef));

			type.fields_range = ReadListRange (rid, Table.TypeDef, Table.Field);
			type.methods_range = ReadListRange (rid, Table.TypeDef, Table.Method);

			if (IsNested (attributes))
				type.DeclaringType = GetNestedTypeDeclaringType (type);

			return type;
		}

		TypeDefinition GetNestedTypeDeclaringType (TypeDefinition type)
		{
			uint declaring_rid;
			if (!metadata.TryGetReverseNestedTypeMapping (type, out declaring_rid))
				return null;

			metadata.RemoveReverseNestedTypeMapping (type);
			return GetTypeDefinition (declaring_rid);
		}

		Range ReadListRange (uint current_index, Table current, Table target)
		{
			var list = new Range ();

			var start = ReadTableIndex (target);
			if (start == 0)
				return list;

			uint next_index;
			var current_table = image.TableHeap [current];

			if (current_index == current_table.Length)
				next_index = image.TableHeap [target].Length + 1;
			else {
				var position = this.position;
				this.position += (int)(current_table.RowSize - image.GetTableIndexSize (target));
				next_index = ReadTableIndex (target);
				this.position = position;
			}

			list.Start = start;
			list.Length = next_index - start;

			return list;
		}

		public Row<short, int> ReadTypeLayout (TypeDefinition type)
		{
			InitializeTypeLayouts ();
			Row<ushort, uint> class_layout;
			var rid = type.token.RID;
			if (!metadata.ClassLayouts.TryGetValue (rid, out class_layout))
				return new Row<short, int> (Mixin.NoDataMarker, Mixin.NoDataMarker);

			type.PackingSize = (short)class_layout.Col1;
			type.ClassSize = (int)class_layout.Col2;

			metadata.ClassLayouts.Remove (rid);

			return new Row<short, int> ((short)class_layout.Col1, (int)class_layout.Col2);
		}

		void InitializeTypeLayouts ()
		{
			if (metadata.ClassLayouts != null)
				return;

			int length = MoveTo (Table.ClassLayout);

			var class_layouts = metadata.ClassLayouts = new Dictionary<uint, Row<ushort, uint>> (length);

			for (uint i = 0; i < length; i++) {
				var packing_size = ReadUInt16 ();
				var class_size = ReadUInt32 ();

				var parent = ReadTableIndex (Table.TypeDef);

				class_layouts.Add (parent, new Row<ushort, uint> (packing_size, class_size));
			}
		}

		public TypeReference GetTypeDefOrRef (MetadataToken token)
		{
			return (TypeReference)LookupToken (token);
		}

		public TypeDefinition GetTypeDefinition (uint rid)
		{
			InitializeTypeDefinitions ();

			var type = metadata.GetTypeDefinition (rid);
			if (type != null)
				return type;

			type = ReadTypeDefinition (rid);

			if (module.IsWindowsMetadata ())
				WindowsRuntimeProjections.Project (type);

			return type;
		}

		TypeDefinition ReadTypeDefinition (uint rid)
		{
			if (!MoveTo (Table.TypeDef, rid))
				return null;

			return ReadType (rid);
		}

		void InitializeTypeReferences ()
		{
			if (metadata.TypeReferences != null)
				return;

			metadata.TypeReferences = new TypeReference [image.GetTableLength (Table.TypeRef)];
		}

		public TypeReference GetTypeReference (string scope, string full_name)
		{
			InitializeTypeReferences ();

			var length = metadata.TypeReferences.Length;

			for (uint i = 1; i <= length; i++) {
				var type = GetTypeReference (i);

				if (type.FullName != full_name)
					continue;

				if (string.IsNullOrEmpty (scope))
					return type;

				if (type.Scope.Name == scope)
					return type;
			}

			return null;
		}

		TypeReference GetTypeReference (uint rid)
		{
			InitializeTypeReferences ();

			var type = metadata.GetTypeReference (rid);
			if (type != null)
				return type;

			return ReadTypeReference (rid);
		}

		TypeReference ReadTypeReference (uint rid)
		{
			if (!MoveTo (Table.TypeRef, rid))
				return null;

			TypeReference declaring_type = null;
			IMetadataScope scope;

			var scope_token = ReadMetadataToken (CodedIndex.ResolutionScope);

			var name = ReadString ();
			var @namespace = ReadString ();

			var type = new TypeReference (
				@namespace,
				name,
				module,
				null);

			type.token = new MetadataToken (TokenType.TypeRef, rid);

			metadata.AddTypeReference (type);

			if (scope_token.TokenType == TokenType.TypeRef) {
				if (scope_token.RID != rid) {
					declaring_type = GetTypeDefOrRef (scope_token);

					scope = declaring_type != null
						? declaring_type.Scope
						: module;
				} else // obfuscated typeref row pointing to self
					scope = module;
			} else
				scope = GetTypeReferenceScope (scope_token);

			type.scope = scope;
			type.DeclaringType = declaring_type;

			MetadataSystem.TryProcessPrimitiveTypeReference (type);

			if (type.Module.IsWindowsMetadata ())
				WindowsRuntimeProjections.Project (type);

			return type;
		}

		IMetadataScope GetTypeReferenceScope (MetadataToken scope)
		{
			if (scope.TokenType == TokenType.Module)
				return module;

			IMetadataScope [] scopes;

			switch (scope.TokenType) {
			case TokenType.AssemblyRef:
				InitializeAssemblyReferences ();
				scopes = metadata.AssemblyReferences;
				break;
			case TokenType.ModuleRef:
				InitializeModuleReferences ();
				scopes = metadata.ModuleReferences;
				break;
			default:
				throw new NotSupportedException ();
			}

			var index = scope.RID - 1;
			if (index < 0 || index >= scopes.Length)
				return null;

			return scopes [index];
		}

		public IEnumerable<TypeReference> GetTypeReferences ()
		{
			InitializeTypeReferences ();

			var length = image.GetTableLength (Table.TypeRef);

			var type_references = new TypeReference [length];

			for (uint i = 1; i <= length; i++)
				type_references [i - 1] = GetTypeReference (i);

			return type_references;
		}

		TypeReference GetTypeSpecification (uint rid)
		{
			if (!MoveTo (Table.TypeSpec, rid))
				return null;

			var reader = ReadSignature (ReadBlobIndex ());
			var type = reader.ReadTypeSignature ();
			if (type.token.RID == 0)
				type.token = new MetadataToken (TokenType.TypeSpec, rid);

			return type;
		}

		SignatureReader ReadSignature (uint signature)
		{
			return new SignatureReader (signature, this);
		}

		public bool HasInterfaces (TypeDefinition type)
		{
			InitializeInterfaces ();
			Collection<Row<uint, MetadataToken>> mapping;

			return metadata.TryGetInterfaceMapping (type, out mapping);
		}

		public InterfaceImplementationCollection ReadInterfaces (TypeDefinition type)
		{
			InitializeInterfaces ();
			Collection<Row<uint, MetadataToken>> mapping;

			if (!metadata.TryGetInterfaceMapping (type, out mapping))
				return new InterfaceImplementationCollection (type);

			var interfaces = new InterfaceImplementationCollection (type, mapping.Count);

			this.context = type;

			for (int i = 0; i < mapping.Count; i++) {
				interfaces.Add (
					new InterfaceImplementation (
						GetTypeDefOrRef (mapping [i].Col2),
						new MetadataToken (TokenType.InterfaceImpl, mapping [i].Col1)));
			}

			metadata.RemoveInterfaceMapping (type);

			return interfaces;
		}

		void InitializeInterfaces ()
		{
			if (metadata.Interfaces != null)
				return;

			int length = MoveTo (Table.InterfaceImpl);

			metadata.Interfaces = new Dictionary<uint, Collection<Row<uint, MetadataToken>>> (length);

			for (uint i = 1; i <= length; i++) {
				var type = ReadTableIndex (Table.TypeDef);
				var @interface = ReadMetadataToken (CodedIndex.TypeDefOrRef);

				AddInterfaceMapping (type, new Row<uint, MetadataToken> (i, @interface));
			}
		}

		void AddInterfaceMapping (uint type, Row<uint, MetadataToken> @interface)
		{
			metadata.SetInterfaceMapping (type, AddMapping (metadata.Interfaces, type, @interface));
		}

		public Collection<FieldDefinition> ReadFields (TypeDefinition type)
		{
			var fields_range = type.fields_range;
			if (fields_range.Length == 0)
				return new MemberDefinitionCollection<FieldDefinition> (type);

			var fields = new MemberDefinitionCollection<FieldDefinition> (type, (int)fields_range.Length);
			this.context = type;

			if (!MoveTo (Table.FieldPtr, fields_range.Start)) {
				if (!MoveTo (Table.Field, fields_range.Start))
					return fields;

				for (uint i = 0; i < fields_range.Length; i++)
					ReadField (fields_range.Start + i, fields);
			} else
				ReadPointers (Table.FieldPtr, Table.Field, fields_range, fields, ReadField);

			return fields;
		}

		void ReadField (uint field_rid, Collection<FieldDefinition> fields)
		{
			var attributes = (FieldAttributes)ReadUInt16 ();
			var name = ReadString ();
			var signature = ReadBlobIndex ();

			var field = new FieldDefinition (name, attributes, ReadFieldType (signature));
			field.token = new MetadataToken (TokenType.Field, field_rid);
			metadata.AddFieldDefinition (field);

			if (IsDeleted (field))
				return;

			fields.Add (field);

			if (module.IsWindowsMetadata ())
				WindowsRuntimeProjections.Project (field);
		}

		void InitializeFields ()
		{
			if (metadata.Fields != null)
				return;

			metadata.Fields = new FieldDefinition [image.GetTableLength (Table.Field)];
		}

		TypeReference ReadFieldType (uint signature)
		{
			var reader = ReadSignature (signature);

			const byte field_sig = 0x6;

			if (reader.ReadByte () != field_sig)
				throw new NotSupportedException ();

			return reader.ReadTypeSignature ();
		}

		public int ReadFieldRVA (FieldDefinition field)
		{
			InitializeFieldRVAs ();
			var rid = field.token.RID;

			RVA rva;
			if (!metadata.FieldRVAs.TryGetValue (rid, out rva))
				return 0;

			var size = GetFieldTypeSize (field.FieldType);

			if (size == 0 || rva == 0)
				return 0;

			metadata.FieldRVAs.Remove (rid);

			field.InitialValue = GetFieldInitializeValue (size, rva);

			return (int)rva;
		}

		byte [] GetFieldInitializeValue (int size, RVA rva)
		{
			return image.GetReaderAt (rva, size, (s, reader) => reader.ReadBytes (s)) ?? Empty<byte>.Array;
		}

		static int GetFieldTypeSize (TypeReference type)
		{
			int size = 0;

			switch (type.etype) {
			case ElementType.Boolean:
			case ElementType.U1:
			case ElementType.I1:
				size = 1;
				break;
			case ElementType.U2:
			case ElementType.I2:
			case ElementType.Char:
				size = 2;
				break;
			case ElementType.U4:
			case ElementType.I4:
			case ElementType.R4:
				size = 4;
				break;
			case ElementType.U8:
			case ElementType.I8:
			case ElementType.R8:
				size = 8;
				break;
			case ElementType.Ptr:
			case ElementType.FnPtr:
				size = IntPtr.Size;
				break;
			case ElementType.CModOpt:
			case ElementType.CModReqD:
				return GetFieldTypeSize (((IModifierType)type).ElementType);
			default:
				var field_type = type.Resolve ();
				if (field_type != null && field_type.HasLayoutInfo)
					size = field_type.ClassSize;

				break;
			}

			return size;
		}

		void InitializeFieldRVAs ()
		{
			if (metadata.FieldRVAs != null)
				return;

			int length = MoveTo (Table.FieldRVA);

			var field_rvas = metadata.FieldRVAs = new Dictionary<uint, uint> (length);

			for (int i = 0; i < length; i++) {
				var rva = ReadUInt32 ();
				var field = ReadTableIndex (Table.Field);

				field_rvas.Add (field, rva);
			}
		}

		public int ReadFieldLayout (FieldDefinition field)
		{
			InitializeFieldLayouts ();
			var rid = field.token.RID;
			uint offset;
			if (!metadata.FieldLayouts.TryGetValue (rid, out offset))
				return Mixin.NoDataMarker;

			metadata.FieldLayouts.Remove (rid);

			return (int)offset;
		}

		void InitializeFieldLayouts ()
		{
			if (metadata.FieldLayouts != null)
				return;

			int length = MoveTo (Table.FieldLayout);

			var field_layouts = metadata.FieldLayouts = new Dictionary<uint, uint> (length);

			for (int i = 0; i < length; i++) {
				var offset = ReadUInt32 ();
				var field = ReadTableIndex (Table.Field);

				field_layouts.Add (field, offset);
			}
		}

		public bool HasEvents (TypeDefinition type)
		{
			InitializeEvents ();

			Range range;
			if (!metadata.TryGetEventsRange (type, out range))
				return false;

			return range.Length > 0;
		}

		public Collection<EventDefinition> ReadEvents (TypeDefinition type)
		{
			InitializeEvents ();
			Range range;

			if (!metadata.TryGetEventsRange (type, out range))
				return new MemberDefinitionCollection<EventDefinition> (type);

			var events = new MemberDefinitionCollection<EventDefinition> (type, (int)range.Length);

			metadata.RemoveEventsRange (type);

			if (range.Length == 0)
				return events;

			this.context = type;

			if (!MoveTo (Table.EventPtr, range.Start)) {
				if (!MoveTo (Table.Event, range.Start))
					return events;

				for (uint i = 0; i < range.Length; i++)
					ReadEvent (range.Start + i, events);
			} else
				ReadPointers (Table.EventPtr, Table.Event, range, events, ReadEvent);

			return events;
		}

		void ReadEvent (uint event_rid, Collection<EventDefinition> events)
		{
			var attributes = (EventAttributes)ReadUInt16 ();
			var name = ReadString ();
			var event_type = GetTypeDefOrRef (ReadMetadataToken (CodedIndex.TypeDefOrRef));

			var @event = new EventDefinition (name, attributes, event_type);
			@event.token = new MetadataToken (TokenType.Event, event_rid);

			if (IsDeleted (@event))
				return;

			events.Add (@event);
		}

		void InitializeEvents ()
		{
			if (metadata.Events != null)
				return;

			int length = MoveTo (Table.EventMap);

			metadata.Events = new Dictionary<uint, Range> (length);

			for (uint i = 1; i <= length; i++) {
				var type_rid = ReadTableIndex (Table.TypeDef);
				Range events_range = ReadListRange (i, Table.EventMap, Table.Event);
				metadata.AddEventsRange (type_rid, events_range);
			}
		}

		public bool HasProperties (TypeDefinition type)
		{
			InitializeProperties ();

			Range range;
			if (!metadata.TryGetPropertiesRange (type, out range))
				return false;

			return range.Length > 0;
		}

		public Collection<PropertyDefinition> ReadProperties (TypeDefinition type)
		{
			InitializeProperties ();

			Range range;

			if (!metadata.TryGetPropertiesRange (type, out range))
				return new MemberDefinitionCollection<PropertyDefinition> (type);

			metadata.RemovePropertiesRange (type);

			var properties = new MemberDefinitionCollection<PropertyDefinition> (type, (int)range.Length);

			if (range.Length == 0)
				return properties;

			this.context = type;

			if (!MoveTo (Table.PropertyPtr, range.Start)) {
				if (!MoveTo (Table.Property, range.Start))
					return properties;
				for (uint i = 0; i < range.Length; i++)
					ReadProperty (range.Start + i, properties);
			} else
				ReadPointers (Table.PropertyPtr, Table.Property, range, properties, ReadProperty);

			return properties;
		}

		void ReadProperty (uint property_rid, Collection<PropertyDefinition> properties)
		{
			var attributes = (PropertyAttributes)ReadUInt16 ();
			var name = ReadString ();
			var signature = ReadBlobIndex ();

			var reader = ReadSignature (signature);
			const byte property_signature = 0x8;

			var calling_convention = reader.ReadByte ();

			if ((calling_convention & property_signature) == 0)
				throw new NotSupportedException ();

			var has_this = (calling_convention & 0x20) != 0;

			reader.ReadCompressedUInt32 (); // count

			var property = new PropertyDefinition (name, attributes, reader.ReadTypeSignature ());
			property.HasThis = has_this;
			property.token = new MetadataToken (TokenType.Property, property_rid);

			if (IsDeleted (property))
				return;

			properties.Add (property);
		}

		void InitializeProperties ()
		{
			if (metadata.Properties != null)
				return;

			int length = MoveTo (Table.PropertyMap);

			metadata.Properties = new Dictionary<uint, Range> (length);

			for (uint i = 1; i <= length; i++) {
				var type_rid = ReadTableIndex (Table.TypeDef);
				var properties_range = ReadListRange (i, Table.PropertyMap, Table.Property);
				metadata.AddPropertiesRange (type_rid, properties_range);
			}
		}

		MethodSemanticsAttributes ReadMethodSemantics (MethodDefinition method)
		{
			InitializeMethodSemantics ();
			Row<MethodSemanticsAttributes, MetadataToken> row;
			if (!metadata.Semantics.TryGetValue (method.token.RID, out row))
				return MethodSemanticsAttributes.None;

			var type = method.DeclaringType;

			switch (row.Col1) {
			case MethodSemanticsAttributes.AddOn:
				GetEvent (type, row.Col2).add_method = method;
				break;
			case MethodSemanticsAttributes.Fire:
				GetEvent (type, row.Col2).invoke_method = method;
				break;
			case MethodSemanticsAttributes.RemoveOn:
				GetEvent (type, row.Col2).remove_method = method;
				break;
			case MethodSemanticsAttributes.Getter:
				GetProperty (type, row.Col2).get_method = method;
				break;
			case MethodSemanticsAttributes.Setter:
				GetProperty (type, row.Col2).set_method = method;
				break;
			case MethodSemanticsAttributes.Other:
				switch (row.Col2.TokenType) {
				case TokenType.Event: {
						var @event = GetEvent (type, row.Col2);
						if (@event.other_methods == null)
							@event.other_methods = new Collection<MethodDefinition> ();

						@event.other_methods.Add (method);
						break;
					}
				case TokenType.Property: {
						var property = GetProperty (type, row.Col2);
						if (property.other_methods == null)
							property.other_methods = new Collection<MethodDefinition> ();

						property.other_methods.Add (method);

						break;
					}
				default:
					throw new NotSupportedException ();
				}
				break;
			default:
				throw new NotSupportedException ();
			}

			metadata.Semantics.Remove (method.token.RID);

			return row.Col1;
		}

		static EventDefinition GetEvent (TypeDefinition type, MetadataToken token)
		{
			if (token.TokenType != TokenType.Event)
				throw new ArgumentException ();

			return GetMember (type.Events, token);
		}

		static PropertyDefinition GetProperty (TypeDefinition type, MetadataToken token)
		{
			if (token.TokenType != TokenType.Property)
				throw new ArgumentException ();

			return GetMember (type.Properties, token);
		}

		static TMember GetMember<TMember> (Collection<TMember> members, MetadataToken token) where TMember : IMemberDefinition
		{
			for (int i = 0; i < members.Count; i++) {
				var member = members [i];
				if (member.MetadataToken == token)
					return member;
			}

			throw new ArgumentException ();
		}

		void InitializeMethodSemantics ()
		{
			if (metadata.Semantics != null)
				return;

			int length = MoveTo (Table.MethodSemantics);

			var semantics = metadata.Semantics = new Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> (0);

			for (uint i = 0; i < length; i++) {
				var attributes = (MethodSemanticsAttributes)ReadUInt16 ();
				var method_rid = ReadTableIndex (Table.Method);
				var association = ReadMetadataToken (CodedIndex.HasSemantics);

				semantics [method_rid] = new Row<MethodSemanticsAttributes, MetadataToken> (attributes, association);
			}
		}

		public void ReadMethods (PropertyDefinition property)
		{
			ReadAllSemantics (property.DeclaringType);
		}

		public void ReadMethods (EventDefinition @event)
		{
			ReadAllSemantics (@event.DeclaringType);
		}

		public void ReadAllSemantics (MethodDefinition method)
		{
			ReadAllSemantics (method.DeclaringType);
		}

		void ReadAllSemantics (TypeDefinition type)
		{
			var methods = type.Methods;
			for (int i = 0; i < methods.Count; i++) {
				var method = methods [i];
				if (method.sem_attrs_ready)
					continue;

				method.sem_attrs = ReadMethodSemantics (method);
				method.sem_attrs_ready = true;
			}
		}

		public Collection<MethodDefinition> ReadMethods (TypeDefinition type)
		{
			var methods_range = type.methods_range;
			if (methods_range.Length == 0)
				return new MemberDefinitionCollection<MethodDefinition> (type);

			var methods = new MemberDefinitionCollection<MethodDefinition> (type, (int)methods_range.Length);
			if (!MoveTo (Table.MethodPtr, methods_range.Start)) {
				if (!MoveTo (Table.Method, methods_range.Start))
					return methods;

				for (uint i = 0; i < methods_range.Length; i++)
					ReadMethod (methods_range.Start + i, methods);
			} else
				ReadPointers (Table.MethodPtr, Table.Method, methods_range, methods, ReadMethod);

			return methods;
		}

		void ReadPointers<TMember> (Table ptr, Table table, Range range, Collection<TMember> members, Action<uint, Collection<TMember>> reader)
			where TMember : IMemberDefinition
		{
			for (uint i = 0; i < range.Length; i++) {
				MoveTo (ptr, range.Start + i);

				var rid = ReadTableIndex (table);
				MoveTo (table, rid);

				reader (rid, members);
			}
		}

		static bool IsDeleted (IMemberDefinition member)
		{
			return member.IsSpecialName && member.Name == "_Deleted";
		}

		void InitializeMethods ()
		{
			if (metadata.Methods != null)
				return;

			metadata.Methods = new MethodDefinition [image.GetTableLength (Table.Method)];
		}

		void ReadMethod (uint method_rid, Collection<MethodDefinition> methods)
		{
			var method = new MethodDefinition ();
			method.rva = ReadUInt32 ();
			method.ImplAttributes = (MethodImplAttributes)ReadUInt16 ();
			method.Attributes = (MethodAttributes)ReadUInt16 ();
			method.Name = ReadString ();
			method.token = new MetadataToken (TokenType.Method, method_rid);

			if (IsDeleted (method))
				return;

			methods.Add (method); // attach method

			var signature = ReadBlobIndex ();
			var param_range = ReadListRange (method_rid, Table.Method, Table.Param);

			this.context = method;

			ReadMethodSignature (signature, method);
			metadata.AddMethodDefinition (method);

			if (param_range.Length != 0) {
				var position = base.position;
				ReadParameters (method, param_range);
				base.position = position;
			}

			if (module.IsWindowsMetadata ())
				WindowsRuntimeProjections.Project (method);
		}

		void ReadParameters (MethodDefinition method, Range param_range)
		{
			if (!MoveTo (Table.ParamPtr, param_range.Start)) {
				if (!MoveTo (Table.Param, param_range.Start))
					return;

				for (uint i = 0; i < param_range.Length; i++)
					ReadParameter (param_range.Start + i, method);
			} else
				ReadParameterPointers (method, param_range);
		}

		void ReadParameterPointers (MethodDefinition method, Range range)
		{
			for (uint i = 0; i < range.Length; i++) {
				MoveTo (Table.ParamPtr, range.Start + i);

				var rid = ReadTableIndex (Table.Param);

				MoveTo (Table.Param, rid);

				ReadParameter (rid, method);
			}
		}

		void ReadParameter (uint param_rid, MethodDefinition method)
		{
			var attributes = (ParameterAttributes)ReadUInt16 ();
			var sequence = ReadUInt16 ();
			var name = ReadString ();

			var parameter = sequence == 0
				? method.MethodReturnType.Parameter
				: method.Parameters [sequence - 1];

			parameter.token = new MetadataToken (TokenType.Param, param_rid);
			parameter.Name = name;
			parameter.Attributes = attributes;
		}

		void ReadMethodSignature (uint signature, IMethodSignature method)
		{
			var reader = ReadSignature (signature);
			reader.ReadMethodSignature (method);
		}

		public PInvokeInfo ReadPInvokeInfo (MethodDefinition method)
		{
			InitializePInvokes ();
			Row<PInvokeAttributes, uint, uint> row;

			var rid = method.token.RID;

			if (!metadata.PInvokes.TryGetValue (rid, out row))
				return null;

			metadata.PInvokes.Remove (rid);

			return new PInvokeInfo (
				row.Col1,
				image.StringHeap.Read (row.Col2),
				module.ModuleReferences [(int)row.Col3 - 1]);
		}

		void InitializePInvokes ()
		{
			if (metadata.PInvokes != null)
				return;

			int length = MoveTo (Table.ImplMap);

			var pinvokes = metadata.PInvokes = new Dictionary<uint, Row<PInvokeAttributes, uint, uint>> (length);

			for (int i = 1; i <= length; i++) {
				var attributes = (PInvokeAttributes)ReadUInt16 ();
				var method = ReadMetadataToken (CodedIndex.MemberForwarded);
				var name = ReadStringIndex ();
				var scope = ReadTableIndex (Table.File);

				if (method.TokenType != TokenType.Method)
					continue;

				pinvokes.Add (method.RID, new Row<PInvokeAttributes, uint, uint> (attributes, name, scope));
			}
		}

		public bool HasGenericParameters (IGenericParameterProvider provider)
		{
			InitializeGenericParameters ();

			Range [] ranges;
			if (!metadata.TryGetGenericParameterRanges (provider, out ranges))
				return false;

			return RangesSize (ranges) > 0;
		}

		public Collection<GenericParameter> ReadGenericParameters (IGenericParameterProvider provider)
		{
			InitializeGenericParameters ();

			Range [] ranges;
			if (!metadata.TryGetGenericParameterRanges (provider, out ranges))
				return new GenericParameterCollection (provider);

			metadata.RemoveGenericParameterRange (provider);

			var generic_parameters = new GenericParameterCollection (provider, RangesSize (ranges));

			for (int i = 0; i < ranges.Length; i++)
				ReadGenericParametersRange (ranges [i], provider, generic_parameters);

			return generic_parameters;
		}

		void ReadGenericParametersRange (Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters)
		{
			if (!MoveTo (Table.GenericParam, range.Start))
				return;

			for (uint i = 0; i < range.Length; i++) {
				ReadUInt16 (); // index
				var flags = (GenericParameterAttributes)ReadUInt16 ();
				ReadMetadataToken (CodedIndex.TypeOrMethodDef);
				var name = ReadString ();

				var parameter = new GenericParameter (name, provider);
				parameter.token = new MetadataToken (TokenType.GenericParam, range.Start + i);
				parameter.Attributes = flags;

				generic_parameters.Add (parameter);
			}
		}

		void InitializeGenericParameters ()
		{
			if (metadata.GenericParameters != null)
				return;

			metadata.GenericParameters = InitializeRanges (
				Table.GenericParam, () => {
					Advance (4);
					var next = ReadMetadataToken (CodedIndex.TypeOrMethodDef);
					ReadStringIndex ();
					return next;
				});
		}

		Dictionary<MetadataToken, Range []> InitializeRanges (Table table, Func<MetadataToken> get_next)
		{
			int length = MoveTo (table);
			var ranges = new Dictionary<MetadataToken, Range []> (length);

			if (length == 0)
				return ranges;

			MetadataToken owner = MetadataToken.Zero;
			Range range = new Range (1, 0);

			for (uint i = 1; i <= length; i++) {
				var next = get_next ();

				if (i == 1) {
					owner = next;
					range.Length++;
				} else if (next != owner) {
					AddRange (ranges, owner, range);
					range = new Range (i, 1);
					owner = next;
				} else
					range.Length++;
			}

			AddRange (ranges, owner, range);

			return ranges;
		}

		static void AddRange (Dictionary<MetadataToken, Range []> ranges, MetadataToken owner, Range range)
		{
			if (owner.RID == 0)
				return;

			Range [] slots;
			if (!ranges.TryGetValue (owner, out slots)) {
				ranges.Add (owner, new [] { range });
				return;
			}

			ranges [owner] = slots.Add (range);
		}

		public bool HasGenericConstraints (GenericParameter generic_parameter)
		{
			InitializeGenericConstraints ();

			Collection<Row<uint, MetadataToken>> mapping;
			if (!metadata.TryGetGenericConstraintMapping (generic_parameter, out mapping))
				return false;

			return mapping.Count > 0;
		}

		public GenericParameterConstraintCollection ReadGenericConstraints (GenericParameter generic_parameter)
		{
			InitializeGenericConstraints ();

			Collection<Row<uint, MetadataToken>> mapping;
			if (!metadata.TryGetGenericConstraintMapping (generic_parameter, out mapping))
				return new GenericParameterConstraintCollection (generic_parameter);

			var constraints = new GenericParameterConstraintCollection (generic_parameter, mapping.Count);

			this.context = (IGenericContext)generic_parameter.Owner;

			for (int i = 0; i < mapping.Count; i++) {
				constraints.Add (
					new GenericParameterConstraint (
						GetTypeDefOrRef (mapping [i].Col2),
						new MetadataToken (TokenType.GenericParamConstraint, mapping [i].Col1)));
			}

			metadata.RemoveGenericConstraintMapping (generic_parameter);

			return constraints;
		}

		void InitializeGenericConstraints ()
		{
			if (metadata.GenericConstraints != null)
				return;

			var length = MoveTo (Table.GenericParamConstraint);

			metadata.GenericConstraints = new Dictionary<uint, Collection<Row<uint, MetadataToken>>> (length);

			for (uint i = 1; i <= length; i++) {
				AddGenericConstraintMapping (
					ReadTableIndex (Table.GenericParam),
					new Row<uint, MetadataToken> (i, ReadMetadataToken (CodedIndex.TypeDefOrRef)));
			}
		}

		void AddGenericConstraintMapping (uint generic_parameter, Row<uint, MetadataToken> constraint)
		{
			metadata.SetGenericConstraintMapping (
				generic_parameter,
				AddMapping (metadata.GenericConstraints, generic_parameter, constraint));
		}

		public bool HasOverrides (MethodDefinition method)
		{
			InitializeOverrides ();
			Collection<MetadataToken> mapping;

			if (!metadata.TryGetOverrideMapping (method, out mapping))
				return false;

			return mapping.Count > 0;
		}

		public Collection<MethodReference> ReadOverrides (MethodDefinition method)
		{
			InitializeOverrides ();

			Collection<MetadataToken> mapping;
			if (!metadata.TryGetOverrideMapping (method, out mapping))
				return new Collection<MethodReference> ();

			var overrides = new Collection<MethodReference> (mapping.Count);

			this.context = method;

			for (int i = 0; i < mapping.Count; i++)
				overrides.Add ((MethodReference)LookupToken (mapping [i]));

			metadata.RemoveOverrideMapping (method);

			return overrides;
		}

		void InitializeOverrides ()
		{
			if (metadata.Overrides != null)
				return;

			var length = MoveTo (Table.MethodImpl);

			metadata.Overrides = new Dictionary<uint, Collection<MetadataToken>> (length);

			for (int i = 1; i <= length; i++) {
				ReadTableIndex (Table.TypeDef);

				var method = ReadMetadataToken (CodedIndex.MethodDefOrRef);
				if (method.TokenType != TokenType.Method)
					throw new NotSupportedException ();

				var @override = ReadMetadataToken (CodedIndex.MethodDefOrRef);

				AddOverrideMapping (method.RID, @override);
			}
		}

		void AddOverrideMapping (uint method_rid, MetadataToken @override)
		{
			metadata.SetOverrideMapping (
				method_rid,
				AddMapping (metadata.Overrides, method_rid, @override));
		}

		public MethodBody ReadMethodBody (MethodDefinition method)
		{
			return code.ReadMethodBody (method);
		}

		public int ReadCodeSize (MethodDefinition method)
		{
			return code.ReadCodeSize (method);
		}

		public CallSite ReadCallSite (MetadataToken token)
		{
			if (!MoveTo (Table.StandAloneSig, token.RID))
				return null;

			var signature = ReadBlobIndex ();

			var call_site = new CallSite ();

			ReadMethodSignature (signature, call_site);

			call_site.MetadataToken = token;

			return call_site;
		}

		public VariableDefinitionCollection ReadVariables (MetadataToken local_var_token, MethodDefinition method = null)
		{
			if (!MoveTo (Table.StandAloneSig, local_var_token.RID))
				return null;

			var reader = ReadSignature (ReadBlobIndex ());
			const byte local_sig = 0x7;

			if (reader.ReadByte () != local_sig)
				throw new NotSupportedException ();

			var count = reader.ReadCompressedUInt32 ();
			if (count == 0)
				return null;

			var variables = new VariableDefinitionCollection (method, (int)count);

			for (int i = 0; i < count; i++)
				variables.Add (new VariableDefinition (reader.ReadTypeSignature ()));

			return variables;
		}

		public IMetadataTokenProvider LookupToken (MetadataToken token)
		{
			var rid = token.RID;

			if (rid == 0)
				return null;

			if (metadata_reader != null)
				return metadata_reader.LookupToken (token);

			IMetadataTokenProvider element;
			var position = this.position;
			var context = this.context;

			switch (token.TokenType) {
			case TokenType.TypeDef:
				element = GetTypeDefinition (rid);
				break;
			case TokenType.TypeRef:
				element = GetTypeReference (rid);
				break;
			case TokenType.TypeSpec:
				element = GetTypeSpecification (rid);
				break;
			case TokenType.Field:
				element = GetFieldDefinition (rid);
				break;
			case TokenType.Method:
				element = GetMethodDefinition (rid);
				break;
			case TokenType.MemberRef:
				element = GetMemberReference (rid);
				break;
			case TokenType.MethodSpec:
				element = GetMethodSpecification (rid);
				break;
			default:
				return null;
			}

			this.position = position;
			this.context = context;

			return element;
		}

		public FieldDefinition GetFieldDefinition (uint rid)
		{
			InitializeTypeDefinitions ();

			var field = metadata.GetFieldDefinition (rid);
			if (field != null)
				return field;

			return LookupField (rid);
		}

		FieldDefinition LookupField (uint rid)
		{
			var type = metadata.GetFieldDeclaringType (rid);
			if (type == null)
				return null;

			Mixin.Read (type.Fields);

			return metadata.GetFieldDefinition (rid);
		}

		public MethodDefinition GetMethodDefinition (uint rid)
		{
			InitializeTypeDefinitions ();

			var method = metadata.GetMethodDefinition (rid);
			if (method != null)
				return method;

			return LookupMethod (rid);
		}

		MethodDefinition LookupMethod (uint rid)
		{
			var type = metadata.GetMethodDeclaringType (rid);
			if (type == null)
				return null;

			Mixin.Read (type.Methods);

			return metadata.GetMethodDefinition (rid);
		}

		MethodSpecification GetMethodSpecification (uint rid)
		{
			if (!MoveTo (Table.MethodSpec, rid))
				return null;

			var element_method = (MethodReference)LookupToken (
				ReadMetadataToken (CodedIndex.MethodDefOrRef));
			var signature = ReadBlobIndex ();

			var method_spec = ReadMethodSpecSignature (signature, element_method);
			method_spec.token = new MetadataToken (TokenType.MethodSpec, rid);
			return method_spec;
		}

		MethodSpecification ReadMethodSpecSignature (uint signature, MethodReference method)
		{
			var reader = ReadSignature (signature);
			const byte methodspec_sig = 0x0a;

			var call_conv = reader.ReadByte ();

			if (call_conv != methodspec_sig)
				throw new NotSupportedException ();

			var arity = reader.ReadCompressedUInt32 ();

			var instance = new GenericInstanceMethod (method, (int)arity);

			reader.ReadGenericInstanceSignature (method, instance, arity);

			return instance;
		}

		MemberReference GetMemberReference (uint rid)
		{
			InitializeMemberReferences ();

			var member = metadata.GetMemberReference (rid);
			if (member != null)
				return member;

			member = ReadMemberReference (rid);
			if (member != null && !member.ContainsGenericParameter)
				metadata.AddMemberReference (member);
			return member;
		}

		MemberReference ReadMemberReference (uint rid)
		{
			if (!MoveTo (Table.MemberRef, rid))
				return null;

			var token = ReadMetadataToken (CodedIndex.MemberRefParent);
			var name = ReadString ();
			var signature = ReadBlobIndex ();

			MemberReference member;

			switch (token.TokenType) {
			case TokenType.TypeDef:
			case TokenType.TypeRef:
			case TokenType.TypeSpec:
				member = ReadTypeMemberReference (token, name, signature);
				break;
			case TokenType.Method:
				member = ReadMethodMemberReference (token, name, signature);
				break;
			default:
				throw new NotSupportedException ();
			}

			member.token = new MetadataToken (TokenType.MemberRef, rid);
			return member;
		}

		MemberReference ReadTypeMemberReference (MetadataToken type, string name, uint signature)
		{
			var declaring_type = GetTypeDefOrRef (type);

			if (!declaring_type.IsArray)
				this.context = declaring_type;

			var member = ReadMemberReferenceSignature (signature, declaring_type);
			member.Name = name;

			return member;
		}

		MemberReference ReadMemberReferenceSignature (uint signature, TypeReference declaring_type)
		{
			var reader = ReadSignature (signature);
			const byte field_sig = 0x6;

			if (reader.buffer [reader.position] == field_sig) {
				reader.position++;
				var field = new FieldReference ();
				field.DeclaringType = declaring_type;
				field.FieldType = reader.ReadTypeSignature ();
				return field;
			} else {
				var method = new MethodReference ();
				method.DeclaringType = declaring_type;
				reader.ReadMethodSignature (method);
				return method;
			}
		}

		MemberReference ReadMethodMemberReference (MetadataToken token, string name, uint signature)
		{
			var method = GetMethodDefinition (token.RID);

			this.context = method;

			var member = ReadMemberReferenceSignature (signature, method.DeclaringType);
			member.Name = name;

			return member;
		}

		void InitializeMemberReferences ()
		{
			if (metadata.MemberReferences != null)
				return;

			metadata.MemberReferences = new MemberReference [image.GetTableLength (Table.MemberRef)];
		}

		public IEnumerable<MemberReference> GetMemberReferences ()
		{
			InitializeMemberReferences ();

			var length = image.GetTableLength (Table.MemberRef);

			var type_system = module.TypeSystem;

			var context = new MethodDefinition (string.Empty, MethodAttributes.Static, type_system.Void);
			context.DeclaringType = new TypeDefinition (string.Empty, string.Empty, TypeAttributes.Public);

			var member_references = new MemberReference [length];

			for (uint i = 1; i <= length; i++) {
				this.context = context;
				member_references [i - 1] = GetMemberReference (i);
			}

			return member_references;
		}

		void InitializeConstants ()
		{
			if (metadata.Constants != null)
				return;

			var length = MoveTo (Table.Constant);

			var constants = metadata.Constants = new Dictionary<MetadataToken, Row<ElementType, uint>> (length);

			for (uint i = 1; i <= length; i++) {
				var type = (ElementType)ReadUInt16 ();
				var owner = ReadMetadataToken (CodedIndex.HasConstant);
				var signature = ReadBlobIndex ();

				constants.Add (owner, new Row<ElementType, uint> (type, signature));
			}
		}

		public TypeReference ReadConstantSignature (MetadataToken token)
		{
			if (token.TokenType != TokenType.Signature)
				throw new NotSupportedException ();

			if (token.RID == 0)
				return null;

			if (!MoveTo (Table.StandAloneSig, token.RID))
				return null;

			return ReadFieldType (ReadBlobIndex ());
		}

		public object ReadConstant (IConstantProvider owner)
		{
			InitializeConstants ();

			Row<ElementType, uint> row;
			if (!metadata.Constants.TryGetValue (owner.MetadataToken, out row))
				return Mixin.NoValue;

			metadata.Constants.Remove (owner.MetadataToken);

			return ReadConstantValue (row.Col1, row.Col2);
		}

		object ReadConstantValue (ElementType etype, uint signature)
		{
			switch (etype) {
			case ElementType.Class:
			case ElementType.Object:
				return null;
			case ElementType.String:
				return ReadConstantString (signature);
			default:
				return ReadConstantPrimitive (etype, signature);
			}
		}

		string ReadConstantString (uint signature)
		{
			byte [] blob;
			int index, count;

			GetBlobView (signature, out blob, out index, out count);
			if (count == 0)
				return string.Empty;

			if ((count & 1) == 1)
				count--;

			return Encoding.Unicode.GetString (blob, index, count);
		}

		object ReadConstantPrimitive (ElementType type, uint signature)
		{
			var reader = ReadSignature (signature);
			return reader.ReadConstantSignature (type);
		}

		internal void InitializeCustomAttributes ()
		{
			if (metadata.CustomAttributes != null)
				return;

			metadata.CustomAttributes = InitializeRanges (
				Table.CustomAttribute, () => {
					var next = ReadMetadataToken (CodedIndex.HasCustomAttribute);
					ReadMetadataToken (CodedIndex.CustomAttributeType);
					ReadBlobIndex ();
					return next;
				});
		}

		public bool HasCustomAttributes (ICustomAttributeProvider owner)
		{
			InitializeCustomAttributes ();

			Range [] ranges;
			if (!metadata.TryGetCustomAttributeRanges (owner, out ranges))
				return false;

			return RangesSize (ranges) > 0;
		}

		public Collection<CustomAttribute> ReadCustomAttributes (ICustomAttributeProvider owner)
		{
			InitializeCustomAttributes ();

			Range [] ranges;
			if (!metadata.TryGetCustomAttributeRanges (owner, out ranges))
				return new Collection<CustomAttribute> ();

			var custom_attributes = new Collection<CustomAttribute> (RangesSize (ranges));

			for (int i = 0; i < ranges.Length; i++)
				ReadCustomAttributeRange (ranges [i], custom_attributes);

			metadata.RemoveCustomAttributeRange (owner);

			if (module.IsWindowsMetadata ())
				foreach (var custom_attribute in custom_attributes)
					WindowsRuntimeProjections.Project (owner, custom_attribute);

			return custom_attributes;
		}

		void ReadCustomAttributeRange (Range range, Collection<CustomAttribute> custom_attributes)
		{
			if (!MoveTo (Table.CustomAttribute, range.Start))
				return;

			for (var i = 0; i < range.Length; i++) {
				ReadMetadataToken (CodedIndex.HasCustomAttribute);

				var constructor = (MethodReference)LookupToken (
					ReadMetadataToken (CodedIndex.CustomAttributeType));

				var signature = ReadBlobIndex ();

				custom_attributes.Add (new CustomAttribute (signature, constructor));
			}
		}

		static int RangesSize (Range [] ranges)
		{
			uint size = 0;
			for (int i = 0; i < ranges.Length; i++)
				size += ranges [i].Length;

			return (int)size;
		}

		public IEnumerable<CustomAttribute> GetCustomAttributes ()
		{
			InitializeTypeDefinitions ();

			var length = image.TableHeap [Table.CustomAttribute].Length;
			var custom_attributes = new Collection<CustomAttribute> ((int)length);
			ReadCustomAttributeRange (new Range (1, length), custom_attributes);

			return custom_attributes;
		}

		public byte [] ReadCustomAttributeBlob (uint signature)
		{
			return ReadBlob (signature);
		}

		public void ReadCustomAttributeSignature (CustomAttribute attribute)
		{
			var reader = ReadSignature (attribute.signature);

			if (!reader.CanReadMore ())
				return;

			if (reader.ReadUInt16 () != 0x0001)
				throw new InvalidOperationException ();

			var constructor = attribute.Constructor;
			if (constructor.HasParameters)
				reader.ReadCustomAttributeConstructorArguments (attribute, constructor.Parameters);

			if (!reader.CanReadMore ())
				return;

			var named = reader.ReadUInt16 ();

			if (named == 0)
				return;

			reader.ReadCustomAttributeNamedArguments (named, ref attribute.fields, ref attribute.properties);
		}

		void InitializeMarshalInfos ()
		{
			if (metadata.FieldMarshals != null)
				return;

			var length = MoveTo (Table.FieldMarshal);

			var marshals = metadata.FieldMarshals = new Dictionary<MetadataToken, uint> (length);

			for (int i = 0; i < length; i++) {
				var token = ReadMetadataToken (CodedIndex.HasFieldMarshal);
				var signature = ReadBlobIndex ();
				if (token.RID == 0)
					continue;

				marshals.Add (token, signature);
			}
		}

		public bool HasMarshalInfo (IMarshalInfoProvider owner)
		{
			InitializeMarshalInfos ();

			return metadata.FieldMarshals.ContainsKey (owner.MetadataToken);
		}

		public MarshalInfo ReadMarshalInfo (IMarshalInfoProvider owner)
		{
			InitializeMarshalInfos ();

			uint signature;
			if (!metadata.FieldMarshals.TryGetValue (owner.MetadataToken, out signature))
				return null;

			var reader = ReadSignature (signature);

			metadata.FieldMarshals.Remove (owner.MetadataToken);

			return reader.ReadMarshalInfo ();
		}

		void InitializeSecurityDeclarations ()
		{
			if (metadata.SecurityDeclarations != null)
				return;

			metadata.SecurityDeclarations = InitializeRanges (
				Table.DeclSecurity, () => {
					ReadUInt16 ();
					var next = ReadMetadataToken (CodedIndex.HasDeclSecurity);
					ReadBlobIndex ();
					return next;
				});
		}

		public bool HasSecurityDeclarations (ISecurityDeclarationProvider owner)
		{
			InitializeSecurityDeclarations ();

			Range [] ranges;
			if (!metadata.TryGetSecurityDeclarationRanges (owner, out ranges))
				return false;

			return RangesSize (ranges) > 0;
		}

		public Collection<SecurityDeclaration> ReadSecurityDeclarations (ISecurityDeclarationProvider owner)
		{
			InitializeSecurityDeclarations ();

			Range [] ranges;
			if (!metadata.TryGetSecurityDeclarationRanges (owner, out ranges))
				return new Collection<SecurityDeclaration> ();

			var security_declarations = new Collection<SecurityDeclaration> (RangesSize (ranges));

			for (int i = 0; i < ranges.Length; i++)
				ReadSecurityDeclarationRange (ranges [i], security_declarations);

			metadata.RemoveSecurityDeclarationRange (owner);

			return security_declarations;
		}

		void ReadSecurityDeclarationRange (Range range, Collection<SecurityDeclaration> security_declarations)
		{
			if (!MoveTo (Table.DeclSecurity, range.Start))
				return;

			for (int i = 0; i < range.Length; i++) {
				var action = (SecurityAction)ReadUInt16 ();
				ReadMetadataToken (CodedIndex.HasDeclSecurity);
				var signature = ReadBlobIndex ();

				security_declarations.Add (new SecurityDeclaration (action, signature, module));
			}
		}

		public byte [] ReadSecurityDeclarationBlob (uint signature)
		{
			return ReadBlob (signature);
		}

		public void ReadSecurityDeclarationSignature (SecurityDeclaration declaration)
		{
			var signature = declaration.signature;
			var reader = ReadSignature (signature);

			if (reader.buffer [reader.position] != '.') {
				ReadXmlSecurityDeclaration (signature, declaration);
				return;
			}

			reader.position++;
			var count = reader.ReadCompressedUInt32 ();
			var attributes = new Collection<SecurityAttribute> ((int)count);

			for (int i = 0; i < count; i++)
				attributes.Add (reader.ReadSecurityAttribute ());

			declaration.security_attributes = attributes;
		}

		void ReadXmlSecurityDeclaration (uint signature, SecurityDeclaration declaration)
		{
			var attributes = new Collection<SecurityAttribute> (1);

			var attribute = new SecurityAttribute (
				module.TypeSystem.LookupType ("System.Security.Permissions", "PermissionSetAttribute"));

			attribute.properties = new Collection<CustomAttributeNamedArgument> (1);
			attribute.properties.Add (
				new CustomAttributeNamedArgument (
					"XML",
					new CustomAttributeArgument (
						module.TypeSystem.String,
						ReadUnicodeStringBlob (signature))));

			attributes.Add (attribute);

			declaration.security_attributes = attributes;
		}

		public Collection<ExportedType> ReadExportedTypes ()
		{
			var length = MoveTo (Table.ExportedType);
			if (length == 0)
				return new Collection<ExportedType> ();

			var exported_types = new Collection<ExportedType> (length);

			for (int i = 1; i <= length; i++) {
				var attributes = (TypeAttributes)ReadUInt32 ();
				var identifier = ReadUInt32 ();
				var name = ReadString ();
				var @namespace = ReadString ();
				var implementation = ReadMetadataToken (CodedIndex.Implementation);

				ExportedType declaring_type = null;
				IMetadataScope scope = null;

				switch (implementation.TokenType) {
				case TokenType.AssemblyRef:
				case TokenType.File:
					scope = GetExportedTypeScope (implementation);
					break;
				case TokenType.ExportedType:
					// FIXME: if the table is not properly sorted
					declaring_type = exported_types [(int)implementation.RID - 1];
					break;
				}

				var exported_type = new ExportedType (@namespace, name, module, scope) {
					Attributes = attributes,
					Identifier = (int)identifier,
					DeclaringType = declaring_type,
				};
				exported_type.token = new MetadataToken (TokenType.ExportedType, i);

				exported_types.Add (exported_type);
			}

			return exported_types;
		}

		IMetadataScope GetExportedTypeScope (MetadataToken token)
		{
			var position = this.position;
			IMetadataScope scope;

			switch (token.TokenType) {
			case TokenType.AssemblyRef:
				InitializeAssemblyReferences ();
				scope = metadata.GetAssemblyNameReference (token.RID);
				break;
			case TokenType.File:
				InitializeModuleReferences ();
				scope = GetModuleReferenceFromFile (token);
				break;
			default:
				throw new NotSupportedException ();
			}

			this.position = position;
			return scope;
		}

		ModuleReference GetModuleReferenceFromFile (MetadataToken token)
		{
			if (!MoveTo (Table.File, token.RID))
				return null;

			ReadUInt32 ();
			var file_name = ReadString ();
			var modules = module.ModuleReferences;

			ModuleReference reference;
			for (int i = 0; i < modules.Count; i++) {
				reference = modules [i];
				if (reference.Name == file_name)
					return reference;
			}

			reference = new ModuleReference (file_name);
			modules.Add (reference);
			return reference;
		}

		void InitializeDocuments ()
		{
			if (metadata.Documents != null)
				return;

			int length = MoveTo (Table.Document);

			var documents = metadata.Documents = new Document [length];

			for (uint i = 1; i <= length; i++) {
				var name_index = ReadBlobIndex ();
				var hash_algorithm = ReadGuid ();
				var hash = ReadBlob ();
				var language = ReadGuid ();

				var signature = ReadSignature (name_index);
				var name = signature.ReadDocumentName ();

				documents [i - 1] = new Document (name) {
					HashAlgorithmGuid = hash_algorithm,
					Hash = hash,
					LanguageGuid = language,
					token = new MetadataToken (TokenType.Document, i),
				};
			}
		}

		public Collection<SequencePoint> ReadSequencePoints (MethodDefinition method)
		{
			InitializeDocuments ();

			if (!MoveTo (Table.MethodDebugInformation, method.MetadataToken.RID))
				return new Collection<SequencePoint> (0);

			var document_index = ReadTableIndex (Table.Document);
			var signature = ReadBlobIndex ();
			if (signature == 0)
				return new Collection<SequencePoint> (0);

			var document = GetDocument (document_index);
			var reader = ReadSignature (signature);

			return reader.ReadSequencePoints (document);
		}

		public Document GetDocument (uint rid)
		{
			var document = metadata.GetDocument (rid);
			if (document == null)
				return null;

			document.custom_infos = GetCustomDebugInformation (document);
			return document;
		}

		void InitializeLocalScopes ()
		{
			if (metadata.LocalScopes != null)
				return;

			InitializeMethods ();

			int length = MoveTo (Table.LocalScope);

			metadata.LocalScopes = new Dictionary<uint, Collection<Row<uint, Range, Range, uint, uint, uint>>> ();

			for (uint i = 1; i <= length; i++) {
				var method = ReadTableIndex (Table.Method);
				var import = ReadTableIndex (Table.ImportScope);
				var variables = ReadListRange (i, Table.LocalScope, Table.LocalVariable);
				var constants = ReadListRange (i, Table.LocalScope, Table.LocalConstant);
				var scope_start = ReadUInt32 ();
				var scope_length = ReadUInt32 ();

				metadata.SetLocalScopes (method, AddMapping (metadata.LocalScopes, method, new Row<uint, Range, Range, uint, uint, uint> (import, variables, constants, scope_start, scope_length, i)));
			}
		}

		public ScopeDebugInformation ReadScope (MethodDefinition method)
		{
			InitializeLocalScopes ();
			InitializeImportScopes ();

			Collection<Row<uint, Range, Range, uint, uint, uint>> records;
			if (!metadata.TryGetLocalScopes (method, out records))
				return null;

			var method_scope = null as ScopeDebugInformation;

			for (int i = 0; i < records.Count; i++) {
				var scope = ReadLocalScope (records [i]);

				if (i == 0) {
					method_scope = scope;
					continue;
				}

				if (!AddScope (method_scope.scopes, scope))
					method_scope.Scopes.Add (scope);
			}

			return method_scope;
		}

		static bool AddScope (Collection<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
		{
			if (scopes.IsNullOrEmpty ())
				return false;

			foreach (var sub_scope in scopes) {
				if (sub_scope.HasScopes && AddScope (sub_scope.Scopes, scope))
					return true;

				if (scope.Start.Offset >= sub_scope.Start.Offset && scope.End.Offset <= sub_scope.End.Offset) {
					sub_scope.Scopes.Add (scope);
					return true;
				}
			}

			return false;
		}

		ScopeDebugInformation ReadLocalScope (Row<uint, Range, Range, uint, uint, uint> record)
		{
			var scope = new ScopeDebugInformation {
				start = new InstructionOffset ((int)record.Col4),
				end = new InstructionOffset ((int)(record.Col4 + record.Col5)),
				token = new MetadataToken (TokenType.LocalScope, record.Col6),
			};

			if (record.Col1 > 0)
				scope.import = metadata.GetImportScope (record.Col1);

			if (record.Col2.Length > 0) {
				scope.variables = new Collection<VariableDebugInformation> ((int)record.Col2.Length);
				for (uint i = 0; i < record.Col2.Length; i++) {
					var variable = ReadLocalVariable (record.Col2.Start + i);
					if (variable != null)
						scope.variables.Add (variable);
				}
			}

			if (record.Col3.Length > 0) {
				scope.constants = new Collection<ConstantDebugInformation> ((int)record.Col3.Length);
				for (uint i = 0; i < record.Col3.Length; i++) {
					var constant = ReadLocalConstant (record.Col3.Start + i);
					if (constant != null)
						scope.constants.Add (constant);
				}
			}

			return scope;
		}

		VariableDebugInformation ReadLocalVariable (uint rid)
		{
			if (!MoveTo (Table.LocalVariable, rid))
				return null;

			var attributes = (VariableAttributes)ReadUInt16 ();
			var index = ReadUInt16 ();
			var name = ReadString ();

			var variable = new VariableDebugInformation (index, name) { Attributes = attributes, token = new MetadataToken (TokenType.LocalVariable, rid) };
			variable.custom_infos = GetCustomDebugInformation (variable);
			return variable;
		}

		ConstantDebugInformation ReadLocalConstant (uint rid)
		{
			if (!MoveTo (Table.LocalConstant, rid))
				return null;

			var name = ReadString ();
			var signature = ReadSignature (ReadBlobIndex ());
			var type = signature.ReadTypeSignature ();

			object value;
			if (type.etype == ElementType.String) {
				if (signature.CanReadMore () && signature.buffer [signature.position] != 0xff) {
					var bytes = signature.ReadBytes ((int)(signature.sig_length - (signature.position - signature.start)));
					value = Encoding.Unicode.GetString (bytes, 0, bytes.Length);
				} else
					value = null;
			} else if (type.IsTypeOf ("System", "Decimal")) {
				var b = signature.ReadByte ();
				value = new decimal (signature.ReadInt32 (), signature.ReadInt32 (), signature.ReadInt32 (), (b & 0x80) != 0, (byte)(b & 0x7f));
			} else if (type.IsTypeOf ("System", "DateTime")) {
				value = new DateTime (signature.ReadInt64 ());
			} else if (type.etype == ElementType.Object || type.etype == ElementType.None || type.etype == ElementType.Class || type.etype == ElementType.Array || type.etype == ElementType.GenericInst) {
				value = null;
			} else
				value = signature.ReadConstantSignature (type.etype);

			var constant = new ConstantDebugInformation (name, type, value) { token = new MetadataToken (TokenType.LocalConstant, rid) };
			constant.custom_infos = GetCustomDebugInformation (constant);
			return constant;
		}

		void InitializeImportScopes ()
		{
			if (metadata.ImportScopes != null)
				return;

			var length = MoveTo (Table.ImportScope);

			metadata.ImportScopes = new ImportDebugInformation [length];

			for (int i = 1; i <= length; i++) {
				ReadTableIndex (Table.ImportScope);

				var import = new ImportDebugInformation ();
				import.token = new MetadataToken (TokenType.ImportScope, i);

				var signature = ReadSignature (ReadBlobIndex ());
				while (signature.CanReadMore ())
					import.Targets.Add (ReadImportTarget (signature));

				metadata.ImportScopes [i - 1] = import;
			}

			MoveTo (Table.ImportScope);

			for (int i = 0; i < length; i++) {
				var parent = ReadTableIndex (Table.ImportScope);

				ReadBlobIndex ();

				if (parent != 0)
					metadata.ImportScopes [i].Parent = metadata.GetImportScope (parent);
			}
		}

		public string ReadUTF8StringBlob (uint signature)
		{
			return ReadStringBlob (signature, Encoding.UTF8);
		}

		string ReadUnicodeStringBlob (uint signature)
		{
			return ReadStringBlob (signature, Encoding.Unicode);
		}

		string ReadStringBlob (uint signature, Encoding encoding)
		{
			byte [] blob;
			int index, count;

			GetBlobView (signature, out blob, out index, out count);
			if (count == 0)
				return string.Empty;

			return encoding.GetString (blob, index, count);
		}

		ImportTarget ReadImportTarget (SignatureReader signature)
		{
			AssemblyNameReference reference = null;
			string @namespace = null;
			string alias = null;
			TypeReference type = null;

			var kind = (ImportTargetKind)signature.ReadCompressedUInt32 ();
			switch (kind) {
			case ImportTargetKind.ImportNamespace:
				@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				break;
			case ImportTargetKind.ImportNamespaceInAssembly:
				reference = metadata.GetAssemblyNameReference (signature.ReadCompressedUInt32 ());
				@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				break;
			case ImportTargetKind.ImportType:
				type = signature.ReadTypeToken ();
				break;
			case ImportTargetKind.ImportXmlNamespaceWithAlias:
				alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				break;
			case ImportTargetKind.ImportAlias:
				alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				break;
			case ImportTargetKind.DefineAssemblyAlias:
				alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				reference = metadata.GetAssemblyNameReference (signature.ReadCompressedUInt32 ());
				break;
			case ImportTargetKind.DefineNamespaceAlias:
				alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				break;
			case ImportTargetKind.DefineNamespaceInAssemblyAlias:
				alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				reference = metadata.GetAssemblyNameReference (signature.ReadCompressedUInt32 ());
				@namespace = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				break;
			case ImportTargetKind.DefineTypeAlias:
				alias = ReadUTF8StringBlob (signature.ReadCompressedUInt32 ());
				type = signature.ReadTypeToken ();
				break;
			}

			return new ImportTarget (kind) {
				alias = alias,
				type = type,
				@namespace = @namespace,
				reference = reference,
			};
		}

		void InitializeStateMachineMethods ()
		{
			if (metadata.StateMachineMethods != null)
				return;

			var length = MoveTo (Table.StateMachineMethod);

			metadata.StateMachineMethods = new Dictionary<uint, uint> (length);

			for (int i = 0; i < length; i++)
				metadata.StateMachineMethods.Add (ReadTableIndex (Table.Method), ReadTableIndex (Table.Method));
		}

		public MethodDefinition ReadStateMachineKickoffMethod (MethodDefinition method)
		{
			InitializeStateMachineMethods ();

			uint rid;
			if (!metadata.TryGetStateMachineKickOffMethod (method, out rid))
				return null;

			return GetMethodDefinition (rid);
		}

		void InitializeCustomDebugInformations ()
		{
			if (metadata.CustomDebugInformations != null)
				return;

			var length = MoveTo (Table.CustomDebugInformation);

			metadata.CustomDebugInformations = new Dictionary<MetadataToken, Row<Guid, uint, uint> []> ();

			for (uint i = 1; i <= length; i++) {
				var token = ReadMetadataToken (CodedIndex.HasCustomDebugInformation);
				var info = new Row<Guid, uint, uint> (ReadGuid (), ReadBlobIndex (), i);

				Row<Guid, uint, uint> [] infos;
				metadata.CustomDebugInformations.TryGetValue (token, out infos);
				metadata.CustomDebugInformations [token] = infos.Add (info);
			}
		}

		public Collection<CustomDebugInformation> GetCustomDebugInformation (ICustomDebugInformationProvider provider)
		{
			InitializeCustomDebugInformations ();

			Row<Guid, uint, uint> [] rows;
			if (!metadata.CustomDebugInformations.TryGetValue (provider.MetadataToken, out rows))
				return null;

			var infos = new Collection<CustomDebugInformation> (rows.Length);

			for (int i = 0; i < rows.Length; i++) {
				if (rows [i].Col1 == StateMachineScopeDebugInformation.KindIdentifier) {
					var signature = ReadSignature (rows [i].Col2);
					var scopes = new Collection<StateMachineScope> ();

					while (signature.CanReadMore ()) {
						var start = signature.ReadInt32 ();
						var end = start + signature.ReadInt32 ();
						scopes.Add (new StateMachineScope (start, end));
					}

					var state_machine = new StateMachineScopeDebugInformation ();
					state_machine.scopes = scopes;

					infos.Add (state_machine);
				} else if (rows [i].Col1 == AsyncMethodBodyDebugInformation.KindIdentifier) {
					var signature = ReadSignature (rows [i].Col2);

					var catch_offset = signature.ReadInt32 () - 1;
					var yields = new Collection<InstructionOffset> ();
					var resumes = new Collection<InstructionOffset> ();
					var resume_methods = new Collection<MethodDefinition> ();

					while (signature.CanReadMore ()) {
						yields.Add (new InstructionOffset (signature.ReadInt32 ()));
						resumes.Add (new InstructionOffset (signature.ReadInt32 ()));
						resume_methods.Add (GetMethodDefinition (signature.ReadCompressedUInt32 ()));
					}

					var async_body = new AsyncMethodBodyDebugInformation (catch_offset);
					async_body.yields = yields;
					async_body.resumes = resumes;
					async_body.resume_methods = resume_methods;

					infos.Add (async_body);
				} else if (rows [i].Col1 == EmbeddedSourceDebugInformation.KindIdentifier) {
					infos.Add (new EmbeddedSourceDebugInformation (rows [i].Col2, this));
				} else if (rows [i].Col1 == SourceLinkDebugInformation.KindIdentifier) {
					infos.Add (new SourceLinkDebugInformation (Encoding.UTF8.GetString (ReadBlob (rows [i].Col2))));
				} else {
					infos.Add (new BinaryCustomDebugInformation (rows [i].Col1, ReadBlob (rows [i].Col2)));
				}

				infos [i].token = new MetadataToken (TokenType.CustomDebugInformation, rows [i].Col3);
			}

			return infos;
		}

		public byte [] ReadRawEmbeddedSourceDebugInformation (uint index)
		{
			var signature = ReadSignature (index);
			return signature.ReadBytes ((int)signature.sig_length);
		}

		public Row<byte [], bool> ReadEmbeddedSourceDebugInformation (uint index)
		{
			var signature = ReadSignature (index);
			var format = signature.ReadInt32 ();
			var length = signature.sig_length - 4;

			if (format == 0) {
				return new Row<byte [], bool> (signature.ReadBytes ((int)length), false);
			} else if (format > 0) {
				var compressed_stream = new MemoryStream (signature.ReadBytes ((int)length));
				var decompressed_document = new byte [format]; // if positive, format is the decompressed length of the document
				var decompressed_stream = new MemoryStream (decompressed_document);

				using (var deflate_stream = new DeflateStream (compressed_stream, CompressionMode.Decompress, leaveOpen: true))
					deflate_stream.CopyTo (decompressed_stream);

				return new Row<byte [], bool> (decompressed_document, true);
			} else
				throw new NotSupportedException ();
		}
	}

	sealed class SignatureReader : ByteBuffer {

		readonly MetadataReader reader;
		readonly internal uint start, sig_length;

		TypeSystem TypeSystem {
			get { return reader.module.TypeSystem; }
		}

		public SignatureReader (uint blob, MetadataReader reader)
			: base (reader.image.BlobHeap.data)
		{
			this.reader = reader;
			this.position = (int)blob;
			this.sig_length = ReadCompressedUInt32 ();
			this.start = (uint)this.position;
		}

		MetadataToken ReadTypeTokenSignature ()
		{
			return CodedIndex.TypeDefOrRef.GetMetadataToken (ReadCompressedUInt32 ());
		}

		GenericParameter GetGenericParameter (GenericParameterType type, uint var)
		{
			var context = reader.context;
			int index = (int)var;

			if (context == null)
				return GetUnboundGenericParameter (type, index);

			IGenericParameterProvider provider;

			switch (type) {
			case GenericParameterType.Type:
				provider = context.Type;
				break;
			case GenericParameterType.Method:
				provider = context.Method;
				break;
			default:
				throw new NotSupportedException ();
			}

			if (!context.IsDefinition)
				CheckGenericContext (provider, index);

			if (index >= provider.GenericParameters.Count)
				return GetUnboundGenericParameter (type, index);

			return provider.GenericParameters [index];
		}

		GenericParameter GetUnboundGenericParameter (GenericParameterType type, int index)
		{
			return new GenericParameter (index, type, reader.module);
		}

		static void CheckGenericContext (IGenericParameterProvider owner, int index)
		{
			var owner_parameters = owner.GenericParameters;

			for (int i = owner_parameters.Count; i <= index; i++)
				owner_parameters.Add (new GenericParameter (owner));
		}

		public void ReadGenericInstanceSignature (IGenericParameterProvider provider, IGenericInstance instance, uint arity)
		{
			if (!provider.IsDefinition)
				CheckGenericContext (provider, (int)arity - 1);

			var instance_arguments = instance.GenericArguments;

			for (int i = 0; i < arity; i++)
				instance_arguments.Add (ReadTypeSignature ());
		}

		ArrayType ReadArrayTypeSignature ()
		{
			var array = new ArrayType (ReadTypeSignature ());

			var rank = ReadCompressedUInt32 ();

			var sizes = new uint [ReadCompressedUInt32 ()];
			for (int i = 0; i < sizes.Length; i++)
				sizes [i] = ReadCompressedUInt32 ();

			var low_bounds = new int [ReadCompressedUInt32 ()];
			for (int i = 0; i < low_bounds.Length; i++)
				low_bounds [i] = ReadCompressedInt32 ();

			array.Dimensions.Clear ();

			for (int i = 0; i < rank; i++) {
				int? lower = null, upper = null;

				if (i < low_bounds.Length)
					lower = low_bounds [i];

				if (i < sizes.Length)
					upper = lower + (int)sizes [i] - 1;

				array.Dimensions.Add (new ArrayDimension (lower, upper));
			}

			return array;
		}

		TypeReference GetTypeDefOrRef (MetadataToken token)
		{
			return reader.GetTypeDefOrRef (token);
		}

		public TypeReference ReadTypeSignature ()
		{
			return ReadTypeSignature ((ElementType)ReadByte ());
		}

		public TypeReference ReadTypeToken ()
		{
			return GetTypeDefOrRef (ReadTypeTokenSignature ());
		}

		TypeReference ReadTypeSignature (ElementType etype)
		{
			switch (etype) {
			case ElementType.ValueType: {
					var value_type = GetTypeDefOrRef (ReadTypeTokenSignature ());
					value_type.KnownValueType ();
					return value_type;
				}
			case ElementType.Class:
				return GetTypeDefOrRef (ReadTypeTokenSignature ());
			case ElementType.Ptr:
				return new PointerType (ReadTypeSignature ());
			case ElementType.FnPtr: {
					var fptr = new FunctionPointerType ();
					ReadMethodSignature (fptr);
					return fptr;
				}
			case ElementType.ByRef:
				return new ByReferenceType (ReadTypeSignature ());
			case ElementType.Pinned:
				return new PinnedType (ReadTypeSignature ());
			case ElementType.SzArray:
				return new ArrayType (ReadTypeSignature ());
			case ElementType.Array:
				return ReadArrayTypeSignature ();
			case ElementType.CModOpt:
				return new OptionalModifierType (
					GetTypeDefOrRef (ReadTypeTokenSignature ()), ReadTypeSignature ());
			case ElementType.CModReqD:
				return new RequiredModifierType (
					GetTypeDefOrRef (ReadTypeTokenSignature ()), ReadTypeSignature ());
			case ElementType.Sentinel:
				return new SentinelType (ReadTypeSignature ());
			case ElementType.Var:
				return GetGenericParameter (GenericParameterType.Type, ReadCompressedUInt32 ());
			case ElementType.MVar:
				return GetGenericParameter (GenericParameterType.Method, ReadCompressedUInt32 ());
			case ElementType.GenericInst: {
					var is_value_type = ReadByte () == (byte)ElementType.ValueType;
					var element_type = GetTypeDefOrRef (ReadTypeTokenSignature ());

					var arity = ReadCompressedUInt32 ();
					var generic_instance = new GenericInstanceType (element_type, (int)arity);

					ReadGenericInstanceSignature (element_type, generic_instance, arity);

					if (is_value_type) {
						generic_instance.KnownValueType ();
						element_type.GetElementType ().KnownValueType ();
					}

					return generic_instance;
				}
			case ElementType.Object: return TypeSystem.Object;
			case ElementType.Void: return TypeSystem.Void;
			case ElementType.TypedByRef: return TypeSystem.TypedReference;
			case ElementType.I: return TypeSystem.IntPtr;
			case ElementType.U: return TypeSystem.UIntPtr;
			default: return GetPrimitiveType (etype);
			}
		}

		public void ReadMethodSignature (IMethodSignature method)
		{
			var calling_convention = ReadByte ();

			const byte has_this = 0x20;
			const byte explicit_this = 0x40;

			if ((calling_convention & has_this) != 0) {
				method.HasThis = true;
				calling_convention = (byte)(calling_convention & ~has_this);
			}

			if ((calling_convention & explicit_this) != 0) {
				method.ExplicitThis = true;
				calling_convention = (byte)(calling_convention & ~explicit_this);
			}

			method.CallingConvention = (MethodCallingConvention)calling_convention;

			var generic_context = method as MethodReference;
			if (generic_context != null && !generic_context.DeclaringType.IsArray)
				reader.context = generic_context;

			if ((calling_convention & 0x10) != 0) {
				var arity = ReadCompressedUInt32 ();

				if (generic_context != null && !generic_context.IsDefinition)
					CheckGenericContext (generic_context, (int)arity - 1);
			}

			var param_count = ReadCompressedUInt32 ();

			method.MethodReturnType.ReturnType = ReadTypeSignature ();

			if (param_count == 0)
				return;

			Collection<ParameterDefinition> parameters;

			var method_ref = method as MethodReference;
			if (method_ref != null)
				parameters = method_ref.parameters = new ParameterDefinitionCollection (method, (int)param_count);
			else
				parameters = method.Parameters;

			for (int i = 0; i < param_count; i++)
				parameters.Add (new ParameterDefinition (ReadTypeSignature ()));
		}

		public object ReadConstantSignature (ElementType type)
		{
			return ReadPrimitiveValue (type);
		}

		public void ReadCustomAttributeConstructorArguments (CustomAttribute attribute, Collection<ParameterDefinition> parameters)
		{
			var count = parameters.Count;
			if (count == 0)
				return;

			attribute.arguments = new Collection<CustomAttributeArgument> (count);

			for (int i = 0; i < count; i++)
				attribute.arguments.Add (
					ReadCustomAttributeFixedArgument (parameters [i].ParameterType));
		}

		CustomAttributeArgument ReadCustomAttributeFixedArgument (TypeReference type)
		{
			if (type.IsArray)
				return ReadCustomAttributeFixedArrayArgument ((ArrayType)type);

			return ReadCustomAttributeElement (type);
		}

		public void ReadCustomAttributeNamedArguments (ushort count, ref Collection<CustomAttributeNamedArgument> fields, ref Collection<CustomAttributeNamedArgument> properties)
		{
			for (int i = 0; i < count; i++) {
				if (!CanReadMore ())
					return;
				ReadCustomAttributeNamedArgument (ref fields, ref properties);
			}
		}

		void ReadCustomAttributeNamedArgument (ref Collection<CustomAttributeNamedArgument> fields, ref Collection<CustomAttributeNamedArgument> properties)
		{
			var kind = ReadByte ();
			var type = ReadCustomAttributeFieldOrPropType ();
			var name = ReadUTF8String ();

			Collection<CustomAttributeNamedArgument> container;
			switch (kind) {
			case 0x53:
				container = GetCustomAttributeNamedArgumentCollection (ref fields);
				break;
			case 0x54:
				container = GetCustomAttributeNamedArgumentCollection (ref properties);
				break;
			default:
				throw new NotSupportedException ();
			}

			container.Add (new CustomAttributeNamedArgument (name, ReadCustomAttributeFixedArgument (type)));
		}

		static Collection<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection (ref Collection<CustomAttributeNamedArgument> collection)
		{
			if (collection != null)
				return collection;

			return collection = new Collection<CustomAttributeNamedArgument> ();
		}

		CustomAttributeArgument ReadCustomAttributeFixedArrayArgument (ArrayType type)
		{
			var length = ReadUInt32 ();

			if (length == 0xffffffff)
				return new CustomAttributeArgument (type, null);

			if (length == 0)
				return new CustomAttributeArgument (type, Empty<CustomAttributeArgument>.Array);

			var arguments = new CustomAttributeArgument [length];
			var element_type = type.ElementType;

			for (int i = 0; i < length; i++)
				arguments [i] = ReadCustomAttributeElement (element_type);

			return new CustomAttributeArgument (type, arguments);
		}

		CustomAttributeArgument ReadCustomAttributeElement (TypeReference type)
		{
			if (type.IsArray)
				return ReadCustomAttributeFixedArrayArgument ((ArrayType)type);

			return new CustomAttributeArgument (
				type,
				type.etype == ElementType.Object
					? ReadCustomAttributeElement (ReadCustomAttributeFieldOrPropType ())
					: ReadCustomAttributeElementValue (type));
		}

		object ReadCustomAttributeElementValue (TypeReference type)
		{
			var etype = type.etype;

			switch (etype) {
			case ElementType.String:
				return ReadUTF8String ();
			case ElementType.None:
				if (type.IsTypeOf ("System", "Type"))
					return ReadTypeReference ();

				return ReadCustomAttributeEnum (type);
			default:
				return ReadPrimitiveValue (etype);
			}
		}

		object ReadPrimitiveValue (ElementType type)
		{
			switch (type) {
			case ElementType.Boolean:
				return ReadByte () == 1;
			case ElementType.I1:
				return (sbyte)ReadByte ();
			case ElementType.U1:
				return ReadByte ();
			case ElementType.Char:
				return (char)ReadUInt16 ();
			case ElementType.I2:
				return ReadInt16 ();
			case ElementType.U2:
				return ReadUInt16 ();
			case ElementType.I4:
				return ReadInt32 ();
			case ElementType.U4:
				return ReadUInt32 ();
			case ElementType.I8:
				return ReadInt64 ();
			case ElementType.U8:
				return ReadUInt64 ();
			case ElementType.R4:
				return ReadSingle ();
			case ElementType.R8:
				return ReadDouble ();
			default:
				throw new NotImplementedException (type.ToString ());
			}
		}

		TypeReference GetPrimitiveType (ElementType etype)
		{
			switch (etype) {
			case ElementType.Boolean:
				return TypeSystem.Boolean;
			case ElementType.Char:
				return TypeSystem.Char;
			case ElementType.I1:
				return TypeSystem.SByte;
			case ElementType.U1:
				return TypeSystem.Byte;
			case ElementType.I2:
				return TypeSystem.Int16;
			case ElementType.U2:
				return TypeSystem.UInt16;
			case ElementType.I4:
				return TypeSystem.Int32;
			case ElementType.U4:
				return TypeSystem.UInt32;
			case ElementType.I8:
				return TypeSystem.Int64;
			case ElementType.U8:
				return TypeSystem.UInt64;
			case ElementType.R4:
				return TypeSystem.Single;
			case ElementType.R8:
				return TypeSystem.Double;
			case ElementType.String:
				return TypeSystem.String;
			default:
				throw new NotImplementedException (etype.ToString ());
			}
		}

		TypeReference ReadCustomAttributeFieldOrPropType ()
		{
			var etype = (ElementType)ReadByte ();

			switch (etype) {
			case ElementType.Boxed:
				return TypeSystem.Object;
			case ElementType.SzArray:
				return new ArrayType (ReadCustomAttributeFieldOrPropType ());
			case ElementType.Enum:
				return ReadTypeReference ();
			case ElementType.Type:
				return TypeSystem.LookupType ("System", "Type");
			default:
				return GetPrimitiveType (etype);
			}
		}

		public TypeReference ReadTypeReference ()
		{
			return TypeParser.ParseType (reader.module, ReadUTF8String ());
		}

		object ReadCustomAttributeEnum (TypeReference enum_type)
		{
			var type = enum_type.CheckedResolve ();
			if (!type.IsEnum)
				throw new ArgumentException ();

			return ReadCustomAttributeElementValue (type.GetEnumUnderlyingType ());
		}

		public SecurityAttribute ReadSecurityAttribute ()
		{
			var attribute = new SecurityAttribute (ReadTypeReference ());

			ReadCompressedUInt32 ();

			ReadCustomAttributeNamedArguments (
				(ushort)ReadCompressedUInt32 (),
				ref attribute.fields,
				ref attribute.properties);

			return attribute;
		}

		public MarshalInfo ReadMarshalInfo ()
		{
			var native = ReadNativeType ();
			switch (native) {
			case NativeType.Array: {
					var array = new ArrayMarshalInfo ();
					if (CanReadMore ())
						array.element_type = ReadNativeType ();
					if (CanReadMore ())
						array.size_parameter_index = (int)ReadCompressedUInt32 ();
					if (CanReadMore ())
						array.size = (int)ReadCompressedUInt32 ();
					if (CanReadMore ())
						array.size_parameter_multiplier = (int)ReadCompressedUInt32 ();
					return array;
				}
			case NativeType.SafeArray: {
					var array = new SafeArrayMarshalInfo ();
					if (CanReadMore ())
						array.element_type = ReadVariantType ();
					return array;
				}
			case NativeType.FixedArray: {
					var array = new FixedArrayMarshalInfo ();
					if (CanReadMore ())
						array.size = (int)ReadCompressedUInt32 ();
					if (CanReadMore ())
						array.element_type = ReadNativeType ();
					return array;
				}
			case NativeType.FixedSysString: {
					var sys_string = new FixedSysStringMarshalInfo ();
					if (CanReadMore ())
						sys_string.size = (int)ReadCompressedUInt32 ();
					return sys_string;
				}
			case NativeType.CustomMarshaler: {
					var marshaler = new CustomMarshalInfo ();
					var guid_value = ReadUTF8String ();
					marshaler.guid = !string.IsNullOrEmpty (guid_value) ? new Guid (guid_value) : Guid.Empty;
					marshaler.unmanaged_type = ReadUTF8String ();
					marshaler.managed_type = ReadTypeReference ();
					marshaler.cookie = ReadUTF8String ();
					return marshaler;
				}
			default:
				return new MarshalInfo (native);
			}
		}

		NativeType ReadNativeType ()
		{
			return (NativeType)ReadByte ();
		}

		VariantType ReadVariantType ()
		{
			return (VariantType)ReadByte ();
		}

		string ReadUTF8String ()
		{
			if (buffer [position] == 0xff) {
				position++;
				return null;
			}

			var length = (int)ReadCompressedUInt32 ();
			if (length == 0)
				return string.Empty;

			if (position + length > buffer.Length)
				return string.Empty;

			var @string = Encoding.UTF8.GetString (buffer, position, length);

			position += length;
			return @string;
		}

		public string ReadDocumentName ()
		{
			var separator = (char)buffer [position];
			position++;

			var builder = new StringBuilder ();
			for (int i = 0; CanReadMore (); i++) {
				if (i > 0 && separator != 0)
					builder.Append (separator);

				uint part = ReadCompressedUInt32 ();
				if (part != 0)
					builder.Append (reader.ReadUTF8StringBlob (part));
			}

			return builder.ToString ();
		}

		public Collection<SequencePoint> ReadSequencePoints (Document document)
		{
			ReadCompressedUInt32 (); // local_sig_token

			if (document == null)
				document = reader.GetDocument (ReadCompressedUInt32 ());

			var offset = 0;
			var start_line = 0;
			var start_column = 0;
			var first_non_hidden = true;

			//there's about 5 compressed int32's per sequenec points.  we don't know exactly how many
			//but let's take a conservative guess so we dont end up reallocating the sequence_points collection
			//as it grows.
			var bytes_remaining_for_sequencepoints = sig_length - (position - start);
			var estimated_sequencepoint_amount = (int)bytes_remaining_for_sequencepoints / 5;
			var sequence_points = new Collection<SequencePoint> (estimated_sequencepoint_amount);

			for (var i = 0; CanReadMore (); i++) {
				var delta_il = (int)ReadCompressedUInt32 ();
				if (i > 0 && delta_il == 0) {
					document = reader.GetDocument (ReadCompressedUInt32 ());
					continue;
				}

				offset += delta_il;

				var delta_lines = (int)ReadCompressedUInt32 ();
				var delta_columns = delta_lines == 0
					? (int)ReadCompressedUInt32 ()
					: ReadCompressedInt32 ();

				if (delta_lines == 0 && delta_columns == 0) {
					sequence_points.Add (new SequencePoint (offset, document) {
						StartLine = 0xfeefee,
						EndLine = 0xfeefee,
						StartColumn = 0,
						EndColumn = 0,
					});
					continue;
				}

				if (first_non_hidden) {
					start_line = (int)ReadCompressedUInt32 ();
					start_column = (int)ReadCompressedUInt32 ();
				} else {
					start_line += ReadCompressedInt32 ();
					start_column += ReadCompressedInt32 ();
				}

				sequence_points.Add (new SequencePoint (offset, document) {
					StartLine = start_line,
					StartColumn = start_column,
					EndLine = start_line + delta_lines,
					EndColumn = start_column + delta_columns,
				});
				first_non_hidden = false;
			}

			return sequence_points;
		}

		public bool CanReadMore ()
		{
			return (position - start) < sig_length;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/AssemblyWriter.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Metadata;
using MonoFN.Cecil.PE;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;
using BlobIndex = System.UInt32;
using CodedRID = System.UInt32;
using GuidIndex = System.UInt32;
using RID = System.UInt32;
using RVA = System.UInt32;
using StringIndex = System.UInt32;

namespace MonoFN.Cecil {

	using AssemblyRefRow = Row<ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint, uint>;
	using AssemblyRow = Row<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint>;
	using ClassLayoutRow = Row<ushort, uint, RID>;
	using ConstantRow = Row<ElementType, CodedRID, BlobIndex>;
	using CustomAttributeRow = Row<CodedRID, CodedRID, BlobIndex>;
	using CustomDebugInformationRow = Row<CodedRID, GuidIndex, BlobIndex>;
	using DeclSecurityRow = Row<SecurityAction, CodedRID, BlobIndex>;
	using DocumentRow = Row<BlobIndex, GuidIndex, BlobIndex, GuidIndex>;
	using EventMapRow = Row<RID, RID>;
	using EventRow = Row<EventAttributes, StringIndex, CodedRID>;
	using ExportedTypeRow = Row<TypeAttributes, uint, StringIndex, StringIndex, CodedRID>;
	using FieldLayoutRow = Row<uint, RID>;
	using FieldMarshalRow = Row<CodedRID, BlobIndex>;
	using FieldRow = Row<FieldAttributes, StringIndex, BlobIndex>;
	using FieldRVARow = Row<RVA, RID>;
	using FileRow = Row<FileAttributes, StringIndex, BlobIndex>;
	using GenericParamConstraintRow = Row<RID, CodedRID>;
	using GenericParamRow = Row<ushort, GenericParameterAttributes, CodedRID, StringIndex>;
	using ImplMapRow = Row<PInvokeAttributes, CodedRID, StringIndex, RID>;
	using ImportScopeRow = Row<RID, BlobIndex>;
	using InterfaceImplRow = Row<uint, CodedRID>;
	using LocalConstantRow = Row<StringIndex, BlobIndex>;
	using LocalScopeRow = Row<RID, RID, RID, RID, uint, uint>;
	using LocalVariableRow = Row<VariableAttributes, ushort, StringIndex>;
	using ManifestResourceRow = Row<uint, ManifestResourceAttributes, StringIndex, CodedRID>;
	using MemberRefRow = Row<CodedRID, StringIndex, BlobIndex>;
	using MethodDebugInformationRow = Row<RID, BlobIndex>;
	using MethodImplRow = Row<RID, CodedRID, CodedRID>;
	using MethodRow = Row<RVA, MethodImplAttributes, MethodAttributes, StringIndex, BlobIndex, RID>;
	using MethodSemanticsRow = Row<MethodSemanticsAttributes, RID, CodedRID>;
	using MethodSpecRow = Row<CodedRID, BlobIndex>;
	using ModuleRow = Row<StringIndex, GuidIndex>;
	using NestedClassRow = Row<RID, RID>;
	using ParamRow = Row<ParameterAttributes, ushort, StringIndex>;
	using PropertyMapRow = Row<RID, RID>;
	using PropertyRow = Row<PropertyAttributes, StringIndex, BlobIndex>;
	using StateMachineMethodRow = Row<RID, RID>;
	using TypeDefRow = Row<TypeAttributes, StringIndex, StringIndex, CodedRID, RID, RID>;
	using TypeRefRow = Row<CodedRID, StringIndex, StringIndex>;

	static class ModuleWriter {

		public static void WriteModule (ModuleDefinition module, Disposable<Stream> stream, WriterParameters parameters)
		{
			using (stream)
				Write (module, stream, parameters);
		}

		static void Write (ModuleDefinition module, Disposable<Stream> stream, WriterParameters parameters)
		{
			if ((module.Attributes & ModuleAttributes.ILOnly) == 0)
				throw new NotSupportedException ("Writing mixed-mode assemblies is not supported");

			if (module.HasImage && module.ReadingMode == ReadingMode.Deferred) {
				var immediate_reader = new ImmediateModuleReader (module.Image);
				immediate_reader.ReadModule (module, resolve_attributes: false);
				immediate_reader.ReadSymbols (module);
			}

			module.MetadataSystem.Clear ();

			if (module.symbol_reader != null)
				module.symbol_reader.Dispose ();

			var name = module.assembly != null && module.kind != ModuleKind.NetModule ? module.assembly.Name : null;
			var fq_name = stream.value.GetFileName ();
			var timestamp = parameters.Timestamp ?? module.timestamp;
			var symbol_writer_provider = parameters.SymbolWriterProvider;

			if (symbol_writer_provider == null && parameters.WriteSymbols)
				symbol_writer_provider = new DefaultSymbolWriterProvider ();

			if (parameters.HasStrongNameKey && name != null) {
				name.PublicKey = CryptoService.GetPublicKey (parameters);
				module.Attributes |= ModuleAttributes.StrongNameSigned;
			}

			if (parameters.DeterministicMvid)
				module.Mvid = Guid.Empty;

			var metadata = new MetadataBuilder (module, fq_name, timestamp, symbol_writer_provider);
			try {
				module.metadata_builder = metadata;

				using (var symbol_writer = GetSymbolWriter (module, fq_name, symbol_writer_provider, parameters)) {
					metadata.SetSymbolWriter (symbol_writer);
					BuildMetadata (module, metadata);

					if (parameters.DeterministicMvid)
						metadata.ComputeDeterministicMvid ();

					var writer = ImageWriter.CreateWriter (module, metadata, stream);
					stream.value.SetLength (0);
					writer.WriteImage ();

					if (parameters.HasStrongNameKey)
						CryptoService.StrongName (stream.value, writer, parameters);
				}
			}
			finally {
				module.metadata_builder = null;
			}
		}

		static void BuildMetadata (ModuleDefinition module, MetadataBuilder metadata)
		{
			if (!module.HasImage) {
				metadata.BuildMetadata ();
				return;
			}

			module.Read (metadata, (builder, _) => {
				builder.BuildMetadata ();
				return builder;
			});
		}

		static ISymbolWriter GetSymbolWriter (ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, WriterParameters parameters)
		{
			if (symbol_writer_provider == null)
				return null;

			if (parameters.SymbolStream != null)
				return symbol_writer_provider.GetSymbolWriter (module, parameters.SymbolStream);

			return symbol_writer_provider.GetSymbolWriter (module, fq_name);
		}
	}

	abstract class MetadataTable {

		public abstract int Length { get; }

		public bool IsLarge {
			get { return Length > ushort.MaxValue; }
		}

		public abstract void Write (TableHeapBuffer buffer);
		public abstract void Sort ();
	}

	abstract class OneRowTable<TRow> : MetadataTable where TRow : struct {

		internal TRow row;

		public sealed override int Length {
			get { return 1; }
		}

		public sealed override void Sort ()
		{
		}
	}

	abstract class MetadataTable<TRow> : MetadataTable where TRow : struct {

		internal TRow [] rows = new TRow [2];
		internal int length;

		public sealed override int Length {
			get { return length; }
		}

		public int AddRow (TRow row)
		{
			if (rows.Length == length)
				Grow ();

			rows [length++] = row;
			return length;
		}

		void Grow ()
		{
			var rows = new TRow [this.rows.Length * 2];
			Array.Copy (this.rows, rows, this.rows.Length);
			this.rows = rows;
		}

		public override void Sort ()
		{
		}
	}

	abstract class SortedTable<TRow> : MetadataTable<TRow>, IComparer<TRow> where TRow : struct {

		public sealed override void Sort ()
		{
			MergeSort<TRow>.Sort (rows, 0, this.length, this);
		}

		protected static int Compare (uint x, uint y)
		{
			return x == y ? 0 : x > y ? 1 : -1;
		}

		public abstract int Compare (TRow x, TRow y);
	}

	sealed class ModuleTable : OneRowTable<ModuleRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			buffer.WriteUInt16 (0);     // Generation
			buffer.WriteString (row.Col1);  // Name
			buffer.WriteGuid (row.Col2);        // Mvid
			buffer.WriteUInt16 (0);     // EncId
			buffer.WriteUInt16 (0);     // EncBaseId
		}
	}

	sealed class TypeRefTable : MetadataTable<TypeRefRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteCodedRID (
					rows [i].Col1, CodedIndex.ResolutionScope); // Scope
				buffer.WriteString (rows [i].Col2);         // Name
				buffer.WriteString (rows [i].Col3);         // Namespace
			}
		}
	}

	sealed class TypeDefTable : MetadataTable<TypeDefRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt32 ((uint)rows [i].Col1);   // Attributes
				buffer.WriteString (rows [i].Col2);         // Name
				buffer.WriteString (rows [i].Col3);         // Namespace
				buffer.WriteCodedRID (
					rows [i].Col4, CodedIndex.TypeDefOrRef);    // Extends
				buffer.WriteRID (rows [i].Col5, Table.Field);   // FieldList
				buffer.WriteRID (rows [i].Col6, Table.Method);  // MethodList
			}
		}
	}

	sealed class FieldTable : MetadataTable<FieldRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1); // Attributes
				buffer.WriteString (rows [i].Col2);         // Name
				buffer.WriteBlob (rows [i].Col3);           // Signature
			}
		}
	}

	sealed class MethodTable : MetadataTable<MethodRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt32 (rows [i].Col1);     // RVA
				buffer.WriteUInt16 ((ushort)rows [i].Col2); // ImplFlags
				buffer.WriteUInt16 ((ushort)rows [i].Col3); // Flags
				buffer.WriteString (rows [i].Col4);     // Name
				buffer.WriteBlob (rows [i].Col5);       // Signature
				buffer.WriteRID (rows [i].Col6, Table.Param);   // ParamList
			}
		}
	}

	sealed class ParamTable : MetadataTable<ParamRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1); // Attributes
				buffer.WriteUInt16 (rows [i].Col2);     // Sequence
				buffer.WriteString (rows [i].Col3);     // Name
			}
		}
	}

	sealed class InterfaceImplTable : MetadataTable<InterfaceImplRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.TypeDef);     // Class
				buffer.WriteCodedRID (rows [i].Col2, CodedIndex.TypeDefOrRef);  // Interface
			}
		}

		/*public override int Compare (InterfaceImplRow x, InterfaceImplRow y)
		{
			return (int) (x.Col1 == y.Col1 ? y.Col2 - x.Col2 : x.Col1 - y.Col1);
		}*/
	}

	sealed class MemberRefTable : MetadataTable<MemberRefRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteCodedRID (rows [i].Col1, CodedIndex.MemberRefParent);
				buffer.WriteString (rows [i].Col2);
				buffer.WriteBlob (rows [i].Col3);
			}
		}
	}

	sealed class ConstantTable : SortedTable<ConstantRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1);
				buffer.WriteCodedRID (rows [i].Col2, CodedIndex.HasConstant);
				buffer.WriteBlob (rows [i].Col3);
			}
		}

		public override int Compare (ConstantRow x, ConstantRow y)
		{
			return Compare (x.Col2, y.Col2);
		}
	}

	sealed class CustomAttributeTable : SortedTable<CustomAttributeRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteCodedRID (rows [i].Col1, CodedIndex.HasCustomAttribute);    // Parent
				buffer.WriteCodedRID (rows [i].Col2, CodedIndex.CustomAttributeType);   // Type
				buffer.WriteBlob (rows [i].Col3);
			}
		}

		public override int Compare (CustomAttributeRow x, CustomAttributeRow y)
		{
			return Compare (x.Col1, y.Col1);
		}
	}

	sealed class FieldMarshalTable : SortedTable<FieldMarshalRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteCodedRID (rows [i].Col1, CodedIndex.HasFieldMarshal);
				buffer.WriteBlob (rows [i].Col2);
			}
		}

		public override int Compare (FieldMarshalRow x, FieldMarshalRow y)
		{
			return Compare (x.Col1, y.Col1);
		}
	}

	sealed class DeclSecurityTable : SortedTable<DeclSecurityRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1);
				buffer.WriteCodedRID (rows [i].Col2, CodedIndex.HasDeclSecurity);
				buffer.WriteBlob (rows [i].Col3);
			}
		}

		public override int Compare (DeclSecurityRow x, DeclSecurityRow y)
		{
			return Compare (x.Col2, y.Col2);
		}
	}

	sealed class ClassLayoutTable : SortedTable<ClassLayoutRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 (rows [i].Col1);     // PackingSize
				buffer.WriteUInt32 (rows [i].Col2);     // ClassSize
				buffer.WriteRID (rows [i].Col3, Table.TypeDef); // Parent
			}
		}

		public override int Compare (ClassLayoutRow x, ClassLayoutRow y)
		{
			return Compare (x.Col3, y.Col3);
		}
	}

	sealed class FieldLayoutTable : SortedTable<FieldLayoutRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt32 (rows [i].Col1);     // Offset
				buffer.WriteRID (rows [i].Col2, Table.Field);   // Parent
			}
		}

		public override int Compare (FieldLayoutRow x, FieldLayoutRow y)
		{
			return Compare (x.Col2, y.Col2);
		}
	}

	sealed class StandAloneSigTable : MetadataTable<uint> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
				buffer.WriteBlob (rows [i]);
		}
	}

	sealed class EventMapTable : MetadataTable<EventMapRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.TypeDef);     // Parent
				buffer.WriteRID (rows [i].Col2, Table.Event);       // EventList
			}
		}
	}

	sealed class EventTable : MetadataTable<EventRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1); // Flags
				buffer.WriteString (rows [i].Col2);     // Name
				buffer.WriteCodedRID (rows [i].Col3, CodedIndex.TypeDefOrRef);  // EventType
			}
		}
	}

	sealed class PropertyMapTable : MetadataTable<PropertyMapRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.TypeDef);     // Parent
				buffer.WriteRID (rows [i].Col2, Table.Property);    // PropertyList
			}
		}
	}

	sealed class PropertyTable : MetadataTable<PropertyRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1); // Flags
				buffer.WriteString (rows [i].Col2);     // Name
				buffer.WriteBlob (rows [i].Col3);       // Type
			}
		}
	}

	sealed class MethodSemanticsTable : SortedTable<MethodSemanticsRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1); // Flags
				buffer.WriteRID (rows [i].Col2, Table.Method);  // Method
				buffer.WriteCodedRID (rows [i].Col3, CodedIndex.HasSemantics);  // Association
			}
		}

		public override int Compare (MethodSemanticsRow x, MethodSemanticsRow y)
		{
			return Compare (x.Col3, y.Col3);
		}
	}

	sealed class MethodImplTable : MetadataTable<MethodImplRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.TypeDef); // Class
				buffer.WriteCodedRID (rows [i].Col2, CodedIndex.MethodDefOrRef);    // MethodBody
				buffer.WriteCodedRID (rows [i].Col3, CodedIndex.MethodDefOrRef);    // MethodDeclaration
			}
		}
	}

	sealed class ModuleRefTable : MetadataTable<uint> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
				buffer.WriteString (rows [i]);  // Name
		}
	}

	sealed class TypeSpecTable : MetadataTable<uint> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
				buffer.WriteBlob (rows [i]);    // Signature
		}
	}

	sealed class ImplMapTable : SortedTable<ImplMapRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1); // Flags
				buffer.WriteCodedRID (rows [i].Col2, CodedIndex.MemberForwarded);   // MemberForwarded
				buffer.WriteString (rows [i].Col3);     // ImportName
				buffer.WriteRID (rows [i].Col4, Table.ModuleRef);   // ImportScope
			}
		}

		public override int Compare (ImplMapRow x, ImplMapRow y)
		{
			return Compare (x.Col2, y.Col2);
		}
	}

	sealed class FieldRVATable : SortedTable<FieldRVARow> {

		internal int position;

		public override void Write (TableHeapBuffer buffer)
		{
			position = buffer.position;
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt32 (rows [i].Col1);     // RVA
				buffer.WriteRID (rows [i].Col2, Table.Field);   // Field
			}
		}

		public override int Compare (FieldRVARow x, FieldRVARow y)
		{
			return Compare (x.Col2, y.Col2);
		}
	}

	sealed class AssemblyTable : OneRowTable<AssemblyRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			buffer.WriteUInt32 ((uint)row.Col1);    // AssemblyHashAlgorithm
			buffer.WriteUInt16 (row.Col2);          // MajorVersion
			buffer.WriteUInt16 (row.Col3);          // MinorVersion
			buffer.WriteUInt16 (row.Col4);          // Build
			buffer.WriteUInt16 (row.Col5);          // Revision
			buffer.WriteUInt32 ((uint)row.Col6);    // Flags
			buffer.WriteBlob (row.Col7);            // PublicKey
			buffer.WriteString (row.Col8);          // Name
			buffer.WriteString (row.Col9);          // Culture
		}
	}

	sealed class AssemblyRefTable : MetadataTable<AssemblyRefRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 (rows [i].Col1);     // MajorVersion
				buffer.WriteUInt16 (rows [i].Col2);     // MinorVersion
				buffer.WriteUInt16 (rows [i].Col3);     // Build
				buffer.WriteUInt16 (rows [i].Col4);     // Revision
				buffer.WriteUInt32 ((uint)rows [i].Col5);   // Flags
				buffer.WriteBlob (rows [i].Col6);       // PublicKeyOrToken
				buffer.WriteString (rows [i].Col7);     // Name
				buffer.WriteString (rows [i].Col8);     // Culture
				buffer.WriteBlob (rows [i].Col9);       // Hash
			}
		}
	}

	sealed class FileTable : MetadataTable<FileRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt32 ((uint)rows [i].Col1);
				buffer.WriteString (rows [i].Col2);
				buffer.WriteBlob (rows [i].Col3);
			}
		}
	}

	sealed class ExportedTypeTable : MetadataTable<ExportedTypeRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt32 ((uint)rows [i].Col1);
				buffer.WriteUInt32 (rows [i].Col2);
				buffer.WriteString (rows [i].Col3);
				buffer.WriteString (rows [i].Col4);
				buffer.WriteCodedRID (rows [i].Col5, CodedIndex.Implementation);
			}
		}
	}

	sealed class ManifestResourceTable : MetadataTable<ManifestResourceRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt32 (rows [i].Col1);
				buffer.WriteUInt32 ((uint)rows [i].Col2);
				buffer.WriteString (rows [i].Col3);
				buffer.WriteCodedRID (rows [i].Col4, CodedIndex.Implementation);
			}
		}
	}

	sealed class NestedClassTable : SortedTable<NestedClassRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.TypeDef);     // NestedClass
				buffer.WriteRID (rows [i].Col2, Table.TypeDef);     // EnclosingClass
			}
		}

		public override int Compare (NestedClassRow x, NestedClassRow y)
		{
			return Compare (x.Col1, y.Col1);
		}
	}

	sealed class GenericParamTable : MetadataTable<GenericParamRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 (rows [i].Col1);     // Number
				buffer.WriteUInt16 ((ushort)rows [i].Col2); // Flags
				buffer.WriteCodedRID (rows [i].Col3, CodedIndex.TypeOrMethodDef);   // Owner
				buffer.WriteString (rows [i].Col4);     // Name
			}
		}
	}

	sealed class MethodSpecTable : MetadataTable<MethodSpecRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteCodedRID (rows [i].Col1, CodedIndex.MethodDefOrRef);    // Method
				buffer.WriteBlob (rows [i].Col2);   // Instantiation
			}
		}
	}

	sealed class GenericParamConstraintTable : MetadataTable<GenericParamConstraintRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.GenericParam);    // Owner
				buffer.WriteCodedRID (rows [i].Col2, CodedIndex.TypeDefOrRef);  // Constraint
			}
		}
	}

	sealed class DocumentTable : MetadataTable<DocumentRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteBlob (rows [i].Col1);   // Name
				buffer.WriteGuid (rows [i].Col2);   // HashAlgorithm
				buffer.WriteBlob (rows [i].Col3);   // Hash
				buffer.WriteGuid (rows [i].Col4);   // Language
			}
		}
	}

	sealed class MethodDebugInformationTable : MetadataTable<MethodDebugInformationRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.Document);    // Document
				buffer.WriteBlob (rows [i].Col2);   // SequencePoints
			}
		}
	}

	sealed class LocalScopeTable : MetadataTable<LocalScopeRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.Method);  // Method
				buffer.WriteRID (rows [i].Col2, Table.ImportScope); // ImportScope
				buffer.WriteRID (rows [i].Col3, Table.LocalVariable); // VariableList
				buffer.WriteRID (rows [i].Col4, Table.LocalConstant); // ConstantList
				buffer.WriteUInt32 (rows [i].Col5); // StartOffset
				buffer.WriteUInt32 (rows [i].Col6); // Length
			}
		}
	}

	sealed class LocalVariableTable : MetadataTable<LocalVariableRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteUInt16 ((ushort)rows [i].Col1); // Attributes
				buffer.WriteUInt16 (rows [i].Col2); // Index
				buffer.WriteString (rows [i].Col3); // Name
			}
		}
	}

	sealed class LocalConstantTable : MetadataTable<LocalConstantRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteString (rows [i].Col1); // Name
				buffer.WriteBlob (rows [i].Col2);   // Signature
			}
		}
	}

	sealed class ImportScopeTable : MetadataTable<ImportScopeRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.ImportScope); // Parent
				buffer.WriteBlob (rows [i].Col2);   // Imports
			}
		}
	}

	sealed class StateMachineMethodTable : MetadataTable<StateMachineMethodRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteRID (rows [i].Col1, Table.Method);  // MoveNextMethod
				buffer.WriteRID (rows [i].Col2, Table.Method);  // KickoffMethod
			}
		}
	}

	sealed class CustomDebugInformationTable : SortedTable<CustomDebugInformationRow> {

		public override void Write (TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++) {
				buffer.WriteCodedRID (rows [i].Col1, CodedIndex.HasCustomDebugInformation); // Parent
				buffer.WriteGuid (rows [i].Col2);   // Kind
				buffer.WriteBlob (rows [i].Col3);   // Value
			}
		}

		public override int Compare (CustomDebugInformationRow x, CustomDebugInformationRow y)
		{
			return Compare (x.Col1, y.Col1);
		}
	}

	sealed class MetadataBuilder {

		readonly internal ModuleDefinition module;
		readonly internal ISymbolWriterProvider symbol_writer_provider;
		internal ISymbolWriter symbol_writer;
		readonly internal TextMap text_map;
		readonly internal string fq_name;
		readonly internal uint timestamp;

		readonly Dictionary<TypeRefRow, MetadataToken> type_ref_map;
		readonly Dictionary<uint, MetadataToken> type_spec_map;
		readonly Dictionary<MemberRefRow, MetadataToken> member_ref_map;
		readonly Dictionary<MethodSpecRow, MetadataToken> method_spec_map;
		readonly Collection<GenericParameter> generic_parameters;

		readonly internal CodeWriter code;
		readonly internal DataBuffer data;
		readonly internal ResourceBuffer resources;
		readonly internal StringHeapBuffer string_heap;
		readonly internal GuidHeapBuffer guid_heap;
		readonly internal UserStringHeapBuffer user_string_heap;
		readonly internal BlobHeapBuffer blob_heap;
		readonly internal TableHeapBuffer table_heap;
		readonly internal PdbHeapBuffer pdb_heap;

		internal MetadataToken entry_point;

		internal RID type_rid = 1;
		internal RID field_rid = 1;
		internal RID method_rid = 1;
		internal RID param_rid = 1;
		internal RID property_rid = 1;
		internal RID event_rid = 1;
		internal RID local_variable_rid = 1;
		internal RID local_constant_rid = 1;

		readonly TypeRefTable type_ref_table;
		readonly TypeDefTable type_def_table;
		readonly FieldTable field_table;
		readonly MethodTable method_table;
		readonly ParamTable param_table;
		readonly InterfaceImplTable iface_impl_table;
		readonly MemberRefTable member_ref_table;
		readonly ConstantTable constant_table;
		readonly CustomAttributeTable custom_attribute_table;
		readonly DeclSecurityTable declsec_table;
		readonly StandAloneSigTable standalone_sig_table;
		readonly EventMapTable event_map_table;
		readonly EventTable event_table;
		readonly PropertyMapTable property_map_table;
		readonly PropertyTable property_table;
		readonly TypeSpecTable typespec_table;
		readonly MethodSpecTable method_spec_table;

		internal MetadataBuilder metadata_builder;

		readonly DocumentTable document_table;
		readonly MethodDebugInformationTable method_debug_information_table;
		readonly LocalScopeTable local_scope_table;
		readonly LocalVariableTable local_variable_table;
		readonly LocalConstantTable local_constant_table;
		readonly ImportScopeTable import_scope_table;
		readonly StateMachineMethodTable state_machine_method_table;
		readonly CustomDebugInformationTable custom_debug_information_table;

		readonly Dictionary<ImportScopeRow, MetadataToken> import_scope_map;
		readonly Dictionary<string, MetadataToken> document_map;

		public MetadataBuilder (ModuleDefinition module, string fq_name, uint timestamp, ISymbolWriterProvider symbol_writer_provider)
		{
			this.module = module;
			this.text_map = CreateTextMap ();
			this.fq_name = fq_name;
			this.timestamp = timestamp;
			this.symbol_writer_provider = symbol_writer_provider;

			this.code = new CodeWriter (this);
			this.data = new DataBuffer ();
			this.resources = new ResourceBuffer ();
			this.string_heap = new StringHeapBuffer ();
			this.guid_heap = new GuidHeapBuffer ();
			this.user_string_heap = new UserStringHeapBuffer ();
			this.blob_heap = new BlobHeapBuffer ();
			this.table_heap = new TableHeapBuffer (module, this);

			this.type_ref_table = GetTable<TypeRefTable> (Table.TypeRef);
			this.type_def_table = GetTable<TypeDefTable> (Table.TypeDef);
			this.field_table = GetTable<FieldTable> (Table.Field);
			this.method_table = GetTable<MethodTable> (Table.Method);
			this.param_table = GetTable<ParamTable> (Table.Param);
			this.iface_impl_table = GetTable<InterfaceImplTable> (Table.InterfaceImpl);
			this.member_ref_table = GetTable<MemberRefTable> (Table.MemberRef);
			this.constant_table = GetTable<ConstantTable> (Table.Constant);
			this.custom_attribute_table = GetTable<CustomAttributeTable> (Table.CustomAttribute);
			this.declsec_table = GetTable<DeclSecurityTable> (Table.DeclSecurity);
			this.standalone_sig_table = GetTable<StandAloneSigTable> (Table.StandAloneSig);
			this.event_map_table = GetTable<EventMapTable> (Table.EventMap);
			this.event_table = GetTable<EventTable> (Table.Event);
			this.property_map_table = GetTable<PropertyMapTable> (Table.PropertyMap);
			this.property_table = GetTable<PropertyTable> (Table.Property);
			this.typespec_table = GetTable<TypeSpecTable> (Table.TypeSpec);
			this.method_spec_table = GetTable<MethodSpecTable> (Table.MethodSpec);

			var row_equality_comparer = new RowEqualityComparer ();
			type_ref_map = new Dictionary<TypeRefRow, MetadataToken> (row_equality_comparer);
			type_spec_map = new Dictionary<uint, MetadataToken> ();
			member_ref_map = new Dictionary<MemberRefRow, MetadataToken> (row_equality_comparer);
			method_spec_map = new Dictionary<MethodSpecRow, MetadataToken> (row_equality_comparer);
			generic_parameters = new Collection<GenericParameter> ();

			this.document_table = GetTable<DocumentTable> (Table.Document);
			this.method_debug_information_table = GetTable<MethodDebugInformationTable> (Table.MethodDebugInformation);
			this.local_scope_table = GetTable<LocalScopeTable> (Table.LocalScope);
			this.local_variable_table = GetTable<LocalVariableTable> (Table.LocalVariable);
			this.local_constant_table = GetTable<LocalConstantTable> (Table.LocalConstant);
			this.import_scope_table = GetTable<ImportScopeTable> (Table.ImportScope);
			this.state_machine_method_table = GetTable<StateMachineMethodTable> (Table.StateMachineMethod);
			this.custom_debug_information_table = GetTable<CustomDebugInformationTable> (Table.CustomDebugInformation);

			this.document_map = new Dictionary<string, MetadataToken> (StringComparer.Ordinal);
			this.import_scope_map = new Dictionary<ImportScopeRow, MetadataToken> (row_equality_comparer);
		}

		public MetadataBuilder (ModuleDefinition module, PortablePdbWriterProvider writer_provider)
		{
			this.module = module;
			this.text_map = new TextMap ();
			this.symbol_writer_provider = writer_provider;

			this.string_heap = new StringHeapBuffer ();
			this.guid_heap = new GuidHeapBuffer ();
			this.user_string_heap = new UserStringHeapBuffer ();
			this.blob_heap = new BlobHeapBuffer ();
			this.table_heap = new TableHeapBuffer (module, this);
			this.pdb_heap = new PdbHeapBuffer ();

			this.document_table = GetTable<DocumentTable> (Table.Document);
			this.method_debug_information_table = GetTable<MethodDebugInformationTable> (Table.MethodDebugInformation);
			this.local_scope_table = GetTable<LocalScopeTable> (Table.LocalScope);
			this.local_variable_table = GetTable<LocalVariableTable> (Table.LocalVariable);
			this.local_constant_table = GetTable<LocalConstantTable> (Table.LocalConstant);
			this.import_scope_table = GetTable<ImportScopeTable> (Table.ImportScope);
			this.state_machine_method_table = GetTable<StateMachineMethodTable> (Table.StateMachineMethod);
			this.custom_debug_information_table = GetTable<CustomDebugInformationTable> (Table.CustomDebugInformation);

			var row_equality_comparer = new RowEqualityComparer ();

			this.document_map = new Dictionary<string, MetadataToken> ();
			this.import_scope_map = new Dictionary<ImportScopeRow, MetadataToken> (row_equality_comparer);
		}

		public void SetSymbolWriter (ISymbolWriter writer)
		{
			symbol_writer = writer;

			if (symbol_writer == null && module.HasImage && module.Image.HasDebugTables ())
				symbol_writer = new PortablePdbWriter (this, module);
		}

		TextMap CreateTextMap ()
		{
			var map = new TextMap ();
			map.AddMap (TextSegment.ImportAddressTable, module.Architecture == TargetArchitecture.I386 ? 8 : 0);
			map.AddMap (TextSegment.CLIHeader, 0x48, 8);
			return map;
		}

		TTable GetTable<TTable> (Table table) where TTable : MetadataTable, new()
		{
			return table_heap.GetTable<TTable> (table);
		}

		uint GetStringIndex (string @string)
		{
			if (string.IsNullOrEmpty (@string))
				return 0;

			return string_heap.GetStringIndex (@string);
		}

		uint GetGuidIndex (Guid guid)
		{
			return guid_heap.GetGuidIndex (guid);
		}

		uint GetBlobIndex (ByteBuffer blob)
		{
			if (blob.length == 0)
				return 0;

			return blob_heap.GetBlobIndex (blob);
		}

		uint GetBlobIndex (byte [] blob)
		{
			if (blob.IsNullOrEmpty ())
				return 0;

			return GetBlobIndex (new ByteBuffer (blob));
		}

		public void BuildMetadata ()
		{
			BuildModule ();

			table_heap.string_offsets = string_heap.WriteStrings ();
			table_heap.ComputeTableInformations ();
			table_heap.WriteTableHeap ();
		}

		void BuildModule ()
		{
			var table = GetTable<ModuleTable> (Table.Module);
			table.row.Col1 = GetStringIndex (module.Name);
			table.row.Col2 = GetGuidIndex (module.Mvid);

			var assembly = module.Assembly;

			if (module.kind != ModuleKind.NetModule && assembly != null)
				BuildAssembly ();

			if (module.HasAssemblyReferences)
				AddAssemblyReferences ();

			if (module.HasModuleReferences)
				AddModuleReferences ();

			if (module.HasResources)
				AddResources ();

			if (module.HasExportedTypes)
				AddExportedTypes ();

			BuildTypes ();

			if (module.kind != ModuleKind.NetModule && assembly != null) {
				if (assembly.HasCustomAttributes)
					AddCustomAttributes (assembly);

				if (assembly.HasSecurityDeclarations)
					AddSecurityDeclarations (assembly);
			}

			if (module.HasCustomAttributes)
				AddCustomAttributes (module);

			if (module.EntryPoint != null)
				entry_point = LookupToken (module.EntryPoint);
		}

		void BuildAssembly ()
		{
			var assembly = module.Assembly;
			var name = assembly.Name;

			var table = GetTable<AssemblyTable> (Table.Assembly);

			table.row = new AssemblyRow (
				name.HashAlgorithm,
				(ushort)name.Version.Major,
				(ushort)name.Version.Minor,
				(ushort)name.Version.Build,
				(ushort)name.Version.Revision,
				name.Attributes,
				GetBlobIndex (name.PublicKey),
				GetStringIndex (name.Name),
				GetStringIndex (name.Culture));

			if (assembly.Modules.Count > 1)
				BuildModules ();
		}

		void BuildModules ()
		{
			var modules = this.module.Assembly.Modules;
			var table = GetTable<FileTable> (Table.File);

			for (int i = 0; i < modules.Count; i++) {
				var module = modules [i];
				if (module.IsMain)
					continue;

#if NET_CORE
				throw new NotSupportedException ();
#else
				var parameters = new WriterParameters {
					SymbolWriterProvider = symbol_writer_provider,
				};

				var file_name = GetModuleFileName (module.Name);
				module.Write (file_name, parameters);

				var hash = CryptoService.ComputeHash (file_name);

				table.AddRow (new FileRow (
					FileAttributes.ContainsMetaData,
					GetStringIndex (module.Name),
					GetBlobIndex (hash)));
#endif
			}
		}

#if !NET_CORE
		string GetModuleFileName (string name)
		{
			if (string.IsNullOrEmpty (name))
				throw new NotSupportedException ();

			var path = Path.GetDirectoryName (fq_name);
			return Path.Combine (path, name);
		}
#endif

		void AddAssemblyReferences ()
		{
			var references = module.AssemblyReferences;
			var table = GetTable<AssemblyRefTable> (Table.AssemblyRef);

			if (module.IsWindowsMetadata ())
				module.Projections.RemoveVirtualReferences (references);

			for (int i = 0; i < references.Count; i++) {
				var reference = references [i];

				var key_or_token = reference.PublicKey.IsNullOrEmpty ()
					? reference.PublicKeyToken
					: reference.PublicKey;

				var version = reference.Version;

				var rid = table.AddRow (new AssemblyRefRow (
					(ushort)version.Major,
					(ushort)version.Minor,
					(ushort)version.Build,
					(ushort)version.Revision,
					reference.Attributes,
					GetBlobIndex (key_or_token),
					GetStringIndex (reference.Name),
					GetStringIndex (reference.Culture),
					GetBlobIndex (reference.Hash)));

				reference.token = new MetadataToken (TokenType.AssemblyRef, rid);
			}

			if (module.IsWindowsMetadata ())
				module.Projections.AddVirtualReferences (references);
		}

		void AddModuleReferences ()
		{
			var references = module.ModuleReferences;
			var table = GetTable<ModuleRefTable> (Table.ModuleRef);

			for (int i = 0; i < references.Count; i++) {
				var reference = references [i];

				reference.token = new MetadataToken (
					TokenType.ModuleRef,
					table.AddRow (GetStringIndex (reference.Name)));
			}
		}

		void AddResources ()
		{
			var resources = module.Resources;
			var table = GetTable<ManifestResourceTable> (Table.ManifestResource);

			for (int i = 0; i < resources.Count; i++) {
				var resource = resources [i];

				var row = new ManifestResourceRow (
					0,
					resource.Attributes,
					GetStringIndex (resource.Name),
					0);

				switch (resource.ResourceType) {
				case ResourceType.Embedded:
					row.Col1 = AddEmbeddedResource ((EmbeddedResource)resource);
					break;
				case ResourceType.Linked:
					row.Col4 = CodedIndex.Implementation.CompressMetadataToken (
						new MetadataToken (
							TokenType.File,
							AddLinkedResource ((LinkedResource)resource)));
					break;
				case ResourceType.AssemblyLinked:
					row.Col4 = CodedIndex.Implementation.CompressMetadataToken (
						((AssemblyLinkedResource)resource).Assembly.MetadataToken);
					break;
				default:
					throw new NotSupportedException ();
				}

				table.AddRow (row);
			}
		}

		uint AddLinkedResource (LinkedResource resource)
		{
			var table = GetTable<FileTable> (Table.File);
			var hash = resource.Hash;

			if (hash.IsNullOrEmpty ())
				hash = CryptoService.ComputeHash (resource.File);

			return (uint)table.AddRow (new FileRow (
				FileAttributes.ContainsNoMetaData,
				GetStringIndex (resource.File),
				GetBlobIndex (hash)));
		}

		uint AddEmbeddedResource (EmbeddedResource resource)
		{
			return resources.AddResource (resource.GetResourceData ());
		}

		void AddExportedTypes ()
		{
			var exported_types = module.ExportedTypes;
			var table = GetTable<ExportedTypeTable> (Table.ExportedType);

			for (int i = 0; i < exported_types.Count; i++) {
				var exported_type = exported_types [i];

				var rid = table.AddRow (new ExportedTypeRow (
					exported_type.Attributes,
					(uint)exported_type.Identifier,
					GetStringIndex (exported_type.Name),
					GetStringIndex (exported_type.Namespace),
					MakeCodedRID (GetExportedTypeScope (exported_type), CodedIndex.Implementation)));

				exported_type.token = new MetadataToken (TokenType.ExportedType, rid);
			}
		}

		MetadataToken GetExportedTypeScope (ExportedType exported_type)
		{
			if (exported_type.DeclaringType != null)
				return exported_type.DeclaringType.MetadataToken;

			var scope = exported_type.Scope;
			switch (scope.MetadataToken.TokenType) {
			case TokenType.AssemblyRef:
				return scope.MetadataToken;
			case TokenType.ModuleRef:
				var file_table = GetTable<FileTable> (Table.File);
				for (int i = 0; i < file_table.length; i++)
					if (file_table.rows [i].Col2 == GetStringIndex (scope.Name))
						return new MetadataToken (TokenType.File, i + 1);

				break;
			}

			throw new NotSupportedException ();
		}

		void BuildTypes ()
		{
			if (!module.HasTypes)
				return;

			AttachTokens ();
			AddTypes ();
			AddGenericParameters ();
		}

		void AttachTokens ()
		{
			var types = module.Types;

			for (int i = 0; i < types.Count; i++)
				AttachTypeToken (types [i]);
		}

		void AttachTypeToken (TypeDefinition type)
		{
			var treatment = WindowsRuntimeProjections.RemoveProjection (type);

			type.token = new MetadataToken (TokenType.TypeDef, type_rid++);
			type.fields_range.Start = field_rid;
			type.methods_range.Start = method_rid;

			if (type.HasFields)
				AttachFieldsToken (type);

			if (type.HasMethods)
				AttachMethodsToken (type);

			if (type.HasNestedTypes)
				AttachNestedTypesToken (type);

			WindowsRuntimeProjections.ApplyProjection (type, treatment);
		}

		void AttachNestedTypesToken (TypeDefinition type)
		{
			var nested_types = type.NestedTypes;
			for (int i = 0; i < nested_types.Count; i++)
				AttachTypeToken (nested_types [i]);
		}

		void AttachFieldsToken (TypeDefinition type)
		{
			var fields = type.Fields;
			type.fields_range.Length = (uint)fields.Count;
			for (int i = 0; i < fields.Count; i++)
				fields [i].token = new MetadataToken (TokenType.Field, field_rid++);
		}

		void AttachMethodsToken (TypeDefinition type)
		{
			var methods = type.Methods;
			type.methods_range.Length = (uint)methods.Count;
			for (int i = 0; i < methods.Count; i++)
				methods [i].token = new MetadataToken (TokenType.Method, method_rid++);
		}

		MetadataToken GetTypeToken (TypeReference type)
		{
			if (type == null)
				return MetadataToken.Zero;

			if (type.IsDefinition)
				return type.token;

			if (type.IsTypeSpecification ())
				return GetTypeSpecToken (type);

			return GetTypeRefToken (type);
		}

		MetadataToken GetTypeSpecToken (TypeReference type)
		{
			var row = GetBlobIndex (GetTypeSpecSignature (type));

			MetadataToken token;
			if (type_spec_map.TryGetValue (row, out token))
				return token;

			return AddTypeSpecification (type, row);
		}

		MetadataToken AddTypeSpecification (TypeReference type, uint row)
		{
			type.token = new MetadataToken (TokenType.TypeSpec, typespec_table.AddRow (row));

			var token = type.token;
			type_spec_map.Add (row, token);
			return token;
		}

		MetadataToken GetTypeRefToken (TypeReference type)
		{
			var projection = WindowsRuntimeProjections.RemoveProjection (type);

			var row = CreateTypeRefRow (type);

			MetadataToken token;
			if (!type_ref_map.TryGetValue (row, out token))
				token = AddTypeReference (type, row);

			WindowsRuntimeProjections.ApplyProjection (type, projection);

			return token;
		}

		TypeRefRow CreateTypeRefRow (TypeReference type)
		{
			var scope_token = GetScopeToken (type);

			return new TypeRefRow (
				MakeCodedRID (scope_token, CodedIndex.ResolutionScope),
				GetStringIndex (type.Name),
				GetStringIndex (type.Namespace));
		}

		MetadataToken GetScopeToken (TypeReference type)
		{
			if (type.IsNested)
				return GetTypeRefToken (type.DeclaringType);

			var scope = type.Scope;

			if (scope == null)
				return MetadataToken.Zero;

			return scope.MetadataToken;
		}

		static CodedRID MakeCodedRID (IMetadataTokenProvider provider, CodedIndex index)
		{
			return MakeCodedRID (provider.MetadataToken, index);
		}

		static CodedRID MakeCodedRID (MetadataToken token, CodedIndex index)
		{
			return index.CompressMetadataToken (token);
		}

		MetadataToken AddTypeReference (TypeReference type, TypeRefRow row)
		{
			type.token = new MetadataToken (TokenType.TypeRef, type_ref_table.AddRow (row));

			var token = type.token;
			type_ref_map.Add (row, token);
			return token;
		}

		void AddTypes ()
		{
			var types = module.Types;

			for (int i = 0; i < types.Count; i++)
				AddType (types [i]);
		}

		void AddType (TypeDefinition type)
		{
			var treatment = WindowsRuntimeProjections.RemoveProjection (type);

			type_def_table.AddRow (new TypeDefRow (
				type.Attributes,
				GetStringIndex (type.Name),
				GetStringIndex (type.Namespace),
				MakeCodedRID (GetTypeToken (type.BaseType), CodedIndex.TypeDefOrRef),
				type.fields_range.Start,
				type.methods_range.Start));

			if (type.HasGenericParameters)
				AddGenericParameters (type);

			if (type.HasInterfaces)
				AddInterfaces (type);

			if (type.HasLayoutInfo)
				AddLayoutInfo (type);

			if (type.HasFields)
				AddFields (type);

			if (type.HasMethods)
				AddMethods (type);

			if (type.HasProperties)
				AddProperties (type);

			if (type.HasEvents)
				AddEvents (type);

			if (type.HasCustomAttributes)
				AddCustomAttributes (type);

			if (type.HasSecurityDeclarations)
				AddSecurityDeclarations (type);

			if (type.HasNestedTypes)
				AddNestedTypes (type);

			WindowsRuntimeProjections.ApplyProjection (type, treatment);
		}

		void AddGenericParameters (IGenericParameterProvider owner)
		{
			var parameters = owner.GenericParameters;

			for (int i = 0; i < parameters.Count; i++)
				generic_parameters.Add (parameters [i]);
		}

		sealed class GenericParameterComparer : IComparer<GenericParameter> {

			public int Compare (GenericParameter a, GenericParameter b)
			{
				var a_owner = MakeCodedRID (a.Owner, CodedIndex.TypeOrMethodDef);
				var b_owner = MakeCodedRID (b.Owner, CodedIndex.TypeOrMethodDef);
				if (a_owner == b_owner) {
					var a_pos = a.Position;
					var b_pos = b.Position;
					return a_pos == b_pos ? 0 : a_pos > b_pos ? 1 : -1;
				}

				return a_owner > b_owner ? 1 : -1;
			}
		}

		void AddGenericParameters ()
		{
			var items = this.generic_parameters.items;
			var size = this.generic_parameters.size;
			Array.Sort (items, 0, size, new GenericParameterComparer ());

			var generic_param_table = GetTable<GenericParamTable> (Table.GenericParam);
			var generic_param_constraint_table = GetTable<GenericParamConstraintTable> (Table.GenericParamConstraint);

			for (int i = 0; i < size; i++) {
				var generic_parameter = items [i];

				var rid = generic_param_table.AddRow (new GenericParamRow (
					(ushort)generic_parameter.Position,
					generic_parameter.Attributes,
					MakeCodedRID (generic_parameter.Owner, CodedIndex.TypeOrMethodDef),
					GetStringIndex (generic_parameter.Name)));

				generic_parameter.token = new MetadataToken (TokenType.GenericParam, rid);

				if (generic_parameter.HasConstraints)
					AddConstraints (generic_parameter, generic_param_constraint_table);

				if (generic_parameter.HasCustomAttributes)
					AddCustomAttributes (generic_parameter);
			}
		}

		void AddConstraints (GenericParameter generic_parameter, GenericParamConstraintTable table)
		{
			var constraints = generic_parameter.Constraints;

			var gp_rid = generic_parameter.token.RID;

			for (int i = 0; i < constraints.Count; i++) {
				var constraint = constraints [i];

				var rid = table.AddRow (new GenericParamConstraintRow (
					gp_rid,
					MakeCodedRID (GetTypeToken (constraint.ConstraintType), CodedIndex.TypeDefOrRef)));

				constraint.token = new MetadataToken (TokenType.GenericParamConstraint, rid);

				if (constraint.HasCustomAttributes)
					AddCustomAttributes (constraint);
			}
		}

		void AddInterfaces (TypeDefinition type)
		{
			var interfaces = type.Interfaces;
			var type_rid = type.token.RID;

			for (int i = 0; i < interfaces.Count; i++) {
				var iface_impl = interfaces [i];

				var rid = iface_impl_table.AddRow (new InterfaceImplRow (
					type_rid,
					MakeCodedRID (GetTypeToken (iface_impl.InterfaceType), CodedIndex.TypeDefOrRef)));

				iface_impl.token = new MetadataToken (TokenType.InterfaceImpl, rid);

				if (iface_impl.HasCustomAttributes)
					AddCustomAttributes (iface_impl);
			}
		}

		void AddLayoutInfo (TypeDefinition type)
		{
			var table = GetTable<ClassLayoutTable> (Table.ClassLayout);

			table.AddRow (new ClassLayoutRow (
				(ushort)type.PackingSize,
				(uint)type.ClassSize,
				type.token.RID));
		}

		void AddNestedTypes (TypeDefinition type)
		{
			var nested_types = type.NestedTypes;
			var nested_table = GetTable<NestedClassTable> (Table.NestedClass);

			for (int i = 0; i < nested_types.Count; i++) {
				var nested = nested_types [i];
				AddType (nested);
				nested_table.AddRow (new NestedClassRow (nested.token.RID, type.token.RID));
			}
		}

		void AddFields (TypeDefinition type)
		{
			var fields = type.Fields;

			for (int i = 0; i < fields.Count; i++)
				AddField (fields [i]);
		}

		void AddField (FieldDefinition field)
		{
			var projection = WindowsRuntimeProjections.RemoveProjection (field);

			field_table.AddRow (new FieldRow (
				field.Attributes,
				GetStringIndex (field.Name),
				GetBlobIndex (GetFieldSignature (field))));

			if (!field.InitialValue.IsNullOrEmpty ())
				AddFieldRVA (field);

			if (field.HasLayoutInfo)
				AddFieldLayout (field);

			if (field.HasCustomAttributes)
				AddCustomAttributes (field);

			if (field.HasConstant)
				AddConstant (field, field.FieldType);

			if (field.HasMarshalInfo)
				AddMarshalInfo (field);

			WindowsRuntimeProjections.ApplyProjection (field, projection);
		}

		void AddFieldRVA (FieldDefinition field)
		{
			var table = GetTable<FieldRVATable> (Table.FieldRVA);
			table.AddRow (new FieldRVARow (
				data.AddData (field.InitialValue),
				field.token.RID));
		}

		void AddFieldLayout (FieldDefinition field)
		{
			var table = GetTable<FieldLayoutTable> (Table.FieldLayout);
			table.AddRow (new FieldLayoutRow ((uint)field.Offset, field.token.RID));
		}

		void AddMethods (TypeDefinition type)
		{
			var methods = type.Methods;

			for (int i = 0; i < methods.Count; i++)
				AddMethod (methods [i]);
		}

		void AddMethod (MethodDefinition method)
		{
			var projection = WindowsRuntimeProjections.RemoveProjection (method);

			method_table.AddRow (new MethodRow (
				method.HasBody ? code.WriteMethodBody (method) : 0,
				method.ImplAttributes,
				method.Attributes,
				GetStringIndex (method.Name),
				GetBlobIndex (GetMethodSignature (method)),
				param_rid));

			AddParameters (method);

			if (method.HasGenericParameters)
				AddGenericParameters (method);

			if (method.IsPInvokeImpl)
				AddPInvokeInfo (method);

			if (method.HasCustomAttributes)
				AddCustomAttributes (method);

			if (method.HasSecurityDeclarations)
				AddSecurityDeclarations (method);

			if (method.HasOverrides)
				AddOverrides (method);

			WindowsRuntimeProjections.ApplyProjection (method, projection);
		}

		void AddParameters (MethodDefinition method)
		{
			var return_parameter = method.MethodReturnType.parameter;

			if (return_parameter != null && RequiresParameterRow (return_parameter))
				AddParameter (0, return_parameter, param_table);

			if (!method.HasParameters)
				return;

			var parameters = method.Parameters;

			for (int i = 0; i < parameters.Count; i++) {
				var parameter = parameters [i];
				if (!RequiresParameterRow (parameter))
					continue;

				AddParameter ((ushort)(i + 1), parameter, param_table);
			}
		}

		void AddPInvokeInfo (MethodDefinition method)
		{
			var pinvoke = method.PInvokeInfo;
			if (pinvoke == null)
				return;

			var table = GetTable<ImplMapTable> (Table.ImplMap);
			table.AddRow (new ImplMapRow (
				pinvoke.Attributes,
				MakeCodedRID (method, CodedIndex.MemberForwarded),
				GetStringIndex (pinvoke.EntryPoint),
				pinvoke.Module.MetadataToken.RID));
		}

		void AddOverrides (MethodDefinition method)
		{
			var overrides = method.Overrides;
			var table = GetTable<MethodImplTable> (Table.MethodImpl);

			for (int i = 0; i < overrides.Count; i++) {
				table.AddRow (new MethodImplRow (
					method.DeclaringType.token.RID,
					MakeCodedRID (method, CodedIndex.MethodDefOrRef),
					MakeCodedRID (LookupToken (overrides [i]), CodedIndex.MethodDefOrRef)));
			}
		}

		static bool RequiresParameterRow (ParameterDefinition parameter)
		{
			return !string.IsNullOrEmpty (parameter.Name)
				|| parameter.Attributes != ParameterAttributes.None
				|| parameter.HasMarshalInfo
				|| parameter.HasConstant
				|| parameter.HasCustomAttributes;
		}

		void AddParameter (ushort sequence, ParameterDefinition parameter, ParamTable table)
		{
			table.AddRow (new ParamRow (
				parameter.Attributes,
				sequence,
				GetStringIndex (parameter.Name)));

			parameter.token = new MetadataToken (TokenType.Param, param_rid++);

			if (parameter.HasCustomAttributes)
				AddCustomAttributes (parameter);

			if (parameter.HasConstant)
				AddConstant (parameter, parameter.ParameterType);

			if (parameter.HasMarshalInfo)
				AddMarshalInfo (parameter);
		}

		void AddMarshalInfo (IMarshalInfoProvider owner)
		{
			var table = GetTable<FieldMarshalTable> (Table.FieldMarshal);

			table.AddRow (new FieldMarshalRow (
				MakeCodedRID (owner, CodedIndex.HasFieldMarshal),
				GetBlobIndex (GetMarshalInfoSignature (owner))));
		}

		void AddProperties (TypeDefinition type)
		{
			var properties = type.Properties;

			property_map_table.AddRow (new PropertyMapRow (type.token.RID, property_rid));

			for (int i = 0; i < properties.Count; i++)
				AddProperty (properties [i]);
		}

		void AddProperty (PropertyDefinition property)
		{
			property_table.AddRow (new PropertyRow (
				property.Attributes,
				GetStringIndex (property.Name),
				GetBlobIndex (GetPropertySignature (property))));
			property.token = new MetadataToken (TokenType.Property, property_rid++);

			var method = property.GetMethod;
			if (method != null)
				AddSemantic (MethodSemanticsAttributes.Getter, property, method);

			method = property.SetMethod;
			if (method != null)
				AddSemantic (MethodSemanticsAttributes.Setter, property, method);

			if (property.HasOtherMethods)
				AddOtherSemantic (property, property.OtherMethods);

			if (property.HasCustomAttributes)
				AddCustomAttributes (property);

			if (property.HasConstant)
				AddConstant (property, property.PropertyType);
		}

		void AddOtherSemantic (IMetadataTokenProvider owner, Collection<MethodDefinition> others)
		{
			for (int i = 0; i < others.Count; i++)
				AddSemantic (MethodSemanticsAttributes.Other, owner, others [i]);
		}

		void AddEvents (TypeDefinition type)
		{
			var events = type.Events;

			event_map_table.AddRow (new EventMapRow (type.token.RID, event_rid));

			for (int i = 0; i < events.Count; i++)
				AddEvent (events [i]);
		}

		void AddEvent (EventDefinition @event)
		{
			event_table.AddRow (new EventRow (
				@event.Attributes,
				GetStringIndex (@event.Name),
				MakeCodedRID (GetTypeToken (@event.EventType), CodedIndex.TypeDefOrRef)));
			@event.token = new MetadataToken (TokenType.Event, event_rid++);

			var method = @event.AddMethod;
			if (method != null)
				AddSemantic (MethodSemanticsAttributes.AddOn, @event, method);

			method = @event.InvokeMethod;
			if (method != null)
				AddSemantic (MethodSemanticsAttributes.Fire, @event, method);

			method = @event.RemoveMethod;
			if (method != null)
				AddSemantic (MethodSemanticsAttributes.RemoveOn, @event, method);

			if (@event.HasOtherMethods)
				AddOtherSemantic (@event, @event.OtherMethods);

			if (@event.HasCustomAttributes)
				AddCustomAttributes (@event);
		}

		void AddSemantic (MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method)
		{
			method.SemanticsAttributes = semantics;
			var table = GetTable<MethodSemanticsTable> (Table.MethodSemantics);

			table.AddRow (new MethodSemanticsRow (
				semantics,
				method.token.RID,
				MakeCodedRID (provider, CodedIndex.HasSemantics)));
		}

		void AddConstant (IConstantProvider owner, TypeReference type)
		{
			var constant = owner.Constant;
			var etype = GetConstantType (type, constant);

			constant_table.AddRow (new ConstantRow (
				etype,
				MakeCodedRID (owner.MetadataToken, CodedIndex.HasConstant),
				GetBlobIndex (GetConstantSignature (etype, constant))));
		}

		static ElementType GetConstantType (TypeReference constant_type, object constant)
		{
			if (constant == null)
				return ElementType.Class;

			var etype = constant_type.etype;
			switch (etype) {
			case ElementType.None:
				var type = constant_type.CheckedResolve ();
				if (type.IsEnum)
					return GetConstantType (type.GetEnumUnderlyingType (), constant);

				return ElementType.Class;
			case ElementType.String:
				return ElementType.String;
			case ElementType.Object:
				return GetConstantType (constant.GetType ());
			case ElementType.Array:
			case ElementType.SzArray:
			case ElementType.MVar:
			case ElementType.Var:
				return ElementType.Class;
			case ElementType.GenericInst:
				var generic_instance = (GenericInstanceType)constant_type;
				if (generic_instance.ElementType.IsTypeOf ("System", "Nullable`1"))
					return GetConstantType (generic_instance.GenericArguments [0], constant);

				return GetConstantType (((TypeSpecification)constant_type).ElementType, constant);
			case ElementType.CModOpt:
			case ElementType.CModReqD:
			case ElementType.ByRef:
			case ElementType.Sentinel:
				return GetConstantType (((TypeSpecification)constant_type).ElementType, constant);
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I:
			case ElementType.I1:
			case ElementType.I2:
			case ElementType.I4:
			case ElementType.I8:
			case ElementType.U:
			case ElementType.U1:
			case ElementType.U2:
			case ElementType.U4:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
				return GetConstantType (constant.GetType ());
			default:
				return etype;
			}
		}

		static ElementType GetConstantType (Type type)
		{
			switch (Type.GetTypeCode (type)) {
			case TypeCode.Boolean:
				return ElementType.Boolean;
			case TypeCode.Byte:
				return ElementType.U1;
			case TypeCode.SByte:
				return ElementType.I1;
			case TypeCode.Char:
				return ElementType.Char;
			case TypeCode.Int16:
				return ElementType.I2;
			case TypeCode.UInt16:
				return ElementType.U2;
			case TypeCode.Int32:
				return ElementType.I4;
			case TypeCode.UInt32:
				return ElementType.U4;
			case TypeCode.Int64:
				return ElementType.I8;
			case TypeCode.UInt64:
				return ElementType.U8;
			case TypeCode.Single:
				return ElementType.R4;
			case TypeCode.Double:
				return ElementType.R8;
			case TypeCode.String:
				return ElementType.String;
			default:
				throw new NotSupportedException (type.FullName);
			}
		}

		void AddCustomAttributes (ICustomAttributeProvider owner)
		{
			var custom_attributes = owner.CustomAttributes;

			for (int i = 0; i < custom_attributes.Count; i++) {
				var attribute = custom_attributes [i];

				var projection = WindowsRuntimeProjections.RemoveProjection (attribute);

				custom_attribute_table.AddRow (new CustomAttributeRow (
					MakeCodedRID (owner, CodedIndex.HasCustomAttribute),
					MakeCodedRID (LookupToken (attribute.Constructor), CodedIndex.CustomAttributeType),
					GetBlobIndex (GetCustomAttributeSignature (attribute))));

				WindowsRuntimeProjections.ApplyProjection (attribute, projection);
			}
		}

		void AddSecurityDeclarations (ISecurityDeclarationProvider owner)
		{
			var declarations = owner.SecurityDeclarations;

			for (int i = 0; i < declarations.Count; i++) {
				var declaration = declarations [i];

				declsec_table.AddRow (new DeclSecurityRow (
					declaration.Action,
					MakeCodedRID (owner, CodedIndex.HasDeclSecurity),
					GetBlobIndex (GetSecurityDeclarationSignature (declaration))));
			}
		}

		MetadataToken GetMemberRefToken (MemberReference member)
		{
			var row = CreateMemberRefRow (member);

			MetadataToken token;
			if (!member_ref_map.TryGetValue (row, out token))
				token = AddMemberReference (member, row);

			return token;
		}

		MemberRefRow CreateMemberRefRow (MemberReference member)
		{
			return new MemberRefRow (
				MakeCodedRID (GetTypeToken (member.DeclaringType), CodedIndex.MemberRefParent),
				GetStringIndex (member.Name),
				GetBlobIndex (GetMemberRefSignature (member)));
		}

		MetadataToken AddMemberReference (MemberReference member, MemberRefRow row)
		{
			member.token = new MetadataToken (TokenType.MemberRef, member_ref_table.AddRow (row));

			var token = member.token;
			member_ref_map.Add (row, token);
			return token;
		}

		MetadataToken GetMethodSpecToken (MethodSpecification method_spec)
		{
			var row = CreateMethodSpecRow (method_spec);

			MetadataToken token;
			if (method_spec_map.TryGetValue (row, out token))
				return token;

			AddMethodSpecification (method_spec, row);

			return method_spec.token;
		}

		void AddMethodSpecification (MethodSpecification method_spec, MethodSpecRow row)
		{
			method_spec.token = new MetadataToken (TokenType.MethodSpec, method_spec_table.AddRow (row));
			method_spec_map.Add (row, method_spec.token);
		}

		MethodSpecRow CreateMethodSpecRow (MethodSpecification method_spec)
		{
			return new MethodSpecRow (
				MakeCodedRID (LookupToken (method_spec.ElementMethod), CodedIndex.MethodDefOrRef),
				GetBlobIndex (GetMethodSpecSignature (method_spec)));
		}

		SignatureWriter CreateSignatureWriter ()
		{
			return new SignatureWriter (this);
		}

		SignatureWriter GetMethodSpecSignature (MethodSpecification method_spec)
		{
			if (!method_spec.IsGenericInstance)
				throw new NotSupportedException ();

			var generic_instance = (GenericInstanceMethod)method_spec;

			var signature = CreateSignatureWriter ();
			signature.WriteByte (0x0a);

			signature.WriteGenericInstanceSignature (generic_instance);

			return signature;
		}

		public uint AddStandAloneSignature (uint signature)
		{
			return (uint)standalone_sig_table.AddRow (signature);
		}

		public uint GetLocalVariableBlobIndex (Collection<VariableDefinition> variables)
		{
			return GetBlobIndex (GetVariablesSignature (variables));
		}

		public uint GetCallSiteBlobIndex (CallSite call_site)
		{
			return GetBlobIndex (GetMethodSignature (call_site));
		}

		public uint GetConstantTypeBlobIndex (TypeReference constant_type)
		{
			return GetBlobIndex (GetConstantTypeSignature (constant_type));
		}

		SignatureWriter GetVariablesSignature (Collection<VariableDefinition> variables)
		{
			var signature = CreateSignatureWriter ();
			signature.WriteByte (0x7);
			signature.WriteCompressedUInt32 ((uint)variables.Count);
			for (int i = 0; i < variables.Count; i++)
				signature.WriteTypeSignature (variables [i].VariableType);
			return signature;
		}

		SignatureWriter GetConstantTypeSignature (TypeReference constant_type)
		{
			var signature = CreateSignatureWriter ();
			signature.WriteByte (0x6);
			signature.WriteTypeSignature (constant_type);
			return signature;
		}

		SignatureWriter GetFieldSignature (FieldReference field)
		{
			var signature = CreateSignatureWriter ();
			signature.WriteByte (0x6);
			signature.WriteTypeSignature (field.FieldType);
			return signature;
		}

		SignatureWriter GetMethodSignature (IMethodSignature method)
		{
			var signature = CreateSignatureWriter ();
			signature.WriteMethodSignature (method);
			return signature;
		}

		SignatureWriter GetMemberRefSignature (MemberReference member)
		{
			var field = member as FieldReference;
			if (field != null)
				return GetFieldSignature (field);

			var method = member as MethodReference;
			if (method != null)
				return GetMethodSignature (method);

			throw new NotSupportedException ();
		}

		SignatureWriter GetPropertySignature (PropertyDefinition property)
		{
			var signature = CreateSignatureWriter ();
			byte calling_convention = 0x8;
			if (property.HasThis)
				calling_convention |= 0x20;

			uint param_count = 0;
			Collection<ParameterDefinition> parameters = null;

			if (property.HasParameters) {
				parameters = property.Parameters;
				param_count = (uint)parameters.Count;
			}

			signature.WriteByte (calling_convention);
			signature.WriteCompressedUInt32 (param_count);
			signature.WriteTypeSignature (property.PropertyType);

			if (param_count == 0)
				return signature;

			for (int i = 0; i < param_count; i++)
				signature.WriteTypeSignature (parameters [i].ParameterType);

			return signature;
		}

		SignatureWriter GetTypeSpecSignature (TypeReference type)
		{
			var signature = CreateSignatureWriter ();
			signature.WriteTypeSignature (type);
			return signature;
		}

		SignatureWriter GetConstantSignature (ElementType type, object value)
		{
			var signature = CreateSignatureWriter ();

			switch (type) {
			case ElementType.Array:
			case ElementType.SzArray:
			case ElementType.Class:
			case ElementType.Object:
			case ElementType.None:
			case ElementType.Var:
			case ElementType.MVar:
				signature.WriteInt32 (0);
				break;
			case ElementType.String:
				signature.WriteConstantString ((string)value);
				break;
			default:
				signature.WriteConstantPrimitive (value);
				break;
			}

			return signature;
		}

		SignatureWriter GetCustomAttributeSignature (CustomAttribute attribute)
		{
			var signature = CreateSignatureWriter ();
			if (!attribute.resolved) {
				signature.WriteBytes (attribute.GetBlob ());
				return signature;
			}

			signature.WriteUInt16 (0x0001);

			signature.WriteCustomAttributeConstructorArguments (attribute);

			signature.WriteCustomAttributeNamedArguments (attribute);

			return signature;
		}

		SignatureWriter GetSecurityDeclarationSignature (SecurityDeclaration declaration)
		{
			var signature = CreateSignatureWriter ();

			if (!declaration.resolved)
				signature.WriteBytes (declaration.GetBlob ());
			else if (module.Runtime < TargetRuntime.Net_2_0)
				signature.WriteXmlSecurityDeclaration (declaration);
			else
				signature.WriteSecurityDeclaration (declaration);

			return signature;
		}

		SignatureWriter GetMarshalInfoSignature (IMarshalInfoProvider owner)
		{
			var signature = CreateSignatureWriter ();

			signature.WriteMarshalInfo (owner.MarshalInfo);

			return signature;
		}

		static Exception CreateForeignMemberException (MemberReference member)
		{
			return new ArgumentException (string.Format ("Member '{0}' is declared in another module and needs to be imported", member));
		}

		public MetadataToken LookupToken (IMetadataTokenProvider provider)
		{
			if (provider == null)
				throw new ArgumentNullException ();

			if (metadata_builder != null)
				return metadata_builder.LookupToken (provider);

			var member = provider as MemberReference;
			if (member == null || member.Module != module)
				throw CreateForeignMemberException (member);

			var token = provider.MetadataToken;

			switch (token.TokenType) {
			case TokenType.TypeDef:
			case TokenType.Method:
			case TokenType.Field:
			case TokenType.Event:
			case TokenType.Property:
				return token;
			case TokenType.TypeRef:
			case TokenType.TypeSpec:
			case TokenType.GenericParam:
				return GetTypeToken ((TypeReference)provider);
			case TokenType.MethodSpec:
				return GetMethodSpecToken ((MethodSpecification)provider);
			case TokenType.MemberRef:
				return GetMemberRefToken (member);
			default:
				throw new NotSupportedException ();
			}
		}

		public void AddMethodDebugInformation (MethodDebugInformation method_info)
		{
			if (method_info.HasSequencePoints)
				AddSequencePoints (method_info);

			if (method_info.Scope != null)
				AddLocalScope (method_info, method_info.Scope);

			if (method_info.StateMachineKickOffMethod != null)
				AddStateMachineMethod (method_info);

			AddCustomDebugInformations (method_info.Method);
		}

		void AddStateMachineMethod (MethodDebugInformation method_info)
		{
			state_machine_method_table.AddRow (new StateMachineMethodRow (method_info.Method.MetadataToken.RID, method_info.StateMachineKickOffMethod.MetadataToken.RID));
		}

		void AddLocalScope (MethodDebugInformation method_info, ScopeDebugInformation scope)
		{
			var rid = local_scope_table.AddRow (new LocalScopeRow (
				method_info.Method.MetadataToken.RID,
				scope.import != null ? AddImportScope (scope.import) : 0,
				local_variable_rid,
				local_constant_rid,
				(uint)scope.Start.Offset,
				(uint)((scope.End.IsEndOfMethod ? method_info.code_size : scope.End.Offset) - scope.Start.Offset)));

			scope.token = new MetadataToken (TokenType.LocalScope, rid);

			AddCustomDebugInformations (scope);

			if (scope.HasVariables)
				AddLocalVariables (scope);

			if (scope.HasConstants)
				AddLocalConstants (scope);

			for (int i = 0; i < scope.Scopes.Count; i++)
				AddLocalScope (method_info, scope.Scopes [i]);
		}

		void AddLocalVariables (ScopeDebugInformation scope)
		{
			for (int i = 0; i < scope.Variables.Count; i++) {
				var variable = scope.Variables [i];
				local_variable_table.AddRow (new LocalVariableRow (variable.Attributes, (ushort)variable.Index, GetStringIndex (variable.Name)));
				variable.token = new MetadataToken (TokenType.LocalVariable, local_variable_rid);
				local_variable_rid++;

				AddCustomDebugInformations (variable);
			}
		}

		void AddLocalConstants (ScopeDebugInformation scope)
		{
			for (int i = 0; i < scope.Constants.Count; i++) {
				var constant = scope.Constants [i];
				local_constant_table.AddRow (new LocalConstantRow (GetStringIndex (constant.Name), GetBlobIndex (GetConstantSignature (constant))));
				constant.token = new MetadataToken (TokenType.LocalConstant, local_constant_rid);
				local_constant_rid++;
			}
		}

		SignatureWriter GetConstantSignature (ConstantDebugInformation constant)
		{
			var type = constant.ConstantType;

			var signature = CreateSignatureWriter ();
			signature.WriteTypeSignature (type);

			if (type.IsTypeOf ("System", "Decimal")) {
				var bits = decimal.GetBits ((decimal)constant.Value);

				var low = (uint)bits [0];
				var mid = (uint)bits [1];
				var high = (uint)bits [2];

				var scale = (byte)(bits [3] >> 16);
				var negative = (bits [3] & 0x80000000) != 0;

				signature.WriteByte ((byte)(scale | (negative ? 0x80 : 0x00)));
				signature.WriteUInt32 (low);
				signature.WriteUInt32 (mid);
				signature.WriteUInt32 (high);

				return signature;
			}

			if (type.IsTypeOf ("System", "DateTime")) {
				var date = (DateTime)constant.Value;
				signature.WriteInt64 (date.Ticks);
				return signature;
			}

			signature.WriteBytes (GetConstantSignature (type.etype, constant.Value));

			return signature;
		}

		public void AddCustomDebugInformations (ICustomDebugInformationProvider provider)
		{
			if (!provider.HasCustomDebugInformations)
				return;

			var custom_infos = provider.CustomDebugInformations;

			for (int i = 0; i < custom_infos.Count; i++) {
				var custom_info = custom_infos [i];
				switch (custom_info.Kind) {
				case CustomDebugInformationKind.Binary:
					var binary_info = (BinaryCustomDebugInformation)custom_info;
					AddCustomDebugInformation (provider, binary_info, GetBlobIndex (binary_info.Data));
					break;
				case CustomDebugInformationKind.AsyncMethodBody:
					AddAsyncMethodBodyDebugInformation (provider, (AsyncMethodBodyDebugInformation)custom_info);
					break;
				case CustomDebugInformationKind.StateMachineScope:
					AddStateMachineScopeDebugInformation (provider, (StateMachineScopeDebugInformation)custom_info);
					break;
				case CustomDebugInformationKind.EmbeddedSource:
					AddEmbeddedSourceDebugInformation (provider, (EmbeddedSourceDebugInformation)custom_info);
					break;
				case CustomDebugInformationKind.SourceLink:
					AddSourceLinkDebugInformation (provider, (SourceLinkDebugInformation)custom_info);
					break;
				default:
					throw new NotImplementedException ();
				}
			}
		}

		void AddStateMachineScopeDebugInformation (ICustomDebugInformationProvider provider, StateMachineScopeDebugInformation state_machine_scope)
		{
			var method_info = ((MethodDefinition)provider).DebugInformation;

			var signature = CreateSignatureWriter ();

			var scopes = state_machine_scope.Scopes;

			for (int i = 0; i < scopes.Count; i++) {
				var scope = scopes [i];
				signature.WriteUInt32 ((uint)scope.Start.Offset);

				var end_offset = scope.End.IsEndOfMethod
					? method_info.code_size
					: scope.End.Offset;

				signature.WriteUInt32 ((uint)(end_offset - scope.Start.Offset));
			}

			AddCustomDebugInformation (provider, state_machine_scope, signature);
		}

		void AddAsyncMethodBodyDebugInformation (ICustomDebugInformationProvider provider, AsyncMethodBodyDebugInformation async_method)
		{
			var signature = CreateSignatureWriter ();
			signature.WriteUInt32 ((uint)async_method.catch_handler.Offset + 1);

			if (!async_method.yields.IsNullOrEmpty ()) {
				for (int i = 0; i < async_method.yields.Count; i++) {
					signature.WriteUInt32 ((uint)async_method.yields [i].Offset);
					signature.WriteUInt32 ((uint)async_method.resumes [i].Offset);
					signature.WriteCompressedUInt32 (async_method.resume_methods [i].MetadataToken.RID);
				}
			}

			AddCustomDebugInformation (provider, async_method, signature);
		}

		void AddEmbeddedSourceDebugInformation (ICustomDebugInformationProvider provider, EmbeddedSourceDebugInformation embedded_source)
		{
			var signature = CreateSignatureWriter ();

			if (!embedded_source.resolved) {
				signature.WriteBytes (embedded_source.ReadRawEmbeddedSourceDebugInformation ());
				AddCustomDebugInformation (provider, embedded_source, signature);
				return;
			}

			var content = embedded_source.content ?? Empty<byte>.Array;
			if (embedded_source.compress) {
				signature.WriteInt32 (content.Length);

				var decompressed_stream = new MemoryStream (content);
				var content_stream = new MemoryStream ();

				using (var compress_stream = new DeflateStream (content_stream, CompressionMode.Compress, leaveOpen: true))
					decompressed_stream.CopyTo (compress_stream);

				signature.WriteBytes (content_stream.ToArray ());
			} else {
				signature.WriteInt32 (0);
				signature.WriteBytes (content);
			}

			AddCustomDebugInformation (provider, embedded_source, signature);
		}

		void AddSourceLinkDebugInformation (ICustomDebugInformationProvider provider, SourceLinkDebugInformation source_link)
		{
			var signature = CreateSignatureWriter ();
			signature.WriteBytes (Encoding.UTF8.GetBytes (source_link.content));

			AddCustomDebugInformation (provider, source_link, signature);
		}

		void AddCustomDebugInformation (ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, SignatureWriter signature)
		{
			AddCustomDebugInformation (provider, custom_info, GetBlobIndex (signature));
		}

		void AddCustomDebugInformation (ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, uint blob_index)
		{
			var rid = custom_debug_information_table.AddRow (new CustomDebugInformationRow (
				MakeCodedRID (provider.MetadataToken, CodedIndex.HasCustomDebugInformation),
				GetGuidIndex (custom_info.Identifier),
				blob_index));

			custom_info.token = new MetadataToken (TokenType.CustomDebugInformation, rid);
		}

		uint AddImportScope (ImportDebugInformation import)
		{
			uint parent = 0;
			if (import.Parent != null)
				parent = AddImportScope (import.Parent);

			uint targets_index = 0;
			if (import.HasTargets) {
				var signature = CreateSignatureWriter ();

				for (int i = 0; i < import.Targets.Count; i++)
					AddImportTarget (import.Targets [i], signature);

				targets_index = GetBlobIndex (signature);
			}

			var row = new ImportScopeRow (parent, targets_index);

			MetadataToken import_token;
			if (import_scope_map.TryGetValue (row, out import_token))
				return import_token.RID;

			import_token = new MetadataToken (TokenType.ImportScope, import_scope_table.AddRow (row));
			import_scope_map.Add (row, import_token);

			return import_token.RID;
		}

		void AddImportTarget (ImportTarget target, SignatureWriter signature)
		{
			signature.WriteCompressedUInt32 ((uint)target.kind);

			switch (target.kind) {
			case ImportTargetKind.ImportNamespace:
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));
				break;
			case ImportTargetKind.ImportNamespaceInAssembly:
				signature.WriteCompressedUInt32 (target.reference.MetadataToken.RID);
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));
				break;
			case ImportTargetKind.ImportType:
				signature.WriteTypeToken (target.type);
				break;
			case ImportTargetKind.ImportXmlNamespaceWithAlias:
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));
				break;
			case ImportTargetKind.ImportAlias:
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));
				break;
			case ImportTargetKind.DefineAssemblyAlias:
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));
				signature.WriteCompressedUInt32 (target.reference.MetadataToken.RID);
				break;
			case ImportTargetKind.DefineNamespaceAlias:
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));
				break;
			case ImportTargetKind.DefineNamespaceInAssemblyAlias:
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));
				signature.WriteCompressedUInt32 (target.reference.MetadataToken.RID);
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.@namespace));
				break;
			case ImportTargetKind.DefineTypeAlias:
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (target.alias));
				signature.WriteTypeToken (target.type);
				break;
			}
		}

		uint GetUTF8StringBlobIndex (string s)
		{
			return GetBlobIndex (Encoding.UTF8.GetBytes (s));
		}

		public MetadataToken GetDocumentToken (Document document)
		{
			MetadataToken token;
			if (document_map.TryGetValue (document.Url, out token))
				return token;

			token = new MetadataToken (TokenType.Document, document_table.AddRow (
				new DocumentRow (GetBlobIndex (GetDocumentNameSignature (document)),
				GetGuidIndex (document.HashAlgorithm.ToGuid ()),
				GetBlobIndex (document.Hash),
				GetGuidIndex (document.Language.ToGuid ()))));

			document.token = token;

			AddCustomDebugInformations (document);

			document_map.Add (document.Url, token);

			return token;
		}

		SignatureWriter GetDocumentNameSignature (Document document)
		{
			var name = document.Url;
			var signature = CreateSignatureWriter ();

			char separator;
			if (!TryGetDocumentNameSeparator (name, out separator)) {
				signature.WriteByte (0);
				signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (name));
				return signature;
			}

			signature.WriteByte ((byte)separator);
			var parts = name.Split (new [] { separator });
			for (int i = 0; i < parts.Length; i++) {
				if (parts [i] == String.Empty)
					signature.WriteCompressedUInt32 (0);
				else
					signature.WriteCompressedUInt32 (GetUTF8StringBlobIndex (parts [i]));
			}

			return signature;
		}

		static bool TryGetDocumentNameSeparator (string path, out char separator)
		{
			const char unix = '/';
			const char win = '\\';
			const char zero = (char)0;

			separator = zero;
			if (string.IsNullOrEmpty (path))
				return false;

			int unix_count = 0;
			int win_count = 0;

			for (int i = 0; i < path.Length; i++) {
				if (path [i] == unix)
					unix_count++;
				else if (path [i] == win)
					win_count++;
			}

			if (unix_count == 0 && win_count == 0)
				return false;

			if (unix_count >= win_count) {
				separator = unix;
				return true;
			}

			separator = win;
			return true;
		}

		void AddSequencePoints (MethodDebugInformation info)
		{
			var rid = info.Method.MetadataToken.RID;

			Document document;
			if (info.TryGetUniqueDocument (out document))
				method_debug_information_table.rows [rid - 1].Col1 = GetDocumentToken (document).RID;

			var signature = CreateSignatureWriter ();
			signature.WriteSequencePoints (info);

			method_debug_information_table.rows [rid - 1].Col2 = GetBlobIndex (signature);
		}

		public void ComputeDeterministicMvid ()
		{
			var guid = CryptoService.ComputeGuid (CryptoService.ComputeHash (
				data,
				resources,
				string_heap,
				user_string_heap,
				blob_heap,
				table_heap,
				code));

			var position = guid_heap.position;
			guid_heap.position = 0;
			guid_heap.WriteBytes (guid.ToByteArray ());
			guid_heap.position = position;

			module.Mvid = guid;
		}
	}

	sealed class SignatureWriter : ByteBuffer {

		readonly MetadataBuilder metadata;

		public SignatureWriter (MetadataBuilder metadata)
			: base (6)
		{
			this.metadata = metadata;
		}

		public void WriteElementType (ElementType element_type)
		{
			WriteByte ((byte)element_type);
		}

		public void WriteUTF8String (string @string)
		{
			if (@string == null) {
				WriteByte (0xff);
				return;
			}

			var bytes = Encoding.UTF8.GetBytes (@string);
			WriteCompressedUInt32 ((uint)bytes.Length);
			WriteBytes (bytes);
		}

		public void WriteMethodSignature (IMethodSignature method)
		{
			byte calling_convention = (byte)method.CallingConvention;
			if (method.HasThis)
				calling_convention |= 0x20;
			if (method.ExplicitThis)
				calling_convention |= 0x40;

			var generic_provider = method as IGenericParameterProvider;
			var generic_arity = generic_provider != null && generic_provider.HasGenericParameters
				? generic_provider.GenericParameters.Count
				: 0;

			if (generic_arity > 0)
				calling_convention |= 0x10;

			var param_count = method.HasParameters ? method.Parameters.Count : 0;

			WriteByte (calling_convention);

			if (generic_arity > 0)
				WriteCompressedUInt32 ((uint)generic_arity);

			WriteCompressedUInt32 ((uint)param_count);
			WriteTypeSignature (method.ReturnType);

			if (param_count == 0)
				return;

			var parameters = method.Parameters;

			for (int i = 0; i < param_count; i++)
				WriteTypeSignature (parameters [i].ParameterType);
		}

		uint MakeTypeDefOrRefCodedRID (TypeReference type)
		{
			return CodedIndex.TypeDefOrRef.CompressMetadataToken (metadata.LookupToken (type));
		}

		public void WriteTypeToken (TypeReference type)
		{
			WriteCompressedUInt32 (MakeTypeDefOrRefCodedRID (type));
		}

		public void WriteTypeSignature (TypeReference type)
		{
			if (type == null)
				throw new ArgumentNullException ();

			var etype = type.etype;

			switch (etype) {
			case ElementType.MVar:
			case ElementType.Var: {
					var generic_parameter = (GenericParameter)type;

					WriteElementType (etype);
					var position = generic_parameter.Position;
					if (position == -1)
						throw new NotSupportedException ();

					WriteCompressedUInt32 ((uint)position);
					break;
				}

			case ElementType.GenericInst: {
					var generic_instance = (GenericInstanceType)type;
					WriteElementType (ElementType.GenericInst);
					WriteElementType (generic_instance.IsValueType ? ElementType.ValueType : ElementType.Class);
					WriteCompressedUInt32 (MakeTypeDefOrRefCodedRID (generic_instance.ElementType));

					WriteGenericInstanceSignature (generic_instance);
					break;
				}

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Pinned:
			case ElementType.Sentinel: {
					var type_spec = (TypeSpecification)type;
					WriteElementType (etype);
					WriteTypeSignature (type_spec.ElementType);
					break;
				}

			case ElementType.FnPtr: {
					var fptr = (FunctionPointerType)type;
					WriteElementType (ElementType.FnPtr);
					WriteMethodSignature (fptr);
					break;
				}

			case ElementType.CModOpt:
			case ElementType.CModReqD: {
					var modifier = (IModifierType)type;
					WriteModifierSignature (etype, modifier);
					break;
				}

			case ElementType.Array: {
					var array = (ArrayType)type;
					if (!array.IsVector) {
						WriteArrayTypeSignature (array);
						break;
					}

					WriteElementType (ElementType.SzArray);
					WriteTypeSignature (array.ElementType);
					break;
				}

			case ElementType.None: {
					WriteElementType (type.IsValueType ? ElementType.ValueType : ElementType.Class);
					WriteCompressedUInt32 (MakeTypeDefOrRefCodedRID (type));
					break;
				}

			default:
				if (!TryWriteElementType (type))
					throw new NotSupportedException ();

				break;

			}
		}

		void WriteArrayTypeSignature (ArrayType array)
		{
			WriteElementType (ElementType.Array);
			WriteTypeSignature (array.ElementType);

			var dimensions = array.Dimensions;
			var rank = dimensions.Count;

			WriteCompressedUInt32 ((uint)rank);

			var sized = 0;
			var lbounds = 0;

			for (int i = 0; i < rank; i++) {
				var dimension = dimensions [i];

				if (dimension.UpperBound.HasValue) {
					sized++;
					lbounds++;
				} else if (dimension.LowerBound.HasValue)
					lbounds++;
			}

			var sizes = new int [sized];
			var low_bounds = new int [lbounds];

			for (int i = 0; i < lbounds; i++) {
				var dimension = dimensions [i];
				low_bounds [i] = dimension.LowerBound.GetValueOrDefault ();
				if (dimension.UpperBound.HasValue)
					sizes [i] = dimension.UpperBound.Value - low_bounds [i] + 1;
			}

			WriteCompressedUInt32 ((uint)sized);
			for (int i = 0; i < sized; i++)
				WriteCompressedUInt32 ((uint)sizes [i]);

			WriteCompressedUInt32 ((uint)lbounds);
			for (int i = 0; i < lbounds; i++)
				WriteCompressedInt32 (low_bounds [i]);
		}

		public void WriteGenericInstanceSignature (IGenericInstance instance)
		{
			var generic_arguments = instance.GenericArguments;
			var arity = generic_arguments.Count;

			WriteCompressedUInt32 ((uint)arity);
			for (int i = 0; i < arity; i++)
				WriteTypeSignature (generic_arguments [i]);
		}

		void WriteModifierSignature (ElementType element_type, IModifierType type)
		{
			WriteElementType (element_type);
			WriteCompressedUInt32 (MakeTypeDefOrRefCodedRID (type.ModifierType));
			WriteTypeSignature (type.ElementType);
		}

		bool TryWriteElementType (TypeReference type)
		{
			var element = type.etype;

			if (element == ElementType.None)
				return false;

			WriteElementType (element);
			return true;
		}

		public void WriteConstantString (string value)
		{
			if (value != null)
				WriteBytes (Encoding.Unicode.GetBytes (value));
			else
				WriteByte (0xff);
		}

		public void WriteConstantPrimitive (object value)
		{
			WritePrimitiveValue (value);
		}

		public void WriteCustomAttributeConstructorArguments (CustomAttribute attribute)
		{
			if (!attribute.HasConstructorArguments)
				return;

			var arguments = attribute.ConstructorArguments;
			var parameters = attribute.Constructor.Parameters;

			if (parameters.Count != arguments.Count)
				throw new InvalidOperationException ();

			for (int i = 0; i < arguments.Count; i++)
				WriteCustomAttributeFixedArgument (parameters [i].ParameterType, arguments [i]);
		}

		void WriteCustomAttributeFixedArgument (TypeReference type, CustomAttributeArgument argument)
		{
			if (type.IsArray) {
				WriteCustomAttributeFixedArrayArgument ((ArrayType)type, argument);
				return;
			}

			WriteCustomAttributeElement (type, argument);
		}

		void WriteCustomAttributeFixedArrayArgument (ArrayType type, CustomAttributeArgument argument)
		{
			var values = argument.Value as CustomAttributeArgument [];

			if (values == null) {
				WriteUInt32 (0xffffffff);
				return;
			}

			WriteInt32 (values.Length);

			if (values.Length == 0)
				return;

			var element_type = type.ElementType;

			for (int i = 0; i < values.Length; i++)
				WriteCustomAttributeElement (element_type, values [i]);
		}

		void WriteCustomAttributeElement (TypeReference type, CustomAttributeArgument argument)
		{
			if (type.IsArray) {
				WriteCustomAttributeFixedArrayArgument ((ArrayType)type, argument);
				return;
			}

			if (type.etype == ElementType.Object) {
				argument = (CustomAttributeArgument)argument.Value;
				type = argument.Type;

				WriteCustomAttributeFieldOrPropType (type);
				WriteCustomAttributeElement (type, argument);
				return;
			}

			WriteCustomAttributeValue (type, argument.Value);
		}

		void WriteCustomAttributeValue (TypeReference type, object value)
		{
			var etype = type.etype;

			switch (etype) {
			case ElementType.String:
				var @string = (string)value;
				if (@string == null)
					WriteByte (0xff);
				else
					WriteUTF8String (@string);
				break;
			case ElementType.None:
				if (type.IsTypeOf ("System", "Type"))
					WriteCustomAttributeTypeValue ((TypeReference)value);
				else
					WriteCustomAttributeEnumValue (type, value);
				break;
			default:
				WritePrimitiveValue (value);
				break;
			}
		}

		private void WriteCustomAttributeTypeValue (TypeReference value)
		{
			var typeDefinition = value as TypeDefinition;

			if (typeDefinition != null) {
				TypeDefinition outermostDeclaringType = typeDefinition;
				while (outermostDeclaringType.DeclaringType != null)
					outermostDeclaringType = outermostDeclaringType.DeclaringType;

				// In CLR .winmd files, custom attribute arguments reference unmangled type names (rather than <CLR>Name)
				if (WindowsRuntimeProjections.IsClrImplementationType (outermostDeclaringType)) {
					WindowsRuntimeProjections.Project (outermostDeclaringType);
					WriteTypeReference (value);
					WindowsRuntimeProjections.RemoveProjection (outermostDeclaringType);
					return;
				}
			}

			WriteTypeReference (value);
		}

		void WritePrimitiveValue (object value)
		{
			if (value == null)
				throw new ArgumentNullException ();

			switch (Type.GetTypeCode (value.GetType ())) {
			case TypeCode.Boolean:
				WriteByte ((byte)(((bool)value) ? 1 : 0));
				break;
			case TypeCode.Byte:
				WriteByte ((byte)value);
				break;
			case TypeCode.SByte:
				WriteSByte ((sbyte)value);
				break;
			case TypeCode.Int16:
				WriteInt16 ((short)value);
				break;
			case TypeCode.UInt16:
				WriteUInt16 ((ushort)value);
				break;
			case TypeCode.Char:
				WriteInt16 ((short)(char)value);
				break;
			case TypeCode.Int32:
				WriteInt32 ((int)value);
				break;
			case TypeCode.UInt32:
				WriteUInt32 ((uint)value);
				break;
			case TypeCode.Single:
				WriteSingle ((float)value);
				break;
			case TypeCode.Int64:
				WriteInt64 ((long)value);
				break;
			case TypeCode.UInt64:
				WriteUInt64 ((ulong)value);
				break;
			case TypeCode.Double:
				WriteDouble ((double)value);
				break;
			default:
				throw new NotSupportedException (value.GetType ().FullName);
			}
		}

		void WriteCustomAttributeEnumValue (TypeReference enum_type, object value)
		{
			var type = enum_type.CheckedResolve ();
			if (!type.IsEnum)
				throw new ArgumentException ();

			WriteCustomAttributeValue (type.GetEnumUnderlyingType (), value);
		}

		void WriteCustomAttributeFieldOrPropType (TypeReference type)
		{
			if (type.IsArray) {
				var array = (ArrayType)type;
				WriteElementType (ElementType.SzArray);
				WriteCustomAttributeFieldOrPropType (array.ElementType);
				return;
			}

			var etype = type.etype;

			switch (etype) {
			case ElementType.Object:
				WriteElementType (ElementType.Boxed);
				return;
			case ElementType.None:
				if (type.IsTypeOf ("System", "Type"))
					WriteElementType (ElementType.Type);
				else {
					WriteElementType (ElementType.Enum);
					WriteTypeReference (type);
				}
				return;
			default:
				WriteElementType (etype);
				return;
			}
		}

		public void WriteCustomAttributeNamedArguments (CustomAttribute attribute)
		{
			var count = GetNamedArgumentCount (attribute);

			WriteUInt16 ((ushort)count);

			if (count == 0)
				return;

			WriteICustomAttributeNamedArguments (attribute);
		}

		static int GetNamedArgumentCount (ICustomAttribute attribute)
		{
			int count = 0;

			if (attribute.HasFields)
				count += attribute.Fields.Count;

			if (attribute.HasProperties)
				count += attribute.Properties.Count;

			return count;
		}

		void WriteICustomAttributeNamedArguments (ICustomAttribute attribute)
		{
			if (attribute.HasFields)
				WriteCustomAttributeNamedArguments (0x53, attribute.Fields);

			if (attribute.HasProperties)
				WriteCustomAttributeNamedArguments (0x54, attribute.Properties);
		}

		void WriteCustomAttributeNamedArguments (byte kind, Collection<CustomAttributeNamedArgument> named_arguments)
		{
			for (int i = 0; i < named_arguments.Count; i++)
				WriteCustomAttributeNamedArgument (kind, named_arguments [i]);
		}

		void WriteCustomAttributeNamedArgument (byte kind, CustomAttributeNamedArgument named_argument)
		{
			var argument = named_argument.Argument;

			WriteByte (kind);
			WriteCustomAttributeFieldOrPropType (argument.Type);
			WriteUTF8String (named_argument.Name);
			WriteCustomAttributeFixedArgument (argument.Type, argument);
		}

		void WriteSecurityAttribute (SecurityAttribute attribute)
		{
			WriteTypeReference (attribute.AttributeType);

			var count = GetNamedArgumentCount (attribute);

			if (count == 0) {
				WriteCompressedUInt32 (1); // length
				WriteCompressedUInt32 (0); // count
				return;
			}

			var buffer = new SignatureWriter (metadata);
			buffer.WriteCompressedUInt32 ((uint)count);
			buffer.WriteICustomAttributeNamedArguments (attribute);

			WriteCompressedUInt32 ((uint)buffer.length);
			WriteBytes (buffer);
		}

		public void WriteSecurityDeclaration (SecurityDeclaration declaration)
		{
			WriteByte ((byte)'.');

			var attributes = declaration.security_attributes;
			if (attributes == null)
				throw new NotSupportedException ();

			WriteCompressedUInt32 ((uint)attributes.Count);

			for (int i = 0; i < attributes.Count; i++)
				WriteSecurityAttribute (attributes [i]);
		}

		public void WriteXmlSecurityDeclaration (SecurityDeclaration declaration)
		{
			var xml = GetXmlSecurityDeclaration (declaration);
			if (xml == null)
				throw new NotSupportedException ();

			WriteBytes (Encoding.Unicode.GetBytes (xml));
		}

		static string GetXmlSecurityDeclaration (SecurityDeclaration declaration)
		{
			if (declaration.security_attributes == null || declaration.security_attributes.Count != 1)
				return null;

			var attribute = declaration.security_attributes [0];

			if (!attribute.AttributeType.IsTypeOf ("System.Security.Permissions", "PermissionSetAttribute"))
				return null;

			if (attribute.properties == null || attribute.properties.Count != 1)
				return null;

			var property = attribute.properties [0];
			if (property.Name != "XML")
				return null;

			return (string)property.Argument.Value;
		}

		void WriteTypeReference (TypeReference type)
		{
			WriteUTF8String (TypeParser.ToParseable (type, top_level: false));
		}

		public void WriteMarshalInfo (MarshalInfo marshal_info)
		{
			WriteNativeType (marshal_info.native);

			switch (marshal_info.native) {
			case NativeType.Array: {
					var array = (ArrayMarshalInfo)marshal_info;
					if (array.element_type != NativeType.None)
						WriteNativeType (array.element_type);
					if (array.size_parameter_index > -1)
						WriteCompressedUInt32 ((uint)array.size_parameter_index);
					if (array.size > -1)
						WriteCompressedUInt32 ((uint)array.size);
					if (array.size_parameter_multiplier > -1)
						WriteCompressedUInt32 ((uint)array.size_parameter_multiplier);
					return;
				}
			case NativeType.SafeArray: {
					var array = (SafeArrayMarshalInfo)marshal_info;
					if (array.element_type != VariantType.None)
						WriteVariantType (array.element_type);
					return;
				}
			case NativeType.FixedArray: {
					var array = (FixedArrayMarshalInfo)marshal_info;
					if (array.size > -1)
						WriteCompressedUInt32 ((uint)array.size);
					if (array.element_type != NativeType.None)
						WriteNativeType (array.element_type);
					return;
				}
			case NativeType.FixedSysString:
				var sys_string = (FixedSysStringMarshalInfo)marshal_info;
				if (sys_string.size > -1)
					WriteCompressedUInt32 ((uint)sys_string.size);
				return;
			case NativeType.CustomMarshaler:
				var marshaler = (CustomMarshalInfo)marshal_info;
				WriteUTF8String (marshaler.guid != Guid.Empty ? marshaler.guid.ToString () : string.Empty);
				WriteUTF8String (marshaler.unmanaged_type);
				WriteTypeReference (marshaler.managed_type);
				WriteUTF8String (marshaler.cookie);
				return;
			}
		}

		void WriteNativeType (NativeType native)
		{
			WriteByte ((byte)native);
		}

		void WriteVariantType (VariantType variant)
		{
			WriteByte ((byte)variant);
		}

		public void WriteSequencePoints (MethodDebugInformation info)
		{
			var start_line = -1;
			var start_column = -1;

			WriteCompressedUInt32 (info.local_var_token.RID);

			Document previous_document;
			if (!info.TryGetUniqueDocument (out previous_document))
				previous_document = null;

			for (int i = 0; i < info.SequencePoints.Count; i++) {
				var sequence_point = info.SequencePoints [i];

				var document = sequence_point.Document;
				if (previous_document != document) {
					var document_token = metadata.GetDocumentToken (document);

					if (previous_document != null)
						WriteCompressedUInt32 (0);

					WriteCompressedUInt32 (document_token.RID);
					previous_document = document;
				}

				if (i > 0)
					WriteCompressedUInt32 ((uint)(sequence_point.Offset - info.SequencePoints [i - 1].Offset));
				else
					WriteCompressedUInt32 ((uint)sequence_point.Offset);

				if (sequence_point.IsHidden) {
					WriteInt16 (0);
					continue;
				}

				var delta_lines = sequence_point.EndLine - sequence_point.StartLine;
				var delta_columns = sequence_point.EndColumn - sequence_point.StartColumn;

				WriteCompressedUInt32 ((uint)delta_lines);

				if (delta_lines == 0)
					WriteCompressedUInt32 ((uint)delta_columns);
				else
					WriteCompressedInt32 (delta_columns);

				if (start_line < 0) {
					WriteCompressedUInt32 ((uint)sequence_point.StartLine);
					WriteCompressedUInt32 ((uint)sequence_point.StartColumn);
				} else {
					WriteCompressedInt32 (sequence_point.StartLine - start_line);
					WriteCompressedInt32 (sequence_point.StartColumn - start_column);
				}

				start_line = sequence_point.StartLine;
				start_column = sequence_point.StartColumn;
			}
		}
	}

	static partial class Mixin {

		public static bool TryGetUniqueDocument (this MethodDebugInformation info, out Document document)
		{
			document = info.SequencePoints [0].Document;

			for (int i = 1; i < info.SequencePoints.Count; i++) {
				var sequence_point = info.SequencePoints [i];
				if (sequence_point.Document != document)
					return false;
			}

			return true;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/BaseAssemblyResolver.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace MonoFN.Cecil {

	public delegate AssemblyDefinition AssemblyResolveEventHandler (object sender, AssemblyNameReference reference);

	public sealed class AssemblyResolveEventArgs : EventArgs {

		readonly AssemblyNameReference reference;

		public AssemblyNameReference AssemblyReference {
			get { return reference; }
		}

		public AssemblyResolveEventArgs (AssemblyNameReference reference)
		{
			this.reference = reference;
		}
	}

#if !NET_CORE
	[Serializable]
#endif
	public sealed class AssemblyResolutionException : FileNotFoundException {

		readonly AssemblyNameReference reference;

		public AssemblyNameReference AssemblyReference {
			get { return reference; }
		}

		public AssemblyResolutionException (AssemblyNameReference reference)
			: this (reference, null)
		{
		}

		public AssemblyResolutionException (AssemblyNameReference reference, Exception innerException)
			: base (string.Format ("Failed to resolve assembly: '{0}'", reference), innerException)
		{
			this.reference = reference;
		}

#if !NET_CORE
		AssemblyResolutionException (
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
			: base (info, context)
		{
		}
#endif
	}

	public abstract class BaseAssemblyResolver : IAssemblyResolver {

		static readonly bool on_mono = Type.GetType ("MonoFN.Runtime") != null;

		readonly Collection<string> directories;

#if NET_CORE
		// Maps file names of available trusted platform assemblies to their full paths.
		// Internal for testing.
		internal static readonly Lazy<Dictionary<string, string>> TrustedPlatformAssemblies = new Lazy<Dictionary<string, string>> (CreateTrustedPlatformAssemblyMap);
#else
		Collection<string> gac_paths;
#endif

		public void AddSearchDirectory (string directory)
		{
			directories.Add (directory);
		}

		public void RemoveSearchDirectory (string directory)
		{
			directories.Remove (directory);
		}

		public string [] GetSearchDirectories ()
		{
			var directories = new string [this.directories.size];
			Array.Copy (this.directories.items, directories, directories.Length);
			return directories;
		}

		public event AssemblyResolveEventHandler ResolveFailure;

		protected BaseAssemblyResolver ()
		{
			directories = new Collection<string> (2) { ".", "bin" };
		}

		AssemblyDefinition GetAssembly (string file, ReaderParameters parameters)
		{
			if (parameters.AssemblyResolver == null)
				parameters.AssemblyResolver = this;

			return ModuleDefinition.ReadModule (file, parameters).Assembly;
		}

		public virtual AssemblyDefinition Resolve (AssemblyNameReference name)
		{
			return Resolve (name, new ReaderParameters ());
		}

		public virtual AssemblyDefinition Resolve (AssemblyNameReference name, ReaderParameters parameters)
		{
			Mixin.CheckName (name);
			Mixin.CheckParameters (parameters);

			var assembly = SearchDirectory (name, directories, parameters);
			if (assembly != null)
				return assembly;

			if (name.IsRetargetable) {
				// if the reference is retargetable, zero it
				name = new AssemblyNameReference (name.Name, Mixin.ZeroVersion) {
					PublicKeyToken = Empty<byte>.Array,
				};
			}

#if NET_CORE
			assembly = SearchTrustedPlatformAssemblies (name, parameters);
			if (assembly != null)
				return assembly;
#else
			var framework_dir = Path.GetDirectoryName (typeof (object).Module.FullyQualifiedName);
			var framework_dirs = on_mono
				? new [] { framework_dir, Path.Combine (framework_dir, "Facades") }
				: new [] { framework_dir };

			if (IsZero (name.Version)) {
				assembly = SearchDirectory (name, framework_dirs, parameters);
				if (assembly != null)
					return assembly;
			}

			if (name.Name == "mscorlib") {
				assembly = GetCorlib (name, parameters);
				if (assembly != null)
					return assembly;
			}

			assembly = GetAssemblyInGac (name, parameters);
			if (assembly != null)
				return assembly;

			assembly = SearchDirectory (name, framework_dirs, parameters);
			if (assembly != null)
				return assembly;
#endif
			if (ResolveFailure != null) {
				assembly = ResolveFailure (this, name);
				if (assembly != null)
					return assembly;
			}

			throw new AssemblyResolutionException (name);
		}

#if NET_CORE
		AssemblyDefinition SearchTrustedPlatformAssemblies (AssemblyNameReference name, ReaderParameters parameters)
		{
			if (name.IsWindowsRuntime)
				return null;

			if (TrustedPlatformAssemblies.Value.TryGetValue (name.Name, out string path))
				return GetAssembly (path, parameters);

			return null;
		}

		static Dictionary<string, string> CreateTrustedPlatformAssemblyMap ()
		{
			var result = new Dictionary<string, string> (StringComparer.OrdinalIgnoreCase);

			string paths;

			try {
				paths = (string) AppDomain.CurrentDomain.GetData ("TRUSTED_PLATFORM_ASSEMBLIES");
			} catch {
				paths = null;
			}

			if (paths == null)
				return result;

			foreach (var path in paths.Split (Path.PathSeparator))
				if (string.Equals (Path.GetExtension (path), ".dll", StringComparison.OrdinalIgnoreCase))
					result [Path.GetFileNameWithoutExtension (path)] = path;

			return result;
		}
#endif

		protected virtual AssemblyDefinition SearchDirectory (AssemblyNameReference name, IEnumerable<string> directories, ReaderParameters parameters)
		{
			var extensions = name.IsWindowsRuntime ? new [] { ".winmd", ".dll" } : new [] { ".exe", ".dll" };
			foreach (var directory in directories) {
				foreach (var extension in extensions) {
					string file = Path.Combine (directory, name.Name + extension);
					if (!File.Exists (file))
						continue;
					try {
						return GetAssembly (file, parameters);
					}
					catch (System.BadImageFormatException) {
						continue;
					}
				}
			}

			return null;
		}

		static bool IsZero (Version version)
		{
			return version.Major == 0 && version.Minor == 0 && version.Build == 0 && version.Revision == 0;
		}

#if !NET_CORE
		AssemblyDefinition GetCorlib (AssemblyNameReference reference, ReaderParameters parameters)
		{
			var version = reference.Version;
			var corlib = typeof (object).Assembly.GetName ();
			if (corlib.Version == version || IsZero (version))
				return GetAssembly (typeof (object).Module.FullyQualifiedName, parameters);

			var path = Directory.GetParent (
				Directory.GetParent (
					typeof (object).Module.FullyQualifiedName).FullName
				).FullName;

			if (on_mono) {
				if (version.Major == 1)
					path = Path.Combine (path, "1.0");
				else if (version.Major == 2) {
					if (version.MajorRevision == 5)
						path = Path.Combine (path, "2.1");
					else
						path = Path.Combine (path, "2.0");
				} else if (version.Major == 4)
					path = Path.Combine (path, "4.0");
				else
					throw new NotSupportedException ("Version not supported: " + version);
			} else {
				switch (version.Major) {
				case 1:
					if (version.MajorRevision == 3300)
						path = Path.Combine (path, "v1.0.3705");
					else
						path = Path.Combine (path, "v1.1.4322");
					break;
				case 2:
					path = Path.Combine (path, "v2.0.50727");
					break;
				case 4:
					path = Path.Combine (path, "v4.0.30319");
					break;
				default:
					throw new NotSupportedException ("Version not supported: " + version);
				}
			}

			var file = Path.Combine (path, "mscorlib.dll");
			if (File.Exists (file))
				return GetAssembly (file, parameters);

			if (on_mono && Directory.Exists (path + "-api")) {
				file = Path.Combine (path + "-api", "mscorlib.dll");
				if (File.Exists (file))
					return GetAssembly (file, parameters);
			}

			return null;
		}

		static Collection<string> GetGacPaths ()
		{
			if (on_mono)
				return GetDefaultMonoGacPaths ();

			var paths = new Collection<string> (2);
			var windir = Environment.GetEnvironmentVariable ("WINDIR");
			if (windir == null)
				return paths;

			paths.Add (Path.Combine (windir, "assembly"));
			paths.Add (Path.Combine (windir, Path.Combine ("Microsoft.NET", "assembly")));
			return paths;
		}

		static Collection<string> GetDefaultMonoGacPaths ()
		{
			var paths = new Collection<string> (1);
			var gac = GetCurrentMonoGac ();
			if (gac != null)
				paths.Add (gac);

			var gac_paths_env = Environment.GetEnvironmentVariable ("MONO_GAC_PREFIX");
			if (string.IsNullOrEmpty (gac_paths_env))
				return paths;

			var prefixes = gac_paths_env.Split (Path.PathSeparator);
			foreach (var prefix in prefixes) {
				if (string.IsNullOrEmpty (prefix))
					continue;

				var gac_path = Path.Combine (Path.Combine (Path.Combine (prefix, "lib"), "mono"), "gac");
				if (Directory.Exists (gac_path) && !paths.Contains (gac))
					paths.Add (gac_path);
			}

			return paths;
		}

		static string GetCurrentMonoGac ()
		{
			return Path.Combine (
				Directory.GetParent (
					Path.GetDirectoryName (typeof (object).Module.FullyQualifiedName)).FullName,
				"gac");
		}

		AssemblyDefinition GetAssemblyInGac (AssemblyNameReference reference, ReaderParameters parameters)
		{
			if (reference.PublicKeyToken == null || reference.PublicKeyToken.Length == 0)
				return null;

			if (gac_paths == null)
				gac_paths = GetGacPaths ();

			if (on_mono)
				return GetAssemblyInMonoGac (reference, parameters);

			return GetAssemblyInNetGac (reference, parameters);
		}

		AssemblyDefinition GetAssemblyInMonoGac (AssemblyNameReference reference, ReaderParameters parameters)
		{
			for (int i = 0; i < gac_paths.Count; i++) {
				var gac_path = gac_paths [i];
				var file = GetAssemblyFile (reference, string.Empty, gac_path);
				if (File.Exists (file))
					return GetAssembly (file, parameters);
			}

			return null;
		}

		AssemblyDefinition GetAssemblyInNetGac (AssemblyNameReference reference, ReaderParameters parameters)
		{
			var gacs = new [] { "GAC_MSIL", "GAC_32", "GAC_64", "GAC" };
			var prefixes = new [] { string.Empty, "v4.0_" };

			for (int i = 0; i < gac_paths.Count; i++) {
				for (int j = 0; j < gacs.Length; j++) {
					var gac = Path.Combine (gac_paths [i], gacs [j]);
					var file = GetAssemblyFile (reference, prefixes [i], gac);
					if (Directory.Exists (gac) && File.Exists (file))
						return GetAssembly (file, parameters);
				}
			}

			return null;
		}

		static string GetAssemblyFile (AssemblyNameReference reference, string prefix, string gac)
		{
			var gac_folder = new StringBuilder ()
				.Append (prefix)
				.Append (reference.Version)
				.Append ("__");

			for (int i = 0; i < reference.PublicKeyToken.Length; i++)
				gac_folder.Append (reference.PublicKeyToken [i].ToString ("x2"));

			return Path.Combine (
				Path.Combine (
					Path.Combine (gac, reference.Name), gac_folder.ToString ()),
				reference.Name + ".dll");
		}
#endif
		public void Dispose ()
		{
			Dispose (true);
			GC.SuppressFinalize (this);
		}

		protected virtual void Dispose (bool disposing)
		{
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/CallSite.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Text;

namespace MonoFN.Cecil {

	public sealed class CallSite : IMethodSignature {

		readonly MethodReference signature;

		public bool HasThis {
			get { return signature.HasThis; }
			set { signature.HasThis = value; }
		}

		public bool ExplicitThis {
			get { return signature.ExplicitThis; }
			set { signature.ExplicitThis = value; }
		}

		public MethodCallingConvention CallingConvention {
			get { return signature.CallingConvention; }
			set { signature.CallingConvention = value; }
		}

		public bool HasParameters {
			get { return signature.HasParameters; }
		}

		public Collection<ParameterDefinition> Parameters {
			get { return signature.Parameters; }
		}

		public TypeReference ReturnType {
			get { return signature.MethodReturnType.ReturnType; }
			set { signature.MethodReturnType.ReturnType = value; }
		}

		public MethodReturnType MethodReturnType {
			get { return signature.MethodReturnType; }
		}

		public string Name {
			get { return string.Empty; }
			set { throw new InvalidOperationException (); }
		}

		public string Namespace {
			get { return string.Empty; }
			set { throw new InvalidOperationException (); }
		}

		public ModuleDefinition Module {
			get { return ReturnType.Module; }
		}

		public IMetadataScope Scope {
			get { return signature.ReturnType.Scope; }
		}

		public MetadataToken MetadataToken {
			get { return signature.token; }
			set { signature.token = value; }
		}

		public string FullName {
			get {
				var signature = new StringBuilder ();
				signature.Append (ReturnType.FullName);
				this.MethodSignatureFullName (signature);
				return signature.ToString ();
			}
		}

		internal CallSite ()
		{
			this.signature = new MethodReference ();
			this.signature.token = new MetadataToken (TokenType.Signature, 0);
		}

		public CallSite (TypeReference returnType)
			: this ()
		{
			if (returnType == null)
				throw new ArgumentNullException ("returnType");

			this.signature.ReturnType = returnType;
		}

		public override string ToString ()
		{
			return FullName;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/Consts.cs ---
static class Consts {
	public const string AssemblyName = "MonoFN.Cecil";
	public const string PublicKey = "00240000048000009400000006020000002400005253413100040000010001002b5c9f7f04346c324a3176f8d3ee823bbf2d60efdbc35f86fd9e65ea3e6cd11bcdcba3a353e55133c8ac5c4caaba581b2c6dfff2cc2d0edc43959ddb86b973300a479a82419ef489c3225f1fe429a708507bd515835160e10bc743d20ca33ab9570cfd68d479fcf0bc797a763bec5d1000f0159ef619e709d915975e87beebaf";
}
'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/CustomAttribute.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Diagnostics;
using System.Threading;

namespace MonoFN.Cecil {

	public struct CustomAttributeArgument {

		readonly TypeReference type;
		readonly object value;

		public TypeReference Type {
			get { return type; }
		}

		public object Value {
			get { return value; }
		}

		public CustomAttributeArgument (TypeReference type, object value)
		{
			Mixin.CheckType (type);
			this.type = type;
			this.value = value;
		}
	}

	public struct CustomAttributeNamedArgument {

		readonly string name;
		readonly CustomAttributeArgument argument;

		public string Name {
			get { return name; }
		}

		public CustomAttributeArgument Argument {
			get { return argument; }
		}

		public CustomAttributeNamedArgument (string name, CustomAttributeArgument argument)
		{
			Mixin.CheckName (name);
			this.name = name;
			this.argument = argument;
		}
	}

	public interface ICustomAttribute {

		TypeReference AttributeType { get; }

		bool HasFields { get; }
		bool HasProperties { get; }
		bool HasConstructorArguments { get; }
		Collection<CustomAttributeNamedArgument> Fields { get; }
		Collection<CustomAttributeNamedArgument> Properties { get; }
		Collection<CustomAttributeArgument> ConstructorArguments { get; }
	}

	[DebuggerDisplay ("{AttributeType}")]
	public sealed class CustomAttribute : ICustomAttribute {

		internal CustomAttributeValueProjection projection;
		readonly internal uint signature;
		internal bool resolved;
		MethodReference constructor;
		byte [] blob;
		internal Collection<CustomAttributeArgument> arguments;
		internal Collection<CustomAttributeNamedArgument> fields;
		internal Collection<CustomAttributeNamedArgument> properties;

		public MethodReference Constructor {
			get { return constructor; }
			set { constructor = value; }
		}

		public TypeReference AttributeType {
			get { return constructor.DeclaringType; }
		}

		public bool IsResolved {
			get { return resolved; }
		}

		public bool HasConstructorArguments {
			get {
				Resolve ();

				return !arguments.IsNullOrEmpty ();
			}
		}

		public Collection<CustomAttributeArgument> ConstructorArguments {
			get {
				Resolve ();

				if (arguments == null)
					Interlocked.CompareExchange (ref arguments, new Collection<CustomAttributeArgument> (), null);

				return arguments;
			}
		}

		public bool HasFields {
			get {
				Resolve ();

				return !fields.IsNullOrEmpty ();
			}
		}

		public Collection<CustomAttributeNamedArgument> Fields {
			get {
				Resolve ();

				if (fields == null)
					Interlocked.CompareExchange (ref fields, new Collection<CustomAttributeNamedArgument> (), null);

				return fields;
			}
		}

		public bool HasProperties {
			get {
				Resolve ();

				return !properties.IsNullOrEmpty ();
			}
		}

		public Collection<CustomAttributeNamedArgument> Properties {
			get {
				Resolve ();

				if (properties == null)
					Interlocked.CompareExchange (ref properties, new Collection<CustomAttributeNamedArgument> (), null);

				return properties;
			}
		}

		internal bool HasImage {
			get { return constructor != null && constructor.HasImage; }
		}

		internal ModuleDefinition Module {
			get { return constructor.Module; }
		}

		internal CustomAttribute (uint signature, MethodReference constructor)
		{
			this.signature = signature;
			this.constructor = constructor;
			this.resolved = false;
		}

		public CustomAttribute (MethodReference constructor)
		{
			this.constructor = constructor;
			this.resolved = true;
		}

		public CustomAttribute (MethodReference constructor, byte [] blob)
		{
			this.constructor = constructor;
			this.resolved = false;
			this.blob = blob;
		}

		public byte [] GetBlob ()
		{
			if (blob != null)
				return blob;

			if (!HasImage)
				throw new NotSupportedException ();

			return Module.Read (ref blob, this, (attribute, reader) => reader.ReadCustomAttributeBlob (attribute.signature));
		}

		void Resolve ()
		{
			if (resolved || !HasImage)
				return;

			lock (Module.SyncRoot) {
				if (resolved)
					return;

				Module.Read (this, (attribute, reader) => {
					try {
						reader.ReadCustomAttributeSignature (attribute);
						resolved = true;
					}
					catch (ResolutionException) {
						if (arguments != null)
							arguments.Clear ();
						if (fields != null)
							fields.Clear ();
						if (properties != null)
							properties.Clear ();

						resolved = false;
					}
				});
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/DefaultAssemblyResolver.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Collections.Generic;

namespace MonoFN.Cecil {

	public class DefaultAssemblyResolver : BaseAssemblyResolver {

		readonly IDictionary<string, AssemblyDefinition> cache;

		public DefaultAssemblyResolver ()
		{
			cache = new Dictionary<string, AssemblyDefinition> (StringComparer.Ordinal);
		}

		public override AssemblyDefinition Resolve (AssemblyNameReference name)
		{
			Mixin.CheckName (name);

			AssemblyDefinition assembly;
			if (cache.TryGetValue (name.FullName, out assembly))
				return assembly;

			assembly = base.Resolve (name);
			cache [name.FullName] = assembly;

			return assembly;
		}

		protected void RegisterAssembly (AssemblyDefinition assembly)
		{
			if (assembly == null)
				throw new ArgumentNullException ("assembly");

			var name = assembly.Name.FullName;
			if (cache.ContainsKey (name))
				return;

			cache [name] = assembly;
		}

		protected override void Dispose (bool disposing)
		{
			foreach (var assembly in cache.Values)
				assembly.Dispose ();

			cache.Clear ();

			base.Dispose (disposing);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/EmbeddedResource.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.IO;

namespace MonoFN.Cecil {

	public sealed class EmbeddedResource : Resource {

		readonly MetadataReader reader;

		uint? offset;
		byte [] data;
		Stream stream;

		public override ResourceType ResourceType {
			get { return ResourceType.Embedded; }
		}

		public EmbeddedResource (string name, ManifestResourceAttributes attributes, byte [] data) :
			base (name, attributes)
		{
			this.data = data;
		}

		public EmbeddedResource (string name, ManifestResourceAttributes attributes, Stream stream) :
			base (name, attributes)
		{
			this.stream = stream;
		}

		internal EmbeddedResource (string name, ManifestResourceAttributes attributes, uint offset, MetadataReader reader)
			: base (name, attributes)
		{
			this.offset = offset;
			this.reader = reader;
		}

		public Stream GetResourceStream ()
		{
			if (stream != null)
				return stream;

			if (data != null)
				return new MemoryStream (data);

			if (offset.HasValue)
				return new MemoryStream (reader.GetManagedResource (offset.Value));

			throw new InvalidOperationException ();
		}

		public byte [] GetResourceData ()
		{
			if (stream != null)
				return ReadStream (stream);

			if (data != null)
				return data;

			if (offset.HasValue)
				return reader.GetManagedResource (offset.Value);

			throw new InvalidOperationException ();
		}

		static byte [] ReadStream (Stream stream)
		{
			int read;

			if (stream.CanSeek) {
				var length = (int)stream.Length;
				var data = new byte [length];
				int offset = 0;

				while ((read = stream.Read (data, offset, length - offset)) > 0)
					offset += read;

				return data;
			}

			var buffer = new byte [1024 * 8];
			var memory = new MemoryStream ();
			while ((read = stream.Read (buffer, 0, buffer.Length)) > 0)
				memory.Write (buffer, 0, read);

			return memory.ToArray ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/EventAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum EventAttributes : ushort {
		None = 0x0000,
		SpecialName = 0x0200,   // Event is special
		RTSpecialName = 0x0400   // CLI provides 'special' behavior, depending upon the name of the event
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/EventDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System.Threading;

namespace MonoFN.Cecil {

	public sealed class EventDefinition : EventReference, IMemberDefinition {

		ushort attributes;

		Collection<CustomAttribute> custom_attributes;

		internal MethodDefinition add_method;
		internal MethodDefinition invoke_method;
		internal MethodDefinition remove_method;
		internal Collection<MethodDefinition> other_methods;

		public EventAttributes Attributes {
			get { return (EventAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public MethodDefinition AddMethod {
			get {
				if (add_method != null)
					return add_method;

				InitializeMethods ();
				return add_method;
			}
			set { add_method = value; }
		}

		public MethodDefinition InvokeMethod {
			get {
				if (invoke_method != null)
					return invoke_method;

				InitializeMethods ();
				return invoke_method;
			}
			set { invoke_method = value; }
		}

		public MethodDefinition RemoveMethod {
			get {
				if (remove_method != null)
					return remove_method;

				InitializeMethods ();
				return remove_method;
			}
			set { remove_method = value; }
		}

		public bool HasOtherMethods {
			get {
				if (other_methods != null)
					return other_methods.Count > 0;

				InitializeMethods ();
				return !other_methods.IsNullOrEmpty ();
			}
		}

		public Collection<MethodDefinition> OtherMethods {
			get {
				if (other_methods != null)
					return other_methods;

				InitializeMethods ();

				if (other_methods == null)
					Interlocked.CompareExchange (ref other_methods, new Collection<MethodDefinition> (), null);

				return other_methods;
			}
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, Module)); }
		}

		#region EventAttributes

		public bool IsSpecialName {
			get { return attributes.GetAttributes ((ushort)EventAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes ((ushort)EventAttributes.SpecialName, value); }
		}

		public bool IsRuntimeSpecialName {
			get { return attributes.GetAttributes ((ushort)EventAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes ((ushort)EventAttributes.RTSpecialName, value); }
		}

		#endregion

		public new TypeDefinition DeclaringType {
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		public override bool IsDefinition {
			get { return true; }
		}

		public EventDefinition (string name, EventAttributes attributes, TypeReference eventType)
			: base (name, eventType)
		{
			this.attributes = (ushort)attributes;
			this.token = new MetadataToken (TokenType.Event);
		}

		void InitializeMethods ()
		{
			var module = this.Module;
			if (module == null)
				return;

			lock (module.SyncRoot) {
				if (add_method != null
					|| invoke_method != null
					|| remove_method != null)
					return;

				if (!module.HasImage ())
					return;

				module.Read (this, (@event, reader) => reader.ReadMethods (@event));
			}
		}

		public override EventDefinition Resolve ()
		{
			return this;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/EventReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public abstract class EventReference : MemberReference {

		TypeReference event_type;

		public TypeReference EventType {
			get { return event_type; }
			set { event_type = value; }
		}

		public override string FullName {
			get { return event_type.FullName + " " + MemberFullName (); }
		}

		protected EventReference (string name, TypeReference eventType)
			: base (name)
		{
			Mixin.CheckType (eventType, Mixin.Argument.eventType);
			event_type = eventType;
		}

		protected override IMemberDefinition ResolveDefinition ()
		{
			return this.Resolve ();
		}

		public new abstract EventDefinition Resolve ();
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ExportedType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public sealed class ExportedType : IMetadataTokenProvider {

		string @namespace;
		string name;
		uint attributes;
		IMetadataScope scope;
		ModuleDefinition module;
		int identifier;
		ExportedType declaring_type;
		internal MetadataToken token;

		public string Namespace {
			get { return @namespace; }
			set { @namespace = value; }
		}

		public string Name {
			get { return name; }
			set { name = value; }
		}

		public TypeAttributes Attributes {
			get { return (TypeAttributes)attributes; }
			set { attributes = (uint)value; }
		}

		public IMetadataScope Scope {
			get {
				if (declaring_type != null)
					return declaring_type.Scope;

				return scope;
			}
			set {
				if (declaring_type != null) {
					declaring_type.Scope = value;
					return;
				}

				scope = value;
			}
		}

		public ExportedType DeclaringType {
			get { return declaring_type; }
			set { declaring_type = value; }
		}

		public MetadataToken MetadataToken {
			get { return token; }
			set { token = value; }
		}

		public int Identifier {
			get { return identifier; }
			set { identifier = value; }
		}

		#region TypeAttributes

		public bool IsNotPublic {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NotPublic); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NotPublic, value); }
		}

		public bool IsPublic {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.Public, value); }
		}

		public bool IsNestedPublic {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPublic); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPublic, value); }
		}

		public bool IsNestedPrivate {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPrivate); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPrivate, value); }
		}

		public bool IsNestedFamily {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamily); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamily, value); }
		}

		public bool IsNestedAssembly {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedAssembly); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedAssembly, value); }
		}

		public bool IsNestedFamilyAndAssembly {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamANDAssem); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamANDAssem, value); }
		}

		public bool IsNestedFamilyOrAssembly {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamORAssem); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamORAssem, value); }
		}

		public bool IsAutoLayout {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.AutoLayout); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.AutoLayout, value); }
		}

		public bool IsSequentialLayout {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.SequentialLayout); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.SequentialLayout, value); }
		}

		public bool IsExplicitLayout {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.ExplicitLayout); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.ExplicitLayout, value); }
		}

		public bool IsClass {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Class); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Class, value); }
		}

		public bool IsInterface {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Interface); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Interface, value); }
		}

		public bool IsAbstract {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Abstract); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Abstract, value); }
		}

		public bool IsSealed {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Sealed); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Sealed, value); }
		}

		public bool IsSpecialName {
			get { return attributes.GetAttributes ((uint)TypeAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.SpecialName, value); }
		}

		public bool IsImport {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Import); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Import, value); }
		}

		public bool IsSerializable {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Serializable); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Serializable, value); }
		}

		public bool IsAnsiClass {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AnsiClass); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AnsiClass, value); }
		}

		public bool IsUnicodeClass {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.UnicodeClass); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.UnicodeClass, value); }
		}

		public bool IsAutoClass {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AutoClass); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AutoClass, value); }
		}

		public bool IsBeforeFieldInit {
			get { return attributes.GetAttributes ((uint)TypeAttributes.BeforeFieldInit); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.BeforeFieldInit, value); }
		}

		public bool IsRuntimeSpecialName {
			get { return attributes.GetAttributes ((uint)TypeAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.RTSpecialName, value); }
		}

		public bool HasSecurity {
			get { return attributes.GetAttributes ((uint)TypeAttributes.HasSecurity); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.HasSecurity, value); }
		}

		#endregion

		public bool IsForwarder {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Forwarder); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Forwarder, value); }
		}

		public string FullName {
			get {
				var fullname = string.IsNullOrEmpty (@namespace)
					? name
					: @namespace + '.' + name;

				if (declaring_type != null)
					return declaring_type.FullName + "/" + fullname;

				return fullname;
			}
		}

		public ExportedType (string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
		{
			this.@namespace = @namespace;
			this.name = name;
			this.scope = scope;
			this.module = module;
		}

		public override string ToString ()
		{
			return FullName;
		}

		public TypeDefinition Resolve ()
		{
			return module.Resolve (CreateReference ());
		}

		internal TypeReference CreateReference ()
		{
			return new TypeReference (@namespace, name, module, scope) {
				DeclaringType = declaring_type != null ? declaring_type.CreateReference () : null,
			};
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/FieldAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum FieldAttributes : ushort {
		FieldAccessMask = 0x0007,
		CompilerControlled = 0x0000,    // Member not referenceable
		Private = 0x0001,   // Accessible only by the parent type
		FamANDAssem = 0x0002,   // Accessible by sub-types only in this assembly
		Assembly = 0x0003,  // Accessible by anyone in the Assembly
		Family = 0x0004,    // Accessible only by type and sub-types
		FamORAssem = 0x0005,    // Accessible by sub-types anywhere, plus anyone in the assembly
		Public = 0x0006,    // Accessible by anyone who has visibility to this scope field contract attributes

		Static = 0x0010,    // Defined on type, else per instance
		InitOnly = 0x0020,  // Field may only be initialized, not written after init
		Literal = 0x0040,   // Value is compile time constant
		NotSerialized = 0x0080, // Field does not have to be serialized when type is remoted
		SpecialName = 0x0200,   // Field is special

		// Interop Attributes
		PInvokeImpl = 0x2000,   // Implementation is forwarded through PInvoke

		// Additional flags
		RTSpecialName = 0x0400, // CLI provides 'special' behavior, depending upon the name of the field
		HasFieldMarshal = 0x1000,   // Field has marshalling information
		HasDefault = 0x8000,    // Field has default
		HasFieldRVA = 0x0100     // Field has RVA
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/FieldDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;

namespace MonoFN.Cecil {

	public sealed class FieldDefinition : FieldReference, IMemberDefinition, IConstantProvider, IMarshalInfoProvider {

		ushort attributes;
		Collection<CustomAttribute> custom_attributes;

		int offset = Mixin.NotResolvedMarker;

		internal int rva = Mixin.NotResolvedMarker;
		byte [] initial_value;

		object constant = Mixin.NotResolved;

		MarshalInfo marshal_info;

		void ResolveLayout ()
		{
			if (offset != Mixin.NotResolvedMarker)
				return;

			if (!HasImage) {
				offset = Mixin.NoDataMarker;
				return;
			}

			lock (Module.SyncRoot) {
				if (offset != Mixin.NotResolvedMarker)
					return;
				offset = Module.Read (this, (field, reader) => reader.ReadFieldLayout (field));
			}
		}

		public bool HasLayoutInfo {
			get {
				if (offset >= 0)
					return true;

				ResolveLayout ();

				return offset >= 0;
			}
		}

		public int Offset {
			get {
				if (offset >= 0)
					return offset;

				ResolveLayout ();

				return offset >= 0 ? offset : -1;
			}
			set { offset = value; }
		}

		internal FieldDefinitionProjection WindowsRuntimeProjection {
			get { return (FieldDefinitionProjection)projection; }
			set { projection = value; }
		}

		void ResolveRVA ()
		{
			if (rva != Mixin.NotResolvedMarker)
				return;

			if (!HasImage)
				return;

			lock (Module.SyncRoot) {
				if (rva != Mixin.NotResolvedMarker)
					return;
				rva = Module.Read (this, (field, reader) => reader.ReadFieldRVA (field));
			}
		}

		public int RVA {
			get {
				if (rva > 0)
					return rva;

				ResolveRVA ();

				return rva > 0 ? rva : 0;
			}
		}

		public byte [] InitialValue {
			get {
				if (initial_value != null)
					return initial_value;

				ResolveRVA ();

				if (initial_value == null)
					initial_value = Empty<byte>.Array;

				return initial_value;
			}
			set {
				initial_value = value;
				HasFieldRVA = !initial_value.IsNullOrEmpty ();
				rva = 0;
			}
		}

		public FieldAttributes Attributes {
			get { return (FieldAttributes)attributes; }
			set {
				if (IsWindowsRuntimeProjection && (ushort)value != attributes)
					throw new InvalidOperationException ();

				attributes = (ushort)value;
			}
		}

		public bool HasConstant {
			get {
				this.ResolveConstant (ref constant, Module);

				return constant != Mixin.NoValue;
			}
			set { if (!value) constant = Mixin.NoValue; }
		}

		public object Constant {
			get { return HasConstant ? constant : null; }
			set { constant = value; }
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, Module)); }
		}

		public bool HasMarshalInfo {
			get {
				if (marshal_info != null)
					return true;

				return this.GetHasMarshalInfo (Module);
			}
		}

		public MarshalInfo MarshalInfo {
			get { return marshal_info ?? (this.GetMarshalInfo (ref marshal_info, Module)); }
			set { marshal_info = value; }
		}

		#region FieldAttributes

		public bool IsCompilerControlled {
			get { return attributes.GetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.CompilerControlled); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.CompilerControlled, value); }
		}

		public bool IsPrivate {
			get { return attributes.GetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Private); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Private, value); }
		}

		public bool IsFamilyAndAssembly {
			get { return attributes.GetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.FamANDAssem); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.FamANDAssem, value); }
		}

		public bool IsAssembly {
			get { return attributes.GetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Assembly); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Assembly, value); }
		}

		public bool IsFamily {
			get { return attributes.GetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Family); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Family, value); }
		}

		public bool IsFamilyOrAssembly {
			get { return attributes.GetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.FamORAssem); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.FamORAssem, value); }
		}

		public bool IsPublic {
			get { return attributes.GetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)FieldAttributes.FieldAccessMask, (ushort)FieldAttributes.Public, value); }
		}

		public bool IsStatic {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.Static); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.Static, value); }
		}

		public bool IsInitOnly {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.InitOnly); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.InitOnly, value); }
		}

		public bool IsLiteral {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.Literal); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.Literal, value); }
		}

		public bool IsNotSerialized {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.NotSerialized); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.NotSerialized, value); }
		}

		public bool IsSpecialName {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.SpecialName, value); }
		}

		public bool IsPInvokeImpl {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.PInvokeImpl); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.PInvokeImpl, value); }
		}

		public bool IsRuntimeSpecialName {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.RTSpecialName, value); }
		}

		public bool HasDefault {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.HasDefault); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.HasDefault, value); }
		}

		public bool HasFieldRVA {
			get { return attributes.GetAttributes ((ushort)FieldAttributes.HasFieldRVA); }
			set { attributes = attributes.SetAttributes ((ushort)FieldAttributes.HasFieldRVA, value); }
		}

		#endregion

		public override bool IsDefinition {
			get { return true; }
		}

		public new TypeDefinition DeclaringType {
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		public FieldDefinition (string name, FieldAttributes attributes, TypeReference fieldType)
			: base (name, fieldType)
		{
			this.attributes = (ushort)attributes;
		}

		public override FieldDefinition Resolve ()
		{
			return this;
		}
	}

	static partial class Mixin {

		public const int NotResolvedMarker = -2;
		public const int NoDataMarker = -1;
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/FieldReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	public class FieldReference : MemberReference {

		TypeReference field_type;

		public TypeReference FieldType {
			get { return field_type; }
			set { field_type = value; }
		}

		public override string FullName {
			get { return field_type.FullName + " " + MemberFullName (); }
		}

		public override bool ContainsGenericParameter {
			get { return field_type.ContainsGenericParameter || base.ContainsGenericParameter; }
		}

		internal FieldReference ()
		{
			this.token = new MetadataToken (TokenType.MemberRef);
		}

		public FieldReference (string name, TypeReference fieldType)
			: base (name)
		{
			Mixin.CheckType (fieldType, Mixin.Argument.fieldType);

			this.field_type = fieldType;
			this.token = new MetadataToken (TokenType.MemberRef);
		}

		public FieldReference (string name, TypeReference fieldType, TypeReference declaringType)
			: this (name, fieldType)
		{
			Mixin.CheckType (declaringType, Mixin.Argument.declaringType);

			this.DeclaringType = declaringType;
		}

		protected override IMemberDefinition ResolveDefinition ()
		{
			return this.Resolve ();
		}

		public new virtual FieldDefinition Resolve ()
		{
			var module = this.Module;
			if (module == null)
				throw new NotSupportedException ();

			return module.Resolve (this);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/FileAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	enum FileAttributes : uint {
		ContainsMetaData = 0x0000,  // This is not a resource file
		ContainsNoMetaData = 0x0001,    // This is a resource file or other non-metadata-containing file
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/FunctionPointerType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Text;
using MD = MonoFN.Cecil.Metadata;

namespace MonoFN.Cecil {

	public sealed class FunctionPointerType : TypeSpecification, IMethodSignature {

		readonly MethodReference function;

		public bool HasThis {
			get { return function.HasThis; }
			set { function.HasThis = value; }
		}

		public bool ExplicitThis {
			get { return function.ExplicitThis; }
			set { function.ExplicitThis = value; }
		}

		public MethodCallingConvention CallingConvention {
			get { return function.CallingConvention; }
			set { function.CallingConvention = value; }
		}

		public bool HasParameters {
			get { return function.HasParameters; }
		}

		public Collection<ParameterDefinition> Parameters {
			get { return function.Parameters; }
		}

		public TypeReference ReturnType {
			get { return function.MethodReturnType.ReturnType; }
			set { function.MethodReturnType.ReturnType = value; }
		}

		public MethodReturnType MethodReturnType {
			get { return function.MethodReturnType; }
		}

		public override string Name {
			get { return function.Name; }
			set { throw new InvalidOperationException (); }
		}

		public override string Namespace {
			get { return string.Empty; }
			set { throw new InvalidOperationException (); }
		}

		public override ModuleDefinition Module {
			get { return ReturnType.Module; }
		}

		public override IMetadataScope Scope {
			get { return function.ReturnType.Scope; }
			set { throw new InvalidOperationException (); }
		}

		public override bool IsFunctionPointer {
			get { return true; }
		}

		public override bool ContainsGenericParameter {
			get { return function.ContainsGenericParameter; }
		}

		public override string FullName {
			get {
				var signature = new StringBuilder ();
				signature.Append (function.Name);
				signature.Append (" ");
				signature.Append (function.ReturnType.FullName);
				signature.Append (" *");
				this.MethodSignatureFullName (signature);
				return signature.ToString ();
			}
		}

		public FunctionPointerType ()
			: base (null)
		{
			this.function = new MethodReference ();
			this.function.Name = "method";
			this.etype = MD.ElementType.FnPtr;
		}

		public override TypeDefinition Resolve ()
		{
			return null;
		}

		public override TypeReference GetElementType ()
		{
			return this;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/GenericInstanceMethod.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System.Text;
using System.Threading;

namespace MonoFN.Cecil {

	public sealed class GenericInstanceMethod : MethodSpecification, IGenericInstance, IGenericContext {

		Collection<TypeReference> arguments;

		public bool HasGenericArguments {
			get { return !arguments.IsNullOrEmpty (); }
		}

		public Collection<TypeReference> GenericArguments {
			get {
				if (arguments == null)
					Interlocked.CompareExchange (ref arguments, new Collection<TypeReference> (), null);

				return arguments;
			}
		}

		public override bool IsGenericInstance {
			get { return true; }
		}

		IGenericParameterProvider IGenericContext.Method {
			get { return ElementMethod; }
		}

		IGenericParameterProvider IGenericContext.Type {
			get { return ElementMethod.DeclaringType; }
		}

		public override bool ContainsGenericParameter {
			get { return this.ContainsGenericParameter () || base.ContainsGenericParameter; }
		}

		public override string FullName {
			get {
				var signature = new StringBuilder ();
				var method = this.ElementMethod;
				signature.Append (method.ReturnType.FullName)
					.Append (" ")
					.Append (method.DeclaringType.FullName)
					.Append ("::")
					.Append (method.Name);
				this.GenericInstanceFullName (signature);
				this.MethodSignatureFullName (signature);
				return signature.ToString ();

			}
		}

		public GenericInstanceMethod (MethodReference method)
			: base (method)
		{
		}

		internal GenericInstanceMethod (MethodReference method, int arity)
			: this (method)
		{
			this.arguments = new Collection<TypeReference> (arity);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/GenericInstanceType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Text;
using System.Threading;
using MD = MonoFN.Cecil.Metadata;

namespace MonoFN.Cecil {

	public sealed class GenericInstanceType : TypeSpecification, IGenericInstance, IGenericContext {

		Collection<TypeReference> arguments;

		public bool HasGenericArguments {
			get { return !arguments.IsNullOrEmpty (); }
		}

		public Collection<TypeReference> GenericArguments {
			get {
				if (arguments == null)
					Interlocked.CompareExchange (ref arguments, new Collection<TypeReference> (), null);

				return arguments;
			}
		}

		public override TypeReference DeclaringType {
			get { return ElementType.DeclaringType; }
			set { throw new NotSupportedException (); }
		}

		public override string FullName {
			get {
				var name = new StringBuilder ();
				name.Append (base.FullName);
				this.GenericInstanceFullName (name);
				return name.ToString ();
			}
		}

		public override bool IsGenericInstance {
			get { return true; }
		}

		public override bool ContainsGenericParameter {
			get { return this.ContainsGenericParameter () || base.ContainsGenericParameter; }
		}

		IGenericParameterProvider IGenericContext.Type {
			get { return ElementType; }
		}

		public GenericInstanceType (TypeReference type)
			: base (type)
		{
			base.IsValueType = type.IsValueType;
			this.etype = MD.ElementType.GenericInst;
		}

		internal GenericInstanceType (TypeReference type, int arity)
			: this (type)
		{
			this.arguments = new Collection<TypeReference> (arity);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/GenericParameter.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using MonoFN.Collections.Generic;
using System;
using System.Threading;

namespace MonoFN.Cecil {

	public sealed class GenericParameter : TypeReference, ICustomAttributeProvider {

		internal int position;
		internal GenericParameterType type;
		internal IGenericParameterProvider owner;

		ushort attributes;
		GenericParameterConstraintCollection constraints;
		Collection<CustomAttribute> custom_attributes;

		public GenericParameterAttributes Attributes {
			get { return (GenericParameterAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public int Position {
			get { return position; }
		}

		public GenericParameterType Type {
			get { return type; }
		}

		public IGenericParameterProvider Owner {
			get { return owner; }
		}

		public bool HasConstraints {
			get {
				if (constraints != null)
					return constraints.Count > 0;

				return HasImage && Module.Read (this, (generic_parameter, reader) => reader.HasGenericConstraints (generic_parameter));
			}
		}

		public Collection<GenericParameterConstraint> Constraints {
			get {
				if (constraints != null)
					return constraints;

				if (HasImage)
					return Module.Read (ref constraints, this, (generic_parameter, reader) => reader.ReadGenericConstraints (generic_parameter));

				Interlocked.CompareExchange (ref constraints, new GenericParameterConstraintCollection (this), null);
				return constraints;
			}
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, Module)); }
		}

		public override IMetadataScope Scope {
			get {
				if (owner == null)
					return null;

				return owner.GenericParameterType == GenericParameterType.Method
					? ((MethodReference)owner).DeclaringType.Scope
					: ((TypeReference)owner).Scope;
			}
			set { throw new InvalidOperationException (); }
		}

		public override TypeReference DeclaringType {
			get { return owner as TypeReference; }
			set { throw new InvalidOperationException (); }
		}

		public MethodReference DeclaringMethod {
			get { return owner as MethodReference; }
		}

		public override ModuleDefinition Module {
			get { return module ?? owner.Module; }
		}

		public override string Name {
			get {
				if (!string.IsNullOrEmpty (base.Name))
					return base.Name;

				return base.Name = (type == GenericParameterType.Method ? "!!" : "!") + position;
			}
		}

		public override string Namespace {
			get { return string.Empty; }
			set { throw new InvalidOperationException (); }
		}

		public override string FullName {
			get { return Name; }
		}

		public override bool IsGenericParameter {
			get { return true; }
		}

		public override bool ContainsGenericParameter {
			get { return true; }
		}

		public override MetadataType MetadataType {
			get { return (MetadataType)etype; }
		}

		#region GenericParameterAttributes

		public bool IsNonVariant {
			get { return attributes.GetMaskedAttributes ((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.NonVariant); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.NonVariant, value); }
		}

		public bool IsCovariant {
			get { return attributes.GetMaskedAttributes ((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.Covariant); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.Covariant, value); }
		}

		public bool IsContravariant {
			get { return attributes.GetMaskedAttributes ((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.Contravariant); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)GenericParameterAttributes.VarianceMask, (ushort)GenericParameterAttributes.Contravariant, value); }
		}

		public bool HasReferenceTypeConstraint {
			get { return attributes.GetAttributes ((ushort)GenericParameterAttributes.ReferenceTypeConstraint); }
			set { attributes = attributes.SetAttributes ((ushort)GenericParameterAttributes.ReferenceTypeConstraint, value); }
		}

		public bool HasNotNullableValueTypeConstraint {
			get { return attributes.GetAttributes ((ushort)GenericParameterAttributes.NotNullableValueTypeConstraint); }
			set { attributes = attributes.SetAttributes ((ushort)GenericParameterAttributes.NotNullableValueTypeConstraint, value); }
		}

		public bool HasDefaultConstructorConstraint {
			get { return attributes.GetAttributes ((ushort)GenericParameterAttributes.DefaultConstructorConstraint); }
			set { attributes = attributes.SetAttributes ((ushort)GenericParameterAttributes.DefaultConstructorConstraint, value); }
		}

		#endregion

		public GenericParameter (IGenericParameterProvider owner)
			: this (string.Empty, owner)
		{
		}

		public GenericParameter (string name, IGenericParameterProvider owner)
			: base (string.Empty, name)
		{
			if (owner == null)
				throw new ArgumentNullException ();

			this.position = -1;
			this.owner = owner;
			this.type = owner.GenericParameterType;
			this.etype = ConvertGenericParameterType (this.type);
			this.token = new MetadataToken (TokenType.GenericParam);

		}

		internal GenericParameter (int position, GenericParameterType type, ModuleDefinition module)
			: base (string.Empty, string.Empty)
		{
			Mixin.CheckModule (module);

			this.position = position;
			this.type = type;
			this.etype = ConvertGenericParameterType (type);
			this.module = module;
			this.token = new MetadataToken (TokenType.GenericParam);
		}

		static ElementType ConvertGenericParameterType (GenericParameterType type)
		{
			switch (type) {
			case GenericParameterType.Type:
				return ElementType.Var;
			case GenericParameterType.Method:
				return ElementType.MVar;
			}

			throw new ArgumentOutOfRangeException ();
		}

		public override TypeDefinition Resolve ()
		{
			return null;
		}
	}

	sealed class GenericParameterCollection : Collection<GenericParameter> {

		readonly IGenericParameterProvider owner;

		internal GenericParameterCollection (IGenericParameterProvider owner)
		{
			this.owner = owner;
		}

		internal GenericParameterCollection (IGenericParameterProvider owner, int capacity)
			: base (capacity)
		{
			this.owner = owner;
		}

		protected override void OnAdd (GenericParameter item, int index)
		{
			UpdateGenericParameter (item, index);
		}

		protected override void OnInsert (GenericParameter item, int index)
		{
			UpdateGenericParameter (item, index);

			for (int i = index; i < size; i++)
				items [i].position = i + 1;
		}

		protected override void OnSet (GenericParameter item, int index)
		{
			UpdateGenericParameter (item, index);
		}

		void UpdateGenericParameter (GenericParameter item, int index)
		{
			item.owner = owner;
			item.position = index;
			item.type = owner.GenericParameterType;
		}

		protected override void OnRemove (GenericParameter item, int index)
		{
			item.owner = null;
			item.position = -1;
			item.type = GenericParameterType.Type;

			for (int i = index + 1; i < size; i++)
				items [i].position = i - 1;
		}
	}

	public sealed class GenericParameterConstraint : ICustomAttributeProvider {

		internal GenericParameter generic_parameter;
		internal MetadataToken token;

		TypeReference constraint_type;
		Collection<CustomAttribute> custom_attributes;

		public TypeReference ConstraintType {
			get { return constraint_type; }
			set { constraint_type = value; }
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				if (generic_parameter == null)
					return false;

				return this.GetHasCustomAttributes (generic_parameter.Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get {
				if (generic_parameter == null) {
					if (custom_attributes == null)
						Interlocked.CompareExchange (ref custom_attributes, new Collection<CustomAttribute> (), null);
					return custom_attributes;
				}

				return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, generic_parameter.Module));
			}
		}

		public MetadataToken MetadataToken {
			get { return token; }
			set { token = value; }
		}

		internal GenericParameterConstraint (TypeReference constraintType, MetadataToken token)
		{
			this.constraint_type = constraintType;
			this.token = token;
		}

		public GenericParameterConstraint (TypeReference constraintType)
		{
			Mixin.CheckType (constraintType, Mixin.Argument.constraintType);

			this.constraint_type = constraintType;
			this.token = new MetadataToken (TokenType.GenericParamConstraint);
		}
	}

	class GenericParameterConstraintCollection : Collection<GenericParameterConstraint> {
		readonly GenericParameter generic_parameter;

		internal GenericParameterConstraintCollection (GenericParameter genericParameter)
		{
			this.generic_parameter = genericParameter;
		}

		internal GenericParameterConstraintCollection (GenericParameter genericParameter, int length)
			: base (length)
		{
			this.generic_parameter = genericParameter;
		}

		protected override void OnAdd (GenericParameterConstraint item, int index)
		{
			item.generic_parameter = generic_parameter;
		}

		protected override void OnInsert (GenericParameterConstraint item, int index)
		{
			item.generic_parameter = generic_parameter;
		}

		protected override void OnSet (GenericParameterConstraint item, int index)
		{
			item.generic_parameter = generic_parameter;
		}

		protected override void OnRemove (GenericParameterConstraint item, int index)
		{
			item.generic_parameter = null;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/GenericParameterAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum GenericParameterAttributes : ushort {
		VarianceMask = 0x0003,
		NonVariant = 0x0000,
		Covariant = 0x0001,
		Contravariant = 0x0002,

		SpecialConstraintMask = 0x001c,
		ReferenceTypeConstraint = 0x0004,
		NotNullableValueTypeConstraint = 0x0008,
		DefaultConstructorConstraint = 0x0010
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/GenericParameterResolver.cs ---
﻿using MonoFN.Cecil.Cil;
using System;

namespace MonoFN.Cecil {
	internal sealed class GenericParameterResolver {
		internal static TypeReference ResolveReturnTypeIfNeeded (MethodReference methodReference)
		{
			if (methodReference.DeclaringType.IsArray && methodReference.Name == "Get")
				return methodReference.ReturnType;

			var genericInstanceMethod = methodReference as GenericInstanceMethod;
			var declaringGenericInstanceType = methodReference.DeclaringType as GenericInstanceType;

			if (genericInstanceMethod == null && declaringGenericInstanceType == null)
				return methodReference.ReturnType;

			return ResolveIfNeeded (genericInstanceMethod, declaringGenericInstanceType, methodReference.ReturnType);
		}

		internal static TypeReference ResolveFieldTypeIfNeeded (FieldReference fieldReference)
		{
			return ResolveIfNeeded (null, fieldReference.DeclaringType as GenericInstanceType, fieldReference.FieldType);
		}

		internal static TypeReference ResolveParameterTypeIfNeeded (MethodReference method, ParameterReference parameter)
		{
			var genericInstanceMethod = method as GenericInstanceMethod;
			var declaringGenericInstanceType = method.DeclaringType as GenericInstanceType;

			if (genericInstanceMethod == null && declaringGenericInstanceType == null)
				return parameter.ParameterType;

			return ResolveIfNeeded (genericInstanceMethod, declaringGenericInstanceType, parameter.ParameterType);
		}

		internal static TypeReference ResolveVariableTypeIfNeeded (MethodReference method, VariableReference variable)
		{
			var genericInstanceMethod = method as GenericInstanceMethod;
			var declaringGenericInstanceType = method.DeclaringType as GenericInstanceType;

			if (genericInstanceMethod == null && declaringGenericInstanceType == null)
				return variable.VariableType;

			return ResolveIfNeeded (genericInstanceMethod, declaringGenericInstanceType, variable.VariableType);
		}

		private static TypeReference ResolveIfNeeded (IGenericInstance genericInstanceMethod, IGenericInstance declaringGenericInstanceType, TypeReference parameterType)
		{
			var byRefType = parameterType as ByReferenceType;
			if (byRefType != null)
				return ResolveIfNeeded (genericInstanceMethod, declaringGenericInstanceType, byRefType);

			var arrayType = parameterType as ArrayType;
			if (arrayType != null)
				return ResolveIfNeeded (genericInstanceMethod, declaringGenericInstanceType, arrayType);

			var genericInstanceType = parameterType as GenericInstanceType;
			if (genericInstanceType != null)
				return ResolveIfNeeded (genericInstanceMethod, declaringGenericInstanceType, genericInstanceType);

			var genericParameter = parameterType as GenericParameter;
			if (genericParameter != null)
				return ResolveIfNeeded (genericInstanceMethod, declaringGenericInstanceType, genericParameter);

			var requiredModifierType = parameterType as RequiredModifierType;
			if (requiredModifierType != null && ContainsGenericParameters (requiredModifierType))
				return ResolveIfNeeded (genericInstanceMethod, declaringGenericInstanceType, requiredModifierType.ElementType);

			if (ContainsGenericParameters (parameterType))
				throw new Exception ("Unexpected generic parameter.");

			return parameterType;
		}

		private static TypeReference ResolveIfNeeded (IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericParameter genericParameterElement)
		{
			return (genericParameterElement.MetadataType == MetadataType.MVar)
				? (genericInstanceMethod != null ? genericInstanceMethod.GenericArguments [genericParameterElement.Position] : genericParameterElement)
				: genericInstanceType.GenericArguments [genericParameterElement.Position];
		}

		private static ArrayType ResolveIfNeeded (IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ArrayType arrayType)
		{
			return new ArrayType (ResolveIfNeeded (genericInstanceMethod, genericInstanceType, arrayType.ElementType), arrayType.Rank);
		}

		private static ByReferenceType ResolveIfNeeded (IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ByReferenceType byReferenceType)
		{
			return new ByReferenceType (ResolveIfNeeded (genericInstanceMethod, genericInstanceType, byReferenceType.ElementType));
		}

		private static GenericInstanceType ResolveIfNeeded (IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericInstanceType genericInstanceType1)
		{
			if (!ContainsGenericParameters (genericInstanceType1))
				return genericInstanceType1;

			var newGenericInstance = new GenericInstanceType (genericInstanceType1.ElementType);

			foreach (var genericArgument in genericInstanceType1.GenericArguments) {
				if (!genericArgument.IsGenericParameter) {
					newGenericInstance.GenericArguments.Add (ResolveIfNeeded (genericInstanceMethod, genericInstanceType, genericArgument));
					continue;
				}

				var genParam = (GenericParameter)genericArgument;

				switch (genParam.Type) {
				case GenericParameterType.Type: {
						if (genericInstanceType == null)
							throw new NotSupportedException ();

						newGenericInstance.GenericArguments.Add (genericInstanceType.GenericArguments [genParam.Position]);
					}
					break;

				case GenericParameterType.Method: {
						if (genericInstanceMethod == null)
							newGenericInstance.GenericArguments.Add (genParam);
						else
							newGenericInstance.GenericArguments.Add (genericInstanceMethod.GenericArguments [genParam.Position]);
					}
					break;
				}
			}

			return newGenericInstance;
		}

		private static bool ContainsGenericParameters (TypeReference typeReference)
		{
			var genericParameter = typeReference as GenericParameter;
			if (genericParameter != null)
				return true;

			var arrayType = typeReference as ArrayType;
			if (arrayType != null)
				return ContainsGenericParameters (arrayType.ElementType);

			var pointerType = typeReference as PointerType;
			if (pointerType != null)
				return ContainsGenericParameters (pointerType.ElementType);

			var byRefType = typeReference as ByReferenceType;
			if (byRefType != null)
				return ContainsGenericParameters (byRefType.ElementType);

			var sentinelType = typeReference as SentinelType;
			if (sentinelType != null)
				return ContainsGenericParameters (sentinelType.ElementType);

			var pinnedType = typeReference as PinnedType;
			if (pinnedType != null)
				return ContainsGenericParameters (pinnedType.ElementType);

			var requiredModifierType = typeReference as RequiredModifierType;
			if (requiredModifierType != null)
				return ContainsGenericParameters (requiredModifierType.ElementType);

			var genericInstance = typeReference as GenericInstanceType;
			if (genericInstance != null) {
				foreach (var genericArgument in genericInstance.GenericArguments) {
					if (ContainsGenericParameters (genericArgument))
						return true;
				}

				return false;
			}

			if (typeReference is TypeSpecification)
				throw new NotSupportedException ();

			return false;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/IConstantProvider.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public interface IConstantProvider : IMetadataTokenProvider {

		bool HasConstant { get; set; }
		object Constant { get; set; }
	}

	static partial class Mixin {

		internal static object NoValue = new object ();
		internal static object NotResolved = new object ();

		public static void ResolveConstant (
			this IConstantProvider self,
			ref object constant,
			ModuleDefinition module)
		{
			if (module == null) {
				constant = Mixin.NoValue;
				return;
			}

			lock (module.SyncRoot) {
				if (constant != Mixin.NotResolved)
					return;
				if (module.HasImage ())
					constant = module.Read (self, (provider, reader) => reader.ReadConstant (provider));
				else
					constant = Mixin.NoValue;
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ICustomAttributeProvider.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System.Threading;

namespace MonoFN.Cecil {

	public interface ICustomAttributeProvider : IMetadataTokenProvider {

		Collection<CustomAttribute> CustomAttributes { get; }

		bool HasCustomAttributes { get; }
	}

	static partial class Mixin {

		public static bool GetHasCustomAttributes (
			this ICustomAttributeProvider self,
			ModuleDefinition module)
		{
			return module.HasImage () && module.Read (self, (provider, reader) => reader.HasCustomAttributes (provider));
		}

		public static Collection<CustomAttribute> GetCustomAttributes (
			this ICustomAttributeProvider self,
			ref Collection<CustomAttribute> variable,
			ModuleDefinition module)
		{
			if (module.HasImage ())
				return module.Read (ref variable, self, (provider, reader) => reader.ReadCustomAttributes (provider));

			Interlocked.CompareExchange (ref variable, new Collection<CustomAttribute> (), null);
			return variable;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/IGenericInstance.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System.Text;

namespace MonoFN.Cecil {

	public interface IGenericInstance : IMetadataTokenProvider {

		bool HasGenericArguments { get; }
		Collection<TypeReference> GenericArguments { get; }
	}

	static partial class Mixin {

		public static bool ContainsGenericParameter (this IGenericInstance self)
		{
			var arguments = self.GenericArguments;

			for (int i = 0; i < arguments.Count; i++)
				if (arguments [i].ContainsGenericParameter)
					return true;

			return false;
		}

		public static void GenericInstanceFullName (this IGenericInstance self, StringBuilder builder)
		{
			builder.Append ("<");
			var arguments = self.GenericArguments;
			for (int i = 0; i < arguments.Count; i++) {
				if (i > 0)
					builder.Append (",");
				builder.Append (arguments [i].FullName);
			}
			builder.Append (">");
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/IGenericParameterProvider.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System.Threading;

namespace MonoFN.Cecil {

	public interface IGenericParameterProvider : IMetadataTokenProvider {

		bool HasGenericParameters { get; }
		bool IsDefinition { get; }
		ModuleDefinition Module { get; }
		Collection<GenericParameter> GenericParameters { get; }
		GenericParameterType GenericParameterType { get; }
	}

	public enum GenericParameterType {
		Type,
		Method
	}

	interface IGenericContext {

		bool IsDefinition { get; }
		IGenericParameterProvider Type { get; }
		IGenericParameterProvider Method { get; }
	}

	static partial class Mixin {

		public static bool GetHasGenericParameters (
			this IGenericParameterProvider self,
			ModuleDefinition module)
		{
			return module.HasImage () && module.Read (self, (provider, reader) => reader.HasGenericParameters (provider));
		}

		public static Collection<GenericParameter> GetGenericParameters (
			this IGenericParameterProvider self,
			ref Collection<GenericParameter> collection,
			ModuleDefinition module)
		{
			if (module.HasImage ())
				return module.Read (ref collection, self, (provider, reader) => reader.ReadGenericParameters (provider));

			Interlocked.CompareExchange (ref collection, new GenericParameterCollection (self), null);
			return collection;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/IMarshalInfoProvider.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public interface IMarshalInfoProvider : IMetadataTokenProvider {

		bool HasMarshalInfo { get; }
		MarshalInfo MarshalInfo { get; set; }
	}

	static partial class Mixin {

		public static bool GetHasMarshalInfo (
			this IMarshalInfoProvider self,
			ModuleDefinition module)
		{
			return module.HasImage () && module.Read (self, (provider, reader) => reader.HasMarshalInfo (provider));
		}

		public static MarshalInfo GetMarshalInfo (
			this IMarshalInfoProvider self,
			ref MarshalInfo variable,
			ModuleDefinition module)
		{
			return module.HasImage ()
				? module.Read (ref variable, self, (provider, reader) => reader.ReadMarshalInfo (provider))
				: null;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/IMemberDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public interface IMemberDefinition : ICustomAttributeProvider {

		string Name { get; set; }
		string FullName { get; }

		bool IsSpecialName { get; set; }
		bool IsRuntimeSpecialName { get; set; }

		TypeDefinition DeclaringType { get; set; }
	}

	static partial class Mixin {

		public static bool GetAttributes (this uint self, uint attributes)
		{
			return (self & attributes) != 0;
		}

		public static uint SetAttributes (this uint self, uint attributes, bool value)
		{
			if (value)
				return self | attributes;

			return self & ~attributes;
		}

		public static bool GetMaskedAttributes (this uint self, uint mask, uint attributes)
		{
			return (self & mask) == attributes;
		}

		public static uint SetMaskedAttributes (this uint self, uint mask, uint attributes, bool value)
		{
			if (value) {
				self &= ~mask;
				return self | attributes;
			}

			return self & ~(mask & attributes);
		}

		public static bool GetAttributes (this ushort self, ushort attributes)
		{
			return (self & attributes) != 0;
		}

		public static ushort SetAttributes (this ushort self, ushort attributes, bool value)
		{
			if (value)
				return (ushort)(self | attributes);

			return (ushort)(self & ~attributes);
		}

		public static bool GetMaskedAttributes (this ushort self, ushort mask, uint attributes)
		{
			return (self & mask) == attributes;
		}

		public static ushort SetMaskedAttributes (this ushort self, ushort mask, uint attributes, bool value)
		{
			if (value) {
				self = (ushort)(self & ~mask);
				return (ushort)(self | attributes);
			}

			return (ushort)(self & ~(mask & attributes));
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/IMetadataScope.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public enum MetadataScopeType {
		AssemblyNameReference,
		ModuleReference,
		ModuleDefinition,
	}

	public interface IMetadataScope : IMetadataTokenProvider {
		MetadataScopeType MetadataScopeType { get; }
		string Name { get; set; }
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/IMetadataTokenProvider.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public interface IMetadataTokenProvider {

		MetadataToken MetadataToken { get; set; }
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/IMethodSignature.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System.Text;

namespace MonoFN.Cecil {

	public interface IMethodSignature : IMetadataTokenProvider {

		bool HasThis { get; set; }
		bool ExplicitThis { get; set; }
		MethodCallingConvention CallingConvention { get; set; }

		bool HasParameters { get; }
		Collection<ParameterDefinition> Parameters { get; }
		TypeReference ReturnType { get; set; }
		MethodReturnType MethodReturnType { get; }
	}

	static partial class Mixin {

		public static bool HasImplicitThis (this IMethodSignature self)
		{
			return self.HasThis && !self.ExplicitThis;
		}

		public static void MethodSignatureFullName (this IMethodSignature self, StringBuilder builder)
		{
			builder.Append ("(");

			if (self.HasParameters) {
				var parameters = self.Parameters;
				for (int i = 0; i < parameters.Count; i++) {
					var parameter = parameters [i];
					if (i > 0)
						builder.Append (",");

					if (parameter.ParameterType.IsSentinel)
						builder.Append ("...,");

					builder.Append (parameter.ParameterType.FullName);
				}
			}

			builder.Append (")");
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/Import.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using SR = System.Reflection;

namespace MonoFN.Cecil {

	public interface IMetadataImporterProvider {
		IMetadataImporter GetMetadataImporter (ModuleDefinition module);
	}

	public interface IMetadataImporter {
		AssemblyNameReference ImportReference (AssemblyNameReference reference);
		TypeReference ImportReference (TypeReference type, IGenericParameterProvider context);
		FieldReference ImportReference (FieldReference field, IGenericParameterProvider context);
		MethodReference ImportReference (MethodReference method, IGenericParameterProvider context);
	}

	public interface IReflectionImporterProvider {
		IReflectionImporter GetReflectionImporter (ModuleDefinition module);
	}

	public interface IReflectionImporter {
		AssemblyNameReference ImportReference (SR.AssemblyName reference);
		TypeReference ImportReference (Type type, IGenericParameterProvider context);
		FieldReference ImportReference (SR.FieldInfo field, IGenericParameterProvider context);
		MethodReference ImportReference (SR.MethodBase method, IGenericParameterProvider context);
	}

	struct ImportGenericContext {

		Collection<IGenericParameterProvider> stack;

		public bool IsEmpty { get { return stack == null; } }

		public ImportGenericContext (IGenericParameterProvider provider)
		{
			if (provider == null)
				throw new ArgumentNullException ("provider");

			stack = null;

			Push (provider);
		}

		public void Push (IGenericParameterProvider provider)
		{
			if (stack == null)
				stack = new Collection<IGenericParameterProvider> (1) { provider };
			else
				stack.Add (provider);
		}

		public void Pop ()
		{
			stack.RemoveAt (stack.Count - 1);
		}

		public TypeReference MethodParameter (string method, int position)
		{
			for (int i = stack.Count - 1; i >= 0; i--) {
				var candidate = stack [i] as MethodReference;
				if (candidate == null)
					continue;

				if (method != NormalizeMethodName (candidate))
					continue;

				return candidate.GenericParameters [position];
			}

			throw new InvalidOperationException ();
		}

		public string NormalizeMethodName (MethodReference method)
		{
			return method.DeclaringType.GetElementType ().FullName + "." + method.Name;
		}

		public TypeReference TypeParameter (string type, int position)
		{
			for (int i = stack.Count - 1; i >= 0; i--) {
				var candidate = GenericTypeFor (stack [i]);

				if (candidate.FullName != type)
					continue;

				return candidate.GenericParameters [position];
			}

			throw new InvalidOperationException ();
		}

		static TypeReference GenericTypeFor (IGenericParameterProvider context)
		{
			var type = context as TypeReference;
			if (type != null)
				return type.GetElementType ();

			var method = context as MethodReference;
			if (method != null)
				return method.DeclaringType.GetElementType ();

			throw new InvalidOperationException ();
		}

		public static ImportGenericContext For (IGenericParameterProvider context)
		{
			return context != null ? new ImportGenericContext (context) : default (ImportGenericContext);
		}
	}

	public class DefaultReflectionImporter : IReflectionImporter {

		readonly protected ModuleDefinition module;

		public DefaultReflectionImporter (ModuleDefinition module)
		{
			Mixin.CheckModule (module);

			this.module = module;
		}

		enum ImportGenericKind {
			Definition,
			Open,
		}

		static readonly Dictionary<Type, ElementType> type_etype_mapping = new Dictionary<Type, ElementType> (18) {
			{ typeof (void), ElementType.Void },
			{ typeof (bool), ElementType.Boolean },
			{ typeof (char), ElementType.Char },
			{ typeof (sbyte), ElementType.I1 },
			{ typeof (byte), ElementType.U1 },
			{ typeof (short), ElementType.I2 },
			{ typeof (ushort), ElementType.U2 },
			{ typeof (int), ElementType.I4 },
			{ typeof (uint), ElementType.U4 },
			{ typeof (long), ElementType.I8 },
			{ typeof (ulong), ElementType.U8 },
			{ typeof (float), ElementType.R4 },
			{ typeof (double), ElementType.R8 },
			{ typeof (string), ElementType.String },
			{ typeof (TypedReference), ElementType.TypedByRef },
			{ typeof (IntPtr), ElementType.I },
			{ typeof (UIntPtr), ElementType.U },
			{ typeof (object), ElementType.Object },
		};

		TypeReference ImportType (Type type, ImportGenericContext context)
		{
			return ImportType (type, context, ImportGenericKind.Open);
		}

		TypeReference ImportType (Type type, ImportGenericContext context, ImportGenericKind import_kind)
		{
			if (IsTypeSpecification (type) || ImportOpenGenericType (type, import_kind))
				return ImportTypeSpecification (type, context);

			var reference = new TypeReference (
				string.Empty,
				type.Name,
				module,
				ImportScope (type),
				type.IsValueType);

			reference.etype = ImportElementType (type);

			if (IsNestedType (type))
				reference.DeclaringType = ImportType (type.DeclaringType, context, import_kind);
			else
				reference.Namespace = type.Namespace ?? string.Empty;

			if (type.IsGenericType)
				ImportGenericParameters (reference, type.GetGenericArguments ());

			return reference;
		}

		protected virtual IMetadataScope ImportScope (Type type)
		{
			return ImportScope (type.Assembly);
		}

		static bool ImportOpenGenericType (Type type, ImportGenericKind import_kind)
		{
			return type.IsGenericType && type.IsGenericTypeDefinition && import_kind == ImportGenericKind.Open;
		}

		static bool ImportOpenGenericMethod (SR.MethodBase method, ImportGenericKind import_kind)
		{
			return method.IsGenericMethod && method.IsGenericMethodDefinition && import_kind == ImportGenericKind.Open;
		}

		static bool IsNestedType (Type type)
		{
			return type.IsNested;
		}

		TypeReference ImportTypeSpecification (Type type, ImportGenericContext context)
		{
			if (type.IsByRef)
				return new ByReferenceType (ImportType (type.GetElementType (), context));

			if (type.IsPointer)
				return new PointerType (ImportType (type.GetElementType (), context));

			if (type.IsArray)
				return new ArrayType (ImportType (type.GetElementType (), context), type.GetArrayRank ());

			if (type.IsGenericType)
				return ImportGenericInstance (type, context);

			if (type.IsGenericParameter)
				return ImportGenericParameter (type, context);

			throw new NotSupportedException (type.FullName);
		}

		static TypeReference ImportGenericParameter (Type type, ImportGenericContext context)
		{
			if (context.IsEmpty)
				throw new InvalidOperationException ();

			if (type.DeclaringMethod != null)
				return context.MethodParameter (NormalizeMethodName (type.DeclaringMethod), type.GenericParameterPosition);

			if (type.DeclaringType != null)
				return context.TypeParameter (NormalizeTypeFullName (type.DeclaringType), type.GenericParameterPosition);

			throw new InvalidOperationException ();
		}

		static string NormalizeMethodName (SR.MethodBase method)
		{
			return NormalizeTypeFullName (method.DeclaringType) + "." + method.Name;
		}

		static string NormalizeTypeFullName (Type type)
		{
			if (IsNestedType (type))
				return NormalizeTypeFullName (type.DeclaringType) + "/" + type.Name;

			return type.FullName;
		}

		TypeReference ImportGenericInstance (Type type, ImportGenericContext context)
		{
			var element_type = ImportType (type.GetGenericTypeDefinition (), context, ImportGenericKind.Definition);
			var arguments = type.GetGenericArguments ();
			var instance = new GenericInstanceType (element_type, arguments.Length);
			var instance_arguments = instance.GenericArguments;

			context.Push (element_type);
			try {
				for (int i = 0; i < arguments.Length; i++)
					instance_arguments.Add (ImportType (arguments [i], context));

				return instance;
			}
			finally {
				context.Pop ();
			}
		}

		static bool IsTypeSpecification (Type type)
		{
			return type.HasElementType
				|| IsGenericInstance (type)
				|| type.IsGenericParameter;
		}

		static bool IsGenericInstance (Type type)
		{
			return type.IsGenericType && !type.IsGenericTypeDefinition;
		}

		static ElementType ImportElementType (Type type)
		{
			ElementType etype;
			if (!type_etype_mapping.TryGetValue (type, out etype))
				return ElementType.None;

			return etype;
		}

		protected AssemblyNameReference ImportScope (SR.Assembly assembly)
		{
			return ImportReference (assembly.GetName ());
		}

		public virtual AssemblyNameReference ImportReference (SR.AssemblyName name)
		{
			Mixin.CheckName (name);

			AssemblyNameReference reference;
			if (TryGetAssemblyNameReference (name, out reference))
				return reference;

			reference = new AssemblyNameReference (name.Name, name.Version) {
				PublicKeyToken = name.GetPublicKeyToken (),
				Culture = name.CultureInfo.Name,
				HashAlgorithm = (AssemblyHashAlgorithm)name.HashAlgorithm,
			};

			module.AssemblyReferences.Add (reference);

			return reference;
		}

		bool TryGetAssemblyNameReference (SR.AssemblyName name, out AssemblyNameReference assembly_reference)
		{
			var references = module.AssemblyReferences;

			for (int i = 0; i < references.Count; i++) {
				var reference = references [i];
				if (name.FullName != reference.FullName) // TODO compare field by field
					continue;

				assembly_reference = reference;
				return true;
			}

			assembly_reference = null;
			return false;
		}

		FieldReference ImportField (SR.FieldInfo field, ImportGenericContext context)
		{
			var declaring_type = ImportType (field.DeclaringType, context);

			if (IsGenericInstance (field.DeclaringType))
				field = ResolveFieldDefinition (field);

			context.Push (declaring_type);
			try {
				return new FieldReference {
					Name = field.Name,
					DeclaringType = declaring_type,
					FieldType = ImportType (field.FieldType, context),
				};
			}
			finally {
				context.Pop ();
			}
		}

		static SR.FieldInfo ResolveFieldDefinition (SR.FieldInfo field)
		{
			return field.Module.ResolveField (field.MetadataToken);
		}

		static SR.MethodBase ResolveMethodDefinition (SR.MethodBase method)
		{
			return method.Module.ResolveMethod (method.MetadataToken);
		}

		MethodReference ImportMethod (SR.MethodBase method, ImportGenericContext context, ImportGenericKind import_kind)
		{
			if (IsMethodSpecification (method) || ImportOpenGenericMethod (method, import_kind))
				return ImportMethodSpecification (method, context);

			var declaring_type = ImportType (method.DeclaringType, context);

			if (IsGenericInstance (method.DeclaringType))
				method = ResolveMethodDefinition (method);

			var reference = new MethodReference {
				Name = method.Name,
				HasThis = HasCallingConvention (method, SR.CallingConventions.HasThis),
				ExplicitThis = HasCallingConvention (method, SR.CallingConventions.ExplicitThis),
				DeclaringType = ImportType (method.DeclaringType, context, ImportGenericKind.Definition),
			};

			if (HasCallingConvention (method, SR.CallingConventions.VarArgs))
				reference.CallingConvention &= MethodCallingConvention.VarArg;

			if (method.IsGenericMethod)
				ImportGenericParameters (reference, method.GetGenericArguments ());

			context.Push (reference);
			try {
				var method_info = method as SR.MethodInfo;
				reference.ReturnType = method_info != null
					? ImportType (method_info.ReturnType, context)
					: ImportType (typeof (void), default (ImportGenericContext));

				var parameters = method.GetParameters ();
				var reference_parameters = reference.Parameters;

				for (int i = 0; i < parameters.Length; i++)
					reference_parameters.Add (
						new ParameterDefinition (ImportType (parameters [i].ParameterType, context)));

				reference.DeclaringType = declaring_type;

				return reference;
			}
			finally {
				context.Pop ();
			}
		}

		static void ImportGenericParameters (IGenericParameterProvider provider, Type [] arguments)
		{
			var provider_parameters = provider.GenericParameters;

			for (int i = 0; i < arguments.Length; i++)
				provider_parameters.Add (new GenericParameter (arguments [i].Name, provider));
		}

		static bool IsMethodSpecification (SR.MethodBase method)
		{
			return method.IsGenericMethod && !method.IsGenericMethodDefinition;
		}

		MethodReference ImportMethodSpecification (SR.MethodBase method, ImportGenericContext context)
		{
			var method_info = method as SR.MethodInfo;
			if (method_info == null)
				throw new InvalidOperationException ();

			var element_method = ImportMethod (method_info.GetGenericMethodDefinition (), context, ImportGenericKind.Definition);
			var instance = new GenericInstanceMethod (element_method);
			var arguments = method.GetGenericArguments ();
			var instance_arguments = instance.GenericArguments;

			context.Push (element_method);
			try {
				for (int i = 0; i < arguments.Length; i++)
					instance_arguments.Add (ImportType (arguments [i], context));

				return instance;
			}
			finally {
				context.Pop ();
			}
		}

		static bool HasCallingConvention (SR.MethodBase method, SR.CallingConventions conventions)
		{
			return (method.CallingConvention & conventions) != 0;
		}

		public virtual TypeReference ImportReference (Type type, IGenericParameterProvider context)
		{
			Mixin.CheckType (type);
			return ImportType (
				type,
				ImportGenericContext.For (context),
				context != null ? ImportGenericKind.Open : ImportGenericKind.Definition);
		}

		public virtual FieldReference ImportReference (SR.FieldInfo field, IGenericParameterProvider context)
		{
			Mixin.CheckField (field);
			return ImportField (field, ImportGenericContext.For (context));
		}

		public virtual MethodReference ImportReference (SR.MethodBase method, IGenericParameterProvider context)
		{
			Mixin.CheckMethod (method);
			return ImportMethod (method,
				ImportGenericContext.For (context),
				context != null ? ImportGenericKind.Open : ImportGenericKind.Definition);
		}
	}

	public class DefaultMetadataImporter : IMetadataImporter {

		readonly protected ModuleDefinition module;

		public DefaultMetadataImporter (ModuleDefinition module)
		{
			Mixin.CheckModule (module);

			this.module = module;
		}

		TypeReference ImportType (TypeReference type, ImportGenericContext context)
		{
			if (type.IsTypeSpecification ())
				return ImportTypeSpecification (type, context);

			var reference = new TypeReference (
				type.Namespace,
				type.Name,
				module,
				ImportScope (type),
				type.IsValueType);

			MetadataSystem.TryProcessPrimitiveTypeReference (reference);

			if (type.IsNested)
				reference.DeclaringType = ImportType (type.DeclaringType, context);

			if (type.HasGenericParameters)
				ImportGenericParameters (reference, type);

			return reference;
		}

		protected virtual IMetadataScope ImportScope (TypeReference type)
		{
			return ImportScope (type.Scope);
		}

		protected IMetadataScope ImportScope (IMetadataScope scope)
		{
			switch (scope.MetadataScopeType) {
			case MetadataScopeType.AssemblyNameReference:
				return ImportReference ((AssemblyNameReference)scope);
			case MetadataScopeType.ModuleDefinition:
				if (scope == module) return scope;
				return ImportReference (((ModuleDefinition)scope).Assembly.Name);
			case MetadataScopeType.ModuleReference:
				throw new NotImplementedException ();
			}

			throw new NotSupportedException ();
		}

		public virtual AssemblyNameReference ImportReference (AssemblyNameReference name)
		{
			Mixin.CheckName (name);

			AssemblyNameReference reference;
			if (module.TryGetAssemblyNameReference (name, out reference))
				return reference;

			reference = new AssemblyNameReference (name.Name, name.Version) {
				Culture = name.Culture,
				HashAlgorithm = name.HashAlgorithm,
				IsRetargetable = name.IsRetargetable,
				IsWindowsRuntime = name.IsWindowsRuntime,
			};

			var pk_token = !name.PublicKeyToken.IsNullOrEmpty ()
				? new byte [name.PublicKeyToken.Length]
				: Empty<byte>.Array;

			if (pk_token.Length > 0)
				Buffer.BlockCopy (name.PublicKeyToken, 0, pk_token, 0, pk_token.Length);

			reference.PublicKeyToken = pk_token;

			module.AssemblyReferences.Add (reference);

			return reference;
		}

		static void ImportGenericParameters (IGenericParameterProvider imported, IGenericParameterProvider original)
		{
			var parameters = original.GenericParameters;
			var imported_parameters = imported.GenericParameters;

			for (int i = 0; i < parameters.Count; i++)
				imported_parameters.Add (new GenericParameter (parameters [i].Name, imported));
		}

		TypeReference ImportTypeSpecification (TypeReference type, ImportGenericContext context)
		{
			switch (type.etype) {
			case ElementType.SzArray:
				var vector = (ArrayType)type;
				return new ArrayType (ImportType (vector.ElementType, context));
			case ElementType.Ptr:
				var pointer = (PointerType)type;
				return new PointerType (ImportType (pointer.ElementType, context));
			case ElementType.ByRef:
				var byref = (ByReferenceType)type;
				return new ByReferenceType (ImportType (byref.ElementType, context));
			case ElementType.Pinned:
				var pinned = (PinnedType)type;
				return new PinnedType (ImportType (pinned.ElementType, context));
			case ElementType.Sentinel:
				var sentinel = (SentinelType)type;
				return new SentinelType (ImportType (sentinel.ElementType, context));
			case ElementType.FnPtr:
				var fnptr = (FunctionPointerType)type;
				var imported_fnptr = new FunctionPointerType () {
					HasThis = fnptr.HasThis,
					ExplicitThis = fnptr.ExplicitThis,
					CallingConvention = fnptr.CallingConvention,
					ReturnType = ImportType (fnptr.ReturnType, context),
				};

				if (!fnptr.HasParameters)
					return imported_fnptr;

				for (int i = 0; i < fnptr.Parameters.Count; i++)
					imported_fnptr.Parameters.Add (new ParameterDefinition (
						ImportType (fnptr.Parameters [i].ParameterType, context)));

				return imported_fnptr;
			case ElementType.CModOpt:
				var modopt = (OptionalModifierType)type;
				return new OptionalModifierType (
					ImportType (modopt.ModifierType, context),
					ImportType (modopt.ElementType, context));
			case ElementType.CModReqD:
				var modreq = (RequiredModifierType)type;
				return new RequiredModifierType (
					ImportType (modreq.ModifierType, context),
					ImportType (modreq.ElementType, context));
			case ElementType.Array:
				var array = (ArrayType)type;
				var imported_array = new ArrayType (ImportType (array.ElementType, context));
				if (array.IsVector)
					return imported_array;

				var dimensions = array.Dimensions;
				var imported_dimensions = imported_array.Dimensions;

				imported_dimensions.Clear ();

				for (int i = 0; i < dimensions.Count; i++) {
					var dimension = dimensions [i];

					imported_dimensions.Add (new ArrayDimension (dimension.LowerBound, dimension.UpperBound));
				}

				return imported_array;
			case ElementType.GenericInst:
				var instance = (GenericInstanceType)type;
				var element_type = ImportType (instance.ElementType, context);
				var arguments = instance.GenericArguments;
				var imported_instance = new GenericInstanceType (element_type, arguments.Count);
				var imported_arguments = imported_instance.GenericArguments;

				for (int i = 0; i < arguments.Count; i++)
					imported_arguments.Add (ImportType (arguments [i], context));

				return imported_instance;
			case ElementType.Var:
				var var_parameter = (GenericParameter)type;
				if (var_parameter.DeclaringType == null)
					throw new InvalidOperationException ();
				return context.TypeParameter (var_parameter.DeclaringType.FullName, var_parameter.Position);
			case ElementType.MVar:
				var mvar_parameter = (GenericParameter)type;
				if (mvar_parameter.DeclaringMethod == null)
					throw new InvalidOperationException ();
				return context.MethodParameter (context.NormalizeMethodName (mvar_parameter.DeclaringMethod), mvar_parameter.Position);
			}

			throw new NotSupportedException (type.etype.ToString ());
		}

		FieldReference ImportField (FieldReference field, ImportGenericContext context)
		{
			var declaring_type = ImportType (field.DeclaringType, context);

			context.Push (declaring_type);
			try {
				return new FieldReference {
					Name = field.Name,
					DeclaringType = declaring_type,
					FieldType = ImportType (field.FieldType, context),
				};
			}
			finally {
				context.Pop ();
			}
		}

		MethodReference ImportMethod (MethodReference method, ImportGenericContext context)
		{
			if (method.IsGenericInstance)
				return ImportMethodSpecification (method, context);

			var declaring_type = ImportType (method.DeclaringType, context);

			var reference = new MethodReference {
				Name = method.Name,
				HasThis = method.HasThis,
				ExplicitThis = method.ExplicitThis,
				DeclaringType = declaring_type,
				CallingConvention = method.CallingConvention,
			};

			if (method.HasGenericParameters)
				ImportGenericParameters (reference, method);

			context.Push (reference);
			try {
				reference.ReturnType = ImportType (method.ReturnType, context);

				if (!method.HasParameters)
					return reference;

				var parameters = method.Parameters;
				var reference_parameters = reference.parameters = new ParameterDefinitionCollection (reference, parameters.Count);
				for (int i = 0; i < parameters.Count; i++)
					reference_parameters.Add (
						new ParameterDefinition (ImportType (parameters [i].ParameterType, context)));

				return reference;
			}
			finally {
				context.Pop ();
			}
		}

		MethodSpecification ImportMethodSpecification (MethodReference method, ImportGenericContext context)
		{
			if (!method.IsGenericInstance)
				throw new NotSupportedException ();

			var instance = (GenericInstanceMethod)method;
			var element_method = ImportMethod (instance.ElementMethod, context);
			var imported_instance = new GenericInstanceMethod (element_method);

			var arguments = instance.GenericArguments;
			var imported_arguments = imported_instance.GenericArguments;

			for (int i = 0; i < arguments.Count; i++)
				imported_arguments.Add (ImportType (arguments [i], context));

			return imported_instance;
		}

		public virtual TypeReference ImportReference (TypeReference type, IGenericParameterProvider context)
		{
			Mixin.CheckType (type);
			return ImportType (type, ImportGenericContext.For (context));
		}

		public virtual FieldReference ImportReference (FieldReference field, IGenericParameterProvider context)
		{
			Mixin.CheckField (field);
			return ImportField (field, ImportGenericContext.For (context));
		}

		public virtual MethodReference ImportReference (MethodReference method, IGenericParameterProvider context)
		{
			Mixin.CheckMethod (method);
			return ImportMethod (method, ImportGenericContext.For (context));
		}
	}

	static partial class Mixin {

		public static void CheckModule (ModuleDefinition module)
		{
			if (module == null)
				throw new ArgumentNullException (Argument.module.ToString ());
		}

		public static bool TryGetAssemblyNameReference (this ModuleDefinition module, AssemblyNameReference name_reference, out AssemblyNameReference assembly_reference)
		{
			var references = module.AssemblyReferences;

			for (int i = 0; i < references.Count; i++) {
				var reference = references [i];
				if (!Equals (name_reference, reference))
					continue;

				assembly_reference = reference;
				return true;
			}

			assembly_reference = null;
			return false;
		}

		static bool Equals (byte [] a, byte [] b)
		{
			if (ReferenceEquals (a, b))
				return true;
			if (a == null)
				return false;
			if (a.Length != b.Length)
				return false;
			for (int i = 0; i < a.Length; i++)
				if (a [i] != b [i])
					return false;
			return true;
		}

		static bool Equals<T> (T a, T b) where T : class, IEquatable<T>
		{
			if (ReferenceEquals (a, b))
				return true;
			if (a == null)
				return false;
			return a.Equals (b);
		}

		static bool Equals (AssemblyNameReference a, AssemblyNameReference b)
		{
			if (ReferenceEquals (a, b))
				return true;
			if (a.Name != b.Name)
				return false;
			if (!Equals (a.Version, b.Version))
				return false;
			if (a.Culture != b.Culture)
				return false;
			if (!Equals (a.PublicKeyToken, b.PublicKeyToken))
				return false;
			return true;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/LinkedResource.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public sealed class LinkedResource : Resource {

		internal byte [] hash;
		string file;

		public byte [] Hash {
			get { return hash; }
		}

		public string File {
			get { return file; }
			set { file = value; }
		}

		public override ResourceType ResourceType {
			get { return ResourceType.Linked; }
		}

		public LinkedResource (string name, ManifestResourceAttributes flags)
			: base (name, flags)
		{
		}

		public LinkedResource (string name, ManifestResourceAttributes flags, string file)
			: base (name, flags)
		{
			this.file = file;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ManifestResourceAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum ManifestResourceAttributes : uint {
		VisibilityMask = 0x0007,
		Public = 0x0001,    // The resource is exported from the Assembly
		Private = 0x0002     // The resource is private to the Assembly
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MarshalInfo.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	public class MarshalInfo {

		internal NativeType native;

		public NativeType NativeType {
			get { return native; }
			set { native = value; }
		}

		public MarshalInfo (NativeType native)
		{
			this.native = native;
		}
	}

	public sealed class ArrayMarshalInfo : MarshalInfo {

		internal NativeType element_type;
		internal int size_parameter_index;
		internal int size;
		internal int size_parameter_multiplier;

		public NativeType ElementType {
			get { return element_type; }
			set { element_type = value; }
		}

		public int SizeParameterIndex {
			get { return size_parameter_index; }
			set { size_parameter_index = value; }
		}

		public int Size {
			get { return size; }
			set { size = value; }
		}

		public int SizeParameterMultiplier {
			get { return size_parameter_multiplier; }
			set { size_parameter_multiplier = value; }
		}

		public ArrayMarshalInfo ()
			: base (NativeType.Array)
		{
			element_type = NativeType.None;
			size_parameter_index = -1;
			size = -1;
			size_parameter_multiplier = -1;
		}
	}

	public sealed class CustomMarshalInfo : MarshalInfo {

		internal Guid guid;
		internal string unmanaged_type;
		internal TypeReference managed_type;
		internal string cookie;

		public Guid Guid {
			get { return guid; }
			set { guid = value; }
		}

		public string UnmanagedType {
			get { return unmanaged_type; }
			set { unmanaged_type = value; }
		}

		public TypeReference ManagedType {
			get { return managed_type; }
			set { managed_type = value; }
		}

		public string Cookie {
			get { return cookie; }
			set { cookie = value; }
		}

		public CustomMarshalInfo ()
			: base (NativeType.CustomMarshaler)
		{
		}
	}

	public sealed class SafeArrayMarshalInfo : MarshalInfo {

		internal VariantType element_type;

		public VariantType ElementType {
			get { return element_type; }
			set { element_type = value; }
		}

		public SafeArrayMarshalInfo ()
			: base (NativeType.SafeArray)
		{
			element_type = VariantType.None;
		}
	}

	public sealed class FixedArrayMarshalInfo : MarshalInfo {

		internal NativeType element_type;
		internal int size;

		public NativeType ElementType {
			get { return element_type; }
			set { element_type = value; }
		}

		public int Size {
			get { return size; }
			set { size = value; }
		}

		public FixedArrayMarshalInfo ()
			: base (NativeType.FixedArray)
		{
			element_type = NativeType.None;
		}
	}

	public sealed class FixedSysStringMarshalInfo : MarshalInfo {

		internal int size;

		public int Size {
			get { return size; }
			set { size = value; }
		}

		public FixedSysStringMarshalInfo ()
			: base (NativeType.FixedSysString)
		{
			size = -1;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MemberDefinitionCollection.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;

namespace MonoFN.Cecil {

	sealed class MemberDefinitionCollection<T> : Collection<T> where T : IMemberDefinition {

		TypeDefinition container;

		internal MemberDefinitionCollection (TypeDefinition container)
		{
			this.container = container;
		}

		internal MemberDefinitionCollection (TypeDefinition container, int capacity)
			: base (capacity)
		{
			this.container = container;
		}

		protected override void OnAdd (T item, int index)
		{
			Attach (item);
		}

		protected sealed override void OnSet (T item, int index)
		{
			Attach (item);
		}

		protected sealed override void OnInsert (T item, int index)
		{
			Attach (item);
		}

		protected sealed override void OnRemove (T item, int index)
		{
			Detach (item);
		}

		protected sealed override void OnClear ()
		{
			foreach (var definition in this)
				Detach (definition);
		}

		void Attach (T element)
		{
			if (element.DeclaringType == container)
				return;

			if (element.DeclaringType != null)
				throw new ArgumentException ("Member already attached");

			element.DeclaringType = this.container;
		}

		static void Detach (T element)
		{
			element.DeclaringType = null;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MemberReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	public abstract class MemberReference : IMetadataTokenProvider {

		string name;
		TypeReference declaring_type;

		internal MetadataToken token;
		internal object projection;

		public virtual string Name {
			get { return name; }
			set {
				if (IsWindowsRuntimeProjection && value != name)
					throw new InvalidOperationException ();

				name = value;
			}
		}

		public abstract string FullName {
			get;
		}

		public virtual TypeReference DeclaringType {
			get { return declaring_type; }
			set { declaring_type = value; }
		}

		public MetadataToken MetadataToken {
			get { return token; }
			set { token = value; }
		}

		public bool IsWindowsRuntimeProjection {
			get { return projection != null; }
		}

		internal bool HasImage {
			get {
				var module = Module;
				if (module == null)
					return false;

				return module.HasImage;
			}
		}

		public virtual ModuleDefinition Module {
			get { return declaring_type != null ? declaring_type.Module : null; }
		}

		public virtual bool IsDefinition {
			get { return false; }
		}

		public virtual bool ContainsGenericParameter {
			get { return declaring_type != null && declaring_type.ContainsGenericParameter; }
		}

		internal MemberReference ()
		{
		}

		internal MemberReference (string name)
		{
			this.name = name ?? string.Empty;
		}

		internal string MemberFullName ()
		{
			if (declaring_type == null)
				return name;

			return declaring_type.FullName + "::" + name;
		}

		public IMemberDefinition Resolve ()
		{
			return ResolveDefinition ();
		}

		protected abstract IMemberDefinition ResolveDefinition ();

		public override string ToString ()
		{
			return FullName;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MetadataResolver.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;

namespace MonoFN.Cecil {

	public interface IAssemblyResolver : IDisposable {
		AssemblyDefinition Resolve (AssemblyNameReference name);
		AssemblyDefinition Resolve (AssemblyNameReference name, ReaderParameters parameters);
	}

	public interface IMetadataResolver {
		TypeDefinition Resolve (TypeReference type);
		FieldDefinition Resolve (FieldReference field);
		MethodDefinition Resolve (MethodReference method);
	}

#if !NET_CORE
	[Serializable]
#endif
	public sealed class ResolutionException : Exception {

		readonly MemberReference member;

		public MemberReference Member {
			get { return member; }
		}

		public IMetadataScope Scope {
			get {
				var type = member as TypeReference;
				if (type != null)
					return type.Scope;

				var declaring_type = member.DeclaringType;
				if (declaring_type != null)
					return declaring_type.Scope;

				throw new NotSupportedException ();
			}
		}

		public ResolutionException (MemberReference member)
			: base ("Failed to resolve " + member.FullName)
		{
			if (member == null)
				throw new ArgumentNullException ("member");

			this.member = member;
		}

		public ResolutionException (MemberReference member, Exception innerException)
			: base ("Failed to resolve " + member.FullName, innerException)
		{
			if (member == null)
				throw new ArgumentNullException ("member");

			this.member = member;
		}

#if !NET_CORE
		ResolutionException (
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
			: base (info, context)
		{
		}
#endif
	}

	public class MetadataResolver : IMetadataResolver {

		readonly IAssemblyResolver assembly_resolver;

		public IAssemblyResolver AssemblyResolver {
			get { return assembly_resolver; }
		}

		public MetadataResolver (IAssemblyResolver assemblyResolver)
		{
			if (assemblyResolver == null)
				throw new ArgumentNullException ("assemblyResolver");

			assembly_resolver = assemblyResolver;
		}

		public virtual TypeDefinition Resolve (TypeReference type)
		{
			Mixin.CheckType (type);

			type = type.GetElementType ();

			var scope = type.Scope;

			if (scope == null)
				return null;

			switch (scope.MetadataScopeType) {
			case MetadataScopeType.AssemblyNameReference:
				var assembly = assembly_resolver.Resolve ((AssemblyNameReference)scope);
				if (assembly == null)
					return null;

				return GetType (assembly.MainModule, type);
			case MetadataScopeType.ModuleDefinition:
				return GetType ((ModuleDefinition)scope, type);
			case MetadataScopeType.ModuleReference:
				if (type.Module.Assembly == null)
					return null;

				var modules = type.Module.Assembly.Modules;
				var module_ref = (ModuleReference)scope;
				for (int i = 0; i < modules.Count; i++) {
					var netmodule = modules [i];
					if (netmodule.Name == module_ref.Name)
						return GetType (netmodule, type);
				}
				break;
			}

			throw new NotSupportedException ();
		}

		static TypeDefinition GetType (ModuleDefinition module, TypeReference reference)
		{
			var type = GetTypeDefinition (module, reference);
			if (type != null)
				return type;

			if (!module.HasExportedTypes)
				return null;

			var exported_types = module.ExportedTypes;

			for (int i = 0; i < exported_types.Count; i++) {
				var exported_type = exported_types [i];
				if (exported_type.Name != reference.Name)
					continue;

				if (exported_type.Namespace != reference.Namespace)
					continue;

				return exported_type.Resolve ();
			}

			return null;
		}

		static TypeDefinition GetTypeDefinition (ModuleDefinition module, TypeReference type)
		{
			if (!type.IsNested)
				return module.GetType (type.Namespace, type.Name);

			var declaring_type = type.DeclaringType.Resolve ();
			if (declaring_type == null)
				return null;

			return declaring_type.GetNestedType (type.TypeFullName ());
		}

		public virtual FieldDefinition Resolve (FieldReference field)
		{
			Mixin.CheckField (field);

			var type = Resolve (field.DeclaringType);
			if (type == null)
				return null;

			if (!type.HasFields)
				return null;

			return GetField (type, field);
		}

		FieldDefinition GetField (TypeDefinition type, FieldReference reference)
		{
			while (type != null) {
				var field = GetField (type.Fields, reference);
				if (field != null)
					return field;

				if (type.BaseType == null)
					return null;

				type = Resolve (type.BaseType);
			}

			return null;
		}

		static FieldDefinition GetField (Collection<FieldDefinition> fields, FieldReference reference)
		{
			for (int i = 0; i < fields.Count; i++) {
				var field = fields [i];

				if (field.Name != reference.Name)
					continue;

				if (!AreSame (field.FieldType, reference.FieldType))
					continue;

				return field;
			}

			return null;
		}

		public virtual MethodDefinition Resolve (MethodReference method)
		{
			Mixin.CheckMethod (method);

			var type = Resolve (method.DeclaringType);
			if (type == null)
				return null;

			method = method.GetElementMethod ();

			if (!type.HasMethods)
				return null;

			return GetMethod (type, method);
		}

		MethodDefinition GetMethod (TypeDefinition type, MethodReference reference)
		{
			while (type != null) {
				var method = GetMethod (type.Methods, reference);
				if (method != null)
					return method;

				if (type.BaseType == null)
					return null;

				type = Resolve (type.BaseType);
			}

			return null;
		}

		public static MethodDefinition GetMethod (Collection<MethodDefinition> methods, MethodReference reference)
		{
			for (int i = 0; i < methods.Count; i++) {
				var method = methods [i];

				if (method.Name != reference.Name)
					continue;

				if (method.HasGenericParameters != reference.HasGenericParameters)
					continue;

				if (method.HasGenericParameters && method.GenericParameters.Count != reference.GenericParameters.Count)
					continue;

				if (!AreSame (method.ReturnType, reference.ReturnType))
					continue;

				if (method.IsVarArg () != reference.IsVarArg ())
					continue;

				if (method.IsVarArg () && IsVarArgCallTo (method, reference))
					return method;

				if (method.HasParameters != reference.HasParameters)
					continue;

				if (!method.HasParameters && !reference.HasParameters)
					return method;

				if (!AreSame (method.Parameters, reference.Parameters))
					continue;

				return method;
			}

			return null;
		}

		static bool AreSame (Collection<ParameterDefinition> a, Collection<ParameterDefinition> b)
		{
			var count = a.Count;

			if (count != b.Count)
				return false;

			if (count == 0)
				return true;

			for (int i = 0; i < count; i++)
				if (!AreSame (a [i].ParameterType, b [i].ParameterType))
					return false;

			return true;
		}

		static bool IsVarArgCallTo (MethodDefinition method, MethodReference reference)
		{
			if (method.Parameters.Count >= reference.Parameters.Count)
				return false;

			if (reference.GetSentinelPosition () != method.Parameters.Count)
				return false;

			for (int i = 0; i < method.Parameters.Count; i++)
				if (!AreSame (method.Parameters [i].ParameterType, reference.Parameters [i].ParameterType))
					return false;

			return true;
		}

		static bool AreSame (TypeSpecification a, TypeSpecification b)
		{
			if (!AreSame (a.ElementType, b.ElementType))
				return false;

			if (a.IsGenericInstance)
				return AreSame ((GenericInstanceType)a, (GenericInstanceType)b);

			if (a.IsRequiredModifier || a.IsOptionalModifier)
				return AreSame ((IModifierType)a, (IModifierType)b);

			if (a.IsArray)
				return AreSame ((ArrayType)a, (ArrayType)b);

			return true;
		}

		static bool AreSame (ArrayType a, ArrayType b)
		{
			if (a.Rank != b.Rank)
				return false;

			// TODO: dimensions

			return true;
		}

		static bool AreSame (IModifierType a, IModifierType b)
		{
			return AreSame (a.ModifierType, b.ModifierType);
		}

		static bool AreSame (GenericInstanceType a, GenericInstanceType b)
		{
			if (a.GenericArguments.Count != b.GenericArguments.Count)
				return false;

			for (int i = 0; i < a.GenericArguments.Count; i++)
				if (!AreSame (a.GenericArguments [i], b.GenericArguments [i]))
					return false;

			return true;
		}

		static bool AreSame (GenericParameter a, GenericParameter b)
		{
			return a.Position == b.Position;
		}

		static bool AreSame (TypeReference a, TypeReference b)
		{
			if (ReferenceEquals (a, b))
				return true;

			if (a == null || b == null)
				return false;

			if (a.etype != b.etype)
				return false;

			if (a.IsGenericParameter)
				return AreSame ((GenericParameter)a, (GenericParameter)b);

			if (a.IsTypeSpecification ())
				return AreSame ((TypeSpecification)a, (TypeSpecification)b);

			if (a.Name != b.Name || a.Namespace != b.Namespace)
				return false;

			return AreSame (a.DeclaringType, b.DeclaringType);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MetadataSystem.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Metadata;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using System.Threading;

namespace MonoFN.Cecil {

	struct Range {
		public uint Start;
		public uint Length;

		public Range (uint index, uint length)
		{
			this.Start = index;
			this.Length = length;
		}
	}

	sealed class MetadataSystem {

		internal AssemblyNameReference [] AssemblyReferences;
		internal ModuleReference [] ModuleReferences;

		internal TypeDefinition [] Types;
		internal TypeReference [] TypeReferences;

		internal FieldDefinition [] Fields;
		internal MethodDefinition [] Methods;
		internal MemberReference [] MemberReferences;

		internal Dictionary<uint, Collection<uint>> NestedTypes;
		internal Dictionary<uint, uint> ReverseNestedTypes;
		internal Dictionary<uint, Collection<Row<uint, MetadataToken>>> Interfaces;
		internal Dictionary<uint, Row<ushort, uint>> ClassLayouts;
		internal Dictionary<uint, uint> FieldLayouts;
		internal Dictionary<uint, uint> FieldRVAs;
		internal Dictionary<MetadataToken, uint> FieldMarshals;
		internal Dictionary<MetadataToken, Row<ElementType, uint>> Constants;
		internal Dictionary<uint, Collection<MetadataToken>> Overrides;
		internal Dictionary<MetadataToken, Range []> CustomAttributes;
		internal Dictionary<MetadataToken, Range []> SecurityDeclarations;
		internal Dictionary<uint, Range> Events;
		internal Dictionary<uint, Range> Properties;
		internal Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> Semantics;
		internal Dictionary<uint, Row<PInvokeAttributes, uint, uint>> PInvokes;
		internal Dictionary<MetadataToken, Range []> GenericParameters;
		internal Dictionary<uint, Collection<Row<uint, MetadataToken>>> GenericConstraints;

		internal Document [] Documents;
		internal Dictionary<uint, Collection<Row<uint, Range, Range, uint, uint, uint>>> LocalScopes;
		internal ImportDebugInformation [] ImportScopes;
		internal Dictionary<uint, uint> StateMachineMethods;
		internal Dictionary<MetadataToken, Row<Guid, uint, uint> []> CustomDebugInformations;

		static Dictionary<string, Row<ElementType, bool>> primitive_value_types;

		static void InitializePrimitives ()
		{
			var types = new Dictionary<string, Row<ElementType, bool>> (18, StringComparer.Ordinal) {
				{ "Void", new Row<ElementType, bool> (ElementType.Void, false) },
				{ "Boolean", new Row<ElementType, bool> (ElementType.Boolean, true) },
				{ "Char", new Row<ElementType, bool> (ElementType.Char, true) },
				{ "SByte", new Row<ElementType, bool> (ElementType.I1, true) },
				{ "Byte", new Row<ElementType, bool> (ElementType.U1, true) },
				{ "Int16", new Row<ElementType, bool> (ElementType.I2, true) },
				{ "UInt16", new Row<ElementType, bool> (ElementType.U2, true) },
				{ "Int32", new Row<ElementType, bool> (ElementType.I4, true) },
				{ "UInt32", new Row<ElementType, bool> (ElementType.U4, true) },
				{ "Int64", new Row<ElementType, bool> (ElementType.I8, true) },
				{ "UInt64", new Row<ElementType, bool> (ElementType.U8, true) },
				{ "Single", new Row<ElementType, bool> (ElementType.R4, true) },
				{ "Double", new Row<ElementType, bool> (ElementType.R8, true) },
				{ "String", new Row<ElementType, bool> (ElementType.String, false) },
				{ "TypedReference", new Row<ElementType, bool> (ElementType.TypedByRef, false) },
				{ "IntPtr", new Row<ElementType, bool> (ElementType.I, true) },
				{ "UIntPtr", new Row<ElementType, bool> (ElementType.U, true) },
				{ "Object", new Row<ElementType, bool> (ElementType.Object, false) },
			};

			Interlocked.CompareExchange (ref primitive_value_types, types, null);
		}

		public static void TryProcessPrimitiveTypeReference (TypeReference type)
		{
			if (type.Namespace != "System")
				return;

			var scope = type.scope;
			if (scope == null || scope.MetadataScopeType != MetadataScopeType.AssemblyNameReference)
				return;

			Row<ElementType, bool> primitive_data;
			if (!TryGetPrimitiveData (type, out primitive_data))
				return;

			type.etype = primitive_data.Col1;
			type.IsValueType = primitive_data.Col2;
		}

		public static bool TryGetPrimitiveElementType (TypeDefinition type, out ElementType etype)
		{
			etype = ElementType.None;

			if (type.Namespace != "System")
				return false;

			Row<ElementType, bool> primitive_data;
			if (TryGetPrimitiveData (type, out primitive_data)) {
				etype = primitive_data.Col1;
				return true;
			}

			return false;
		}

		static bool TryGetPrimitiveData (TypeReference type, out Row<ElementType, bool> primitive_data)
		{
			if (primitive_value_types == null)
				InitializePrimitives ();

			return primitive_value_types.TryGetValue (type.Name, out primitive_data);
		}

		public void Clear ()
		{
			if (NestedTypes != null) NestedTypes = new Dictionary<uint, Collection<uint>> (capacity: 0);
			if (ReverseNestedTypes != null) ReverseNestedTypes = new Dictionary<uint, uint> (capacity: 0);
			if (Interfaces != null) Interfaces = new Dictionary<uint, Collection<Row<uint, MetadataToken>>> (capacity: 0);
			if (ClassLayouts != null) ClassLayouts = new Dictionary<uint, Row<ushort, uint>> (capacity: 0);
			if (FieldLayouts != null) FieldLayouts = new Dictionary<uint, uint> (capacity: 0);
			if (FieldRVAs != null) FieldRVAs = new Dictionary<uint, uint> (capacity: 0);
			if (FieldMarshals != null) FieldMarshals = new Dictionary<MetadataToken, uint> (capacity: 0);
			if (Constants != null) Constants = new Dictionary<MetadataToken, Row<ElementType, uint>> (capacity: 0);
			if (Overrides != null) Overrides = new Dictionary<uint, Collection<MetadataToken>> (capacity: 0);
			if (CustomAttributes != null) CustomAttributes = new Dictionary<MetadataToken, Range []> (capacity: 0);
			if (SecurityDeclarations != null) SecurityDeclarations = new Dictionary<MetadataToken, Range []> (capacity: 0);
			if (Events != null) Events = new Dictionary<uint, Range> (capacity: 0);
			if (Properties != null) Properties = new Dictionary<uint, Range> (capacity: 0);
			if (Semantics != null) Semantics = new Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> (capacity: 0);
			if (PInvokes != null) PInvokes = new Dictionary<uint, Row<PInvokeAttributes, uint, uint>> (capacity: 0);
			if (GenericParameters != null) GenericParameters = new Dictionary<MetadataToken, Range []> (capacity: 0);
			if (GenericConstraints != null) GenericConstraints = new Dictionary<uint, Collection<Row<uint, MetadataToken>>> (capacity: 0);

			Documents = Empty<Document>.Array;
			ImportScopes = Empty<ImportDebugInformation>.Array;
			if (LocalScopes != null) LocalScopes = new Dictionary<uint, Collection<Row<uint, Range, Range, uint, uint, uint>>> (capacity: 0);
			if (StateMachineMethods != null) StateMachineMethods = new Dictionary<uint, uint> (capacity: 0);
		}

		public AssemblyNameReference GetAssemblyNameReference (uint rid)
		{
			if (rid < 1 || rid > AssemblyReferences.Length)
				return null;

			return AssemblyReferences [rid - 1];
		}

		public TypeDefinition GetTypeDefinition (uint rid)
		{
			if (rid < 1 || rid > Types.Length)
				return null;

			return Types [rid - 1];
		}

		public void AddTypeDefinition (TypeDefinition type)
		{
			Types [type.token.RID - 1] = type;
		}

		public TypeReference GetTypeReference (uint rid)
		{
			if (rid < 1 || rid > TypeReferences.Length)
				return null;

			return TypeReferences [rid - 1];
		}

		public void AddTypeReference (TypeReference type)
		{
			TypeReferences [type.token.RID - 1] = type;
		}

		public FieldDefinition GetFieldDefinition (uint rid)
		{
			if (rid < 1 || rid > Fields.Length)
				return null;

			return Fields [rid - 1];
		}

		public void AddFieldDefinition (FieldDefinition field)
		{
			Fields [field.token.RID - 1] = field;
		}

		public MethodDefinition GetMethodDefinition (uint rid)
		{
			if (rid < 1 || rid > Methods.Length)
				return null;

			return Methods [rid - 1];
		}

		public void AddMethodDefinition (MethodDefinition method)
		{
			Methods [method.token.RID - 1] = method;
		}

		public MemberReference GetMemberReference (uint rid)
		{
			if (rid < 1 || rid > MemberReferences.Length)
				return null;

			return MemberReferences [rid - 1];
		}

		public void AddMemberReference (MemberReference member)
		{
			MemberReferences [member.token.RID - 1] = member;
		}

		public bool TryGetNestedTypeMapping (TypeDefinition type, out Collection<uint> mapping)
		{
			return NestedTypes.TryGetValue (type.token.RID, out mapping);
		}

		public void SetNestedTypeMapping (uint type_rid, Collection<uint> mapping)
		{
			NestedTypes [type_rid] = mapping;
		}

		public void RemoveNestedTypeMapping (TypeDefinition type)
		{
			NestedTypes.Remove (type.token.RID);
		}

		public bool TryGetReverseNestedTypeMapping (TypeDefinition type, out uint declaring)
		{
			return ReverseNestedTypes.TryGetValue (type.token.RID, out declaring);
		}

		public void SetReverseNestedTypeMapping (uint nested, uint declaring)
		{
			ReverseNestedTypes [nested] = declaring;
		}

		public void RemoveReverseNestedTypeMapping (TypeDefinition type)
		{
			ReverseNestedTypes.Remove (type.token.RID);
		}

		public bool TryGetInterfaceMapping (TypeDefinition type, out Collection<Row<uint, MetadataToken>> mapping)
		{
			return Interfaces.TryGetValue (type.token.RID, out mapping);
		}

		public void SetInterfaceMapping (uint type_rid, Collection<Row<uint, MetadataToken>> mapping)
		{
			Interfaces [type_rid] = mapping;
		}

		public void RemoveInterfaceMapping (TypeDefinition type)
		{
			Interfaces.Remove (type.token.RID);
		}

		public void AddPropertiesRange (uint type_rid, Range range)
		{
			Properties.Add (type_rid, range);
		}

		public bool TryGetPropertiesRange (TypeDefinition type, out Range range)
		{
			return Properties.TryGetValue (type.token.RID, out range);
		}

		public void RemovePropertiesRange (TypeDefinition type)
		{
			Properties.Remove (type.token.RID);
		}

		public void AddEventsRange (uint type_rid, Range range)
		{
			Events.Add (type_rid, range);
		}

		public bool TryGetEventsRange (TypeDefinition type, out Range range)
		{
			return Events.TryGetValue (type.token.RID, out range);
		}

		public void RemoveEventsRange (TypeDefinition type)
		{
			Events.Remove (type.token.RID);
		}

		public bool TryGetGenericParameterRanges (IGenericParameterProvider owner, out Range [] ranges)
		{
			return GenericParameters.TryGetValue (owner.MetadataToken, out ranges);
		}

		public void RemoveGenericParameterRange (IGenericParameterProvider owner)
		{
			GenericParameters.Remove (owner.MetadataToken);
		}

		public bool TryGetCustomAttributeRanges (ICustomAttributeProvider owner, out Range [] ranges)
		{
			return CustomAttributes.TryGetValue (owner.MetadataToken, out ranges);
		}

		public void RemoveCustomAttributeRange (ICustomAttributeProvider owner)
		{
			CustomAttributes.Remove (owner.MetadataToken);
		}

		public bool TryGetSecurityDeclarationRanges (ISecurityDeclarationProvider owner, out Range [] ranges)
		{
			return SecurityDeclarations.TryGetValue (owner.MetadataToken, out ranges);
		}

		public void RemoveSecurityDeclarationRange (ISecurityDeclarationProvider owner)
		{
			SecurityDeclarations.Remove (owner.MetadataToken);
		}

		public bool TryGetGenericConstraintMapping (GenericParameter generic_parameter, out Collection<Row<uint, MetadataToken>> mapping)
		{
			return GenericConstraints.TryGetValue (generic_parameter.token.RID, out mapping);
		}

		public void SetGenericConstraintMapping (uint gp_rid, Collection<Row<uint, MetadataToken>> mapping)
		{
			GenericConstraints [gp_rid] = mapping;
		}

		public void RemoveGenericConstraintMapping (GenericParameter generic_parameter)
		{
			GenericConstraints.Remove (generic_parameter.token.RID);
		}

		public bool TryGetOverrideMapping (MethodDefinition method, out Collection<MetadataToken> mapping)
		{
			return Overrides.TryGetValue (method.token.RID, out mapping);
		}

		public void SetOverrideMapping (uint rid, Collection<MetadataToken> mapping)
		{
			Overrides [rid] = mapping;
		}

		public void RemoveOverrideMapping (MethodDefinition method)
		{
			Overrides.Remove (method.token.RID);
		}

		public Document GetDocument (uint rid)
		{
			if (rid < 1 || rid > Documents.Length)
				return null;

			return Documents [rid - 1];
		}

		public bool TryGetLocalScopes (MethodDefinition method, out Collection<Row<uint, Range, Range, uint, uint, uint>> scopes)
		{
			return LocalScopes.TryGetValue (method.MetadataToken.RID, out scopes);
		}

		public void SetLocalScopes (uint method_rid, Collection<Row<uint, Range, Range, uint, uint, uint>> records)
		{
			LocalScopes [method_rid] = records;
		}

		public ImportDebugInformation GetImportScope (uint rid)
		{
			if (rid < 1 || rid > ImportScopes.Length)
				return null;

			return ImportScopes [rid - 1];
		}

		public bool TryGetStateMachineKickOffMethod (MethodDefinition method, out uint rid)
		{
			return StateMachineMethods.TryGetValue (method.MetadataToken.RID, out rid);
		}

		public TypeDefinition GetFieldDeclaringType (uint field_rid)
		{
			return BinaryRangeSearch (Types, field_rid, true);
		}

		public TypeDefinition GetMethodDeclaringType (uint method_rid)
		{
			return BinaryRangeSearch (Types, method_rid, false);
		}

		static TypeDefinition BinaryRangeSearch (TypeDefinition [] types, uint rid, bool field)
		{
			int min = 0;
			int max = types.Length - 1;
			while (min <= max) {
				int mid = min + ((max - min) / 2);
				var type = types [mid];
				var range = field ? type.fields_range : type.methods_range;

				if (rid < range.Start)
					max = mid - 1;
				else if (rid >= range.Start + range.Length)
					min = mid + 1;
				else
					return type;
			}

			return null;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum MethodAttributes : ushort {
		MemberAccessMask = 0x0007,
		CompilerControlled = 0x0000,    // Member not referenceable
		Private = 0x0001,   // Accessible only by the parent type
		FamANDAssem = 0x0002,   // Accessible by sub-types only in this Assembly
		Assembly = 0x0003,  // Accessibly by anyone in the Assembly
		Family = 0x0004,    // Accessible only by type and sub-types
		FamORAssem = 0x0005,    // Accessibly by sub-types anywhere, plus anyone in assembly
		Public = 0x0006,    // Accessibly by anyone who has visibility to this scope

		Static = 0x0010,    // Defined on type, else per instance
		Final = 0x0020, // Method may not be overridden
		Virtual = 0x0040,   // Method is virtual
		HideBySig = 0x0080, // Method hides by name+sig, else just by name

		VtableLayoutMask = 0x0100,  // Use this mask to retrieve vtable attributes
		ReuseSlot = 0x0000, // Method reuses existing slot in vtable
		NewSlot = 0x0100,   // Method always gets a new slot in the vtable

		CheckAccessOnOverride = 0x0200,   // Method can only be overriden if also accessible
		Abstract = 0x0400,  // Method does not provide an implementation
		SpecialName = 0x0800,   // Method is special

		// Interop Attributes
		PInvokeImpl = 0x2000,   // Implementation is forwarded through PInvoke
		UnmanagedExport = 0x0008,   // Reserved: shall be zero for conforming implementations

		// Additional flags
		RTSpecialName = 0x1000, // CLI provides 'special' behavior, depending upon the name of the method
		HasSecurity = 0x4000,   // Method has security associate with it
		RequireSecObject = 0x8000    // Method calls another method containing security code
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodCallingConvention.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public enum MethodCallingConvention : byte {
		Default = 0x0,
		C = 0x1,
		StdCall = 0x2,
		ThisCall = 0x3,
		FastCall = 0x4,
		VarArg = 0x5,
		Generic = 0x10,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Collections.Generic;
using System;
using System.Threading;
using RVA = System.UInt32;

namespace MonoFN.Cecil {

	public sealed class MethodDefinition : MethodReference, IMemberDefinition, ISecurityDeclarationProvider, ICustomDebugInformationProvider {

		ushort attributes;
		ushort impl_attributes;
		internal volatile bool sem_attrs_ready;
		internal MethodSemanticsAttributes sem_attrs;
		Collection<CustomAttribute> custom_attributes;
		Collection<SecurityDeclaration> security_declarations;

		internal RVA rva;
		internal PInvokeInfo pinvoke;
		Collection<MethodReference> overrides;

		internal MethodBody body;
		internal MethodDebugInformation debug_info;
		internal Collection<CustomDebugInformation> custom_infos;

		public override string Name {
			get { return base.Name; }
			set {
				if (IsWindowsRuntimeProjection && value != base.Name)
					throw new InvalidOperationException ();

				base.Name = value;
			}
		}

		public MethodAttributes Attributes {
			get { return (MethodAttributes)attributes; }
			set {
				if (IsWindowsRuntimeProjection && (ushort)value != attributes)
					throw new InvalidOperationException ();

				attributes = (ushort)value;
			}
		}

		public MethodImplAttributes ImplAttributes {
			get { return (MethodImplAttributes)impl_attributes; }
			set {
				if (IsWindowsRuntimeProjection && (ushort)value != impl_attributes)
					throw new InvalidOperationException ();

				impl_attributes = (ushort)value;
			}
		}

		public MethodSemanticsAttributes SemanticsAttributes {
			get {
				if (sem_attrs_ready)
					return sem_attrs;

				if (HasImage) {
					ReadSemantics ();
					return sem_attrs;
				}

				sem_attrs = MethodSemanticsAttributes.None;
				sem_attrs_ready = true;
				return sem_attrs;
			}
			set { sem_attrs = value; }
		}

		internal MethodDefinitionProjection WindowsRuntimeProjection {
			get { return (MethodDefinitionProjection)projection; }
			set { projection = value; }
		}

		internal void ReadSemantics ()
		{
			if (sem_attrs_ready)
				return;

			var module = this.Module;
			if (module == null)
				return;

			if (!module.HasImage)
				return;

			lock (module.SyncRoot) {
				if (sem_attrs_ready)
					return;

				module.Read (this, (method, reader) => reader.ReadAllSemantics (method));
			}
		}

		public bool HasSecurityDeclarations {
			get {
				if (security_declarations != null)
					return security_declarations.Count > 0;

				return this.GetHasSecurityDeclarations (Module);
			}
		}

		public Collection<SecurityDeclaration> SecurityDeclarations {
			get { return security_declarations ?? (this.GetSecurityDeclarations (ref security_declarations, Module)); }
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, Module)); }
		}

		public int RVA {
			get { return (int)rva; }
		}

		public bool HasBody {
			get {
				return (attributes & (ushort)MethodAttributes.Abstract) == 0 &&
					(attributes & (ushort)MethodAttributes.PInvokeImpl) == 0 &&
					(impl_attributes & (ushort)MethodImplAttributes.InternalCall) == 0 &&
					(impl_attributes & (ushort)MethodImplAttributes.Native) == 0 &&
					(impl_attributes & (ushort)MethodImplAttributes.Unmanaged) == 0 &&
					(impl_attributes & (ushort)MethodImplAttributes.Runtime) == 0;
			}
		}

		public MethodBody Body {
			get {
				var local = this.body;
				if (local != null)
					return local;

				if (!HasBody)
					return null;

				if (HasImage && rva != 0)
					return Module.Read (ref body, this, (method, reader) => reader.ReadMethodBody (method));

				Interlocked.CompareExchange (ref body, new MethodBody (this), null);

				return body;
			}
			set {
				var module = this.Module;
				if (module == null) {
					body = value;
					return;
				}

				// we reset Body to null in ILSpy to save memory; so we need that operation to be thread-safe
				lock (module.SyncRoot) {
					body = value;
					if (value == null)
						this.debug_info = null;
				}
			}
		}

		public MethodDebugInformation DebugInformation {
			get {
				Mixin.Read (Body);

				if (debug_info == null) {
					Interlocked.CompareExchange (ref debug_info, new MethodDebugInformation (this), null);
				}

				return debug_info;
			}
			set {
				debug_info = value;
			}
		}

		public bool HasPInvokeInfo {
			get {
				if (pinvoke != null)
					return true;

				return IsPInvokeImpl;
			}
		}

		public PInvokeInfo PInvokeInfo {
			get {
				if (pinvoke != null)
					return pinvoke;

				if (HasImage && IsPInvokeImpl)
					return Module.Read (ref pinvoke, this, (method, reader) => reader.ReadPInvokeInfo (method));

				return null;
			}
			set {
				IsPInvokeImpl = true;
				pinvoke = value;
			}
		}

		public bool HasOverrides {
			get {
				if (overrides != null)
					return overrides.Count > 0;

				return HasImage && Module.Read (this, (method, reader) => reader.HasOverrides (method));
			}
		}

		public Collection<MethodReference> Overrides {
			get {
				if (overrides != null)
					return overrides;

				if (HasImage)
					return Module.Read (ref overrides, this, (method, reader) => reader.ReadOverrides (method));

				Interlocked.CompareExchange (ref overrides, new Collection<MethodReference> (), null);

				return overrides;
			}
		}

		public override bool HasGenericParameters {
			get {
				if (generic_parameters != null)
					return generic_parameters.Count > 0;

				return this.GetHasGenericParameters (Module);
			}
		}

		public override Collection<GenericParameter> GenericParameters {
			get { return generic_parameters ?? (this.GetGenericParameters (ref generic_parameters, Module)); }
		}

		public bool HasCustomDebugInformations {
			get {
				Mixin.Read (Body);

				return !custom_infos.IsNullOrEmpty ();
			}
		}

		public Collection<CustomDebugInformation> CustomDebugInformations {
			get {
				Mixin.Read (Body);

				if (custom_infos == null)
					Interlocked.CompareExchange (ref custom_infos, new Collection<CustomDebugInformation> (), null);

				return custom_infos;
			}
		}

		#region MethodAttributes

		public bool IsCompilerControlled {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.CompilerControlled); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.CompilerControlled, value); }
		}

		public bool IsPrivate {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Private); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Private, value); }
		}

		public bool IsFamilyAndAssembly {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.FamANDAssem); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.FamANDAssem, value); }
		}

		public bool IsAssembly {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Assembly); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Assembly, value); }
		}

		public bool IsFamily {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Family); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Family, value); }
		}

		public bool IsFamilyOrAssembly {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.FamORAssem); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.FamORAssem, value); }
		}

		public bool IsPublic {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.MemberAccessMask, (ushort)MethodAttributes.Public, value); }
		}

		public bool IsStatic {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.Static); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.Static, value); }
		}

		public bool IsFinal {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.Final); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.Final, value); }
		}

		public bool IsVirtual {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.Virtual); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.Virtual, value); }
		}

		public bool IsHideBySig {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.HideBySig); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.HideBySig, value); }
		}

		public bool IsReuseSlot {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.VtableLayoutMask, (ushort)MethodAttributes.ReuseSlot); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.VtableLayoutMask, (ushort)MethodAttributes.ReuseSlot, value); }
		}

		public bool IsNewSlot {
			get { return attributes.GetMaskedAttributes ((ushort)MethodAttributes.VtableLayoutMask, (ushort)MethodAttributes.NewSlot); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)MethodAttributes.VtableLayoutMask, (ushort)MethodAttributes.NewSlot, value); }
		}

		public bool IsCheckAccessOnOverride {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.CheckAccessOnOverride); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.CheckAccessOnOverride, value); }
		}

		public bool IsAbstract {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.Abstract); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.Abstract, value); }
		}

		public bool IsSpecialName {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.SpecialName, value); }
		}

		public bool IsPInvokeImpl {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.PInvokeImpl); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.PInvokeImpl, value); }
		}

		public bool IsUnmanagedExport {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.UnmanagedExport); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.UnmanagedExport, value); }
		}

		public bool IsRuntimeSpecialName {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.RTSpecialName, value); }
		}

		public bool HasSecurity {
			get { return attributes.GetAttributes ((ushort)MethodAttributes.HasSecurity); }
			set { attributes = attributes.SetAttributes ((ushort)MethodAttributes.HasSecurity, value); }
		}

		#endregion

		#region MethodImplAttributes

		public bool IsIL {
			get { return impl_attributes.GetMaskedAttributes ((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.IL); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes ((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.IL, value); }
		}

		public bool IsNative {
			get { return impl_attributes.GetMaskedAttributes ((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.Native); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes ((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.Native, value); }
		}

		public bool IsRuntime {
			get { return impl_attributes.GetMaskedAttributes ((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.Runtime); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes ((ushort)MethodImplAttributes.CodeTypeMask, (ushort)MethodImplAttributes.Runtime, value); }
		}

		public bool IsUnmanaged {
			get { return impl_attributes.GetMaskedAttributes ((ushort)MethodImplAttributes.ManagedMask, (ushort)MethodImplAttributes.Unmanaged); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes ((ushort)MethodImplAttributes.ManagedMask, (ushort)MethodImplAttributes.Unmanaged, value); }
		}

		public bool IsManaged {
			get { return impl_attributes.GetMaskedAttributes ((ushort)MethodImplAttributes.ManagedMask, (ushort)MethodImplAttributes.Managed); }
			set { impl_attributes = impl_attributes.SetMaskedAttributes ((ushort)MethodImplAttributes.ManagedMask, (ushort)MethodImplAttributes.Managed, value); }
		}

		public bool IsForwardRef {
			get { return impl_attributes.GetAttributes ((ushort)MethodImplAttributes.ForwardRef); }
			set { impl_attributes = impl_attributes.SetAttributes ((ushort)MethodImplAttributes.ForwardRef, value); }
		}

		public bool IsPreserveSig {
			get { return impl_attributes.GetAttributes ((ushort)MethodImplAttributes.PreserveSig); }
			set { impl_attributes = impl_attributes.SetAttributes ((ushort)MethodImplAttributes.PreserveSig, value); }
		}

		public bool IsInternalCall {
			get { return impl_attributes.GetAttributes ((ushort)MethodImplAttributes.InternalCall); }
			set { impl_attributes = impl_attributes.SetAttributes ((ushort)MethodImplAttributes.InternalCall, value); }
		}

		public bool IsSynchronized {
			get { return impl_attributes.GetAttributes ((ushort)MethodImplAttributes.Synchronized); }
			set { impl_attributes = impl_attributes.SetAttributes ((ushort)MethodImplAttributes.Synchronized, value); }
		}

		public bool NoInlining {
			get { return impl_attributes.GetAttributes ((ushort)MethodImplAttributes.NoInlining); }
			set { impl_attributes = impl_attributes.SetAttributes ((ushort)MethodImplAttributes.NoInlining, value); }
		}

		public bool NoOptimization {
			get { return impl_attributes.GetAttributes ((ushort)MethodImplAttributes.NoOptimization); }
			set { impl_attributes = impl_attributes.SetAttributes ((ushort)MethodImplAttributes.NoOptimization, value); }
		}

		public bool AggressiveInlining {
			get { return impl_attributes.GetAttributes ((ushort)MethodImplAttributes.AggressiveInlining); }
			set { impl_attributes = impl_attributes.SetAttributes ((ushort)MethodImplAttributes.AggressiveInlining, value); }
		}

		#endregion

		#region MethodSemanticsAttributes

		public bool IsSetter {
			get { return this.GetSemantics (MethodSemanticsAttributes.Setter); }
			set { this.SetSemantics (MethodSemanticsAttributes.Setter, value); }
		}

		public bool IsGetter {
			get { return this.GetSemantics (MethodSemanticsAttributes.Getter); }
			set { this.SetSemantics (MethodSemanticsAttributes.Getter, value); }
		}

		public bool IsOther {
			get { return this.GetSemantics (MethodSemanticsAttributes.Other); }
			set { this.SetSemantics (MethodSemanticsAttributes.Other, value); }
		}

		public bool IsAddOn {
			get { return this.GetSemantics (MethodSemanticsAttributes.AddOn); }
			set { this.SetSemantics (MethodSemanticsAttributes.AddOn, value); }
		}

		public bool IsRemoveOn {
			get { return this.GetSemantics (MethodSemanticsAttributes.RemoveOn); }
			set { this.SetSemantics (MethodSemanticsAttributes.RemoveOn, value); }
		}

		public bool IsFire {
			get { return this.GetSemantics (MethodSemanticsAttributes.Fire); }
			set { this.SetSemantics (MethodSemanticsAttributes.Fire, value); }
		}

		#endregion

		public new TypeDefinition DeclaringType {
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		public bool IsConstructor {
			get {
				return this.IsRuntimeSpecialName
					&& this.IsSpecialName
					&& (this.Name == ".cctor" || this.Name == ".ctor");
			}
		}

		public override bool IsDefinition {
			get { return true; }
		}

		internal MethodDefinition ()
		{
			this.token = new MetadataToken (TokenType.Method);
		}

		public MethodDefinition (string name, MethodAttributes attributes, TypeReference returnType)
			: base (name, returnType)
		{
			this.attributes = (ushort)attributes;
			this.HasThis = !this.IsStatic;
			this.token = new MetadataToken (TokenType.Method);
		}

		public override MethodDefinition Resolve ()
		{
			return this;
		}
	}

	static partial class Mixin {

		public static ParameterDefinition GetParameter (this MethodBody self, int index)
		{
			var method = self.method;

			if (method.HasThis) {
				if (index == 0)
					return self.ThisParameter;

				index--;
			}

			var parameters = method.Parameters;

			if (index < 0 || index >= parameters.size)
				return null;

			return parameters [index];
		}

		public static VariableDefinition GetVariable (this MethodBody self, int index)
		{
			var variables = self.Variables;

			if (index < 0 || index >= variables.size)
				return null;

			return variables [index];
		}

		public static bool GetSemantics (this MethodDefinition self, MethodSemanticsAttributes semantics)
		{
			return (self.SemanticsAttributes & semantics) != 0;
		}

		public static void SetSemantics (this MethodDefinition self, MethodSemanticsAttributes semantics, bool value)
		{
			if (value)
				self.SemanticsAttributes |= semantics;
			else
				self.SemanticsAttributes &= ~semantics;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodImplAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum MethodImplAttributes : ushort {
		CodeTypeMask = 0x0003,
		IL = 0x0000,    // Method impl is CIL
		Native = 0x0001,    // Method impl is native
		OPTIL = 0x0002, // Reserved: shall be zero in conforming implementations
		Runtime = 0x0003,   // Method impl is provided by the runtime

		ManagedMask = 0x0004,   // Flags specifying whether the code is managed or unmanaged
		Unmanaged = 0x0004, // Method impl is unmanaged, otherwise managed
		Managed = 0x0000,   // Method impl is managed

		// Implementation info and interop
		ForwardRef = 0x0010,    // Indicates method is defined; used primarily in merge scenarios
		PreserveSig = 0x0080,   // Reserved: conforming implementations may ignore
		InternalCall = 0x1000,  // Reserved: shall be zero in conforming implementations
		Synchronized = 0x0020,  // Method is single threaded through the body
		NoOptimization = 0x0040,    // Method is not optimized by the JIT.
		NoInlining = 0x0008,    // Method may not be inlined
		AggressiveInlining = 0x0100,   // Method should be inlined, if possible.
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Text;
using System.Threading;

namespace MonoFN.Cecil {

	public class MethodReference : MemberReference, IMethodSignature, IGenericParameterProvider, IGenericContext {

		internal ParameterDefinitionCollection parameters;
		MethodReturnType return_type;

		bool has_this;
		bool explicit_this;
		MethodCallingConvention calling_convention;
		internal Collection<GenericParameter> generic_parameters;

		public virtual bool HasThis {
			get { return has_this; }
			set { has_this = value; }
		}

		public virtual bool ExplicitThis {
			get { return explicit_this; }
			set { explicit_this = value; }
		}

		public virtual MethodCallingConvention CallingConvention {
			get { return calling_convention; }
			set { calling_convention = value; }
		}

		public virtual bool HasParameters {
			get { return !parameters.IsNullOrEmpty (); }
		}

		public virtual Collection<ParameterDefinition> Parameters {
			get {
				if (parameters == null)
					Interlocked.CompareExchange (ref parameters, new ParameterDefinitionCollection (this), null);

				return parameters;
			}
		}

		IGenericParameterProvider IGenericContext.Type {
			get {
				var declaring_type = this.DeclaringType;
				var instance = declaring_type as GenericInstanceType;
				if (instance != null)
					return instance.ElementType;

				return declaring_type;
			}
		}

		IGenericParameterProvider IGenericContext.Method {
			get { return this; }
		}

		GenericParameterType IGenericParameterProvider.GenericParameterType {
			get { return GenericParameterType.Method; }
		}

		public virtual bool HasGenericParameters {
			get { return !generic_parameters.IsNullOrEmpty (); }
		}

		public virtual Collection<GenericParameter> GenericParameters {
			get {
				if (generic_parameters == null)
					Interlocked.CompareExchange (ref generic_parameters, new GenericParameterCollection (this), null);

				return generic_parameters;
			}
		}

		public TypeReference ReturnType {
			get {
				var return_type = MethodReturnType;
				return return_type != null ? return_type.ReturnType : null;
			}
			set {
				var return_type = MethodReturnType;
				if (return_type != null)
					return_type.ReturnType = value;
			}
		}

		public virtual MethodReturnType MethodReturnType {
			get { return return_type; }
			set { return_type = value; }
		}

		public override string FullName {
			get {
				var builder = new StringBuilder ();
				builder.Append (ReturnType.FullName)
					.Append (" ")
					.Append (MemberFullName ());
				this.MethodSignatureFullName (builder);
				return builder.ToString ();
			}
		}

		public virtual bool IsGenericInstance {
			get { return false; }
		}

		public override bool ContainsGenericParameter {
			get {
				if (this.ReturnType.ContainsGenericParameter || base.ContainsGenericParameter)
					return true;

				if (!HasParameters)
					return false;

				var parameters = this.Parameters;

				for (int i = 0; i < parameters.Count; i++)
					if (parameters [i].ParameterType.ContainsGenericParameter)
						return true;

				return false;
			}
		}

		internal MethodReference ()
		{
			this.return_type = new MethodReturnType (this);
			this.token = new MetadataToken (TokenType.MemberRef);
		}

		public MethodReference (string name, TypeReference returnType)
			: base (name)
		{
			Mixin.CheckType (returnType, Mixin.Argument.returnType);

			this.return_type = new MethodReturnType (this);
			this.return_type.ReturnType = returnType;
			this.token = new MetadataToken (TokenType.MemberRef);
		}

		public MethodReference (string name, TypeReference returnType, TypeReference declaringType)
			: this (name, returnType)
		{
			Mixin.CheckType (declaringType, Mixin.Argument.declaringType);

			this.DeclaringType = declaringType;
		}

		public virtual MethodReference GetElementMethod ()
		{
			return this;
		}

		protected override IMemberDefinition ResolveDefinition ()
		{
			return this.Resolve ();
		}

		public new virtual MethodDefinition Resolve ()
		{
			var module = this.Module;
			if (module == null)
				throw new NotSupportedException ();

			return module.Resolve (this);
		}
	}

	static partial class Mixin {

		public static bool IsVarArg (this IMethodSignature self)
		{
			return self.CallingConvention == MethodCallingConvention.VarArg;
		}

		public static int GetSentinelPosition (this IMethodSignature self)
		{
			if (!self.HasParameters)
				return -1;

			var parameters = self.Parameters;
			for (int i = 0; i < parameters.Count; i++)
				if (parameters [i].ParameterType.IsSentinel)
					return i;

			return -1;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodReferenceComparer.cs ---
using System;
using System.Collections.Generic;

namespace MonoFN.Cecil {
	internal sealed class MethodReferenceComparer : EqualityComparer<MethodReference> {
		// Initialized lazily for each thread
		[ThreadStatic]
		static List<MethodReference> xComparisonStack = null;

		[ThreadStatic]
		static List<MethodReference> yComparisonStack = null;

		public override bool Equals (MethodReference x, MethodReference y)
		{
			return AreEqual (x, y);
		}

		public override int GetHashCode (MethodReference obj)
		{
			return GetHashCodeFor (obj);
		}

		public static bool AreEqual (MethodReference x, MethodReference y)
		{
			if (ReferenceEquals (x, y))
				return true;

			if (x.HasThis != y.HasThis)
				return false;

			if (x.HasParameters != y.HasParameters)
				return false;

			if (x.HasGenericParameters != y.HasGenericParameters)
				return false;

			if (x.Parameters.Count != y.Parameters.Count)
				return false;

			if (x.Name != y.Name)
				return false;

			if (!TypeReferenceEqualityComparer.AreEqual (x.DeclaringType, y.DeclaringType))
				return false;

			var xGeneric = x as GenericInstanceMethod;
			var yGeneric = y as GenericInstanceMethod;
			if (xGeneric != null || yGeneric != null) {
				if (xGeneric == null || yGeneric == null)
					return false;

				if (xGeneric.GenericArguments.Count != yGeneric.GenericArguments.Count)
					return false;

				for (int i = 0; i < xGeneric.GenericArguments.Count; i++)
					if (!TypeReferenceEqualityComparer.AreEqual (xGeneric.GenericArguments [i], yGeneric.GenericArguments [i]))
						return false;
			}

			var xResolved = x.Resolve ();
			var yResolved = y.Resolve ();

			if (xResolved != yResolved)
				return false;

			if (xResolved == null) {
				// We couldn't resolve either method. In order for them to be equal, their parameter types _must_ match. But wait, there's a twist!
				// There exists a situation where we might get into a recursive state: parameter type comparison might lead to comparing the same
				// methods again if the parameter types are generic parameters whose owners are these methods. We guard against these by using a
				// thread static list of all our comparisons carried out in the stack so far, and if we're in progress of comparing them already,
				// we'll just say that they match.

				if (xComparisonStack == null)
					xComparisonStack = new List<MethodReference> ();

				if (yComparisonStack == null)
					yComparisonStack = new List<MethodReference> ();

				for (int i = 0; i < xComparisonStack.Count; i++) {
					if (xComparisonStack [i] == x && yComparisonStack [i] == y)
						return true;
				}

				xComparisonStack.Add (x);

				try {
					yComparisonStack.Add (y);

					try {
						for (int i = 0; i < x.Parameters.Count; i++) {
							if (!TypeReferenceEqualityComparer.AreEqual (x.Parameters [i].ParameterType, y.Parameters [i].ParameterType))
								return false;
						}
					}
					finally {
						yComparisonStack.RemoveAt (yComparisonStack.Count - 1);
					}
				}
				finally {
					xComparisonStack.RemoveAt (xComparisonStack.Count - 1);
				}
			}

			return true;
		}

		public static bool AreSignaturesEqual (MethodReference x, MethodReference y, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
		{
			if (x.HasThis != y.HasThis)
				return false;

			if (x.Parameters.Count != y.Parameters.Count)
				return false;

			if (x.GenericParameters.Count != y.GenericParameters.Count)
				return false;

			for (var i = 0; i < x.Parameters.Count; i++)
				if (!TypeReferenceEqualityComparer.AreEqual (x.Parameters [i].ParameterType, y.Parameters [i].ParameterType, comparisonMode))
					return false;

			if (!TypeReferenceEqualityComparer.AreEqual (x.ReturnType, y.ReturnType, comparisonMode))
				return false;

			return true;
		}

		public static int GetHashCodeFor (MethodReference obj)
		{
			// a very good prime number
			const int hashCodeMultiplier = 486187739;

			var genericInstanceMethod = obj as GenericInstanceMethod;
			if (genericInstanceMethod != null) {
				var hashCode = GetHashCodeFor (genericInstanceMethod.ElementMethod);
				for (var i = 0; i < genericInstanceMethod.GenericArguments.Count; i++)
					hashCode = hashCode * hashCodeMultiplier + TypeReferenceEqualityComparer.GetHashCodeFor (genericInstanceMethod.GenericArguments [i]);
				return hashCode;
			}

			return TypeReferenceEqualityComparer.GetHashCodeFor (obj.DeclaringType) * hashCodeMultiplier + obj.Name.GetHashCode ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodReturnType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System.Threading;

namespace MonoFN.Cecil {

	public sealed class MethodReturnType : IConstantProvider, ICustomAttributeProvider, IMarshalInfoProvider {

		internal IMethodSignature method;
		internal ParameterDefinition parameter;
		TypeReference return_type;

		public IMethodSignature Method {
			get { return method; }
		}

		public TypeReference ReturnType {
			get { return return_type; }
			set { return_type = value; }
		}

		internal ParameterDefinition Parameter {
			get {
				if (parameter == null)
					Interlocked.CompareExchange (ref parameter, new ParameterDefinition (return_type, method), null);

				return parameter;
			}
		}

		public MetadataToken MetadataToken {
			get { return Parameter.MetadataToken; }
			set { Parameter.MetadataToken = value; }
		}

		public ParameterAttributes Attributes {
			get { return Parameter.Attributes; }
			set { Parameter.Attributes = value; }
		}

		public string Name {
			get { return Parameter.Name; }
			set { Parameter.Name = value; }
		}

		public bool HasCustomAttributes {
			get { return parameter != null && parameter.HasCustomAttributes; }
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return Parameter.CustomAttributes; }
		}

		public bool HasDefault {
			get { return parameter != null && parameter.HasDefault; }
			set { Parameter.HasDefault = value; }
		}

		public bool HasConstant {
			get { return parameter != null && parameter.HasConstant; }
			set { Parameter.HasConstant = value; }
		}

		public object Constant {
			get { return Parameter.Constant; }
			set { Parameter.Constant = value; }
		}

		public bool HasFieldMarshal {
			get { return parameter != null && parameter.HasFieldMarshal; }
			set { Parameter.HasFieldMarshal = value; }
		}

		public bool HasMarshalInfo {
			get { return parameter != null && parameter.HasMarshalInfo; }
		}

		public MarshalInfo MarshalInfo {
			get { return Parameter.MarshalInfo; }
			set { Parameter.MarshalInfo = value; }
		}

		public MethodReturnType (IMethodSignature method)
		{
			this.method = method;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodSemanticsAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum MethodSemanticsAttributes : ushort {
		None = 0x0000,
		Setter = 0x0001,    // Setter for property
		Getter = 0x0002,    // Getter for property
		Other = 0x0004, // Other method for property or event
		AddOn = 0x0008, // AddOn method for event
		RemoveOn = 0x0010,  // RemoveOn method for event
		Fire = 0x0020    // Fire method for event
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/MethodSpecification.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;

namespace MonoFN.Cecil {

	public abstract class MethodSpecification : MethodReference {

		readonly MethodReference method;

		public MethodReference ElementMethod {
			get { return method; }
		}

		public override string Name {
			get { return method.Name; }
			set { throw new InvalidOperationException (); }
		}

		public override MethodCallingConvention CallingConvention {
			get { return method.CallingConvention; }
			set { throw new InvalidOperationException (); }
		}

		public override bool HasThis {
			get { return method.HasThis; }
			set { throw new InvalidOperationException (); }
		}

		public override bool ExplicitThis {
			get { return method.ExplicitThis; }
			set { throw new InvalidOperationException (); }
		}

		public override MethodReturnType MethodReturnType {
			get { return method.MethodReturnType; }
			set { throw new InvalidOperationException (); }
		}

		public override TypeReference DeclaringType {
			get { return method.DeclaringType; }
			set { throw new InvalidOperationException (); }
		}

		public override ModuleDefinition Module {
			get { return method.Module; }
		}

		public override bool HasParameters {
			get { return method.HasParameters; }
		}

		public override Collection<ParameterDefinition> Parameters {
			get { return method.Parameters; }
		}

		public override bool ContainsGenericParameter {
			get { return method.ContainsGenericParameter; }
		}

		internal MethodSpecification (MethodReference method)
		{
			Mixin.CheckMethod (method);

			this.method = method;
			this.token = new MetadataToken (TokenType.MethodSpec);
		}

		public sealed override MethodReference GetElementMethod ()
		{
			return method.GetElementMethod ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/Modifiers.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

using MD = MonoFN.Cecil.Metadata;

namespace MonoFN.Cecil {

	public interface IModifierType {
		TypeReference ModifierType { get; }
		TypeReference ElementType { get; }
	}

	public sealed class OptionalModifierType : TypeSpecification, IModifierType {

		TypeReference modifier_type;

		public TypeReference ModifierType {
			get { return modifier_type; }
			set { modifier_type = value; }
		}

		public override string Name {
			get { return base.Name + Suffix; }
		}

		public override string FullName {
			get { return base.FullName + Suffix; }
		}

		string Suffix {
			get { return " modopt(" + modifier_type + ")"; }
		}

		public override bool IsValueType {
			get { return false; }
			set { throw new InvalidOperationException (); }
		}

		public override bool IsOptionalModifier {
			get { return true; }
		}

		public override bool ContainsGenericParameter {
			get { return modifier_type.ContainsGenericParameter || base.ContainsGenericParameter; }
		}

		public OptionalModifierType (TypeReference modifierType, TypeReference type)
			: base (type)
		{
			if (modifierType == null)
				throw new ArgumentNullException (Mixin.Argument.modifierType.ToString ());
			Mixin.CheckType (type);
			this.modifier_type = modifierType;
			this.etype = MD.ElementType.CModOpt;
		}
	}

	public sealed class RequiredModifierType : TypeSpecification, IModifierType {

		TypeReference modifier_type;

		public TypeReference ModifierType {
			get { return modifier_type; }
			set { modifier_type = value; }
		}

		public override string Name {
			get { return base.Name + Suffix; }
		}

		public override string FullName {
			get { return base.FullName + Suffix; }
		}

		string Suffix {
			get { return " modreq(" + modifier_type + ")"; }
		}

		public override bool IsValueType {
			get { return false; }
			set { throw new InvalidOperationException (); }
		}

		public override bool IsRequiredModifier {
			get { return true; }
		}

		public override bool ContainsGenericParameter {
			get { return modifier_type.ContainsGenericParameter || base.ContainsGenericParameter; }
		}

		public RequiredModifierType (TypeReference modifierType, TypeReference type)
			: base (type)
		{
			if (modifierType == null)
				throw new ArgumentNullException (Mixin.Argument.modifierType.ToString ());
			Mixin.CheckType (type);
			this.modifier_type = modifierType;
			this.etype = MD.ElementType.CModReqD;
		}

	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ModuleDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Cecil.Metadata;
using MonoFN.Cecil.PE;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using SR = System.Reflection;

namespace MonoFN.Cecil {

	public enum ReadingMode {
		Immediate = 1,
		Deferred = 2,
	}

	public sealed class ReaderParameters {

		ReadingMode reading_mode;
		internal IAssemblyResolver assembly_resolver;
		internal IMetadataResolver metadata_resolver;
		internal IMetadataImporterProvider metadata_importer_provider;
		internal IReflectionImporterProvider reflection_importer_provider;
		Stream symbol_stream;
		ISymbolReaderProvider symbol_reader_provider;
		bool read_symbols;
		bool throw_symbols_mismatch;
		bool projections;
		bool in_memory;
		bool read_write;

		public ReadingMode ReadingMode {
			get { return reading_mode; }
			set { reading_mode = value; }
		}

		public bool InMemory {
			get { return in_memory; }
			set { in_memory = value; }
		}

		public IAssemblyResolver AssemblyResolver {
			get { return assembly_resolver; }
			set { assembly_resolver = value; }
		}

		public IMetadataResolver MetadataResolver {
			get { return metadata_resolver; }
			set { metadata_resolver = value; }
		}

		public IMetadataImporterProvider MetadataImporterProvider {
			get { return metadata_importer_provider; }
			set { metadata_importer_provider = value; }
		}

		public IReflectionImporterProvider ReflectionImporterProvider {
			get { return reflection_importer_provider; }
			set { reflection_importer_provider = value; }
		}

		public Stream SymbolStream {
			get { return symbol_stream; }
			set { symbol_stream = value; }
		}

		public ISymbolReaderProvider SymbolReaderProvider {
			get { return symbol_reader_provider; }
			set { symbol_reader_provider = value; }
		}

		public bool ReadSymbols {
			get { return read_symbols; }
			set { read_symbols = value; }
		}

		public bool ThrowIfSymbolsAreNotMatching {
			get { return throw_symbols_mismatch; }
			set { throw_symbols_mismatch = value; }
		}

		public bool ReadWrite {
			get { return read_write; }
			set { read_write = value; }
		}

		public bool ApplyWindowsRuntimeProjections {
			get { return projections; }
			set { projections = value; }
		}

		public ReaderParameters ()
			: this (ReadingMode.Deferred)
		{
		}

		public ReaderParameters (ReadingMode readingMode)
		{
			this.reading_mode = readingMode;
			this.throw_symbols_mismatch = true;
		}
	}

	public sealed class ModuleParameters {

		ModuleKind kind;
		TargetRuntime runtime;
		uint? timestamp;
		TargetArchitecture architecture;
		IAssemblyResolver assembly_resolver;
		IMetadataResolver metadata_resolver;
		IMetadataImporterProvider metadata_importer_provider;
		IReflectionImporterProvider reflection_importer_provider;

		public ModuleKind Kind {
			get { return kind; }
			set { kind = value; }
		}

		public TargetRuntime Runtime {
			get { return runtime; }
			set { runtime = value; }
		}

		public uint? Timestamp {
			get { return timestamp; }
			set { timestamp = value; }
		}

		public TargetArchitecture Architecture {
			get { return architecture; }
			set { architecture = value; }
		}

		public IAssemblyResolver AssemblyResolver {
			get { return assembly_resolver; }
			set { assembly_resolver = value; }
		}

		public IMetadataResolver MetadataResolver {
			get { return metadata_resolver; }
			set { metadata_resolver = value; }
		}

		public IMetadataImporterProvider MetadataImporterProvider {
			get { return metadata_importer_provider; }
			set { metadata_importer_provider = value; }
		}

		public IReflectionImporterProvider ReflectionImporterProvider {
			get { return reflection_importer_provider; }
			set { reflection_importer_provider = value; }
		}

		public ModuleParameters ()
		{
			this.kind = ModuleKind.Dll;
			this.Runtime = GetCurrentRuntime ();
			this.architecture = TargetArchitecture.I386;
		}

		static TargetRuntime GetCurrentRuntime ()
		{
			return typeof (object).Assembly.ImageRuntimeVersion.ParseRuntime ();
		}
	}

	public sealed class WriterParameters {

		uint? timestamp;
		Stream symbol_stream;
		ISymbolWriterProvider symbol_writer_provider;
		bool write_symbols;
		byte [] key_blob;
		string key_container;
		SR.StrongNameKeyPair key_pair;

		public uint? Timestamp {
			get { return timestamp; }
			set { timestamp = value; }
		}

		public Stream SymbolStream {
			get { return symbol_stream; }
			set { symbol_stream = value; }
		}

		public ISymbolWriterProvider SymbolWriterProvider {
			get { return symbol_writer_provider; }
			set { symbol_writer_provider = value; }
		}

		public bool WriteSymbols {
			get { return write_symbols; }
			set { write_symbols = value; }
		}

		public bool HasStrongNameKey {
			get { return key_pair != null || key_blob != null || key_container != null; }
		}

		public byte [] StrongNameKeyBlob {
			get { return key_blob; }
			set { key_blob = value; }
		}

		public string StrongNameKeyContainer {
			get { return key_container; }
			set { key_container = value; }
		}

		public SR.StrongNameKeyPair StrongNameKeyPair {
			get { return key_pair; }
			set { key_pair = value; }
		}

		public bool DeterministicMvid { get; set; }
	}

	public sealed class ModuleDefinition : ModuleReference, ICustomAttributeProvider, ICustomDebugInformationProvider, IDisposable {

		internal Image Image;
		internal MetadataSystem MetadataSystem;
		internal ReadingMode ReadingMode;
		internal ISymbolReaderProvider SymbolReaderProvider;

		internal ISymbolReader symbol_reader;
		internal Disposable<IAssemblyResolver> assembly_resolver;
		internal IMetadataResolver metadata_resolver;
		internal TypeSystem type_system;
		internal readonly MetadataReader reader;
		readonly string file_name;

		internal string runtime_version;
		internal ModuleKind kind;
		WindowsRuntimeProjections projections;
		MetadataKind metadata_kind;
		TargetRuntime runtime;
		TargetArchitecture architecture;
		ModuleAttributes attributes;
		ModuleCharacteristics characteristics;
		Guid mvid;

		internal ushort linker_version = 8;
		internal ushort subsystem_major = 4;
		internal ushort subsystem_minor = 0;
		internal uint timestamp;

		internal AssemblyDefinition assembly;
		MethodDefinition entry_point;
		bool entry_point_set;

		internal IReflectionImporter reflection_importer;
		internal IMetadataImporter metadata_importer;

		Collection<CustomAttribute> custom_attributes;
		Collection<AssemblyNameReference> references;
		Collection<ModuleReference> modules;
		Collection<Resource> resources;
		Collection<ExportedType> exported_types;
		TypeDefinitionCollection types;

		internal Collection<CustomDebugInformation> custom_infos;

		internal MetadataBuilder metadata_builder;

		public bool IsMain {
			get { return kind != ModuleKind.NetModule; }
		}

		public ModuleKind Kind {
			get { return kind; }
			set { kind = value; }
		}

		public MetadataKind MetadataKind {
			get { return metadata_kind; }
			set { metadata_kind = value; }
		}

		internal WindowsRuntimeProjections Projections {
			get {
				if (projections == null)
					Interlocked.CompareExchange (ref projections, new WindowsRuntimeProjections (this), null);

				return projections;
			}
		}

		public TargetRuntime Runtime {
			get { return runtime; }
			set {
				runtime = value;
				runtime_version = runtime.RuntimeVersionString ();
			}
		}

		public string RuntimeVersion {
			get { return runtime_version; }
			set {
				runtime_version = value;
				runtime = runtime_version.ParseRuntime ();
			}
		}

		public TargetArchitecture Architecture {
			get { return architecture; }
			set { architecture = value; }
		}

		public ModuleAttributes Attributes {
			get { return attributes; }
			set { attributes = value; }
		}

		public ModuleCharacteristics Characteristics {
			get { return characteristics; }
			set { characteristics = value; }
		}

		[Obsolete ("Use FileName")]
		public string FullyQualifiedName {
			get { return file_name; }
		}

		public string FileName {
			get { return file_name; }
		}

		public Guid Mvid {
			get { return mvid; }
			set { mvid = value; }
		}

		internal bool HasImage {
			get { return Image != null; }
		}

		public bool HasSymbols {
			get { return symbol_reader != null; }
		}

		public ISymbolReader SymbolReader {
			get { return symbol_reader; }
		}

		public override MetadataScopeType MetadataScopeType {
			get { return MetadataScopeType.ModuleDefinition; }
		}

		public AssemblyDefinition Assembly {
			get { return assembly; }
		}

		internal IReflectionImporter ReflectionImporter {
			get {
				if (reflection_importer == null)
					Interlocked.CompareExchange (ref reflection_importer, new DefaultReflectionImporter (this), null);

				return reflection_importer;
			}
		}

		internal IMetadataImporter MetadataImporter {
			get {
				if (metadata_importer == null)
					Interlocked.CompareExchange (ref metadata_importer, new DefaultMetadataImporter (this), null);

				return metadata_importer;
			}
		}

		public IAssemblyResolver AssemblyResolver {
			get {
				if (assembly_resolver.value == null) {
					lock (module_lock) {
						assembly_resolver = Disposable.Owned (new DefaultAssemblyResolver () as IAssemblyResolver);
					}
				}

				return assembly_resolver.value;
			}
		}

		public IMetadataResolver MetadataResolver {
			get {
				if (metadata_resolver == null)
					Interlocked.CompareExchange (ref metadata_resolver, new MetadataResolver (this.AssemblyResolver), null);

				return metadata_resolver;
			}
		}

		public TypeSystem TypeSystem {
			get {
				if (type_system == null)
					Interlocked.CompareExchange (ref type_system, TypeSystem.CreateTypeSystem (this), null);

				return type_system;
			}
		}

		public bool HasAssemblyReferences {
			get {
				if (references != null)
					return references.Count > 0;

				return HasImage && Image.HasTable (Table.AssemblyRef);
			}
		}

		public Collection<AssemblyNameReference> AssemblyReferences {
			get {
				if (references != null)
					return references;

				if (HasImage)
					return Read (ref references, this, (_, reader) => reader.ReadAssemblyReferences ());

				Interlocked.CompareExchange (ref references, new Collection<AssemblyNameReference> (), null);
				return references;
			}
		}

		public bool HasModuleReferences {
			get {
				if (modules != null)
					return modules.Count > 0;

				return HasImage && Image.HasTable (Table.ModuleRef);
			}
		}

		public Collection<ModuleReference> ModuleReferences {
			get {
				if (modules != null)
					return modules;

				if (HasImage)
					return Read (ref modules, this, (_, reader) => reader.ReadModuleReferences ());

				Interlocked.CompareExchange (ref modules, new Collection<ModuleReference> (), null);
				return modules;
			}
		}

		public bool HasResources {
			get {
				if (resources != null)
					return resources.Count > 0;

				if (HasImage)
					return Image.HasTable (Table.ManifestResource) || Read (this, (_, reader) => reader.HasFileResource ());

				return false;
			}
		}

		public Collection<Resource> Resources {
			get {
				if (resources != null)
					return resources;

				if (HasImage)
					return Read (ref resources, this, (_, reader) => reader.ReadResources ());

				Interlocked.CompareExchange (ref resources, new Collection<Resource> (), null);
				return resources;
			}
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (this);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, this)); }
		}

		public bool HasTypes {
			get {
				if (types != null)
					return types.Count > 0;

				return HasImage && Image.HasTable (Table.TypeDef);
			}
		}

		public Collection<TypeDefinition> Types {
			get {
				if (types != null)
					return types;

				if (HasImage)
					return Read (ref types, this, (_, reader) => reader.ReadTypes ());

				Interlocked.CompareExchange (ref types, new TypeDefinitionCollection (this), null);
				return types;
			}
		}

		public bool HasExportedTypes {
			get {
				if (exported_types != null)
					return exported_types.Count > 0;

				return HasImage && Image.HasTable (Table.ExportedType);
			}
		}

		public Collection<ExportedType> ExportedTypes {
			get {
				if (exported_types != null)
					return exported_types;

				if (HasImage)
					return Read (ref exported_types, this, (_, reader) => reader.ReadExportedTypes ());

				Interlocked.CompareExchange (ref exported_types, new Collection<ExportedType> (), null);
				return exported_types;
			}
		}

		public MethodDefinition EntryPoint {
			get {
				if (entry_point_set)
					return entry_point;

				if (HasImage)
					Read (ref entry_point, this, (_, reader) => reader.ReadEntryPoint ());
				else
					entry_point = null;

				entry_point_set = true;
				return entry_point;
			}
			set {
				entry_point = value;
				entry_point_set = true;
			}
		}

		public bool HasCustomDebugInformations {
			get {
				return custom_infos != null && custom_infos.Count > 0;
			}
		}

		public Collection<CustomDebugInformation> CustomDebugInformations {
			get {
				if (custom_infos == null)
					Interlocked.CompareExchange (ref custom_infos, new Collection<CustomDebugInformation> (), null);

				return custom_infos;
			}
		}

		internal ModuleDefinition ()
		{
			this.MetadataSystem = new MetadataSystem ();
			this.token = new MetadataToken (TokenType.Module, 1);
		}

		internal ModuleDefinition (Image image)
			: this ()
		{
			this.Image = image;
			this.kind = image.Kind;
			this.RuntimeVersion = image.RuntimeVersion;
			this.architecture = image.Architecture;
			this.attributes = image.Attributes;
			this.characteristics = image.DllCharacteristics;
			this.linker_version = image.LinkerVersion;
			this.subsystem_major = image.SubSystemMajor;
			this.subsystem_minor = image.SubSystemMinor;
			this.file_name = image.FileName;
			this.timestamp = image.Timestamp;

			this.reader = new MetadataReader (this);
		}

		public void Dispose ()
		{
			if (Image != null)
				Image.Dispose ();

			if (symbol_reader != null)
				symbol_reader.Dispose ();

			if (assembly_resolver.value != null)
				assembly_resolver.Dispose ();
		}

		public bool HasTypeReference (string fullName)
		{
			return HasTypeReference (string.Empty, fullName);
		}

		public bool HasTypeReference (string scope, string fullName)
		{
			Mixin.CheckFullName (fullName);

			if (!HasImage)
				return false;

			return GetTypeReference (scope, fullName) != null;
		}

		public bool TryGetTypeReference (string fullName, out TypeReference type)
		{
			return TryGetTypeReference (string.Empty, fullName, out type);
		}

		public bool TryGetTypeReference (string scope, string fullName, out TypeReference type)
		{
			Mixin.CheckFullName (fullName);

			if (!HasImage) {
				type = null;
				return false;
			}

			return (type = GetTypeReference (scope, fullName)) != null;
		}

		TypeReference GetTypeReference (string scope, string fullname)
		{
			return Read (new Row<string, string> (scope, fullname), (row, reader) => reader.GetTypeReference (row.Col1, row.Col2));
		}

		public IEnumerable<TypeReference> GetTypeReferences ()
		{
			if (!HasImage)
				return Empty<TypeReference>.Array;

			return Read (this, (_, reader) => reader.GetTypeReferences ());
		}

		public IEnumerable<MemberReference> GetMemberReferences ()
		{
			if (!HasImage)
				return Empty<MemberReference>.Array;

			return Read (this, (_, reader) => reader.GetMemberReferences ());
		}

		public IEnumerable<CustomAttribute> GetCustomAttributes ()
		{
			if (!HasImage)
				return Empty<CustomAttribute>.Array;

			return Read (this, (_, reader) => reader.GetCustomAttributes ());
		}

		public TypeReference GetType (string fullName, bool runtimeName)
		{
			return runtimeName
				? TypeParser.ParseType (this, fullName, typeDefinitionOnly: true)
				: GetType (fullName);
		}

		public TypeDefinition GetType (string fullName)
		{
			Mixin.CheckFullName (fullName);

			var position = fullName.IndexOf ('/');
			if (position > 0)
				return GetNestedType (fullName);

			return ((TypeDefinitionCollection)this.Types).GetType (fullName);
		}

		public TypeDefinition GetType (string @namespace, string name)
		{
			Mixin.CheckName (name);

			return ((TypeDefinitionCollection)this.Types).GetType (@namespace ?? string.Empty, name);
		}

		public IEnumerable<TypeDefinition> GetTypes ()
		{
			return GetTypes (Types);
		}

		static IEnumerable<TypeDefinition> GetTypes (Collection<TypeDefinition> types)
		{
			for (int i = 0; i < types.Count; i++) {
				var type = types [i];

				yield return type;

				if (!type.HasNestedTypes)
					continue;

				foreach (var nested in GetTypes (type.NestedTypes))
					yield return nested;
			}
		}

		TypeDefinition GetNestedType (string fullname)
		{
			var names = fullname.Split ('/');
			var type = GetType (names [0]);

			if (type == null)
				return null;

			for (int i = 1; i < names.Length; i++) {
				var nested_type = type.GetNestedType (names [i]);
				if (nested_type == null)
					return null;

				type = nested_type;
			}

			return type;
		}

		internal FieldDefinition Resolve (FieldReference field)
		{
			return MetadataResolver.Resolve (field);
		}

		internal MethodDefinition Resolve (MethodReference method)
		{
			return MetadataResolver.Resolve (method);
		}

		internal TypeDefinition Resolve (TypeReference type)
		{
			return MetadataResolver.Resolve (type);
		}

		static void CheckContext (IGenericParameterProvider context, ModuleDefinition module)
		{
			if (context == null)
				return;

			if (context.Module != module)
				throw new ArgumentException ();
		}

		[Obsolete ("Use ImportReference", error: false)]
		public TypeReference Import (Type type)
		{
			return ImportReference (type, null);
		}

		public TypeReference ImportReference (Type type)
		{
			return ImportReference (type, null);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public TypeReference Import (Type type, IGenericParameterProvider context)
		{
			return ImportReference (type, context);
		}

		public TypeReference ImportReference (Type type, IGenericParameterProvider context)
		{
			Mixin.CheckType (type);
			CheckContext (context, this);

			return ReflectionImporter.ImportReference (type, context);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public FieldReference Import (SR.FieldInfo field)
		{
			return ImportReference (field, null);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public FieldReference Import (SR.FieldInfo field, IGenericParameterProvider context)
		{
			return ImportReference (field, context);
		}

		public FieldReference ImportReference (SR.FieldInfo field)
		{
			return ImportReference (field, null);
		}

		public FieldReference ImportReference (SR.FieldInfo field, IGenericParameterProvider context)
		{
			Mixin.CheckField (field);
			CheckContext (context, this);

			return ReflectionImporter.ImportReference (field, context);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public MethodReference Import (SR.MethodBase method)
		{
			return ImportReference (method, null);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public MethodReference Import (SR.MethodBase method, IGenericParameterProvider context)
		{
			return ImportReference (method, context);
		}

		public MethodReference ImportReference (SR.MethodBase method)
		{
			return ImportReference (method, null);
		}

		public MethodReference ImportReference (SR.MethodBase method, IGenericParameterProvider context)
		{
			Mixin.CheckMethod (method);
			CheckContext (context, this);

			return ReflectionImporter.ImportReference (method, context);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public TypeReference Import (TypeReference type)
		{
			return ImportReference (type, null);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public TypeReference Import (TypeReference type, IGenericParameterProvider context)
		{
			return ImportReference (type, context);
		}

		public TypeReference ImportReference (TypeReference type)
		{
			return ImportReference (type, null);
		}

		public TypeReference ImportReference (TypeReference type, IGenericParameterProvider context)
		{
			Mixin.CheckType (type);

			if (type.Module == this)
				return type;

			CheckContext (context, this);

			return MetadataImporter.ImportReference (type, context);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public FieldReference Import (FieldReference field)
		{
			return ImportReference (field, null);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public FieldReference Import (FieldReference field, IGenericParameterProvider context)
		{
			return ImportReference (field, context);
		}

		public FieldReference ImportReference (FieldReference field)
		{
			return ImportReference (field, null);
		}

		public FieldReference ImportReference (FieldReference field, IGenericParameterProvider context)
		{
			Mixin.CheckField (field);

			if (field.Module == this)
				return field;

			CheckContext (context, this);

			return MetadataImporter.ImportReference (field, context);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public MethodReference Import (MethodReference method)
		{
			return ImportReference (method, null);
		}

		[Obsolete ("Use ImportReference", error: false)]
		public MethodReference Import (MethodReference method, IGenericParameterProvider context)
		{
			return ImportReference (method, context);
		}

		public MethodReference ImportReference (MethodReference method)
		{
			return ImportReference (method, null);
		}

		public MethodReference ImportReference (MethodReference method, IGenericParameterProvider context)
		{
			Mixin.CheckMethod (method);

			if (method.Module == this)
				return method;

			CheckContext (context, this);

			return MetadataImporter.ImportReference (method, context);
		}

		public IMetadataTokenProvider LookupToken (int token)
		{
			return LookupToken (new MetadataToken ((uint)token));
		}

		public IMetadataTokenProvider LookupToken (MetadataToken token)
		{
			return Read (token, (t, reader) => reader.LookupToken (t));
		}

		public void ImmediateRead ()
		{
			if (!HasImage)
				return;
			ReadingMode = ReadingMode.Immediate;
			var moduleReader = new ImmediateModuleReader (Image);
			moduleReader.ReadModule (this, resolve_attributes: true);
		}

		readonly object module_lock = new object ();

		internal object SyncRoot {
			get { return module_lock; }
		}

		internal void Read<TItem> (TItem item, Action<TItem, MetadataReader> read)
		{
			lock (module_lock) {
				var position = reader.position;
				var context = reader.context;

				read (item, reader);

				reader.position = position;
				reader.context = context;
			}
		}

		internal TRet Read<TItem, TRet> (TItem item, Func<TItem, MetadataReader, TRet> read)
		{
			lock (module_lock) {
				var position = reader.position;
				var context = reader.context;

				var ret = read (item, reader);

				reader.position = position;
				reader.context = context;

				return ret;
			}
		}

		internal TRet Read<TItem, TRet> (ref TRet variable, TItem item, Func<TItem, MetadataReader, TRet> read) where TRet : class
		{
			lock (module_lock) {
				if (variable != null)
					return variable;

				var position = reader.position;
				var context = reader.context;

				var ret = read (item, reader);

				reader.position = position;
				reader.context = context;

				return variable = ret;
			}
		}

		public bool HasDebugHeader {
			get { return Image != null && Image.DebugHeader != null; }
		}

		public ImageDebugHeader GetDebugHeader ()
		{
			return Image.DebugHeader ?? new ImageDebugHeader ();
		}

		public static ModuleDefinition CreateModule (string name, ModuleKind kind)
		{
			return CreateModule (name, new ModuleParameters { Kind = kind });
		}

		public static ModuleDefinition CreateModule (string name, ModuleParameters parameters)
		{
			Mixin.CheckName (name);
			Mixin.CheckParameters (parameters);

			var module = new ModuleDefinition {
				Name = name,
				kind = parameters.Kind,
				timestamp = parameters.Timestamp ?? Mixin.GetTimestamp (),
				Runtime = parameters.Runtime,
				architecture = parameters.Architecture,
				mvid = Guid.NewGuid (),
				Attributes = ModuleAttributes.ILOnly,
				Characteristics = (ModuleCharacteristics)0x8540,
			};

			if (parameters.AssemblyResolver != null)
				module.assembly_resolver = Disposable.NotOwned (parameters.AssemblyResolver);

			if (parameters.MetadataResolver != null)
				module.metadata_resolver = parameters.MetadataResolver;

			if (parameters.MetadataImporterProvider != null)
				module.metadata_importer = parameters.MetadataImporterProvider.GetMetadataImporter (module);

			if (parameters.ReflectionImporterProvider != null)
				module.reflection_importer = parameters.ReflectionImporterProvider.GetReflectionImporter (module);

			if (parameters.Kind != ModuleKind.NetModule) {
				var assembly = new AssemblyDefinition ();
				module.assembly = assembly;
				module.assembly.Name = CreateAssemblyName (name);
				assembly.main_module = module;
			}

			module.Types.Add (new TypeDefinition (string.Empty, "<Module>", TypeAttributes.NotPublic));

			return module;
		}

		static AssemblyNameDefinition CreateAssemblyName (string name)
		{
			if (name.EndsWith (".dll") || name.EndsWith (".exe"))
				name = name.Substring (0, name.Length - 4);

			return new AssemblyNameDefinition (name, Mixin.ZeroVersion);
		}

		public void ReadSymbols ()
		{
			if (string.IsNullOrEmpty (file_name))
				throw new InvalidOperationException ();

			var provider = new DefaultSymbolReaderProvider (throwIfNoSymbol: true);
			ReadSymbols (provider.GetSymbolReader (this, file_name), throwIfSymbolsAreNotMaching: true);
		}

		public void ReadSymbols (ISymbolReader reader)
		{
			ReadSymbols (reader, throwIfSymbolsAreNotMaching: true);
		}

		public void ReadSymbols (ISymbolReader reader, bool throwIfSymbolsAreNotMaching)
		{
			if (reader == null)
				throw new ArgumentNullException ("reader");

			symbol_reader = reader;

			if (!symbol_reader.ProcessDebugHeader (GetDebugHeader ())) {
				symbol_reader = null;

				if (throwIfSymbolsAreNotMaching)
					throw new SymbolsNotMatchingException ("Symbols were found but are not matching the assembly");

				return;
			}

			if (HasImage && ReadingMode == ReadingMode.Immediate) {
				var immediate_reader = new ImmediateModuleReader (Image);
				immediate_reader.ReadSymbols (this);
			}
		}

		public static ModuleDefinition ReadModule (string fileName)
		{
			return ReadModule (fileName, new ReaderParameters (ReadingMode.Deferred));
		}

		public static ModuleDefinition ReadModule (string fileName, ReaderParameters parameters)
		{
			var stream = GetFileStream (fileName, FileMode.Open, parameters.ReadWrite ? FileAccess.ReadWrite : FileAccess.Read, FileShare.Read);

			if (parameters.InMemory) {
				var memory = new MemoryStream (stream.CanSeek ? (int)stream.Length : 0);
				using (stream)
					stream.CopyTo (memory);

				memory.Position = 0;
				stream = memory;
			}

			try {
				return ReadModule (Disposable.Owned (stream), fileName, parameters);
			}
			catch (Exception) {
				stream.Dispose ();
				throw;
			}
		}

		static Stream GetFileStream (string fileName, FileMode mode, FileAccess access, FileShare share)
		{
			Mixin.CheckFileName (fileName);

			return new FileStream (fileName, mode, access, share);
		}

		public static ModuleDefinition ReadModule (Stream stream)
		{
			return ReadModule (stream, new ReaderParameters (ReadingMode.Deferred));
		}

		public static ModuleDefinition ReadModule (Stream stream, ReaderParameters parameters)
		{
			Mixin.CheckStream (stream);
			Mixin.CheckReadSeek (stream);

			return ReadModule (Disposable.NotOwned (stream), stream.GetFileName (), parameters);
		}

		static ModuleDefinition ReadModule (Disposable<Stream> stream, string fileName, ReaderParameters parameters)
		{
			Mixin.CheckParameters (parameters);

			return ModuleReader.CreateModule (
				ImageReader.ReadImage (stream, fileName),
				parameters);
		}

		public void Write (string fileName)
		{
			Write (fileName, new WriterParameters ());
		}

		public void Write (string fileName, WriterParameters parameters)
		{
			Mixin.CheckParameters (parameters);
			var file = GetFileStream (fileName, FileMode.Create, FileAccess.ReadWrite, FileShare.Read);
			ModuleWriter.WriteModule (this, Disposable.Owned (file), parameters);
		}

		public void Write ()
		{
			Write (new WriterParameters ());
		}

		public void Write (WriterParameters parameters)
		{
			if (!HasImage)
				throw new InvalidOperationException ();

			Write (Image.Stream.value, parameters);
		}

		public void Write (Stream stream)
		{
			Write (stream, new WriterParameters ());
		}

		public void Write (Stream stream, WriterParameters parameters)
		{
			Mixin.CheckStream (stream);
			Mixin.CheckWriteSeek (stream);
			Mixin.CheckParameters (parameters);

			ModuleWriter.WriteModule (this, Disposable.NotOwned (stream), parameters);
		}
	}

	static partial class Mixin {

		public enum Argument {
			name,
			fileName,
			fullName,
			stream,
			type,
			method,
			field,
			parameters,
			module,
			modifierType,
			eventType,
			fieldType,
			declaringType,
			returnType,
			propertyType,
			interfaceType,
			constraintType,
		}

		public static void CheckName (object name)
		{
			if (name == null)
				throw new ArgumentNullException (Argument.name.ToString ());
		}

		public static void CheckName (string name)
		{
			if (string.IsNullOrEmpty (name))
				throw new ArgumentNullOrEmptyException (Argument.name.ToString ());
		}

		public static void CheckFileName (string fileName)
		{
			if (string.IsNullOrEmpty (fileName))
				throw new ArgumentNullOrEmptyException (Argument.fileName.ToString ());
		}

		public static void CheckFullName (string fullName)
		{
			if (string.IsNullOrEmpty (fullName))
				throw new ArgumentNullOrEmptyException (Argument.fullName.ToString ());
		}

		public static void CheckStream (object stream)
		{
			if (stream == null)
				throw new ArgumentNullException (Argument.stream.ToString ());
		}

		public static void CheckWriteSeek (Stream stream)
		{
			if (!stream.CanWrite || !stream.CanSeek)
				throw new ArgumentException ("Stream must be writable and seekable.");
		}

		public static void CheckReadSeek (Stream stream)
		{
			if (!stream.CanRead || !stream.CanSeek)
				throw new ArgumentException ("Stream must be readable and seekable.");
		}

		public static void CheckType (object type)
		{
			if (type == null)
				throw new ArgumentNullException (Argument.type.ToString ());
		}

		public static void CheckType (object type, Argument argument)
		{
			if (type == null)
				throw new ArgumentNullException (argument.ToString ());
		}

		public static void CheckField (object field)
		{
			if (field == null)
				throw new ArgumentNullException (Argument.field.ToString ());
		}

		public static void CheckMethod (object method)
		{
			if (method == null)
				throw new ArgumentNullException (Argument.method.ToString ());
		}

		public static void CheckParameters (object parameters)
		{
			if (parameters == null)
				throw new ArgumentNullException (Argument.parameters.ToString ());
		}

		public static uint GetTimestamp ()
		{
			return (uint)DateTime.UtcNow.Subtract (new DateTime (1970, 1, 1)).TotalSeconds;
		}

		public static bool HasImage (this ModuleDefinition self)
		{
			return self != null && self.HasImage;
		}

		public static string GetFileName (this Stream self)
		{
			var file_stream = self as FileStream;
			if (file_stream == null)
				return string.Empty;

			return Path.GetFullPath (file_stream.Name);
		}

		public static TargetRuntime ParseRuntime (this string self)
		{
			if (string.IsNullOrEmpty (self))
				return TargetRuntime.Net_4_0;

			switch (self [1]) {
			case '1':
				return self [3] == '0'
					? TargetRuntime.Net_1_0
					: TargetRuntime.Net_1_1;
			case '2':
				return TargetRuntime.Net_2_0;
			case '4':
			default:
				return TargetRuntime.Net_4_0;
			}
		}

		public static string RuntimeVersionString (this TargetRuntime runtime)
		{
			switch (runtime) {
			case TargetRuntime.Net_1_0:
				return "v1.0.3705";
			case TargetRuntime.Net_1_1:
				return "v1.1.4322";
			case TargetRuntime.Net_2_0:
				return "v2.0.50727";
			case TargetRuntime.Net_4_0:
			default:
				return "v4.0.30319";
			}
		}

		public static bool IsWindowsMetadata (this ModuleDefinition module)
		{
			return module.MetadataKind != MetadataKind.Ecma335;
		}

		public static byte [] ReadAll (this Stream self)
		{
			int read;
			var memory = new MemoryStream ((int)self.Length);
			var buffer = new byte [1024];

			while ((read = self.Read (buffer, 0, buffer.Length)) != 0)
				memory.Write (buffer, 0, read);

			return memory.ToArray ();
		}

		public static void Read (object o)
		{
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ModuleKind.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	public enum ModuleKind {
		Dll,
		Console,
		Windows,
		NetModule,
	}

	public enum MetadataKind {
		Ecma335,
		WindowsMetadata,
		ManagedWindowsMetadata,
	}

	public enum TargetArchitecture {
		I386 = 0x014c,
		AMD64 = 0x8664,
		IA64 = 0x0200,
		ARM = 0x01c0,
		ARMv7 = 0x01c4,
		ARM64 = 0xaa64,
	}

	[Flags]
	public enum ModuleAttributes {
		ILOnly = 1,
		Required32Bit = 2,
		ILLibrary = 4,
		StrongNameSigned = 8,
		Preferred32Bit = 0x00020000,
	}

	[Flags]
	public enum ModuleCharacteristics {
		HighEntropyVA = 0x0020,
		DynamicBase = 0x0040,
		NoSEH = 0x0400,
		NXCompat = 0x0100,
		AppContainer = 0x1000,
		TerminalServerAware = 0x8000,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ModuleReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public class ModuleReference : IMetadataScope {

		string name;

		internal MetadataToken token;

		public string Name {
			get { return name; }
			set { name = value; }
		}

		public virtual MetadataScopeType MetadataScopeType {
			get { return MetadataScopeType.ModuleReference; }
		}

		public MetadataToken MetadataToken {
			get { return token; }
			set { token = value; }
		}

		internal ModuleReference ()
		{
			this.token = new MetadataToken (TokenType.ModuleRef);
		}

		public ModuleReference (string name)
			: this ()
		{
			this.name = name;
		}

		public override string ToString ()
		{
			return name;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/NativeType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public enum NativeType {
		None = 0x66,

		Boolean = 0x02,
		I1 = 0x03,
		U1 = 0x04,
		I2 = 0x05,
		U2 = 0x06,
		I4 = 0x07,
		U4 = 0x08,
		I8 = 0x09,
		U8 = 0x0a,
		R4 = 0x0b,
		R8 = 0x0c,
		LPStr = 0x14,
		Int = 0x1f,
		UInt = 0x20,
		Func = 0x26,
		Array = 0x2a,

		// Msft specific
		Currency = 0x0f,
		BStr = 0x13,
		LPWStr = 0x15,
		LPTStr = 0x16,
		FixedSysString = 0x17,
		IUnknown = 0x19,
		IDispatch = 0x1a,
		Struct = 0x1b,
		IntF = 0x1c,
		SafeArray = 0x1d,
		FixedArray = 0x1e,
		ByValStr = 0x22,
		ANSIBStr = 0x23,
		TBStr = 0x24,
		VariantBool = 0x25,
		ASAny = 0x28,
		LPStruct = 0x2b,
		CustomMarshaler = 0x2c,
		Error = 0x2d,
		Max = 0x50
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/PInvokeAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum PInvokeAttributes : ushort {
		NoMangle = 0x0001,  // PInvoke is to use the member name as specified

		// Character set
		CharSetMask = 0x0006,
		CharSetNotSpec = 0x0000,
		CharSetAnsi = 0x0002,
		CharSetUnicode = 0x0004,
		CharSetAuto = 0x0006,

		SupportsLastError = 0x0040, // Information about target function. Not relevant for fields

		// Calling convetion
		CallConvMask = 0x0700,
		CallConvWinapi = 0x0100,
		CallConvCdecl = 0x0200,
		CallConvStdCall = 0x0300,
		CallConvThiscall = 0x0400,
		CallConvFastcall = 0x0500,

		BestFitMask = 0x0030,
		BestFitEnabled = 0x0010,
		BestFitDisabled = 0x0020,

		ThrowOnUnmappableCharMask = 0x3000,
		ThrowOnUnmappableCharEnabled = 0x1000,
		ThrowOnUnmappableCharDisabled = 0x2000,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/PInvokeInfo.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public sealed class PInvokeInfo {

		ushort attributes;
		string entry_point;
		ModuleReference module;

		public PInvokeAttributes Attributes {
			get { return (PInvokeAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public string EntryPoint {
			get { return entry_point; }
			set { entry_point = value; }
		}

		public ModuleReference Module {
			get { return module; }
			set { module = value; }
		}

		#region PInvokeAttributes

		public bool IsNoMangle {
			get { return attributes.GetAttributes ((ushort)PInvokeAttributes.NoMangle); }
			set { attributes = attributes.SetAttributes ((ushort)PInvokeAttributes.NoMangle, value); }
		}

		public bool IsCharSetNotSpec {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetNotSpec); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetNotSpec, value); }
		}

		public bool IsCharSetAnsi {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetAnsi); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetAnsi, value); }
		}

		public bool IsCharSetUnicode {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetUnicode); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetUnicode, value); }
		}

		public bool IsCharSetAuto {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetAuto); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CharSetMask, (ushort)PInvokeAttributes.CharSetAuto, value); }
		}

		public bool SupportsLastError {
			get { return attributes.GetAttributes ((ushort)PInvokeAttributes.SupportsLastError); }
			set { attributes = attributes.SetAttributes ((ushort)PInvokeAttributes.SupportsLastError, value); }
		}

		public bool IsCallConvWinapi {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvWinapi); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvWinapi, value); }
		}

		public bool IsCallConvCdecl {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvCdecl); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvCdecl, value); }
		}

		public bool IsCallConvStdCall {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvStdCall); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvStdCall, value); }
		}

		public bool IsCallConvThiscall {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvThiscall); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvThiscall, value); }
		}

		public bool IsCallConvFastcall {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvFastcall); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.CallConvMask, (ushort)PInvokeAttributes.CallConvFastcall, value); }
		}

		public bool IsBestFitEnabled {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.BestFitMask, (ushort)PInvokeAttributes.BestFitEnabled); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.BestFitMask, (ushort)PInvokeAttributes.BestFitEnabled, value); }
		}

		public bool IsBestFitDisabled {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.BestFitMask, (ushort)PInvokeAttributes.BestFitDisabled); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.BestFitMask, (ushort)PInvokeAttributes.BestFitDisabled, value); }
		}

		public bool IsThrowOnUnmappableCharEnabled {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.ThrowOnUnmappableCharMask, (ushort)PInvokeAttributes.ThrowOnUnmappableCharEnabled); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.ThrowOnUnmappableCharMask, (ushort)PInvokeAttributes.ThrowOnUnmappableCharEnabled, value); }
		}

		public bool IsThrowOnUnmappableCharDisabled {
			get { return attributes.GetMaskedAttributes ((ushort)PInvokeAttributes.ThrowOnUnmappableCharMask, (ushort)PInvokeAttributes.ThrowOnUnmappableCharDisabled); }
			set { attributes = attributes.SetMaskedAttributes ((ushort)PInvokeAttributes.ThrowOnUnmappableCharMask, (ushort)PInvokeAttributes.ThrowOnUnmappableCharDisabled, value); }
		}

		#endregion

		public PInvokeInfo (PInvokeAttributes attributes, string entryPoint, ModuleReference module)
		{
			this.attributes = (ushort)attributes;
			this.entry_point = entryPoint;
			this.module = module;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ParameterAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum ParameterAttributes : ushort {
		None = 0x0000,
		In = 0x0001,    // Param is [In]
		Out = 0x0002,   // Param is [Out]
		Lcid = 0x0004,
		Retval = 0x0008,
		Optional = 0x0010,  // Param is optional
		HasDefault = 0x1000,    // Param has default value
		HasFieldMarshal = 0x2000,   // Param has field marshal
		Unused = 0xcfe0  // Reserved: shall be zero in a conforming implementation
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ParameterDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;

namespace MonoFN.Cecil {

	public sealed class ParameterDefinition : ParameterReference, ICustomAttributeProvider, IConstantProvider, IMarshalInfoProvider {

		ushort attributes;

		internal IMethodSignature method;

		object constant = Mixin.NotResolved;
		Collection<CustomAttribute> custom_attributes;
		MarshalInfo marshal_info;

		public ParameterAttributes Attributes {
			get { return (ParameterAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public IMethodSignature Method {
			get { return method; }
		}

		public int Sequence {
			get {
				if (method == null)
					return -1;

				return method.HasImplicitThis () ? index + 1 : index;
			}
		}

		public bool HasConstant {
			get {
				this.ResolveConstant (ref constant, parameter_type.Module);

				return constant != Mixin.NoValue;
			}
			set { if (!value) constant = Mixin.NoValue; }
		}

		public object Constant {
			get { return HasConstant ? constant : null; }
			set { constant = value; }
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (parameter_type.Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, parameter_type.Module)); }
		}

		public bool HasMarshalInfo {
			get {
				if (marshal_info != null)
					return true;

				return this.GetHasMarshalInfo (parameter_type.Module);
			}
		}

		public MarshalInfo MarshalInfo {
			get { return marshal_info ?? (this.GetMarshalInfo (ref marshal_info, parameter_type.Module)); }
			set { marshal_info = value; }
		}

		#region ParameterAttributes

		public bool IsIn {
			get { return attributes.GetAttributes ((ushort)ParameterAttributes.In); }
			set { attributes = attributes.SetAttributes ((ushort)ParameterAttributes.In, value); }
		}

		public bool IsOut {
			get { return attributes.GetAttributes ((ushort)ParameterAttributes.Out); }
			set { attributes = attributes.SetAttributes ((ushort)ParameterAttributes.Out, value); }
		}

		public bool IsLcid {
			get { return attributes.GetAttributes ((ushort)ParameterAttributes.Lcid); }
			set { attributes = attributes.SetAttributes ((ushort)ParameterAttributes.Lcid, value); }
		}

		public bool IsReturnValue {
			get { return attributes.GetAttributes ((ushort)ParameterAttributes.Retval); }
			set { attributes = attributes.SetAttributes ((ushort)ParameterAttributes.Retval, value); }
		}

		public bool IsOptional {
			get { return attributes.GetAttributes ((ushort)ParameterAttributes.Optional); }
			set { attributes = attributes.SetAttributes ((ushort)ParameterAttributes.Optional, value); }
		}

		public bool HasDefault {
			get { return attributes.GetAttributes ((ushort)ParameterAttributes.HasDefault); }
			set { attributes = attributes.SetAttributes ((ushort)ParameterAttributes.HasDefault, value); }
		}

		public bool HasFieldMarshal {
			get { return attributes.GetAttributes ((ushort)ParameterAttributes.HasFieldMarshal); }
			set { attributes = attributes.SetAttributes ((ushort)ParameterAttributes.HasFieldMarshal, value); }
		}

		#endregion

		internal ParameterDefinition (TypeReference parameterType, IMethodSignature method)
			: this (string.Empty, ParameterAttributes.None, parameterType)
		{
			this.method = method;
		}

		public ParameterDefinition (TypeReference parameterType)
			: this (string.Empty, ParameterAttributes.None, parameterType)
		{
		}

		public ParameterDefinition (string name, ParameterAttributes attributes, TypeReference parameterType)
			: base (name, parameterType)
		{
			this.attributes = (ushort)attributes;
			this.token = new MetadataToken (TokenType.Param);
		}

		public override ParameterDefinition Resolve ()
		{
			return this;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ParameterDefinitionCollection.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;

namespace MonoFN.Cecil {

	sealed class ParameterDefinitionCollection : Collection<ParameterDefinition> {

		readonly IMethodSignature method;

		internal ParameterDefinitionCollection (IMethodSignature method)
		{
			this.method = method;
		}

		internal ParameterDefinitionCollection (IMethodSignature method, int capacity)
			: base (capacity)
		{
			this.method = method;
		}

		protected override void OnAdd (ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;
		}

		protected override void OnInsert (ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;

			for (int i = index; i < size; i++)
				items [i].index = i + 1;
		}

		protected override void OnSet (ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;
		}

		protected override void OnRemove (ParameterDefinition item, int index)
		{
			item.method = null;
			item.index = -1;

			for (int i = index + 1; i < size; i++)
				items [i].index = i - 1;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ParameterReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	public abstract class ParameterReference : IMetadataTokenProvider {

		string name;
		internal int index = -1;
		protected TypeReference parameter_type;
		internal MetadataToken token;

		public string Name {
			get { return name; }
			set { name = value; }
		}

		public int Index {
			get { return index; }
		}

		public TypeReference ParameterType {
			get { return parameter_type; }
			set { parameter_type = value; }
		}

		public MetadataToken MetadataToken {
			get { return token; }
			set { token = value; }
		}

		internal ParameterReference (string name, TypeReference parameterType)
		{
			if (parameterType == null)
				throw new ArgumentNullException ("parameterType");

			this.name = name ?? string.Empty;
			this.parameter_type = parameterType;
		}

		public override string ToString ()
		{
			return name;
		}

		public abstract ParameterDefinition Resolve ();
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/PinnedType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

using MD = MonoFN.Cecil.Metadata;

namespace MonoFN.Cecil {

	public sealed class PinnedType : TypeSpecification {

		public override bool IsValueType {
			get { return false; }
			set { throw new InvalidOperationException (); }
		}

		public override bool IsPinned {
			get { return true; }
		}

		public PinnedType (TypeReference type)
			: base (type)
		{
			Mixin.CheckType (type);
			this.etype = MD.ElementType.Pinned;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/PointerType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

using MD = MonoFN.Cecil.Metadata;

namespace MonoFN.Cecil {

	public sealed class PointerType : TypeSpecification {

		public override string Name {
			get { return base.Name + "*"; }
		}

		public override string FullName {
			get { return base.FullName + "*"; }
		}

		public override bool IsValueType {
			get { return false; }
			set { throw new InvalidOperationException (); }
		}

		public override bool IsPointer {
			get { return true; }
		}

		public PointerType (TypeReference type)
			: base (type)
		{
			Mixin.CheckType (type);
			this.etype = MD.ElementType.Ptr;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/PropertyAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum PropertyAttributes : ushort {
		None = 0x0000,
		SpecialName = 0x0200,   // Property is special
		RTSpecialName = 0x0400, // Runtime(metadata internal APIs) should check name encoding
		HasDefault = 0x1000,    // Property has default
		Unused = 0xe9ff  // Reserved: shall be zero in a conforming implementation
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/PropertyDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System.Text;
using System.Threading;

namespace MonoFN.Cecil {

	public sealed class PropertyDefinition : PropertyReference, IMemberDefinition, IConstantProvider {

		bool? has_this;
		ushort attributes;

		Collection<CustomAttribute> custom_attributes;

		internal MethodDefinition get_method;
		internal MethodDefinition set_method;
		internal Collection<MethodDefinition> other_methods;

		object constant = Mixin.NotResolved;

		public PropertyAttributes Attributes {
			get { return (PropertyAttributes)attributes; }
			set { attributes = (ushort)value; }
		}

		public bool HasThis {
			get {
				if (has_this.HasValue)
					return has_this.Value;

				if (GetMethod != null)
					return get_method.HasThis;

				if (SetMethod != null)
					return set_method.HasThis;

				return false;
			}
			set { has_this = value; }
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, Module)); }
		}

		public MethodDefinition GetMethod {
			get {
				if (get_method != null)
					return get_method;

				InitializeMethods ();
				return get_method;
			}
			set { get_method = value; }
		}

		public MethodDefinition SetMethod {
			get {
				if (set_method != null)
					return set_method;

				InitializeMethods ();
				return set_method;
			}
			set { set_method = value; }
		}

		public bool HasOtherMethods {
			get {
				if (other_methods != null)
					return other_methods.Count > 0;

				InitializeMethods ();
				return !other_methods.IsNullOrEmpty ();
			}
		}

		public Collection<MethodDefinition> OtherMethods {
			get {
				if (other_methods != null)
					return other_methods;

				InitializeMethods ();

				if (other_methods != null)
					return other_methods;

				Interlocked.CompareExchange (ref other_methods, new Collection<MethodDefinition> (), null);
				return other_methods;
			}
		}

		public bool HasParameters {
			get {
				InitializeMethods ();

				if (get_method != null)
					return get_method.HasParameters;

				if (set_method != null)
					return set_method.HasParameters && set_method.Parameters.Count > 1;

				return false;
			}
		}

		public override Collection<ParameterDefinition> Parameters {
			get {
				InitializeMethods ();

				if (get_method != null)
					return MirrorParameters (get_method, 0);

				if (set_method != null)
					return MirrorParameters (set_method, 1);

				return new Collection<ParameterDefinition> ();
			}
		}

		static Collection<ParameterDefinition> MirrorParameters (MethodDefinition method, int bound)
		{
			var parameters = new Collection<ParameterDefinition> ();
			if (!method.HasParameters)
				return parameters;

			var original_parameters = method.Parameters;
			var end = original_parameters.Count - bound;

			for (int i = 0; i < end; i++)
				parameters.Add (original_parameters [i]);

			return parameters;
		}

		public bool HasConstant {
			get {
				this.ResolveConstant (ref constant, Module);

				return constant != Mixin.NoValue;
			}
			set { if (!value) constant = Mixin.NoValue; }
		}

		public object Constant {
			get { return HasConstant ? constant : null; }
			set { constant = value; }
		}

		#region PropertyAttributes

		public bool IsSpecialName {
			get { return attributes.GetAttributes ((ushort)PropertyAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes ((ushort)PropertyAttributes.SpecialName, value); }
		}

		public bool IsRuntimeSpecialName {
			get { return attributes.GetAttributes ((ushort)PropertyAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes ((ushort)PropertyAttributes.RTSpecialName, value); }
		}

		public bool HasDefault {
			get { return attributes.GetAttributes ((ushort)PropertyAttributes.HasDefault); }
			set { attributes = attributes.SetAttributes ((ushort)PropertyAttributes.HasDefault, value); }
		}

		#endregion

		public new TypeDefinition DeclaringType {
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		public override bool IsDefinition {
			get { return true; }
		}

		public override string FullName {
			get {
				var builder = new StringBuilder ();
				builder.Append (PropertyType.ToString ());
				builder.Append (' ');
				builder.Append (MemberFullName ());
				builder.Append ('(');
				if (HasParameters) {
					var parameters = Parameters;
					for (int i = 0; i < parameters.Count; i++) {
						if (i > 0)
							builder.Append (',');
						builder.Append (parameters [i].ParameterType.FullName);
					}
				}
				builder.Append (')');
				return builder.ToString ();
			}
		}

		public PropertyDefinition (string name, PropertyAttributes attributes, TypeReference propertyType)
			: base (name, propertyType)
		{
			this.attributes = (ushort)attributes;
			this.token = new MetadataToken (TokenType.Property);
		}

		void InitializeMethods ()
		{
			var module = this.Module;
			if (module == null)
				return;

			lock (module.SyncRoot) {
				if (get_method != null || set_method != null)
					return;

				if (!module.HasImage ())
					return;

				module.Read (this, (property, reader) => reader.ReadMethods (property));
			}
		}

		public override PropertyDefinition Resolve ()
		{
			return this;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/PropertyReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;

namespace MonoFN.Cecil {

	public abstract class PropertyReference : MemberReference {

		TypeReference property_type;

		public TypeReference PropertyType {
			get { return property_type; }
			set { property_type = value; }
		}

		public abstract Collection<ParameterDefinition> Parameters {
			get;
		}

		internal PropertyReference (string name, TypeReference propertyType)
			: base (name)
		{
			Mixin.CheckType (propertyType, Mixin.Argument.propertyType);

			property_type = propertyType;
		}

		protected override IMemberDefinition ResolveDefinition ()
		{
			return this.Resolve ();
		}

		public new abstract PropertyDefinition Resolve ();
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/ReferenceType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

using MD = MonoFN.Cecil.Metadata;

namespace MonoFN.Cecil {

	public sealed class ByReferenceType : TypeSpecification {

		public override string Name {
			get { return base.Name + "&"; }
		}

		public override string FullName {
			get { return base.FullName + "&"; }
		}

		public override bool IsValueType {
			get { return false; }
			set { throw new InvalidOperationException (); }
		}

		public override bool IsByReference {
			get { return true; }
		}

		public ByReferenceType (TypeReference type)
			: base (type)
		{
			Mixin.CheckType (type);
			this.etype = MD.ElementType.ByRef;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/Resource.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public enum ResourceType {
		Linked,
		Embedded,
		AssemblyLinked,
	}

	public abstract class Resource {

		string name;
		uint attributes;

		public string Name {
			get { return name; }
			set { name = value; }
		}

		public ManifestResourceAttributes Attributes {
			get { return (ManifestResourceAttributes)attributes; }
			set { attributes = (uint)value; }
		}

		public abstract ResourceType ResourceType {
			get;
		}

		#region ManifestResourceAttributes

		public bool IsPublic {
			get { return attributes.GetMaskedAttributes ((uint)ManifestResourceAttributes.VisibilityMask, (uint)ManifestResourceAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes ((uint)ManifestResourceAttributes.VisibilityMask, (uint)ManifestResourceAttributes.Public, value); }
		}

		public bool IsPrivate {
			get { return attributes.GetMaskedAttributes ((uint)ManifestResourceAttributes.VisibilityMask, (uint)ManifestResourceAttributes.Private); }
			set { attributes = attributes.SetMaskedAttributes ((uint)ManifestResourceAttributes.VisibilityMask, (uint)ManifestResourceAttributes.Private, value); }
		}

		#endregion

		internal Resource (string name, ManifestResourceAttributes attributes)
		{
			this.name = name;
			this.attributes = (uint)attributes;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/SecurityDeclaration.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Diagnostics;
using System.Threading;

namespace MonoFN.Cecil {

	public enum SecurityAction : ushort {
		Request = 1,
		Demand = 2,
		Assert = 3,
		Deny = 4,
		PermitOnly = 5,
		LinkDemand = 6,
		InheritDemand = 7,
		RequestMinimum = 8,
		RequestOptional = 9,
		RequestRefuse = 10,
		PreJitGrant = 11,
		PreJitDeny = 12,
		NonCasDemand = 13,
		NonCasLinkDemand = 14,
		NonCasInheritance = 15
	}

	public interface ISecurityDeclarationProvider : IMetadataTokenProvider {

		bool HasSecurityDeclarations { get; }
		Collection<SecurityDeclaration> SecurityDeclarations { get; }
	}

	[DebuggerDisplay ("{AttributeType}")]
	public sealed class SecurityAttribute : ICustomAttribute {

		TypeReference attribute_type;

		internal Collection<CustomAttributeNamedArgument> fields;
		internal Collection<CustomAttributeNamedArgument> properties;

		public TypeReference AttributeType {
			get { return attribute_type; }
			set { attribute_type = value; }
		}

		public bool HasFields {
			get { return !fields.IsNullOrEmpty (); }
		}

		public Collection<CustomAttributeNamedArgument> Fields {
			get {
				if (fields == null)
					Interlocked.CompareExchange (ref fields, new Collection<CustomAttributeNamedArgument> (), null);

				return fields;
			}
		}

		public bool HasProperties {
			get { return !properties.IsNullOrEmpty (); }
		}

		public Collection<CustomAttributeNamedArgument> Properties {
			get {
				if (properties == null)
					Interlocked.CompareExchange (ref properties, new Collection<CustomAttributeNamedArgument> (), null);

				return properties;
			}
		}

		public SecurityAttribute (TypeReference attributeType)
		{
			this.attribute_type = attributeType;
		}

		bool ICustomAttribute.HasConstructorArguments {
			get { return false; }
		}

		Collection<CustomAttributeArgument> ICustomAttribute.ConstructorArguments {
			get { throw new NotSupportedException (); }
		}
	}

	public sealed class SecurityDeclaration {

		readonly internal uint signature;
		byte [] blob;
		readonly ModuleDefinition module;

		internal bool resolved;
		SecurityAction action;
		internal Collection<SecurityAttribute> security_attributes;

		public SecurityAction Action {
			get { return action; }
			set { action = value; }
		}

		public bool HasSecurityAttributes {
			get {
				Resolve ();

				return !security_attributes.IsNullOrEmpty ();
			}
		}

		public Collection<SecurityAttribute> SecurityAttributes {
			get {
				Resolve ();

				if (security_attributes == null)
					Interlocked.CompareExchange (ref security_attributes, new Collection<SecurityAttribute> (), null);

				return security_attributes;
			}
		}

		internal bool HasImage {
			get { return module != null && module.HasImage; }
		}

		internal SecurityDeclaration (SecurityAction action, uint signature, ModuleDefinition module)
		{
			this.action = action;
			this.signature = signature;
			this.module = module;
		}

		public SecurityDeclaration (SecurityAction action)
		{
			this.action = action;
			this.resolved = true;
		}

		public SecurityDeclaration (SecurityAction action, byte [] blob)
		{
			this.action = action;
			this.resolved = false;
			this.blob = blob;
		}

		public byte [] GetBlob ()
		{
			if (blob != null)
				return blob;

			if (!HasImage || signature == 0)
				throw new NotSupportedException ();

			return module.Read (ref blob, this, (declaration, reader) => reader.ReadSecurityDeclarationBlob (declaration.signature));
		}

		void Resolve ()
		{
			if (resolved || !HasImage)
				return;

			lock (module.SyncRoot) {

				if (resolved)
					return;

				module.Read (this, (declaration, reader) => reader.ReadSecurityDeclarationSignature (declaration));
				resolved = true;
			}
		}
	}

	static partial class Mixin {

		public static bool GetHasSecurityDeclarations (
			this ISecurityDeclarationProvider self,
			ModuleDefinition module)
		{
			return module.HasImage () && module.Read (self, (provider, reader) => reader.HasSecurityDeclarations (provider));
		}

		public static Collection<SecurityDeclaration> GetSecurityDeclarations (
			this ISecurityDeclarationProvider self,
			ref Collection<SecurityDeclaration> variable,
			ModuleDefinition module)
		{
			if (module.HasImage)
				return module.Read (ref variable, self, (provider, reader) => reader.ReadSecurityDeclarations (provider));

			Interlocked.CompareExchange (ref variable, new Collection<SecurityDeclaration> (), null);
			return variable;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/SentinelType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

using MD = MonoFN.Cecil.Metadata;

namespace MonoFN.Cecil {

	public sealed class SentinelType : TypeSpecification {

		public override bool IsValueType {
			get { return false; }
			set { throw new InvalidOperationException (); }
		}

		public override bool IsSentinel {
			get { return true; }
		}

		public SentinelType (TypeReference type)
			: base (type)
		{
			Mixin.CheckType (type);
			this.etype = MD.ElementType.Sentinel;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TargetRuntime.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public enum TargetRuntime {
		Net_1_0,
		Net_1_1,
		Net_2_0,
		Net_4_0,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/Treatments.cs ---
﻿//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	enum TypeDefinitionTreatment {
		None = 0x0,

		KindMask = 0xf,
		NormalType = 0x1,
		NormalAttribute = 0x2,
		UnmangleWindowsRuntimeName = 0x3,
		PrefixWindowsRuntimeName = 0x4,
		RedirectToClrType = 0x5,
		RedirectToClrAttribute = 0x6,
		RedirectImplementedMethods = 0x7,

		Abstract = 0x10,
		Internal = 0x20,
	}

	enum TypeReferenceTreatment {
		None = 0x0,
		SystemDelegate = 0x1,
		SystemAttribute = 0x2,
		UseProjectionInfo = 0x3,
	}

	[Flags]
	enum MethodDefinitionTreatment {
		None = 0x0,
		Abstract = 0x2,
		Private = 0x4,
		Public = 0x8,
		Runtime = 0x10,
		InternalCall = 0x20,
	}

	enum FieldDefinitionTreatment {
		None = 0x0,
		Public = 0x1,
	}

	enum CustomAttributeValueTreatment {
		None = 0x0,
		AllowSingle = 0x1,
		AllowMultiple = 0x2,
		VersionAttribute = 0x3,
		DeprecatedAttribute = 0x4,
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeAttributes.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	[Flags]
	public enum TypeAttributes : uint {
		// Visibility attributes
		VisibilityMask = 0x00000007,    // Use this mask to retrieve visibility information
		NotPublic = 0x00000000, // Class has no public scope
		Public = 0x00000001,    // Class has public scope
		NestedPublic = 0x00000002,  // Class is nested with public visibility
		NestedPrivate = 0x00000003, // Class is nested with private visibility
		NestedFamily = 0x00000004,  // Class is nested with family visibility
		NestedAssembly = 0x00000005,    // Class is nested with assembly visibility
		NestedFamANDAssem = 0x00000006, // Class is nested with family and assembly visibility
		NestedFamORAssem = 0x00000007,  // Class is nested with family or assembly visibility

		// Class layout attributes
		LayoutMask = 0x00000018,    // Use this mask to retrieve class layout information
		AutoLayout = 0x00000000,    // Class fields are auto-laid out
		SequentialLayout = 0x00000008,  // Class fields are laid out sequentially
		ExplicitLayout = 0x00000010,    // Layout is supplied explicitly

		// Class semantics attributes
		ClassSemanticMask = 0x00000020, // Use this mask to retrieve class semantics information
		Class = 0x00000000, // Type is a class
		Interface = 0x00000020, // Type is an interface

		// Special semantics in addition to class semantics
		Abstract = 0x00000080,  // Class is abstract
		Sealed = 0x00000100,    // Class cannot be extended
		SpecialName = 0x00000400,   // Class name is special

		// Implementation attributes
		Import = 0x00001000,    // Class/Interface is imported
		Serializable = 0x00002000,  // Class is serializable
		WindowsRuntime = 0x00004000,    // Windows Runtime type

		// String formatting attributes
		StringFormatMask = 0x00030000,  // Use this mask to retrieve string information for native interop
		AnsiClass = 0x00000000, // LPSTR is interpreted as ANSI
		UnicodeClass = 0x00010000,  // LPSTR is interpreted as Unicode
		AutoClass = 0x00020000, // LPSTR is interpreted automatically

		// Class initialization attributes
		BeforeFieldInit = 0x00100000,   // Initialize the class before first static field access

		// Additional flags
		RTSpecialName = 0x00000800, // CLI provides 'special' behavior, depending upon the name of the Type
		HasSecurity = 0x00040000,   // Type has security associate with it
		Forwarder = 0x00200000,   // Exported type is a type forwarder
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeComparisonMode.cs ---
namespace MonoFN.Cecil {
	internal enum TypeComparisonMode {
		Exact,
		SignatureOnly,

		/// <summary>
		/// Types can be in different assemblies, as long as the module, assembly, and type names match they will be considered equal
		/// </summary>
		SignatureOnlyLoose
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeDefinition.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using MonoFN.Collections.Generic;
using System;
using System.Threading;

namespace MonoFN.Cecil {

	public sealed class TypeDefinition : TypeReference, IMemberDefinition, ISecurityDeclarationProvider {

		uint attributes;
		TypeReference base_type;
		internal Range fields_range;
		internal Range methods_range;

		short packing_size = Mixin.NotResolvedMarker;
		int class_size = Mixin.NotResolvedMarker;

		InterfaceImplementationCollection interfaces;
		Collection<TypeDefinition> nested_types;
		Collection<MethodDefinition> methods;
		Collection<FieldDefinition> fields;
		Collection<EventDefinition> events;
		Collection<PropertyDefinition> properties;
		Collection<CustomAttribute> custom_attributes;
		Collection<SecurityDeclaration> security_declarations;

		public TypeAttributes Attributes {
			get { return (TypeAttributes)attributes; }
			set {
				if (IsWindowsRuntimeProjection && (ushort)value != attributes)
					throw new InvalidOperationException ();

				attributes = (uint)value;
			}
		}

		public TypeReference BaseType {
			get { return base_type; }
			set { base_type = value; }
		}

		public override string Name {
			get { return base.Name; }
			set {
				if (IsWindowsRuntimeProjection && value != base.Name)
					throw new InvalidOperationException ();

				base.Name = value;
			}
		}

		void ResolveLayout ()
		{
			if (!HasImage) {
				packing_size = Mixin.NoDataMarker;
				class_size = Mixin.NoDataMarker;
				return;
			}

			lock (Module.SyncRoot) {
				if (packing_size != Mixin.NotResolvedMarker || class_size != Mixin.NotResolvedMarker)
					return;

				var row = Module.Read (this, (type, reader) => reader.ReadTypeLayout (type));

				packing_size = row.Col1;
				class_size = row.Col2;
			}
		}

		public bool HasLayoutInfo {
			get {
				if (packing_size >= 0 || class_size >= 0)
					return true;

				ResolveLayout ();

				return packing_size >= 0 || class_size >= 0;
			}
		}

		public short PackingSize {
			get {
				if (packing_size >= 0)
					return packing_size;

				ResolveLayout ();

				return packing_size >= 0 ? packing_size : (short)-1;
			}
			set { packing_size = value; }
		}

		public int ClassSize {
			get {
				if (class_size >= 0)
					return class_size;

				ResolveLayout ();

				return class_size >= 0 ? class_size : -1;
			}
			set { class_size = value; }
		}

		public bool HasInterfaces {
			get {
				if (interfaces != null)
					return interfaces.Count > 0;

				return HasImage && Module.Read (this, (type, reader) => reader.HasInterfaces (type));
			}
		}

		public Collection<InterfaceImplementation> Interfaces {
			get {
				if (interfaces != null)
					return interfaces;

				if (HasImage)
					return Module.Read (ref interfaces, this, (type, reader) => reader.ReadInterfaces (type));

				Interlocked.CompareExchange (ref interfaces, new InterfaceImplementationCollection (this), null);
				return interfaces;
			}
		}

		public bool HasNestedTypes {
			get {
				if (nested_types != null)
					return nested_types.Count > 0;

				return HasImage && Module.Read (this, (type, reader) => reader.HasNestedTypes (type));
			}
		}

		public Collection<TypeDefinition> NestedTypes {
			get {
				if (nested_types != null)
					return nested_types;

				if (HasImage)
					return Module.Read (ref nested_types, this, (type, reader) => reader.ReadNestedTypes (type));

				Interlocked.CompareExchange (ref nested_types, new MemberDefinitionCollection<TypeDefinition> (this), null);
				return nested_types;
			}
		}

		public bool HasMethods {
			get {
				if (methods != null)
					return methods.Count > 0;

				return HasImage && methods_range.Length > 0;
			}
		}

		public Collection<MethodDefinition> Methods {
			get {
				if (methods != null)
					return methods;

				if (HasImage)
					return Module.Read (ref methods, this, (type, reader) => reader.ReadMethods (type));

				Interlocked.CompareExchange (ref methods, new MemberDefinitionCollection<MethodDefinition> (this), null);
				return methods;
			}
		}

		public bool HasFields {
			get {
				if (fields != null)
					return fields.Count > 0;

				return HasImage && fields_range.Length > 0;
			}
		}

		public Collection<FieldDefinition> Fields {
			get {
				if (fields != null)
					return fields;

				if (HasImage)
					return Module.Read (ref fields, this, (type, reader) => reader.ReadFields (type));

				Interlocked.CompareExchange (ref fields, new MemberDefinitionCollection<FieldDefinition> (this), null);
				return fields;
			}
		}

		public bool HasEvents {
			get {
				if (events != null)
					return events.Count > 0;

				return HasImage && Module.Read (this, (type, reader) => reader.HasEvents (type));
			}
		}

		public Collection<EventDefinition> Events {
			get {
				if (events != null)
					return events;

				if (HasImage)
					return Module.Read (ref events, this, (type, reader) => reader.ReadEvents (type));

				Interlocked.CompareExchange (ref events, new MemberDefinitionCollection<EventDefinition> (this), null);
				return events;
			}
		}

		public bool HasProperties {
			get {
				if (properties != null)
					return properties.Count > 0;

				return HasImage && Module.Read (this, (type, reader) => reader.HasProperties (type));
			}
		}

		public Collection<PropertyDefinition> Properties {
			get {
				if (properties != null)
					return properties;

				if (HasImage)
					return Module.Read (ref properties, this, (type, reader) => reader.ReadProperties (type));

				Interlocked.CompareExchange (ref properties, new MemberDefinitionCollection<PropertyDefinition> (this), null);
				return properties;
			}
		}

		public bool HasSecurityDeclarations {
			get {
				if (security_declarations != null)
					return security_declarations.Count > 0;

				return this.GetHasSecurityDeclarations (Module);
			}
		}

		public Collection<SecurityDeclaration> SecurityDeclarations {
			get { return security_declarations ?? (this.GetSecurityDeclarations (ref security_declarations, Module)); }
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				return this.GetHasCustomAttributes (Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get { return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, Module)); }
		}

		public override bool HasGenericParameters {
			get {
				if (generic_parameters != null)
					return generic_parameters.Count > 0;

				return this.GetHasGenericParameters (Module);
			}
		}

		public override Collection<GenericParameter> GenericParameters {
			get { return generic_parameters ?? (this.GetGenericParameters (ref generic_parameters, Module)); }
		}

		#region TypeAttributes

		public bool IsNotPublic {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NotPublic); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NotPublic, value); }
		}

		public bool IsPublic {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.Public); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.Public, value); }
		}

		public bool IsNestedPublic {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPublic); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPublic, value); }
		}

		public bool IsNestedPrivate {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPrivate); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedPrivate, value); }
		}

		public bool IsNestedFamily {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamily); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamily, value); }
		}

		public bool IsNestedAssembly {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedAssembly); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedAssembly, value); }
		}

		public bool IsNestedFamilyAndAssembly {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamANDAssem); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamANDAssem, value); }
		}

		public bool IsNestedFamilyOrAssembly {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamORAssem); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.VisibilityMask, (uint)TypeAttributes.NestedFamORAssem, value); }
		}

		public bool IsAutoLayout {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.AutoLayout); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.AutoLayout, value); }
		}

		public bool IsSequentialLayout {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.SequentialLayout); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.SequentialLayout, value); }
		}

		public bool IsExplicitLayout {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.ExplicitLayout); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.LayoutMask, (uint)TypeAttributes.ExplicitLayout, value); }
		}

		public bool IsClass {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Class); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Class, value); }
		}

		public bool IsInterface {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Interface); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.ClassSemanticMask, (uint)TypeAttributes.Interface, value); }
		}

		public bool IsAbstract {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Abstract); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Abstract, value); }
		}

		public bool IsSealed {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Sealed); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Sealed, value); }
		}

		public bool IsSpecialName {
			get { return attributes.GetAttributes ((uint)TypeAttributes.SpecialName); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.SpecialName, value); }
		}

		public bool IsImport {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Import); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Import, value); }
		}

		public bool IsSerializable {
			get { return attributes.GetAttributes ((uint)TypeAttributes.Serializable); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.Serializable, value); }
		}

		public bool IsWindowsRuntime {
			get { return attributes.GetAttributes ((uint)TypeAttributes.WindowsRuntime); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.WindowsRuntime, value); }
		}

		public bool IsAnsiClass {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AnsiClass); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AnsiClass, value); }
		}

		public bool IsUnicodeClass {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.UnicodeClass); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.UnicodeClass, value); }
		}

		public bool IsAutoClass {
			get { return attributes.GetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AutoClass); }
			set { attributes = attributes.SetMaskedAttributes ((uint)TypeAttributes.StringFormatMask, (uint)TypeAttributes.AutoClass, value); }
		}

		public bool IsBeforeFieldInit {
			get { return attributes.GetAttributes ((uint)TypeAttributes.BeforeFieldInit); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.BeforeFieldInit, value); }
		}

		public bool IsRuntimeSpecialName {
			get { return attributes.GetAttributes ((uint)TypeAttributes.RTSpecialName); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.RTSpecialName, value); }
		}

		public bool HasSecurity {
			get { return attributes.GetAttributes ((uint)TypeAttributes.HasSecurity); }
			set { attributes = attributes.SetAttributes ((uint)TypeAttributes.HasSecurity, value); }
		}

		#endregion

		public bool IsEnum {
			get { return base_type != null && base_type.IsTypeOf ("System", "Enum"); }
		}

		public override bool IsValueType {
			get {
				if (base_type == null)
					return false;

				return base_type.IsTypeOf ("System", "Enum") || (base_type.IsTypeOf ("System", "ValueType") && !this.IsTypeOf ("System", "Enum"));
			}
			set {
				throw new NotSupportedException ();
			}
		}

		public override bool IsPrimitive {
			get {
				ElementType primitive_etype;
				return MetadataSystem.TryGetPrimitiveElementType (this, out primitive_etype) && primitive_etype.IsPrimitive ();
			}
		}

		public override MetadataType MetadataType {
			get {
				ElementType primitive_etype;
				if (MetadataSystem.TryGetPrimitiveElementType (this, out primitive_etype))
					return (MetadataType)primitive_etype;

				return base.MetadataType;
			}
		}

		public override bool IsDefinition {
			get { return true; }
		}

		public new TypeDefinition DeclaringType {
			get { return (TypeDefinition)base.DeclaringType; }
			set { base.DeclaringType = value; }
		}

		internal new TypeDefinitionProjection WindowsRuntimeProjection {
			get { return (TypeDefinitionProjection)projection; }
			set { projection = value; }
		}

		public TypeDefinition (string @namespace, string name, TypeAttributes attributes)
			: base (@namespace, name)
		{
			this.attributes = (uint)attributes;
			this.token = new MetadataToken (TokenType.TypeDef);
		}

		public TypeDefinition (string @namespace, string name, TypeAttributes attributes, TypeReference baseType) :
			this (@namespace, name, attributes)
		{
			this.BaseType = baseType;
		}

		protected override void ClearFullName ()
		{
			base.ClearFullName ();

			if (!HasNestedTypes)
				return;

			var nested_types = this.NestedTypes;

			for (int i = 0; i < nested_types.Count; i++)
				nested_types [i].ClearFullName ();
		}

		public override TypeDefinition Resolve ()
		{
			return this;
		}
	}

	public sealed class InterfaceImplementation : ICustomAttributeProvider {
		internal TypeDefinition type;
		internal MetadataToken token;

		TypeReference interface_type;
		Collection<CustomAttribute> custom_attributes;

		public TypeReference InterfaceType {
			get { return interface_type; }
			set { interface_type = value; }
		}

		public bool HasCustomAttributes {
			get {
				if (custom_attributes != null)
					return custom_attributes.Count > 0;

				if (type == null)
					return false;

				return this.GetHasCustomAttributes (type.Module);
			}
		}

		public Collection<CustomAttribute> CustomAttributes {
			get {
				if (type == null) {
					if (custom_attributes == null)
						Interlocked.CompareExchange (ref custom_attributes, new Collection<CustomAttribute> (), null);
					return custom_attributes;
				}

				return custom_attributes ?? (this.GetCustomAttributes (ref custom_attributes, type.Module));
			}
		}

		public MetadataToken MetadataToken {
			get { return token; }
			set { token = value; }
		}

		internal InterfaceImplementation (TypeReference interfaceType, MetadataToken token)
		{
			this.interface_type = interfaceType;
			this.token = token;
		}

		public InterfaceImplementation (TypeReference interfaceType)
		{
			Mixin.CheckType (interfaceType, Mixin.Argument.interfaceType);

			this.interface_type = interfaceType;
			this.token = new MetadataToken (TokenType.InterfaceImpl);
		}
	}

	class InterfaceImplementationCollection : Collection<InterfaceImplementation> {
		readonly TypeDefinition type;

		internal InterfaceImplementationCollection (TypeDefinition type)
		{
			this.type = type;
		}

		internal InterfaceImplementationCollection (TypeDefinition type, int length)
			: base (length)
		{
			this.type = type;
		}

		protected override void OnAdd (InterfaceImplementation item, int index)
		{
			item.type = type;
		}

		protected override void OnInsert (InterfaceImplementation item, int index)
		{
			item.type = type;
		}

		protected override void OnSet (InterfaceImplementation item, int index)
		{
			item.type = type;
		}

		protected override void OnRemove (InterfaceImplementation item, int index)
		{
			item.type = null;
		}
	}

	static partial class Mixin {

		public static TypeReference GetEnumUnderlyingType (this TypeDefinition self)
		{
			var fields = self.Fields;

			for (int i = 0; i < fields.Count; i++) {
				var field = fields [i];
				if (!field.IsStatic)
					return field.FieldType;
			}

			throw new ArgumentException ();
		}

		public static TypeDefinition GetNestedType (this TypeDefinition self, string fullname)
		{
			if (!self.HasNestedTypes)
				return null;

			var nested_types = self.NestedTypes;

			for (int i = 0; i < nested_types.Count; i++) {
				var nested_type = nested_types [i];

				if (nested_type.TypeFullName () == fullname)
					return nested_type;
			}

			return null;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeDefinitionCollection.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;

namespace MonoFN.Cecil {

	using Slot = Row<string, string>;

	sealed class TypeDefinitionCollection : Collection<TypeDefinition> {

		readonly ModuleDefinition container;
		readonly Dictionary<Slot, TypeDefinition> name_cache;

		internal TypeDefinitionCollection (ModuleDefinition container)
		{
			this.container = container;
			this.name_cache = new Dictionary<Slot, TypeDefinition> (new RowEqualityComparer ());
		}

		internal TypeDefinitionCollection (ModuleDefinition container, int capacity)
			: base (capacity)
		{
			this.container = container;
			this.name_cache = new Dictionary<Slot, TypeDefinition> (capacity, new RowEqualityComparer ());
		}

		protected override void OnAdd (TypeDefinition item, int index)
		{
			Attach (item);
		}

		protected override void OnSet (TypeDefinition item, int index)
		{
			Attach (item);
		}

		protected override void OnInsert (TypeDefinition item, int index)
		{
			Attach (item);
		}

		protected override void OnRemove (TypeDefinition item, int index)
		{
			Detach (item);
		}

		protected override void OnClear ()
		{
			foreach (var type in this)
				Detach (type);
		}

		void Attach (TypeDefinition type)
		{
			if (type.Module != null && type.Module != container)
				throw new ArgumentException ("Type already attached");

			type.module = container;
			type.scope = container;
			name_cache [new Slot (type.Namespace, type.Name)] = type;
		}

		void Detach (TypeDefinition type)
		{
			type.module = null;
			type.scope = null;
			name_cache.Remove (new Slot (type.Namespace, type.Name));
		}

		public TypeDefinition GetType (string fullname)
		{
			string @namespace, name;
			TypeParser.SplitFullName (fullname, out @namespace, out name);

			return GetType (@namespace, name);
		}

		public TypeDefinition GetType (string @namespace, string name)
		{
			TypeDefinition type;
			if (name_cache.TryGetValue (new Slot (@namespace, name), out type))
				return type;

			return null;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeParser.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using System;
using System.Text;

namespace MonoFN.Cecil {

	class TypeParser {

		class Type {
			public const int Ptr = -1;
			public const int ByRef = -2;
			public const int SzArray = -3;

			public string type_fullname;
			public string [] nested_names;
			public int arity;
			public int [] specs;
			public Type [] generic_arguments;
			public string assembly;
		}

		readonly string fullname;
		readonly int length;

		int position;

		TypeParser (string fullname)
		{
			this.fullname = fullname;
			this.length = fullname.Length;
		}

		Type ParseType (bool fq_name)
		{
			var type = new Type ();
			type.type_fullname = ParsePart ();

			type.nested_names = ParseNestedNames ();

			if (TryGetArity (type))
				type.generic_arguments = ParseGenericArguments (type.arity);

			type.specs = ParseSpecs ();

			if (fq_name)
				type.assembly = ParseAssemblyName ();

			return type;
		}

		static bool TryGetArity (Type type)
		{
			int arity = 0;

			TryAddArity (type.type_fullname, ref arity);

			var nested_names = type.nested_names;
			if (!nested_names.IsNullOrEmpty ()) {
				for (int i = 0; i < nested_names.Length; i++)
					TryAddArity (nested_names [i], ref arity);
			}

			type.arity = arity;
			return arity > 0;
		}

		static bool TryGetArity (string name, out int arity)
		{
			arity = 0;
			var index = name.LastIndexOf ('`');
			if (index == -1)
				return false;

			return ParseInt32 (name.Substring (index + 1), out arity);
		}

		static bool ParseInt32 (string value, out int result)
		{
			return int.TryParse (value, out result);
		}

		static void TryAddArity (string name, ref int arity)
		{
			int type_arity;
			if (!TryGetArity (name, out type_arity))
				return;

			arity += type_arity;
		}

		string ParsePart ()
		{
			var part = new StringBuilder ();
			while (position < length && !IsDelimiter (fullname [position])) {
				if (fullname [position] == '\\')
					position++;

				part.Append (fullname [position++]);
			}

			return part.ToString ();
		}

		static bool IsDelimiter (char chr)
		{
			return "+,[]*&".IndexOf (chr) != -1;
		}

		void TryParseWhiteSpace ()
		{
			while (position < length && Char.IsWhiteSpace (fullname [position]))
				position++;
		}

		string [] ParseNestedNames ()
		{
			string [] nested_names = null;
			while (TryParse ('+'))
				Add (ref nested_names, ParsePart ());

			return nested_names;
		}

		bool TryParse (char chr)
		{
			if (position < length && fullname [position] == chr) {
				position++;
				return true;
			}

			return false;
		}

		static void Add<T> (ref T [] array, T item)
		{
			array = array.Add (item);
		}

		int [] ParseSpecs ()
		{
			int [] specs = null;

			while (position < length) {
				switch (fullname [position]) {
				case '*':
					position++;
					Add (ref specs, Type.Ptr);
					break;
				case '&':
					position++;
					Add (ref specs, Type.ByRef);
					break;
				case '[':
					position++;
					switch (fullname [position]) {
					case ']':
						position++;
						Add (ref specs, Type.SzArray);
						break;
					case '*':
						position++;
						Add (ref specs, 1);
						break;
					default:
						var rank = 1;
						while (TryParse (','))
							rank++;

						Add (ref specs, rank);

						TryParse (']');
						break;
					}
					break;
				default:
					return specs;
				}
			}

			return specs;
		}

		Type [] ParseGenericArguments (int arity)
		{
			Type [] generic_arguments = null;

			if (position == length || fullname [position] != '[')
				return generic_arguments;

			TryParse ('[');

			for (int i = 0; i < arity; i++) {
				var fq_argument = TryParse ('[');
				Add (ref generic_arguments, ParseType (fq_argument));
				if (fq_argument)
					TryParse (']');

				TryParse (',');
				TryParseWhiteSpace ();
			}

			TryParse (']');

			return generic_arguments;
		}

		string ParseAssemblyName ()
		{
			if (!TryParse (','))
				return string.Empty;

			TryParseWhiteSpace ();

			var start = position;
			while (position < length) {
				var chr = fullname [position];
				if (chr == '[' || chr == ']')
					break;

				position++;
			}

			return fullname.Substring (start, position - start);
		}

		public static TypeReference ParseType (ModuleDefinition module, string fullname, bool typeDefinitionOnly = false)
		{
			if (string.IsNullOrEmpty (fullname))
				return null;

			var parser = new TypeParser (fullname);
			return GetTypeReference (module, parser.ParseType (true), typeDefinitionOnly);
		}

		static TypeReference GetTypeReference (ModuleDefinition module, Type type_info, bool type_def_only)
		{
			TypeReference type;
			if (!TryGetDefinition (module, type_info, out type)) {
				if (type_def_only)
					return null;

				type = CreateReference (type_info, module, GetMetadataScope (module, type_info));
			}

			return CreateSpecs (type, type_info);
		}

		static TypeReference CreateSpecs (TypeReference type, Type type_info)
		{
			type = TryCreateGenericInstanceType (type, type_info);

			var specs = type_info.specs;
			if (specs.IsNullOrEmpty ())
				return type;

			for (int i = 0; i < specs.Length; i++) {
				switch (specs [i]) {
				case Type.Ptr:
					type = new PointerType (type);
					break;
				case Type.ByRef:
					type = new ByReferenceType (type);
					break;
				case Type.SzArray:
					type = new ArrayType (type);
					break;
				default:
					var array = new ArrayType (type);
					array.Dimensions.Clear ();

					for (int j = 0; j < specs [i]; j++)
						array.Dimensions.Add (new ArrayDimension ());

					type = array;
					break;
				}
			}

			return type;
		}

		static TypeReference TryCreateGenericInstanceType (TypeReference type, Type type_info)
		{
			var generic_arguments = type_info.generic_arguments;
			if (generic_arguments.IsNullOrEmpty ())
				return type;

			var instance = new GenericInstanceType (type, generic_arguments.Length);
			var instance_arguments = instance.GenericArguments;

			for (int i = 0; i < generic_arguments.Length; i++)
				instance_arguments.Add (GetTypeReference (type.Module, generic_arguments [i], false));

			return instance;
		}

		public static void SplitFullName (string fullname, out string @namespace, out string name)
		{
			var last_dot = fullname.LastIndexOf ('.');

			if (last_dot == -1) {
				@namespace = string.Empty;
				name = fullname;
			} else {
				@namespace = fullname.Substring (0, last_dot);
				name = fullname.Substring (last_dot + 1);
			}
		}

		static TypeReference CreateReference (Type type_info, ModuleDefinition module, IMetadataScope scope)
		{
			string @namespace, name;
			SplitFullName (type_info.type_fullname, out @namespace, out name);

			var type = new TypeReference (@namespace, name, module, scope);
			MetadataSystem.TryProcessPrimitiveTypeReference (type);

			AdjustGenericParameters (type);

			var nested_names = type_info.nested_names;
			if (nested_names.IsNullOrEmpty ())
				return type;

			for (int i = 0; i < nested_names.Length; i++) {
				type = new TypeReference (string.Empty, nested_names [i], module, null) {
					DeclaringType = type,
				};

				AdjustGenericParameters (type);
			}

			return type;
		}

		static void AdjustGenericParameters (TypeReference type)
		{
			int arity;
			if (!TryGetArity (type.Name, out arity))
				return;

			for (int i = 0; i < arity; i++)
				type.GenericParameters.Add (new GenericParameter (type));
		}

		static IMetadataScope GetMetadataScope (ModuleDefinition module, Type type_info)
		{
			if (string.IsNullOrEmpty (type_info.assembly))
				return module.TypeSystem.CoreLibrary;

			AssemblyNameReference match;
			var reference = AssemblyNameReference.Parse (type_info.assembly);

			return module.TryGetAssemblyNameReference (reference, out match)
				? match
				: reference;
		}

		static bool TryGetDefinition (ModuleDefinition module, Type type_info, out TypeReference type)
		{
			type = null;
			if (!TryCurrentModule (module, type_info))
				return false;

			var typedef = module.GetType (type_info.type_fullname);
			if (typedef == null)
				return false;

			var nested_names = type_info.nested_names;
			if (!nested_names.IsNullOrEmpty ()) {
				for (int i = 0; i < nested_names.Length; i++) {
					var nested_type = typedef.GetNestedType (nested_names [i]);
					if (nested_type == null)
						return false;

					typedef = nested_type;
				}
			}

			type = typedef;
			return true;
		}

		static bool TryCurrentModule (ModuleDefinition module, Type type_info)
		{
			if (string.IsNullOrEmpty (type_info.assembly))
				return true;

			if (module.assembly != null && module.assembly.Name.FullName == type_info.assembly)
				return true;

			return false;
		}

		public static string ToParseable (TypeReference type, bool top_level = true)
		{
			if (type == null)
				return null;

			var name = new StringBuilder ();
			AppendType (type, name, true, top_level);
			return name.ToString ();
		}

		static void AppendNamePart (string part, StringBuilder name)
		{
			foreach (var c in part) {
				if (IsDelimiter (c))
					name.Append ('\\');

				name.Append (c);
			}
		}

		static void AppendType (TypeReference type, StringBuilder name, bool fq_name, bool top_level)
		{
			var element_type = type.GetElementType ();

			var declaring_type = element_type.DeclaringType;
			if (declaring_type != null) {
				AppendType (declaring_type, name, false, top_level);
				name.Append ('+');
			}

			var @namespace = type.Namespace;
			if (!string.IsNullOrEmpty (@namespace)) {
				AppendNamePart (@namespace, name);
				name.Append ('.');
			}

			AppendNamePart (element_type.Name, name);

			if (!fq_name)
				return;

			if (type.IsTypeSpecification ())
				AppendTypeSpecification ((TypeSpecification)type, name);

			if (RequiresFullyQualifiedName (type, top_level)) {
				name.Append (", ");
				name.Append (GetScopeFullName (type));
			}
		}

		static string GetScopeFullName (TypeReference type)
		{
			var scope = type.Scope;
			switch (scope.MetadataScopeType) {
			case MetadataScopeType.AssemblyNameReference:
				return ((AssemblyNameReference)scope).FullName;
			case MetadataScopeType.ModuleDefinition:
				return ((ModuleDefinition)scope).Assembly.Name.FullName;
			}

			throw new ArgumentException ();
		}

		static void AppendTypeSpecification (TypeSpecification type, StringBuilder name)
		{
			if (type.ElementType.IsTypeSpecification ())
				AppendTypeSpecification ((TypeSpecification)type.ElementType, name);

			switch (type.etype) {
			case ElementType.Ptr:
				name.Append ('*');
				break;
			case ElementType.ByRef:
				name.Append ('&');
				break;
			case ElementType.SzArray:
			case ElementType.Array:
				var array = (ArrayType)type;
				if (array.IsVector) {
					name.Append ("[]");
				} else {
					name.Append ('[');
					for (int i = 1; i < array.Rank; i++)
						name.Append (',');
					name.Append (']');
				}
				break;
			case ElementType.GenericInst:
				var instance = (GenericInstanceType)type;
				var arguments = instance.GenericArguments;

				name.Append ('[');

				for (int i = 0; i < arguments.Count; i++) {
					if (i > 0)
						name.Append (',');

					var argument = arguments [i];
					var requires_fqname = argument.Scope != argument.Module;

					if (requires_fqname)
						name.Append ('[');

					AppendType (argument, name, true, false);

					if (requires_fqname)
						name.Append (']');
				}

				name.Append (']');
				break;
			default:
				return;
			}
		}

		static bool RequiresFullyQualifiedName (TypeReference type, bool top_level)
		{
			if (type.Scope == type.Module)
				return false;

			if (type.Scope.Name == "mscorlib" && top_level)
				return false;

			return true;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeReference.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using MonoFN.Collections.Generic;
using System;
using System.Threading;

namespace MonoFN.Cecil {

	public enum MetadataType : byte {
		Void = ElementType.Void,
		Boolean = ElementType.Boolean,
		Char = ElementType.Char,
		SByte = ElementType.I1,
		Byte = ElementType.U1,
		Int16 = ElementType.I2,
		UInt16 = ElementType.U2,
		Int32 = ElementType.I4,
		UInt32 = ElementType.U4,
		Int64 = ElementType.I8,
		UInt64 = ElementType.U8,
		Single = ElementType.R4,
		Double = ElementType.R8,
		String = ElementType.String,
		Pointer = ElementType.Ptr,
		ByReference = ElementType.ByRef,
		ValueType = ElementType.ValueType,
		Class = ElementType.Class,
		Var = ElementType.Var,
		Array = ElementType.Array,
		GenericInstance = ElementType.GenericInst,
		TypedByReference = ElementType.TypedByRef,
		IntPtr = ElementType.I,
		UIntPtr = ElementType.U,
		FunctionPointer = ElementType.FnPtr,
		Object = ElementType.Object,
		MVar = ElementType.MVar,
		RequiredModifier = ElementType.CModReqD,
		OptionalModifier = ElementType.CModOpt,
		Sentinel = ElementType.Sentinel,
		Pinned = ElementType.Pinned,
	}

	public class TypeReference : MemberReference, IGenericParameterProvider, IGenericContext {

		string @namespace;
		bool value_type;
		internal IMetadataScope scope;
		internal ModuleDefinition module;

		internal ElementType etype = ElementType.None;

		string fullname;

		protected Collection<GenericParameter> generic_parameters;

		public override string Name {
			get { return base.Name; }
			set {
				if (IsWindowsRuntimeProjection && value != base.Name)
					throw new InvalidOperationException ("Projected type reference name can't be changed.");
				base.Name = value;
				ClearFullName ();
			}
		}

		public virtual string Namespace {
			get { return @namespace; }
			set {
				if (IsWindowsRuntimeProjection && value != @namespace)
					throw new InvalidOperationException ("Projected type reference namespace can't be changed.");
				@namespace = value;
				ClearFullName ();
			}
		}

		public virtual bool IsValueType {
			get { return value_type; }
			set { value_type = value; }
		}

		public override ModuleDefinition Module {
			get {
				if (module != null)
					return module;

				var declaring_type = this.DeclaringType;
				if (declaring_type != null)
					return declaring_type.Module;

				return null;
			}
		}

		internal TypeReferenceProjection WindowsRuntimeProjection {
			get { return (TypeReferenceProjection)projection; }
			set { projection = value; }
		}

		IGenericParameterProvider IGenericContext.Type {
			get { return this; }
		}

		IGenericParameterProvider IGenericContext.Method {
			get { return null; }
		}

		GenericParameterType IGenericParameterProvider.GenericParameterType {
			get { return GenericParameterType.Type; }
		}

		public virtual bool HasGenericParameters {
			get { return !generic_parameters.IsNullOrEmpty (); }
		}

		public virtual Collection<GenericParameter> GenericParameters {
			get {
				if (generic_parameters == null)
					Interlocked.CompareExchange (ref generic_parameters, new GenericParameterCollection (this), null);

				return generic_parameters;
			}
		}

		public virtual IMetadataScope Scope {
			get {
				var declaring_type = this.DeclaringType;
				if (declaring_type != null)
					return declaring_type.Scope;

				return scope;
			}
			set {
				var declaring_type = this.DeclaringType;
				if (declaring_type != null) {
					if (IsWindowsRuntimeProjection && value != declaring_type.Scope)
						throw new InvalidOperationException ("Projected type scope can't be changed.");
					declaring_type.Scope = value;
					return;
				}

				if (IsWindowsRuntimeProjection && value != scope)
					throw new InvalidOperationException ("Projected type scope can't be changed.");
				scope = value;
			}
		}

		public bool IsNested {
			get { return this.DeclaringType != null; }
		}

		public override TypeReference DeclaringType {
			get { return base.DeclaringType; }
			set {
				if (IsWindowsRuntimeProjection && value != base.DeclaringType)
					throw new InvalidOperationException ("Projected type declaring type can't be changed.");
				base.DeclaringType = value;
				ClearFullName ();
			}
		}

		public override string FullName {
			get {
				if (fullname != null)
					return fullname;

				var new_fullname = this.TypeFullName ();

				if (IsNested)
					new_fullname = DeclaringType.FullName + "/" + new_fullname;
				Interlocked.CompareExchange (ref fullname, new_fullname, null);
				return fullname;
			}
		}

		public virtual bool IsByReference {
			get { return false; }
		}

		public virtual bool IsPointer {
			get { return false; }
		}

		public virtual bool IsSentinel {
			get { return false; }
		}

		public virtual bool IsArray {
			get { return false; }
		}

		public virtual bool IsGenericParameter {
			get { return false; }
		}

		public virtual bool IsGenericInstance {
			get { return false; }
		}

		public virtual bool IsRequiredModifier {
			get { return false; }
		}

		public virtual bool IsOptionalModifier {
			get { return false; }
		}

		public virtual bool IsPinned {
			get { return false; }
		}

		public virtual bool IsFunctionPointer {
			get { return false; }
		}

		public virtual bool IsPrimitive {
			get { return etype.IsPrimitive (); }
		}

		public virtual MetadataType MetadataType {
			get {
				switch (etype) {
				case ElementType.None:
					return IsValueType ? MetadataType.ValueType : MetadataType.Class;
				default:
					return (MetadataType)etype;
				}
			}
		}

		protected TypeReference (string @namespace, string name)
			: base (name)
		{
			this.@namespace = @namespace ?? string.Empty;
			this.token = new MetadataToken (TokenType.TypeRef, 0);
		}

		public TypeReference (string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
			: this (@namespace, name)
		{
			this.module = module;
			this.scope = scope;
		}

		public TypeReference (string @namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType) :
			this (@namespace, name, module, scope)
		{
			value_type = valueType;
		}

		protected virtual void ClearFullName ()
		{
			this.fullname = null;
		}

		public virtual TypeReference GetElementType ()
		{
			return this;
		}

		protected override IMemberDefinition ResolveDefinition ()
		{
			return this.Resolve ();
		}

		public new virtual TypeDefinition Resolve ()
		{
			var module = this.Module;
			if (module == null)
				throw new NotSupportedException ();

			return module.Resolve (this);
		}
	}

	static partial class Mixin {

		public static bool IsPrimitive (this ElementType self)
		{
			switch (self) {
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I:
			case ElementType.U:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
				return true;
			default:
				return false;
			}
		}

		public static string TypeFullName (this TypeReference self)
		{
			return string.IsNullOrEmpty (self.Namespace)
				? self.Name
				: self.Namespace + '.' + self.Name;
		}

		public static bool IsTypeOf (this TypeReference self, string @namespace, string name)
		{
			return self.Name == name
				&& self.Namespace == @namespace;
		}

		public static bool IsTypeSpecification (this TypeReference type)
		{
			switch (type.etype) {
			case ElementType.Array:
			case ElementType.ByRef:
			case ElementType.CModOpt:
			case ElementType.CModReqD:
			case ElementType.FnPtr:
			case ElementType.GenericInst:
			case ElementType.MVar:
			case ElementType.Pinned:
			case ElementType.Ptr:
			case ElementType.SzArray:
			case ElementType.Sentinel:
			case ElementType.Var:
				return true;
			}

			return false;
		}

		public static TypeDefinition CheckedResolve (this TypeReference self)
		{
			var type = self.Resolve ();
			if (type == null)
				throw new ResolutionException (self);

			return type;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeReferenceEqualityComparer.cs ---
﻿using System;
using System.Collections.Generic;

namespace MonoFN.Cecil {
	internal sealed class TypeReferenceEqualityComparer : EqualityComparer<TypeReference> {
		public override bool Equals (TypeReference x, TypeReference y)
		{
			return AreEqual (x, y);
		}

		public override int GetHashCode (TypeReference obj)
		{
			return GetHashCodeFor (obj);
		}

		public static bool AreEqual (TypeReference a, TypeReference b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
		{
			if (ReferenceEquals (a, b))
				return true;

			if (a == null || b == null)
				return false;

			var aMetadataType = a.MetadataType;
			var bMetadataType = b.MetadataType;

			if (aMetadataType == MetadataType.GenericInstance || bMetadataType == MetadataType.GenericInstance) {
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual ((GenericInstanceType)a, (GenericInstanceType)b, comparisonMode);
			}

			if (aMetadataType == MetadataType.Array || bMetadataType == MetadataType.Array) {
				if (aMetadataType != bMetadataType)
					return false;

				var a1 = (ArrayType)a;
				var b1 = (ArrayType)b;
				if (a1.Rank != b1.Rank)
					return false;

				return AreEqual (a1.ElementType, b1.ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.Var || bMetadataType == MetadataType.Var) {
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual ((GenericParameter)a, (GenericParameter)b, comparisonMode);
			}

			if (aMetadataType == MetadataType.MVar || bMetadataType == MetadataType.MVar) {
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual ((GenericParameter)a, (GenericParameter)b, comparisonMode);
			}

			if (aMetadataType == MetadataType.ByReference || bMetadataType == MetadataType.ByReference) {
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual (((ByReferenceType)a).ElementType, ((ByReferenceType)b).ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.Pointer || bMetadataType == MetadataType.Pointer) {
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual (((PointerType)a).ElementType, ((PointerType)b).ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.RequiredModifier || bMetadataType == MetadataType.RequiredModifier) {
				if (aMetadataType != bMetadataType)
					return false;

				var a1 = (RequiredModifierType)a;
				var b1 = (RequiredModifierType)b;

				return AreEqual (a1.ModifierType, b1.ModifierType, comparisonMode) && AreEqual (a1.ElementType, b1.ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.OptionalModifier || bMetadataType == MetadataType.OptionalModifier) {
				if (aMetadataType != bMetadataType)
					return false;

				var a1 = (OptionalModifierType)a;
				var b1 = (OptionalModifierType)b;

				return AreEqual (a1.ModifierType, b1.ModifierType, comparisonMode) && AreEqual (a1.ElementType, b1.ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.Pinned || bMetadataType == MetadataType.Pinned) {
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual (((PinnedType)a).ElementType, ((PinnedType)b).ElementType, comparisonMode);
			}

			if (aMetadataType == MetadataType.Sentinel || bMetadataType == MetadataType.Sentinel) {
				if (aMetadataType != bMetadataType)
					return false;

				return AreEqual (((SentinelType)a).ElementType, ((SentinelType)b).ElementType, comparisonMode);
			}

			if (!a.Name.Equals (b.Name) || !a.Namespace.Equals (b.Namespace))
				return false;

			var xDefinition = a.Resolve ();
			var yDefinition = b.Resolve ();

			// For loose signature the types could be in different assemblies, as long as the type names match we will consider them equal
			if (comparisonMode == TypeComparisonMode.SignatureOnlyLoose) {
				if (xDefinition.Module.Name != yDefinition.Module.Name)
					return false;

				if (xDefinition.Module.Assembly.Name.Name != yDefinition.Module.Assembly.Name.Name)
					return false;

				return xDefinition.FullName == yDefinition.FullName;
			}

			return xDefinition == yDefinition;
		}

		static bool AreEqual (GenericParameter a, GenericParameter b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
		{
			if (ReferenceEquals (a, b))
				return true;

			if (a.Position != b.Position)
				return false;

			if (a.Type != b.Type)
				return false;

			var aOwnerType = a.Owner as TypeReference;
			if (aOwnerType != null && AreEqual (aOwnerType, b.Owner as TypeReference, comparisonMode))
				return true;

			var aOwnerMethod = a.Owner as MethodReference;
			if (aOwnerMethod != null && comparisonMode != TypeComparisonMode.SignatureOnlyLoose && MethodReferenceComparer.AreEqual (aOwnerMethod, b.Owner as MethodReference))
				return true;

			return comparisonMode == TypeComparisonMode.SignatureOnly || comparisonMode == TypeComparisonMode.SignatureOnlyLoose;
		}

		static bool AreEqual (GenericInstanceType a, GenericInstanceType b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
		{
			if (ReferenceEquals (a, b))
				return true;

			var aGenericArgumentsCount = a.GenericArguments.Count;
			if (aGenericArgumentsCount != b.GenericArguments.Count)
				return false;

			if (!AreEqual (a.ElementType, b.ElementType, comparisonMode))
				return false;

			for (int i = 0; i < aGenericArgumentsCount; i++)
				if (!AreEqual (a.GenericArguments [i], b.GenericArguments [i], comparisonMode))
					return false;

			return true;
		}

		public static int GetHashCodeFor (TypeReference obj)
		{
			// a very good prime number
			const int hashCodeMultiplier = 486187739;
			// prime numbers
			const int genericInstanceTypeMultiplier = 31;
			const int byReferenceMultiplier = 37;
			const int pointerMultiplier = 41;
			const int requiredModifierMultiplier = 43;
			const int optionalModifierMultiplier = 47;
			const int pinnedMultiplier = 53;
			const int sentinelMultiplier = 59;

			var metadataType = obj.MetadataType;

			if (metadataType == MetadataType.GenericInstance) {
				var genericInstanceType = (GenericInstanceType)obj;
				var hashCode = GetHashCodeFor (genericInstanceType.ElementType) * hashCodeMultiplier + genericInstanceTypeMultiplier;
				for (var i = 0; i < genericInstanceType.GenericArguments.Count; i++)
					hashCode = hashCode * hashCodeMultiplier + GetHashCodeFor (genericInstanceType.GenericArguments [i]);
				return hashCode;
			}

			if (metadataType == MetadataType.Array) {
				var arrayType = (ArrayType)obj;
				return GetHashCodeFor (arrayType.ElementType) * hashCodeMultiplier + arrayType.Rank.GetHashCode ();
			}

			if (metadataType == MetadataType.Var || metadataType == MetadataType.MVar) {
				var genericParameter = (GenericParameter)obj;
				var hashCode = genericParameter.Position.GetHashCode () * hashCodeMultiplier + ((int)metadataType).GetHashCode ();

				var ownerTypeReference = genericParameter.Owner as TypeReference;
				if (ownerTypeReference != null)
					return hashCode * hashCodeMultiplier + GetHashCodeFor (ownerTypeReference);

				var ownerMethodReference = genericParameter.Owner as MethodReference;
				if (ownerMethodReference != null)
					return hashCode * hashCodeMultiplier + MethodReferenceComparer.GetHashCodeFor (ownerMethodReference);

				throw new InvalidOperationException ("Generic parameter encountered with invalid owner");
			}

			if (metadataType == MetadataType.ByReference) {
				var byReferenceType = (ByReferenceType)obj;
				return GetHashCodeFor (byReferenceType.ElementType) * hashCodeMultiplier * byReferenceMultiplier;
			}

			if (metadataType == MetadataType.Pointer) {
				var pointerType = (PointerType)obj;
				return GetHashCodeFor (pointerType.ElementType) * hashCodeMultiplier * pointerMultiplier;
			}

			if (metadataType == MetadataType.RequiredModifier) {
				var requiredModifierType = (RequiredModifierType)obj;
				var hashCode = GetHashCodeFor (requiredModifierType.ElementType) * requiredModifierMultiplier;
				hashCode = hashCode * hashCodeMultiplier + GetHashCodeFor (requiredModifierType.ModifierType);
				return hashCode;
			}

			if (metadataType == MetadataType.OptionalModifier) {
				var optionalModifierType = (OptionalModifierType)obj;
				var hashCode = GetHashCodeFor (optionalModifierType.ElementType) * optionalModifierMultiplier;
				hashCode = hashCode * hashCodeMultiplier + GetHashCodeFor (optionalModifierType.ModifierType);
				return hashCode;
			}

			if (metadataType == MetadataType.Pinned) {
				var pinnedType = (PinnedType)obj;
				return GetHashCodeFor (pinnedType.ElementType) * hashCodeMultiplier * pinnedMultiplier;
			}

			if (metadataType == MetadataType.Sentinel) {
				var sentinelType = (SentinelType)obj;
				return GetHashCodeFor (sentinelType.ElementType) * hashCodeMultiplier * sentinelMultiplier;
			}

			if (metadataType == MetadataType.FunctionPointer) {
				throw new NotImplementedException ("We currently don't handle function pointer types.");
			}

			return obj.Namespace.GetHashCode () * hashCodeMultiplier + obj.FullName.GetHashCode ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeResolver.cs ---
﻿using MonoFN.Cecil.Cil;
using System;

namespace MonoFN.Cecil {
	internal sealed class TypeResolver {
		private readonly IGenericInstance _typeDefinitionContext;
		private readonly IGenericInstance _methodDefinitionContext;

		public static TypeResolver For (TypeReference typeReference)
		{
			return typeReference.IsGenericInstance ? new TypeResolver ((GenericInstanceType)typeReference) : new TypeResolver ();
		}

		public static TypeResolver For (TypeReference typeReference, MethodReference methodReference)
		{
			return new TypeResolver (typeReference as GenericInstanceType, methodReference as GenericInstanceMethod);
		}

		public TypeResolver ()
		{

		}

		public TypeResolver (GenericInstanceType typeDefinitionContext)
		{
			_typeDefinitionContext = typeDefinitionContext;
		}

		public TypeResolver (GenericInstanceMethod methodDefinitionContext)
		{
			_methodDefinitionContext = methodDefinitionContext;
		}

		public TypeResolver (GenericInstanceType typeDefinitionContext, GenericInstanceMethod methodDefinitionContext)
		{
			_typeDefinitionContext = typeDefinitionContext;
			_methodDefinitionContext = methodDefinitionContext;
		}

		public MethodReference Resolve (MethodReference method)
		{
			var methodReference = method;
			if (IsDummy ())
				return methodReference;

			var declaringType = Resolve (method.DeclaringType);

			var genericInstanceMethod = method as GenericInstanceMethod;
			if (genericInstanceMethod != null) {
				methodReference = new MethodReference (method.Name, method.ReturnType, declaringType);

				foreach (var p in method.Parameters)
					methodReference.Parameters.Add (new ParameterDefinition (p.Name, p.Attributes, p.ParameterType));

				foreach (var gp in genericInstanceMethod.ElementMethod.GenericParameters)
					methodReference.GenericParameters.Add (new GenericParameter (gp.Name, methodReference));

				methodReference.HasThis = method.HasThis;

				var m = new GenericInstanceMethod (methodReference);
				foreach (var ga in genericInstanceMethod.GenericArguments) {
					m.GenericArguments.Add (Resolve (ga));
				}

				methodReference = m;
			} else {
				methodReference = new MethodReference (method.Name, method.ReturnType, declaringType);

				foreach (var gp in method.GenericParameters)
					methodReference.GenericParameters.Add (new GenericParameter (gp.Name, methodReference));

				foreach (var p in method.Parameters)
					methodReference.Parameters.Add (new ParameterDefinition (p.Name, p.Attributes, p.ParameterType));

				methodReference.HasThis = method.HasThis;
			}

			return methodReference;
		}

		public FieldReference Resolve (FieldReference field)
		{
			var declaringType = Resolve (field.DeclaringType);

			if (declaringType == field.DeclaringType)
				return field;

			return new FieldReference (field.Name, field.FieldType, declaringType);
		}

		public TypeReference ResolveReturnType (MethodReference method)
		{
			return Resolve (GenericParameterResolver.ResolveReturnTypeIfNeeded (method));
		}

		public TypeReference ResolveParameterType (MethodReference method, ParameterReference parameter)
		{
			return Resolve (GenericParameterResolver.ResolveParameterTypeIfNeeded (method, parameter));
		}

		public TypeReference ResolveVariableType (MethodReference method, VariableReference variable)
		{
			return Resolve (GenericParameterResolver.ResolveVariableTypeIfNeeded (method, variable));
		}

		public TypeReference ResolveFieldType (FieldReference field)
		{
			return Resolve (GenericParameterResolver.ResolveFieldTypeIfNeeded (field));
		}

		public TypeReference Resolve (TypeReference typeReference)
		{
			return Resolve (typeReference, true);
		}

		public TypeReference Resolve (TypeReference typeReference, bool includeTypeDefinitions)
		{
			if (IsDummy ())
				return typeReference;

			if (_typeDefinitionContext != null && _typeDefinitionContext.GenericArguments.Contains (typeReference))
				return typeReference;
			if (_methodDefinitionContext != null && _methodDefinitionContext.GenericArguments.Contains (typeReference))
				return typeReference;

			var genericParameter = typeReference as GenericParameter;
			if (genericParameter != null) {
				if (_typeDefinitionContext != null && _typeDefinitionContext.GenericArguments.Contains (genericParameter))
					return genericParameter;
				if (_methodDefinitionContext != null && _methodDefinitionContext.GenericArguments.Contains (genericParameter))
					return genericParameter;
				return ResolveGenericParameter (genericParameter);
			}

			var arrayType = typeReference as ArrayType;
			if (arrayType != null)
				return new ArrayType (Resolve (arrayType.ElementType), arrayType.Rank);

			var pointerType = typeReference as PointerType;
			if (pointerType != null)
				return new PointerType (Resolve (pointerType.ElementType));

			var byReferenceType = typeReference as ByReferenceType;
			if (byReferenceType != null)
				return new ByReferenceType (Resolve (byReferenceType.ElementType));

			var pinnedType = typeReference as PinnedType;
			if (pinnedType != null)
				return new PinnedType (Resolve (pinnedType.ElementType));

			var genericInstanceType = typeReference as GenericInstanceType;
			if (genericInstanceType != null) {
				var newGenericInstanceType = new GenericInstanceType (genericInstanceType.ElementType);
				foreach (var genericArgument in genericInstanceType.GenericArguments)
					newGenericInstanceType.GenericArguments.Add (Resolve (genericArgument));
				return newGenericInstanceType;
			}

			var requiredModType = typeReference as RequiredModifierType;
			if (requiredModType != null)
				return Resolve (requiredModType.ElementType, includeTypeDefinitions);

			if (includeTypeDefinitions) {
				var typeDefinition = typeReference as TypeDefinition;
				if (typeDefinition != null && typeDefinition.HasGenericParameters) {
					var newGenericInstanceType = new GenericInstanceType (typeDefinition);
					foreach (var gp in typeDefinition.GenericParameters)
						newGenericInstanceType.GenericArguments.Add (Resolve (gp));
					return newGenericInstanceType;
				}
			}

			if (typeReference is TypeSpecification)
				throw new NotSupportedException (string.Format ("The type {0} cannot be resolved correctly.", typeReference.FullName));

			return typeReference;
		}

		internal TypeResolver Nested (GenericInstanceMethod genericInstanceMethod)
		{
			return new TypeResolver (_typeDefinitionContext as GenericInstanceType, genericInstanceMethod);
		}

		private TypeReference ResolveGenericParameter (GenericParameter genericParameter)
		{
			if (genericParameter.Owner == null)
				return HandleOwnerlessInvalidILCode (genericParameter);

			var memberReference = genericParameter.Owner as MemberReference;
			if (memberReference == null)
				throw new NotSupportedException ();

			return genericParameter.Type == GenericParameterType.Type
				? _typeDefinitionContext.GenericArguments [genericParameter.Position]
				: (_methodDefinitionContext != null ? _methodDefinitionContext.GenericArguments [genericParameter.Position] : genericParameter);
		}

		private TypeReference HandleOwnerlessInvalidILCode (GenericParameter genericParameter)
		{
			// NOTE: If owner is null and we have a method parameter, then we'll assume that the method parameter
			// is actually a type parameter, and we'll use the type parameter from the corresponding position. I think
			// this assumption is valid, but if you're visiting this code then I might have been proven wrong.
			if (genericParameter.Type == GenericParameterType.Method && (_typeDefinitionContext != null && genericParameter.Position < _typeDefinitionContext.GenericArguments.Count))
				return _typeDefinitionContext.GenericArguments [genericParameter.Position];

			// NOTE: Owner cannot be null, but sometimes the Mono compiler generates invalid IL and we
			// end up in this situation.
			// When we do, we assume that the runtime doesn't care about the resolved type of the GenericParameter,
			// thus we return a reference to System.Object.
			return genericParameter.Module.TypeSystem.Object;
		}

		private bool IsDummy ()
		{
			return _typeDefinitionContext == null && _methodDefinitionContext == null;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeSpecification.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil {

	public abstract class TypeSpecification : TypeReference {

		readonly TypeReference element_type;

		public TypeReference ElementType {
			get { return element_type; }
		}

		public override string Name {
			get { return element_type.Name; }
			set { throw new InvalidOperationException (); }
		}

		public override string Namespace {
			get { return element_type.Namespace; }
			set { throw new InvalidOperationException (); }
		}

		public override IMetadataScope Scope {
			get { return element_type.Scope; }
			set { throw new InvalidOperationException (); }
		}

		public override ModuleDefinition Module {
			get { return element_type.Module; }
		}

		public override string FullName {
			get { return element_type.FullName; }
		}

		public override bool ContainsGenericParameter {
			get { return element_type.ContainsGenericParameter; }
		}

		public override MetadataType MetadataType {
			get { return (MetadataType)etype; }
		}

		internal TypeSpecification (TypeReference type)
			: base (null, null)
		{
			this.element_type = type;
			this.token = new MetadataToken (TokenType.TypeSpec);
		}

		public override TypeReference GetElementType ()
		{
			return element_type.GetElementType ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/TypeSystem.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Metadata;
using System;

namespace MonoFN.Cecil {

	public abstract class TypeSystem {

		sealed class CoreTypeSystem : TypeSystem {

			public CoreTypeSystem (ModuleDefinition module)
				: base (module)
			{
			}

			internal override TypeReference LookupType (string @namespace, string name)
			{
				var type = LookupTypeDefinition (@namespace, name) ?? LookupTypeForwarded (@namespace, name);
				if (type != null)
					return type;

				throw new NotSupportedException ();
			}

			TypeReference LookupTypeDefinition (string @namespace, string name)
			{
				var metadata = module.MetadataSystem;
				if (metadata.Types == null)
					Initialize (module.Types);

				return module.Read (new Row<string, string> (@namespace, name), (row, reader) => {
					var types = reader.metadata.Types;

					for (int i = 0; i < types.Length; i++) {
						if (types [i] == null)
							types [i] = reader.GetTypeDefinition ((uint)i + 1);

						var type = types [i];

						if (type.Name == row.Col2 && type.Namespace == row.Col1)
							return type;
					}

					return null;
				});
			}

			TypeReference LookupTypeForwarded (string @namespace, string name)
			{
				if (!module.HasExportedTypes)
					return null;

				var exported_types = module.ExportedTypes;
				for (int i = 0; i < exported_types.Count; i++) {
					var exported_type = exported_types [i];

					if (exported_type.Name == name && exported_type.Namespace == @namespace)
						return exported_type.CreateReference ();
				}

				return null;
			}

			static void Initialize (object obj)
			{
			}
		}

		sealed class CommonTypeSystem : TypeSystem {

			AssemblyNameReference core_library;

			public CommonTypeSystem (ModuleDefinition module)
				: base (module)
			{
			}

			internal override TypeReference LookupType (string @namespace, string name)
			{
				return CreateTypeReference (@namespace, name);
			}

			public AssemblyNameReference GetCoreLibraryReference ()
			{
				if (core_library != null)
					return core_library;

				if (module.TryGetCoreLibraryReference (out core_library))
					return core_library;

				core_library = new AssemblyNameReference {
					Name = Mixin.mscorlib,
					Version = GetCorlibVersion (),
					PublicKeyToken = new byte [] { 0xb7, 0x7a, 0x5c, 0x56, 0x19, 0x34, 0xe0, 0x89 },
				};

				module.AssemblyReferences.Add (core_library);

				return core_library;
			}

			Version GetCorlibVersion ()
			{
				switch (module.Runtime) {
				case TargetRuntime.Net_1_0:
				case TargetRuntime.Net_1_1:
					return new Version (1, 0, 0, 0);
				case TargetRuntime.Net_2_0:
					return new Version (2, 0, 0, 0);
				case TargetRuntime.Net_4_0:
					return new Version (4, 0, 0, 0);
				default:
					throw new NotSupportedException ();
				}
			}

			TypeReference CreateTypeReference (string @namespace, string name)
			{
				return new TypeReference (@namespace, name, module, GetCoreLibraryReference ());
			}
		}

		readonly ModuleDefinition module;

		TypeReference type_object;
		TypeReference type_void;
		TypeReference type_bool;
		TypeReference type_char;
		TypeReference type_sbyte;
		TypeReference type_byte;
		TypeReference type_int16;
		TypeReference type_uint16;
		TypeReference type_int32;
		TypeReference type_uint32;
		TypeReference type_int64;
		TypeReference type_uint64;
		TypeReference type_single;
		TypeReference type_double;
		TypeReference type_intptr;
		TypeReference type_uintptr;
		TypeReference type_string;
		TypeReference type_typedref;

		TypeSystem (ModuleDefinition module)
		{
			this.module = module;
		}

		internal static TypeSystem CreateTypeSystem (ModuleDefinition module)
		{
			if (module.IsCoreLibrary ())
				return new CoreTypeSystem (module);

			return new CommonTypeSystem (module);
		}

		internal abstract TypeReference LookupType (string @namespace, string name);

		TypeReference LookupSystemType (ref TypeReference reference, string name, ElementType element_type)
		{
			lock (module.SyncRoot) {
				if (reference != null)
					return reference;
				var type = LookupType ("System", name);
				type.etype = element_type;
				return reference = type;
			}
		}

		TypeReference LookupSystemValueType (ref TypeReference typeRef, string name, ElementType element_type)
		{
			lock (module.SyncRoot) {
				if (typeRef != null)
					return typeRef;
				var type = LookupType ("System", name);
				type.etype = element_type;
				type.KnownValueType ();
				return typeRef = type;
			}
		}

		[Obsolete ("Use CoreLibrary")]
		public IMetadataScope Corlib {
			get { return CoreLibrary; }
		}

		public IMetadataScope CoreLibrary {
			get {
				var common = this as CommonTypeSystem;
				if (common == null)
					return module;

				return common.GetCoreLibraryReference ();
			}
		}

		public TypeReference Object {
			get { return type_object ?? (LookupSystemType (ref type_object, "Object", ElementType.Object)); }
		}

		public TypeReference Void {
			get { return type_void ?? (LookupSystemType (ref type_void, "Void", ElementType.Void)); }
		}

		public TypeReference Boolean {
			get { return type_bool ?? (LookupSystemValueType (ref type_bool, "Boolean", ElementType.Boolean)); }
		}

		public TypeReference Char {
			get { return type_char ?? (LookupSystemValueType (ref type_char, "Char", ElementType.Char)); }
		}

		public TypeReference SByte {
			get { return type_sbyte ?? (LookupSystemValueType (ref type_sbyte, "SByte", ElementType.I1)); }
		}

		public TypeReference Byte {
			get { return type_byte ?? (LookupSystemValueType (ref type_byte, "Byte", ElementType.U1)); }
		}

		public TypeReference Int16 {
			get { return type_int16 ?? (LookupSystemValueType (ref type_int16, "Int16", ElementType.I2)); }
		}

		public TypeReference UInt16 {
			get { return type_uint16 ?? (LookupSystemValueType (ref type_uint16, "UInt16", ElementType.U2)); }
		}

		public TypeReference Int32 {
			get { return type_int32 ?? (LookupSystemValueType (ref type_int32, "Int32", ElementType.I4)); }
		}

		public TypeReference UInt32 {
			get { return type_uint32 ?? (LookupSystemValueType (ref type_uint32, "UInt32", ElementType.U4)); }
		}

		public TypeReference Int64 {
			get { return type_int64 ?? (LookupSystemValueType (ref type_int64, "Int64", ElementType.I8)); }
		}

		public TypeReference UInt64 {
			get { return type_uint64 ?? (LookupSystemValueType (ref type_uint64, "UInt64", ElementType.U8)); }
		}

		public TypeReference Single {
			get { return type_single ?? (LookupSystemValueType (ref type_single, "Single", ElementType.R4)); }
		}

		public TypeReference Double {
			get { return type_double ?? (LookupSystemValueType (ref type_double, "Double", ElementType.R8)); }
		}

		public TypeReference IntPtr {
			get { return type_intptr ?? (LookupSystemValueType (ref type_intptr, "IntPtr", ElementType.I)); }
		}

		public TypeReference UIntPtr {
			get { return type_uintptr ?? (LookupSystemValueType (ref type_uintptr, "UIntPtr", ElementType.U)); }
		}

		public TypeReference String {
			get { return type_string ?? (LookupSystemType (ref type_string, "String", ElementType.String)); }
		}

		public TypeReference TypedReference {
			get { return type_typedref ?? (LookupSystemValueType (ref type_typedref, "TypedReference", ElementType.TypedByRef)); }
		}
	}

	static partial class Mixin {

		public const string mscorlib = "mscorlib";
		public const string system_runtime = "System.Runtime";
		public const string system_private_corelib = "System.Private.CoreLib";
		public const string netstandard = "netstandard";

		public static bool TryGetCoreLibraryReference (this ModuleDefinition module, out AssemblyNameReference reference)
		{
			var references = module.AssemblyReferences;

			for (int i = 0; i < references.Count; i++) {
				reference = references [i];
				if (IsCoreLibrary (reference))
					return true;
			}

			reference = null;
			return false;

		}

		public static bool IsCoreLibrary (this ModuleDefinition module)
		{
			if (module.Assembly == null)
				return false;

			if (!IsCoreLibrary (module.Assembly.Name))
				return false;

			if (module.HasImage && module.Read (module, (m, reader) => reader.image.GetTableLength (Table.AssemblyRef) > 0))
				return false;

			return true;
		}

		public static void KnownValueType (this TypeReference type)
		{
			if (!type.IsDefinition)
				type.IsValueType = true;
		}

		static bool IsCoreLibrary (AssemblyNameReference reference)
		{
			var name = reference.Name;
			return name == mscorlib
				|| name == system_runtime
				|| name == system_private_corelib
				|| name == netstandard;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/VariantType.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

namespace MonoFN.Cecil {

	public enum VariantType {
		None = 0,
		I2 = 2,
		I4 = 3,
		R4 = 4,
		R8 = 5,
		CY = 6,
		Date = 7,
		BStr = 8,
		Dispatch = 9,
		Error = 10,
		Bool = 11,
		Variant = 12,
		Unknown = 13,
		Decimal = 14,
		I1 = 16,
		UI1 = 17,
		UI2 = 18,
		UI4 = 19,
		I8 = 20,
		UI8 = 21,
		Int = 22,
		UInt = 23
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Cecil/WindowsRuntimeProjections.cs ---
﻿//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;
using System.Collections.Generic;
using System.Threading;

namespace MonoFN.Cecil {

	sealed class TypeDefinitionProjection {

		public readonly TypeAttributes Attributes;
		public readonly string Name;
		public readonly TypeDefinitionTreatment Treatment;
		public readonly Collection<MethodDefinition> RedirectedMethods;
		public readonly Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> RedirectedInterfaces;

		public TypeDefinitionProjection (TypeDefinition type, TypeDefinitionTreatment treatment, Collection<MethodDefinition> redirectedMethods, Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces)
		{
			Attributes = type.Attributes;
			Name = type.Name;
			Treatment = treatment;
			RedirectedMethods = redirectedMethods;
			RedirectedInterfaces = redirectedInterfaces;
		}
	}

	sealed class TypeReferenceProjection {

		public readonly string Name;
		public readonly string Namespace;
		public readonly IMetadataScope Scope;
		public readonly TypeReferenceTreatment Treatment;

		public TypeReferenceProjection (TypeReference type, TypeReferenceTreatment treatment)
		{
			Name = type.Name;
			Namespace = type.Namespace;
			Scope = type.Scope;
			Treatment = treatment;
		}
	}

	sealed class MethodDefinitionProjection {

		public readonly MethodAttributes Attributes;
		public readonly MethodImplAttributes ImplAttributes;
		public readonly string Name;
		public readonly MethodDefinitionTreatment Treatment;

		public MethodDefinitionProjection (MethodDefinition method, MethodDefinitionTreatment treatment)
		{
			Attributes = method.Attributes;
			ImplAttributes = method.ImplAttributes;
			Name = method.Name;
			Treatment = treatment;
		}
	}

	sealed class FieldDefinitionProjection {

		public readonly FieldAttributes Attributes;
		public readonly FieldDefinitionTreatment Treatment;

		public FieldDefinitionProjection (FieldDefinition field, FieldDefinitionTreatment treatment)
		{
			Attributes = field.Attributes;
			Treatment = treatment;
		}
	}

	sealed class CustomAttributeValueProjection {

		public readonly AttributeTargets Targets;
		public readonly CustomAttributeValueTreatment Treatment;

		public CustomAttributeValueProjection (AttributeTargets targets, CustomAttributeValueTreatment treatment)
		{
			Targets = targets;
			Treatment = treatment;
		}
	}

	sealed class WindowsRuntimeProjections {

		struct ProjectionInfo {

			public readonly string WinRTNamespace;
			public readonly string ClrNamespace;
			public readonly string ClrName;
			public readonly string ClrAssembly;
			public readonly bool Attribute;

			public ProjectionInfo (string winrt_namespace, string clr_namespace, string clr_name, string clr_assembly, bool attribute = false)
			{
				WinRTNamespace = winrt_namespace;
				ClrNamespace = clr_namespace;
				ClrName = clr_name;
				ClrAssembly = clr_assembly;
				Attribute = attribute;
			}
		}

		static readonly Version version = new Version (4, 0, 0, 0);

		static readonly byte [] contract_pk_token = {
			0xB0, 0x3F, 0x5F, 0x7F, 0x11, 0xD5, 0x0A, 0x3A
		};

		static readonly byte [] contract_pk = {
			0x00, 0x24, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x06, 0x02, 0x00, 0x00,
			0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
			0x07, 0xD1, 0xFA, 0x57, 0xC4, 0xAE, 0xD9, 0xF0, 0xA3, 0x2E, 0x84, 0xAA, 0x0F, 0xAE, 0xFD, 0x0D,
			0xE9, 0xE8, 0xFD, 0x6A, 0xEC, 0x8F, 0x87, 0xFB, 0x03, 0x76, 0x6C, 0x83, 0x4C, 0x99, 0x92, 0x1E,
			0xB2, 0x3B, 0xE7, 0x9A, 0xD9, 0xD5, 0xDC, 0xC1, 0xDD, 0x9A, 0xD2, 0x36, 0x13, 0x21, 0x02, 0x90,
			0x0B, 0x72, 0x3C, 0xF9, 0x80, 0x95, 0x7F, 0xC4, 0xE1, 0x77, 0x10, 0x8F, 0xC6, 0x07, 0x77, 0x4F,
			0x29, 0xE8, 0x32, 0x0E, 0x92, 0xEA, 0x05, 0xEC, 0xE4, 0xE8, 0x21, 0xC0, 0xA5, 0xEF, 0xE8, 0xF1,
			0x64, 0x5C, 0x4C, 0x0C, 0x93, 0xC1, 0xAB, 0x99, 0x28, 0x5D, 0x62, 0x2C, 0xAA, 0x65, 0x2C, 0x1D,
			0xFA, 0xD6, 0x3D, 0x74, 0x5D, 0x6F, 0x2D, 0xE5, 0xF1, 0x7E, 0x5E, 0xAF, 0x0F, 0xC4, 0x96, 0x3D,
			0x26, 0x1C, 0x8A, 0x12, 0x43, 0x65, 0x18, 0x20, 0x6D, 0xC0, 0x93, 0x34, 0x4D, 0x5A, 0xD2, 0x93
		};

		static Dictionary<string, ProjectionInfo> projections;

		static Dictionary<string, ProjectionInfo> Projections {
			get {
				if (projections != null)
					return projections;

				var new_projections = new Dictionary<string, ProjectionInfo> {
					{ "AttributeTargets", new ProjectionInfo ("Windows.Foundation.Metadata", "System", "AttributeTargets", "System.Runtime") },
					{ "AttributeUsageAttribute", new ProjectionInfo ("Windows.Foundation.Metadata", "System", "AttributeUsageAttribute", "System.Runtime", attribute: true) },
					{ "Color", new ProjectionInfo ("Windows.UI", "Windows.UI", "Color", "System.Runtime.WindowsRuntime") },
					{ "CornerRadius", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "CornerRadius", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "DateTime", new ProjectionInfo ("Windows.Foundation", "System", "DateTimeOffset", "System.Runtime") },
					{ "Duration", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "Duration", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "DurationType", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "DurationType", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "EventHandler`1", new ProjectionInfo ("Windows.Foundation", "System", "EventHandler`1", "System.Runtime") },
					{ "EventRegistrationToken", new ProjectionInfo ("Windows.Foundation", "System.Runtime.InteropServices.WindowsRuntime", "EventRegistrationToken", "System.Runtime.InteropServices.WindowsRuntime") },
					{ "GeneratorPosition", new ProjectionInfo ("Windows.UI.Xaml.Controls.Primitives", "Windows.UI.Xaml.Controls.Primitives", "GeneratorPosition", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "GridLength", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "GridLength", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "GridUnitType", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "GridUnitType", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "HResult", new ProjectionInfo ("Windows.Foundation", "System", "Exception", "System.Runtime") },
					{ "IBindableIterable", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections", "IEnumerable", "System.Runtime") },
					{ "IBindableVector", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections", "IList", "System.Runtime") },
					{ "IClosable", new ProjectionInfo ("Windows.Foundation", "System", "IDisposable", "System.Runtime") },
					{ "ICommand", new ProjectionInfo ("Windows.UI.Xaml.Input", "System.Windows.Input", "ICommand", "System.ObjectModel") },
					{ "IIterable`1", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IEnumerable`1", "System.Runtime") },
					{ "IKeyValuePair`2", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "KeyValuePair`2", "System.Runtime") },
					{ "IMapView`2", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IReadOnlyDictionary`2", "System.Runtime") },
					{ "IMap`2", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IDictionary`2", "System.Runtime") },
					{ "INotifyCollectionChanged", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "INotifyCollectionChanged", "System.ObjectModel") },
					{ "INotifyPropertyChanged", new ProjectionInfo ("Windows.UI.Xaml.Data", "System.ComponentModel", "INotifyPropertyChanged", "System.ObjectModel") },
					{ "IReference`1", new ProjectionInfo ("Windows.Foundation", "System", "Nullable`1", "System.Runtime") },
					{ "IVectorView`1", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IReadOnlyList`1", "System.Runtime") },
					{ "IVector`1", new ProjectionInfo ("Windows.Foundation.Collections", "System.Collections.Generic", "IList`1", "System.Runtime") },
					{ "KeyTime", new ProjectionInfo ("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "KeyTime", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "Matrix", new ProjectionInfo ("Windows.UI.Xaml.Media", "Windows.UI.Xaml.Media", "Matrix", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "Matrix3D", new ProjectionInfo ("Windows.UI.Xaml.Media.Media3D", "Windows.UI.Xaml.Media.Media3D", "Matrix3D", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "Matrix3x2", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Matrix3x2", "System.Numerics.Vectors") },
					{ "Matrix4x4", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Matrix4x4", "System.Numerics.Vectors") },
					{ "NotifyCollectionChangedAction", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedAction", "System.ObjectModel") },
					{ "NotifyCollectionChangedEventArgs", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedEventArgs", "System.ObjectModel") },
					{ "NotifyCollectionChangedEventHandler", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedEventHandler", "System.ObjectModel") },
					{ "Plane", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Plane", "System.Numerics.Vectors") },
					{ "Point", new ProjectionInfo ("Windows.Foundation", "Windows.Foundation", "Point", "System.Runtime.WindowsRuntime") },
					{ "PropertyChangedEventArgs", new ProjectionInfo ("Windows.UI.Xaml.Data", "System.ComponentModel", "PropertyChangedEventArgs", "System.ObjectModel") },
					{ "PropertyChangedEventHandler", new ProjectionInfo ("Windows.UI.Xaml.Data", "System.ComponentModel", "PropertyChangedEventHandler", "System.ObjectModel") },
					{ "Quaternion", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Quaternion", "System.Numerics.Vectors") },
					{ "Rect", new ProjectionInfo ("Windows.Foundation", "Windows.Foundation", "Rect", "System.Runtime.WindowsRuntime") },
					{ "RepeatBehavior", new ProjectionInfo ("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "RepeatBehavior", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "RepeatBehaviorType", new ProjectionInfo ("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "RepeatBehaviorType", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "Size", new ProjectionInfo ("Windows.Foundation", "Windows.Foundation", "Size", "System.Runtime.WindowsRuntime") },
					{ "Thickness", new ProjectionInfo ("Windows.UI.Xaml", "Windows.UI.Xaml", "Thickness", "System.Runtime.WindowsRuntime.UI.Xaml") },
					{ "TimeSpan", new ProjectionInfo ("Windows.Foundation", "System", "TimeSpan", "System.Runtime") },
					{ "TypeName", new ProjectionInfo ("Windows.UI.Xaml.Interop", "System", "Type", "System.Runtime") },
					{ "Uri", new ProjectionInfo ("Windows.Foundation", "System", "Uri", "System.Runtime") },
					{ "Vector2", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Vector2", "System.Numerics.Vectors") },
					{ "Vector3", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Vector3", "System.Numerics.Vectors") },
					{ "Vector4", new ProjectionInfo ("Windows.Foundation.Numerics", "System.Numerics", "Vector4", "System.Numerics.Vectors") },
				};

				Interlocked.CompareExchange (ref projections, new_projections, null);
				return projections;
			}
		}

		readonly ModuleDefinition module;
		Version corlib_version = new Version (255, 255, 255, 255);
		AssemblyNameReference [] virtual_references;

		AssemblyNameReference [] VirtualReferences {
			get {
				if (virtual_references == null) {
					// force module to read its assembly references. that will in turn initialize virtual_references
					Mixin.Read (module.AssemblyReferences);
				}

				return virtual_references;
			}
		}

		public WindowsRuntimeProjections (ModuleDefinition module)
		{
			this.module = module;
		}

		public static void Project (TypeDefinition type)
		{
			var treatment = TypeDefinitionTreatment.None;
			var metadata_kind = type.Module.MetadataKind;
			Collection<MethodDefinition> redirectedMethods = null;
			Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces = null;

			if (type.IsWindowsRuntime) {
				if (metadata_kind == MetadataKind.WindowsMetadata) {
					treatment = GetWellKnownTypeDefinitionTreatment (type);
					if (treatment != TypeDefinitionTreatment.None) {
						ApplyProjection (type, new TypeDefinitionProjection (type, treatment, redirectedMethods, redirectedInterfaces));
						return;
					}

					var base_type = type.BaseType;
					if (base_type != null && IsAttribute (base_type)) {
						treatment = TypeDefinitionTreatment.NormalAttribute;
					} else {
						treatment = GenerateRedirectionInformation (type, out redirectedMethods, out redirectedInterfaces);
					}
				} else if (metadata_kind == MetadataKind.ManagedWindowsMetadata && NeedsWindowsRuntimePrefix (type))
					treatment = TypeDefinitionTreatment.PrefixWindowsRuntimeName;

				if (treatment == TypeDefinitionTreatment.PrefixWindowsRuntimeName || treatment == TypeDefinitionTreatment.NormalType)
					if (!type.IsInterface && HasAttribute (type, "Windows.UI.Xaml", "TreatAsAbstractComposableClassAttribute"))
						treatment |= TypeDefinitionTreatment.Abstract;
			} else if (metadata_kind == MetadataKind.ManagedWindowsMetadata && IsClrImplementationType (type))
				treatment = TypeDefinitionTreatment.UnmangleWindowsRuntimeName;

			if (treatment != TypeDefinitionTreatment.None)
				ApplyProjection (type, new TypeDefinitionProjection (type, treatment, redirectedMethods, redirectedInterfaces));
		}

		static TypeDefinitionTreatment GetWellKnownTypeDefinitionTreatment (TypeDefinition type)
		{
			ProjectionInfo info;
			if (!Projections.TryGetValue (type.Name, out info))
				return TypeDefinitionTreatment.None;

			var treatment = info.Attribute ? TypeDefinitionTreatment.RedirectToClrAttribute : TypeDefinitionTreatment.RedirectToClrType;

			if (type.Namespace == info.ClrNamespace)
				return treatment;

			if (type.Namespace == info.WinRTNamespace)
				return treatment | TypeDefinitionTreatment.Internal;

			return TypeDefinitionTreatment.None;
		}

		private static TypeDefinitionTreatment GenerateRedirectionInformation (TypeDefinition type, out Collection<MethodDefinition> redirectedMethods, out Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces)
		{
			bool implementsProjectedInterface = false;
			redirectedMethods = null;
			redirectedInterfaces = null;

			foreach (var implementedInterface in type.Interfaces) {
				if (IsRedirectedType (implementedInterface.InterfaceType)) {
					implementsProjectedInterface = true;
					break;
				}
			}

			if (!implementsProjectedInterface)
				return TypeDefinitionTreatment.NormalType;

			var allImplementedInterfaces = new HashSet<TypeReference> (new TypeReferenceEqualityComparer ());
			redirectedMethods = new Collection<MethodDefinition> ();
			redirectedInterfaces = new Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> ();

			foreach (var @interface in type.Interfaces) {
				var interfaceType = @interface.InterfaceType;

				if (IsRedirectedType (interfaceType)) {
					allImplementedInterfaces.Add (interfaceType);
					CollectImplementedInterfaces (interfaceType, allImplementedInterfaces);
				}
			}

			foreach (var implementedInterface in type.Interfaces) {
				var interfaceType = implementedInterface.InterfaceType;
				if (IsRedirectedType (implementedInterface.InterfaceType)) {
					var etype = interfaceType.GetElementType ();
					var unprojectedType = new TypeReference (etype.Namespace, etype.Name, etype.Module, etype.Scope) {
						DeclaringType = etype.DeclaringType,
						projection = etype.projection
					};

					RemoveProjection (unprojectedType);

					var genericInstanceType = interfaceType as GenericInstanceType;
					if (genericInstanceType != null) {
						var genericUnprojectedType = new GenericInstanceType (unprojectedType);
						foreach (var genericArgument in genericInstanceType.GenericArguments)
							genericUnprojectedType.GenericArguments.Add (genericArgument);

						unprojectedType = genericUnprojectedType;
					}

					var unprojectedInterface = new InterfaceImplementation (unprojectedType);
					redirectedInterfaces.Add (new KeyValuePair<InterfaceImplementation, InterfaceImplementation> (implementedInterface, unprojectedInterface));
				}
			}

			// Interfaces don't inherit methods of the interfaces they implement
			if (!type.IsInterface) {
				foreach (var implementedInterface in allImplementedInterfaces) {
					RedirectInterfaceMethods (implementedInterface, redirectedMethods);
				}
			}

			return TypeDefinitionTreatment.RedirectImplementedMethods;
		}

		private static void CollectImplementedInterfaces (TypeReference type, HashSet<TypeReference> results)
		{
			var typeResolver = TypeResolver.For (type);
			var typeDef = type.Resolve ();

			foreach (var implementedInterface in typeDef.Interfaces) {
				var interfaceType = typeResolver.Resolve (implementedInterface.InterfaceType);
				results.Add (interfaceType);
				CollectImplementedInterfaces (interfaceType, results);
			}
		}

		private static void RedirectInterfaceMethods (TypeReference interfaceType, Collection<MethodDefinition> redirectedMethods)
		{
			var typeResolver = TypeResolver.For (interfaceType);
			var typeDef = interfaceType.Resolve ();

			foreach (var method in typeDef.Methods) {
				var redirectedMethod = new MethodDefinition (method.Name, MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot, typeResolver.Resolve (method.ReturnType));
				redirectedMethod.ImplAttributes = MethodImplAttributes.Runtime;

				foreach (var parameter in method.Parameters) {
					redirectedMethod.Parameters.Add (new ParameterDefinition (parameter.Name, parameter.Attributes, typeResolver.Resolve (parameter.ParameterType)));
				}

				redirectedMethod.Overrides.Add (typeResolver.Resolve (method));
				redirectedMethods.Add (redirectedMethod);
			}
		}

		private static bool IsRedirectedType (TypeReference type)
		{
			var typeRefProjection = type.GetElementType ().projection as TypeReferenceProjection;
			return typeRefProjection != null && typeRefProjection.Treatment == TypeReferenceTreatment.UseProjectionInfo;
		}

		static bool NeedsWindowsRuntimePrefix (TypeDefinition type)
		{
			if ((type.Attributes & (TypeAttributes.VisibilityMask | TypeAttributes.Interface)) != TypeAttributes.Public)
				return false;

			var base_type = type.BaseType;
			if (base_type == null || base_type.MetadataToken.TokenType != TokenType.TypeRef)
				return false;

			if (base_type.Namespace == "System")
				switch (base_type.Name) {
				case "Attribute":
				case "MulticastDelegate":
				case "ValueType":
					return false;
				}

			return true;
		}

		public static bool IsClrImplementationType (TypeDefinition type)
		{
			if ((type.Attributes & (TypeAttributes.VisibilityMask | TypeAttributes.SpecialName)) != TypeAttributes.SpecialName)
				return false;
			return type.Name.StartsWith ("<CLR>");
		}

		public static void ApplyProjection (TypeDefinition type, TypeDefinitionProjection projection)
		{
			if (projection == null)
				return;

			var treatment = projection.Treatment;

			switch (treatment & TypeDefinitionTreatment.KindMask) {
			case TypeDefinitionTreatment.NormalType:
				type.Attributes |= TypeAttributes.WindowsRuntime | TypeAttributes.Import;
				break;

			case TypeDefinitionTreatment.NormalAttribute:
				type.Attributes |= TypeAttributes.WindowsRuntime | TypeAttributes.Sealed;
				break;

			case TypeDefinitionTreatment.UnmangleWindowsRuntimeName:
				type.Attributes = type.Attributes & ~TypeAttributes.SpecialName | TypeAttributes.Public;
				type.Name = type.Name.Substring ("<CLR>".Length);
				break;

			case TypeDefinitionTreatment.PrefixWindowsRuntimeName:
				type.Attributes = type.Attributes & ~TypeAttributes.Public | TypeAttributes.Import;
				type.Name = "<WinRT>" + type.Name;
				break;

			case TypeDefinitionTreatment.RedirectToClrType:
				type.Attributes = type.Attributes & ~TypeAttributes.Public | TypeAttributes.Import;
				break;

			case TypeDefinitionTreatment.RedirectToClrAttribute:
				type.Attributes = type.Attributes & ~TypeAttributes.Public;
				break;

			case TypeDefinitionTreatment.RedirectImplementedMethods: {
					type.Attributes |= TypeAttributes.WindowsRuntime | TypeAttributes.Import;

					foreach (var redirectedInterfacePair in projection.RedirectedInterfaces) {
						type.Interfaces.Add (redirectedInterfacePair.Value);

						foreach (var customAttribute in redirectedInterfacePair.Key.CustomAttributes)
							redirectedInterfacePair.Value.CustomAttributes.Add (customAttribute);

						redirectedInterfacePair.Key.CustomAttributes.Clear ();

						foreach (var method in type.Methods) {
							foreach (var @override in method.Overrides) {
								if (TypeReferenceEqualityComparer.AreEqual (@override.DeclaringType, redirectedInterfacePair.Key.InterfaceType)) {
									@override.DeclaringType = redirectedInterfacePair.Value.InterfaceType;
								}
							}
						}
					}

					foreach (var method in projection.RedirectedMethods) {
						type.Methods.Add (method);
					}
				}
				break;
			}

			if ((treatment & TypeDefinitionTreatment.Abstract) != 0)
				type.Attributes |= TypeAttributes.Abstract;

			if ((treatment & TypeDefinitionTreatment.Internal) != 0)
				type.Attributes &= ~TypeAttributes.Public;

			type.WindowsRuntimeProjection = projection;
		}

		public static TypeDefinitionProjection RemoveProjection (TypeDefinition type)
		{
			if (!type.IsWindowsRuntimeProjection)
				return null;

			var projection = type.WindowsRuntimeProjection;
			type.WindowsRuntimeProjection = null;

			type.Attributes = projection.Attributes;
			type.Name = projection.Name;

			if (projection.Treatment == TypeDefinitionTreatment.RedirectImplementedMethods) {
				foreach (var method in projection.RedirectedMethods) {
					type.Methods.Remove (method);
				}

				foreach (var redirectedInterfacePair in projection.RedirectedInterfaces) {
					foreach (var method in type.Methods) {
						foreach (var @override in method.Overrides) {
							if (TypeReferenceEqualityComparer.AreEqual (@override.DeclaringType, redirectedInterfacePair.Value.InterfaceType)) {
								@override.DeclaringType = redirectedInterfacePair.Key.InterfaceType;
							}
						}
					}

					foreach (var customAttribute in redirectedInterfacePair.Value.CustomAttributes)
						redirectedInterfacePair.Key.CustomAttributes.Add (customAttribute);

					redirectedInterfacePair.Value.CustomAttributes.Clear ();
					type.Interfaces.Remove (redirectedInterfacePair.Value);
				}
			}

			return projection;
		}

		public static void Project (TypeReference type)
		{
			TypeReferenceTreatment treatment;

			ProjectionInfo info;
			if (Projections.TryGetValue (type.Name, out info) && info.WinRTNamespace == type.Namespace)
				treatment = TypeReferenceTreatment.UseProjectionInfo;
			else
				treatment = GetSpecialTypeReferenceTreatment (type);

			if (treatment != TypeReferenceTreatment.None)
				ApplyProjection (type, new TypeReferenceProjection (type, treatment));
		}

		static TypeReferenceTreatment GetSpecialTypeReferenceTreatment (TypeReference type)
		{
			if (type.Namespace == "System") {
				if (type.Name == "MulticastDelegate")
					return TypeReferenceTreatment.SystemDelegate;
				if (type.Name == "Attribute")
					return TypeReferenceTreatment.SystemAttribute;
			}

			return TypeReferenceTreatment.None;
		}

		static bool IsAttribute (TypeReference type)
		{
			if (type.MetadataToken.TokenType != TokenType.TypeRef)
				return false;
			return type.Name == "Attribute" && type.Namespace == "System";
		}

		static bool IsEnum (TypeReference type)
		{
			if (type.MetadataToken.TokenType != TokenType.TypeRef)
				return false;
			return type.Name == "Enum" && type.Namespace == "System";
		}

		public static void ApplyProjection (TypeReference type, TypeReferenceProjection projection)
		{
			if (projection == null)
				return;

			switch (projection.Treatment) {
			case TypeReferenceTreatment.SystemDelegate:
			case TypeReferenceTreatment.SystemAttribute:
				type.Scope = type.Module.Projections.GetAssemblyReference ("System.Runtime");
				break;

			case TypeReferenceTreatment.UseProjectionInfo:
				var info = Projections [type.Name];
				type.Name = info.ClrName;
				type.Namespace = info.ClrNamespace;
				type.Scope = type.Module.Projections.GetAssemblyReference (info.ClrAssembly);
				break;
			}

			type.WindowsRuntimeProjection = projection;
		}

		public static TypeReferenceProjection RemoveProjection (TypeReference type)
		{
			if (!type.IsWindowsRuntimeProjection)
				return null;

			var projection = type.WindowsRuntimeProjection;
			type.WindowsRuntimeProjection = null;

			type.Name = projection.Name;
			type.Namespace = projection.Namespace;
			type.Scope = projection.Scope;

			return projection;
		}

		public static void Project (MethodDefinition method)
		{
			var treatment = MethodDefinitionTreatment.None;
			var other = false;
			var declaring_type = method.DeclaringType;

			if (declaring_type.IsWindowsRuntime) {
				if (IsClrImplementationType (declaring_type))
					treatment = MethodDefinitionTreatment.None;
				else if (declaring_type.IsNested)
					treatment = MethodDefinitionTreatment.None;
				else if (declaring_type.IsInterface)
					treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall;
				else if (declaring_type.Module.MetadataKind == MetadataKind.ManagedWindowsMetadata && !method.IsPublic)
					treatment = MethodDefinitionTreatment.None;
				else {
					other = true;

					var base_type = declaring_type.BaseType;
					if (base_type != null && base_type.MetadataToken.TokenType == TokenType.TypeRef) {
						switch (GetSpecialTypeReferenceTreatment (base_type)) {
						case TypeReferenceTreatment.SystemDelegate:
							treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.Public;
							other = false;
							break;

						case TypeReferenceTreatment.SystemAttribute:
							treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall;
							other = false;
							break;
						}
					}
				}
			}

			if (other) {
				var seen_redirected = false;
				var seen_non_redirected = false;

				foreach (var @override in method.Overrides) {
					if (@override.MetadataToken.TokenType == TokenType.MemberRef && ImplementsRedirectedInterface (@override)) {
						seen_redirected = true;
					} else {
						seen_non_redirected = true;
					}
				}

				if (seen_redirected && !seen_non_redirected) {
					treatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall | MethodDefinitionTreatment.Private;
					other = false;
				}
			}

			if (other)
				treatment |= GetMethodDefinitionTreatmentFromCustomAttributes (method);

			if (treatment != MethodDefinitionTreatment.None)
				ApplyProjection (method, new MethodDefinitionProjection (method, treatment));
		}

		static MethodDefinitionTreatment GetMethodDefinitionTreatmentFromCustomAttributes (MethodDefinition method)
		{
			var treatment = MethodDefinitionTreatment.None;

			foreach (var attribute in method.CustomAttributes) {
				var type = attribute.AttributeType;
				if (type.Namespace != "Windows.UI.Xaml")
					continue;
				if (type.Name == "TreatAsPublicMethodAttribute")
					treatment |= MethodDefinitionTreatment.Public;
				else if (type.Name == "TreatAsAbstractMethodAttribute")
					treatment |= MethodDefinitionTreatment.Abstract;
			}

			return treatment;
		}

		public static void ApplyProjection (MethodDefinition method, MethodDefinitionProjection projection)
		{
			if (projection == null)
				return;

			var treatment = projection.Treatment;

			if ((treatment & MethodDefinitionTreatment.Abstract) != 0)
				method.Attributes |= MethodAttributes.Abstract;

			if ((treatment & MethodDefinitionTreatment.Private) != 0)
				method.Attributes = (method.Attributes & ~MethodAttributes.MemberAccessMask) | MethodAttributes.Private;

			if ((treatment & MethodDefinitionTreatment.Public) != 0)
				method.Attributes = (method.Attributes & ~MethodAttributes.MemberAccessMask) | MethodAttributes.Public;

			if ((treatment & MethodDefinitionTreatment.Runtime) != 0)
				method.ImplAttributes |= MethodImplAttributes.Runtime;

			if ((treatment & MethodDefinitionTreatment.InternalCall) != 0)
				method.ImplAttributes |= MethodImplAttributes.InternalCall;

			method.WindowsRuntimeProjection = projection;
		}

		public static MethodDefinitionProjection RemoveProjection (MethodDefinition method)
		{
			if (!method.IsWindowsRuntimeProjection)
				return null;

			var projection = method.WindowsRuntimeProjection;
			method.WindowsRuntimeProjection = null;

			method.Attributes = projection.Attributes;
			method.ImplAttributes = projection.ImplAttributes;
			method.Name = projection.Name;

			return projection;
		}

		public static void Project (FieldDefinition field)
		{
			var treatment = FieldDefinitionTreatment.None;
			var declaring_type = field.DeclaringType;

			if (declaring_type.Module.MetadataKind == MetadataKind.WindowsMetadata && field.IsRuntimeSpecialName && field.Name == "value__") {
				var base_type = declaring_type.BaseType;
				if (base_type != null && IsEnum (base_type))
					treatment = FieldDefinitionTreatment.Public;
			}

			if (treatment != FieldDefinitionTreatment.None)
				ApplyProjection (field, new FieldDefinitionProjection (field, treatment));
		}

		public static void ApplyProjection (FieldDefinition field, FieldDefinitionProjection projection)
		{
			if (projection == null)
				return;

			if (projection.Treatment == FieldDefinitionTreatment.Public)
				field.Attributes = (field.Attributes & ~FieldAttributes.FieldAccessMask) | FieldAttributes.Public;

			field.WindowsRuntimeProjection = projection;
		}

		public static FieldDefinitionProjection RemoveProjection (FieldDefinition field)
		{
			if (!field.IsWindowsRuntimeProjection)
				return null;

			var projection = field.WindowsRuntimeProjection;
			field.WindowsRuntimeProjection = null;

			field.Attributes = projection.Attributes;

			return projection;
		}

		static bool ImplementsRedirectedInterface (MemberReference member)
		{
			var declaring_type = member.DeclaringType;
			TypeReference type;
			switch (declaring_type.MetadataToken.TokenType) {
			case TokenType.TypeRef:
				type = declaring_type;
				break;

			case TokenType.TypeSpec:
				if (!declaring_type.IsGenericInstance)
					return false;

				type = ((TypeSpecification)declaring_type).ElementType;
				if (type.MetadataType != MetadataType.Class || type.MetadataToken.TokenType != TokenType.TypeRef)
					return false;

				break;

			default:
				return false;
			}

			var projection = RemoveProjection (type);

			var found = false;

			ProjectionInfo info;
			if (Projections.TryGetValue (type.Name, out info) && type.Namespace == info.WinRTNamespace) {
				found = true;
			}

			ApplyProjection (type, projection);

			return found;
		}

		public void AddVirtualReferences (Collection<AssemblyNameReference> references)
		{
			var corlib = GetCoreLibrary (references);
			corlib_version = corlib.Version;
			corlib.Version = version;

			if (virtual_references == null) {
				var winrt_references = GetAssemblyReferences (corlib);
				Interlocked.CompareExchange (ref virtual_references, winrt_references, null);
			}

			foreach (var reference in virtual_references)
				references.Add (reference);
		}

		public void RemoveVirtualReferences (Collection<AssemblyNameReference> references)
		{
			var corlib = GetCoreLibrary (references);
			corlib.Version = corlib_version;

			foreach (var reference in VirtualReferences)
				references.Remove (reference);
		}

		static AssemblyNameReference [] GetAssemblyReferences (AssemblyNameReference corlib)
		{
			var system_runtime = new AssemblyNameReference ("System.Runtime", version);
			var system_runtime_interopservices_windowsruntime = new AssemblyNameReference ("System.Runtime.InteropServices.WindowsRuntime", version);
			var system_objectmodel = new AssemblyNameReference ("System.ObjectModel", version);
			var system_runtime_windowsruntime = new AssemblyNameReference ("System.Runtime.WindowsRuntime", version);
			var system_runtime_windowsruntime_ui_xaml = new AssemblyNameReference ("System.Runtime.WindowsRuntime.UI.Xaml", version);
			var system_numerics_vectors = new AssemblyNameReference ("System.Numerics.Vectors", version);

			if (corlib.HasPublicKey) {
				system_runtime_windowsruntime.PublicKey =
				system_runtime_windowsruntime_ui_xaml.PublicKey = corlib.PublicKey;

				system_runtime.PublicKey =
				system_runtime_interopservices_windowsruntime.PublicKey =
				system_objectmodel.PublicKey =
				system_numerics_vectors.PublicKey = contract_pk;
			} else {
				system_runtime_windowsruntime.PublicKeyToken =
				system_runtime_windowsruntime_ui_xaml.PublicKeyToken = corlib.PublicKeyToken;

				system_runtime.PublicKeyToken =
				system_runtime_interopservices_windowsruntime.PublicKeyToken =
				system_objectmodel.PublicKeyToken =
				system_numerics_vectors.PublicKeyToken = contract_pk_token;
			}

			return new [] {
				system_runtime,
				system_runtime_interopservices_windowsruntime,
				system_objectmodel,
				system_runtime_windowsruntime,
				system_runtime_windowsruntime_ui_xaml,
				system_numerics_vectors,
			};
		}

		static AssemblyNameReference GetCoreLibrary (Collection<AssemblyNameReference> references)
		{
			foreach (var reference in references)
				if (reference.Name == "mscorlib")
					return reference;

			throw new BadImageFormatException ("Missing mscorlib reference in AssemblyRef table.");
		}

		AssemblyNameReference GetAssemblyReference (string name)
		{
			foreach (var assembly in VirtualReferences)
				if (assembly.Name == name)
					return assembly;

			throw new Exception ();
		}

		public static void Project (ICustomAttributeProvider owner, CustomAttribute attribute)
		{
			if (!IsWindowsAttributeUsageAttribute (owner, attribute))
				return;

			var treatment = CustomAttributeValueTreatment.None;
			var type = (TypeDefinition)owner;

			if (type.Namespace == "Windows.Foundation.Metadata") {
				if (type.Name == "VersionAttribute")
					treatment = CustomAttributeValueTreatment.VersionAttribute;
				else if (type.Name == "DeprecatedAttribute")
					treatment = CustomAttributeValueTreatment.DeprecatedAttribute;
			}

			if (treatment == CustomAttributeValueTreatment.None) {
				var multiple = HasAttribute (type, "Windows.Foundation.Metadata", "AllowMultipleAttribute");
				treatment = multiple ? CustomAttributeValueTreatment.AllowMultiple : CustomAttributeValueTreatment.AllowSingle;
			}

			if (treatment != CustomAttributeValueTreatment.None) {
				var attribute_targets = (AttributeTargets)attribute.ConstructorArguments [0].Value;
				ApplyProjection (attribute, new CustomAttributeValueProjection (attribute_targets, treatment));
			}
		}

		static bool IsWindowsAttributeUsageAttribute (ICustomAttributeProvider owner, CustomAttribute attribute)
		{
			if (owner.MetadataToken.TokenType != TokenType.TypeDef)
				return false;

			var constructor = attribute.Constructor;

			if (constructor.MetadataToken.TokenType != TokenType.MemberRef)
				return false;

			var declaring_type = constructor.DeclaringType;

			if (declaring_type.MetadataToken.TokenType != TokenType.TypeRef)
				return false;

			// declaring type is already projected
			return declaring_type.Name == "AttributeUsageAttribute" && declaring_type.Namespace == /*"Windows.Foundation.Metadata"*/"System";
		}

		static bool HasAttribute (TypeDefinition type, string @namespace, string name)
		{
			foreach (var attribute in type.CustomAttributes) {
				var attribute_type = attribute.AttributeType;
				if (attribute_type.Name == name && attribute_type.Namespace == @namespace)
					return true;
			}
			return false;
		}

		public static void ApplyProjection (CustomAttribute attribute, CustomAttributeValueProjection projection)
		{
			if (projection == null)
				return;

			bool version_or_deprecated;
			bool multiple;

			switch (projection.Treatment) {
			case CustomAttributeValueTreatment.AllowSingle:
				version_or_deprecated = false;
				multiple = false;
				break;

			case CustomAttributeValueTreatment.AllowMultiple:
				version_or_deprecated = false;
				multiple = true;
				break;

			case CustomAttributeValueTreatment.VersionAttribute:
			case CustomAttributeValueTreatment.DeprecatedAttribute:
				version_or_deprecated = true;
				multiple = true;
				break;

			default:
				throw new ArgumentException ();
			}

			var attribute_targets = (AttributeTargets)attribute.ConstructorArguments [0].Value;
			if (version_or_deprecated)
				attribute_targets |= AttributeTargets.Constructor | AttributeTargets.Property;
			attribute.ConstructorArguments [0] = new CustomAttributeArgument (attribute.ConstructorArguments [0].Type, attribute_targets);

			attribute.Properties.Add (new CustomAttributeNamedArgument ("AllowMultiple", new CustomAttributeArgument (attribute.Module.TypeSystem.Boolean, multiple)));

			attribute.projection = projection;
		}

		public static CustomAttributeValueProjection RemoveProjection (CustomAttribute attribute)
		{
			if (attribute.projection == null)
				return null;

			var projection = attribute.projection;
			attribute.projection = null;

			attribute.ConstructorArguments [0] = new CustomAttributeArgument (attribute.ConstructorArguments [0].Type, projection.Targets);
			attribute.Properties.Clear ();

			return projection;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Collections.Generic/Collection.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil;
using System;
using System.Collections;
using System.Collections.Generic;

namespace MonoFN.Collections.Generic {

	public class Collection<T> : IList<T>, IList {

		internal T [] items;
		internal int size;
		int version;

		public int Count {
			get { return size; }
		}

		public T this [int index] {
			get {
				if (index >= size)
					throw new ArgumentOutOfRangeException ();

				return items [index];
			}
			set {
				CheckIndex (index);
				if (index == size)
					throw new ArgumentOutOfRangeException ();

				OnSet (value, index);

				items [index] = value;
			}
		}

		public int Capacity {
			get { return items.Length; }
			set {
				if (value < 0 || value < size)
					throw new ArgumentOutOfRangeException ();

				Resize (value);
			}
		}

		bool ICollection<T>.IsReadOnly {
			get { return false; }
		}

		bool IList.IsFixedSize {
			get { return false; }
		}

		bool IList.IsReadOnly {
			get { return false; }
		}

		object IList.this [int index] {
			get { return this [index]; }
			set {
				CheckIndex (index);

				try {
					this [index] = (T)value;
					return;
				}
				catch (InvalidCastException) {
				}
				catch (NullReferenceException) {
				}

				throw new ArgumentException ();
			}
		}

		int ICollection.Count {
			get { return Count; }
		}

		bool ICollection.IsSynchronized {
			get { return false; }
		}

		object ICollection.SyncRoot {
			get { return this; }
		}

		public Collection ()
		{
			items = Empty<T>.Array;
		}

		public Collection (int capacity)
		{
			if (capacity < 0)
				throw new ArgumentOutOfRangeException ();

			items = capacity == 0
				? Empty<T>.Array
				: new T [capacity];
		}

		public Collection (ICollection<T> items)
		{
			if (items == null)
				throw new ArgumentNullException ("items");

			this.items = new T [items.Count];
			items.CopyTo (this.items, 0);
			this.size = this.items.Length;
		}

		public void Add (T item)
		{
			if (size == items.Length)
				Grow (1);

			OnAdd (item, size);

			items [size++] = item;
			version++;
		}

		public bool Contains (T item)
		{
			return IndexOf (item) != -1;
		}

		public int IndexOf (T item)
		{
			return Array.IndexOf (items, item, 0, size);
		}

		public void Insert (int index, T item)
		{
			CheckIndex (index);
			if (size == items.Length)
				Grow (1);

			OnInsert (item, index);

			Shift (index, 1);
			items [index] = item;
			version++;
		}

		public void RemoveAt (int index)
		{
			if (index < 0 || index >= size)
				throw new ArgumentOutOfRangeException ();

			var item = items [index];

			OnRemove (item, index);

			Shift (index, -1);
			version++;
		}

		public bool Remove (T item)
		{
			var index = IndexOf (item);
			if (index == -1)
				return false;

			OnRemove (item, index);

			Shift (index, -1);
			version++;

			return true;
		}

		public void Clear ()
		{
			OnClear ();

			Array.Clear (items, 0, size);
			size = 0;
			version++;
		}

		public void CopyTo (T [] array, int arrayIndex)
		{
			Array.Copy (items, 0, array, arrayIndex, size);
		}

		public T [] ToArray ()
		{
			var array = new T [size];
			Array.Copy (items, 0, array, 0, size);
			return array;
		}

		void CheckIndex (int index)
		{
			if (index < 0 || index > size)
				throw new ArgumentOutOfRangeException ();
		}

		void Shift (int start, int delta)
		{
			if (delta < 0)
				start -= delta;

			if (start < size)
				Array.Copy (items, start, items, start + delta, size - start);

			size += delta;

			if (delta < 0)
				Array.Clear (items, size, -delta);
		}

		protected virtual void OnAdd (T item, int index)
		{
		}

		protected virtual void OnInsert (T item, int index)
		{
		}

		protected virtual void OnSet (T item, int index)
		{
		}

		protected virtual void OnRemove (T item, int index)
		{
		}

		protected virtual void OnClear ()
		{
		}

		internal virtual void Grow (int desired)
		{
			int new_size = size + desired;
			if (new_size <= items.Length)
				return;

			const int default_capacity = 4;

			new_size = System.Math.Max (
				System.Math.Max (items.Length * 2, default_capacity),
				new_size);

			Resize (new_size);
		}

		protected void Resize (int new_size)
		{
			if (new_size == size)
				return;
			if (new_size < size)
				throw new ArgumentOutOfRangeException ();

			items = items.Resize (new_size);
		}

		int IList.Add (object value)
		{
			try {
				Add ((T)value);
				return size - 1;
			}
			catch (InvalidCastException) {
			}
			catch (NullReferenceException) {
			}

			throw new ArgumentException ();
		}

		void IList.Clear ()
		{
			Clear ();
		}

		bool IList.Contains (object value)
		{
			return ((IList)this).IndexOf (value) > -1;
		}

		int IList.IndexOf (object value)
		{
			try {
				return IndexOf ((T)value);
			}
			catch (InvalidCastException) {
			}
			catch (NullReferenceException) {
			}

			return -1;
		}

		void IList.Insert (int index, object value)
		{
			CheckIndex (index);

			try {
				Insert (index, (T)value);
				return;
			}
			catch (InvalidCastException) {
			}
			catch (NullReferenceException) {
			}

			throw new ArgumentException ();
		}

		void IList.Remove (object value)
		{
			try {
				Remove ((T)value);
			}
			catch (InvalidCastException) {
			}
			catch (NullReferenceException) {
			}
		}

		void IList.RemoveAt (int index)
		{
			RemoveAt (index);
		}

		void ICollection.CopyTo (Array array, int index)
		{
			Array.Copy (items, 0, array, index, size);
		}

		public Enumerator GetEnumerator ()
		{
			return new Enumerator (this);
		}

		IEnumerator IEnumerable.GetEnumerator ()
		{
			return new Enumerator (this);
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator ()
		{
			return new Enumerator (this);
		}

		public struct Enumerator : IEnumerator<T>, IDisposable {

			Collection<T> collection;
			T current;

			int next;
			readonly int version;

			public T Current {
				get { return current; }
			}

			object IEnumerator.Current {
				get {
					CheckState ();

					if (next <= 0)
						throw new InvalidOperationException ();

					return current;
				}
			}

			internal Enumerator (Collection<T> collection)
				: this ()
			{
				this.collection = collection;
				this.version = collection.version;
			}

			public bool MoveNext ()
			{
				CheckState ();

				if (next < 0)
					return false;

				if (next < collection.size) {
					current = collection.items [next++];
					return true;
				}

				next = -1;
				return false;
			}

			public void Reset ()
			{
				CheckState ();

				next = 0;
			}

			void CheckState ()
			{
				if (collection == null)
					throw new ObjectDisposedException (GetType ().FullName);

				if (version != collection.version)
					throw new InvalidOperationException ();
			}

			public void Dispose ()
			{
				collection = null;
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Collections.Generic/ReadOnlyCollection.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

namespace MonoFN.Collections.Generic {

	public sealed class ReadOnlyCollection<T> : Collection<T>, ICollection<T>, IList {

		static ReadOnlyCollection<T> empty;

		public static ReadOnlyCollection<T> Empty {
			get {
				if (empty != null)
					return empty;

				Interlocked.CompareExchange (ref empty, new ReadOnlyCollection<T> (), null);
				return empty;
			}
		}

		bool ICollection<T>.IsReadOnly {
			get { return true; }
		}

		bool IList.IsFixedSize {
			get { return true; }
		}

		bool IList.IsReadOnly {
			get { return true; }
		}

		ReadOnlyCollection ()
		{
		}

		public ReadOnlyCollection (T [] array)
		{
			if (array == null)
				throw new ArgumentNullException ();

			Initialize (array, array.Length);
		}

		public ReadOnlyCollection (Collection<T> collection)
		{
			if (collection == null)
				throw new ArgumentNullException ();

			Initialize (collection.items, collection.size);
		}

		void Initialize (T [] items, int size)
		{
			this.items = new T [size];
			Array.Copy (items, 0, this.items, 0, size);
			this.size = size;
		}

		internal override void Grow (int desired)
		{
			throw new InvalidOperationException ();
		}

		protected override void OnAdd (T item, int index)
		{
			throw new InvalidOperationException ();
		}

		protected override void OnClear ()
		{
			throw new InvalidOperationException ();
		}

		protected override void OnInsert (T item, int index)
		{
			throw new InvalidOperationException ();
		}

		protected override void OnRemove (T item, int index)
		{
			throw new InvalidOperationException ();
		}

		protected override void OnSet (T item, int index)
		{
			throw new InvalidOperationException ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Security.Cryptography/CryptoConvert.cs ---
//
// CryptoConvert.cs - Crypto Convertion Routines
//
// Author:
//	Sebastien Pouliot  <sebastien@ximian.com>
//
// (C) 2003 Motus Technologies Inc. (http://www.motus.com)
// Copyright (C) 2004-2006 Novell Inc. (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Security.Cryptography;

namespace MonoFN.Security.Cryptography {

	static class CryptoConvert {

		static private int ToInt32LE (byte [] bytes, int offset)
		{
			return (bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset];
		}

		static private uint ToUInt32LE (byte [] bytes, int offset)
		{
			return (uint)((bytes [offset + 3] << 24) | (bytes [offset + 2] << 16) | (bytes [offset + 1] << 8) | bytes [offset]);
		}

		static private byte [] GetBytesLE (int val)
		{
			return new byte [] {
				(byte) (val & 0xff),
				(byte) ((val >> 8) & 0xff),
				(byte) ((val >> 16) & 0xff),
				(byte) ((val >> 24) & 0xff)
			};
		}

		static private byte [] Trim (byte [] array)
		{
			for (int i = 0; i < array.Length; i++) {
				if (array [i] != 0x00) {
					byte [] result = new byte [array.Length - i];
					Buffer.BlockCopy (array, i, result, 0, result.Length);
					return result;
				}
			}
			return null;
		}

		static RSA FromCapiPrivateKeyBlob (byte [] blob, int offset)
		{
			RSAParameters rsap = new RSAParameters ();
			try {
				if ((blob [offset] != 0x07) ||              // PRIVATEKEYBLOB (0x07)
					(blob [offset + 1] != 0x02) ||              // Version (0x02)
					(blob [offset + 2] != 0x00) ||              // Reserved (word)
					(blob [offset + 3] != 0x00) ||
					(ToUInt32LE (blob, offset + 8) != 0x32415352))  // DWORD magic = RSA2
					throw new CryptographicException ("Invalid blob header");

				// ALGID (CALG_RSA_SIGN, CALG_RSA_KEYX, ...)
				// int algId = ToInt32LE (blob, offset+4);

				// DWORD bitlen
				int bitLen = ToInt32LE (blob, offset + 12);

				// DWORD public exponent
				byte [] exp = new byte [4];
				Buffer.BlockCopy (blob, offset + 16, exp, 0, 4);
				Array.Reverse (exp);
				rsap.Exponent = Trim (exp);

				int pos = offset + 20;
				// BYTE modulus[rsapubkey.bitlen/8];
				int byteLen = (bitLen >> 3);
				rsap.Modulus = new byte [byteLen];
				Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
				Array.Reverse (rsap.Modulus);
				pos += byteLen;

				// BYTE prime1[rsapubkey.bitlen/16];
				int byteHalfLen = (byteLen >> 1);
				rsap.P = new byte [byteHalfLen];
				Buffer.BlockCopy (blob, pos, rsap.P, 0, byteHalfLen);
				Array.Reverse (rsap.P);
				pos += byteHalfLen;

				// BYTE prime2[rsapubkey.bitlen/16];
				rsap.Q = new byte [byteHalfLen];
				Buffer.BlockCopy (blob, pos, rsap.Q, 0, byteHalfLen);
				Array.Reverse (rsap.Q);
				pos += byteHalfLen;

				// BYTE exponent1[rsapubkey.bitlen/16];
				rsap.DP = new byte [byteHalfLen];
				Buffer.BlockCopy (blob, pos, rsap.DP, 0, byteHalfLen);
				Array.Reverse (rsap.DP);
				pos += byteHalfLen;

				// BYTE exponent2[rsapubkey.bitlen/16];
				rsap.DQ = new byte [byteHalfLen];
				Buffer.BlockCopy (blob, pos, rsap.DQ, 0, byteHalfLen);
				Array.Reverse (rsap.DQ);
				pos += byteHalfLen;

				// BYTE coefficient[rsapubkey.bitlen/16];
				rsap.InverseQ = new byte [byteHalfLen];
				Buffer.BlockCopy (blob, pos, rsap.InverseQ, 0, byteHalfLen);
				Array.Reverse (rsap.InverseQ);
				pos += byteHalfLen;

				// ok, this is hackish but CryptoAPI support it so...
				// note: only works because CRT is used by default
				// http://bugzilla.ximian.com/show_bug.cgi?id=57941
				rsap.D = new byte [byteLen]; // must be allocated
				if (pos + byteLen + offset <= blob.Length) {
					// BYTE privateExponent[rsapubkey.bitlen/8];
					Buffer.BlockCopy (blob, pos, rsap.D, 0, byteLen);
					Array.Reverse (rsap.D);
				}
			}
			catch (Exception e) {
				throw new CryptographicException ("Invalid blob.", e);
			}

			RSA rsa = null;
			try {
				rsa = RSA.Create ();
				rsa.ImportParameters (rsap);
			}
			catch (CryptographicException) {
				// this may cause problem when this code is run under
				// the SYSTEM identity on Windows (e.g. ASP.NET). See
				// http://bugzilla.ximian.com/show_bug.cgi?id=77559
				bool throws = false;
				try {
					CspParameters csp = new CspParameters ();
					csp.Flags = CspProviderFlags.UseMachineKeyStore;
					rsa = new RSACryptoServiceProvider (csp);
					rsa.ImportParameters (rsap);
				}
				catch {
					throws = true;
				}

				if (throws) {
					// rethrow original, not the latter, exception if this fails
					throw;
				}
			}
			return rsa;
		}

		static RSA FromCapiPublicKeyBlob (byte [] blob, int offset)
		{
			try {
				if ((blob [offset] != 0x06) ||              // PUBLICKEYBLOB (0x06)
					(blob [offset + 1] != 0x02) ||              // Version (0x02)
					(blob [offset + 2] != 0x00) ||              // Reserved (word)
					(blob [offset + 3] != 0x00) ||
					(ToUInt32LE (blob, offset + 8) != 0x31415352))  // DWORD magic = RSA1
					throw new CryptographicException ("Invalid blob header");

				// ALGID (CALG_RSA_SIGN, CALG_RSA_KEYX, ...)
				// int algId = ToInt32LE (blob, offset+4);

				// DWORD bitlen
				int bitLen = ToInt32LE (blob, offset + 12);

				// DWORD public exponent
				RSAParameters rsap = new RSAParameters ();
				rsap.Exponent = new byte [3];
				rsap.Exponent [0] = blob [offset + 18];
				rsap.Exponent [1] = blob [offset + 17];
				rsap.Exponent [2] = blob [offset + 16];

				int pos = offset + 20;
				// BYTE modulus[rsapubkey.bitlen/8];
				int byteLen = (bitLen >> 3);
				rsap.Modulus = new byte [byteLen];
				Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
				Array.Reverse (rsap.Modulus);

				RSA rsa = null;
				try {
					rsa = RSA.Create ();
					rsa.ImportParameters (rsap);
				}
				catch (CryptographicException) {
					// this may cause problem when this code is run under
					// the SYSTEM identity on Windows (e.g. ASP.NET). See
					// http://bugzilla.ximian.com/show_bug.cgi?id=77559
					CspParameters csp = new CspParameters ();
					csp.Flags = CspProviderFlags.UseMachineKeyStore;
					rsa = new RSACryptoServiceProvider (csp);
					rsa.ImportParameters (rsap);
				}
				return rsa;
			}
			catch (Exception e) {
				throw new CryptographicException ("Invalid blob.", e);
			}
		}

		// PRIVATEKEYBLOB
		// PUBLICKEYBLOB
		static public RSA FromCapiKeyBlob (byte [] blob)
		{
			return FromCapiKeyBlob (blob, 0);
		}

		static public RSA FromCapiKeyBlob (byte [] blob, int offset)
		{
			if (blob == null)
				throw new ArgumentNullException ("blob");
			if (offset >= blob.Length)
				throw new ArgumentException ("blob is too small.");

			switch (blob [offset]) {
			case 0x00:
				// this could be a public key inside an header
				// like "sn -e" would produce
				if (blob [offset + 12] == 0x06) {
					return FromCapiPublicKeyBlob (blob, offset + 12);
				}
				break;
			case 0x06:
				return FromCapiPublicKeyBlob (blob, offset);
			case 0x07:
				return FromCapiPrivateKeyBlob (blob, offset);
			}
			throw new CryptographicException ("Unknown blob format.");
		}

		static public byte [] ToCapiPublicKeyBlob (RSA rsa)
		{
			RSAParameters p = rsa.ExportParameters (false);
			int keyLength = p.Modulus.Length; // in bytes
			byte [] blob = new byte [20 + keyLength];

			blob [0] = 0x06;    // Type - PUBLICKEYBLOB (0x06)
			blob [1] = 0x02;    // Version - Always CUR_BLOB_VERSION (0x02)
								// [2], [3]		// RESERVED - Always 0
			blob [5] = 0x24;    // ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
			blob [8] = 0x52;    // Magic - RSA1 (ASCII in hex)
			blob [9] = 0x53;
			blob [10] = 0x41;
			blob [11] = 0x31;

			byte [] bitlen = GetBytesLE (keyLength << 3);
			blob [12] = bitlen [0]; // bitlen
			blob [13] = bitlen [1];
			blob [14] = bitlen [2];
			blob [15] = bitlen [3];

			// public exponent (DWORD)
			int pos = 16;
			int n = p.Exponent.Length;
			while (n > 0)
				blob [pos++] = p.Exponent [--n];
			// modulus
			pos = 20;
			byte [] part = p.Modulus;
			int len = part.Length;
			Array.Reverse (part, 0, len);
			Buffer.BlockCopy (part, 0, blob, pos, len);
			pos += len;
			return blob;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono.Security.Cryptography/CryptoService.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.PE;
using MonoFN.Security.Cryptography;
using System;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;
using System.Security.Cryptography;

namespace MonoFN.Cecil {

	// Most of this code has been adapted
	// from Jeroen Frijters' fantastic work
	// in IKVM.Reflection.Emit. Thanks!

	static class CryptoService {

		public static byte [] GetPublicKey (WriterParameters parameters)
		{
			using (var rsa = parameters.CreateRSA ()) {
				var cspBlob = CryptoConvert.ToCapiPublicKeyBlob (rsa);
				var publicKey = new byte [12 + cspBlob.Length];
				Buffer.BlockCopy (cspBlob, 0, publicKey, 12, cspBlob.Length);
				// The first 12 bytes are documented at:
				// http://msdn.microsoft.com/library/en-us/cprefadd/html/grfungethashfromfile.asp
				// ALG_ID - Signature
				publicKey [1] = 36;
				// ALG_ID - Hash
				publicKey [4] = 4;
				publicKey [5] = 128;
				// Length of Public Key (in bytes)
				publicKey [8] = (byte)(cspBlob.Length >> 0);
				publicKey [9] = (byte)(cspBlob.Length >> 8);
				publicKey [10] = (byte)(cspBlob.Length >> 16);
				publicKey [11] = (byte)(cspBlob.Length >> 24);
				return publicKey;
			}
		}

		public static void StrongName (Stream stream, ImageWriter writer, WriterParameters parameters)
		{
			int strong_name_pointer;

			var strong_name = CreateStrongName (parameters, HashStream (stream, writer, out strong_name_pointer));
			PatchStrongName (stream, strong_name_pointer, strong_name);
		}

		static void PatchStrongName (Stream stream, int strong_name_pointer, byte [] strong_name)
		{
			stream.Seek (strong_name_pointer, SeekOrigin.Begin);
			stream.Write (strong_name, 0, strong_name.Length);
		}

		static byte [] CreateStrongName (WriterParameters parameters, byte [] hash)
		{
			const string hash_algo = "SHA1";

			using (var rsa = parameters.CreateRSA ()) {
				var formatter = new RSAPKCS1SignatureFormatter (rsa);
				formatter.SetHashAlgorithm (hash_algo);

				byte [] signature = formatter.CreateSignature (hash);
				Array.Reverse (signature);

				return signature;
			}
		}

		static byte [] HashStream (Stream stream, ImageWriter writer, out int strong_name_pointer)
		{
			const int buffer_size = 8192;

			var text = writer.text;
			var header_size = (int)writer.GetHeaderSize ();
			var text_section_pointer = (int)text.PointerToRawData;
			var strong_name_directory = writer.GetStrongNameSignatureDirectory ();

			if (strong_name_directory.Size == 0)
				throw new InvalidOperationException ();

			strong_name_pointer = (int)(text_section_pointer
				+ (strong_name_directory.VirtualAddress - text.VirtualAddress));
			var strong_name_length = (int)strong_name_directory.Size;

			var sha1 = new SHA1Managed ();
			var buffer = new byte [buffer_size];
			using (var crypto_stream = new CryptoStream (Stream.Null, sha1, CryptoStreamMode.Write)) {
				stream.Seek (0, SeekOrigin.Begin);
				CopyStreamChunk (stream, crypto_stream, buffer, header_size);

				stream.Seek (text_section_pointer, SeekOrigin.Begin);
				CopyStreamChunk (stream, crypto_stream, buffer, (int)strong_name_pointer - text_section_pointer);

				stream.Seek (strong_name_length, SeekOrigin.Current);
				CopyStreamChunk (stream, crypto_stream, buffer, (int)(stream.Length - (strong_name_pointer + strong_name_length)));
			}

			return sha1.Hash;
		}

		static void CopyStreamChunk (Stream stream, Stream dest_stream, byte [] buffer, int length)
		{
			while (length > 0) {
				int read = stream.Read (buffer, 0, System.Math.Min (buffer.Length, length));
				dest_stream.Write (buffer, 0, read);
				length -= read;
			}
		}

		public static byte [] ComputeHash (string file)
		{
			if (!File.Exists (file))
				return Empty<byte>.Array;

			using (var stream = new FileStream (file, FileMode.Open, FileAccess.Read, FileShare.Read))
				return ComputeHash (stream);
		}

		public static byte [] ComputeHash (Stream stream)
		{
			const int buffer_size = 8192;

			var sha1 = new SHA1Managed ();
			var buffer = new byte [buffer_size];

			using (var crypto_stream = new CryptoStream (Stream.Null, sha1, CryptoStreamMode.Write))
				CopyStreamChunk (stream, crypto_stream, buffer, (int)stream.Length);

			return sha1.Hash;
		}

		public static byte [] ComputeHash (params ByteBuffer [] buffers)
		{
			var sha1 = new SHA1Managed ();

			using (var crypto_stream = new CryptoStream (Stream.Null, sha1, CryptoStreamMode.Write)) {
				for (int i = 0; i < buffers.Length; i++) {
					crypto_stream.Write (buffers [i].buffer, 0, buffers [i].length);
				}
			}

			return sha1.Hash;
		}

		public static Guid ComputeGuid (byte [] hash)
		{
			// From corefx/src/System.Reflection.Metadata/src/System/Reflection/Metadata/BlobContentId.cs
			var guid = new byte [16];
			Buffer.BlockCopy (hash, 0, guid, 0, 16);

			// modify the guid data so it decodes to the form of a "random" guid ala rfc4122
			guid [7] = (byte)((guid [7] & 0x0f) | (4 << 4));
			guid [8] = (byte)((guid [8] & 0x3f) | (2 << 6));

			return new Guid (guid);
		}
	}

	static partial class Mixin {

		public static RSA CreateRSA (this WriterParameters writer_parameters)
		{
			byte [] key;
			string key_container;

			if (writer_parameters.StrongNameKeyBlob != null)
				return CryptoConvert.FromCapiKeyBlob (writer_parameters.StrongNameKeyBlob);

			if (writer_parameters.StrongNameKeyContainer != null)
				key_container = writer_parameters.StrongNameKeyContainer;
			else if (!TryGetKeyContainer (writer_parameters.StrongNameKeyPair, out key, out key_container))
				return CryptoConvert.FromCapiKeyBlob (key);

			var parameters = new CspParameters {
				Flags = CspProviderFlags.UseMachineKeyStore,
				KeyContainerName = key_container,
				KeyNumber = 2,
			};

			return new RSACryptoServiceProvider (parameters);
		}

		static bool TryGetKeyContainer (ISerializable key_pair, out byte [] key, out string key_container)
		{
			var info = new SerializationInfo (typeof (StrongNameKeyPair), new FormatterConverter ());
			key_pair.GetObjectData (info, new StreamingContext ());

			key = (byte [])info.GetValue ("_keyPairArray", typeof (byte []));
			key_container = info.GetString ("_keyPairContainer");
			return key_container != null;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono/Disposable.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
// 

using System;

namespace MonoFN {

	static class Disposable {

		public static Disposable<T> Owned<T> (T value) where T : class, IDisposable
		{
			return new Disposable<T> (value, owned: true);
		}

		public static Disposable<T> NotOwned<T> (T value) where T : class, IDisposable
		{
			return new Disposable<T> (value, owned: false);
		}
	}

	struct Disposable<T> : IDisposable where T : class, IDisposable {

		internal readonly T value;
		readonly bool owned;

		public Disposable (T value, bool owned)
		{
			this.value = value;
			this.owned = owned;
		}

		public void Dispose ()
		{
			if (value != null && owned)
				value.Dispose ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono/Empty.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Collections.Generic;
using System;

namespace MonoFN {

	static class Empty<T> {

		public static readonly T [] Array = new T [0];
	}

	class ArgumentNullOrEmptyException : ArgumentException {

		public ArgumentNullOrEmptyException (string paramName)
			: base ("Argument null or empty", paramName)
		{
		}
	}
}

namespace MonoFN.Cecil {

	static partial class Mixin {

		public static bool IsNullOrEmpty<T> (this T [] self)
		{
			return self == null || self.Length == 0;
		}

		public static bool IsNullOrEmpty<T> (this Collection<T> self)
		{
			return self == null || self.size == 0;
		}

		public static T [] Resize<T> (this T [] self, int length)
		{
			Array.Resize (ref self, length);
			return self;
		}

		public static T [] Add<T> (this T [] self, T item)
		{
			if (self == null) {
				self = new [] { item };
				return self;
			}

			self = self.Resize (self.Length + 1);
			self [self.Length - 1] = item;
			return self;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/Mono/MergeSort.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Collections.Generic;

namespace MonoFN {

	class MergeSort<T> {
		private readonly T [] elements;
		private readonly T [] buffer;
		private readonly IComparer<T> comparer;

		private MergeSort (T [] elements, IComparer<T> comparer)
		{
			this.elements = elements;
			this.buffer = new T [elements.Length];
			Array.Copy (this.elements, this.buffer, elements.Length);
			this.comparer = comparer;
		}

		public static void Sort (T [] source, IComparer<T> comparer)
		{
			Sort (source, 0, source.Length, comparer);
		}

		public static void Sort (T [] source, int start, int length, IComparer<T> comparer)
		{
			new MergeSort<T> (source, comparer).Sort (start, length);
		}

		private void Sort (int start, int length)
		{
			TopDownSplitMerge (this.buffer, this.elements, start, length);
		}

		private void TopDownSplitMerge (T [] a, T [] b, int start, int end)
		{
			if (end - start < 2)
				return;

			int middle = (end + start) / 2;
			TopDownSplitMerge (b, a, start, middle);
			TopDownSplitMerge (b, a, middle, end);
			TopDownMerge (a, b, start, middle, end);
		}

		private void TopDownMerge (T [] a, T [] b, int start, int middle, int end)
		{
			for (int i = start, j = middle, k = start; k < end; k++) {
				if (i < middle && (j >= end || comparer.Compare (a [i], a [j]) <= 0)) {
					b [k] = a [i++];
				} else {
					b [k] = a [j++];
				}
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/ProjectInfo.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
//
// Licensed under the MIT/X11 license.
//

using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyProduct (Consts.AssemblyName)]
[assembly: AssemblyCopyright ("Copyright © 2008 - 2018 Jb Evain")]

[assembly: ComVisible (false)]

[assembly: AssemblyVersion ("0.11.4.0")]
[assembly: AssemblyFileVersion ("0.11.4.0")]
[assembly: AssemblyInformationalVersion ("0.11.4.0")]

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/README.md ---
Cecil
=====

Mono.Cecil is a library to generate and inspect programs and libraries in the ECMA CIL form.

To put it simply, you can use Cecil to:

* Analyze .NET binaries using a simple and powerful object model, without having to load assemblies to use Reflection.
* Modify .NET binaries, add new metadata structures and alter the IL code.

Cecil has been around since 2004 and is [widely used](https://github.com/jbevain/cecil/wiki/Users) in the .NET community. If you're using Cecil, or depend on a framework, project, or product using it, please consider [sponsoring Cecil](https://github.com/sponsors/jbevain/).

Read about the Cecil development on the [development log](http://cecil.pe).

To discuss Cecil, the best place is the [mono-cecil](https://groups.google.com/group/mono-cecil) Google Group.

Cecil is a project under the benevolent umbrella of the [.NET Foundation](http://www.dotnetfoundation.org/).

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/AssemblyInfo.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

//[assembly: AssemblyTitle ("MonoFN.Cecil.Rocks")]

[assembly: CLSCompliant (false)]

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/DocCommentId.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Collections.Generic;
using System.Text;

namespace MonoFN.Cecil.Rocks {

	public class DocCommentId {
		StringBuilder id;

		DocCommentId ()
		{
			id = new StringBuilder ();
		}

		void WriteField (FieldDefinition field)
		{
			WriteDefinition ('F', field);
		}

		void WriteEvent (EventDefinition @event)
		{
			WriteDefinition ('E', @event);
		}

		void WriteType (TypeDefinition type)
		{
			id.Append ('T').Append (':');
			WriteTypeFullName (type);
		}

		void WriteMethod (MethodDefinition method)
		{
			WriteDefinition ('M', method);

			if (method.HasGenericParameters) {
				id.Append ('`').Append ('`');
				id.Append (method.GenericParameters.Count);
			}

			if (method.HasParameters)
				WriteParameters (method.Parameters);

			if (IsConversionOperator (method))
				WriteReturnType (method);
		}

		static bool IsConversionOperator (MethodDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			return self.IsSpecialName
				&& (self.Name == "op_Explicit" || self.Name == "op_Implicit");
		}

		void WriteReturnType (MethodDefinition method)
		{
			id.Append ('~');
			WriteTypeSignature (method.ReturnType);
		}

		void WriteProperty (PropertyDefinition property)
		{
			WriteDefinition ('P', property);

			if (property.HasParameters)
				WriteParameters (property.Parameters);
		}

		void WriteParameters (IList<ParameterDefinition> parameters)
		{
			id.Append ('(');
			WriteList (parameters, p => WriteTypeSignature (p.ParameterType));
			id.Append (')');
		}

		void WriteTypeSignature (TypeReference type)
		{
			switch (type.MetadataType) {
			case MetadataType.Array:
				WriteArrayTypeSignature ((ArrayType)type);
				break;
			case MetadataType.ByReference:
				WriteTypeSignature (((ByReferenceType)type).ElementType);
				id.Append ('@');
				break;
			case MetadataType.FunctionPointer:
				WriteFunctionPointerTypeSignature ((FunctionPointerType)type);
				break;
			case MetadataType.GenericInstance:
				WriteGenericInstanceTypeSignature ((GenericInstanceType)type);
				break;
			case MetadataType.Var:
				id.Append ('`');
				id.Append (((GenericParameter)type).Position);
				break;
			case MetadataType.MVar:
				id.Append ('`').Append ('`');
				id.Append (((GenericParameter)type).Position);
				break;
			case MetadataType.OptionalModifier:
				WriteModiferTypeSignature ((OptionalModifierType)type, '!');
				break;
			case MetadataType.RequiredModifier:
				WriteModiferTypeSignature ((RequiredModifierType)type, '|');
				break;
			case MetadataType.Pointer:
				WriteTypeSignature (((PointerType)type).ElementType);
				id.Append ('*');
				break;
			default:
				WriteTypeFullName (type);
				break;
			}
		}

		void WriteGenericInstanceTypeSignature (GenericInstanceType type)
		{
			if (type.ElementType.IsTypeSpecification ())
				throw new NotSupportedException ();

			WriteTypeFullName (type.ElementType, stripGenericArity: true);
			id.Append ('{');
			WriteList (type.GenericArguments, WriteTypeSignature);
			id.Append ('}');
		}

		void WriteList<T> (IList<T> list, Action<T> action)
		{
			for (int i = 0; i < list.Count; i++) {
				if (i > 0)
					id.Append (',');

				action (list [i]);
			}
		}

		void WriteModiferTypeSignature (IModifierType type, char id)
		{
			WriteTypeSignature (type.ElementType);
			this.id.Append (id);
			WriteTypeSignature (type.ModifierType);
		}

		void WriteFunctionPointerTypeSignature (FunctionPointerType type)
		{
			id.Append ("=FUNC:");
			WriteTypeSignature (type.ReturnType);

			if (type.HasParameters)
				WriteParameters (type.Parameters);
		}

		void WriteArrayTypeSignature (ArrayType type)
		{
			WriteTypeSignature (type.ElementType);

			if (type.IsVector) {
				id.Append ("[]");
				return;
			}

			id.Append ("[");

			WriteList (type.Dimensions, dimension => {
				if (dimension.LowerBound.HasValue)
					id.Append (dimension.LowerBound.Value);

				id.Append (':');

				if (dimension.UpperBound.HasValue)
					id.Append (dimension.UpperBound.Value - (dimension.LowerBound.GetValueOrDefault () + 1));
			});

			id.Append ("]");
		}

		void WriteDefinition (char id, IMemberDefinition member)
		{
			this.id.Append (id)
				.Append (':');

			WriteTypeFullName (member.DeclaringType);
			this.id.Append ('.');
			WriteItemName (member.Name);
		}

		void WriteTypeFullName (TypeReference type, bool stripGenericArity = false)
		{
			if (type.DeclaringType != null) {
				WriteTypeFullName (type.DeclaringType);
				id.Append ('.');
			}

			if (!string.IsNullOrEmpty (type.Namespace)) {
				id.Append (type.Namespace);
				id.Append ('.');
			}

			var name = type.Name;

			if (stripGenericArity) {
				var index = name.LastIndexOf ('`');
				if (index > 0)
					name = name.Substring (0, index);
			}

			id.Append (name);
		}

		void WriteItemName (string name)
		{
			id.Append (name.Replace ('.', '#').Replace ('<', '{').Replace ('>', '}'));
		}

		public override string ToString ()
		{
			return id.ToString ();
		}

		public static string GetDocCommentId (IMemberDefinition member)
		{
			if (member == null)
				throw new ArgumentNullException ("member");

			var documentId = new DocCommentId ();

			switch (member.MetadataToken.TokenType) {
			case TokenType.Field:
				documentId.WriteField ((FieldDefinition)member);
				break;
			case TokenType.Method:
				documentId.WriteMethod ((MethodDefinition)member);
				break;
			case TokenType.TypeDef:
				documentId.WriteType ((TypeDefinition)member);
				break;
			case TokenType.Event:
				documentId.WriteEvent ((EventDefinition)member);
				break;
			case TokenType.Property:
				documentId.WriteProperty ((PropertyDefinition)member);
				break;
			default:
				throw new NotSupportedException (member.FullName);
			}

			return documentId.ToString ();
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/Functional.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Collections.Generic;

namespace MonoFN.Cecil.Rocks {

	static class Functional {

		public static System.Func<A, R> Y<A, R> (System.Func<System.Func<A, R>, System.Func<A, R>> f)
		{
			System.Func<A, R> g = null;
			g = f (a => g (a));
			return g;
		}

		public static IEnumerable<TSource> Prepend<TSource> (this IEnumerable<TSource> source, TSource element)
		{
			if (source == null)
				throw new ArgumentNullException ("source");

			return PrependIterator (source, element);
		}

		static IEnumerable<TSource> PrependIterator<TSource> (IEnumerable<TSource> source, TSource element)
		{
			yield return element;

			foreach (var item in source)
				yield return item;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/ILParser.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using MonoFN.Collections.Generic;
using System;

namespace MonoFN.Cecil.Rocks {

#if UNITY_EDITOR
	public
#endif
	interface IILVisitor {
		void OnInlineNone (OpCode opcode);
		void OnInlineSByte (OpCode opcode, sbyte value);
		void OnInlineByte (OpCode opcode, byte value);
		void OnInlineInt32 (OpCode opcode, int value);
		void OnInlineInt64 (OpCode opcode, long value);
		void OnInlineSingle (OpCode opcode, float value);
		void OnInlineDouble (OpCode opcode, double value);
		void OnInlineString (OpCode opcode, string value);
		void OnInlineBranch (OpCode opcode, int offset);
		void OnInlineSwitch (OpCode opcode, int [] offsets);
		void OnInlineVariable (OpCode opcode, VariableDefinition variable);
		void OnInlineArgument (OpCode opcode, ParameterDefinition parameter);
		void OnInlineSignature (OpCode opcode, CallSite callSite);
		void OnInlineType (OpCode opcode, TypeReference type);
		void OnInlineField (OpCode opcode, FieldReference field);
		void OnInlineMethod (OpCode opcode, MethodReference method);
	}

#if UNITY_EDITOR
	public
#endif
	static class ILParser {

		class ParseContext {
			public CodeReader Code { get; set; }
			public int Position { get; set; }
			public MetadataReader Metadata { get; set; }
			public Collection<VariableDefinition> Variables { get; set; }
			public IILVisitor Visitor { get; set; }
		}

		public static void Parse (MethodDefinition method, IILVisitor visitor)
		{
			if (method == null)
				throw new ArgumentNullException ("method");
			if (visitor == null)
				throw new ArgumentNullException ("visitor");
			if (!method.HasBody || !method.HasImage)
				throw new ArgumentException ();

			method.Module.Read (method, (m, _) => {
				ParseMethod (m, visitor);
				return true;
			});
		}

		static void ParseMethod (MethodDefinition method, IILVisitor visitor)
		{
			var context = CreateContext (method, visitor);
			var code = context.Code;

			var flags = code.ReadByte ();

			switch (flags & 0x3) {
			case 0x2: // tiny
				int code_size = flags >> 2;
				ParseCode (code_size, context);
				break;
			case 0x3: // fat
				code.Advance (-1);
				ParseFatMethod (context);
				break;
			default:
				throw new NotSupportedException ();
			}

			code.MoveBackTo (context.Position);
		}

		static ParseContext CreateContext (MethodDefinition method, IILVisitor visitor)
		{
			var code = method.Module.Read (method, (_, reader) => reader.code);
			var position = code.MoveTo (method);

			return new ParseContext {
				Code = code,
				Position = position,
				Metadata = code.reader,
				Visitor = visitor,
			};
		}

		static void ParseFatMethod (ParseContext context)
		{
			var code = context.Code;

			code.Advance (4);
			var code_size = code.ReadInt32 ();
			var local_var_token = code.ReadToken ();

			if (local_var_token != MetadataToken.Zero)
				context.Variables = code.ReadVariables (local_var_token);

			ParseCode (code_size, context);
		}

		static void ParseCode (int code_size, ParseContext context)
		{
			var code = context.Code;
			var metadata = context.Metadata;
			var visitor = context.Visitor;

			var start = code.Position;
			var end = start + code_size;

			while (code.Position < end) {
				var il_opcode = code.ReadByte ();
				var opcode = il_opcode != 0xfe
					? OpCodes.OneByteOpCode [il_opcode]
					: OpCodes.TwoBytesOpCode [code.ReadByte ()];

				switch (opcode.OperandType) {
				case OperandType.InlineNone:
					visitor.OnInlineNone (opcode);
					break;
				case OperandType.InlineSwitch:
					var length = code.ReadInt32 ();
					var branches = new int [length];
					for (int i = 0; i < length; i++)
						branches [i] = code.ReadInt32 ();
					visitor.OnInlineSwitch (opcode, branches);
					break;
				case OperandType.ShortInlineBrTarget:
					visitor.OnInlineBranch (opcode, code.ReadSByte ());
					break;
				case OperandType.InlineBrTarget:
					visitor.OnInlineBranch (opcode, code.ReadInt32 ());
					break;
				case OperandType.ShortInlineI:
					if (opcode == OpCodes.Ldc_I4_S)
						visitor.OnInlineSByte (opcode, code.ReadSByte ());
					else
						visitor.OnInlineByte (opcode, code.ReadByte ());
					break;
				case OperandType.InlineI:
					visitor.OnInlineInt32 (opcode, code.ReadInt32 ());
					break;
				case OperandType.InlineI8:
					visitor.OnInlineInt64 (opcode, code.ReadInt64 ());
					break;
				case OperandType.ShortInlineR:
					visitor.OnInlineSingle (opcode, code.ReadSingle ());
					break;
				case OperandType.InlineR:
					visitor.OnInlineDouble (opcode, code.ReadDouble ());
					break;
				case OperandType.InlineSig:
					visitor.OnInlineSignature (opcode, code.GetCallSite (code.ReadToken ()));
					break;
				case OperandType.InlineString:
					visitor.OnInlineString (opcode, code.GetString (code.ReadToken ()));
					break;
				case OperandType.ShortInlineArg:
					visitor.OnInlineArgument (opcode, code.GetParameter (code.ReadByte ()));
					break;
				case OperandType.InlineArg:
					visitor.OnInlineArgument (opcode, code.GetParameter (code.ReadInt16 ()));
					break;
				case OperandType.ShortInlineVar:
					visitor.OnInlineVariable (opcode, GetVariable (context, code.ReadByte ()));
					break;
				case OperandType.InlineVar:
					visitor.OnInlineVariable (opcode, GetVariable (context, code.ReadInt16 ()));
					break;
				case OperandType.InlineTok:
				case OperandType.InlineField:
				case OperandType.InlineMethod:
				case OperandType.InlineType:
					var member = metadata.LookupToken (code.ReadToken ());
					switch (member.MetadataToken.TokenType) {
					case TokenType.TypeDef:
					case TokenType.TypeRef:
					case TokenType.TypeSpec:
						visitor.OnInlineType (opcode, (TypeReference)member);
						break;
					case TokenType.Method:
					case TokenType.MethodSpec:
						visitor.OnInlineMethod (opcode, (MethodReference)member);
						break;
					case TokenType.Field:
						visitor.OnInlineField (opcode, (FieldReference)member);
						break;
					case TokenType.MemberRef:
						var field_ref = member as FieldReference;
						if (field_ref != null) {
							visitor.OnInlineField (opcode, field_ref);
							break;
						}

						var method_ref = member as MethodReference;
						if (method_ref != null) {
							visitor.OnInlineMethod (opcode, method_ref);
							break;
						}

						throw new InvalidOperationException ();
					}
					break;
				}
			}
		}

		static VariableDefinition GetVariable (ParseContext context, int index)
		{
			return context.Variables [index];
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/MethodBodyRocks.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using MonoFN.Cecil.Cil;
using System;

namespace MonoFN.Cecil.Rocks {

#if UNITY_EDITOR
	public
#endif
	static class MethodBodyRocks {

		public static void SimplifyMacros (this MethodBody self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			foreach (var instruction in self.Instructions) {
				if (instruction.OpCode.OpCodeType != OpCodeType.Macro)
					continue;

				switch (instruction.OpCode.Code) {
				case Code.Ldarg_0:
					ExpandMacro (instruction, OpCodes.Ldarg, self.GetParameter (0));
					break;
				case Code.Ldarg_1:
					ExpandMacro (instruction, OpCodes.Ldarg, self.GetParameter (1));
					break;
				case Code.Ldarg_2:
					ExpandMacro (instruction, OpCodes.Ldarg, self.GetParameter (2));
					break;
				case Code.Ldarg_3:
					ExpandMacro (instruction, OpCodes.Ldarg, self.GetParameter (3));
					break;
				case Code.Ldloc_0:
					ExpandMacro (instruction, OpCodes.Ldloc, self.Variables [0]);
					break;
				case Code.Ldloc_1:
					ExpandMacro (instruction, OpCodes.Ldloc, self.Variables [1]);
					break;
				case Code.Ldloc_2:
					ExpandMacro (instruction, OpCodes.Ldloc, self.Variables [2]);
					break;
				case Code.Ldloc_3:
					ExpandMacro (instruction, OpCodes.Ldloc, self.Variables [3]);
					break;
				case Code.Stloc_0:
					ExpandMacro (instruction, OpCodes.Stloc, self.Variables [0]);
					break;
				case Code.Stloc_1:
					ExpandMacro (instruction, OpCodes.Stloc, self.Variables [1]);
					break;
				case Code.Stloc_2:
					ExpandMacro (instruction, OpCodes.Stloc, self.Variables [2]);
					break;
				case Code.Stloc_3:
					ExpandMacro (instruction, OpCodes.Stloc, self.Variables [3]);
					break;
				case Code.Ldarg_S:
					instruction.OpCode = OpCodes.Ldarg;
					break;
				case Code.Ldarga_S:
					instruction.OpCode = OpCodes.Ldarga;
					break;
				case Code.Starg_S:
					instruction.OpCode = OpCodes.Starg;
					break;
				case Code.Ldloc_S:
					instruction.OpCode = OpCodes.Ldloc;
					break;
				case Code.Ldloca_S:
					instruction.OpCode = OpCodes.Ldloca;
					break;
				case Code.Stloc_S:
					instruction.OpCode = OpCodes.Stloc;
					break;
				case Code.Ldc_I4_M1:
					ExpandMacro (instruction, OpCodes.Ldc_I4, -1);
					break;
				case Code.Ldc_I4_0:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 0);
					break;
				case Code.Ldc_I4_1:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 1);
					break;
				case Code.Ldc_I4_2:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 2);
					break;
				case Code.Ldc_I4_3:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 3);
					break;
				case Code.Ldc_I4_4:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 4);
					break;
				case Code.Ldc_I4_5:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 5);
					break;
				case Code.Ldc_I4_6:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 6);
					break;
				case Code.Ldc_I4_7:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 7);
					break;
				case Code.Ldc_I4_8:
					ExpandMacro (instruction, OpCodes.Ldc_I4, 8);
					break;
				case Code.Ldc_I4_S:
					ExpandMacro (instruction, OpCodes.Ldc_I4, (int)(sbyte)instruction.Operand);
					break;
				case Code.Br_S:
					instruction.OpCode = OpCodes.Br;
					break;
				case Code.Brfalse_S:
					instruction.OpCode = OpCodes.Brfalse;
					break;
				case Code.Brtrue_S:
					instruction.OpCode = OpCodes.Brtrue;
					break;
				case Code.Beq_S:
					instruction.OpCode = OpCodes.Beq;
					break;
				case Code.Bge_S:
					instruction.OpCode = OpCodes.Bge;
					break;
				case Code.Bgt_S:
					instruction.OpCode = OpCodes.Bgt;
					break;
				case Code.Ble_S:
					instruction.OpCode = OpCodes.Ble;
					break;
				case Code.Blt_S:
					instruction.OpCode = OpCodes.Blt;
					break;
				case Code.Bne_Un_S:
					instruction.OpCode = OpCodes.Bne_Un;
					break;
				case Code.Bge_Un_S:
					instruction.OpCode = OpCodes.Bge_Un;
					break;
				case Code.Bgt_Un_S:
					instruction.OpCode = OpCodes.Bgt_Un;
					break;
				case Code.Ble_Un_S:
					instruction.OpCode = OpCodes.Ble_Un;
					break;
				case Code.Blt_Un_S:
					instruction.OpCode = OpCodes.Blt_Un;
					break;
				case Code.Leave_S:
					instruction.OpCode = OpCodes.Leave;
					break;
				}
			}
		}

		static void ExpandMacro (Instruction instruction, OpCode opcode, object operand)
		{
			instruction.OpCode = opcode;
			instruction.Operand = operand;
		}

		static void MakeMacro (Instruction instruction, OpCode opcode)
		{
			instruction.OpCode = opcode;
			instruction.Operand = null;
		}

		public static void Optimize (this MethodBody self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			OptimizeLongs (self);
			OptimizeMacros (self);
		}

		static void OptimizeLongs (this MethodBody self)
		{
			for (var i = 0; i < self.Instructions.Count; i++) {
				var instruction = self.Instructions [i];
				if (instruction.OpCode.Code != Code.Ldc_I8)
					continue;
				var l = (long)instruction.Operand;
				if (l >= int.MaxValue || l <= int.MinValue)
					continue;
				ExpandMacro (instruction, OpCodes.Ldc_I4, (int)l);
				self.Instructions.Insert (++i, Instruction.Create (OpCodes.Conv_I8));
			}
		}

		public static void OptimizeMacros (this MethodBody self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			var method = self.Method;

			foreach (var instruction in self.Instructions) {
				int index;
				switch (instruction.OpCode.Code) {
				case Code.Ldarg:
					index = ((ParameterDefinition)instruction.Operand).Index;
					if (index == -1 && instruction.Operand == self.ThisParameter)
						index = 0;
					else if (method.HasThis)
						index++;

					switch (index) {
					case 0:
						MakeMacro (instruction, OpCodes.Ldarg_0);
						break;
					case 1:
						MakeMacro (instruction, OpCodes.Ldarg_1);
						break;
					case 2:
						MakeMacro (instruction, OpCodes.Ldarg_2);
						break;
					case 3:
						MakeMacro (instruction, OpCodes.Ldarg_3);
						break;
					default:
						if (index < 256)
							ExpandMacro (instruction, OpCodes.Ldarg_S, instruction.Operand);
						break;
					}
					break;
				case Code.Ldloc:
					index = ((VariableDefinition)instruction.Operand).Index;
					switch (index) {
					case 0:
						MakeMacro (instruction, OpCodes.Ldloc_0);
						break;
					case 1:
						MakeMacro (instruction, OpCodes.Ldloc_1);
						break;
					case 2:
						MakeMacro (instruction, OpCodes.Ldloc_2);
						break;
					case 3:
						MakeMacro (instruction, OpCodes.Ldloc_3);
						break;
					default:
						if (index < 256)
							ExpandMacro (instruction, OpCodes.Ldloc_S, instruction.Operand);
						break;
					}
					break;
				case Code.Stloc:
					index = ((VariableDefinition)instruction.Operand).Index;
					switch (index) {
					case 0:
						MakeMacro (instruction, OpCodes.Stloc_0);
						break;
					case 1:
						MakeMacro (instruction, OpCodes.Stloc_1);
						break;
					case 2:
						MakeMacro (instruction, OpCodes.Stloc_2);
						break;
					case 3:
						MakeMacro (instruction, OpCodes.Stloc_3);
						break;
					default:
						if (index < 256)
							ExpandMacro (instruction, OpCodes.Stloc_S, instruction.Operand);
						break;
					}
					break;
				case Code.Ldarga:
					index = ((ParameterDefinition)instruction.Operand).Index;
					if (index == -1 && instruction.Operand == self.ThisParameter)
						index = 0;
					else if (method.HasThis)
						index++;
					if (index < 256)
						ExpandMacro (instruction, OpCodes.Ldarga_S, instruction.Operand);
					break;
				case Code.Ldloca:
					if (((VariableDefinition)instruction.Operand).Index < 256)
						ExpandMacro (instruction, OpCodes.Ldloca_S, instruction.Operand);
					break;
				case Code.Ldc_I4:
					int i = (int)instruction.Operand;
					switch (i) {
					case -1:
						MakeMacro (instruction, OpCodes.Ldc_I4_M1);
						break;
					case 0:
						MakeMacro (instruction, OpCodes.Ldc_I4_0);
						break;
					case 1:
						MakeMacro (instruction, OpCodes.Ldc_I4_1);
						break;
					case 2:
						MakeMacro (instruction, OpCodes.Ldc_I4_2);
						break;
					case 3:
						MakeMacro (instruction, OpCodes.Ldc_I4_3);
						break;
					case 4:
						MakeMacro (instruction, OpCodes.Ldc_I4_4);
						break;
					case 5:
						MakeMacro (instruction, OpCodes.Ldc_I4_5);
						break;
					case 6:
						MakeMacro (instruction, OpCodes.Ldc_I4_6);
						break;
					case 7:
						MakeMacro (instruction, OpCodes.Ldc_I4_7);
						break;
					case 8:
						MakeMacro (instruction, OpCodes.Ldc_I4_8);
						break;
					default:
						if (i >= -128 && i < 128)
							ExpandMacro (instruction, OpCodes.Ldc_I4_S, (sbyte)i);
						break;
					}
					break;
				}
			}

			OptimizeBranches (self);
		}

		static void OptimizeBranches (MethodBody body)
		{
			ComputeOffsets (body);

			foreach (var instruction in body.Instructions) {
				if (instruction.OpCode.OperandType != OperandType.InlineBrTarget)
					continue;

				if (OptimizeBranch (instruction))
					ComputeOffsets (body);
			}
		}

		static bool OptimizeBranch (Instruction instruction)
		{
			var offset = ((Instruction)instruction.Operand).Offset - (instruction.Offset + instruction.OpCode.Size + 4);
			if (!(offset >= -128 && offset <= 127))
				return false;

			switch (instruction.OpCode.Code) {
			case Code.Br:
				instruction.OpCode = OpCodes.Br_S;
				break;
			case Code.Brfalse:
				instruction.OpCode = OpCodes.Brfalse_S;
				break;
			case Code.Brtrue:
				instruction.OpCode = OpCodes.Brtrue_S;
				break;
			case Code.Beq:
				instruction.OpCode = OpCodes.Beq_S;
				break;
			case Code.Bge:
				instruction.OpCode = OpCodes.Bge_S;
				break;
			case Code.Bgt:
				instruction.OpCode = OpCodes.Bgt_S;
				break;
			case Code.Ble:
				instruction.OpCode = OpCodes.Ble_S;
				break;
			case Code.Blt:
				instruction.OpCode = OpCodes.Blt_S;
				break;
			case Code.Bne_Un:
				instruction.OpCode = OpCodes.Bne_Un_S;
				break;
			case Code.Bge_Un:
				instruction.OpCode = OpCodes.Bge_Un_S;
				break;
			case Code.Bgt_Un:
				instruction.OpCode = OpCodes.Bgt_Un_S;
				break;
			case Code.Ble_Un:
				instruction.OpCode = OpCodes.Ble_Un_S;
				break;
			case Code.Blt_Un:
				instruction.OpCode = OpCodes.Blt_Un_S;
				break;
			case Code.Leave:
				instruction.OpCode = OpCodes.Leave_S;
				break;
			}

			return true;
		}

		static void ComputeOffsets (MethodBody body)
		{
			var offset = 0;
			foreach (var instruction in body.Instructions) {
				instruction.Offset = offset;
				offset += instruction.GetSize ();
			}
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/MethodDefinitionRocks.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil.Rocks {

#if UNITY_EDITOR
	public
#endif
	static class MethodDefinitionRocks {

		public static MethodDefinition GetBaseMethod (this MethodDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");
			if (!self.IsVirtual)
				return self;
			if (self.IsNewSlot)
				return self;

			var base_type = ResolveBaseType (self.DeclaringType);
			while (base_type != null) {
				var @base = GetMatchingMethod (base_type, self);
				if (@base != null)
					return @base;

				base_type = ResolveBaseType (base_type);
			}

			return self;
		}

		public static MethodDefinition GetOriginalBaseMethod (this MethodDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			while (true) {
				var @base = self.GetBaseMethod ();
				if (@base == self)
					return self;

				self = @base;
			}
		}

		static TypeDefinition ResolveBaseType (TypeDefinition type)
		{
			if (type == null)
				return null;

			var base_type = type.BaseType;
			if (base_type == null)
				return null;

			return base_type.Resolve ();
		}

		static MethodDefinition GetMatchingMethod (TypeDefinition type, MethodDefinition method)
		{
			return MetadataResolver.GetMethod (type.Methods, method);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/ModuleDefinitionRocks.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Collections.Generic;
using System.Linq;

namespace MonoFN.Cecil.Rocks {

#if UNITY_EDITOR
	public
#endif
	static class ModuleDefinitionRocks {

		public static IEnumerable<TypeDefinition> GetAllTypes (this ModuleDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			// it was fun to write, but we need a somewhat less convoluted implementation
			return self.Types.SelectMany (
				Functional.Y<TypeDefinition, IEnumerable<TypeDefinition>> (f => type => type.NestedTypes.SelectMany (f).Prepend (type)));
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/ParameterReferenceRocks.cs ---

namespace MonoFN.Cecil.Rocks {

	public static class ParameterReferenceRocks {

		public static int GetSequence (this ParameterReference self)
		{
			return self.Index + 1;
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/SecurityDeclarationRocks.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

#if !NET_CORE

using System;
using System.Security;
using SSP = System.Security.Permissions;

namespace MonoFN.Cecil.Rocks {

#if UNITY_EDITOR
	public
#endif
	static class SecurityDeclarationRocks {

		public static PermissionSet ToPermissionSet (this SecurityDeclaration self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			PermissionSet set;
			if (TryProcessPermissionSetAttribute (self, out set))
				return set;

			return CreatePermissionSet (self);
		}

		static bool TryProcessPermissionSetAttribute (SecurityDeclaration declaration, out PermissionSet set)
		{
			set = null;

			if (!declaration.HasSecurityAttributes && declaration.SecurityAttributes.Count != 1)
				return false;

			var security_attribute = declaration.SecurityAttributes [0];
			if (!security_attribute.AttributeType.IsTypeOf ("System.Security.Permissions", "PermissionSetAttribute"))
				return false;

			var attribute = new SSP.PermissionSetAttribute ((SSP.SecurityAction)declaration.Action);

			var named_argument = security_attribute.Properties [0];
			string value = (string)named_argument.Argument.Value;
			switch (named_argument.Name) {
			case "XML":
				attribute.XML = value;
				break;
			case "Name":
				attribute.Name = value;
				break;
			default:
				throw new NotImplementedException (named_argument.Name);
			}

			set = attribute.CreatePermissionSet ();
			return true;
		}

		static PermissionSet CreatePermissionSet (SecurityDeclaration declaration)
		{
			var set = new PermissionSet (SSP.PermissionState.None);

			foreach (var attribute in declaration.SecurityAttributes) {
				var permission = CreatePermission (declaration, attribute);
				set.AddPermission (permission);
			}

			return set;
		}

		static IPermission CreatePermission (SecurityDeclaration declaration, SecurityAttribute attribute)
		{
			var attribute_type = Type.GetType (attribute.AttributeType.FullName);
			if (attribute_type == null)
				throw new ArgumentException ("attribute");

			var security_attribute = CreateSecurityAttribute (attribute_type, declaration);
			if (security_attribute == null)
				throw new InvalidOperationException ();

			CompleteSecurityAttribute (security_attribute, attribute);

			return security_attribute.CreatePermission ();
		}

		static void CompleteSecurityAttribute (SSP.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			if (attribute.HasFields)
				CompleteSecurityAttributeFields (security_attribute, attribute);

			if (attribute.HasProperties)
				CompleteSecurityAttributeProperties (security_attribute, attribute);
		}

		static void CompleteSecurityAttributeFields (SSP.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			var type = security_attribute.GetType ();

			foreach (var named_argument in attribute.Fields)
				type.GetField (named_argument.Name).SetValue (security_attribute, named_argument.Argument.Value);
		}

		static void CompleteSecurityAttributeProperties (SSP.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			var type = security_attribute.GetType ();

			foreach (var named_argument in attribute.Properties)
				type.GetProperty (named_argument.Name).SetValue (security_attribute, named_argument.Argument.Value, null);
		}

		static SSP.SecurityAttribute CreateSecurityAttribute (Type attribute_type, SecurityDeclaration declaration)
		{
			SSP.SecurityAttribute security_attribute;
			try {
				security_attribute = (SSP.SecurityAttribute)Activator.CreateInstance (
					attribute_type, new object [] { (SSP.SecurityAction)declaration.Action });
			}
			catch (MissingMethodException) {
				security_attribute = (SSP.SecurityAttribute)Activator.CreateInstance (attribute_type, new object [0]);
			}

			return security_attribute;
		}

		public static SecurityDeclaration ToSecurityDeclaration (this PermissionSet self, SecurityAction action, ModuleDefinition module)
		{
			if (self == null)
				throw new ArgumentNullException ("self");
			if (module == null)
				throw new ArgumentNullException ("module");

			var declaration = new SecurityDeclaration (action);

			var attribute = new SecurityAttribute (
				module.TypeSystem.LookupType ("System.Security.Permissions", "PermissionSetAttribute"));

			attribute.Properties.Add (
				new CustomAttributeNamedArgument (
					"XML",
					new CustomAttributeArgument (
						module.TypeSystem.String, self.ToXml ().ToString ())));

			declaration.SecurityAttributes.Add (attribute);

			return declaration;
		}
	}
}

#endif

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/TypeDefinitionRocks.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;
using System.Collections.Generic;
using System.Linq;

namespace MonoFN.Cecil.Rocks {

#if UNITY_EDITOR
	public
#endif
	static class TypeDefinitionRocks {

		public static IEnumerable<MethodDefinition> GetConstructors (this TypeDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			if (!self.HasMethods)
				return Empty<MethodDefinition>.Array;

			return self.Methods.Where (method => method.IsConstructor);
		}

		public static MethodDefinition GetStaticConstructor (this TypeDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			if (!self.HasMethods)
				return null;

			return self.GetConstructors ().FirstOrDefault (ctor => ctor.IsStatic);
		}

		public static IEnumerable<MethodDefinition> GetMethods (this TypeDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");

			if (!self.HasMethods)
				return Empty<MethodDefinition>.Array;

			return self.Methods.Where (method => !method.IsConstructor);
		}

		public static TypeReference GetEnumUnderlyingType (this TypeDefinition self)
		{
			if (self == null)
				throw new ArgumentNullException ("self");
			if (!self.IsEnum)
				throw new ArgumentException ();

			return Mixin.GetEnumUnderlyingType (self);
		}
	}
}

'''
'''--- Assets/FishNet/CodeGenerating/cecil-0.11.4/rocks/Mono.Cecil.Rocks/TypeReferenceRocks.cs ---
//
// Author:
//   Jb Evain (jbevain@gmail.com)
//
// Copyright (c) 2008 - 2015 Jb Evain
// Copyright (c) 2008 - 2011 Novell, Inc.
//
// Licensed under the MIT/X11 license.
//

using System;

namespace MonoFN.Cecil.Rocks {

#if UNITY_EDITOR
	public
#endif
	static class TypeReferenceRocks {

		public static ArrayType MakeArrayType (this TypeReference self)
		{
			return new ArrayType (self);
		}

		public static ArrayType MakeArrayType (this TypeReference self, int rank)
		{
			if (rank == 0)
				throw new ArgumentOutOfRangeException ("rank");

			var array = new ArrayType (self);

			for (int i = 1; i < rank; i++)
				array.Dimensions.Add (new ArrayDimension ());

			return array;
		}

		public static PointerType MakePointerType (this TypeReference self)
		{
			return new PointerType (self);
		}

		public static ByReferenceType MakeByReferenceType (this TypeReference self)
		{
			return new ByReferenceType (self);
		}

		public static OptionalModifierType MakeOptionalModifierType (this TypeReference self, TypeReference modifierType)
		{
			return new OptionalModifierType (modifierType, self);
		}

		public static RequiredModifierType MakeRequiredModifierType (this TypeReference self, TypeReference modifierType)
		{
			return new RequiredModifierType (modifierType, self);
		}

		public static GenericInstanceType MakeGenericInstanceType (this TypeReference self, params TypeReference [] arguments)
		{
			if (self == null)
				throw new ArgumentNullException ("self");
			if (arguments == null)
				throw new ArgumentNullException ("arguments");
			if (arguments.Length == 0)
				throw new ArgumentException ();
			if (self.GenericParameters.Count != arguments.Length)
				throw new ArgumentException ();

			var instance = new GenericInstanceType (self, arguments.Length);

			foreach (var argument in arguments)
				instance.GenericArguments.Add (argument);

			return instance;
		}

		public static PinnedType MakePinnedType (this TypeReference self)
		{
			return new PinnedType (self);
		}

		public static SentinelType MakeSentinelType (this TypeReference self)
		{
			return new SentinelType (self);
		}
	}
}

'''
'''--- Assets/FishNet/DOCUMENTATION.txt ---
Please view our online documentation for the most up to date information: https://fish-networking.gitbook.io/docs/

Support is available on our discord. Please contact FirstGearGames#0001 @ https://discord.gg/Ta9HgDh4Hj
'''
'''--- Assets/FishNet/Example/All/Authenticator/Scripts/Broadcasts.cs ---
﻿
using FishNet.Broadcast;

namespace FishNet.Example.Authenticating
{
    public struct HostPasswordBroadcast : IBroadcast
    {
        public string Password;
    }

    public struct PasswordBroadcast : IBroadcast
    {
        public string Password;
    }

    public struct ResponseBroadcast : IBroadcast
    {
        public bool Passed;
    }

}
'''
'''--- Assets/FishNet/Example/All/Authenticator/Scripts/HostAuthenticator.cs ---
﻿using FishNet.Connection;
using FishNet.Example.Authenticating;
using FishNet.Managing;
using FishNet.Transporting;
using System;
using System.Security.Cryptography;
using System.Text;
using UnityEngine;

namespace FishNet.Authenticating
{

    /// <summary>
    /// This authenticator is an example of how to let host bypass the authentication process.
    /// When checking to authenticate on the client side call AuthenticateAsHost, and if returned true skip normal authentication.
    /// </summary>
    public abstract class HostAuthenticator : Authenticator
    {
        #region Serialized.
        /// <summary>
        /// True to enable use of AuthenticateAsHost.
        /// </summary>
        [Tooltip("True to enable use of AuthenticateAsHost.")]
        [SerializeField]
        private bool _allowHostAuthentication;
        /// <summary>
        /// Sets if to allow host authentication.
        /// </summary>
        /// <param name="value"></param>
        public void SetAllowHostAuthentication(bool value) => _allowHostAuthentication = value;
        /// <summary>
        /// Returns if AllowHostAuthentication is enabled.
        /// </summary>
        /// <returns></returns>
        public bool GetAllowHostAuthentication() => _allowHostAuthentication;
        #endregion

        #region Private.
        /// <summary>
        /// A random hash which only exist if the server is started.
        /// </summary>
        private static string _hostHash = string.Empty;
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="networkManager"></param>
        public override void InitializeOnce(NetworkManager networkManager)
        {
            base.InitializeOnce(networkManager);
            //Listen for connection state of local server to set hash.
            base.NetworkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
            //Listen for broadcast from client. Be sure to set requireAuthentication to false.
            base.NetworkManager.ServerManager.RegisterBroadcast<HostPasswordBroadcast>(OnHostPasswordBroadcast, false);
        }

        /// <summary>
        /// Called after the local server connection state changes.
        /// </summary>
        private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
        {
            int length = (obj.ConnectionState == LocalConnectionState.Started) ? 25 : 0;
            SetHostHash(length);
        }

        /// <summary>
        /// Received on server when a client sends the password broadcast message.
        /// </summary>
        /// <param name="conn">Connection sending broadcast.</param>
        /// <param name="hpb"></param>
        private void OnHostPasswordBroadcast(NetworkConnection conn, HostPasswordBroadcast hpb)
        {
            //Not accepting host authentications. This could be an attack.
            if (!_allowHostAuthentication)
            {
                conn.Disconnect(true);
                return;
            }
            /* If client is already authenticated this could be an attack. Connections
             * are removed when a client disconnects so there is no reason they should
             * already be considered authenticated. */
            if (conn.Authenticated)
            {
                conn.Disconnect(true);
                return;
            }

            bool correctPassword = (hpb.Password == _hostHash);
            OnHostAuthenticationResult(conn, correctPassword);
        }

        /// <summary>
        /// Called after handling a host authentication result.
        /// </summary>
        /// <param name="conn">Connection authenticating.</param>
        /// <param name="authenticated">True if authentication passed.</param>
        protected abstract void OnHostAuthenticationResult(NetworkConnection conn, bool authenticated);    

        /// <summary>
        /// Sets a host hash of length.
        /// </summary>
        /// https://stackoverflow.com/questions/32932679/using-rngcryptoserviceprovider-to-generate-random-string
        private void SetHostHash(int length)
        {            
            if (length <= 0)
            {
                _hostHash = string.Empty;
            }
            else
            {
                const string charPool = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()";
                StringBuilder result = new StringBuilder();
                using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())
                {
                    byte[] uintBuffer = new byte[sizeof(uint)];
                    while (length-- > 0)
                    {
                        rng.GetBytes(uintBuffer);
                        uint num = BitConverter.ToUInt32(uintBuffer, 0);
                        result.Append(charPool[(int)(num % (uint)charPool.Length)]);
                    }
                }

                _hostHash = result.ToString();
            }
        }

        /// <summary>
        /// Returns true if authentication was sent as host.
        /// </summary>
        /// <returns></returns>
        protected bool AuthenticateAsHost()
        {
            if (!_allowHostAuthentication)
                return false;
            if (_hostHash == string.Empty)
                return false;

            HostPasswordBroadcast hpb = new HostPasswordBroadcast()
            {
                Password = _hostHash,
            };

            base.NetworkManager.ClientManager.Broadcast(hpb);
            return true;
        }

    }

}
'''
'''--- Assets/FishNet/Example/All/Authenticator/Scripts/PasswordAuthenticator.cs ---
﻿using FishNet.Authenticating;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Transporting;
using System;
using UnityEngine;

namespace FishNet.Example.Authenticating
{
    /// <summary>
    /// This is an example of a password authenticator.
    /// Never send passwords without encryption.
    /// </summary>
    public class PasswordAuthenticator : HostAuthenticator
    {
        #region Public.
        /// <summary>
        /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed.
        /// Server listens for this event automatically.
        /// </summary>
        public override event Action<NetworkConnection, bool> OnAuthenticationResult;
        #endregion

        #region Serialized.
        /// <summary>
        /// Password to authenticate.
        /// </summary>
        [Tooltip("Password to authenticate.")]
        [SerializeField]
        private string _password = "HelloWorld";
        #endregion

        public override void InitializeOnce(NetworkManager networkManager)
        {
            base.InitializeOnce(networkManager);

            //Listen for connection state change as client.
            base.NetworkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;
            //Listen for broadcast from client. Be sure to set requireAuthentication to false.
            base.NetworkManager.ServerManager.RegisterBroadcast<PasswordBroadcast>(OnPasswordBroadcast, false);
            //Listen to response from server.
            base.NetworkManager.ClientManager.RegisterBroadcast<ResponseBroadcast>(OnResponseBroadcast);
        }

        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs args)
        {
            /* If anything but the started state then exit early.
             * Only try to authenticate on started state. The server
            * doesn't have to send an authentication request before client
            * can authenticate, that is entirely optional and up to you. In this
            * example the client tries to authenticate soon as they connect. */
            if (args.ConnectionState != LocalConnectionState.Started)
                return;
            //Authentication was sent as host, no need to authenticate normally.
            if (AuthenticateAsHost())
                return;

            PasswordBroadcast pb = new PasswordBroadcast()
            {
                Password = _password
            };

            base.NetworkManager.ClientManager.Broadcast(pb);
        }

        /// <summary>
        /// Received on server when a client sends the password broadcast message.
        /// </summary>
        /// <param name="conn">Connection sending broadcast.</param>
        /// <param name="pb"></param>
        private void OnPasswordBroadcast(NetworkConnection conn, PasswordBroadcast pb)
        {
            /* If client is already authenticated this could be an attack. Connections
             * are removed when a client disconnects so there is no reason they should
             * already be considered authenticated. */
            if (conn.Authenticated)
            {
                conn.Disconnect(true);
                return;
            }

            bool correctPassword = (pb.Password == _password);
            SendAuthenticationResponse(conn, correctPassword);
            /* Invoke result. This is handled internally to complete the connection or kick client.
             * It's important to call this after sending the broadcast so that the broadcast
             * makes it out to the client before the kick. */
            OnAuthenticationResult?.Invoke(conn, correctPassword);
        }

        /// <summary>
        /// Received on client after server sends an authentication response.
        /// </summary>
        /// <param name="rb"></param>
        private void OnResponseBroadcast(ResponseBroadcast rb)
        {
            string result = (rb.Passed) ? "Authentication complete." : "Authenitcation failed.";
            if (NetworkManager.CanLog(LoggingType.Common))
                Debug.Log(result);
        }

        /// <summary>
        /// Sends an authentication result to a connection.
        /// </summary>
        private void SendAuthenticationResponse(NetworkConnection conn, bool authenticated)
        {
            /* Tell client if they authenticated or not. This is
            * entirely optional but does demonstrate that you can send
            * broadcasts to client on pass or fail. */
            ResponseBroadcast rb = new ResponseBroadcast()
            {
                Passed = authenticated
            };
            base.NetworkManager.ServerManager.Broadcast(conn, rb, false);
        }
        /// <summary>
        /// Called after handling a host authentication result.
        /// </summary>
        /// <param name="conn">Connection authenticating.</param>
        /// <param name="authenticated">True if authentication passed.</param>
        protected override void OnHostAuthenticationResult(NetworkConnection conn, bool authenticated)
        {
            SendAuthenticationResponse(conn, authenticated);
            OnAuthenticationResult?.Invoke(conn, authenticated);
        }
    }

}

'''
'''--- Assets/FishNet/Example/All/CustomSyncType/Component State Sync/AMonoScript.cs ---
﻿using UnityEngine;

namespace FishNet.Example.ComponentStateSync
{

    public class AMonoScript : MonoBehaviour
    {

        private void Start()
        {
            //Start is here to show enabled toggle within inspector.
        }
    }

}
'''
'''--- Assets/FishNet/Example/All/CustomSyncType/Component State Sync/ComponentStateSync.cs ---
﻿using FishNet.Managing.Logging;
using FishNet.Object.Synchronizing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Example.ComponentStateSync
{

    /// <summary>
    /// It's very important to exclude this from codegen.
    /// However, whichever value you are synchronizing must not be excluded. This is why the value is outside the StructySync class.
    /// </summary>
    public class ComponentStateSync<T> : SyncBase, ICustomSync where T : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Gets or Sets the enabled state for Component.
        /// </summary>
        public bool Enabled
        {
            get => (Component == null) ? false : GetState();
            set => SetState(value);
        } 
        /// <summary>
        /// Component to state sync.
        /// </summary>
        public T Component { get; private set; }
        /// <summary>
        /// Delegate signature for when the component changes.
        /// </summary>
        public delegate void StateChanged(T component, bool prevState, bool nextState, bool asServer);
        /// <summary>
        /// Called when the component state changes.
        /// </summary>
        public event StateChanged OnChange;
        #endregion

        /// <summary>
        /// Initializes this StateSync with a component.
        /// </summary>
        /// <param name="monoComponent"></param>
        public void Initialize(T component)
        {
            Component = component;
        }

        /// <summary>
        /// Sets the enabled state for Component.
        /// </summary>
        /// <param name="enabled"></param>
        private void SetState(bool enabled)
        {
            if (base.NetworkManager == null)
                return;

            if (Component == null)
            {
                if (base.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"State cannot be changed as Initialize has not been called with a valid component.");
            }

            //If hasn't changed then ignore.
            bool prev = GetState();
            if (enabled == prev)
                return;

            //Set to new value and add operation.
            Component.enabled = enabled;
            AddOperation(Component, prev, enabled);
        }

        /// <summary>
        /// Gets the enabled state for Component.
        /// </summary>
        /// <returns></returns>
        private bool GetState()
        {
            return Component.enabled;
        }

        /// <summary>
        /// Adds an operation to synchronize.
        /// </summary>
        private void AddOperation(T component, bool prev, bool next)
        {
            if (!base.IsRegistered)
                return;

            if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot complete operation as server when server is not active.");
                return;
            }

            base.Dirty();

            //Data can currently only be set from server, so this is always asServer.
            bool asServer = true;
            OnChange?.Invoke(component, prev, next, asServer);
        }
        /// <summary>
        /// Writes all changed values.
        /// </summary>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        public override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.WriteBoolean(Component.enabled);
        }

        /// <summary>
        /// Writes all values.
        /// </summary>
        public override void WriteFull(PooledWriter writer)
        {
            /* Always write full for this custom sync type.
             * It would be difficult to know if the
             * state has changed given it's a boolean, and
             * may or may not be true/false after pooling is added. */
            WriteDelta(writer, false);
        }

        /// <summary>
        /// Reads and sets the current values.
        /// </summary>
        public override void Read(PooledReader reader)
        {
            //Read is always on client side.
            bool asServer = false;
            bool nextValue = reader.ReadBoolean();
            if (base.NetworkManager == null)
                return;

            bool prevValue = GetState();

            /* When !asServer don't make changes if server is running.
            * This is because changes would have already been made on
            * the server side and doing so again would result in duplicates
            * and potentially overwrite data not yet sent. */
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServer);
            if (!asClientAndHost)
                Component.enabled = nextValue;

            OnChange?.Invoke(Component, prevValue, nextValue, asServer);
        }

        /// <summary>
        /// Return the serialized type.
        /// </summary>
        /// <returns></returns>
        public object GetSerializedType() => typeof(bool);
    }
}

'''
'''--- Assets/FishNet/Example/All/CustomSyncType/Component State Sync/ComponentSyncStateBehaviour.cs ---
﻿using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine;

namespace FishNet.Example.ComponentStateSync
{

    public class ComponentSyncStateBehaviour : NetworkBehaviour
    {
        /// <summary>  
        /// Using my custom SyncType for Structy.
        /// </summary>
        [SyncObject]
        private readonly ComponentStateSync<AMonoScript> _syncScript = new ComponentStateSync<AMonoScript>();

        private void Awake()
        {
            AMonoScript ams = GetComponent<AMonoScript>();
            //Initialize with the component of your choice.
            _syncScript.Initialize(ams);
            //Optionally listen for changes.
            _syncScript.OnChange += _syncScript_OnChange;
        }

        /// <summary>
        /// Called when enabled state changes for SyncScript.
        /// </summary>
        private void _syncScript_OnChange(AMonoScript component, bool prevState, bool nextState, bool asServer)
        {
            Debug.Log($"Change received on {component.GetType().Name}. New value is {nextState}. Received asServer {asServer}.");
        }

        private void Update()
        {
            //Every so often flip the state of the component.
            if (base.IsServer && Time.frameCount % 200 == 0)
                _syncScript.Enabled = !_syncScript.Enabled;
        }

    }

}
'''
'''--- Assets/FishNet/Example/All/CustomSyncType/Custom Struct Sync/StructSyncBehaviour.cs ---
﻿using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine;

namespace FishNet.Example.CustomSyncObject
{

    public class StructSyncBehaviour : NetworkBehaviour
    {
        /// <summary>
        /// Using my custom SyncType for Structy.
        /// </summary>
        [SyncObject]
        private readonly StructySync _structy = new StructySync();

        private void Awake()
        {
            //Listen for change events.
            _structy.OnChange += _structy_OnChange;
        }

        private void _structy_OnChange(StructySync.CustomOperation op, Structy oldItem, Structy newItem, bool asServer)
        {
            Debug.Log("Changed " + op.ToString() + ", " + newItem.Age + ", " + asServer);
        }

        private void Update()
        {
            //Every so often increase the age property on structy using StructySync, my custom sync type.
            if (base.IsServer && Time.frameCount % 200 == 0)
            {
                /* Custom code inside StructySync to return
                 * current value. You can expose this, or don't, however
                 * you like. */
                Structy s = _structy.GetValue(true);
                //Increase age.
                _structy.SetAge((ushort)(s.Age + 1));
            }
        }

    }

}
'''
'''--- Assets/FishNet/Example/All/CustomSyncType/Custom Struct Sync/StructySync.cs ---
﻿using FishNet.Managing.Logging;
using FishNet.Object.Synchronizing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Example.CustomSyncObject
{
    /// <summary>
    /// This is the data type I want to create a custom SyncType for.
    /// </summary>
    public struct Structy
    {
        public string Name;
        public ushort Age;

        public Structy(string name, ushort age)
        {
            Name = name;
            Age = age;
        }
    }

    /// <summary>
    /// It's very important to exclude this from codegen.
    /// However, whichever value you are synchronizing must not be excluded. This is why the value is outside the StructySync class.
    /// </summary>
    public class StructySync : SyncBase, ICustomSync
    {
        #region Types.
        /// <summary>
        /// Information about how the struct has changed.
        /// You could send the entire struct on every change
        /// but this is an example of how you might send individual changed
        /// fields.
        /// </summary>
        private struct ChangeData
        {
            internal CustomOperation Operation;
            internal Structy Data;

            public ChangeData(CustomOperation operation, Structy data)
            {
                Operation = operation;
                Data = data;
            }
        }
        /// <summary>
        /// Types of changes. This is related to ChangedData
        /// where you can specify what has changed.
        /// </summary>
        public enum CustomOperation : byte
        {
            Full = 0,
            Name = 1,
            Age = 2
        }
        #endregion

        #region Public.
        /// <summary>
        /// Delegate signature for when Structy changes.
        /// </summary>
        /// <param name="op"></param>
        /// <param name="oldItem"></param>
        /// <param name="newItem"></param>
        public delegate void CustomChanged(CustomOperation op, Structy oldItem, Structy newItem, bool asServer);
        /// <summary>
        /// Called when the Structy changes.
        /// </summary>
        public event CustomChanged OnChange;
        #endregion

        #region Private.
        /// <summary>
        /// Initial value when initialized.
        /// </summary>
        private Structy _initialValue;
        /// <summary>
        /// Value this SyncType is for, which is Structy.
        /// </summary>
        private Structy _value = new Structy();
        /// <summary>
        /// Copy of value on client portion when acting as a host.
        /// This is not mandatory but this setup separates server values
        /// from client, creating a more reliable test environment when running as host.
        /// </summary>
        private Structy _clientValue = new Structy();
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private readonly List<ChangeData> _changed = new List<ChangeData>();
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        #endregion

        protected override void Registered()
        {
            base.Registered();
            _initialValue = _value;
        }

        /// <summary>
        /// Adds an operation and invokes locally.
        /// </summary>
        /// <param name="operation"></param>
        /// <param name="index"></param>
        /// <param name="prev"></param>
        /// <param name="next"></param>
        private void AddOperation(CustomOperation operation, Structy prev, Structy next)
        {
            if (!base.IsRegistered)
                return;

            if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot complete operation as server when server is not active.");
                return;
            }

            /* Set as changed even if cannot dirty.
            * Dirty is only set when there are observers,
            * but even if there are not observers
            * values must be marked as changed so when
            * there are observers, new values are sent. */
            _valuesChanged = true;
            base.Dirty();

            //Data can currently only be set from server, so this is always asServer.
            bool asServer = true;
            //Add to changed.
            ChangeData cd = new ChangeData(operation, next);
            _changed.Add(cd);
            OnChange?.Invoke(operation, prev, next, asServer);
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        public override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.WriteUInt32((uint)_changed.Count);

            for (int i = 0; i < _changed.Count; i++)
            {
                ChangeData change = _changed[i];
                writer.WriteByte((byte)change.Operation);

                //Clear does not need to write anymore data so it is not included in checks.
                if (change.Operation == CustomOperation.Age)
                {
                    writer.WriteUInt16(change.Data.Age);
                }
                else if (change.Operation == CustomOperation.Name)
                {
                    writer.WriteString(change.Data.Name);
                }
            }

            _changed.Clear();
        }

        /// <summary>
        /// Writes all values if not initial values.
        /// </summary>
        /// <param name="writer"></param>
        public override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //Write one change.
            writer.WriteInt32(1);
            //Write if changed is from the server, so always use the server _value.           
            writer.WriteByte((byte)CustomOperation.Full);
            //Write value.
            writer.Write(_value);
        }

        /// <summary>
        /// Sets current values.
        /// </summary>
        /// <param name="reader"></param>
        public override void Read(PooledReader reader)
        {
            //Read is always on client side.
            bool asServer = false;
            /* When !asServer don't make changes if server is running.
            * This is because changes would have already been made on
            * the server side and doing so again would result in duplicates
            * and potentially overwrite data not yet sent. */
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServer);

            int changes = (int)reader.ReadUInt32();
            for (int i = 0; i < changes; i++)
            {
                CustomOperation operation = (CustomOperation)reader.ReadByte();
                Structy prev = GetValue(asServer);
                Structy next = default(Structy);

                //Full.
                if (operation == CustomOperation.Full)
                {
                    next = reader.Read<Structy>();
                }
                //Name.
                else if (operation == CustomOperation.Name)
                {
                    next = prev;
                    next.Name = reader.ReadString();
                }
                //Age
                else if (operation == CustomOperation.Age)
                {
                    next = prev;
                    next.Age = reader.ReadUInt16();
                }

                OnChange?.Invoke(operation, prev, next, asServer);
            }

        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        public override void Reset()
        {
            base.Reset();
            _changed.Clear();
            _value = _initialValue;
            _clientValue = _initialValue;
            _valuesChanged = false;
        }

        /// <summary>
        /// Sets name value.
        /// </summary>
        public void SetName(string name)
        {
            SetName(name, true, true);
        }
        private void SetName(string name, bool asServer, bool force)
        {
            Structy data = GetValue(asServer);
            bool sameValue = (!force && (name == data.Name));
            if (!sameValue)
            {
                Structy prev = data;

                Structy next = data;
                next.Name = name;
                SetValue(asServer, next);

                if (asServer)
                {
                    if (base.NetworkManager == null)
                        _clientValue = next;
                    AddOperation(CustomOperation.Name, prev, next);
                }
            }
        }

        /// <summary>
        /// Sets age value.
        /// </summary>
        public void SetAge(ushort age)
        {
            SetAge(age, true, true);
        }
        private void SetAge(ushort age, bool asServer, bool force)
        {
            Structy data = GetValue(asServer);
            bool sameValue = (!force && (age == data.Age));
            if (!sameValue)
            {
                Structy prev = data;

                Structy next = data;
                next.Age = age;
                SetValue(asServer, next);

                if (asServer)
                {
                    if (base.NetworkManager == null)
                        _clientValue = next;
                    AddOperation(CustomOperation.Age, prev, next);
                }
            }
        }

        /// <summary>
        /// Gets value depending if being called asServer or not.
        /// </summary>
        /// <param name="asServer"></param>
        /// <returns></returns>
        public Structy GetValue(bool asServer)
        {
            return (asServer) ? _value : _clientValue;
        }

        /// <summary>
        /// Sets value depending if being called asServer or not.
        /// </summary>
        /// <param name="asServer"></param>
        /// <returns></returns>
        private void SetValue(bool asServer, Structy data)
        {
            if (asServer)
                _value = data;
            else
                _clientValue = data;
        }

        /// <summary>
        /// Return the serialized type.
        /// </summary>
        /// <returns></returns>
        public object GetSerializedType() => typeof(Structy);
    }
}

'''
'''--- Assets/FishNet/Example/All/Prediction/CharacterController/Scripts/CharacterControllerPrediction.cs ---
﻿using FishNet;
using FishNet.Object;
using FishNet.Object.Prediction;
using UnityEngine;

/*
* 
* See TransformPrediction.cs for more detailed notes.
* 
*/

namespace FishNet.Example.Prediction.CharacterControllers
{

    public class CharacterControllerPrediction : NetworkBehaviour
    {
        #region Types.
        public struct MoveData
        {
            public float Horizontal;
            public float Vertical;
        }
        public struct ReconcileData
        {
            public Vector3 Position;
            public Quaternion Rotation;
            public ReconcileData(Vector3 position, Quaternion rotation)
            {
                Position = position;
                Rotation = rotation;
            }
        }
        #endregion

        #region Serialized.
        [SerializeField]
        private float _moveRate = 5f;
        #endregion

        #region Private.
        private CharacterController _characterController;
        #endregion

        private void Awake()
        {
            InstanceFinder.TimeManager.OnTick += TimeManager_OnTick;
            _characterController = GetComponent<CharacterController>();
        }

        public override void OnStartClient()
        {
            base.OnStartClient();            
            _characterController.enabled = (base.IsServer || base.IsOwner);
        }

        private void OnDestroy()
        {
            if (InstanceFinder.TimeManager != null)
            {
                InstanceFinder.TimeManager.OnTick -= TimeManager_OnTick;
            }
        }

        private void TimeManager_OnTick()
        {
            if (base.IsOwner)
            {
                Reconciliation(default, false);
                CheckInput(out MoveData md);
                Move(md, false);
            }
            if (base.IsServer)
            {
                Move(default, true);
                ReconcileData rd = new ReconcileData(transform.position, transform.rotation);
                Reconciliation(rd, true);
            }
        }

        private void CheckInput(out MoveData md)
        {
            md = default;

            float horizontal = Input.GetAxisRaw("Horizontal");
            float vertical = Input.GetAxisRaw("Vertical");

            if (horizontal == 0f && vertical == 0f)
                return;

            md = new MoveData()
            {
                Horizontal = horizontal,
                Vertical = vertical
            };
        }

        [Replicate]
        private void Move(MoveData md, bool asServer, bool replaying = false)
        {
            Vector3 move = new Vector3(md.Horizontal, 0f, md.Vertical).normalized + new Vector3(0f, Physics.gravity.y, 0f);
            _characterController.Move(move * _moveRate * (float)base.TimeManager.TickDelta);
        }

        [Reconcile]
        private void Reconciliation(ReconcileData rd, bool asServer)
        {
            transform.position = rd.Position;
            transform.rotation = rd.Rotation;
        }

    }

}
'''
'''--- Assets/FishNet/Example/All/Prediction/Rigidbody/Scripts/RigidbodyPrediction.cs ---
﻿using FishNet;
using FishNet.Object;
using FishNet.Object.Prediction;
using UnityEngine;

/*
* 
* See TransformPrediction.cs for more detailed notes.
* 
*/

namespace FishNet.Example.Prediction.Rigidbodies
{

    public class RigidbodyPrediction : NetworkBehaviour
    {
        #region Types.
        public struct MoveData
        {
            public bool Jump;
            public float Horizontal;
            public float Vertical;
            public MoveData(bool jump, float horizontal, float vertical)
            {
                Jump = jump;
                Horizontal = horizontal;
                Vertical = vertical;
            }
        }
        public struct ReconcileData
        {
            public Vector3 Position;
            public Quaternion Rotation;
            public Vector3 Velocity;
            public Vector3 AngularVelocity;
            public ReconcileData(Vector3 position, Quaternion rotation, Vector3 velocity, Vector3 angularVelocity)
            {
                Position = position;
                Rotation = rotation;
                Velocity = velocity;
                AngularVelocity = angularVelocity;
            }
        }
        #endregion

        #region Serialized.
        [SerializeField]
        private float _jumpForce = 15f;
        [SerializeField]
        private float _moveRate = 15f;
        #endregion

        #region Private.
        /// <summary>
        /// Rigidbody on this object.
        /// </summary>
        private Rigidbody _rigidbody;
        /// <summary>
        /// Next time a jump is allowed.
        /// </summary>
        private float _nextJumpTime;
        /// <summary>
        /// True to jump next frame.
        /// </summary>
        private bool _jump;
        #endregion

        private void Awake()
        {

            _rigidbody = GetComponent<Rigidbody>();
            InstanceFinder.TimeManager.OnTick += TimeManager_OnTick;
            InstanceFinder.TimeManager.OnPostTick += TimeManager_OnPostTick;
        }

        private void OnDestroy()
        {
            if (InstanceFinder.TimeManager != null)
            {
                InstanceFinder.TimeManager.OnTick -= TimeManager_OnTick;
                InstanceFinder.TimeManager.OnPostTick -= TimeManager_OnPostTick;
            }
        }

        private void Update()
        {
            if (base.IsOwner)
            {
                if (Input.GetKeyDown(KeyCode.Space) && Time.time > _nextJumpTime)
                {
                    _nextJumpTime = Time.time + 1f;
                    _jump = true;
                }
            }
        }

        private void TimeManager_OnTick()
        {
            if (base.IsOwner)
            {
                Reconciliation(default, false);
                CheckInput(out MoveData md);
                Move(md, false);
            }
            if (base.IsServer)
            {
                Move(default, true);
            }
        }

        private void TimeManager_OnPostTick()
        {
            if (base.IsServer)
            {
                ReconcileData rd = new ReconcileData(transform.position, transform.rotation, _rigidbody.velocity, _rigidbody.angularVelocity);
                Reconciliation(rd, true);
            }
        }

        private void CheckInput(out MoveData md)
        {
            md = default;

            float horizontal = Input.GetAxisRaw("Horizontal");
            float vertical = Input.GetAxisRaw("Vertical");

            if (horizontal == 0f && vertical == 0f && !_jump)
                return;

            md = new MoveData(_jump, horizontal, vertical);
            _jump = false;
        }

        [Replicate]
        private void Move(MoveData md, bool asServer, bool replaying = false)
        {
            //Add extra gravity for faster falls.
            Vector3 forces = new Vector3(md.Horizontal, Physics.gravity.y, md.Vertical) * _moveRate;
            _rigidbody.AddForce(forces);

            if (md.Jump)
                _rigidbody.AddForce(new Vector3(0f, _jumpForce, 0f), ForceMode.Impulse);
        }

        [Reconcile]
        private void Reconciliation(ReconcileData rd, bool asServer)
        {
            transform.position = rd.Position;
            transform.rotation = rd.Rotation;
            _rigidbody.velocity = rd.Velocity;
            _rigidbody.angularVelocity = rd.AngularVelocity;
        }

    }

}
'''
'''--- Assets/FishNet/Example/All/Prediction/Transform/Scripts/TransformPrediction.cs ---
﻿using FishNet;
using FishNet.Object;
using FishNet.Object.Prediction;
using UnityEngine;

namespace FishNet.Example.Prediction.Transforms
{
    public class TransformPrediction : NetworkBehaviour
    {
        /// <summary>
        /// Data on how to move.
        /// This is processed locally as well sent to the server for processing.
        /// Any inputs or values which may affect your move should be placed in your own MoveData.
        /// The structure type may be named anything. Classes can also be used but will generate garbage, so structures
        /// are recommended.
        /// </summary>
        public struct MoveData
        {
            public float Horizontal;
            public float Vertical;

            public MoveData(float horizontal, float vertical)
            {
                Horizontal = horizontal;
                Vertical = vertical;
            }
        }

        /// <summary>
        /// Data on how to reconcile.
        /// Server sends this back to the client. Once the client receives this they
        /// will reset their object using this information. Like with MoveData anything that may
        /// affect your movement should be reset. Since this is just a transform only position and
        /// rotation would be reset. But a rigidbody would include velocities as well. If you are using
        /// an asset it's important to know what systems in that asset affect movement and need
        /// to be reset as well.
        /// </summary>
        public struct ReconcileData
        {
            public Vector3 Position;
            public Quaternion Rotation;
            public ReconcileData(Vector3 position, Quaternion rotation)
            {
                Position = position;
                Rotation = rotation;
            }
        }

        #region Serialized.
        /// <summary>
        /// How many units to move per second.
        /// </summary>
        [Tooltip("How many units to move per second.")]
        [SerializeField]
        private float _moveRate = 5f;
        #endregion

        private void Awake()
        {
            /* Prediction is tick based so you must
             * send datas during ticks. You can use whichever
             * tick best fits your need, such as PreTick, Tick, or PostTick.
             * In most cases you will send/move using Tick. For rigidbodies
             * you will send using PostTick. I subscribe to ticks using
             * the InstanceFinder class, which finds the first NetworkManager
             * loaded. If you are using several NetworkManagers you would want
             * to subscrube in OnStartServer/Client using base.TimeManager. */
            InstanceFinder.TimeManager.OnTick += TimeManager_OnTick;
        }

        private void OnDestroy()
        {
            //Unsubscribe as well.
            if (InstanceFinder.TimeManager != null)
            {
                InstanceFinder.TimeManager.OnTick -= TimeManager_OnTick;
            }
        }

        private void TimeManager_OnTick()
        {
            if (base.IsOwner)
            {
                /* Call reconcile using default, and false for
                 * asServer. This will reset the client to the latest
                 * values from server and replay cached inputs. */
                Reconciliation(default, false);
                /* CheckInput builds MoveData from user input. When there
                 * is no input CheckInput returns default. You can handle this
                 * however you like but Move should be called when default if
                 * there is no input which needs to be sent to the server. */
                CheckInput(out MoveData md);
                /* Move using the input, and false for asServer.
                 * Inputs are automatically sent with redundancy. How many past
                 * inputs will be configurable at a later time.
                 * When a default value is used the most recent past inputs
                 * are sent a predetermined amount of times. It's important you
                 * call Move whether your data is default or not. FishNet will
                 * automatically determine how to send the data, and run the logic. */
                Move(md, false);
            }
            if (base.IsServer)
            {
                /* Move using default data with true for asServer.
                 * The server will use stored data from the client automatically.
                 * You may also run any sanity checks on the input as demonstrated
                 * in the method. */
                Move(default, true);
                /* After the server has processed input you will want to send
                 * the result back to clients. You are welcome to skip
                 * a few sends if you like, eg only send every few ticks.
                 * Generate data required on how the client will reset and send it by calling your Reconcile
                 * method with the data, again using true for asServer. Like the
                 * Replicate method (Move) this will send with redundancy a certain
                 * amount of times. If there is no input to process from the client this
                 * will not continue to send data. */
                ReconcileData rd = new ReconcileData(transform.position, transform.rotation);
                Reconciliation(rd, true);
            }
        }

        /// <summary>
        /// A simple method to get input. This doesn't have any relation to the prediction.
        /// </summary>
        private void CheckInput(out MoveData md)
        {
            md = default;

            float horizontal = Input.GetAxisRaw("Horizontal");
            float vertical = Input.GetAxisRaw("Vertical");

            //No input to send.
            if (horizontal == 0f && vertical == 0f)
                return;

            //Make movedata with input.
            md = new MoveData()
            {
                Horizontal = horizontal,
                Vertical = vertical
            };
        }

        /// <summary>
        /// Replicate attribute indicates the data is being sent from the client to the server.
        /// When Replicate is present data is automatically sent with redundancy.
        /// The replay parameter becomes true automatically when client inputs are
        /// being replayed after a reconcile. This is useful for a variety of things,
        /// such as if you only want to show effects the first time input is run you will
        /// do so when replaying is false.
        /// </summary>
        [Replicate]
        private void Move(MoveData md, bool asServer, bool replaying = false)
        {
            /* You can check if being run as server to
             * add security checks such as normalizing
             * the inputs. */
            if (asServer)
            {
                //Sanity check!
            }
            /* You may also use replaying to know
             * if a client is replaying inputs rather
             * than running them for the first time. This can
             * be useful because you may only want to run
             * VFX during the first input and not during
             * replayed inputs. */
            if (!replaying)
            {
                //VFX!
            }

            Vector3 move = new Vector3(md.Horizontal, 0f, md.Vertical);
            transform.position += (move * _moveRate * (float)base.TimeManager.TickDelta);
        }

        /// <summary>
        /// A Reconcile attribute indicates the client will reconcile
        /// using the data and logic within the method. When asServer
        /// is true the data is sent to the client with redundancy,
        /// and the server will not run the logic.
        /// When asServer is false the client will reset using the logic
        /// you supply then replay their inputs.
        /// </summary>
        [Reconcile]
        private void Reconciliation(ReconcileData rd, bool asServer)
        {
            transform.position = rd.Position;
            transform.rotation = rd.Rotation;
        }

    }

}
'''
'''--- Assets/FishNet/Example/All/SceneManager/Scripts/PlayerController.cs ---
﻿using FishNet.Connection;
using FishNet.Object;
using UnityEngine;

namespace FishNet.Example.Scened
{

    public class PlayerController : NetworkBehaviour
    {
        [SerializeField]
        private GameObject _camera;
        [SerializeField]
        private float _moveRate = 4f;
        [SerializeField]
        private bool _clientAuth = true;

        public override void OnStartClient()
        {
            base.OnStartClient();
            if (base.IsOwner)
                _camera.SetActive(true);
        }

        private void Update()
        {
            if (!base.IsOwner)
                return;

            float hor = Input.GetAxisRaw("Horizontal");
            float ver = Input.GetAxisRaw("Vertical");

            /* If ground cannot be found for 20 units then bump up 3 units. 
             * This is just to keep player on ground if they fall through
             * when changing scenes.             */
            if (_clientAuth || (!_clientAuth && base.IsServer))
            {
                if (!Physics.Linecast(transform.position + new Vector3(0f, 0.3f, 0f), transform.position - (Vector3.one * 20f)))
                    transform.position += new Vector3(0f, 3f, 0f);
            }

            if (_clientAuth)
                Move(hor, ver);
            else
                ServerMove(hor, ver);
        }

        [ServerRpc]
        private void ServerMove(float hor, float ver)
        {
            Move(hor, ver);
        }

        private void Move(float hor, float ver)
        {
            float gravity = -10f * Time.deltaTime;
            //If ray hits floor then cancel gravity.
            Ray ray = new Ray(transform.position + new Vector3(0f, 0.05f, 0f), -Vector3.up);
            if (Physics.Raycast(ray, 0.1f + -gravity))
                gravity = 0f;

            /* Moving. */
            Vector3 direction = new Vector3(
                0f,
                gravity,
                ver * _moveRate * Time.deltaTime);

            transform.position += transform.TransformDirection(direction);
            transform.Rotate(new Vector3(0f, hor * 100f * Time.deltaTime, 0f));
        }

    }

}
'''
'''--- Assets/FishNet/Example/All/SceneManager/Scripts/SceneLoaderExample.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Scened;
using FishNet.Object;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Example.Scened
{

    /// <summary>
    /// Loads a single scene, additive scenes, or both when a client
    /// enters or exits this trigger.
    /// </summary>
    public class SceneLoaderExample : MonoBehaviour
    {
        /// <summary>
        /// True to move the triggering object.
        /// </summary>
        [Tooltip("True to move the triggering object.")]
        [SerializeField]
        private bool _moveObject = true;
        /// <summary>
        /// True to move all connection objects (clients).
        /// </summary>
        [Tooltip("True to move all connection objects (clients).")]
        [SerializeField]
        private bool _moveAllObjects;
        /// <summary>
        /// True to replace current scenes with new scenes. First scene loaded will become active scene.
        /// </summary>
        [Tooltip("True to replace current scenes with new scenes. First scene loaded will become active scene.")]
        [SerializeField]
        private bool _replaceScenes;
        /// <summary>
        /// Scenes to load.
        /// </summary>
        [Tooltip("Scenes to load.")]
        [SerializeField]
        private string[] _scenes = new string[0];
        /// <summary>
        /// True to only unload for the connectioning causing the trigger.
        /// </summary>
        [Tooltip("True to only unload for the connectioning causing the trigger.")]
        [SerializeField]
        private bool _connectionOnly;
        /// <summary>
        /// True to automatically unload the loaded scenes when no more connections are using them.
        /// </summary>
        [Tooltip("True to automatically unload the loaded scenes when no more connections are using them.")]
        [SerializeField]
        private bool _automaticallyUnload = true;
        /// <summary>
        /// True to fire when entering the trigger. False to fire when exiting the trigger.
        /// </summary>
        [Tooltip("True to fire when entering the trigger. False to fire when exiting the trigger.")]
        [SerializeField]
        private bool _onTriggerEnter = true;

        /// <summary>
        /// Used to prevent excessive triggering when two clients are loaded and server is separate.
        /// Client may enter trigger intentionally then when moved to a new scene will re-enter trigger
        /// since original scene will still be loaded on server due to another client being in it.
        /// This scenario is extremely unlikely in production but keep it in mind.
        /// </summary>
        private Dictionary<NetworkConnection, float> _triggeredTimes = new Dictionary<NetworkConnection, float>();

        [Server(Logging = LoggingType.Off)]
        private void OnTriggerEnter(Collider other)
        {
            if (!_onTriggerEnter)
                return;

            LoadScene(other.GetComponent<NetworkObject>());
        }

        [Server(Logging = LoggingType.Off)]
        private void OnTriggerExit(Collider other)
        {
            if (_onTriggerEnter)
                return;

            LoadScene(other.GetComponent<NetworkObject>());
        }

        private void LoadScene(NetworkObject triggeringIdentity)
        {
            if (!InstanceFinder.NetworkManager.IsServer)
                return;

            //NetworkObject isn't necessarily needed but to ensure its the player only run if found.
            if (triggeringIdentity == null)
                return;

            /* Dont let trigger hit twice by same connection too frequently
             * See _triggeredTimes field for more info. */
            if (_triggeredTimes.TryGetValue(triggeringIdentity.Owner, out float time))
            {
                if (Time.time - time < 0.5f)
                    return;
            }
            _triggeredTimes[triggeringIdentity.Owner] = Time.time;

            //Which objects to move.
            List<NetworkObject> movedObjects = new List<NetworkObject>();
            if (_moveAllObjects)
            {
                foreach (NetworkConnection item in InstanceFinder.ServerManager.Clients.Values)
                {
                    foreach (NetworkObject nob in item.Objects)
                        movedObjects.Add(nob);
                }
            }
            else if (_moveObject)
            {
                movedObjects.Add(triggeringIdentity);
            }
            //Load options.
            LoadOptions loadOptions = new LoadOptions
            {
                AutomaticallyUnload = _automaticallyUnload,
            };

            //Make scene data.
            SceneLoadData sld = new SceneLoadData(_scenes);
            sld.ReplaceScenes = (_replaceScenes) ? ReplaceOption.All : ReplaceOption.None;
            sld.Options = loadOptions;
            sld.MovedNetworkObjects = movedObjects.ToArray();

            //Load for connection only.
            if (_connectionOnly)
                InstanceFinder.SceneManager.LoadConnectionScenes(triggeringIdentity.Owner, sld);
            //Load for all clients.
            else
                InstanceFinder.SceneManager.LoadGlobalScenes(sld);

        }

    }

}
'''
'''--- Assets/FishNet/Example/All/SceneManager/Scripts/SceneUnloaderExample.cs ---
﻿using FishNet.Managing.Logging;
using FishNet.Managing.Scened;
using FishNet.Object;
using UnityEngine;

namespace FishNet.Example.Scened
{

    /// <summary>
    /// Unloads specified scenes when entering or exiting this trigger.
    /// </summary>
    public class SceneUnloaderExample : MonoBehaviour
    {
        /// <summary>
        /// Scenes to unload.
        /// </summary>
        [Tooltip("Scenes to unload.")]
        [SerializeField]
        private string[] _scenes = new string[0];
        /// <summary>
        /// True to only unload for the connectioning causing the trigger.
        /// </summary>
        [Tooltip("True to only unload for the connectioning causing the trigger.")]
        [SerializeField]
        private bool _connectionOnly;
        /// <summary>
        /// True to unload unused scenes.
        /// </summary>
        [Tooltip("True to unload unused scenes.")]
        [SerializeField]
        private bool _unloadUnused = true;
        /// <summary>
        /// True to fire when entering the trigger. False to fire when exiting the trigger.
        /// </summary>
        [Tooltip("True to fire when entering the trigger. False to fire when exiting the trigger.")]
        [SerializeField]
        private bool _onTriggerEnter = true;

        [Server(Logging = LoggingType.Off)]
        private void OnTriggerEnter(Collider other)
        {
            if (!_onTriggerEnter)
                return;

            UnloadScenes(other.gameObject.GetComponent<NetworkObject>());
        }

        [Server(Logging = LoggingType.Off)]
        private void OnTriggerExit(Collider other)
        {
            if (_onTriggerEnter)
                return;

            UnloadScenes(other.gameObject.GetComponent<NetworkObject>());
        }

        /// <summary>
        /// Unload scenes.
        /// </summary>
        /// <param name="triggeringIdentity"></param>
        private void UnloadScenes(NetworkObject triggeringIdentity)
        {
            if (!InstanceFinder.NetworkManager.IsServer)
                return;

            //NetworkObject isn't necessarily needed but to ensure its the player only run if nob is found.
            if (triggeringIdentity == null)
                return;

            UnloadOptions unloadOptions = new UnloadOptions()
            {
                Mode = (_unloadUnused) ? UnloadOptions.ServerUnloadMode.UnloadUnused : UnloadOptions.ServerUnloadMode.KeepUnused
            };

            SceneUnloadData sud = new SceneUnloadData(_scenes);
            sud.Options = unloadOptions;

            //Unload only for the triggering connection.
            if (_connectionOnly)
                InstanceFinder.SceneManager.UnloadConnectionScenes(triggeringIdentity.Owner, sud);
            //Unload for all players.
            else
                InstanceFinder.SceneManager.UnloadGlobalScenes(sud);
        }

    }

}
'''
'''--- Assets/FishNet/Example/Scripts/NetworkHudCanvases.cs ---
﻿using FishNet.Managing;
using FishNet.Transporting;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class NetworkHudCanvases : MonoBehaviour
{
    #region Types.
    /// <summary>
    /// Ways the HUD will automatically start a connection.
    /// </summary>
    private enum AutoStartType
    {
        Disabled,
        Host,
        Server,
        Client
    }
    #endregion

    #region Serialized.
    /// <summary>
    /// What connections to automatically start on play.
    /// </summary>
    [Tooltip("What connections to automatically start on play.")]
    [SerializeField]
    private AutoStartType _autoStartType = AutoStartType.Disabled;
    /// <summary>
    /// Color when socket is stopped.
    /// </summary>
    [Tooltip("Color when socket is stopped.")]
    [SerializeField]
    private Color _stoppedColor;
    /// <summary>
    /// Color when socket is changing.
    /// </summary>
    [Tooltip("Color when socket is changing.")]
    [SerializeField]
    private Color _changingColor;
    /// <summary>
    /// Color when socket is started.
    /// </summary>
    [Tooltip("Color when socket is started.")]
    [SerializeField]
    private Color _startedColor;
    [Header("Indicators")]
    /// <summary>
    /// Indicator for server state.
    /// </summary>
    [Tooltip("Indicator for server state.")]
    [SerializeField]
    private Image _serverIndicator;
    /// <summary>
    /// Indicator for client state.
    /// </summary>
    [Tooltip("Indicator for client state.")]
    [SerializeField]
    private Image _clientIndicator;
    #endregion

    #region Private.
    /// <summary>
    /// Found NetworkManager.
    /// </summary>
    private NetworkManager _networkManager;
    /// <summary>
    /// Current state of client socket.
    /// </summary>
    private LocalConnectionState _clientState = LocalConnectionState.Stopped;
    /// <summary>
    /// Current state of server socket.
    /// </summary>
    private LocalConnectionState _serverState = LocalConnectionState.Stopped;
#if !ENABLE_INPUT_SYSTEM
    /// <summary>
    /// EventSystem for the project.
    /// </summary>
    private EventSystem _eventSystem;
#endif
    #endregion

    void OnGUI()
    {
#if ENABLE_INPUT_SYSTEM        
        string GetNextStateText(LocalConnectionState state)
        {
            if (state == LocalConnectionState.Stopped)
                return "Start";
            else if (state == LocalConnectionState.Starting)
                return "Starting";
            else if (state == LocalConnectionState.Stopping)
                return "Stopping";
            else if (state == LocalConnectionState.Started)
                return "Stop";
            else
                return "Invalid";
        }

        GUILayout.BeginArea(new Rect(16, 16, 256, 9000));
        Vector2 defaultResolution = new Vector2(1920f, 1080f);
        GUI.matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(Screen.width / defaultResolution.x, Screen.height / defaultResolution.y, 1));

        GUIStyle style = GUI.skin.GetStyle("button");
        int originalFontSize = style.fontSize;

        Vector2 buttonSize = new Vector2(256f, 64f);
        style.fontSize = 28;
        //Server button.
        if (Application.platform != RuntimePlatform.WebGLPlayer)
        {
            if (GUILayout.Button($"{GetNextStateText(_serverState)} Server", GUILayout.Width(buttonSize.x), GUILayout.Height(buttonSize.y)))
                OnClick_Server();
            GUILayout.Space(10f);
        }

        //Client button.
        if (GUILayout.Button($"{GetNextStateText(_clientState)} Client", GUILayout.Width(buttonSize.x), GUILayout.Height(buttonSize.y)))
            OnClick_Client();

        style.fontSize = originalFontSize;

        GUILayout.EndArea();
#endif
    }

    private void Start()
    {
#if !ENABLE_INPUT_SYSTEM
        SetEventSystem();
        BaseInputModule inputModule = FindObjectOfType<BaseInputModule>();
        if (inputModule == null)
            gameObject.AddComponent<StandaloneInputModule>();
#else
        _serverIndicator.transform.parent.gameObject.SetActive(false);
        _clientIndicator.transform.parent.gameObject.SetActive(false);
#endif

        _networkManager = FindObjectOfType<NetworkManager>();
        if (_networkManager == null)
        {
            Debug.LogError("NetworkManager not found, HUD will not function.");
            return;
        }
        else
        {
            UpdateColor(LocalConnectionState.Stopped, ref _serverIndicator);
            UpdateColor(LocalConnectionState.Stopped, ref _clientIndicator);
            _networkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
            _networkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;
        }

        if (_autoStartType == AutoStartType.Host || _autoStartType == AutoStartType.Server)
            OnClick_Server();
        if (!Application.isBatchMode && (_autoStartType == AutoStartType.Host || _autoStartType == AutoStartType.Client))
            OnClick_Client();
    }

    private void OnDestroy()
    {
        if (_networkManager == null)
            return;

        _networkManager.ServerManager.OnServerConnectionState -= ServerManager_OnServerConnectionState;
        _networkManager.ClientManager.OnClientConnectionState -= ClientManager_OnClientConnectionState;
    }

    /// <summary>
    /// Updates img color baased on state.
    /// </summary>
    /// <param name="state"></param>
    /// <param name="img"></param>
    private void UpdateColor(LocalConnectionState state, ref Image img)
    {
        Color c;
        if (state == LocalConnectionState.Started)
            c = _startedColor;
        else if (state == LocalConnectionState.Stopped)
            c = _stoppedColor;
        else
            c = _changingColor;

        img.color = c;
    }

    private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
    {
        _clientState = obj.ConnectionState;
        UpdateColor(obj.ConnectionState, ref _clientIndicator);
    }

    private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
    {
        _serverState = obj.ConnectionState;
        UpdateColor(obj.ConnectionState, ref _serverIndicator);
    }

    public void OnClick_Server()
    {
        if (_networkManager == null)
            return;

        if (_serverState != LocalConnectionState.Stopped)
            _networkManager.ServerManager.StopConnection(true);
        else
            _networkManager.ServerManager.StartConnection();

        DeselectButtons();
    }

    public void OnClick_Client()
    {
        if (_networkManager == null)
            return;

        if (_clientState != LocalConnectionState.Stopped)
            _networkManager.ClientManager.StopConnection();
        else
            _networkManager.ClientManager.StartConnection();

        DeselectButtons();
    }

    private void SetEventSystem()
    {
#if !ENABLE_INPUT_SYSTEM
        if (_eventSystem != null)
            return;
        _eventSystem = FindObjectOfType<EventSystem>();
        if (_eventSystem == null)
            _eventSystem = gameObject.AddComponent<EventSystem>();
#endif
    }

    private void DeselectButtons()
    {
#if !ENABLE_INPUT_SYSTEM
        SetEventSystem();
        _eventSystem?.SetSelectedGameObject(null);
#endif
    }
}
'''
'''--- Assets/FishNet/LICENSE.txt ---
0. Definitions.

"Fish-Net" means FishNet, FishNetworking, Fish-Networking, networking for Unity Engine.

"Repository Service" means the respository service through which Fish-Net is made available.

“Software” means the software (including code in source or object format as applicable) of Fish-Net that accompanies this License.

"FirstGearGames" means Benjamin Berwick of FirstGearGames LLC, registered 2018, North Carolina.

1. License Grant to the Software. FirstGearGames grants to you a worldwide, non-exclusive, no-charge, and royalty-free license to reproduce, modify, and use the Software for developed game, or other content with Software.

1.1 Exclusions. Other products of like Software (eg: networking solutions) may not use, reverse engineer, or implement Software in part or full. Exclusions do not apply to parts of Software which are governed by a third-party license, nor to content or works created specifically to be used with Software, such as tools, add-ons, games, or improvements for Software.

2. Trademarks. You are not granted any right or license under this License to use any trademarks, service marks, trade names, products names, or branding of FirstGearGames or its affiliates (“Trademarks”).

3. Notice & Third-Party Terms. This License, including notices of copyright associated with the Software, must be provided in all substantial portions of the Software (or, if that is impracticable, in any other location where such notices are customarily placed). If the Software is accompanied by a “third-party notices” or similar file, you acknowledge and agree that software identified in that file is governed exclusively by those separate license terms.

4. DISCLAIMER, LIMITATION OF LIABILITY. THE SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, AND IS PROVIDED WITHOUT WARRANTY OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND/OR NONINFRINGEMENT. IN NO EVENT SHALL ANY COPYRIGHT HOLDER OR AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES (WHETHER DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL, INCLUDING PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, LOSS OF USE, DATA, OR PROFITS, AND BUSINESS INTERRUPTION), OR OTHER LIABILITY WHATSOEVER, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM OR OUT OF, OR IN CONNECTION WITH, THE SOFTWARE OR THE USE OF OR OTHER DEALINGS IN IT, EVEN WHERE ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

5. USE IS ACCEPTANCE and License Versions. Your access to and use of the Software, and/or any other indications of acceptance where required, constitutes your acceptance of this License and its terms and conditions. This License may be modified or updated; upon any such modification or update, you will comply with the terms of the updated License for any use of any of the Software under the updated License.

6. Use in Compliance with Law and Termination.

6.1 Compliance. Your exercise of the license granted herein will at all times be in compliance with applicable law and will not infringe any proprietary rights (including intellectual property rights).

6.2 Termination. This License will terminate immediately (i) on any breach by you of this License; and (ii) if you commence any form of patent litigation, including a cross-claim or counterclaim, against anyone wherein you allege that the Software constitutes direct or secondary/indirect patent infringement.

7. Severability. If any provision of this License is held to be unenforceable or invalid, that provision will be enforced to the maximum extent possible and the other provisions will remain in full force and effect.

8. Governing Law and Venue. This License is governed by and construed in accordance with the laws of North Carolina, United States. You and FirstGearGames agree to submit to the personal and exclusive jurisdiction of and venue in the state and federal courts located in Onslow County, North Carolina concerning any dispute arising out of this License (“Dispute”).

9. You agree by submitting ideas, modifications, or changes (content) of any kind to Software within Repository Service does not grant you ownership to Software nor additional rights to Software.

9.1 By submitting to Repository Service you are granting FirstGearGames with a no-charge, and royalty-free license to reproduce, modify, and use submitted content.
'''
'''--- Assets/FishNet/Plugins/Addressables/AddressablesExtensions.cs ---
﻿//Remove on 2023/01/01
//using UnityEngine;
//using UnityEngine.ResourceManagement.AsyncOperations;
//using UnitySceneManager = UnityEngine.SceneManagement;

//namespace FishNet.Managing.Scened.Addressable
//{

//    public static class AddressablesExtensions
//    {
//        public static AsyncOperationHandle LoadAsync(string sceneName, UnityEngine.SceneManagement.LoadSceneMode loadSceneMode)
//        {
//            return default;
//            //return Addressables.LoadSceneAsync(sceneName, loadSceneMode);
//        }
//        public static AsyncOperationHandle UnloadAsync(string sceneName, UnityEngine.SceneManagement.LoadSceneMode loadSceneMode)
//        {
//            return default;
//            //return Addressables.UnloadSceneAsync() .UnloadSceneAsync(sceneName);
//        }

//    }

//}
'''
'''--- Assets/FishNet/Plugins/CodeAnalysis/LICENSE.txt ---
MIT License

Copyright (c) 2022 Abdelfattah-Radwan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
'''
'''--- Assets/FishNet/Plugins/CodeAnalysis/README.txt ---
Git URL:
https://github.com/Abdelfattah-Radwan/FishNet.CodeAnalysis
'''
'''--- Assets/FishNet/Runtime/Authenticating/Authenticator.cs ---
﻿using FishNet.Connection;
using FishNet.Managing;
using System;
using UnityEngine;

namespace FishNet.Authenticating
{
    /// <summary>
    /// When inherited from this can be used to create a custom authentication process before clients may communicate with the server.
    /// </summary>
    public abstract class Authenticator : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// True if this authenticator has been intiialzied.
        /// </summary>
        public bool Initialized { get; private set; }
        #endregion

        #region Protected.
        /// <summary>
        /// NetworkManager for this Authenticator.
        /// </summary>
        protected NetworkManager NetworkManager { get; private set; }
        #endregion

        /// <summary>
        /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed.
        /// Server listens for this event automatically.
        /// </summary>
        public abstract event Action<NetworkConnection, bool> OnAuthenticationResult;

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="networkManager"></param>
        public virtual void InitializeOnce(NetworkManager networkManager)
        {
            NetworkManager = networkManager;
            Initialized = true;
        }

        /// <summary>
        /// Called on the server immediately after a client connects. Can be used to send data to the client for authentication.
        /// </summary>
        /// <param name="connection">Connection which is not yet authenticated.</param>
        public virtual void OnRemoteConnection(NetworkConnection connection) { }
    }

}
'''
'''--- Assets/FishNet/Runtime/Broadcast/Helping/BroadcastHelper.cs ---
﻿using FishNet.Object.Helping;

namespace FishNet.Broadcast.Helping
{
    internal static class BroadcastHelper
    {
        /// <summary>
        /// Gets the key for a broadcast type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="broadcastType"></param>
        /// <returns></returns>
        public static ushort GetKey<T>()
        {
            return typeof(T).FullName.GetStableHash16();
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Broadcast/IBroadcast.cs ---
﻿
namespace FishNet.Broadcast
{
    /// <summary>
    /// Include this interface on types intended to be used with Broadcast.
    /// </summary>
    public interface IBroadcast { }
}
'''
'''--- Assets/FishNet/Runtime/Config.json ---
{"StripReleaseBuilds":true}
'''
'''--- Assets/FishNet/Runtime/Connection/Buffer.cs ---
﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Serializing;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Connection
{
    /// <summary>
    /// A byte buffer that automatically resizes.
    /// </summary>
    internal class ByteBuffer
    {
        /// <summary>
        /// How many more bytes may fit into the buffer.
        /// </summary>
        internal int Remaining => (Size - Length);
        /// <summary>
        /// Buffer data.
        /// </summary>
        internal byte[] Data { get; private set; }
        /// <summary>
        /// How many bytes currently into Data. This will include the reserve.
        /// </summary>
        internal int Length { get; private set; }
        /// <summary>
        /// Size of the buffer. Data.Length may exceed this value as it uses a pooled array.
        /// </summary>
        internal int Size { get; private set; }
        /// <summary>
        /// True if data has been written.
        /// </summary>
        internal bool HasData { get; private set; }
        /// <summary>
        /// Bytes to reserve when resetting.
        /// </summary>
        private int _reserve;

        internal ByteBuffer(int size, int reserve = 0)
        {
            Data = ByteArrayPool.Retrieve(size);
            Size = size;
            _reserve = reserve;
            Reset();
        }

        ~ByteBuffer()
        {
            if (Data != null)
                ByteArrayPool.Store(Data);
        }

        /// <summary>
        /// Resets instance without clearing Data.
        /// </summary>
        internal void Reset()
        {
            Length = _reserve;
            HasData = false;
        }

        /// <summary>
        /// Copies segments without error checking.
        /// </summary>
        /// <param name="segment"></param>
        internal void CopySegment(uint tick, ArraySegment<byte> segment)
        {
            /* If data has not been written to buffer yet
            * then write tick to the start. */
            if (!HasData)
            {
                int pos = 0;
                WriterExtensions.WriteUInt32(Data, tick, ref pos);
            }

            Buffer.BlockCopy(segment.Array, segment.Offset, Data, Length, segment.Count);
            Length += segment.Count;
            HasData = true;
        }
    }

    internal class PacketBundle
    {
        /// <summary>
        /// True if data has been written.
        /// </summary>
        internal bool HasData => _buffers[0].HasData;
        /// <summary>
        /// All buffers written. Collection is not cleared when reset but rather the index in which to write is.
        /// </summary>
        private List<ByteBuffer> _buffers = new List<ByteBuffer>();
        /// <summary>
        /// Buffer which is being written to.
        /// </summary>
        private int _bufferIndex;
        /// <summary>
        /// Maximum size packet the transport can handle.
        /// </summary>
        private int _maximumTransportUnit;
        /// <summary>
        /// Number of buffers written to. Will return 0 if nothing has been written.
        /// </summary>
        public int WrittenBuffers => (!HasData) ? 0 : (_bufferIndex + 1);
        /// <summary>
        /// Number of bytes to reserve at the beginning of each buffer.
        /// </summary>
        private int _reserve;
        /// <summary>
        /// NetworkManager this is for.
        /// </summary>
        private NetworkManager _networkManager;

        internal PacketBundle(NetworkManager manager, int mtu, int reserve = 0)
        {
            //Allow bytes for the tick.
            reserve += TransportManager.TICK_BYTES;

            _networkManager = manager;
            _maximumTransportUnit = mtu;
            _reserve = reserve;
            AddBuffer();

            Reset();
        }

        /// <summary>
        /// Adds a buffer using current settings.
        /// </summary>
        private ByteBuffer AddBuffer()
        {
            ByteBuffer ba = new ByteBuffer(_maximumTransportUnit, _reserve);
            _buffers.Add(ba);
            return ba;
        }

        /// <summary>
        /// Resets using current settings.
        /// </summary>
        internal void Reset()
        {
            _bufferIndex = 0;

            for (int i = 0; i < _buffers.Count; i++)
                _buffers[i].Reset();
        }

        /// <summary>
        /// Writes a segment to this packet bundle using the current WriteIndex.
        /// </summary>
        /// <param name="forceNewBuffer">True to force data into a new buffer.</param>
        internal void Write(ArraySegment<byte> segment, bool forceNewBuffer = false)
        {
            //Nothing to be written.
            if (segment.Count == 0)
                return;

            /* If the segment count is larger than the mtu then
             * something went wrong. Nothing should call this method
             * directly except the TransportManager, which will automatically
             * split packets that exceed MTU into reliable ordered. */
            if (segment.Count > _maximumTransportUnit)
            {
                if (_networkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Segment is length of {segment.Count} while MTU is {_maximumTransportUnit}. Packet was not split properly and will not be sent.");
                return;
            }

            ByteBuffer ba = _buffers[_bufferIndex];
            /* Make a new buffer if...
             * forcing a new buffer and data has already been written to the current.
             * or---
             * segment.Count is more than what is remaining in the buffer. */
            bool useNewBuffer = (forceNewBuffer && ba.Length > _reserve) ||
                (segment.Count > ba.Remaining);
            if (useNewBuffer)
            {
                _bufferIndex++;
                //If need to make a new buffer then do so.
                if (_buffers.Count <= _bufferIndex)
                {
                    ba = AddBuffer();
                }
                else
                {
                    ba = _buffers[_bufferIndex];
                    ba.Reset();
                }
            }

            uint tick = _networkManager.TimeManager.LocalTick;
            ba.CopySegment(tick, segment);
        }

        /// <summary>
        /// Gets a buffer for the specified index. Returns true and outputs the buffer if it was successfully found.
        /// </summary>
        /// <param name="index">Index of the buffer to retrieve.</param>
        /// <param name="bb">Buffer retrieved from the list. Null if the specified buffer was not found.</param>
        internal bool GetBuffer(int index, out ByteBuffer bb)
        {
            bb = null;

            if (index >= _buffers.Count || index < 0)
            {
                if (_networkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Index of {index} is out of bounds. There are {_buffers.Count} available.");
                return false;
            }
            if (index > _bufferIndex)
            {
                if (_networkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Index of {index} exceeds the number of written buffers. There are {WrittenBuffers} written buffers.");
                return false;
            }

            bb = _buffers[index];
            return bb.HasData;
        }

        /// <summary>
        /// Returns a PacketBundle for a channel. ResetPackets must be called afterwards.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns>True if PacketBundle is valid on the index and contains data.</returns>
        internal static bool GetPacketBundle(int channel, List<PacketBundle> bundles, out PacketBundle mtuBuffer)
        {
            //Out of bounds.
            if (channel >= bundles.Count)
            {
                mtuBuffer = null;
                return false;
            }

            mtuBuffer = bundles[channel];
            return mtuBuffer.HasData;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Connection/NetworkConnection.Buffer.cs ---
﻿using FishNet.Broadcast;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Connection
{
    public partial class NetworkConnection
    {

        #region Private.
        /// <summary>
        /// PacketBundles to send to this connection. An entry will be made for each channel.
        /// </summary>
        private List<PacketBundle> _toClientBundles = new List<PacketBundle>();
        /// <summary>
        /// True if this object has been dirtied.
        /// </summary>
        private bool _serverDirtied;
        #endregion

        /// <summary>
        /// Initializes this script.
        /// </summary>
        private void InitializeBuffer()
        {
            for (byte i = 0; i < TransportManager.CHANNEL_COUNT; i++)
            {
                int mtu = NetworkManager.TransportManager.Transport.GetMTU(i);
                _toClientBundles.Add(new PacketBundle(NetworkManager, mtu));
            }
        }

        /// <summary>
        /// Sends a broadcast to this connection.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the client must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!IsActive)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Connection is not valid, cannot send broadcast.");
            }
            else
            {
                NetworkManager.ServerManager.Broadcast<T>(this, message, requireAuthenticated, channel);
            }
        }

        /// <summary>
        /// Sends data from the server to a client.
        /// </summary>
        /// <param name="forceNewBuffer">True to force data into a new buffer.</param>
        internal void SendToClient(byte channel, ArraySegment<byte> segment, bool forceNewBuffer = false)
        {
            //Cannot send data when disconnecting.
            if (Disconnecting)
                return;

            if (!IsActive)
            {
                NetworkManager.LogWarning($"Data cannot be sent to connection {ClientId} because it is not active.");
                return;
            }
            //If channel is out of bounds then default to the first channel.
            if (channel >= _toClientBundles.Count)
                channel = 0;

            _toClientBundles[channel].Write(segment, forceNewBuffer);
            ServerDirty();
        }

        /// <summary>
        /// Returns a PacketBundle for a channel. ResetPackets must be called afterwards.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns>True if PacketBundle is valid on the index and contains data.</returns>
        internal bool GetPacketBundle(int channel, out PacketBundle packetBundle)
        {
            return PacketBundle.GetPacketBundle(channel, _toClientBundles, out packetBundle);
        }

        /// <summary>
        /// Indicates the server has data to send to this connection.
        /// </summary>
        private void ServerDirty()
        {
            bool wasDirty = _serverDirtied;
            _serverDirtied = true;

            //If not yet dirty then tell transport manager this is dirty.
            if (!wasDirty)
                NetworkManager.TransportManager.ServerDirty(this);
        }

        /// <summary>
        /// Resets that there is data to send.
        /// </summary>
        internal void ResetServerDirty()
        {
            _serverDirtied = false;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Connection/NetworkConnection.PingPong.cs ---
﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Timing;
using System;
using UnityEngine;

namespace FishNet.Connection
{

    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection : IEquatable<NetworkConnection>
    {
#pragma warning disable CS0414
        #region Private.
        /// <summary>
        /// Last tick this connection sent a ping.
        /// </summary>
        private uint _lastPingTick;
        /// <summary>
        /// Number of times client has excessively sent a ping.
        /// </summary>
        private float _excessivePingCount;
        /// <summary>
        /// Ticks expected between each ping.
        /// </summary>
        private uint _requiredPingTicks;
        #endregion

        #region Const.
        /// <summary>
        /// Number of times a ping may occur excessively before server will punish connection.
        /// </summary>
        private const byte EXCESSIVE_PING_LIMIT = 10;
        #endregion
#pragma warning restore CS0414
        /// <summary>
        /// Initializes for ping.
        /// </summary>
        private void InitializePing()
        {
            //Give the client some room for error.
            float requiredInterval = (NetworkManager.TimeManager.PingInterval * 0.85f);
            //Round down so required ticks is lower.
            _requiredPingTicks = NetworkManager.TimeManager.TimeToTicks(requiredInterval, TickRounding.RoundDown);
        }

        /// <summary>
        /// Resets PingPong values.
        /// </summary>
        private void ResetPingPong()
        {
            _excessivePingCount = 0;
            _lastPingTick = 0;
        }

        /// <summary>
        /// Called when a ping is received from this connection. Returns if can respond to ping.
        /// </summary>
        /// <returns>True to respond to ping, false to kick connection.</returns>
        internal bool CanPingPong()
        {
            /* Only check ping conditions in build. Editors are prone to pausing which can
             * improperly kick clients. */
#if UNITY_EDITOR
            return true;
#else
            TimeManager tm = (NetworkManager == null) ? InstanceFinder.TimeManager : NetworkManager.TimeManager;
            //Server FPS is running low, timing isn't reliable enough to kick clients.
            if (tm.LowFrameRate)
                return true;

            uint currentTick = tm.Tick;
            uint difference = (currentTick - _lastPingTick);
            _lastPingTick = currentTick;

            //Ping sent too quickly.
            if (difference < _requiredPingTicks)
            {
                _excessivePingCount += 1f;
                //Ping limit hit.
                if (_excessivePingCount >= EXCESSIVE_PING_LIMIT)
                {
                    if (NetworkManager.CanLog(LoggingType.Warning))
                        Debug.LogWarning($"Kicked connectionId {ClientId} for excessive pings.");
                    Disconnect(true);
                }

                //Return to not send pong back.
                return false;
            }
            //Ping isnt too fast.
            else
            {
                _excessivePingCount = Mathf.Max(0f, _excessivePingCount - 0.5f);
                return true;
            }
#endif
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Connection/NetworkConnection.Prediction.cs ---
﻿using FishNet.Managing;
using FishNet.Serializing.Helping;
using System;

namespace FishNet.Connection
{

    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection : IEquatable<NetworkConnection>
    {

        /// <summary>
        /// Called when the server performs replication on any object which has this connection as the owner.
        /// </summary>
        [CodegenExclude] //Make private.
        public void ReplicationPerformedInternal()
        {

        }
     
    }

}
'''
'''--- Assets/FishNet/Runtime/Connection/NetworkConnection.QOL.cs ---
﻿using FishNet.Managing;
using System;

namespace FishNet.Connection
{

    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection : IEquatable<NetworkConnection>
    {

        /// <summary>
        /// Returns the address of this connection.
        /// </summary>
        /// <returns></returns>
        public string GetAddress()
        {
            if (!IsValid)
                return string.Empty;
            if (NetworkManager == null)
                return string.Empty;

            return NetworkManager.TransportManager.Transport.GetConnectionAddress(ClientId);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Connection/NetworkConnection.cs ---
﻿using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine.SceneManagement;

namespace FishNet.Connection
{

    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection : IEquatable<NetworkConnection>
    {

        #region Public.
        /// <summary>
        /// Called after this connection has loaded start scenes. Boolean will be true if asServer. Available to this connection and server.
        /// </summary>
        public event Action<NetworkConnection, bool> OnLoadedStartScenes;
        /// <summary>
        /// Called after connection gains ownership of an object, and after the object has been added to Objects. Available to this connection and server.
        /// </summary>
        public event Action<NetworkObject> OnObjectAdded;
        /// <summary>
        /// Called after connection loses ownership of an object, and after the object has been removed from Objects. Available to this connection and server.
        /// </summary>
        public event Action<NetworkObject> OnObjectRemoved;
        /// <summary>
        /// NetworkManager managing this class.
        /// </summary>
        public NetworkManager NetworkManager { get; private set; }
        /// <summary>
        /// True if connection has loaded start scenes. Available to this connection and server.
        /// </summary>
        public bool LoadedStartScenes => (_loadedStartScenesAsServer || _loadedStartScenesAsClient);
        /// <summary>
        /// True if loaded start scenes as server.
        /// </summary>
        private bool _loadedStartScenesAsServer;
        /// <summary>
        /// True if loaded start scenes as client.
        /// </summary>
        private bool _loadedStartScenesAsClient;
        /// <summary>
        /// True if this connection is authenticated. Only available to server.
        /// </summary>
        public bool Authenticated { get; private set; }
        /// <summary>
        /// True if this connection IsValid and not Disconnecting.
        /// </summary>
        public bool IsActive => (ClientId >= 0 && !Disconnecting);
        /// <summary>
        /// True if this connection is valid. An invalid connection indicates no client is set for this reference.
        /// </summary>
        public bool IsValid => (ClientId >= 0);
        /// <summary>
        /// Unique Id for this connection.
        /// </summary>
        public int ClientId = -1;
        /// <summary>
        /// Returns if this connection is for the local client.
        /// </summary>
        public bool IsLocalClient => (NetworkManager == null) ? false : (NetworkManager.ClientManager.Connection == this);
        /// <summary>
        /// 
        /// </summary>
        private HashSet<NetworkObject> _objects = new HashSet<NetworkObject>();
        /// <summary>
        /// Objects owned by this connection. Available to this connection and server.
        /// </summary>
        public IReadOnlyCollection<NetworkObject> Objects => _objects;
        /// <summary>
        /// The first object within Objects.
        /// </summary>
        public NetworkObject FirstObject { get; private set; }
        /// <summary>
        /// Scenes this connection is in. Available to this connection and server.
        /// </summary>
        public HashSet<Scene> Scenes { get; private set; } = new HashSet<Scene>();
        /// <summary>
        /// True if this connection is being disconnected. Only available to server.
        /// </summary>
        public bool Disconnecting { get; private set; }
        /// <summary>
        /// Tick when Disconnecting was set.
        /// </summary>
        internal uint DisconnectingTick { get; private set; }
        /// <summary>
        /// Custom data associated with this connection which may be modified by the user.
        /// The value of this field are not synchronized over the network.
        /// </summary>
        public object CustomData = null;
        /// <summary>
        /// Local tick of the server when this connection last replicated.
        /// </summary>
        public uint LocalReplicateTick { get; internal set; }
        /// <summary>
        /// Tick of the last packet received from this connection.
        /// This value is only available on the server.
        /// </summary>
        public uint LastPacketTick { get; internal set; }
        #endregion

        #region Comparers.
        public override bool Equals(object obj)
        {
            if (obj is NetworkConnection nc)
                return (nc.ClientId == this.ClientId);
            else
                return false;
        }
        public bool Equals(NetworkConnection nc)
        {
            if (nc is null)
                return false;
            //If either is -1 Id.
            if (this.ClientId == -1 || nc.ClientId == -1)
                return false;
            //Same object.
            if (System.Object.ReferenceEquals(this, nc))
                return true;

            return (this.ClientId == nc.ClientId);
        }
        public override int GetHashCode()
        {
            return ClientId;
        }
        public static bool operator ==(NetworkConnection a, NetworkConnection b)
        {
            if (a is null && b is null)
                return true;
            if (a is null && !(b is null))
                return false;

            return (b == null) ? a.Equals(b) : b.Equals(a);
        }
        public static bool operator !=(NetworkConnection a, NetworkConnection b)
        {
            return !(a == b);
        }
        #endregion

        [APIExclude]
        public NetworkConnection() { }
        [APIExclude]
        public NetworkConnection(NetworkManager manager, int clientId)
        {
            Initialize(manager, clientId);
        }

        /// <summary>
        /// Initializes this for use.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Initialize(NetworkManager nm, int clientId)
        {
            NetworkManager = nm;
            ClientId = clientId;
            InitializeBuffer();
            InitializePing();
        }

        /// <summary>
        /// Resets this instance.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void Reset()
        {
            ClientId = -1;
            ClearObjects();
            Authenticated = false;
            NetworkManager = null;
            _loadedStartScenesAsClient = false;
            _loadedStartScenesAsServer = false;
            SetDisconnecting(false);
            Scenes.Clear();
            ResetPingPong();
        }

        /// <summary>
        /// Sets Disconnecting boolean for this connection.
        /// </summary>
        internal void SetDisconnecting(bool value)
        {
            Disconnecting = value;
            if (Disconnecting)
                DisconnectingTick = NetworkManager.TimeManager.LocalTick;
        }

        /// <summary>
        /// Disconnects this connection.
        /// </summary>
        /// <param name="immediately">True to disconnect immediately. False to send any pending data first.</param>
        public void Disconnect(bool immediately)
        {
            if (Disconnecting)
            {
                NetworkManager.LogWarning($"ClientId {ClientId} is already disconnecting.");
                return;
            }

            SetDisconnecting(true);
            //If immediately then force disconnect through transport.
            if (immediately)
                NetworkManager.TransportManager.Transport.StopConnection(ClientId, true);
            //Otherwise mark dirty so server will push out any pending information, and then disconnect.
            else
                ServerDirty();
        }

        /// <summary>
        /// Returns if just loaded start scenes and sets them as loaded if not.
        /// </summary>
        /// <returns></returns>
        internal bool SetLoadedStartScenes(bool asServer)
        {
            bool loadedToCheck = (asServer) ? _loadedStartScenesAsServer : _loadedStartScenesAsClient;
            //Result becomes true if not yet loaded start scenes.
            bool result = !loadedToCheck;
            if (asServer)
                _loadedStartScenesAsServer = true;
            else
                _loadedStartScenesAsClient = true;

            OnLoadedStartScenes?.Invoke(this, asServer);

            return result;
        }

        /// <summary>
        /// Sets connection as authenticated.
        /// </summary>
        internal void ConnectionAuthenticated()
        {
            Authenticated = true;
        }

        /// <summary>
        /// Adds to Objects owned by this connection.
        /// </summary>
        /// <param name="nob"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void AddObject(NetworkObject nob)
        {
            _objects.Add(nob);
            //If adding the first object then set new FirstObject.
            if (_objects.Count == 1)
                FirstObject = nob;

            OnObjectAdded?.Invoke(nob);
        }

        /// <summary>
        /// Removes from Objects owned by this connection.
        /// </summary>
        /// <param name="nob"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void RemoveObject(NetworkObject nob)
        {
            _objects.Remove(nob);
            //If removing the first object then set a new one.
            if (nob == FirstObject)
                SetFirstObject();

            OnObjectRemoved?.Invoke(nob);
        }

        /// <summary>
        /// Clears all Objects.
        /// </summary>
        private void ClearObjects()
        {
            _objects.Clear();
            FirstObject = null;
        }

        /// <summary>
        /// Sets FirstObject using the first element in Objects.
        /// </summary>
        private void SetFirstObject()
        {
            if (_objects.Count == 0)
            {
                FirstObject = null;
            }
            else
            {
                foreach (NetworkObject nob in Objects)
                {
                    FirstObject = nob;
                    break;
                }
            }
        }

        /// <summary>
        /// Adds a scene to this connections Scenes.
        /// </summary>
        /// <param name="scene"></param>
        /// <returns></returns>
        internal bool AddToScene(Scene scene)
        {
            return Scenes.Add(scene);
        }

        /// <summary>
        /// Removes a scene to this connections Scenes.
        /// </summary>
        /// <param name="scene"></param>
        /// <returns></returns>
        internal bool RemoveFromScene(Scene scene)
        {
            return Scenes.Remove(scene);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Documenting/Attributes.cs ---
﻿
using System;

namespace FishNet.Documenting
{
    public class APIExcludeAttribute : Attribute { }

}

'''
'''--- Assets/FishNet/Runtime/Editor/CodeStripping.cs ---
﻿
using FishNet.Configuring;
using System.IO;
using UnityEngine;
using System.Xml.Serialization;

#if UNITY_EDITOR
using FishNet.Editing.PrefabCollectionGenerator;
using UnityEditor.Compilation;
using UnityEditor.Build.Reporting;
using UnityEditor;
using UnityEditor.Build;
#endif

namespace FishNet.Configuring
{

    public class CodeStripping
    
    {

        /// <summary>
        /// True if making a release build for client.
        /// </summary>
        public static bool ReleasingForClient => (Configuration.ConfigurationData.IsBuilding && !Configuration.ConfigurationData.IsHeadless && !Configuration.ConfigurationData.IsDevelopment);
        /// <summary>
        /// True if making a release build for server.
        /// </summary>
        public static bool ReleasingForServer => (Configuration.ConfigurationData.IsBuilding && Configuration.ConfigurationData.IsHeadless && !Configuration.ConfigurationData.IsDevelopment);
        /// <summary>
        /// Returns if to remove server logic.
        /// </summary>
        /// <returns></returns>
        public static bool RemoveServerLogic
        {
            get
            {
                

                /* This is to protect non pro users from enabling this
                 * without the extra logic code.  */
#pragma warning disable CS0162 // Unreachable code detected
                return false;
#pragma warning restore CS0162 // Unreachable code detected
            }
        }
        /// <summary>
        /// True if building and stripping is enabled.
        /// </summary>
        public static bool StripBuild
        {
            get
            {
                

                /* This is to protect non pro users from enabling this
                 * without the extra logic code.  */
#pragma warning disable CS0162 // Unreachable code detected
                return false;
#pragma warning restore CS0162 // Unreachable code detected
            }
        }
        /// <summary>
        /// Technique to strip methods.
        /// </summary>
        public static StrippingTypes StrippingType => (StrippingTypes)Configuration.ConfigurationData.StrippingType;

        private static object _compilationContext;
        public int callbackOrder => 0;
#if UNITY_EDITOR

        public void OnPreprocessBuild(BuildReport report)
        {
            Generator.IgnorePostProcess = true;
            Generator.GenerateFull();
            CompilationPipeline.compilationStarted += CompilationPipelineOnCompilationStarted;
            CompilationPipeline.compilationFinished += CompilationPipelineOnCompilationFinished;

            
        }
        /* Solution for builds ending with errors and not triggering OnPostprocessBuild.
        * Link: https://gamedev.stackexchange.com/questions/181611/custom-build-failure-callback
        */
        private void CompilationPipelineOnCompilationStarted(object compilationContext)
        {
            _compilationContext = compilationContext;
        }

        private void CompilationPipelineOnCompilationFinished(object compilationContext)
        {
            if (compilationContext != _compilationContext)
                return;

            _compilationContext = null;

            CompilationPipeline.compilationStarted -= CompilationPipelineOnCompilationStarted;
            CompilationPipeline.compilationFinished -= CompilationPipelineOnCompilationFinished;

            BuildingEnded();
        }

        private void BuildingEnded()
        {
            

            Generator.IgnorePostProcess = false;
        }

        public void OnPostprocessBuild(BuildReport report)
        {
            
                BuildingEnded();
        }
#endif
        }

}

'''
'''--- Assets/FishNet/Runtime/Editor/Configuration/SettingsProvider.cs ---
﻿//File intentionally left blank. //remove on 2023/01/01
'''
'''--- Assets/FishNet/Runtime/Editor/Configuring/ConfigurationData.cs ---
﻿
using System;
using System.IO;
using System.Xml.Serialization;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FishNet.Configuring
{
     
    public enum StrippingTypes : int
    { 
        Redirect = 0,
        Empty_Experimental = 1,
        //MoveAndEmpty = 2
    }

    public class ConfigurationData
    {
        //Non serialized doesn't really do anything, its just for me.
        [System.NonSerialized]
        public bool Loaded;

        public bool IsBuilding;
        public bool IsDevelopment;
        public bool IsHeadless;

        public bool StripReleaseBuilds = false;
        public int StrippingType;
    }

    public static class ConfigurationDataExtension
    {

        /// <summary>
        /// Returns if a differs from b.
        /// </summary>
        public static bool HasChanged(this ConfigurationData a, ConfigurationData b)
        {
            return (a.StripReleaseBuilds != b.StripReleaseBuilds);
        }
        /// <summary>
        /// Copies all values from source to target.
        /// </summary>
        public static void CopyTo(this ConfigurationData source, ConfigurationData target)
        {
            target.StripReleaseBuilds = source.StripReleaseBuilds;
        }

        /// <summary>
        /// Writes a configuration data.
        /// </summary>
        public static void Write(this ConfigurationData cd, bool refreshAssetDatabase)
        {
            /* Why is this a thing you ask? Because Unity makes it VERY difficult to read values from
             * memory during builds since on some Unity versions the building application is on a different
             * processor. In result instead of using memory to read configurationdata the values
             * must be written to disk then load the disk values as needed.
             * 
             * Fortunatelly the file is extremely small and this does not occur often at all. The disk read
             * will occur once per script save, and once per assembly when building. */
            try
            {
                string path = Configuration.GetAssetsPath(Configuration.CONFIG_FILE_NAME);
                XmlSerializer serializer = new XmlSerializer(typeof(ConfigurationData));
                TextWriter writer = new StreamWriter(path);
                serializer.Serialize(writer, cd);
                writer.Close();
#if UNITY_EDITOR
                if (refreshAssetDatabase)
                {
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }
#endif
            }
            catch (Exception ex)
            {
                throw new Exception($"An error occurred while writing ConfigurationData. Message: {ex.Message}");
            }

        }

        /// <summary>
        /// Writes a configuration data.
        /// </summary>
        public static void Write(this ConfigurationData cd, string path, bool refreshAssetDatabase)
        {
            /* Why is this a thing you ask? Because Unity makes it VERY difficult to read values from
             * memory during builds since on some Unity versions the building application is on a different
             * processor. In result instead of using memory to read configurationdata the values
             * must be written to disk then load the disk values as needed.
             * 
             * Fortunatelly the file is extremely small and this does not occur often at all. The disk read
             * will occur once per script save, and once per assembly when building. */
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(ConfigurationData));
                TextWriter writer = new StreamWriter(path);
                serializer.Serialize(writer, cd);
                writer.Close();
#if UNITY_EDITOR
                if (refreshAssetDatabase)
                {
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }
#endif
            }
            catch (Exception ex)
            {
                throw new Exception($"An error occurred while writing ConfigurationData. Message: {ex.Message}");
            }

        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Editor/Configuring/ConfigurationEditor.cs ---
﻿#if UNITY_EDITOR
using FishNet.Editing.PrefabCollectionGenerator;
using FishNet.Object;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Editing
{
    public class ConfigurationEditor : EditorWindow
    {

        [MenuItem("Fish-Networking/Configuration", false, 0)]
        public static void ShowConfiguration()
        {
            SettingsService.OpenProjectSettings("Project/Fish-Networking/Configuration");
        }

    }

    public class OpenDocumentationMenu : MonoBehaviour
    {
        /// <summary>
        /// Opens the documentation.
        /// </summary>
        [MenuItem("Fish-Networking/Documentation", false, int.MaxValue)]
        public static void OpenDocumentation()
        {
            System.Diagnostics.Process.Start("https://fish-networking.gitbook.io/docs/");
        }

    }

    public class RebuildSceneIdMenu : MonoBehaviour
    {
        /// <summary>
        /// Rebuilds sceneIds for open scenes.
        /// </summary>
        [MenuItem("Fish-Networking/Rebuild SceneIds", false, 20)]
        public static void RebuildSceneIds()
        {
            int generatedCount = 0;
            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene s = SceneManager.GetSceneAt(i);

                ListCache<NetworkObject> nobs;
                SceneFN.GetSceneNetworkObjects(s, false, out nobs);
                for (int z = 0; z < nobs.Written; z++)
                {
                    NetworkObject nob = nobs.Collection[z];
                    nob.TryCreateSceneID();
                    EditorUtility.SetDirty(nob);
                }
                generatedCount += nobs.Written;

                ListCaches.StoreCache(nobs);
            }

            Debug.Log($"Generated sceneIds for {generatedCount} objects over {SceneManager.sceneCount} scenes. Please save your open scenes.");
        }

    }

    public class RefreshDefaultPrefabsMenu : MonoBehaviour
    {
        /// <summary>
        /// Rebuilds the DefaultPrefabsCollection file.
        /// </summary>
        [MenuItem("Fish-Networking/Refresh Default Prefabs", false, 21)]
        public static void RebuildDefaultPrefabs()
        {
            Debug.Log("Refreshing default prefabs.");
            Generator.GenerateFull(null, true);
        }

    }

}
#endif
'''
'''--- Assets/FishNet/Runtime/Editor/Configuring/Configuring.cs ---
﻿using System.IO;
using System.Xml.Serialization;

#if UNITY_EDITOR
using UnityEditor.Compilation;
using UnityEditor.Build.Reporting;
using UnityEditor;
using UnityEditor.Build;
#endif

namespace FishNet.Configuring
{

    public class Configuration
    {

        /// <summary>
        /// 
        /// </summary>
        private static ConfigurationData _configurationData;
        /// <summary>
        /// ConfigurationData to use.
        /// </summary>
        public static ConfigurationData ConfigurationData
        {
            get
            {
                if (_configurationData == null)
                    _configurationData = LoadConfigurationData();
                if (_configurationData == null)
                    throw new System.Exception("Fish-Networking ConfigurationData could not be loaded. Certain features such as code-stripping may not function.");
                return _configurationData;
            }
            private set
            {
                _configurationData = value;
            }
        }

        /// <summary>
        /// File name for configuration disk data.
        /// </summary>
        public const string CONFIG_FILE_NAME = "FishNet.Config.XML";

        /// <summary>
        /// Returns the path for the configuration file.
        /// </summary>
        /// <returns></returns>
        internal static string GetAssetsPath(string additional = "")
        {
            string a = Path.Combine(System.IO.Directory.GetCurrentDirectory(), "Assets");
            if (additional != "")
                a = Path.Combine(a, additional);
            return a;
        }
        /// <summary>
        /// Returns FishNetworking ConfigurationData.
        /// </summary>
        /// <returns></returns>
        internal static ConfigurationData LoadConfigurationData()
        {
            //return new ConfigurationData();
            if (_configurationData == null || !_configurationData.Loaded)
            {
                string configPath = GetAssetsPath(CONFIG_FILE_NAME);
                //string configPath = string.Empty;
                //File is on disk.
                if (File.Exists(configPath))
                {
                    XmlSerializer serializer = new XmlSerializer(typeof(ConfigurationData));
                    FileStream fs = new FileStream(configPath, FileMode.Open, FileAccess.Read, FileShare.Read);
                    _configurationData = (ConfigurationData)serializer.Deserialize(fs);
                    fs.Close();

                    _configurationData.Loaded = true;
                }
                else
                {
                    //If null then make a new instance.
                    if (_configurationData == null)
                        _configurationData = new ConfigurationData();
                    //Don't unset loaded, if its true then it should have proper info.
                    //_configurationData.Loaded = false;
                }
            }

            return _configurationData;

        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Editor/Configuring/SettingsProvider.cs ---
﻿#if UNITY_EDITOR

using UnityEngine;
using UnityEditor;
using FishNet.Configuring;

using UnitySettingsProviderAttribute = UnityEditor.SettingsProviderAttribute;
using UnitySettingsProvider = UnityEditor.SettingsProvider;
using System.Collections.Generic;

namespace FishNet.Configuring.Editing
{
    internal static class SettingsProvider
    {
        private static Vector2 _scrollView;

        [UnitySettingsProvider]
        private static UnitySettingsProvider Create()
        {
            return new UnitySettingsProvider("Project/Fish-Networking/Configuration", SettingsScope.Project)
            {
                label = "Configuration",

                guiHandler = OnGUI,

                keywords = new string[]
                {
                    "Fish",
                    "Networking",
                    "Configuration",
                },
            };
        }

        private static void OnGUI(string searchContext)
        {
            ConfigurationData configuration = Configuration.LoadConfigurationData();

            if (configuration == null)
            {
                EditorGUILayout.HelpBox("Unable to load configuration data.", MessageType.Error);

                return;
            }

            EditorGUI.BeginChangeCheck();

            GUIStyle scrollViewStyle = new GUIStyle()
            {
                padding = new RectOffset(10, 10, 10, 10),
            };

            _scrollView = GUILayout.BeginScrollView(_scrollView, scrollViewStyle);

            EditorGUILayout.BeginHorizontal();

            GUIStyle toggleStyle = new GUIStyle(EditorStyles.toggle)
            {
                richText = true,
            };

            configuration.StripReleaseBuilds = GUILayout.Toggle(configuration.StripReleaseBuilds, $"{ObjectNames.NicifyVariableName(nameof(configuration.StripReleaseBuilds))} <color=yellow>(Pro Only)</color>", toggleStyle);

            EditorGUILayout.EndHorizontal();

            if (configuration.StripReleaseBuilds)
            {
                EditorGUI.indentLevel++;
                //Stripping Method.
                List<string> enumStrings = new List<string>();
                foreach (string item in System.Enum.GetNames(typeof(StrippingTypes)))
                    enumStrings.Add(item);
                configuration.StrippingType = EditorGUILayout.Popup($"{ObjectNames.NicifyVariableName(nameof(configuration.StrippingType))}", (int)configuration.StrippingType, enumStrings.ToArray());

                EditorGUILayout.HelpBox("Development builds will not have code stripped. Additionally, if you plan to run as host disable code stripping.", MessageType.Warning);
                EditorGUI.indentLevel--;
            }

            GUILayout.EndScrollView();

            if (EditorGUI.EndChangeCheck()) Configuration.ConfigurationData.Write(true);
        }
    }
}

#endif

'''
'''--- Assets/FishNet/Runtime/Editor/Constants.cs ---
﻿using FishNet.Documenting;

namespace FishNet.Editing
{
    [APIExclude]
    public static class EditingConstants
    {
        public const string PRO_ASSETS_LOCKED_TEXT = "Fields marked with * are only active with Fish-Networking Pro.";
        public const string PRO_ASSETS_UNLOCKED_TEXT = "Thank you for supporting Fish-Networking! Pro asset features are unlocked.";

    }

}
'''
'''--- Assets/FishNet/Runtime/Editor/DefaultPrefabsFinder.cs ---
//#if UNITY_EDITOR
//using FishNet.Managing.Object;
//using FishNet.Object;
//using System.Collections.Generic;
//using System.IO;
//using UnityEditor;
//using UnityEngine;

//namespace FishNet.Editing
//{

//    [InitializeOnLoad]
//    internal static class DefaultPrefabsFinder
//    {
//        /// <summary>
//        /// True if initialized.
//        /// </summary>
//        [System.NonSerialized]
//        private static bool _initialized;
//        /// <summary>
//        /// Found default prefabs.
//        /// </summary>
//        private static DefaultPrefabObjects _defaultPrefabs;

//        static DefaultPrefabsFinder()
//        {
//            EditorApplication.update += InitializeOnce;
//        }

//        /// <summary>
//        /// Finds and sets the default prefabs reference.
//        /// </summary>
//        internal static DefaultPrefabObjects GetDefaultPrefabsFile(out bool justPopulated)
//        {
//            if (_defaultPrefabs == null)
//            {
//                List<UnityEngine.Object> results = Finding.GetScriptableObjects<DefaultPrefabObjects>(true, true);
//                if (results.Count > 0)
//                    _defaultPrefabs = (DefaultPrefabObjects)results[0];
//            }

//            justPopulated = false;
//            //If not found then try to create file.
//            if (_defaultPrefabs == null)
//            {
//                if (DefaultPrefabObjects.CanAutomate)
//                {
//                    DefaultPrefabObjects dpo = ScriptableObject.CreateInstance<DefaultPrefabObjects>();
//                    //Get save directory.
//                    string savePath = Finding.GetFishNetRuntimePath(true);
//                    AssetDatabase.CreateAsset(dpo, Path.Combine(savePath, $"{nameof(DefaultPrefabObjects)}.asset"));
//                }
//                else
//                {
//                    Debug.LogError($"Cannot create DefaultPrefabs because auto create is blocked.");
//                }
//            }

//            //If still null.
//            if (_defaultPrefabs == null)
//                Debug.LogWarning($"DefaultPrefabObjects not found. Prefabs list will not be automatically populated.");
//            else
//                justPopulated = PopulateDefaultPrefabs();

//            return _defaultPrefabs;
//        }

//        /// <summary>
//        /// Initializes the default prefab.
//        /// </summary>
//        private static void InitializeOnce()
//        {
//            if (_initialized)
//                return;
//            _initialized = true;

//            Finding.GetFishNetRuntimePath(false);
//            GetDefaultPrefabsFile(out _);

//            if (_defaultPrefabs != null)
//            {
//                //Populate any missing.
//                if (_defaultPrefabs.GetObjectCount() == 0)
//                    PopulateDefaultPrefabs();
//            }
//        }

//        /// <summary>
//        /// Finds all NetworkObjects in project and adds them to defaultPrefabs.
//        /// </summary>
//        /// <returns>True if was populated from assets.</returns>
//        internal static bool PopulateDefaultPrefabs(bool log = true, bool clear = false)
//        {
//            if (_defaultPrefabs == null)
//                return false;
//            if (!DefaultPrefabObjects.CanAutomate)
//                return false;
//            if (clear)
//                _defaultPrefabs.Clear();
//            if (_defaultPrefabs.GetObjectCount() > 0)
//                return false;

//            List<GameObject> gameObjects = Finding.GetGameObjects(true, true, false);
//            foreach (GameObject go in gameObjects)
//            {
//                if (go.TryGetComponent(out NetworkObject nob))
//                    _defaultPrefabs.AddObject(nob);
//            }

//            _defaultPrefabs.Sort();

//            int entriesAdded = _defaultPrefabs.GetObjectCount();
//            //Only print if some were added.
//            if (log && entriesAdded > 0)
//                Debug.Log($"Default prefabs was populated with {entriesAdded} prefabs.");

//            EditorUtility.SetDirty(_defaultPrefabs);
//            return true;
//        }

//    }

//}
//#endif
'''
'''--- Assets/FishNet/Runtime/Editor/Finding.cs ---
﻿#if UNITY_EDITOR
using FishNet.Utility.Constant;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Editing
{
    public static class Finding
    {
        #region Private.
        /// <summary>
        /// Path where the FishNet.Runtime assembly is.
        /// </summary>
        [System.NonSerialized]
        private static string _fishNetRuntimePath = string.Empty;
        /// <summary>
        /// Path where the FishNet.Generated assembly is.
        /// </summary>
        private static string _fishNetGeneratedPath = string.Empty;
        #endregion

        /// <summary>
        /// Sets FishNet assembly paths.
        /// </summary>
        /// <param name="error"></param>
        private static void SetPaths(bool error)
        {
            if (_fishNetGeneratedPath != string.Empty && _fishNetRuntimePath != string.Empty)
                return;

            string[] guids = AssetDatabase.FindAssets("t:asmdef", new string[] { "Assets" });
            string[] objectPaths = new string[guids.Length];
            for (int i = 0; i < guids.Length; i++)
                objectPaths[i] = AssetDatabase.GUIDToAssetPath(guids[i]);

            string runtimeName = (UtilityConstants.RUNTIME_ASSEMBLY_NAME + ".asmdef").ToLower();
            string generatedName = (UtilityConstants.GENERATED_ASSEMBLY_NAME + ".asmdef").ToLower();
            /* Find all network managers which use Single prefab linking
             * as well all network object prefabs. */
            foreach (string item in objectPaths)
            {
                //Found directory to create object in.
                if (item.ToLower().Contains(runtimeName))
                    _fishNetRuntimePath = System.IO.Path.GetDirectoryName(item);
                else if (item.ToLower().Contains(generatedName))
                    _fishNetGeneratedPath = System.IO.Path.GetDirectoryName(item);

                if (_fishNetGeneratedPath != string.Empty && _fishNetRuntimePath != string.Empty)
                    return;
            }
        }
        /// <summary>
        /// Gets path for where the FishNet.Runtime assembly is.
        /// </summary>
        /// <returns></returns>
        public static string GetFishNetRuntimePath(bool error)
        {
            SetPaths(error);
            return _fishNetRuntimePath;
        }
        /// <summary>
        /// Gets path for where the FishNet.Generated assembly is.
        /// </summary>
        /// <param name="error"></param>
        /// <returns></returns>
        public static string GetFishNetGeneratedPath(bool error)
        {
            SetPaths(error);
            return _fishNetGeneratedPath;
        }

        /// <summary>
        /// Gets all GameObjects in Assets and optionally scenes.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static List<GameObject> GetGameObjects(bool userAssemblies, bool fishNetAssembly, bool includeScenes, string[] ignoredPaths = null)
        {
            List<GameObject> results = new List<GameObject>();

            string[] guids;
            string[] objectPaths;

            guids = AssetDatabase.FindAssets("t:GameObject", null);
            objectPaths = new string[guids.Length];
            for (int i = 0; i < guids.Length; i++)
                objectPaths[i] = AssetDatabase.GUIDToAssetPath(guids[i]);

            foreach (string item in objectPaths)
            {
                bool inFishNet = item.Contains(_fishNetRuntimePath);
                if (inFishNet && !fishNetAssembly)
                    continue;
                if (!inFishNet && !userAssemblies)
                    continue;
                if (ignoredPaths != null)
                {
                    bool ignore = false;
                    foreach (string path in ignoredPaths)
                    {
                        if (item.Contains(path))
                        {
                            ignore = true;
                            break;
                        }
                    }
                    if (ignore)
                        continue;
                }

                GameObject go = (GameObject)AssetDatabase.LoadAssetAtPath(item, typeof(GameObject));
                results.Add(go);
            }

            if (includeScenes)
                results.AddRange(GetSceneGameObjects());

            return results;
        }

        /// <summary>
        /// Gets all GameObjects in all open scenes.
        /// </summary>
        /// <returns></returns>
        private static List<GameObject> GetSceneGameObjects()
        {
            List<GameObject> results = new List<GameObject>();

            for (int i = 0; i < SceneManager.sceneCount; i++)
                results.AddRange(GetSceneGameObjects(SceneManager.GetSceneAt(i)));

            return results;
        }
        /// <summary>
        /// Gets all GameObjects in a scene.
        /// </summary>
        private static List<GameObject> GetSceneGameObjects(Scene s)
        {
            List<GameObject> results = new List<GameObject>();
            List<Transform> buffer = new List<Transform>();
            //Iterate all root objects for the scene.
            GameObject[] gos = s.GetRootGameObjects();
            for (int i = 0; i < gos.Length; i++)
            {
                /* Get GameObjects within children of each
                 * root object then add them to the cache. */
                gos[i].GetComponentsInChildren<Transform>(true, buffer);
                foreach (Transform t in buffer)
                    results.Add(t.gameObject);
            }

            return results;
        }

        /// <summary>
        /// Gets created ScriptableObjects of T.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static List<UnityEngine.Object> GetScriptableObjects<T>(bool fishNetAssembly, bool breakOnFirst = false)
        {
            System.Type tType = typeof(T);
            List<UnityEngine.Object> results = new List<UnityEngine.Object>();

            string[] guids = AssetDatabase.FindAssets("t:ScriptableObject", new string[] { "Assets" });
            string[] objectPaths = new string[guids.Length];
            for (int i = 0; i < guids.Length; i++)
                objectPaths[i] = AssetDatabase.GUIDToAssetPath(guids[i]);

            /* This might be faster than using directory comparers.
             * Don't really care since this occurs only at edit. */
            List<string> fishNetPaths = new List<string>();
            fishNetPaths.Add(_fishNetGeneratedPath.Replace(@"/", @"\"));
            fishNetPaths.Add(_fishNetGeneratedPath.Replace(@"\", @"/"));
            fishNetPaths.Add(_fishNetRuntimePath.Replace(@"/", @"\"));
            fishNetPaths.Add(_fishNetRuntimePath.Replace(@"\", @"/"));
            /* Find all network managers which use Single prefab linking
             * as well all network object prefabs. */
            foreach (string item in objectPaths)
            {
                //This will skip hidden unity types.
                if (!item.EndsWith(".asset"))
                    continue;
                if (fishNetAssembly)
                {
                    bool found = false;
                    foreach (string path in fishNetPaths)
                    {
                        if (item.Contains(path))
                        {
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                        continue;
                }
                UnityEngine.Object obj = AssetDatabase.LoadAssetAtPath(item, tType);
                if (obj != null && tType != null && obj.GetType() == tType)
                {
                    results.Add(obj);
                    if (breakOnFirst)
                        return results;
                }
            }

            return results;
        }

    }
}
#endif
'''
'''--- Assets/FishNet/Runtime/Editor/PlayModeTracker.cs ---
﻿#if UNITY_EDITOR
using System;
using UnityEditor;
using UnityEngine;

namespace FishNet.Editing
{

    [InitializeOnLoad]
    public class PlayModeTracker
    {
        static PlayModeTracker()
        {
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
        }

        ~PlayModeTracker()
        {
            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
        }

        /// <summary>
        /// DateTime when the editor last exited playmode.
        /// </summary>
        private static DateTime _quitTime = DateTime.MaxValue;

        /// <summary>
        /// True if the editor has exited playmode within past.
        /// </summary>
        /// <param name="past"></param>
        /// <returns></returns>
        internal static bool QuitRecently(float past)
        {
            past *= 1000;
            return ((DateTime.Now - _quitTime).TotalMilliseconds < past);
        }

        private static void OnPlayModeStateChanged(PlayModeStateChange stateChange)
        {
            switch (stateChange)
            {
                case (PlayModeStateChange.ExitingPlayMode):
                    _quitTime = DateTime.Now;
                    break;
            }
        }

    }
}

#endif
'''
'''--- Assets/FishNet/Runtime/Editor/PrefabCollectionGenerator/Generator.cs ---
﻿#if UNITY_EDITOR

using FishNet.Managing.Object;
using FishNet.Object;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityDebug = UnityEngine.Debug;

namespace FishNet.Editing.PrefabCollectionGenerator
{
    internal sealed class Generator : AssetPostprocessor
    {
        public Generator()
        {
            if (!_subscribed)
            {
                _subscribed = true;
                EditorApplication.update += OnEditorUpdate;
            }
        }
        ~Generator()
        {
            if (_subscribed)
            {
                _subscribed = false;
                EditorApplication.update -= OnEditorUpdate;
            }
        }

        #region Types.
        private struct SpecifiedFolder
        {
            public string Path;
            public bool Recursive;

            public SpecifiedFolder(string path, bool recursive)
            {
                Path = path;
                Recursive = recursive;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// True to ignore post process changes.
        /// </summary>
        public static bool IgnorePostProcess = false;
        #endregion

        #region Private.
        /// <summary>
        /// Last asset to import when there was only one imported asset and no other changes.
        /// </summary>
        private static string _lastSingleImportedAsset = string.Empty;
        /// <summary>
        /// Cached DefaultPrefabObjects reference.
        /// </summary>
        private static DefaultPrefabObjects _cachedDefaultPrefabs;
        /// <summary>
        /// True to refresh prefabs next update.
        /// </summary>
        private static bool _retryRefreshDefaultPrefabs;
        /// <summary>
        /// True if already subscribed to EditorApplication.Update.
        /// </summary>
        private static bool _subscribed;
        /// <summary>
        /// True if ran once since editor started.
        /// </summary>
        [System.NonSerialized]
        private static bool _ranOnce;
        /// <summary>
        /// Last paths of updated nobs during a changed update.
        /// </summary>
        [System.NonSerialized]
        private static List<string> _lastUpdatedNamePaths = new List<string>();
        /// <summary>
        /// Last frame changed was updated.
        /// </summary>
        [System.NonSerialized]
        private static int _lastUpdatedFrame = -1;
        /// <summary>
        /// Length of assets strings during the last update.
        /// </summary>
        [System.NonSerialized]
        private static int _lastUpdatedLengths = -1;
        #endregion

        private static string[] GetPrefabFiles(string startingPath, HashSet<string> excludedPaths, bool recursive)
        {
            //Opportunity to exit early if there are no excluded paths.
            if (excludedPaths.Count == 0)
            {
                string[] strResults = Directory.GetFiles(startingPath, "*.prefab", SearchOption.AllDirectories);
                return strResults;
            }
            //starting path is excluded.
            if (excludedPaths.Contains(startingPath))
                return new string[0];

            //Folders remaining to be iterated.
            List<string> enumeratedCollection = new List<string>() { startingPath };
            //Only check other directories if recursive.
            if (recursive)
            {
                //Find all folders which aren't excluded.
                for (int i = 0; i < enumeratedCollection.Count; i++)
                {
                    string[] allFolders = Directory.GetDirectories(enumeratedCollection[i], "*", SearchOption.TopDirectoryOnly);
                    for (int z = 0; z < allFolders.Length; z++)
                    {
                        string current = allFolders[z];
                        //Not excluded.
                        if (!excludedPaths.Contains(current))
                            enumeratedCollection.Add(current);
                    }
                }
            }

            //Valid prefab files.
            List<string> results = new List<string>();
            //Build files from folders.
            int count = enumeratedCollection.Count;
            for (int i = 0; i < count; i++)
            {
                string[] r = Directory.GetFiles(enumeratedCollection[i], "*.prefab", SearchOption.TopDirectoryOnly);
                results.AddRange(r);
            }

            return results.ToArray();
        }

        /// <summary>
        /// Removes paths which may overlap each other, such as sub directories.
        /// </summary>
        private static void RemoveOverlappingFolders(List<SpecifiedFolder> folders)
        {
            for (int z = 0; z < folders.Count; z++)
            {
                for (int i = 0; i < folders.Count; i++)
                {
                    //Do not check against self.
                    if (i == z)
                        continue;

                    //Duplicate.
                    if (folders[z].Path.Equals(folders[i].Path, System.StringComparison.OrdinalIgnoreCase))
                    {
                        UnityDebug.LogError($"The same path is specified multiple times in the DefaultPrefabGenerator settings. Remove the duplicate to clear this error.");
                        folders.RemoveAt(i);
                        break;
                    }

                    /* We are checking if i can be within
                     * z. This is only possible if i is longer
                     * than z. */
                    if (folders[i].Path.Length < folders[z].Path.Length)
                        continue;
                    /* Do not need to check if not recursive.
                     * Only recursive needs to be checked because
                     * a shorter recursive path could contain
                     * a longer path. */
                    if (!folders[z].Recursive)
                        continue;

                    //Compare paths.
                    string zPath = GetPathWithSeparator(folders[z].Path);
                    string iPath = zPath.Substring(0, zPath.Length);
                    //If paths match.
                    if (iPath.Equals(zPath, System.StringComparison.OrdinalIgnoreCase))
                    {
                        UnityDebug.LogError($"Path {folders[i].Path} is included within recursive path {folders[z].Path}. Remove path {folders[i].Path} to clear this error.");
                        folders.RemoveAt(i);
                        break;
                    }
                }
            }

            string GetPathWithSeparator(string txt)
            {
                return txt.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar)
                    + Path.DirectorySeparatorChar;
            }
        }

        /// <summary>
        /// Returns a message to attach to logs if objects were dirtied.
        /// </summary>
        private static string GetDirtiedMessage(Settings settings, bool dirtied)
        {
            if (!settings.SaveChanges && dirtied)
                return " One or more NetworkObjects were dirtied. Please save your project.";
            else
                return string.Empty;
        }

        /// <summary>
        /// Updates prefabs by using only changed information.
        /// </summary>
        public static void GenerateChanged(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths, Settings settings = null)
        {
            if (settings == null)
                settings = Settings.Load();
            if (!settings.Enabled)
                return;

            bool log = settings.LogToConsole;
            Stopwatch sw = (log) ? Stopwatch.StartNew() : null;

            DefaultPrefabObjects prefabCollection = GetDefaultPrefabObjects(settings);
            //No need to error if nto found, GetDefaultPrefabObjects will.
            if (prefabCollection == null)
                return;

            int assetsLength = (importedAssets.Length + deletedAssets.Length + movedAssets.Length + movedFromAssetPaths.Length);
            List<string> changedNobPaths = new List<string>();

            System.Type goType = typeof(UnityEngine.GameObject);
            IterateAssetCollection(importedAssets);
            IterateAssetCollection(movedAssets);

            //True if dirtied by changes.
            bool dirtied;
            //First remove null entries.
            int startCount = prefabCollection.GetObjectCount();
            prefabCollection.RemoveNull();
            dirtied = (prefabCollection.GetObjectCount() != startCount);
            //First index which new objects will be added to.
            int firstAddIndex = (prefabCollection.GetObjectCount() - 1);

            //Iterates strings adding prefabs to collection.
            void IterateAssetCollection(string[] c)
            {
                foreach (string item in c)
                {
                    System.Type assetType = AssetDatabase.GetMainAssetTypeAtPath(item);
                    if (assetType != goType)
                        continue;

                    NetworkObject nob = AssetDatabase.LoadAssetAtPath<NetworkObject>(item);
                    if (nob != null)
                    {
                        changedNobPaths.Add(item);
                        prefabCollection.AddObject(nob, true);
                        dirtied = true;
                    }
                }
            }

            //To prevent out of range.
            if (firstAddIndex < 0 || firstAddIndex >= prefabCollection.GetObjectCount())
                firstAddIndex = 0;
            dirtied |= prefabCollection.SetAssetPathHashes(firstAddIndex);

            if (log && dirtied)
                UnityDebug.Log($"Default prefab generator updated prefabs in {sw.ElapsedMilliseconds}ms.{GetDirtiedMessage(settings, dirtied)}");

            //Check for redundancy.
            int frameCount = Time.frameCount;
            int changedCount = changedNobPaths.Count;
            if (frameCount == _lastUpdatedFrame && assetsLength == _lastUpdatedLengths && (changedCount == _lastUpdatedNamePaths.Count) && changedCount > 0)
            {
                bool allMatch = true;
                for (int i = 0; i < changedCount; i++)
                {
                    if (changedNobPaths[i] != _lastUpdatedNamePaths[i])
                    {
                        allMatch = false;
                        break;
                    }
                }

                /* If the import results are the same as the last attempt, on the same frame
                 * then there is likely an issue saving the assets. */
                if (allMatch)
                {
                    //Unset dirtied to prevent a save.
                    dirtied = false;
                    //Log this no matter what, it's critical.
                    UnityDebug.LogError($"Default prefab generator had a problem saving one or more assets. " +
                        $"This usually occurs when the assets cannot be saved due to missing scripts or serialization errors. " +
                        $"Please see above any prefabs which could not save any make corrections.");
                }

            }
            //Set last values.
            _lastUpdatedFrame = Time.frameCount;
            _lastUpdatedNamePaths = changedNobPaths;
            _lastUpdatedLengths = assetsLength;

            EditorUtility.SetDirty(prefabCollection);
            if (dirtied && settings.SaveChanges)
                AssetDatabase.SaveAssets();
        }

        /// <summary>
        /// Generates prefabs by iterating all files within settings parameters.
        /// </summary>
        public static void GenerateFull(Settings settings = null, bool forced = false)
        {
            if (settings == null)
                settings = Settings.Load();
            if (!forced && !settings.Enabled)
                return;
            bool log = settings.LogToConsole;

            Stopwatch sw = (log) ? Stopwatch.StartNew() : null;
            List<NetworkObject> foundNobs = new List<NetworkObject>();
            HashSet<string> excludedPaths = new HashSet<string>(settings.ExcludedFolders);

            //If searching the entire project.
            if (settings.SearchScope == Settings.SearchScopeType.EntireProject)
            {
                foreach (string path in GetPrefabFiles("Assets", excludedPaths, true))
                {
                    NetworkObject nob = AssetDatabase.LoadAssetAtPath<NetworkObject>(path);
                    if (nob != null)
                        foundNobs.Add(nob);
                }
            }
            //Specific folders.
            else if (settings.SearchScope == Settings.SearchScopeType.SpecificFolders)
            {
                List<SpecifiedFolder> folders = GetSpecifiedFolders(settings.IncludedFolders);
                RemoveOverlappingFolders(folders);

                foreach (SpecifiedFolder sf in folders)
                {
                    //If specified folder doesn't exist then continue.
                    if (!Directory.Exists(sf.Path))
                        continue;

                    foreach (string path in GetPrefabFiles(sf.Path, excludedPaths, sf.Recursive))
                    {
                        NetworkObject nob = AssetDatabase.LoadAssetAtPath<NetworkObject>(path);
                        if (nob != null)
                            foundNobs.Add(nob);
                    }
                }
            }
            //Unhandled.
            else
            {
                UnityDebug.LogError($"{settings.SearchScope} is not handled; default prefabs will not generator properly.");
            }

            DefaultPrefabObjects prefabCollection = GetDefaultPrefabObjects(settings);
            //No need to error if not found, GetDefaultPrefabObjects will throw.
            if (prefabCollection == null)
                return;

            //Clear and add built list.
            prefabCollection.Clear();
            prefabCollection.AddObjects(foundNobs, false);
            bool dirtied = prefabCollection.SetAssetPathHashes(0);

            if (log)
                UnityDebug.Log($"Default prefab generator found {prefabCollection.GetObjectCount()} prefabs in {sw.ElapsedMilliseconds}ms.{GetDirtiedMessage(settings, dirtied)}");

            EditorUtility.SetDirty(prefabCollection);
            if (settings.SaveChanges)
                AssetDatabase.SaveAssets();
        }

        /// <summary>
        /// Iterates folders building them into SpecifiedFolders.
        /// </summary>
        private static List<SpecifiedFolder> GetSpecifiedFolders(List<string> folders)
        {
            List<SpecifiedFolder> results = new List<SpecifiedFolder>();
            //Remove astericks.
            foreach (string path in folders)
            {
                int pLength = path.Length;
                if (pLength == 0)
                    continue;

                bool recursive;
                string p;
                //If the last character indicates resursive.
                if (path.Substring(pLength - 1, 1) == "*")
                {
                    p = path.Substring(0, pLength - 1);
                    recursive = true;
                }
                else
                {
                    p = path;
                    recursive = false;
                }

                results.Add(new SpecifiedFolder(p, recursive));
            }

            return results;
        }

        /// <summary>
        /// Returns the DefaultPrefabObjects file.
        /// </summary>
        private static DefaultPrefabObjects GetDefaultPrefabObjects(Settings settings = null)
        {
            if (settings == null)
                settings = Settings.Load();

            //Load the prefab collection
            string assetPath = settings.AssetPath;

            //If cached prefabs is not the same path as assetPath.
            if (_cachedDefaultPrefabs != null)
            {
                string foundPath = Path.GetFullPath(AssetDatabase.GetAssetPath(_cachedDefaultPrefabs));
                string assetPathFull = Path.GetFullPath(assetPath);
                if (foundPath != assetPathFull)
                    _cachedDefaultPrefabs = null;
            }

            //If cached is null try to get it.
            if (_cachedDefaultPrefabs == null)
            {
                //Only try to load it if file exist.
                if (File.Exists(assetPath))
                {
                    _cachedDefaultPrefabs = AssetDatabase.LoadAssetAtPath<DefaultPrefabObjects>(assetPath);
                    if (_cachedDefaultPrefabs == null)
                    {
                        //If already retried then throw an error.
                        if (_retryRefreshDefaultPrefabs)
                        {
                            UnityDebug.LogError("DefaultPrefabObjects file exists but it could not be loaded by Unity. Use the Fish-Networking menu to Refresh Default Prefabs.");
                        }
                        else
                        {
                            UnityDebug.Log("DefaultPrefabObjects file exists but it could not be loaded by Unity. Trying to reload the file next frame.");
                            _retryRefreshDefaultPrefabs = true;
                        }
                        return null;
                    }
                }
            }

            if (_cachedDefaultPrefabs == null)
            {
                UnityDebug.Log($"Creating a new DefaultPrefabsObject at {assetPath}.");
                string directory = Path.GetDirectoryName(assetPath);

                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                    AssetDatabase.Refresh();
                }

                _cachedDefaultPrefabs = ScriptableObject.CreateInstance<DefaultPrefabObjects>();
                AssetDatabase.CreateAsset(_cachedDefaultPrefabs, assetPath);
                AssetDatabase.SaveAssets();
            }

            if (_cachedDefaultPrefabs != null && _retryRefreshDefaultPrefabs)
                UnityDebug.Log("DefaultPrefabObjects found on the second iteration.");
            return _cachedDefaultPrefabs;
        }

        /// <summary>
        /// Called every frame the editor updates.
        /// </summary>
        private static void OnEditorUpdate()
        {
            if (!_retryRefreshDefaultPrefabs)
                return;

            GenerateFull();
            _retryRefreshDefaultPrefabs = false;
        }

        /// <summary>
        /// Called by Unity when assets are modified.
        /// </summary>
        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
        {
            //If retrying next frame don't bother updating, next frame will do a full refresh.
            if (_retryRefreshDefaultPrefabs)
                return;
            //Post process is being ignored. Could be temporary or user has disabled this feature.
            if (IgnorePostProcess)
                return;
            /* Don't iterate if updating or compiling as that could cause an infinite loop
             * due to the prefabs being generated during an update, which causes the update
             * to start over, which causes the generator to run again, which... you get the idea. */
            if (EditorApplication.isCompiling)
                return;

            DefaultPrefabObjects prefabCollection = GetDefaultPrefabObjects();
            if (prefabCollection == null)
                return;
            Settings settings = Settings.Load();

            if (prefabCollection.GetObjectCount() == 0)
            {
                //If there are no prefabs then do a full rebuild. Odds of there being none are pretty much nill.
                GenerateFull(settings);
            }
            else
            {
                int totalChanges = importedAssets.Length + deletedAssets.Length + movedAssets.Length + movedFromAssetPaths.Length;
                //Nothing has changed. This shouldn't occur but unity is funny so we're going to check anyway.
                if (totalChanges == 0)
                    return;

                //normalizes path.
                string dpoPath = Path.GetFullPath(settings.AssetPath);
                //If total changes is 1 and the only changed file is the default prefab collection then do nothing.
                if (totalChanges == 1)
                {
                    //Do not need to check movedFromAssetPaths because that's not possible for this check.
                    if ((importedAssets.Length == 1 && Path.GetFullPath(importedAssets[0]) == dpoPath)
                        || (deletedAssets.Length == 1 && Path.GetFullPath(deletedAssets[0]) == dpoPath)
                        || (movedAssets.Length == 1 && Path.GetFullPath(movedAssets[0]) == dpoPath))
                        return;

                    /* If the only change is an import then check if the imported file
                     * is the same as the last, and if so check into returning early.
                     * For some reason occasionally when files are saved unity runs postprocess
                     * multiple times on the same file. */
                    string imported = (importedAssets.Length == 1) ? importedAssets[0] : null;
                    if (imported != null && imported == _lastSingleImportedAsset)
                    {
                        //If here then the file is the same. Make sure it's already in the collection before returning.
                        System.Type assetType = AssetDatabase.GetMainAssetTypeAtPath(imported);
                        //Not a gameObject, no reason to continue.
                        if (assetType != typeof(GameObject))
                            return;

                        NetworkObject nob = AssetDatabase.LoadAssetAtPath<NetworkObject>(imported);
                        //If is a networked object.
                        if (nob != null)
                        {
                            //Already added!
                            if (prefabCollection.Prefabs.Contains(nob))
                                return;
                        }
                    }
                    else if (imported != null)
                    {
                        _lastSingleImportedAsset = imported;
                    }
                }

                bool fullRebuild = settings.FullRebuild;
                /* If updating FN. This needs to be done a better way.
                 * Parsing the actual version file would be better. 
                 * I'll get to it next release. */
                if (!_ranOnce)
                {
                    _ranOnce = true;
                    fullRebuild = true;
                }
                else
                {
                    CheckForVersionFile(importedAssets);
                    CheckForVersionFile(deletedAssets);
                    CheckForVersionFile(movedAssets);
                    CheckForVersionFile(movedFromAssetPaths);
                }

                /* See if any of the changed files are the version file.
                * A new version file suggests an update. Granted, this could occur if
                * other assets imported a new version file as well but better
                * safe than sorry. */
                void CheckForVersionFile(string[] arr)
                {
                    string targetText = "VERSION.txt".ToLower();
                    int targetLength = targetText.Length;

                    for (int i = 0; i < arr.Length; i++)
                    {
                        string item = arr[i];
                        int itemLength = item.Length;
                        if (itemLength < targetLength)
                            continue;

                        item = item.ToLower();
                        int startIndex = (itemLength - targetLength);
                        if (item.Substring(startIndex, targetLength) == targetText)
                        {
                            fullRebuild = true;
                            return;
                        }
                    }
                }

                if (fullRebuild)
                    GenerateFull(settings);
                else
                    GenerateChanged(importedAssets, deletedAssets, movedAssets, movedFromAssetPaths, settings);
            }
        }
    }
}

#endif

'''
'''--- Assets/FishNet/Runtime/Editor/PrefabCollectionGenerator/Settings.cs ---
﻿#if UNITY_EDITOR

using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace FishNet.Editing.PrefabCollectionGenerator
{
	internal sealed class Settings
	{
		#region Types.
		public enum SearchScopeType : byte
		{
			EntireProject = 0,
			SpecificFolders = 1
		}
		#endregion

		#region Public.
		/// <summary>
		/// True if prefab generation is enabled.
		/// </summary>
		public bool Enabled;
		/// <summary>
		/// True to rebuild all prefabs during any change. False to only check changed prefabs.
		/// </summary>
		public bool FullRebuild;
		/// <summary>
		/// True to log results to console.
		/// </summary>
		public bool LogToConsole;
		/// <summary>
		/// True to automatically save assets when default prefabs change.
		/// </summary>
		public bool SaveChanges;
		/// <summary>
		/// Path where prefabs file is created.
		/// </summary>
		public string AssetPath;
		/// <summary>
		/// How to search for files.
		/// </summary>
		public SearchScopeType SearchScope = SearchScopeType.EntireProject;
		/// <summary>
		/// Folders to exclude when using SearchScopeType.SpecificFolders.
		/// </summary>
		public List<string> ExcludedFolders = new List<string>();
		/// <summary>
		/// Folders to include when using SearchScopeType.SpecificFolders.
		/// </summary>
		public List<string> IncludedFolders = new List<string>();
		#endregion

		#region Private.
		/// <summary>
		/// Library folder for project. Presumably where files are saved, but this is changing. This is going away in favor of FN config. //fnconfig.
		/// </summary>
		private static string DirectoryPath => Path.Combine(Path.GetDirectoryName(Application.dataPath), "Library");
		/// <summary>
		/// Full path of settings file. This is going away in favor of FN config. //fnconfig.
		/// </summary>
		private static string FilePath => Path.Combine(DirectoryPath, $"FishNet.Runtime.Editor.PrefabObjects.Generation.{nameof(Settings)}.json");
        #endregion

        public Settings()
		{
			Enabled = true;
			LogToConsole = true;
			FullRebuild = false;
			SaveChanges = true;
			SearchScope = SearchScopeType.EntireProject;

			AssetPath = $"Assets{Path.DirectorySeparatorChar}FishNet{Path.DirectorySeparatorChar}Runtime{Path.DirectorySeparatorChar}DefaultPrefabObjects.asset";
		}

		public void Save()
		{
			//Create save folder if it doesn't exist. This is going away in favor of FN config. //fnconfig.
			if (!Directory.Exists(DirectoryPath))
				Directory.CreateDirectory(DirectoryPath);

			File.WriteAllText(FilePath, JsonUtility.ToJson(this));
		}

		public static Settings Load()
		{
			try
			{
				if (File.Exists(FilePath))
					return JsonUtility.FromJson<Settings>(File.ReadAllText(FilePath));
			}
			catch (Exception ex)
			{
				Debug.LogError($"An error has occurred when loading the prefab collection generator settings: {ex}");
			}

			return new Settings();
		}
	}
}

#endif
'''
'''--- Assets/FishNet/Runtime/Editor/PrefabCollectionGenerator/SettingsProvider.cs ---
﻿#if UNITY_EDITOR

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

using UnitySettingsProviderAttribute = UnityEditor.SettingsProviderAttribute;
using UnitySettingsProvider = UnityEditor.SettingsProvider;

namespace FishNet.Editing.PrefabCollectionGenerator
{
    internal static class SettingsProvider
    {
        private static readonly Regex SlashRegex = new Regex(@"[\\//]");

        private static Settings _settings;

        private static GUIContent _folderIcon;
        private static GUIContent _deleteIcon;

        private static Vector2 _scrollVector;

        private static bool _showFolders;

        [UnitySettingsProvider]
        private static UnitySettingsProvider Create()
        {
            return new UnitySettingsProvider("Project/Fish-Networking/Prefab Objects Generator", SettingsScope.Project)
            {
                label = "Prefab Objects Generator",

                guiHandler = OnGUI,

                keywords = new string[]
                {
                    "Fish",
                    "Networking",
                    "Prefab",
                    "Objects",
                    "Generator",
                },
            };
        }

        private static void OnGUI(string searchContext)
        {
            if (_settings == null)
                _settings = Settings.Load();
            if (_folderIcon == null)
                _folderIcon = EditorGUIUtility.IconContent("d_FolderOpened Icon");
            if (_deleteIcon == null)
                _deleteIcon = EditorGUIUtility.IconContent("P4_DeletedLocal");

            EditorGUI.BeginChangeCheck();
            GUIStyle scrollViewStyle = new GUIStyle()
            {
                padding = new RectOffset(10, 10, 10, 10),
            };

            _scrollVector = EditorGUILayout.BeginScrollView(_scrollVector, scrollViewStyle);

            _settings.Enabled = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.Enabled)), _settings.Enabled);
            _settings.LogToConsole = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.LogToConsole)), _settings.LogToConsole);
            _settings.FullRebuild = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.FullRebuild)), _settings.FullRebuild);
            _settings.SaveChanges = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.SaveChanges)), _settings.SaveChanges);

            GUILayoutOption iconWidthConstraint = GUILayout.MaxWidth(32.0f);
            GUILayoutOption iconHeightConstraint = GUILayout.MaxHeight(EditorGUIUtility.singleLineHeight);

            EditorGUILayout.BeginHorizontal();

            string oldAssetPath = _settings.AssetPath;
            string newAssetPath = EditorGUILayout.DelayedTextField(ObjectNames.NicifyVariableName(nameof(_settings.AssetPath)), oldAssetPath);

            if (GUILayout.Button(_folderIcon, iconWidthConstraint, iconHeightConstraint))
            {
                if (TrySaveFilePathInsideAssetsFolder(null, Application.dataPath, "DefaultPrefabObjects", "asset", out string result))
                    newAssetPath = result;
                else
                    EditorWindow.focusedWindow.ShowNotification(new GUIContent($"{ObjectNames.NicifyVariableName(nameof(_settings.AssetPath))} must be inside the Assets folder."));
            }

            if (!newAssetPath.Equals(oldAssetPath, StringComparison.OrdinalIgnoreCase))
            {
                if (newAssetPath.StartsWith($"Assets{Path.DirectorySeparatorChar}", StringComparison.OrdinalIgnoreCase))
                {
                    if (File.Exists(newAssetPath))
                    {
                        EditorWindow.focusedWindow.ShowNotification(new GUIContent("Another asset already exists at the new path."));
                    }
                    else
                    {
                        Generator.IgnorePostProcess = true;

                        if (File.Exists(oldAssetPath))
                            AssetDatabase.MoveAsset(oldAssetPath, newAssetPath);
                        _settings.AssetPath = newAssetPath;

                        Generator.IgnorePostProcess = false;
                    }
                }
                else
                {
                    EditorWindow.focusedWindow.ShowNotification(new GUIContent($"{ObjectNames.NicifyVariableName(nameof(_settings.AssetPath))} must be inside the Assets folder."));
                }
            }

            EditorGUILayout.EndHorizontal();

            _settings.SearchScope = (Settings.SearchScopeType)EditorGUILayout.EnumPopup(ObjectNames.NicifyVariableName(nameof(_settings.SearchScope)), _settings.SearchScope);
            if (_settings.SearchScope == Settings.SearchScopeType.EntireProject)
            {
                EditorGUILayout.HelpBox("Searching the entire project for prefabs can become very slow. Consider switching the search scope to specific folders instead.", MessageType.Warning);

                if (GUILayout.Button("Switch"))
                    _settings.SearchScope = Settings.SearchScopeType.SpecificFolders;
            }

            List<string> folders = null;
            string foldersName = null;

            if (_settings.SearchScope == Settings.SearchScopeType.EntireProject)
            {
                folders = _settings.ExcludedFolders;
                foldersName = ObjectNames.NicifyVariableName(nameof(_settings.ExcludedFolders));
            }
            else if (_settings.SearchScope == Settings.SearchScopeType.SpecificFolders)
            {
                folders = _settings.IncludedFolders;
                foldersName = ObjectNames.NicifyVariableName(nameof(_settings.IncludedFolders));
            }

            string folderName = foldersName.Substring(0, foldersName.Length - 1);

            if ((_showFolders = EditorGUILayout.Foldout(_showFolders, $"{foldersName} ({folders.Count})")) && folders != null)
            {
                EditorGUI.indentLevel++;

                for (int i = 0; i < folders.Count; i++)
                {
                    EditorGUILayout.BeginHorizontal();

                    string oldFolder = folders[i];
                    string newFolder = SlashRegex.Replace(EditorGUILayout.DelayedTextField(oldFolder), Path.DirectorySeparatorChar.ToString());
                    if (!newFolder.Equals(oldFolder, StringComparison.OrdinalIgnoreCase))
                    {
                        if (newFolder.StartsWith($"Assets{Path.DirectorySeparatorChar}", StringComparison.OrdinalIgnoreCase))
                            folders[i] = newFolder;
                        else
                            EditorWindow.focusedWindow.ShowNotification(new GUIContent($"{folderName} must be inside the Assets folder."));
                    }

                    if (GUILayout.Button(_folderIcon, iconWidthConstraint, iconHeightConstraint))
                    {
                        if (TryOpenFolderPathInsideAssetsFolder(null, Application.dataPath, null, out string result))
                            folders[i] = result;
                        else
                            EditorWindow.focusedWindow.ShowNotification(new GUIContent($"{folderName} must be inside the Assets folder."));
                    }

                    if (GUILayout.Button(_deleteIcon, iconWidthConstraint, iconHeightConstraint)) folders.RemoveAt(i);

                    EditorGUILayout.EndHorizontal();
                }

                EditorGUI.indentLevel--;

                if (_settings.SearchScope == Settings.SearchScopeType.SpecificFolders) EditorGUILayout.HelpBox("You can include subfolders by appending an asterisk (*) to a path.", MessageType.None);

                if (GUILayout.Button("Browse"))
                {
                    if (TryOpenFolderPathInsideAssetsFolder(null, Application.dataPath, null, out string result))
                    {
                        folders.Add(result);
                    }
                    else
                    {
                        EditorWindow.focusedWindow.ShowNotification(new GUIContent($"{folderName} must be inside the Assets folder."));
                    }
                }
            }

            if (EditorGUI.EndChangeCheck())
                _settings.Save();
            if (GUILayout.Button("Generate"))
                Generator.GenerateFull();

            EditorGUILayout.HelpBox("Consider pressing 'Generate' after changing the settings.", MessageType.Info);

            EditorGUILayout.EndScrollView();
        }

        private static bool TrySaveFilePathInsideAssetsFolder(string title, string directory, string name, string extension, out string result)
        {
            result = null;

            string selectedPath = EditorUtility.SaveFilePanel(title, directory, name, extension);

            if (selectedPath.StartsWith(Application.dataPath, StringComparison.OrdinalIgnoreCase))
            {
                result = SlashRegex.Replace(selectedPath.Remove(0, Path.GetDirectoryName(Application.dataPath).Length + 1), Path.DirectorySeparatorChar.ToString());

                return true;
            }

            return false;
        }

        private static bool TryOpenFolderPathInsideAssetsFolder(string title, string folder, string name, out string result)
        {
            result = null;

            string selectedPath = EditorUtility.OpenFolderPanel(title, folder, name);

            if (selectedPath.StartsWith(Application.dataPath, StringComparison.OrdinalIgnoreCase))
            {
                result = SlashRegex.Replace(selectedPath.Remove(0, Path.GetDirectoryName(Application.dataPath).Length + 1), Path.DirectorySeparatorChar.ToString());

                return true;
            }

            return false;
        }
    }
}

#endif
'''
'''--- Assets/FishNet/Runtime/Editor/PrefabProcessor.cs ---
//#if UNITY_EDITOR
//using FishNet.Managing.Object;
//using FishNet.Object;
//using UnityEditor;
//using UnityEngine;

//namespace FishNet.Editing
//{
//    internal class PrefabProcessor : AssetPostprocessor
//    {
//        #region Private.   
//        /// <summary>
//        /// ScriptableObject to store default prefabs.
//        /// </summary>
//        private static DefaultPrefabObjects _defaultPrefabs;
//        #endregion

//        /// <summary>
//        /// Called after assets are created or imported.
//        /// </summary>
//        /// <param name="importedAssets"></param>
//        /// <param name="deletedAssets"></param>
//        /// <param name="movedAssets"></param>
//        /// <param name="movedFromAssetPaths"></param>
//#if UNITY_2021_3_OR_NEWER
//        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths, bool didDomainReload)
//#else
//        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
//#endif
//        {

//#if UNITY_2021_3_OR_NEWER
//            if (didDomainReload)
//                return;
//#endif
//            bool justPopulated;
//            if (_defaultPrefabs == null)
//                _defaultPrefabs = DefaultPrefabsFinder.GetDefaultPrefabsFile(out justPopulated);
//            else
//                justPopulated = DefaultPrefabsFinder.PopulateDefaultPrefabs();
//            //Not found.
//            if (_defaultPrefabs == null)
//                return;

//            //True if null must be removed as well.
//            bool removeNull = (deletedAssets.Length > 0 || movedAssets.Length > 0 || movedFromAssetPaths.Length > 0);
//            if (removeNull)
//                _defaultPrefabs.RemoveNull();

//            /* Only need to add new prefabs if not justPopulated.
//            * justPopulated would have already picked up the new prefabs. */
//            if (justPopulated)
//                return;

//            System.Type goType = typeof(UnityEngine.GameObject);
//            foreach (string item in importedAssets)
//            {
//                System.Type assetType = AssetDatabase.GetMainAssetTypeAtPath(item);
//                if (assetType != goType)
//                    continue;

//                GameObject go = (GameObject)AssetDatabase.LoadAssetAtPath(item, typeof(GameObject));
//                //If is a gameobject.
//                if (go != null)
//                {

//                    NetworkObject nob;
//                    //Not a network object.
//                    if (!go.TryGetComponent<NetworkObject>(out nob))
//                        continue;

//                    /* Check for duplicates because adding a component to a prefab will also call this function
//                     * which will result in this function calling multiple times for the same object. */
//                    _defaultPrefabs.AddObject(nob, true);
//                }
//            }

//            EditorUtility.SetDirty(_defaultPrefabs);
//        }

//    }

//}

//#endif
'''
'''--- Assets/FishNet/Runtime/Editor/ScriptingDefines.cs ---
﻿#if UNITY_EDITOR
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace FishNet
{
    internal static class ScriptingDefines
    {
        [InitializeOnLoadMethod]
        public static void AddDefineSymbols()
        {
            string currentDefines = PlayerSettings.GetScriptingDefineSymbolsForGroup(EditorUserBuildSettings.selectedBuildTargetGroup);
            /* Convert current defines into a hashset. This is so we can
             * determine if any of our defines were added. Only save playersettings
             * when a define is added. */
            HashSet<string> definesHs = new HashSet<string>();
            string[] currentArr = currentDefines.Split(';');
            //Add current defines into hs.
            foreach (string item in currentArr)
                definesHs.Add(item);

            string proDefine = "FISHNET_PRO";
            string[] fishNetDefines = new string[]
            {
                "FISHNET",
                
            };
            bool modified = false;
            //Now add FN defines.
            foreach (string item in fishNetDefines)
                modified |= definesHs.Add(item);

            /* Remove pro define if not on pro. This might look a little
             * funny because the code below varies depending on if pro or not. */
            
#pragma warning disable CS0162 // Unreachable code detected
                modified |= definesHs.Remove(proDefine);
#pragma warning restore CS0162 // Unreachable code detected

            if (modified)
            {
                Debug.Log("Added Fish-Networking defines to player settings.");
                string changedDefines = string.Join(";", definesHs);
                PlayerSettings.SetScriptingDefineSymbolsForGroup(EditorUserBuildSettings.selectedBuildTargetGroup, changedDefines);
            }
        }
    }
}
#endif
'''
'''--- Assets/FishNet/Runtime/Generated/Component/NetworkAnimator/Editor/NetworkAnimatorEditor.cs ---
﻿#if UNITY_EDITOR
using FishNet.Editing;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Animations;
using UnityEngine;

namespace FishNet.Component.Animating.Editing
{

    [CustomEditor(typeof(NetworkAnimator), true)]
    [CanEditMultipleObjects]
    public class NetworkAnimatorEditor : Editor
    {
        private SerializedProperty _animator;
        private SerializedProperty _synchronizeInterval;
        private SerializedProperty _smoothFloats;
        private SerializedProperty _clientAuthoritative;
        private SerializedProperty _sendToOwner;
        private RuntimeAnimatorController _lastRuntimeAnimatorController;
        private AnimatorController _lastAnimatorController;

        protected virtual void OnEnable()
        {
            _animator = serializedObject.FindProperty("_animator");

            _synchronizeInterval = serializedObject.FindProperty("_synchronizeInterval");
            _smoothFloats = serializedObject.FindProperty("_smoothFloats");

            _clientAuthoritative = serializedObject.FindProperty("_clientAuthoritative");
            _sendToOwner = serializedObject.FindProperty("_sendToOwner");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            NetworkAnimator na = (NetworkAnimator)target;

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour(na), typeof(NetworkAnimator), false);
            GUI.enabled = true;

            
#pragma warning disable CS0162 // Unreachable code detected
                EditorGUILayout.HelpBox(EditingConstants.PRO_ASSETS_LOCKED_TEXT, MessageType.Warning);
#pragma warning restore CS0162 // Unreachable code detected

            //Animator
            EditorGUILayout.LabelField("Animator", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_animator, new GUIContent("Animator", "The animator component to synchronize."));
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Synchronization Processing.
            EditorGUILayout.LabelField("Synchronization Processing", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_synchronizeInterval, new GUIContent("Synchronize Interval", "How often to synchronize this animator."));
            EditorGUILayout.PropertyField(_smoothFloats, new GUIContent("Smooth Floats", "True to smooth floats on spectators rather than snap to their values immediately. Commonly set to true for smooth blend tree animations."));
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Authority.
            EditorGUILayout.LabelField("Authority", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_clientAuthoritative, new GUIContent("Client Authoritative", "True if using client authoritative movement."));
            if (_clientAuthoritative.boolValue == false)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_sendToOwner, new GUIContent("Synchronize To Owner", "True to synchronize server results back to owner. Typically used when you are sending inputs to the server and are relying on the server response to move the transform."));
                EditorGUI.indentLevel--;
            }
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            DrawParameters(na);

            serializedObject.ApplyModifiedProperties();
        }

        private void DrawParameters(NetworkAnimator na)
        {
            EditorGUILayout.LabelField("* Synchronized Parameters", EditorStyles.boldLabel);

            if (Application.isPlaying)
            {
                EditorGUILayout.HelpBox("This feature can only be configured while out of play mode.", MessageType.Info);
                return;
            }
            if (na == null)
                return;
            Animator animator = na.Animator;
            if (animator == null)
                return;

            RuntimeAnimatorController runtimeController = (animator.runtimeAnimatorController is AnimatorOverrideController aoc) ? aoc.runtimeAnimatorController : animator.runtimeAnimatorController;
            if (runtimeController == null)
            {
                na.IgnoredParameters.Clear();
                return;
            }

            /* If runtime controller changed 
             * or editor controller is null
             * then get new editor controller. */
            if (runtimeController != _lastRuntimeAnimatorController || _lastAnimatorController == null)
                _lastAnimatorController = (AnimatorController)AssetDatabase.LoadAssetAtPath(AssetDatabase.GetAssetPath(runtimeController), typeof(AnimatorController));
            _lastRuntimeAnimatorController = runtimeController;

            Color defaultColor = GUI.backgroundColor;
            float width = Screen.width;
            float spacePerEntry = 125f;
            //Buttons seem to be longer than spacePerEntry. Why, because who knows...
            float extraSpaceJustBecause = 60;
            float spacer = 20f;
            width -= spacer;
            int entriesPerWidth = Mathf.Max(1, Mathf.FloorToInt(width / (spacePerEntry + extraSpaceJustBecause)));

            List<AnimatorControllerParameter> aps = new List<AnimatorControllerParameter>();
            //Create a parameter detail for each parameter that can be synchronized.
            int count = 0;
            foreach (AnimatorControllerParameter item in _lastAnimatorController.parameters)
            {
                count++;
                //Over 240 parameters; who would do this!?
                if (count >= 240)
                    continue;

                aps.Add(item);
            }

            int apsCount = aps.Count;
            for (int i = 0; i < apsCount; i++)
            {
                using (GUILayout.HorizontalScope hs = new GUILayout.HorizontalScope())
                {
                    GUILayout.Space(spacer);
                    int z = 0;
                    while (z < entriesPerWidth && (z + i < apsCount))
                    {
                        //If this z+i would exceed entries then break.
                        if (z + i >= apsCount)
                            break;

                        AnimatorControllerParameter item = aps[i + z];
                        string parameterName = item.name;
                        bool ignored = na.IgnoredParameters.Contains(parameterName);

                        Color c = (ignored) ? Color.gray : Color.green;
                        GUI.backgroundColor = c;
                        if (GUILayout.Button(item.name, GUILayout.Width(spacePerEntry)))
                        {
                            if (Application.isPlaying)
                            {
                                Debug.Log("Synchronized parameters may not be changed while playing.");
                            }
                            else
                            {
                                if (ignored)
                                    na.IgnoredParameters.Remove(parameterName);
                                else
                                    na.IgnoredParameters.Add(parameterName);
                            }
                        }

                        z++;
                    }

                    i += (z - 1);
                }

                GUI.backgroundColor = defaultColor;
            }
        }

    }

}

#endif
'''
'''--- Assets/FishNet/Runtime/Generated/Component/NetworkAnimator/NetworkAnimator.cs ---
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Utility;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Component.Animating
{
    [AddComponentMenu("FishNet/Component/NetworkAnimator")]
    public sealed class NetworkAnimator : NetworkBehaviour
    {
        #region Types.
        private struct StateChange
        {
            /// <summary>
            /// True if a crossfade.
            /// </summary>
            public bool IsCrossfade;
            /// <summary>
            /// Hash to crossfade into.
            /// </summary>  
            public int Hash;
            /// <summary>
            /// True if using FixedTime.
            /// </summary>
            public bool FixedTime;
            /// <summary>
            /// Duration of crossfade.
            /// </summary>
            public float DurationTime;
            /// <summary>
            /// Offset time of crossfade.
            /// </summary>
            public float OffsetTime;
            /// <summary>
            /// Normalized transition time of crossfade.
            /// </summary>
            public float NormalizedTransitionTime;

            public StateChange(int hash, bool fixedTime, float duration, float offset, float normalizedTransition)
            {
                IsCrossfade = true;
                Hash = hash;
                FixedTime = fixedTime;
                DurationTime = duration;
                OffsetTime = offset;
                NormalizedTransitionTime = normalizedTransition;
            }
        }
        /// <summary>
        /// Animator updates received from clients when using Client Authoritative.
        /// </summary>
        private class ClientAuthoritativeUpdate
        {
            /// <summary>
            /// 
            /// </summary>
            public ClientAuthoritativeUpdate()
            {
                //Start buffers off at 8 bytes nad grow them as needed.
                for (int i = 0; i < MAXIMUM_BUFFER_COUNT; i++)
                    _buffers.Add(new byte[MAXIMUM_DATA_SIZE]);

                _bufferLengths = new int[MAXIMUM_BUFFER_COUNT];
            }

            #region Public.
            /// <summary>
            /// True to force all animator data and ignore buffers.
            /// </summary>
            public bool ForceAll { get; private set; }
            /// <summary>
            /// Number of entries in Buffers.
            /// </summary>
            public int BufferCount = 0;
            #endregion

            #region Private.
            /// <summary>
            /// Length of buffers.
            /// </summary>
            private int[] _bufferLengths;
            /// <summary>
            /// Buffers.
            /// </summary>
            private List<byte[]> _buffers = new List<byte[]>();
            #endregion

            #region Const.
            /// <summary>
            /// Maximum size data may be.
            /// </summary>
            private const int MAXIMUM_DATA_SIZE = 1000;
            /// <summary>
            /// Maximum number of allowed buffers.
            /// </summary>
            public const int MAXIMUM_BUFFER_COUNT = 2;
            #endregion

            public void AddToBuffer(ref ArraySegment<byte> data)
            {
                int dataCount = data.Count;
                /* Data will never get this large, it's quite impossible.
                 * Just ignore the data if it does, client is likely performing
                 * an attack. */
                if (dataCount > MAXIMUM_DATA_SIZE)
                    return;

                //If index exceeds buffer count.
                if (BufferCount >= MAXIMUM_BUFFER_COUNT)
                {
                    ForceAll = true;
                    return;
                }

                /* If here, can write to buffer. */
                byte[] buffer = _buffers[BufferCount];

                Buffer.BlockCopy(data.Array, data.Offset, buffer, 0, dataCount);
                _bufferLengths[BufferCount] = dataCount;
                BufferCount++;
            }

            /// <summary>
            /// Sets referenced data to buffer and it's length for index.
            /// </summary>
            /// <param name="index"></param>
            /// <param name="buffer"></param>
            /// <param name="length"></param>
            public void GetBuffer(int index, ref byte[] buffer, ref int length)
            {
                if (index > _buffers.Count)
                {
                    Debug.LogWarning("Index exceeds Buffers count.");
                    return;
                }
                if (index > _bufferLengths.Length)
                {
                    Debug.LogWarning("Index exceeds BufferLengths count.");
                    return;
                }

                buffer = _buffers[index];
                length = _bufferLengths[index];
            }
            /// <summary>
            /// Resets buffers.
            /// </summary>
            public void Reset()
            {
                BufferCount = 0;
                ForceAll = false;
            }

        }
        /// <summary>
        /// Information on how to smooth to a float value.
        /// </summary>
        private struct SmoothedFloat
        {
            public SmoothedFloat(float rate, float target)
            {
                Rate = rate;
                Target = target;
            }

            public readonly float Rate;
            public readonly float Target;
        }

        /// <summary>
        /// Details about a trigger update.
        /// </summary>
        private struct TriggerUpdate
        {
            public byte ParameterIndex;
            public bool Setting;

            public TriggerUpdate(byte parameterIndex, bool setting)
            {
                ParameterIndex = parameterIndex;
                Setting = setting;
            }
        }
        /// <summary>
        /// Details about an animator parameter.
        /// </summary>
        private class ParameterDetail
        {
            /// <summary>
            /// Parameter information.
            /// </summary>
            public readonly AnimatorControllerParameter ControllerParameter = null;
            /// <summary>
            /// Index within the types collection for this parameters value. The exception is with triggers; if the parameter type is a trigger then a value of 1 is set, 0 is unset.
            /// </summary>
            public readonly byte TypeIndex = 0;
            /// <summary>
            /// Hash for the animator string.
            /// </summary>
            public readonly int Hash;

            public ParameterDetail(AnimatorControllerParameter controllerParameter, byte typeIndex)
            {
                ControllerParameter = controllerParameter;
                TypeIndex = typeIndex;
                Hash = controllerParameter.nameHash;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Parameters which will not be synchronized.
        /// Internal use only.
        /// </summary>
        [SerializeField, HideInInspector]
        internal List<string> IgnoredParameters = new List<string>();
        #endregion

        #region Serialized.
        /// <summary>
        /// The animator component to synchronize.
        /// </summary>
        [Tooltip("The animator component to synchronize.")]
        [SerializeField]
        private Animator _animator;
        /// <summary>
        /// The animator component to synchronize.
        /// </summary>
        public Animator Animator { get { return _animator; } }
        /// <summary>
        /// True to smooth float value changes for spectators.
        /// </summary>
        [Tooltip("True to smooth float value changes for spectators.")]
        [SerializeField]
        private bool _smoothFloats = true;
        /// <summary>
        /// How often to synchronize this animator.
        /// </summary>
        [Tooltip("How often to synchronize this animator.")]
        [Range(0.01f, 0.5f)]
        [SerializeField]
        private float _synchronizeInterval = 0.1f;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True if using client authoritative animations.")]
        [SerializeField]
        private bool _clientAuthoritative = true;
        /// <summary>
        /// True if using client authoritative animations.
        /// </summary>
        public bool ClientAuthoritative { get { return _clientAuthoritative; } }
        /// <summary>
        /// True to synchronize server results back to owner. Typically used when you are changing animations on the server and are relying on the server response to update the clients animations.
        /// </summary>
        [Tooltip("True to synchronize server results back to owner. Typically used when you are changing animations on the server and are relying on the server response to update the clients animations.")]
        [SerializeField]
        private bool _sendToOwner;
        #endregion

        #region Private.
        /// <summary>
        /// All parameter values, excluding triggers.
        /// </summary>
        private List<ParameterDetail> _parameterDetails = new List<ParameterDetail>();
        /// <summary>
        /// Last int values.
        /// </summary>
        private List<int> _ints = new List<int>();
        /// <summary>
        /// Last float values.
        /// </summary>
        private List<float> _floats = new List<float>();
        /// <summary>
        /// Last bool values.
        /// </summary>
        private List<bool> _bools = new List<bool>();
        /// <summary>
        /// Last layer weights.
        /// </summary>
        private float[] _layerWeights;
        /// <summary>
        /// Last speed.
        /// </summary>
        private float _speed;
        /// <summary>
        /// Next time client may send parameter updates.
        /// </summary>
        private float _nextClientSendTime = -1f;
        /// <summary>
        /// Next time server may send parameter updates.
        /// </summary>
        private float _nextServerSendTime = -1f;
        /// <summary>
        /// Trigger values set by using SetTrigger and ResetTrigger.
        /// </summary>
        private List<TriggerUpdate> _triggerUpdates = new List<TriggerUpdate>();
        /// <summary>
        /// Updates going to clients.
        /// </summary>
        private List<byte[]> _toClientsBuffer = new List<byte[]>();
        /// <summary>
        /// Returns if the animator is exist and is active.
        /// </summary>
        private bool _isAnimatorEnabled
        {
            get
            {
                bool failedChecks = (_animator == null || !_animator.enabled || _animator.runtimeAnimatorController == null);
                return !failedChecks;
            }
        }
        /// <summary>
        /// Float valeus to smooth towards.
        /// </summary>
        private Dictionary<int, SmoothedFloat> _smoothedFloats = new Dictionary<int, SmoothedFloat>();
        /// <summary>
        /// Returns if floats can be smoothed for this client.
        /// </summary>
        private bool _canSmoothFloats
        {
            get
            {
                //Don't smooth on server only.
                if (!base.IsClient)
                    return false;
                //Smoothing is disabled.
                if (!_smoothFloats)
                    return false;
                //No reason to smooth for self.
                if (base.IsOwner && ClientAuthoritative)
                    return false;

                //Fall through.
                return true;
            }
        }        
        /// <summary>
        /// Layers which need to have their state synchronized. Key is the layer, Value is the state change information.
        /// </summary>
        private Dictionary<int, StateChange> _unsynchronizedLayerStates = new Dictionary<int, StateChange>();
        /// <summary>
        /// Layers which need to have their state blend synchronized. Key is ParameterIndex, Value is next state hash.
        /// </summary>
        //private Dictionary<int, int> _unsynchronizedLayerStates = new HashSet<int>();
        /// <summary>
        /// Last animator set.
        /// </summary>
        private Animator _lastAnimator;
        /// <summary>
        /// Last Controller set.
        /// </summary>
        private RuntimeAnimatorController _lastController;
        /// <summary>
        /// PooledWriter for this animator.
        /// </summary>
        private PooledWriter _writer = new PooledWriter();
        /// <summary>
        /// Holds client authoritative updates received to send to other clients.
        /// </summary>
        private ClientAuthoritativeUpdate _clientAuthoritativeUpdates;
        /// <summary>
        /// True to forceAll next timed send.
        /// </summary>
        private bool _forceAllOnTimed;
        #endregion

        #region Const.
        /// <summary>
        /// How much time to fall behind when using smoothing. Only increase value if the smoothing is sometimes jittery. Recommended values are between 0 and 0.04.
        /// </summary>
        private const float INTERPOLATION = 0.02f;
        /// <summary>
        /// ParameterDetails index which indicates a layer weight change.
        /// </summary>
        private const byte LAYER_WEIGHT = 240;
        /// <summary>
        /// ParameterDetails index which indicates an animator speed change.
        /// </summary>
        private const byte SPEED = 241;
        /// <summary>
        /// ParameterDetails index which indicates a layer state change.
        /// </summary>
        private const byte STATE = 242;
        /// <summary>
        /// ParameterDetails index which indicates a crossfade change.
        /// </summary>
        private const byte CROSSFADE = 243;
        #endregion

        private void Awake()
        {
            InitializeOnce();
        }

        [APIExclude]
        public override void OnSpawnServer(NetworkConnection connection)
        {
            base.OnSpawnServer(connection);
            if (!_isAnimatorEnabled)
                return;
            if (AnimatorUpdated(out ArraySegment<byte> updatedBytes, true))
                TargetAnimatorUpdated(connection, updatedBytes);
        }

        [APIExclude]
        public override void OnStartServer()
        {
            base.OnStartServer();
            //If using client authoritative then initialize clientAuthoritativeUpdates.
            if (_clientAuthoritative)
            {
                _clientAuthoritativeUpdates = new ClientAuthoritativeUpdate();
                //Expand to clients buffer count to however many buffers can be held.
                for (int i = 0; i < ClientAuthoritativeUpdate.MAXIMUM_BUFFER_COUNT; i++)
                    _toClientsBuffer.Add(new byte[0]);
            }
            else
            {
                _toClientsBuffer.Add(new byte[0]);
            }
        }

        private void Update()
        {
            //One check rather than per each method.
            if (!_isAnimatorEnabled)
                return;

            if (base.IsClient)
            {
                CheckSendToServer();
                SmoothFloats();
            }
            if (base.IsServer)
            {
                CheckSendToClients();
            }
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void InitializeOnce()
        {
            if (_animator == null)
                _animator = GetComponent<Animator>();

            //Don't run the rest if not in play mode.
            if (!ApplicationState.IsPlaying())
                return;

            if (!_isAnimatorEnabled)
            {
                //Debug.LogWarning("Animator is null or not enabled; unable to initialize for animator. Use SetAnimator if animator was changed or enable the animator.");
                return;
            }

            //Speed.
            _speed = _animator.speed;

            //Build layer weights.
            _layerWeights = new float[_animator.layerCount];
            for (int i = 0; i < _layerWeights.Length; i++)
                _layerWeights[i] = _animator.GetLayerWeight(i);

            _parameterDetails.Clear();
            _bools.Clear();
            _floats.Clear();
            _ints.Clear();
            //Create a parameter detail for each parameter that can be synchronized.
            foreach (AnimatorControllerParameter item in _animator.parameters)
            {
                bool process = !_animator.IsParameterControlledByCurve(item.name);
                
                if (process)
                {
                    //Over 250 parameters; who would do this!?
                    if (_parameterDetails.Count == 240)
                    {
                        Debug.LogError($"Parameter {item.name} exceeds the allowed 240 parameter count and is being ignored.");
                        continue;
                    }

                    int typeIndex = 0;
                    //Bools.
                    if (item.type == AnimatorControllerParameterType.Bool)
                    {
                        typeIndex = _bools.Count;
                        _bools.Add(_animator.GetBool(item.nameHash));
                    }
                    //Floats.
                    else if (item.type == AnimatorControllerParameterType.Float)
                    {
                        typeIndex = _floats.Count;
                        _floats.Add(_animator.GetFloat(item.name));
                    }
                    //Ints.
                    else if (item.type == AnimatorControllerParameterType.Int)
                    {
                        typeIndex = _ints.Count;
                        _ints.Add(_animator.GetInteger(item.nameHash));
                    }
                    //Triggers.
                    else if (item.type == AnimatorControllerParameterType.Trigger)
                    {
                        /* Triggers aren't persistent so they don't use stored values
                         * but I do need to make a parameter detail to track the hash. */
                        typeIndex = -1;
                    }

                    _parameterDetails.Add(new ParameterDetail(item, (byte)typeIndex));
                }
            }
        }

        /// <summary>
        /// Sets which animator to use. You must call this with the appropriate animator on all clients and server. This change is not automatically synchronized.
        /// </summary>
        /// <param name="animator"></param>
        public void SetAnimator(Animator animator)
        {
            //No update required.
            if (animator == _lastAnimator)
                return;

            _animator = animator;
            InitializeOnce();
            _lastAnimator = animator;
        }

        /// <summary>
        /// Sets which controller to use. You must call this with the appropriate controller on all clients and server. This change is not automatically synchronized.
        /// </summary>
        /// <param name="controller"></param>        
        public void SetController(RuntimeAnimatorController controller)
        {
            //No update required.
            if (controller == _lastController)
                return;

            _animator.runtimeAnimatorController = controller;
            InitializeOnce();
            _lastController = controller;
        }

        /// <summary>
        /// Checks to send animator data from server to clients.
        /// </summary>
        private void CheckSendToServer()
        {
            //Cannot send to server if is server or not client.
            if (base.IsServer || !base.IsClient)
                return;
            //Cannot send to server if not client authoritative or don't have authority.
            if (!ClientAuthoritative || !base.IsOwner)
                return;
            //Not enough time passed to send.
            if (Time.time < _nextClientSendTime)
                return;
            _nextClientSendTime = Time.time + _synchronizeInterval;

            /* If there are updated parameters to send.
             * Don't really need to worry about mtu here
             * because there's no way the sent bytes are
             * ever going to come close to the mtu
             * when sending a single update. */
            if (AnimatorUpdated(out ArraySegment<byte> updatedBytes, _forceAllOnTimed))
                ServerAnimatorUpdated(updatedBytes);

            _forceAllOnTimed = false;
        }

        /// <summary>
        /// Checks to send animator data from server to clients.
        /// </summary>
        private void CheckSendToClients()
        {
            //Cannot send to clients if not server.
            if (!base.IsServer)
                return;
            //Not enough time passed to send.
            if (Time.time < _nextServerSendTime)
                return;
            _nextServerSendTime = Time.time + _synchronizeInterval;

            bool sendFromServer;
            //If client authoritative.
            if (ClientAuthoritative)
            {
                //If has no owner then use latest values on server.
                if (!base.Owner.IsValid)
                {
                    sendFromServer = true;
                }
                //If has a owner.
                else
                {
                    //If is owner then send latest values on server.
                    if (base.IsOwner)
                    {
                        sendFromServer = true;
                    }
                    //Not owner.
                    else
                    {
                        //Haven't received any data from clients, cannot send yet.
                        if (_clientAuthoritativeUpdates.BufferCount == 0)
                        {
                            return;
                        }
                        //Data was received from client; check eligibility to send it.
                        else
                        {
                            /* If forceAll is true then the latest values on
                             * server must be used, rather than what was received
                             * from client. This can occur if the client is possibly
                             * trying to use an attack or if the client is
                             * excessively sending updates. To prevent relaying that
                             * same data to others the server will send it's current
                             * animator settings in this scenario. */
                            if (_clientAuthoritativeUpdates.ForceAll)
                            {
                                sendFromServer = true;
                                _clientAuthoritativeUpdates.Reset();
                            }
                            else
                            {
                                sendFromServer = false;
                            }
                        }
                    }
                }
            }
            //Not client authoritative, always send from server.
            else
            {
                sendFromServer = true;
            }

            /* If client authoritative then use what was received from clients
             * if data exist. */
            if (!sendFromServer)
            {
                byte[] buffer = null;
                int bufferLength = 0;
                for (int i = 0; i < _clientAuthoritativeUpdates.BufferCount; i++)
                {
                    _clientAuthoritativeUpdates.GetBuffer(i, ref buffer, ref bufferLength);

                    //If null was returned then something went wrong.
                    if (buffer == null || bufferLength == 0)
                        continue;

                    ObserversAnimatorUpdated(new ArraySegment<byte>(buffer, 0, bufferLength));
                }
                //Reset client auth buffer.
                _clientAuthoritativeUpdates.Reset();
            }
            //Sending from server, send what's changed.
            else
            {
                if (AnimatorUpdated(out ArraySegment<byte> updatedBytes, _forceAllOnTimed))
                    ObserversAnimatorUpdated(updatedBytes);

                _forceAllOnTimed = false;
            }
        }

        /// <summary>
        /// Smooths floats on clients.
        /// </summary>
        private void SmoothFloats()
        {
            //Don't need to smooth on authoritative client.
            if (!_canSmoothFloats)
                return;
            //Nothing to smooth.
            if (_smoothedFloats.Count == 0)
                return;

            float deltaTime = Time.deltaTime;

            List<int> finishedEntries = new List<int>();

            /* Cycle through each target float and move towards it.
                * Once at a target float mark it to be removed from floatTargets. */
            foreach (KeyValuePair<int, SmoothedFloat> item in _smoothedFloats)
            {
                float current = _animator.GetFloat(item.Key);
                float next = Mathf.MoveTowards(current, item.Value.Target, item.Value.Rate * deltaTime);
                _animator.SetFloat(item.Key, next);

                if (next == item.Value.Target)
                    finishedEntries.Add(item.Key);
            }

            //Remove finished entries from dictionary.
            for (int i = 0; i < finishedEntries.Count; i++)
                _smoothedFloats.Remove(finishedEntries[i]);
        }

        /// <summary>
        /// Returns if animator is updated and bytes of updated values.
        /// </summary>
        /// <returns></returns>
        private bool AnimatorUpdated(out ArraySegment<byte> updatedBytes, bool forceAll = false)
        {
            updatedBytes = default;
            //Something isn't setup right.
            if (_layerWeights == null)
                return false;
            //Reset the writer.
            _writer.Reset();

            /* Every time a parameter is updated a byte is added
             * for it's index, this is why requiredBytes increases
             * by 1 when a value updates. ChangedParameter contains
             * the index updated and the new value. The requiresBytes
             * is increased also by however many bytes are required
             * for the type which has changed. Some types use special parameter
             * detail indexes, such as layer weights; these can be found under const. */
            for (byte parameterIndex = 0; parameterIndex < _parameterDetails.Count; parameterIndex++)
            {
                ParameterDetail pd = _parameterDetails[parameterIndex];
                /* Bool. */
                if (pd.ControllerParameter.type == AnimatorControllerParameterType.Bool)
                {
                    bool next = _animator.GetBool(pd.Hash);
                    //If changed.
                    if (forceAll || _bools[pd.TypeIndex] != next)
                    {
                        _writer.WriteByte(parameterIndex);
                        _writer.WriteBoolean(next);
                        _bools[pd.TypeIndex] = next;
                    }
                }
                /* Float. */
                else if (pd.ControllerParameter.type == AnimatorControllerParameterType.Float)
                {
                    float next = _animator.GetFloat(pd.Hash);
                    //If changed.
                    if (forceAll || _floats[pd.TypeIndex] != next)
                    {
                        _writer.WriteByte(parameterIndex);
                        _writer.WriteSingle(next, AutoPackType.Packed);
                        _floats[pd.TypeIndex] = next;
                    }
                }
                /* Int. */
                else if (pd.ControllerParameter.type == AnimatorControllerParameterType.Int)
                {
                    int next = _animator.GetInteger(pd.Hash);
                    //If changed.
                    if (forceAll || _ints[pd.TypeIndex] != next)
                    {
                        _writer.WriteByte(parameterIndex);
                        _writer.WriteInt32(next, AutoPackType.Packed);
                        _ints[pd.TypeIndex] = next;
                    }
                }
            }

            /* Don't need to force trigger sends since
             * they're one-shots. */
            for (int i = 0; i < _triggerUpdates.Count; i++)
            {
                _writer.WriteByte(_triggerUpdates[i].ParameterIndex);
                _writer.WriteBoolean(_triggerUpdates[i].Setting);
            }
            _triggerUpdates.Clear();

            /* States. */
            if (forceAll)
            {
                //Add all layers to layer states.
                for (int i = 0; i < _animator.layerCount; i++)
                    _unsynchronizedLayerStates[i] = new StateChange();
            }

            //Go through each layer which needs to be synchronized.
            foreach (KeyValuePair<int, StateChange> item in _unsynchronizedLayerStates)
            {
                int layerIndex = item.Key;
                StateChange sc = item.Value;
                //If a regular state change.
                if (!sc.IsCrossfade)
                {
                    if (ReturnCurrentLayerState(out int stateHash, out float normalizedTime, layerIndex))
                    {
                        _writer.WriteByte(STATE);
                        _writer.WriteByte((byte)layerIndex);
                        //Current hash will always be too large to compress.
                        _writer.WriteInt32(stateHash);
                        _writer.WriteSingle(normalizedTime, AutoPackType.Packed);
                    }
                }
                //When it's a crossfade then send crossfade data.
                else
                {
                    _writer.WriteByte(CROSSFADE);
                    _writer.WriteByte((byte)layerIndex);
                    //Current hash will always be too large to compress.
                    _writer.WriteInt32(sc.Hash);
                    _writer.WriteBoolean(sc.FixedTime);
                    //Times usually can be compressed.
                    _writer.WriteSingle(sc.DurationTime, AutoPackType.Packed);
                    _writer.WriteSingle(sc.OffsetTime, AutoPackType.Packed);
                    _writer.WriteSingle(sc.NormalizedTransitionTime, AutoPackType.Packed);
                }
            }
            _unsynchronizedLayerStates.Clear();

            /* Layer weights. */
            for (int layerIndex = 0; layerIndex < _layerWeights.Length; layerIndex++)
            {
                float next = _animator.GetLayerWeight(layerIndex);
                if (forceAll || _layerWeights[layerIndex] != next)
                {
                    _writer.WriteByte(LAYER_WEIGHT);
                    _writer.WriteByte((byte)layerIndex);
                    _writer.WriteSingle(next, AutoPackType.Packed);
                    _layerWeights[layerIndex] = next;
                }
            }

            /* Speed is similar to layer weights but we don't need the index,
             * only the indicator and value. */
            float speedNext = _animator.speed;
            if (forceAll || _speed != speedNext)
            {
                _writer.WriteByte(SPEED);
                _writer.WriteSingle(speedNext, AutoPackType.Packed);
                _speed = speedNext;
            }

            //Nothing to update.
            if (_writer.Position == 0)
            {
                return false;
            }
            else
            {
                updatedBytes = _writer.GetArraySegment();
                return true;
            }
        }

        /// <summary>
        /// Applies changed parameters to the animator.
        /// </summary>
        /// <param name="changedParameters"></param>
        private void ApplyParametersUpdated(ref ArraySegment<byte> updatedParameters)
        {
            if (!_isAnimatorEnabled)
                return;
            if (_layerWeights == null)
                return;
            if (updatedParameters.Count == 0)
                return;
            //Exit if client authoritative and has authority.
            if (ClientAuthoritative && base.IsOwner)
                return;
            //Exit if not client authoritative, but also not sync to owner, and is owner.
            if (!ClientAuthoritative && !_sendToOwner && base.IsOwner)
                return;
            //Exit if trying to apply when server and not client authoritative.
            if (base.IsServer && !ClientAuthoritative)
                return;

            try
            {
                using (PooledReader reader = ReaderPool.GetReader(updatedParameters, base.NetworkManager))
                {
                    while (reader.Remaining > 0)
                    {
                        byte parameterIndex = reader.ReadByte();
                        //Layer weight
                        if (parameterIndex == LAYER_WEIGHT)
                        {
                            byte layerIndex = reader.ReadByte();
                            float value = reader.ReadSingle(AutoPackType.Packed);
                            _animator.SetLayerWeight((int)layerIndex, value);
                        }
                        //Speed.
                        else if (parameterIndex == SPEED)
                        {
                            float value = reader.ReadSingle(AutoPackType.Packed);
                            _animator.speed = value;
                        }
                        //State.
                        else if (parameterIndex == STATE)
                        {
                            byte layerIndex = reader.ReadByte();
                            //Hashes will always be too large to compress.
                            int hash = reader.ReadInt32();
                            float normalizedTime = reader.ReadSingle(AutoPackType.Packed);
                            //Play results.
                            _animator.Play(hash, layerIndex, normalizedTime);
                        }
                        //Crossfade.
                        else if (parameterIndex == CROSSFADE)
                        {
                            byte layerIndex = reader.ReadByte();
                            //Hashes will always be too large to compress.
                            int hash = reader.ReadInt32();
                            bool useFixedTime = reader.ReadBoolean();
                            //Get time values.
                            float durationTime = reader.ReadSingle(AutoPackType.Packed);
                            float offsetTime = reader.ReadSingle(AutoPackType.Packed);
                            float normalizedTransitionTime = reader.ReadSingle(AutoPackType.Packed);
                            //If using fixed.
                            if (useFixedTime)
                                _animator.CrossFadeInFixedTime(hash, durationTime, layerIndex, offsetTime, normalizedTransitionTime);
                            else
                                _animator.CrossFade(hash, durationTime, layerIndex, offsetTime, normalizedTransitionTime);
                        }
                        //Not a predetermined index, is an actual parameter.
                        else
                        {
                            AnimatorControllerParameterType acpt = _parameterDetails[parameterIndex].ControllerParameter.type;
                            if (acpt == AnimatorControllerParameterType.Bool)
                            {
                                bool value = reader.ReadBoolean();
                                _animator.SetBool(_parameterDetails[parameterIndex].Hash, value);
                            }
                            //Float.
                            else if (acpt == AnimatorControllerParameterType.Float)
                            {
                                float value = reader.ReadSingle(AutoPackType.Packed);
                                //If able to smooth floats.
                                if (_canSmoothFloats)
                                {
                                    float currentValue = _animator.GetFloat(_parameterDetails[parameterIndex].Hash);
                                    float past = _synchronizeInterval + INTERPOLATION;
                                    float rate = Mathf.Abs(currentValue - value) / past;
                                    _smoothedFloats[_parameterDetails[parameterIndex].Hash] = new SmoothedFloat(rate, value);
                                }
                                else
                                {
                                    _animator.SetFloat(_parameterDetails[parameterIndex].Hash, value);
                                }
                            }
                            //Integer.
                            else if (acpt == AnimatorControllerParameterType.Int)
                            {
                                int value = reader.ReadInt32();
                                _animator.SetInteger(_parameterDetails[parameterIndex].Hash, value);
                            }
                            //Trigger.
                            else if (acpt == AnimatorControllerParameterType.Trigger)
                            {
                                bool value = reader.ReadBoolean();
                                if (value)
                                    _animator.SetTrigger(_parameterDetails[parameterIndex].Hash);
                                else
                                    _animator.ResetTrigger(_parameterDetails[parameterIndex].Hash);
                            }
                            //Unhandled.
                            else
                            {
                                Debug.LogWarning($"Unhandled parameter type of {acpt}.");
                            }
                        }
                    }
                }
            }
            catch
            {
                Debug.LogWarning("An error occurred while applying updates. This may occur when malformed data is sent or when you change the animator or controller but not on all connections.");
            }
        }

        /// <summary>
        /// Outputs the current state and time for a layer. Returns true if stateHash is not 0.
        /// </summary>
        /// <param name="stateHash"></param>
        /// <param name="normalizedTime"></param>
        /// <param name="results"></param>
        /// <param name="layerIndex"></param>
        /// <returns></returns>
        private bool ReturnCurrentLayerState(out int stateHash, out float normalizedTime, int layerIndex)
        {
            stateHash = 0;
            normalizedTime = 0f;

            if (!_isAnimatorEnabled)
                return false;

            AnimatorStateInfo st = _animator.GetCurrentAnimatorStateInfo(layerIndex);
            stateHash = st.fullPathHash;
            normalizedTime = st.normalizedTime;

            return (stateHash != 0);
        }

        /// <summary>
        /// Forces values to send next update regardless of time remaining.
        /// Can be useful if you have a short lasting parameter that you want to ensure goes through.
        /// </summary>
        public void ForceSend()
        {
            _nextClientSendTime = 0f;
            _nextServerSendTime = 0f;
        }

        /// <summary>
        /// Immediately sends all variables and states of layers.
        /// This is a very bandwidth intensive operation.
        /// </summary>
        public void SendAll()
        {
            _forceAllOnTimed = true;
            ForceSend();
        }

        #region Play.
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(string name)
        {
            Play(Animator.StringToHash(name));
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(int hash)
        {
            for (int i = 0; i < _animator.layerCount; i++)
                Play(hash, i, 0f);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(string name, int layer)
        {
            Play(Animator.StringToHash(name), layer);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(int hash, int layer)
        {
            Play(hash, layer, 0f);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(string name, int layer, float normalizedTime)
        {
            Play(Animator.StringToHash(name), layer, normalizedTime);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(int hash, int layer, float normalizedTime)
        {
            if (!_isAnimatorEnabled)
                return;
            if (_animator.HasState(layer, hash))
            {
                _animator.Play(hash, layer, normalizedTime);
                _unsynchronizedLayerStates[layer] = new StateChange();
            }
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void PlayInFixedTime(string name, float fixedTime)
        {
            PlayInFixedTime(Animator.StringToHash(name), fixedTime);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void PlayInFixedTime(int hash, float fixedTime)
        {
            for (int i = 0; i < _animator.layerCount; i++)
                PlayInFixedTime(hash, i, fixedTime);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void PlayInFixedTime(string name, int layer, float fixedTime)
        {
            PlayInFixedTime(Animator.StringToHash(name), layer, fixedTime);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void PlayInFixedTime(int hash, int layer, float fixedTime)
        {
            if (!_isAnimatorEnabled)
                return;
            if (_animator.HasState(layer, hash))
            {
                _animator.PlayInFixedTime(hash, layer, fixedTime);
                _unsynchronizedLayerStates[layer] = new StateChange();
            }
        }
        #endregion

        #region Crossfade.
        /// <summary>
        /// Creates a crossfade from the current state to any other state using normalized times.
        /// </summary>
        /// <param name="stateName"></param>
        /// <param name="normalizedTransitionDuration"></param>
        /// <param name="layer"></param>
        /// <param name="normalizedTimeOffset"></param>
        /// <param name="normalizedTransitionTime"></param>
        public void CrossFade(string stateName, float normalizedTransitionDuration, int layer, float normalizedTimeOffset = float.NegativeInfinity, float normalizedTransitionTime = 0.0f)
        {
            CrossFade(Animator.StringToHash(stateName), normalizedTransitionDuration, layer, normalizedTimeOffset, normalizedTransitionTime);
        }
        /// <summary>
        /// Creates a crossfade from the current state to any other state using normalized times.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="normalizedTransitionDuration"></param>
        /// <param name="layer"></param>
        /// <param name="normalizedTimeOffset"></param>
        /// <param name="normalizedTransitionTime"></param>
        public void CrossFade(int hash, float normalizedTransitionDuration, int layer, float normalizedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f)
        {
            if (!_isAnimatorEnabled)
                return;
            if (_animator.HasState(layer, hash))
            {
                _animator.CrossFade(hash, normalizedTransitionDuration, layer, normalizedTimeOffset, normalizedTransitionTime);
                _unsynchronizedLayerStates[layer] = new StateChange(hash, false, normalizedTransitionDuration, normalizedTimeOffset, normalizedTransitionTime);
            }
        }
        /// <summary>
        /// Creates a crossfade from the current state to any other state using times in seconds.
        /// </summary>
        /// <param name="stateName"></param>
        /// <param name="fixedTransitionDuration"></param>
        /// <param name="layer"></param>
        /// <param name="fixedTimeOffset"></param>
        /// <param name="normalizedTransitionTime"></param>
        public void CrossFadeInFixedTime(string stateName, float fixedTransitionDuration, int layer, float fixedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f)
        {
            CrossFadeInFixedTime(Animator.StringToHash(stateName), fixedTransitionDuration, layer, fixedTimeOffset, normalizedTransitionTime);
        }
        /// <summary>
        /// Creates a crossfade from the current state to any other state using times in seconds.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="fixedTransitionDuration"></param>
        /// <param name="layer"></param>
        /// <param name="fixedTimeOffset"></param>
        /// <param name="normalizedTransitionTime"></param>
        public void CrossFadeInFixedTime(int hash, float fixedTransitionDuration, int layer, float fixedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f)
        {
            if (!_isAnimatorEnabled)
                return;
            if (_animator.HasState(layer, hash))
            {
                _animator.CrossFadeInFixedTime(hash, fixedTransitionDuration, layer, fixedTimeOffset, normalizedTransitionTime);
                _unsynchronizedLayerStates[layer] = new StateChange(hash, true, fixedTransitionDuration, fixedTimeOffset, normalizedTransitionTime);
            }
        }
        #endregion

        #region Triggers.
        /// <summary>
        /// Sets a trigger on the animator and sends it over the network.
        /// </summary>
        /// <param name="hash"></param>
        public void SetTrigger(int hash)
        {
            if (!_isAnimatorEnabled)
                return;
            UpdateTrigger(hash, true);
        }
        /// <summary>
        /// Sets a trigger on the animator and sends it over the network.
        /// </summary>
        /// <param name="hash"></param>
        public void SetTrigger(string name)
        {
            SetTrigger(Animator.StringToHash(name));
        }

        /// <summary>
        /// Resets a trigger on the animator and sends it over the network.
        /// </summary>
        /// <param name="hash"></param>
        public void ResetTrigger(int hash)
        {
            UpdateTrigger(hash, false);
        }
        /// <summary>
        /// Resets a trigger on the animator and sends it over the network.
        /// </summary>
        /// <param name="hash"></param>
        public void ResetTrigger(string name)
        {
            ResetTrigger(Animator.StringToHash(name));
        }

        /// <summary>
        /// Updates a trigger, sets or resets.
        /// </summary>
        /// <param name="set"></param>
        private void UpdateTrigger(int hash, bool set)
        {
            if (!_isAnimatorEnabled)
                return;
            /* Allow triggers to run on owning client if using client authority,
             * as well when not using client authority but also not using synchronize to owner.
             * This allows clients to run animations locally while maintaining server authority. */
            //Using client authority but not owner.
            if (ClientAuthoritative && !base.IsOwner)
                return;

            //Also block if not using client authority, synchronizing to owner, and not server.
            if (!ClientAuthoritative && _sendToOwner && !base.IsServer)
                return;

            //Update locally.
            if (set)
                _animator.SetTrigger(hash);
            else
                _animator.ResetTrigger(hash);

            /* Can send if not client auth but is server,
            * or if client auth and owner. */
            bool canSend = (!ClientAuthoritative && base.IsServer) ||
                (ClientAuthoritative && base.IsOwner);
            //Only queue a send if proper side.
            if (canSend)
            {
                for (byte i = 0; i < _parameterDetails.Count; i++)
                {
                    if (_parameterDetails[i].Hash == hash)
                    {
                        _triggerUpdates.Add(new TriggerUpdate(i, set));
                        return;
                    }
                }
                //Fall through, hash not found.
                Debug.LogWarning($"Hash {hash} not found while trying to update a trigger.");
            }
        }
        #endregion

        #region Remote actions.
        /// <summary>
        /// Called on clients to receive an animator update.
        /// </summary>
        /// <param name="data"></param>
        [ObserversRpc]
        private void ObserversAnimatorUpdated(ArraySegment<byte> data)
        {
            ServerDataReceived(ref data);
        }
        /// <summary>
        /// Called on clients to receive an animator update.
        /// </summary>
        /// <param name="data"></param>
        [TargetRpc]
        private void TargetAnimatorUpdated(NetworkConnection connection, ArraySegment<byte> data)
        {
            ServerDataReceived(ref data);
        }
        /// <summary>
        /// Called on server to receive an animator update.
        /// </summary>
        /// <param name="data"></param>
        [ServerRpc]
        private void ServerAnimatorUpdated(ArraySegment<byte> data)
        {
            if (!_isAnimatorEnabled)
                return;
            if (!ClientAuthoritative)
                return;

            ApplyParametersUpdated(ref data);
            _clientAuthoritativeUpdates.AddToBuffer(ref data);
        }
        /// <summary>
        /// Called on clients to receive an animator update.
        /// </summary>
        /// <param name="data"></param>
        private void ServerDataReceived(ref ArraySegment<byte> data)
        {
            if (!_isAnimatorEnabled)
                return;
            //If also server, client host, then do nothing. Animations already ran on server.
            if (base.IsServer)
                return;

            //If has authority.
            if (base.IsOwner)
            {
                //No need to sync to self if client authoritative.
                if (ClientAuthoritative)
                    return;
                //Not client authoritative, but also don't sync to owner.
                else if (!ClientAuthoritative && !_sendToOwner)
                    return;
            }

            ApplyParametersUpdated(ref data);
        }
        #endregion

        #region Editor.
#if UNITY_EDITOR
        protected override void Reset()
        {
            base.Reset();
            if (_animator == null)
                SetAnimator(GetComponent<Animator>());
        }
#endif
        #endregion

    }
}

'''
'''--- Assets/FishNet/Runtime/Generated/Component/NetworkTransform/Editor/NetworkTransformEditor.cs ---
﻿#if UNITY_EDITOR
using FishNet.Editing;
using UnityEditor;
using UnityEngine;

namespace FishNet.Component.Transforming.Editing
{

    [CustomEditor(typeof(NetworkTransform), true)]
    [CanEditMultipleObjects]
    public class NetworkTransformEditor : Editor
    {
        private SerializedProperty _packing;
        private SerializedProperty _synchronizeParent;
        private SerializedProperty _interpolation;
        private SerializedProperty _extrapolation;
        private SerializedProperty _enableTeleport;
        private SerializedProperty _teleportThreshold;
        private SerializedProperty _clientAuthoritative;
        private SerializedProperty _sendToOwner;
        private SerializedProperty _interval;
        private SerializedProperty _synchronizePosition;
        private SerializedProperty _positionSnapping;
        private SerializedProperty _synchronizeRotation;
        private SerializedProperty _rotationSnapping;
        private SerializedProperty _synchronizeScale;
        private SerializedProperty _scaleSnapping;

        protected virtual void OnEnable()
        {
            _packing = serializedObject.FindProperty("_packing");
            _synchronizeParent = serializedObject.FindProperty("_synchronizeParent");
            _interpolation = serializedObject.FindProperty("_interpolation");
            _extrapolation = serializedObject.FindProperty("_extrapolation");
            _enableTeleport = serializedObject.FindProperty("_enableTeleport");
            _teleportThreshold = serializedObject.FindProperty("_teleportThreshold");
            _clientAuthoritative = serializedObject.FindProperty("_clientAuthoritative");
            _sendToOwner = serializedObject.FindProperty("_sendToOwner");
            _interval = serializedObject.FindProperty("_interval");
            _synchronizePosition = serializedObject.FindProperty("_synchronizePosition");
            _positionSnapping = serializedObject.FindProperty("_positionSnapping");
            _synchronizeRotation = serializedObject.FindProperty("_synchronizeRotation");
            _rotationSnapping = serializedObject.FindProperty("_rotationSnapping");
            _synchronizeScale = serializedObject.FindProperty("_synchronizeScale");
            _scaleSnapping = serializedObject.FindProperty("_scaleSnapping");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((NetworkTransform)target), typeof(NetworkTransform), false);
            GUI.enabled = true;

            
#pragma warning disable CS0162 // Unreachable code detected
                EditorGUILayout.HelpBox(EditingConstants.PRO_ASSETS_LOCKED_TEXT, MessageType.Warning);
#pragma warning restore CS0162 // Unreachable code detected

            //Misc.
            EditorGUILayout.LabelField("Misc", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_synchronizeParent, new GUIContent("* Synchronize Parent"));
            EditorGUILayout.PropertyField(_packing);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Smoothing.
            EditorGUILayout.LabelField("Smoothing", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_interpolation);
            EditorGUILayout.PropertyField(_extrapolation, new GUIContent("* Extrapolation"));
            EditorGUILayout.PropertyField(_enableTeleport);
            if (_enableTeleport.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_teleportThreshold);
                EditorGUI.indentLevel--;
            }
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Authority.
            EditorGUILayout.LabelField("Authority", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_clientAuthoritative);
            if (!_clientAuthoritative.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_sendToOwner);
                EditorGUI.indentLevel--;
            }
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Synchronizing.
            EditorGUILayout.LabelField("Synchronizing.", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            //Interval.
            EditorGUILayout.PropertyField(_interval, new GUIContent("Interval", "How often in ticks to synchronize. A value of 1 will synchronize every tick, a value of 10 will synchronize every 10 ticks."));
            //Position.
            EditorGUILayout.PropertyField(_synchronizePosition);
            if (_synchronizePosition.boolValue)
            {
                EditorGUI.indentLevel += 2;
                EditorGUILayout.PropertyField(_positionSnapping);
                EditorGUI.indentLevel -= 2;
            }
            //Rotation.
            EditorGUILayout.PropertyField(_synchronizeRotation);
            if (_synchronizeRotation.boolValue)
            {
                EditorGUI.indentLevel += 2;
                EditorGUILayout.PropertyField(_rotationSnapping);
                EditorGUI.indentLevel -= 2;
            }
            //Scale.
            EditorGUILayout.PropertyField(_synchronizeScale);
            if (_synchronizeScale.boolValue)
            {
                EditorGUI.indentLevel += 2;
                EditorGUILayout.PropertyField(_scaleSnapping);
                EditorGUI.indentLevel -= 2;
            }
            EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }
    }

}
#endif
'''
'''--- Assets/FishNet/Runtime/Generated/Component/NetworkTransform/NetworkTransform.cs ---
﻿/* If nested then the nested NB should be sent every tick.
 * This is because if that tick happens to drop then the
 * sent data is now wrong given the parent information is wrong.
 * Once EC is added in we won't have to send every time since
 * it will eventually correct itself. */

using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Transforming
{
    /// <summary> 
    /// A somewhat basic but reliable NetworkTransform that will be improved upon greatly after release.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Component/NetworkTransform")]
    public sealed class NetworkTransform : NetworkBehaviour
    {
        #region Types.
        private struct ReceivedData
        {
            public bool HasData;
            public PooledWriter Writer;
            public Channel Channel;
        }
        [System.Serializable]
        public struct SnappedAxes
        {
            public bool X;
            public bool Y;
            public bool Z;
        }
        private enum ChangedDelta
        {
            Unset = 0,
            PositionX = 1,
            PositionY = 2,
            PositionZ = 4,
            Rotation = 8,
            Extended = 16,
            ScaleX = 32,
            ScaleY = 64,
            ScaleZ = 128,
            Nested = 256
        }
        private enum ChangedFull
        {
            Unset = 0,
            Position = 1,
            Rotation = 2,
            Scale = 4,
            Nested = 8
        }

        private enum UpdateFlagA : byte
        {
            Unset = 0,
            X2 = 1,
            X4 = 2,
            Y2 = 4,
            Y4 = 8,
            Z2 = 16,
            Z4 = 32,
            Rotation = 64,
            Extended = 128
        }
        private enum UpdateFlagB : byte
        {
            Unset = 0,
            X2 = 1,
            X4 = 2,
            Y2 = 4,
            Y4 = 8,
            Z2 = 16,
            Z4 = 32,
            Nested = 64
        }
        public class GoalData
        {
            public uint ReceivedTick;
            public RateData Rates = new RateData();
            public TransformData Transforms = new TransformData();

            public GoalData() { }
            public void Reset()
            {
                ReceivedTick = 0;
                Transforms.Reset();
                Rates.Reset();
            }
        }
        public class RateData
        {
            /// <summary>
            /// Rate for position after smart calculations.
            /// </summary>
            public float Position;
            /// <summary>
            /// Rate for rotation after smart calculations.
            /// </summary>
            public float Rotation;
            /// <summary>
            /// Rate for scale after smart calculations.
            /// </summary>
            public float Scale;
            /// <summary>
            /// Unaltered rate for position calculated through position change and tickspan.
            /// </summary>
            public float LastUnalteredPositionRate;
            /// <summary>
            /// Number of ticks the rates are calculated for.
            /// If TickSpan is 2 then the rates are calculated under the assumption the transform changed over 2 ticks.
            /// </summary>
            public uint TickSpan;
            /// <summary>
            /// True if the rate is believed to be fluctuating unusually.
            /// </summary>
            internal bool AbnormalRateDetected;
            /// <summary>
            /// Time remaining until transform is expected to reach it's goal.
            /// </summary>
            internal float TimeRemaining;

            public RateData() { }

            public void Reset()
            {
                Position = 0f;
                Rotation = 0f;
                Scale = 0f;
                LastUnalteredPositionRate = 0f;
                TickSpan = 0;
                AbnormalRateDetected = false;
                TimeRemaining = 0f;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Update(RateData rd)
            {
                Update(rd.Position, rd.Rotation, rd.Scale, rd.LastUnalteredPositionRate, rd.TickSpan, rd.AbnormalRateDetected, rd.TimeRemaining);
            }

            /// <summary>
            /// Updates rates.
            /// </summary>
            public void Update(float position, float rotation, float scale, float unalteredPositionRate, uint tickSpan, bool abnormalRateDetected, float timeRemaining)
            {
                Position = position;
                Rotation = rotation;
                Scale = scale;
                LastUnalteredPositionRate = unalteredPositionRate;
                TickSpan = tickSpan;
                AbnormalRateDetected = abnormalRateDetected;
                TimeRemaining = timeRemaining;
            }
        }

        public class TransformData
        {
            public enum ExtrapolateState : byte
            {
                Disabled = 0,
                Available = 1,
                Active = 2
            }
            public uint Tick;
            public bool Snapped;
            public Vector3 Position;
            public Quaternion Rotation;
            public Vector3 Scale;
            public Vector3 ExtrapolatedPosition;
            public ExtrapolateState ExtrapolationState;
            public NetworkBehaviour ParentBehaviour;
            public TransformData() { }

            internal void Reset()
            {
                Tick = 0;
                Snapped = false;
                Position = Vector3.zero;
                Rotation = Quaternion.identity;
                Scale = Vector3.zero;
                ExtrapolatedPosition = Vector3.zero;
                ExtrapolationState = ExtrapolateState.Disabled;
                ParentBehaviour = null;
            }
            internal void Update(TransformData copy)
            {
                Update(copy.Tick, copy.Position, copy.Rotation, copy.Scale, copy.ExtrapolatedPosition, copy.ParentBehaviour);
            }
            internal void Update(uint tick, Vector3 position, Quaternion rotation, Vector3 scale, Vector3 extrapolatedPosition, NetworkBehaviour parentBehaviour)
            {
                Tick = tick;
                Position = position;
                Rotation = rotation;
                Scale = scale;
                ExtrapolatedPosition = extrapolatedPosition;
                ParentBehaviour = parentBehaviour;
            }
        }

        #endregion

        #region Public.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="next"></param>
        [APIExclude]
        public delegate void DataReceivedChanged(TransformData prev, TransformData next);
        /// <summary>
        /// Called when new data is received. Previous and next data are provided. Next data may be manipulated.
        /// </summary>
        public event DataReceivedChanged OnDataReceived;
        /// <summary>
        /// Called when GoalData is updated.
        /// </summary>
        public event Action<GoalData> OnNextGoal;
        /// <summary>
        /// Called when the transform has reached it's goal.
        /// </summary>
        public event Action OnInterpolationComplete;
        #endregion

        #region Serialized.
        /// <summary>
        /// True to synchronize when this transform changes parent.
        /// </summary>
        [Tooltip("True to synchronize when this transform changes parent.")]
        [SerializeField]
        private bool _synchronizeParent;
        /// <summary>
        /// How much to compress each transform property.
        /// </summary>
        [Tooltip("How much to compress each transform property.")]
        [SerializeField]
        private TransformPackingData _packing = new TransformPackingData()
        {
            Position = AutoPackType.Packed,
            Rotation = AutoPackType.Packed,
            Scale = AutoPackType.Unpacked
        };
        /// <summary>
        /// How many ticks to interpolate.
        /// </summary>
        [Tooltip("How many ticks to interpolate.")]
        [Range(1, MAX_INTERPOLATION)]
        [SerializeField]
        private ushort _interpolation = 2;
        /// <summary>
        /// How many ticks to extrapolate.
        /// </summary>
        [Tooltip("How many ticks to extrapolate.")]
        [Range(0, 1024)]
        [SerializeField]
#pragma warning disable CS0414 //Not in use.
        private ushort _extrapolation = 2;
#pragma warning restore CS0414 //Not in use.
        /// <summary>
        /// True to enable teleport threshhold.
        /// </summary>
        [Tooltip("True to enable teleport threshhold.")]
        [SerializeField]
        private bool _enableTeleport;
        /// <summary>
        /// How far the transform must travel in a single update to cause a teleport rather than smoothing. Using 0f will teleport every update.
        /// </summary>
        [Tooltip("How far the transform must travel in a single update to cause a teleport rather than smoothing. Using 0f will teleport every update.")]
        [Range(0f, float.MaxValue)]
        [SerializeField]
        private float _teleportThreshold = 1f;
        /// <summary>
        /// True if owner controls how the object is synchronized.
        /// </summary>
        [Tooltip("True if owner controls how the object is synchronized.")]
        [SerializeField]
        private bool _clientAuthoritative = true;
        /// <summary>
        /// True to synchronize movements on server to owner when not using client authoritative movement.
        /// </summary>
        [Tooltip("True to synchronize movements on server to owner when not using client authoritative movement.")]
        [SerializeField]
        private bool _sendToOwner = true;
        /// <summary>
        /// How often in ticks to synchronize. A value of 1 will synchronize every tick, a value of 10 will synchronize every 10 ticks.
        /// </summary>
        [Tooltip("How often in ticks to synchronize. A value of 1 will synchronize every tick, a value of 10 will synchronize every 10 ticks.")]
        [Range(1, 255)]
        [SerializeField]
        private byte _interval = 1;
        /// <summary>
        /// True to synchronize position. Even while checked only changed values are sent.
        /// </summary>
        [Tooltip("True to synchronize position. Even while checked only changed values are sent.")]
        [SerializeField]
        private bool _synchronizePosition = true;
        /// <summary>
        /// Sets if to synchronize position.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetSynchronizePosition(bool value) => _synchronizePosition = value;
        /// <summary>
        /// Axes to snap on position.
        /// </summary>
        [Tooltip("Axes to snap on position.")]
        [SerializeField]
        private SnappedAxes _positionSnapping = new SnappedAxes();
        /// <summary>
        /// Sets which Position axes to snap.
        /// </summary>
        /// <param name="axes">Axes to snap.</param>
        public void SetPositionSnapping(SnappedAxes axes) => _positionSnapping = axes;
        /// <summary>
        /// True to synchronize rotation. Even while checked only changed values are sent.
        /// </summary>
        [Tooltip("True to synchronize rotation. Even while checked only changed values are sent.")]
        [SerializeField]
        private bool _synchronizeRotation = true;
        /// <summary>
        /// Sets if to synchronize rotation.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetSynchronizeRotation(bool value) => _synchronizeRotation = value;
        /// <summary>
        /// Axes to snap on rotation.
        /// </summary>
        [Tooltip("Axes to snap on rotation.")]
        [SerializeField]
        private SnappedAxes _rotationSnapping = new SnappedAxes();
        /// <summary>
        /// Sets which Scale axes to snap.
        /// </summary>
        /// <param name="axes">Axes to snap.</param>
        public void SetRotationSnapping(SnappedAxes axes) => _rotationSnapping = axes;
        /// <summary>
        /// True to synchronize scale. Even while checked only changed values are sent.
        /// </summary>
        [Tooltip("True to synchronize scale. Even while checked only changed values are sent.")]
        [SerializeField]
        private bool _synchronizeScale = true;
        /// <summary>
        /// Sets if to synchronize scale.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetSynchronizeScale(bool value) => _synchronizeScale = value;
        /// <summary>
        /// Axes to snap on scale.
        /// </summary>
        [Tooltip("Axes to snap on scale.")]
        [SerializeField]
        private SnappedAxes _scaleSnapping = new SnappedAxes();
        /// <summary>
        /// Sets which Scale axes to snap.
        /// </summary>
        /// <param name="axes">Axes to snap.</param>
        public void SetScaleSnapping(SnappedAxes axes) => _scaleSnapping = axes;
        #endregion

        #region Private.
        /// <summary>
        /// Packing data with all values set to uncompressed.
        /// </summary>
        private TransformPackingData _unpacked = new TransformPackingData()
        {
            Position = AutoPackType.Unpacked,
            Rotation = AutoPackType.Unpacked,
            Scale = AutoPackType.Unpacked
        };
        /// <summary>
        /// True if the last DataReceived was on the reliable channel. Default to true so initial values do not extrapolate.
        /// </summary>
        private bool _lastReceiveReliable = true;
        /// <summary>
        /// NetworkBehaviour this transform is a child of.
        /// </summary>
        private NetworkBehaviour _parentBehaviour;
        /// <summary>
        /// Last transform which this object was a child of.
        /// </summary>
        private Transform _parentTransform;
        /// <summary>
        /// Values changed over time that server has sent to clients since last reliable has been sent.
        /// </summary>
        private ChangedDelta _serverChangedSinceReliable = ChangedDelta.Unset;
        /// <summary>
        /// Values changed over time that client has sent to server since last reliable has been sent.
        /// </summary>
        private ChangedDelta _clientChangedSinceReliable = ChangedDelta.Unset;
        /// <summary>
        /// Last tick an ObserverRpc passed checks.
        /// </summary>
        private uint _lastObserversRpcTick;
        /// <summary>
        /// Last tick a ServerRpc passed checks.
        /// </summary>
        private uint _lastServerRpcTick;
        /// <summary>
        /// Last received data from an authoritative client.
        /// </summary>
        private ReceivedData _receivedClientData = new ReceivedData();
        /// <summary>
        /// True if subscribed to TimeManager for ticks.
        /// </summary>
        private bool _subscribedToTicks;
        /// <summary>
        /// Last TransformData to be sent.
        /// </summary>
        private TransformData _lastSentTransformData = new TransformData();
        /// <summary>
        /// Last TransformData to be received.
        /// </summary>
        private TransformData _lastReceivedTransformData = new TransformData();
        /// <summary>
        /// Last RateData to be calculated from LastReceivedTransformData.
        /// </summary>
        private RateData _lastCalculatedRateData = new RateData();
        /// <summary>
        /// GoalDatas to move towards.
        /// </summary>
        private Queue<GoalData> _goalDataQueue = new Queue<GoalData>();
        /// <summary>
        /// Current GoalData being used.
        /// </summary>
        private GoalData _currentGoalData = new GoalData();
        /// <summary>
        /// True if queue can be read. While true objects will move to CurrentGoalData.
        /// </summary>
        private bool _queueReady = false;
        /// <summary>
        /// Cache of GoalDatas to prevent allocations.
        /// </summary>
        private static Stack<GoalData> _goalDataCache = new Stack<GoalData>();
        /// <summary>
        /// True if the transform has changed since it started.
        /// </summary>
        private bool _changedSinceStart;
        /// <summary>
        /// Number of intervals remaining before synchronization.
        /// </summary>
        private short _intervalsRemaining;
        #endregion

        #region Const.
        /// <summary>
        /// Maximum possible interpolation value.
        /// </summary>
        public const ushort MAX_INTERPOLATION = 250;
        #endregion

        private void Awake()
        {
            _interval = Math.Max(_interval, (byte)1);
        }

        private void OnDestroy()
        {
            if (_receivedClientData.Writer != null)
            {
                _receivedClientData.Writer.Dispose();
                _receivedClientData.Writer = null;
            }
        }

        public override void OnStartServer()
        {
            base.OnStartServer();
            SetDefaultGoalData();
            /* Server must always subscribe.
             * Server needs to relay client auth in
             * ticks or send non-auth/non-owner to
             * clients in tick. */
            ChangeTickSubscription(true);
        }

        public override void OnSpawnServer(NetworkConnection connection)
        {
            base.OnSpawnServer(connection);
            /* If not on the root then the initial properties may need to be synchronized
             * since the spawn message only sends root information. If initial
             * properties have changed update spawning connection. */
            if (base.NetworkObject.gameObject != gameObject && _changedSinceStart)
            {
                //Send latest.
                using (PooledWriter writer = WriterPool.GetWriter())
                {
                    ChangedDelta fullTransform = (ChangedDelta.PositionX | ChangedDelta.PositionY | ChangedDelta.PositionZ | ChangedDelta.Extended | ChangedDelta.ScaleX | ChangedDelta.ScaleY | ChangedDelta.ScaleZ | ChangedDelta.Rotation);
                    SerializeChanged(fullTransform, writer);
                    TargetUpdateTransform(connection, writer.GetArraySegment(), Channel.Reliable);
                }
            }

            
        }

        public override void OnStartClient()
        {
            base.OnStartClient();
            SetDefaultGoalData();
        }

        public override void OnOwnershipServer(NetworkConnection prevOwner)
        {
            base.OnOwnershipServer(prevOwner);
            _intervalsRemaining = 0;
            //Reset last tick since each client sends their own ticks.
            _lastServerRpcTick = 0;
        }

        public override void OnOwnershipClient(NetworkConnection prevOwner)
        {
            base.OnOwnershipClient(prevOwner);
            _intervalsRemaining = 0;
            /* If newOwner is self then client
             * must subscribe to ticks. Client can also
             * unsubscribe from ticks if not owner,
             * long as the server is also not active. */
            if (base.IsOwner)
            {
                ChangeTickSubscription(true);
            }
            //Not new owner.
            else
            {
                /* If client authoritative and ownership was lost
                 * then default goals must be set to force the
                 * object to it's last transform. */
                if (_clientAuthoritative)
                    SetDefaultGoalData();

                if (!base.IsServer)
                    ChangeTickSubscription(false);
            }
        }

        public override void OnStopServer()
        {
            base.OnStopServer();
            //Always unsubscribe; if the server stopped so did client.
            ChangeTickSubscription(false);
        }

        public override void OnStopClient()
        {
            base.OnStopClient();
            //If not also server unsubscribe from ticks.
            if (!base.IsServer)
                ChangeTickSubscription(false);
        }

        private void Update()
        {
            MoveToTarget();
        }

        /// <summary>
        /// Called when a tick occurs.
        /// </summary>
        private void TimeManager_OnPostTick()
        {
            /* Intervals remaining is only used when the interval value
             * is set higher than 1. An interval of 1 indicates to send
             * every tick. Only check to wait more ticks if interval
             * is larger than 1. */
            if (_interval > 1)
            {
                /* If intervalsRemaining is unset then that means the transform
                 * did not change last tick. See if transform changed and if so then
                 * update remaining to _interval. */
                if (_intervalsRemaining == -1)
                {
                    //Transform didn't change, no reason to start remaining.
                    if (!transform.hasChanged)
                        return;

                    _intervalsRemaining = _interval;
                }

                //If here then intervalsRemaining can be deducted.
                _intervalsRemaining--;
                //Interval not met yet.
                if (_intervalsRemaining > 0)
                    return;
                //Intervals remainin is met. Reset to -1 to await new change.
                else
                    _intervalsRemaining = -1;
            }

            
            if (base.IsServer)
                SendToClients();
            if (base.IsClient)
                SendToServer();
        }

        /// <summary>
        /// Tries to subscribe to TimeManager ticks.
        /// </summary>
        private void ChangeTickSubscription(bool subscribe)
        {
            if (subscribe == _subscribedToTicks)
                return;

            _subscribedToTicks = subscribe;
            if (subscribe)
                base.NetworkManager.TimeManager.OnPostTick += TimeManager_OnPostTick;
            else
                base.NetworkManager.TimeManager.OnPostTick -= TimeManager_OnPostTick;
        }

        /// <summary>
        /// Updates the interval value over the network.
        /// </summary>
        /// <param name="value">New interval.</param>
        public void SetInterval(byte value)
        {
            bool canSet = (base.IsServer && !_clientAuthoritative)
                || (base.IsServer && _clientAuthoritative && !base.Owner.IsValid)
                || (_clientAuthoritative && base.IsOwner);

            if (!canSet)
                return;

            if (base.IsServer)
                ObserversSetInterval(value);
            else
                ServerSetInterval(value);
        }

        /// <summary>
        /// Updates the interval value.
        /// </summary>
        /// <param name="value"></param>
        private void SetIntervalInternal(byte value)
        {
            value = (byte)Mathf.Max(value, 1);
            _interval = value;
        }

        /// <summary>
        /// Sets interval over the network.
        /// </summary>
        [ServerRpc(RunLocally = true)]
        private void ServerSetInterval(byte value)
        {
            SetIntervalInternal(value);
        }
        /// <summary>
        /// Sets interval over the network.
        /// </summary>
        [ObserversRpc(RunLocally = true)]
        private void ObserversSetInterval(byte value)
        {
            SetIntervalInternal(value);
        }

        /// <summary>
        /// Creates goal data using current position.
        /// </summary>
        private void SetDefaultGoalData()
        {
            Transform t = transform;
            NetworkBehaviour parentBehaviour = null;
            //If there is a parent try to output the behaviour on it.
            if (_synchronizeParent && transform.parent != null)
            {
                transform.parent.TryGetComponent<NetworkBehaviour>(out parentBehaviour);
                if (parentBehaviour == null)
                {
                    LogInvalidParent();
                }
                else
                {
                    _parentTransform = transform.parent;
                    _parentBehaviour = parentBehaviour;
                }
            }

            _lastReceivedTransformData.Update(0, t.localPosition, t.localRotation, t.localScale, t.localPosition, parentBehaviour);
            SetInstantRates(_currentGoalData.Rates);
        }

        /// <summary>
        /// Prints an invalid parent debug.
        /// </summary>
        private void LogInvalidParent()
        {
            Debug.LogWarning($"{gameObject.name} [Id {base.ObjectId}] is nested but the parent {transform.parent.name} does not contain a NetworkBehaviour component. To synchronize parents the parent object must have a NetworkBehaviour component, even if empty.");
        }

        /// <summary>
        /// Serializes only changed data into writer.
        /// </summary>
        /// <param name="changed"></param>
        /// <param name="writer"></param>
        private void SerializeChanged(ChangedDelta changed, PooledWriter writer)
        {
            UpdateFlagA flagsA = UpdateFlagA.Unset;
            UpdateFlagB flagsB = UpdateFlagB.Unset;
            /* Do not use compression when nested. Depending
             * on the scale of the parent compression may
             * not be accurate enough. */
            TransformPackingData packing = (ChangedContains(changed, ChangedDelta.Nested)) ?
                _unpacked : _packing;

            int startIndexA = writer.Position;
            writer.Reserve(1);
            //Original axis value.
            float original;
            //Compressed axis value.
            float compressed;
            //Multiplier for compression.
            float multiplier = 100f;
            /* Maximum value compressed may be 
             * to send as compressed. */
            float maxValue = (short.MaxValue - 1);

            Transform t = transform;
            /* Position. */
            if (_synchronizePosition)
            {
                AutoPackType localPacking = packing.Position;
                //PositionX
                if (ChangedContains(changed, ChangedDelta.PositionX))
                {
                    original = t.localPosition.x;
                    compressed = original * multiplier;
                    if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                    {
                        flagsA |= UpdateFlagA.X2;
                        writer.WriteInt16((short)compressed);
                    }
                    else
                    {
                        flagsA |= UpdateFlagA.X4;
                        writer.WriteSingle(original);
                    }
                }
                //PositionY
                if (ChangedContains(changed, ChangedDelta.PositionY))
                {
                    original = t.localPosition.y;
                    compressed = original * multiplier;
                    if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                    {
                        flagsA |= UpdateFlagA.Y2;
                        writer.WriteInt16((short)compressed);
                    }
                    else
                    {
                        flagsA |= UpdateFlagA.Y4;
                        writer.WriteSingle(original);
                    }
                }
                //PositionZ
                if (ChangedContains(changed, ChangedDelta.PositionZ))
                {
                    original = t.localPosition.z;
                    compressed = original * multiplier;
                    if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                    {
                        flagsA |= UpdateFlagA.Z2;
                        writer.WriteInt16((short)compressed);
                    }
                    else
                    {
                        flagsA |= UpdateFlagA.Z4;
                        writer.WriteSingle(original);
                    }
                }
            }

            /* Rotation. */
            if (_synchronizeRotation)
            {
                if (ChangedContains(changed, ChangedDelta.Rotation))
                {
                    flagsA |= UpdateFlagA.Rotation;
                    /* Rotation can always use pack settings even
                     * if nested. Unsual transform scale shouldn't affect rotation. */
                    writer.WriteQuaternion(t.localRotation, _packing.Rotation);
                }
            }

            if (ChangedContains(changed, ChangedDelta.Extended))
            {
                AutoPackType localPacking = packing.Position;
                flagsA |= UpdateFlagA.Extended;
                int startIndexB = writer.Position;
                writer.Reserve(1);

                /* Scale. */
                if (_synchronizeScale)
                {
                    //ScaleX
                    if (ChangedContains(changed, ChangedDelta.ScaleX))
                    {
                        original = t.localScale.x;
                        compressed = original * multiplier;
                        if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                        {
                            flagsB |= UpdateFlagB.X2;
                            writer.WriteInt16((short)compressed);
                        }
                        else
                        {
                            flagsB |= UpdateFlagB.X4;
                            writer.WriteSingle(original);
                        }
                    }
                    //ScaleY
                    if (ChangedContains(changed, ChangedDelta.ScaleY))
                    {
                        original = t.localScale.y;
                        compressed = original * multiplier;
                        if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                        {
                            flagsB |= UpdateFlagB.Y2;
                            writer.WriteInt16((short)compressed);
                        }
                        else
                        {
                            flagsB |= UpdateFlagB.Y4;
                            writer.WriteSingle(original);
                        }
                    }
                    //ScaleZ
                    if (ChangedContains(changed, ChangedDelta.ScaleZ))
                    {
                        original = t.localScale.z;
                        compressed = original * multiplier;
                        if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                        {
                            flagsB |= UpdateFlagB.Z2;
                            writer.WriteInt16((short)compressed);
                        }
                        else
                        {
                            flagsB |= UpdateFlagB.Z4;
                            writer.WriteSingle(original);
                        }
                    }
                }

                //Nested.
                if (ChangedContains(changed, ChangedDelta.Nested) && _parentBehaviour != null)
                {
                    flagsB |= UpdateFlagB.Nested;
                    writer.WriteNetworkBehaviour(_parentBehaviour);
                }

                writer.FastInsertByte((byte)flagsB, startIndexB);
            }

            //Insert flags.
            writer.FastInsertByte((byte)flagsA, startIndexA);
            bool ChangedContains(ChangedDelta whole, ChangedDelta part)
            {
                return (whole & part) == part;
            }
        }

        /// <summary>
        /// Deerializes a received packet.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void DeserializePacket(ArraySegment<byte> data, TransformData prevTransformData, TransformData nextTransformData, ref ChangedFull changedFull)
        {
            using (PooledReader r = ReaderPool.GetReader(data, base.NetworkManager))
            {
                UpdateFlagA flagsA = (UpdateFlagA)r.ReadByte();

                int readerRemaining;
                readerRemaining = r.Remaining;
                //X
                if (UpdateFlagAContains(flagsA, UpdateFlagA.X2))
                    nextTransformData.Position.x = r.ReadInt16() / 100f;
                else if (UpdateFlagAContains(flagsA, UpdateFlagA.X4))
                    nextTransformData.Position.x = r.ReadSingle();
                else
                    nextTransformData.Position.x = prevTransformData.Position.x;
                //Y
                if (UpdateFlagAContains(flagsA, UpdateFlagA.Y2))
                    nextTransformData.Position.y = r.ReadInt16() / 100f;
                else if (UpdateFlagAContains(flagsA, UpdateFlagA.Y4))
                    nextTransformData.Position.y = r.ReadSingle();
                else
                    nextTransformData.Position.y = prevTransformData.Position.y;
                //Z
                if (UpdateFlagAContains(flagsA, UpdateFlagA.Z2))
                    nextTransformData.Position.z = r.ReadInt16() / 100f;
                else if (UpdateFlagAContains(flagsA, UpdateFlagA.Z4))
                    nextTransformData.Position.z = r.ReadSingle();
                else
                    nextTransformData.Position.z = prevTransformData.Position.z;
                //If remaining has changed then a position was read.
                if (readerRemaining != r.Remaining)
                    changedFull |= ChangedFull.Position;

                //Rotation.
                if (UpdateFlagAContains(flagsA, UpdateFlagA.Rotation))
                {
                    //Always use _packing value even if nested.
                    nextTransformData.Rotation = r.ReadQuaternion(_packing.Rotation);
                    changedFull |= ChangedFull.Rotation;
                }
                else
                {
                    nextTransformData.Rotation = prevTransformData.Rotation;
                }

                //Extended settings.
                if (UpdateFlagAContains(flagsA, UpdateFlagA.Extended))
                {
                    UpdateFlagB flagsB = (UpdateFlagB)r.ReadByte();
                    readerRemaining = r.Remaining;

                    //X
                    if (UpdateFlagBContains(flagsB, UpdateFlagB.X2))
                        nextTransformData.Scale.x = r.ReadInt16() / 100f;
                    else if (UpdateFlagBContains(flagsB, UpdateFlagB.X4))
                        nextTransformData.Scale.x = r.ReadSingle();
                    else
                        nextTransformData.Scale.x = prevTransformData.Scale.x;
                    //Y
                    if (UpdateFlagBContains(flagsB, UpdateFlagB.Y2))
                        nextTransformData.Scale.y = r.ReadInt16() / 100f;
                    else if (UpdateFlagBContains(flagsB, UpdateFlagB.Y4))
                        nextTransformData.Scale.y = r.ReadSingle();
                    else
                        nextTransformData.Scale.y = prevTransformData.Scale.y;
                    //X
                    if (UpdateFlagBContains(flagsB, UpdateFlagB.Z2))
                        nextTransformData.Scale.z = r.ReadInt16() / 100f;
                    else if (UpdateFlagBContains(flagsB, UpdateFlagB.Z4))
                        nextTransformData.Scale.z = r.ReadSingle();
                    else
                        nextTransformData.Scale.z = prevTransformData.Scale.z;

                    if (r.Remaining != readerRemaining)
                        changedFull |= ChangedFull.Scale;
                    else
                        nextTransformData.Scale = prevTransformData.Scale;

                    if (UpdateFlagBContains(flagsB, UpdateFlagB.Nested))
                    {
                        nextTransformData.ParentBehaviour = r.ReadNetworkBehaviour();
                        changedFull |= ChangedFull.Nested;
                    }
                    else
                    {
                        Unnest();
                    }
                }
                //No extended settings.
                else
                {
                    nextTransformData.Scale = prevTransformData.Scale;
                    Unnest();
                }
            }

            void Unnest()
            {
                nextTransformData.ParentBehaviour = null;
            }

            //Returns if whole contains part.
            bool UpdateFlagAContains(UpdateFlagA whole, UpdateFlagA part)
            {
                return (whole & part) == part;
            }
            //Returns if whole contains part.
            bool UpdateFlagBContains(UpdateFlagB whole, UpdateFlagB part)
            {
                return (whole & part) == part;
            }
        }

        

        /// <summary>
        /// Moves to a GoalData. Automatically determins if to use data from server or client.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void MoveToTarget(float deltaOverride = -1f)
        {
            if (!_queueReady)
                return;
            //Cannot move if neither is active.
            if (!base.IsServer && !base.IsClient)
                return;
            //If client auth and the owner don't move towards target.
            if (_clientAuthoritative && base.IsOwner)
                return;
            //If not client authoritative, is owner, and don't sync to owner.
            if (!_clientAuthoritative && base.IsOwner && !_sendToOwner)
                return;
            //True if not client controlled.
            bool controlledByClient = (_clientAuthoritative && base.Owner.IsActive);
            //If not controlled by client and is server then no reason to move.
            if (!controlledByClient && base.IsServer)
                return;

            float delta = (deltaOverride != -1f) ? deltaOverride : Time.deltaTime;
            /* Once here it's safe to assume the object will be moving.
             * Any checks which would stop it from moving be it client
             * auth and owner, or server controlled and server, ect,
             * would have already been run. */
            TransformData td = _currentGoalData.Transforms;
            RateData rd = _currentGoalData.Rates;

            

            float multiplier = 1f;
            int queueCount = _goalDataQueue.Count;
            //For every entry past interpolation increase move rate.
            if (queueCount > (_interpolation + 1))
                multiplier += (0.05f * queueCount);

            //Rate to update. Changes per property.
            float rate;
            Transform t = transform;

            //Snap any positions that should be.
            SnapProperties(td);

            //Position.
            if (_synchronizePosition)
            {
                rate = rd.Position;
                Vector3 posGoal = (td.ExtrapolationState == TransformData.ExtrapolateState.Active && !_lastReceiveReliable) ? td.ExtrapolatedPosition : td.Position;
                if (rate == -1f)
                    t.localPosition = td.Position;
                else
                    t.localPosition = Vector3.MoveTowards(t.localPosition, posGoal, rate * delta * multiplier);
            }

            //Rotation.
            if (_synchronizeRotation)
            {
                rate = rd.Rotation;
                if (rate == -1f)
                    t.localRotation = td.Rotation;
                else
                    t.localRotation = Quaternion.RotateTowards(t.localRotation, td.Rotation, rate * delta);
            }

            //Scale.
            if (_synchronizeScale)
            {
                rate = rd.Scale;
                if (rate == -1f)
                    t.localScale = td.Scale;
                else
                    t.localScale = Vector3.MoveTowards(t.localScale, td.Scale, rate * delta);
            }

            float timeRemaining = rd.TimeRemaining - (delta * multiplier);
            if (timeRemaining < -delta)
                timeRemaining = -delta;
            rd.TimeRemaining = timeRemaining;

            if (rd.TimeRemaining <= 0f)
            {
                float leftOver = Mathf.Abs(rd.TimeRemaining);
                //If more in buffer then run next buffer.
                if (queueCount > 0)
                {
                    _currentGoalData.Reset();
                    _goalDataCache.Push(_currentGoalData);
                    SetCurrentGoalData(_goalDataQueue.Dequeue());
                    if (leftOver > 0f)
                        MoveToTarget(leftOver);
                }
                //No more in buffer, see if can extrapolate.
                else
                {
                    
                        /* If everything matches up then end queue.
                        * Otherwise let it play out until stuff
                        * aligns. Generally the time remaining is enough
                        * but every once in awhile something goes funky
                        * and it's thrown off. */
                        if (!HasChanged(td))
                            _queueReady = false;
                        OnInterpolationComplete?.Invoke();
                        
                }
            }

        }

        /// <summary>
        /// Sends transform data to clients if needed.
        /// </summary>
        private void SendToClients()
        {
            //True if clientAuthoritative and there is an owner.
            bool clientAuthoritativeWithOwner = (_clientAuthoritative && base.Owner.IsValid);
            //Quick exit if client auth and there's no new data.
            if (_clientAuthoritative && base.Owner.IsValid && !_receivedClientData.HasData)
                return;
            //Channel to send rpc on.
            Channel channel = Channel.Unreliable;
            //If relaying from client.
            if (clientAuthoritativeWithOwner)
            {
                if (_receivedClientData.HasData)
                {
                    _changedSinceStart = true;
                    //Resend data from clients.
                    ObserversUpdateTransform(_receivedClientData.Writer.GetArraySegment(), _receivedClientData.Channel);
                    _receivedClientData.HasData = false;
                }
            }
            //Sending server transform state.
            else
            {
                ChangedDelta changed = GetChanged(_lastSentTransformData);

                //If no change.
                if (changed == ChangedDelta.Unset)
                {
                    //No changes since last reliable; transform is up to date.
                    if (_serverChangedSinceReliable == ChangedDelta.Unset)
                        return;

                    //Set changed to all changes over time and unset changes over time.
                    changed = _serverChangedSinceReliable;
                    _serverChangedSinceReliable = ChangedDelta.Unset;
                    channel = Channel.Reliable;
                }
                //There is change.
                else
                {
                    _serverChangedSinceReliable |= changed;
                }

                _changedSinceStart = true;
                Transform t = transform;
                /* If here a send for transform values will occur. Update last values.
                 * Tick doesn't need to be set for whoever controls transform. */
                _lastSentTransformData.Update(0, t.localPosition, t.localRotation, t.localScale, t.localPosition, _parentBehaviour);

                //Send latest.
                using (PooledWriter writer = WriterPool.GetWriter())
                {
                    SerializeChanged(changed, writer);
                    ObserversUpdateTransform(writer.GetArraySegment(), channel);
                }
            }

        }

        /// <summary>
        /// Sends transform data to server if needed.
        /// </summary>
        private void SendToServer()
        {
            //Not client auth or not owner.
            if (!_clientAuthoritative || !base.IsOwner)
                return;

            //Channel to send on.
            Channel channel = Channel.Unreliable;
            //Values changed since last check.
            ChangedDelta changed = GetChanged(_lastSentTransformData);

            //If no change.
            if (changed == ChangedDelta.Unset)
            {
                //No changes since last reliable; transform is up to date.
                if (_clientChangedSinceReliable == ChangedDelta.Unset)
                    return;

                //Set changed to all changes over time and unset changes over time.
                changed = _clientChangedSinceReliable;
                _clientChangedSinceReliable = ChangedDelta.Unset;
                channel = Channel.Reliable;
            }
            //There is change.
            else
            {
                _clientChangedSinceReliable |= changed;
            }

            /* If here a send for transform values will occur. Update last values.
            * Tick doesn't need to be set for whoever controls transform. */
            Transform t = transform;
            _lastSentTransformData.Update(0, t.localPosition, t.localRotation, t.localScale, t.localPosition, _parentBehaviour);

            //Send latest.
            using (PooledWriter writer = WriterPool.GetWriter())
            {
                SerializeChanged(changed, writer);
                ServerUpdateTransform(writer.GetArraySegment(), channel);
            }
        }

        #region GetChanged.
        /// <summary>
        /// Returns if the transform differs from td.
        /// </summary>
        private bool HasChanged(TransformData td)
        {
            bool changed = (td.Position != transform.localPosition ||
                td.Rotation != transform.localRotation ||
                td.Scale != transform.localScale);

            return changed;
        }
        /// <summary>
        /// Returns if there is any change between two datas.
        /// </summary>
        private bool HasChanged(TransformData a, TransformData b)
        {
            return (a.Position != b.Position) ||
                (a.Rotation != b.Rotation) ||
                (a.Scale != b.Scale) ||
                (a.ParentBehaviour != b.ParentBehaviour);
        }
        /// <summary>
        /// Returns if there is any change between two datas and outputs what has changed.
        /// </summary>
        private bool HasChanged(TransformData a, TransformData b, ref ChangedFull changedFull)
        {
            bool hasChanged = false;

            if (a.Position != b.Position)
            {
                hasChanged = true;
                changedFull |= ChangedFull.Position;
            }
            if (a.Rotation != b.Rotation)
            {
                hasChanged = true;
                changedFull |= ChangedFull.Rotation;
            }
            if (a.Scale != b.Scale)
            {
                hasChanged = true;
                changedFull |= ChangedFull.Scale;
            }
            if (a.ParentBehaviour != b.ParentBehaviour)
            {
                hasChanged = true;
                changedFull |= ChangedFull.Nested;
            }

            return hasChanged;
        }
        /// <summary>
        /// Gets transform values that have changed against goalData.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ChangedDelta GetChanged(TransformData transformData)
        {
            return GetChanged(ref transformData.Position, ref transformData.Rotation, ref transformData.Scale, transformData.ParentBehaviour);
        }
        /// <summary>
        /// Gets transform values that have changed against specified proprties.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ChangedDelta GetChanged(ref Vector3 lastPosition, ref Quaternion lastRotation, ref Vector3 lastScale, NetworkBehaviour parentBehaviour)
        {
            ChangedDelta changed = ChangedDelta.Unset;
            Transform t = transform;

            Vector3 position = t.localPosition;
            if (position.x != lastPosition.x)
                changed |= ChangedDelta.PositionX;
            if (position.y != lastPosition.y)
                changed |= ChangedDelta.PositionY;
            if (position.z != lastPosition.z)
                changed |= ChangedDelta.PositionZ;

            Quaternion rotation = t.localRotation;
            if (!rotation.Matches(lastRotation, true))
                changed |= ChangedDelta.Rotation;

            ChangedDelta startChanged;
            startChanged = changed;

            Vector3 scale = t.localScale;
            if (scale.x != lastScale.x)
                changed |= ChangedDelta.ScaleX;
            if (scale.y != lastScale.y)
                changed |= ChangedDelta.ScaleY;
            if (scale.z != lastScale.z)
                changed |= ChangedDelta.ScaleZ;

            //Parent behaviour exist.
            if (parentBehaviour != null)
                changed |= ChangedDelta.Nested;

            //If added scale or nested then also add extended.
            if (startChanged != changed)
                changed |= ChangedDelta.Extended;

            return changed;
        }
        #endregion

        #region Rates.
        /// <summary>
        /// Snaps transform properties using snapping settings.
        /// </summary>
        private void SnapProperties(TransformData transformData)
        {
            //Already snapped.
            if (transformData.Snapped)
                return;

            transformData.Snapped = true;
            Transform t = transform;

            //Position.
            if (_synchronizePosition)
            {
                Vector3 position;
                position.x = (_positionSnapping.X) ? transformData.Position.x : t.localPosition.x;
                position.y = (_positionSnapping.Y) ? transformData.Position.y : t.localPosition.y;
                position.z = (_positionSnapping.Z) ? transformData.Position.z : t.localPosition.z;
                t.localPosition = position;
            }

            //Rotation.
            if (_synchronizeRotation)
            {
                Vector3 eulers;
                Vector3 goalEulers = transformData.Rotation.eulerAngles;
                eulers.x = (_rotationSnapping.X) ? goalEulers.x : t.localEulerAngles.x;
                eulers.y = (_rotationSnapping.Y) ? goalEulers.y : t.localEulerAngles.y;
                eulers.z = (_rotationSnapping.Z) ? goalEulers.z : t.localEulerAngles.z;
                t.localEulerAngles = eulers;
            }

            //Scale.
            if (_synchronizeScale)
            {
                Vector3 scale;
                scale.x = (_scaleSnapping.X) ? transformData.Scale.x : t.localScale.x;
                scale.y = (_scaleSnapping.Y) ? transformData.Scale.y : t.localScale.y;
                scale.z = (_scaleSnapping.Z) ? transformData.Scale.z : t.localScale.z;
                t.localScale = scale;
            }
        }

        /// <summary>
        /// Sets move rates which will occur instantly.
        /// </summary>
        private void SetInstantRates(RateData rd)
        {
            rd.Update(-1f, -1f, -1f, -1f, 1, false, -1f);
        }

        /// <summary>
        /// Sets move rates which will occur over time.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void SetCalculatedRates(uint lastTick, RateData prevRd, TransformData prevTd, GoalData nextGd, ChangedFull changedFull, bool hasChanged, Channel channel)
        {
            /* Only update rates if data has changed.
             * When data comes in reliably for eventual consistency
             * it's possible that it will be the same as the last
             * unreliable packet. When this happens no change has occurred
             * and the distance of change woudl also be 0; this prevents
             * the NT from moving. Only need to compare data if channel is reliable. */
            TransformData td = nextGd.Transforms;
            if (channel == Channel.Reliable && !hasChanged)
            {
                nextGd.Rates.Update(prevRd);
                return;
            }

            /* How much time has passed between last update and current.
             * If set to 0 then that means the transform has
             * settled. */
            if (lastTick == 0)
                lastTick = (nextGd.Transforms.Tick - _interval);

            uint tickDifference = (td.Tick - lastTick);
            float timePassed = (float)base.NetworkManager.TimeManager.TicksToTime(tickDifference);

            //Distance between properties.
            float distance;
            float positionRate = 0f;
            float rotationRate = 0f;
            float scaleRate = 0f;

            RateData rd = nextGd.Rates;
            //Correction to apply towards rates when a rate change is detected as abnormal.
            float abnormalCorrection = 1f;
            bool abnormalRateDetected = false;
            float unalteredPositionRate = rd.LastUnalteredPositionRate;

            //Position.
            if (ChangedFullContains(changedFull, ChangedFull.Position))
            {
                Vector3 lastPosition = prevTd.Position;
                distance = Vector3.Distance(lastPosition, td.Position);
                //If distance teleports assume rest do.
                if (_enableTeleport && distance >= _teleportThreshold)
                {
                    SetInstantRates(rd);
                    return;
                }

                //Position distance already calculated.
                unalteredPositionRate = distance / timePassed;
                /* Try to detect abnormal rate changes.
                 * 
                 * This won't occur if the user
                 * is moving using the tick system but will likely happen when the transform
                 * is being moved in update.
                 * 
                 * Update will iterate a varying amount of times per tick,
                 * which will result in distances being slightly different. This is
                 * rarely an issue when the frame rate is high and the distance 
                 * variance is very little, but for games which are running at about
                 * the same frame rate as the tick it's possible the object will
                 * move twice the distance every few ticks. EG: if running 60 fps/50 tick.
                 * Execution may look like this..
                 * frame, tick, frame, tick, frame, frame, tick. The frame, frame would
                 * result in double movement distance. */

                //If last position rate is known then compare against it.
                if (unalteredPositionRate > 0f && rd.LastUnalteredPositionRate > 0f)
                {
                    float percentage = Mathf.Abs(1f - (unalteredPositionRate / rd.LastUnalteredPositionRate));
                    /* If percentage change is more than 25% then speed is considered
                     * to have changed drastically. */
                    if (percentage > 0.25f)
                    {
                        float c = (rd.LastUnalteredPositionRate / unalteredPositionRate);
                        /* Sometimes stop and goes can incorrectly trigger 
                         * an abnormal detection. Fortunately abnornalties tend
                         * to either skip a tick or send twice in one tick.
                         * Because of this it's fairly safe to assume that if the calculated
                         * correction is not ~0.5f or ~2f then it's a false detection. */
                        float allowedDifference = 0.1f;
                        if (
                            (c < 1f && Mathf.Abs(0.5f - c) < allowedDifference) ||
                            (c > 1f && Mathf.Abs(2f - c) < allowedDifference))
                        {
                            abnormalCorrection = c;
                            abnormalRateDetected = true;
                        }
                        /* If an abnormality has been marked then assume new rate
                         * is proper. When an abnormal rate occurs unintentionally
                         * the values will fix themselves next tick, therefor when
                         * rate changes drastically twice assume its intentional or
                         * that the rate had simply fixed itself, both which would unset
                         * abnormal rate detected. */
                    }
                }

                //abnormalCorrection = 1f;
                positionRate = (unalteredPositionRate * abnormalCorrection);
            }

            //Rotation.
            if (ChangedFullContains(changedFull, ChangedFull.Rotation))
            {
                Quaternion lastRotation = prevTd.Rotation;
                distance = lastRotation.Angle(td.Rotation, true);
                rotationRate = (distance / timePassed) * abnormalCorrection;
            }

            //Scale.
            if (ChangedFullContains(changedFull, ChangedFull.Scale))
            {
                Vector3 lastScale = prevTd.Scale;
                distance = Vector3.Distance(lastScale, td.Scale);
                scaleRate = (distance / timePassed) * abnormalCorrection;
            }

            rd.Update(positionRate, rotationRate, scaleRate, unalteredPositionRate, tickDifference, abnormalRateDetected, timePassed);

            //Returns if whole contains part.
            bool ChangedFullContains(ChangedFull whole, ChangedFull part)
            {
                return (whole & part) == part;
            }
        }
        #endregion       

        /// <summary>
        /// Sets extrapolation data on next.
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="next"></param>
        /// <param name="channel"></param>
        private void SetExtrapolation(TransformData prev, TransformData next, Channel channel)
        {
            //Default value.
            next.ExtrapolationState = TransformData.ExtrapolateState.Disabled;

            
        }

        /// <summary>
        /// Updates a client with transform data.
        /// </summary>
        [TargetRpc]
        private void TargetUpdateTransform(NetworkConnection conn, ArraySegment<byte> data, Channel channel)
        {
            DataReceived(data, channel, false);
        }

        /// <summary>
        /// Updates clients with transform data.
        /// </summary>
        [ObserversRpc]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ObserversUpdateTransform(ArraySegment<byte> data, Channel channel)
        {
            if (!_clientAuthoritative && base.IsOwner && !_sendToOwner)
                return;
            if (_clientAuthoritative && base.IsOwner)
                return;
            if (base.IsServer)
                return;

            //Not new data.
            uint lastPacketTick = base.TimeManager.LastPacketTick;
            if (lastPacketTick <= _lastObserversRpcTick)
                return;
            _lastObserversRpcTick = lastPacketTick;

            DataReceived(data, channel, false);
        }

        /// <summary>
        /// Updates the transform on the server.
        /// </summary>
        /// <param name="tb"></param>
        /// <param name="channel"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [ServerRpc]
        private void ServerUpdateTransform(ArraySegment<byte> data, Channel channel)
        {
            //Not new data.
            uint lastPacketTick = base.TimeManager.LastPacketTick;
            if (lastPacketTick <= _lastServerRpcTick)
                return;
            _lastServerRpcTick = lastPacketTick;

            //Populate writer if it doesn't exist.
            if (_receivedClientData.Writer == null)
                _receivedClientData.Writer = WriterPool.GetWriter();
            _receivedClientData.Channel = channel;
            _receivedClientData.Writer.Reset();
            _receivedClientData.Writer.WriteArraySegment(data);
            _receivedClientData.HasData = true;

            DataReceived(data, channel, true);
        }

        /// <summary>
        /// Processes received data for lcients and server.
        /// </summary>
        private void DataReceived(ArraySegment<byte> data, Channel channel, bool asServer)
        {
            TransformData prevTd = _lastReceivedTransformData;
            RateData prevRd = _lastCalculatedRateData;
            ChangedFull changedFull = new ChangedFull();

            GoalData nextGd = GetCachedGoalData();
            TransformData nextTd = nextGd.Transforms;
            UpdateTransformData(data, prevTd, nextTd, ref changedFull);
            OnDataReceived?.Invoke(prevTd, nextTd);
            SetExtrapolation(prevTd, nextTd, channel);

            bool hasChanged = HasChanged(prevTd, nextTd);
            //If server only teleport.
            if (asServer && !base.IsClient)
                SetInstantRates(nextGd.Rates);
            //Otherwise use timed.
            else
                SetCalculatedRates(prevTd.Tick, prevRd, prevTd, nextGd, changedFull, hasChanged, channel);

            _lastReceivedTransformData.Update(nextTd);

            _lastReceiveReliable = (channel == Channel.Reliable);
            /* If channel is reliable then this is a settled packet.
             * Reset last received tick so next starting move eases
             * in. */
            if (channel == Channel.Reliable)
                nextTd.Tick = 0;

            prevTd.Update(nextTd);
            prevRd.Update(nextGd.Rates);

            nextGd.ReceivedTick = base.TimeManager.LocalTick;

            /* If extrapolating then immediately break the extrapolation
            * in favor of newest results. This will keep the buffer
            * at 0 until the transform settles but the only other option is
            * to stop the movement, which would defeat purpose of extrapolation,
            * or slow down the transform while buffer rebuilds. Neither choice
            * is great but later on I might try slowing down the transform slightly
            * to give the buffer a chance to rebuild. */
            if (_currentGoalData.Transforms.ExtrapolationState == TransformData.ExtrapolateState.Active)
            {
                _queueReady = true;
                SetCurrentGoalData(nextGd);
            }
            /* If queue isn't started and its buffered enough
             * to satisfy interpolation then set ready
             * and set current data.
             * 
             * Also if reliable then begin moving. */
            else if (!_queueReady && _goalDataQueue.Count >= _interpolation
                || channel == Channel.Reliable)
            {
                _queueReady = true;
                if (_goalDataQueue.Count > 0)
                {
                    SetCurrentGoalData(_goalDataQueue.Dequeue());
                    /* If is reliable and has changed then also
                    * enqueue latest. */
                    if (hasChanged)
                        _goalDataQueue.Enqueue(nextGd);

                }
                else
                {
                    SetCurrentGoalData(nextGd);
                }
            }
            /* If here then there's not enough in buffer to begin
             * so add onto the buffer. */
            else
            {
                _goalDataQueue.Enqueue(nextGd);
            }

            /* If the queue is excessive beyond interpolation then
             * dequeue extras to prevent from dropping behind too
             * quickly. This shouldn't be an issue with normal movement
             * as the NT speeds up if the buffer unexpectedly grows, but
             * when connections are unstable results may come in chunks
             * and for a better experience the older parts of the chunks
             * will be dropped. */
            if (_goalDataQueue.Count > (_interpolation + 3))
            {
                while (_goalDataQueue.Count > _interpolation)
                {
                    GoalData tmpGd = _goalDataQueue.Dequeue();
                    _goalDataCache.Push(tmpGd);
                }
            }
        }

        /// <summary>
        /// Sets CurrentGoalData value.
        /// </summary>
        /// <param name="data"></param>
        private void SetCurrentGoalData(GoalData data)
        {
            _currentGoalData = data;
            OnNextGoal?.Invoke(data);
        }

        /// <summary>
        /// Immediately sets the parent of this NetworkTransform for a single connection.
        /// </summary>
        [TargetRpc]
        private void TargetSetParent(NetworkConnection conn, NetworkBehaviour parent)
        {
            
        }

        /// <summary>
        /// Updates a TransformData from packetData.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void UpdateTransformData(ArraySegment<byte> packetData, TransformData prevTransformData, TransformData nextTransformData, ref ChangedFull changedFull)
        {
            DeserializePacket(packetData, prevTransformData, nextTransformData, ref changedFull);
            nextTransformData.Tick = base.TimeManager.LastPacketTick;
        }

        /// <summary>
        /// Returns a GoalData from the cache.
        /// </summary>
        /// <returns></returns>
        private GoalData GetCachedGoalData()
        {
            GoalData result = (_goalDataCache.Count > 0) ? _goalDataCache.Pop() : new GoalData();
            result.Reset();
            return result;
        }

        /// <summary>
        /// Configures this NetworkTransform for CSP.
        /// </summary>
        internal void ConfigureForCSP()
        {
            _clientAuthoritative = false;
            _sendToOwner = false;
        }

        /// <summary>
        /// Updates which properties are synchronized.
        /// </summary>
        /// <param name="value">Properties to synchronize.</param>
        public void SetSynchronizedProperties(SynchronizedProperty value)
        {
            /* Make sure permissions are proper to change values.
             * Let the server override client auth. 
             *
             * Can send if server.
             * Or owner + client auth.
             */
            bool canSend = (
                base.IsServer ||
                (_clientAuthoritative && base.IsOwner)
                );

            if (!canSend)
                return;

            //If server send out observerRpc.
            if (base.IsServer)
                ObserversSetSynchronizedProperties(value);
            //Otherwise send to the server.
            else
                ServerSetSynchronizedProperties(value);
        }

        /// <summary>
        /// Sets synchronized values based on value.
        /// </summary>
        [ServerRpc]
        private void ServerSetSynchronizedProperties(SynchronizedProperty value)
        {
            /* Client is trying to be sneaky ...
             * a client should not be able to call this when NT isnt client auth. */
            if (!_clientAuthoritative)
                return;

            SetSynchronizedPropertiesInternal(value);
            ObserversSetSynchronizedProperties(value);
        }

        /// <summary>
        /// Sets synchronized values based on value.
        /// </summary>
        [ObserversRpc(BufferLast = true)]
        private void ObserversSetSynchronizedProperties(SynchronizedProperty value)
        {
            //Would have already run on server if host.
            if (base.IsServer)
                return;

            SetSynchronizedPropertiesInternal(value);
        }

        /// <summary>
        /// Sets synchronized values based on value.
        /// </summary>
        private void SetSynchronizedPropertiesInternal(SynchronizedProperty value)
        {
            _synchronizeParent = SynchronizedPropertyContains(value, SynchronizedProperty.Parent);
            _synchronizePosition = SynchronizedPropertyContains(value, SynchronizedProperty.Position);
            _synchronizeRotation = SynchronizedPropertyContains(value, SynchronizedProperty.Rotation);
            _synchronizeScale = SynchronizedPropertyContains(value, SynchronizedProperty.Scale);

            bool SynchronizedPropertyContains(SynchronizedProperty whole, SynchronizedProperty part)
            {
                return (whole & part) == part;
            }
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/NetworkTransform/SynchronizedProperty.cs ---
﻿namespace FishNet.Component.Transforming
{

    public enum SynchronizedProperty : byte
    {
        None = 0,
        Parent = 1,
        Position = 2,
        Rotation = 4,
        Scale = 8
    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/DesyncSmoother.cs ---
﻿using FishNet.Object;
using System;

namespace FishNet.Component.Prediction
{
    [Obsolete("DesyncSmoother is obsolete. Please remove this component and use PredictedObject on your gameObject's root.")] 
    //remove on 2023/01/01
    public class DesyncSmoother : NetworkBehaviour { }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/Editor/PredictedObjectEditor.cs ---
﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Component.Prediction
{

    [CustomEditor(typeof(PredictedObject), true)]
    [CanEditMultipleObjects]
    public class PredictedObjectEditor : Editor
    {
        private SerializedProperty _graphicalObject;
        private SerializedProperty _smoothTicks;
        private SerializedProperty _durationType;
        private SerializedProperty _smoothingDuration;
        private SerializedProperty _enableTeleport;
        private SerializedProperty _teleportThreshold;
        private SerializedProperty _predictionType;
        private SerializedProperty _rigidbody;
        private SerializedProperty _rigidbody2d;
        private SerializedProperty _networkTransform;
        private SerializedProperty _predictionRatio;

        protected virtual void OnEnable()
        {
            _graphicalObject = serializedObject.FindProperty("_graphicalObject");
            _smoothTicks = serializedObject.FindProperty("_smoothTicks");
            _durationType = serializedObject.FindProperty("_durationType");
            _smoothingDuration = serializedObject.FindProperty("_smoothingDuration");
            _enableTeleport = serializedObject.FindProperty("_enableTeleport");
            _teleportThreshold = serializedObject.FindProperty("_teleportThreshold");
            _predictionType = serializedObject.FindProperty("_predictionType");
            _rigidbody = serializedObject.FindProperty("_rigidbody");
            _rigidbody2d = serializedObject.FindProperty("_rigidbody2d");
            _networkTransform = serializedObject.FindProperty("_networkTransform");
            _predictionRatio = serializedObject.FindProperty("_predictionRatio");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((PredictedObject)target), typeof(PredictedObject), false);
            GUI.enabled = true;

            EditorGUILayout.PropertyField(_graphicalObject);
            EditorGUILayout.PropertyField(_smoothTicks);
            EditorGUILayout.PropertyField(_durationType);
            if ((PredictedObject.SmoothingDurationType)_durationType.intValue == PredictedObject.SmoothingDurationType.Time)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_smoothingDuration);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.PropertyField(_enableTeleport);
            if (_enableTeleport.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_teleportThreshold);
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.PropertyField(_predictionType);
            PredictedObject.PredictionType movementType = (PredictedObject.PredictionType)_predictionType.intValue;
            if (movementType != PredictedObject.PredictionType.Other)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.HelpBox("When using physics prediction do not include a NetworkTransform; this component will synchronize instead.", MessageType.Info);
                if (movementType == PredictedObject.PredictionType.Rigidbody)
                    EditorGUILayout.PropertyField(_rigidbody);
                else
                    EditorGUILayout.PropertyField(_rigidbody2d, new GUIContent("Rigidbody2D", "Rigidbody2D to predict."));
                EditorGUILayout.PropertyField(_predictionRatio);
                EditorGUI.indentLevel--;
            }
            else
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.HelpBox("When other is selected another component, such as NetworkTransform, must be used to synchronize.", MessageType.Info);
                EditorGUILayout.PropertyField(_networkTransform);
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.Space();
            serializedObject.ApplyModifiedProperties();
        }

    }
}
#endif

'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/OfflineRigidbody.cs ---
﻿using FishNet.Managing.Timing;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    public partial class OfflineRigidbody : MonoBehaviour
    {

        #region Serialized.
        /// <summary>
        /// Type of prediction movement which is being used.
        /// </summary>
        [Tooltip("Type of prediction movement which is being used.")]
        [SerializeField]
        private RigidbodyType _rigidbodyType;
        /// <summary>
        /// True to also get rigidbody components within children.
        /// </summary>
        [Tooltip("True to also get rigidbody components within children.")]
        [SerializeField]
        private bool _getInChildren;
        #endregion

        #region Private.
        /// <summary>
        /// Pauser for rigidbodies.
        /// </summary>
        private RigidbodyPauser _rigidbodyPauser = new RigidbodyPauser();
        /// <summary>
        /// TimeManager subscribed to.
        /// </summary>
        private TimeManager _timeManager;
        #endregion

        private void Awake()
        {
            InitializeOnce();
        }

        private void OnDestroy()
        {
            ChangeSubscription(false);
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void InitializeOnce()
        {
            _timeManager = InstanceFinder.TimeManager;
            UpdateRigidbodies();
            ChangeSubscription(true);
        }

        /// <summary>
        /// Sets a new TimeManager to use.
        /// </summary>
        /// <param name="tm"></param>
        public void SetTimeManager(TimeManager tm)
        {
            if (tm == _timeManager)
                return;

            //Unsub from current.
            ChangeSubscription(false);
            //Sub to newest.
            _timeManager = tm;
            ChangeSubscription(true);
        }

        /// <summary>
        /// Finds and assigns rigidbodie using configured settings.
        /// </summary>
        public void UpdateRigidbodies()
        {
            _rigidbodyPauser.UpdateRigidbodies(transform, _rigidbodyType, _getInChildren);
        }

        /// <summary>
        /// Changes the subscription to the TimeManager.
        /// </summary>
        private void ChangeSubscription(bool subscribe)
        {
            if (_timeManager == null)
                return;

            if (subscribe)
            {
                _timeManager.OnPreReconcile += _timeManager_OnPreReconcile;
                _timeManager.OnPostReconcile += _timeManager_OnPostReconcile;
            }
            else
            {
                _timeManager.OnPreReconcile -= _timeManager_OnPreReconcile;
                _timeManager.OnPostReconcile -= _timeManager_OnPostReconcile;
            }
        }

        private void _timeManager_OnPreReconcile(Object.NetworkBehaviour obj)
        {
            //Make rbs all kinematic/!simulated before reconciling, which would also result in replays.
            _rigidbodyPauser.ChangeKinematic(true);
        }

        private void _timeManager_OnPostReconcile(Object.NetworkBehaviour obj)
        {
            //After reconcile finishes set back to !kinematic/simulated.
            _rigidbodyPauser.ChangeKinematic(false);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/PredictedObject.Rigidbodies.cs ---
﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    public partial class PredictedObject : NetworkBehaviour
    {
        #region All.
        #region Internal.
        /// <summary>
        /// Number of instantiated PredictedObjects that are configured for rigidbodies.
        /// </summary>
        [APIExclude]
        [CodegenMakePublic] //To internal.
        public static int InstantiatedRigidbodyCountInternal { get; private set; }

        #endregion

        #region Private.
        /// <summary>
        /// Pauser for rigidbodies when they cannot be rolled back.
        /// </summary>
        private RigidbodyPauser _rigidbodyPauser = new RigidbodyPauser();
        #endregion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Rigidbodies_OnSpawnServer(NetworkConnection c)
        {
            if (!IsRigidbodyPrediction)
                return;
            if (c == base.Owner)
                return;

            if (_predictionType == PredictionType.Rigidbody)
                SendRigidbodyState(base.TimeManager.LocalTick, c);
            else
                SendRigidbody2DState(base.TimeManager.LocalTick, c);
        }

        /// <summary>
        /// Called after a tick occurs; physics would have simulated if using PhysicsMode.TimeManager.
        /// </summary>
        private void Rigidbodies_TimeManager_OnPostTick()
        {
            if (!IsRigidbodyPrediction)
                return;

            bool is2D = (_predictionType == PredictionType.Rigidbody2D);

            if (CanPredict())
            {
                if (!is2D)
                    PredictVelocity(gameObject.scene.GetPhysicsScene());
                else
                    PredictVelocity(gameObject.scene.GetPhysicsScene2D());
            }

            //if (base.IsServer)
            //{
            //    uint tick = base.TimeManager.Tick;
            //    if (tick >= _nextSendTick)
            //    {
            //        uint ticksRequired = base.TimeManager.TimeToTicks(SEND_INTERVAL, TickRounding.RoundUp);
            //        _nextSendTick = tick + ticksRequired;

            //        if (!is2D)
            //            SendRigidbodyState();
            //        else
            //            SendRigidbody2DState();
            //    }
            //}
        }

        /// <summary>
        /// Called before performing a reconcile on NetworkBehaviour.
        /// </summary>
        private void Rigidbodies_TimeManager_OnPreReconcile(NetworkBehaviour nb)
        {
            if (nb.gameObject == gameObject)
                return;
            if (!IsRigidbodyPrediction)
                return;

            bool is2D = (_predictionType == PredictionType.Rigidbody2D);
            uint lastStateTick = (is2D) ? _receivedRigidbody2DState.LastReplicateTick : _receivedRigidbodyState.LastReplicateTick;
            uint lastNbTick = nb.GetLastReconcileTick();

            /* If running again on the same reconcile or state is for a different
             * tick then do make RBs kinematic. Resetting to a different state
             * could cause a desync and there's no reason to run the same
             * tick twice. */
            if (lastStateTick != lastNbTick || lastStateTick == _lastResetTick)
            {
                _rigidbodyPauser.ChangeKinematic(true);
            }
            //If possible to perhaps reset.
            else
            {
                _lastResetTick = lastStateTick;
                /* If the reconciling nb won't change then
                 * there is no reason to rollback. */
                //if (!nb.TransformMayChange())
                //{
                //    _rigidbodyPauser.ChangeKinematic(true);
                //}
                //Need to reset / rollback.
                //else
                //{
                if (is2D)
                    ResetRigidbody2DToData();
                else
                    ResetRigidbodyToData();
                //}
            }
        }

        /// <summary>
        /// Called after performing a reconcile on a NetworkBehaviour.
        /// </summary>
        private void Rigidbodies_TimeManager_OnPostReconcile(NetworkBehaviour nb)
        {
            _rigidbodyPauser.ChangeKinematic(false);
        }

        /// <summary>
        /// Called before physics is simulated when replaying a replicate method.
        /// Contains the PhysicsScene and PhysicsScene2D which was simulated.
        /// </summary>
        private void Rigidbodies_TimeManager_OnPreReplicateReplay(PhysicsScene ps, PhysicsScene2D ps2d)
        {
            if (!CanPredict())
                return;

            if (_predictionType == PredictionType.Rigidbody)
                PredictVelocity(ps);
            else if (_predictionType == PredictionType.Rigidbody2D)
                PredictVelocity(ps2d);
        }

        /// <summary>
        /// Sends rigidbody state before reconciling for a network behaviour.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SendRigidbodyStatesInternal(NetworkBehaviour nb)
        {
            NetworkConnection owner = nb.Owner;
            if (!owner.IsActive)
                return;
            NetworkManager nm = nb.NetworkManager;
            if (nm == null)
                return;

            //Tell all predictedobjects for the networkmanager to try and send states.
            if (_predictedObjects.TryGetValue(nm, out List<PredictedObject> collection))
            {
                uint tick = nb.GetLastReplicateTick();
                int count = collection.Count;
                for (int i = 0; i < count; i++)
                    collection[i].TrySendRigidbodyState(nb, tick);
            }
        }

        /// <summary>
        /// Send current state to a connection.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void TrySendRigidbodyState(NetworkBehaviour nb, uint tick)
        {
            if (!IsRigidbodyPrediction)
                return;
            NetworkConnection nbOwner = nb.Owner;
            //No need to send to self.
            if (nbOwner == base.Owner)
                return;
            /* Not an observer. SendTargetRpc normally
             * already checks this when ValidateTarget
             * is true but we want to save perf by exiting
             * early before checks and serialization when
             * we know the conn is not an observer. */
            if (!base.Observers.Contains(nbOwner))
                return;

            //Only send if transform may change.
            if (!base.TransformMayChange())
                return;

            if (_predictionType == PredictionType.Rigidbody)
                SendRigidbodyState(tick, nbOwner);
            else
                SendRigidbody2DState(tick, nbOwner);
        }

        /// <summary>
        /// Tries to predict velocity for a Vector3.
        /// </summary>
        protected bool PredictVector3Velocity(ref float? velocityBaseline, ref Vector3 lastVelocity, Vector3 velocity, out Vector3 result)
        {
            float velocityDifference;
            float directionDifference;

            /* Velocity. */
            directionDifference = (velocityBaseline != null) ?
                Vector3.SqrMagnitude(lastVelocity.normalized - velocity.normalized) :
                0f;
            //If direction has changed too much then reset the baseline.
            if (directionDifference > 0.01f)
            {
                velocityBaseline = null;
            }
            //Direction hasn't changed enough to reset baseline.
            else
            {
                //Difference in velocity since last simulation.
                velocityDifference = Vector3.Magnitude(lastVelocity - velocity);
                //If there is no baseline.
                if (velocityBaseline == null)
                {
                    if (velocityDifference > 0)
                        velocityBaseline = velocityDifference;
                }
                //If there is a baseline.
                else
                {
                    //If the difference exceeds the baseline by 10% then reset baseline so another will be calculated.
                    if (velocityDifference > (velocityBaseline.Value * 1.1f) || velocityDifference < (velocityBaseline.Value * 0.9f))
                    {
                        velocityBaseline = null;
                    }
                    //Velocity difference is close enough to the baseline to where it doesn't need to be reset, so use prediction.
                    else
                    {
                        result = Vector3.Lerp(velocity, lastVelocity, _predictionRatio);
                        return true;
                    }
                }
            }

            //Fall through.
            result = Vector3.zero;
            return false;
        }

        /// <summary>
        /// Tries to predict velocity for a float.
        /// </summary>
        private bool PredictFloatVelocity(ref float? velocityBaseline, ref float lastVelocity, float velocity, out float result)
        {
            float velocityDifference;
            float directionDifference;

            /* Velocity. */
            directionDifference = (velocityBaseline != null) ? (velocity - lastVelocity) : 0f;

            //If direction has changed too much then reset the baseline.
            if (directionDifference > 0.01f)
            {
                velocityBaseline = null;
            }
            //Direction hasn't changed enough to reset baseline.
            else
            {
                //Difference in velocity since last simulation.
                velocityDifference = Mathf.Abs(lastVelocity - velocity);
                //If there is no baseline.
                if (velocityBaseline == null)
                {
                    if (velocityDifference > 0)
                        velocityBaseline = velocityDifference;
                }
                //If there is a baseline.
                else
                {
                    //If the difference exceeds the baseline by 10% then reset baseline so another will be calculated.
                    if (velocityDifference > (velocityBaseline.Value * 1.1f) || velocityDifference < (velocityBaseline.Value * 0.9f))
                    {
                        velocityBaseline = null;
                    }
                    //Velocity difference is close enough to the baseline to where it doesn't need to be reset, so use prediction.
                    else
                    {
                        result = Mathf.Lerp(velocity, lastVelocity, _predictionRatio);
                        return true;
                    }
                }
            }

            //Fall through.
            result = 0f;
            return false;
        }

        /// <summary>
        /// Returns if prediction can be used on this rigidbody.
        /// </summary>
        /// <returns></returns>
        private bool CanPredict()
        {
            if (!IsRigidbodyPrediction)
                return false;
            if (base.IsServer || base.IsOwner)
                return false;

            return true;
        }
        #endregion

        #region Rigidbody.
        #region Private.
        /// <summary>
        /// The last received Rigidbody2D state.
        /// </summary>
        private RigidbodyState _receivedRigidbodyState;
        /// <summary>
        /// Velocity from previous simulation.
        /// </summary>
        private Vector3 _lastVelocity;
        /// <summary>
        /// Angular velocity from previous simulation.
        /// </summary>
        private Vector3 _lastAngularVelocity;
        /// <summary>
        /// Baseline for velocity magnitude.
        /// </summary>
        private float? _velocityBaseline;
        /// <summary>
        /// Baseline for angular velocity magnitude.
        /// </summary>
        private float? _angularVelocityBaseline;
        /// <summary>
        /// PhysicsScene for this object when OnPreReconcile is called.
        /// </summary>
        private PhysicsScene _physicsScene;
        #endregion

        private void ResetRigidbodyToData()
        {
            RigidbodyState state = _receivedRigidbodyState;
            //Update transform and rigidbody.
            _rigidbody.transform.position = state.Position;
            _rigidbody.transform.rotation = state.Rotation;
            bool isKinematic = state.IsKinematic;
            _rigidbody.isKinematic = isKinematic;
            if (!isKinematic)
            {
                _rigidbody.velocity = state.Velocity;
                _rigidbody.angularVelocity = state.AngularVelocity;
            }

            /* Do not need to sync transforms because it's done internally by the reconcile method.
             * That is, so long as this is called using OnPreReconcile. */

            //Set prediction defaults.
            _velocityBaseline = null;
            _angularVelocityBaseline = null;
            _lastVelocity = _rigidbody.velocity;
            _lastAngularVelocity = _rigidbody.angularVelocity;
        }

        /// <summary>
        /// Sets the next predicted velocity on the rigidbody.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void PredictVelocity(PhysicsScene ps)
        {
            if (_predictionRatio <= 0f)
                return;
            if (ps != _physicsScene)
                return;

            Vector3 result;
            if (PredictVector3Velocity(ref _velocityBaseline, ref _lastVelocity, _rigidbody.velocity, out result))
                _rigidbody.velocity = result;
            if (PredictVector3Velocity(ref _angularVelocityBaseline, ref _lastAngularVelocity, _rigidbody.angularVelocity, out result))
                _rigidbody.angularVelocity = result;

            _lastVelocity = _rigidbody.velocity;
            _lastAngularVelocity = _rigidbody.angularVelocity;
        }

        /// <summary>
        /// Sends current states of this object to client.
        /// </summary>
        private void SendRigidbodyState(uint reconcileTick, NetworkConnection conn)
        {
            if (conn == base.Owner)
                return;

            RigidbodyState state = new RigidbodyState(_rigidbody, reconcileTick);
            TargetSendRigidbodyState(conn, state, false);
        }

        /// <summary>
        /// Sends transform and rigidbody state to spectators.
        /// </summary>
        [TargetRpc(ValidateTarget = false)]
        private void TargetSendRigidbodyState(NetworkConnection c, RigidbodyState state, bool applyImmediately, Channel channel = Channel.Unreliable)
        {
            if (!CanPredict())
                return;

            _receivedRigidbodyState = state;
            if (applyImmediately)
            {
                ResetRigidbodyToData();
                Physics.SyncTransforms();
            }
        }
        #endregion

        #region Rigidbody2D.
        #region Private.
        /// <summary>
        /// The last received Rigidbody2D state.
        /// </summary>
        private Rigidbody2DState _receivedRigidbody2DState;
        /// <summary>
        /// Velocity from previous simulation.
        /// </summary>
        private Vector3 _lastVelocity2D;
        /// <summary>
        /// Angular velocity from previous simulation.
        /// </summary>
        private float _lastAngularVelocity2D;
        /// <summary>
        /// Baseline for velocity magnitude.
        /// </summary>
        private float? _velocityBaseline2D;
        /// <summary>
        /// Baseline for angular velocity magnitude.
        /// </summary>
        private float? _angularVelocityBaseline2D;
        /// <summary>
        /// PhysicsScene for this object when OnPreReconcile is called.
        /// </summary>
        private PhysicsScene2D _physicsScene2D;
        /// <summary>
        /// The last tick rigidbodies were reset.
        /// </summary>
        private long _lastResetTick = -1;
        #endregion

        /// <summary>
        /// Resets the Rigidbody2D to last received data.
        /// </summary>
        private void ResetRigidbody2DToData()
        {
            Rigidbody2DState state = _receivedRigidbody2DState;
            //Update transform and rigidbody.
            _rigidbody2d.transform.position = state.Position;
            _rigidbody2d.transform.rotation = state.Rotation;
            bool simulated = state.Simulated;
            _rigidbody2d.simulated = simulated;
            _rigidbody2d.isKinematic = !simulated;
            if (simulated)
            {
                _rigidbody2d.velocity = state.Velocity;
                _rigidbody2d.angularVelocity = state.AngularVelocity;
            }

            /* Do not need to sync transforms because it's done internally by the reconcile method.
             * That is, so long as this is called using OnPreReconcile. */

            //Set prediction defaults.
            _velocityBaseline2D = null;
            _angularVelocityBaseline2D = null;
            _lastVelocity2D = _rigidbody2d.velocity;
            _lastAngularVelocity2D = _rigidbody2d.angularVelocity;
        }

        /// <summary>
        /// Sets the next predicted velocity on the rigidbody.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void PredictVelocity(PhysicsScene2D ps)
        {
            if (_predictionRatio <= 0f)
                return;
            if (ps != _physicsScene2D)
                return;

            Vector3 v3Result;
            if (PredictVector3Velocity(ref _velocityBaseline2D, ref _lastVelocity2D, _rigidbody2d.velocity, out v3Result))
                _rigidbody2d.velocity = v3Result;
            float floatResult;
            if (PredictFloatVelocity(ref _angularVelocityBaseline2D, ref _lastAngularVelocity2D, _rigidbody2d.angularVelocity, out floatResult))
                _rigidbody2d.angularVelocity = floatResult;

            _lastVelocity2D = _rigidbody2d.velocity;
            _lastAngularVelocity2D = _rigidbody2d.angularVelocity;
        }

        /// <summary>
        /// Sends current Rigidbody2D state to a connection.
        /// </summary>
        private void SendRigidbody2DState(uint reconcileTick, NetworkConnection conn)
        {
            Rigidbody2DState state = new Rigidbody2DState(_rigidbody2d, reconcileTick);
            TargetSendRigidbody2DState(conn, state, false);
        }

        /// <summary>
        /// Sends transform and rigidbody state to spectators.
        /// </summary>
        [TargetRpc(ValidateTarget = false)]
        private void TargetSendRigidbody2DState(NetworkConnection c, Rigidbody2DState state, bool applyImmediately, Channel channel = Channel.Unreliable)
        {
            if (!CanPredict())
                return;

            _receivedRigidbody2DState = state;
            if (applyImmediately)
            {
                ResetRigidbody2DToData();
                Physics2D.SyncTransforms();
            }
        }
        #endregion

    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/PredictedObject.cs ---
﻿using FishNet.Component.Transforming;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Object;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    [AddComponentMenu("FishNet/Component/PredictedObject")]
    public partial class PredictedObject : NetworkBehaviour
    {
        #region Types.
        private enum CollectionState : byte
        {
            Unset = 0,
            Added = 1,
            Removed = 2,
        }

        /// <summary>
        /// How to smooth. Over the tick duration or specified time.
        /// </summary>
        public enum SmoothingDurationType : byte
        {
            Tick = 0,
            Time = 1
        }
        /// <summary>
        /// Type of prediction movement being used.
        /// </summary>
        internal enum PredictionType : byte
        {
            Other = 0,
            Rigidbody = 1,
            Rigidbody2D = 2
        }
        #endregion

        #region Public.
        /// <summary>
        /// True if the prediction type is for a rigidbody.
        /// </summary>
        public bool IsRigidbodyPrediction => (_predictionType == PredictionType.Rigidbody || _predictionType == PredictionType.Rigidbody2D);
        #endregion

        #region Serialized.
        /// <summary>
        /// Transform which holds the graphical features of this object. This transform will be smoothed when desynchronizations occur.
        /// </summary>
        [Tooltip("Transform which holds the graphical features of this object. This transform will be smoothed when desynchronizations occur.")]
        [SerializeField]
        private Transform _graphicalObject;
        /// <summary>
        /// Gets GraphicalObject.
        /// </summary>
        public Transform GetGraphicalObject => _graphicalObject;
        /// <summary>
        /// Sets GraphicalObject.
        /// </summary>
        /// <param name="value"></param>
        public void SetGraphicalObject(Transform value) => _graphicalObject = value;
        /// <summary>
        /// True to smooth graphical object over tick durations. While true objects will be smooth even with low tick rates, but the visual representation will be behind one tick.
        /// </summary>
        [Tooltip("True to smooth graphical object over tick durations. While true objects will be smooth even with low tick rates, but the visual representation will be behind one tick.")]
        [SerializeField]
        private bool _smoothTicks = true;
        /// <summary>
        /// Gets the value for SmoothTicks.
        /// </summary>
        /// <returns></returns>
        public bool GetSmoothTicks() => _smoothTicks;
        /// <summary>
        /// Sets the value for SmoothTicks.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public void SetSmoothTicks(bool value) => _smoothTicks = value;
        /// <summary>
        /// How to smooth desynchronizations. Tick will smooth over the tick while Time will smooth over a set duration.
        /// </summary>
        [Tooltip("How to smooth desynchronizations. Tick will smooth over the tick while Time will smooth over a set duration.")]
        [SerializeField]
        private SmoothingDurationType _durationType = SmoothingDurationType.Tick;
        /// <summary>
        /// Duration to smooth desynchronizations over.
        /// </summary>
        [Tooltip("Duration to smooth desynchronizations over.")]
        [Range(0.01f, 0.5f)]
        [SerializeField]
        private float _smoothingDuration = 0.125f;
        /// <summary>
        /// True to enable teleport threshhold.
        /// </summary>
        [Tooltip("True to enable teleport threshhold.")]
        [SerializeField]
        private bool _enableTeleport;
        /// <summary>
        /// How far the transform must travel in a single update to cause a teleport rather than smoothing. Using 0f will teleport every update.
        /// </summary>
        [Tooltip("How far the transform must travel in a single update to cause a teleport rather than smoothing. Using 0f will teleport every update.")]
        [Range(0f, float.MaxValue)]
        [SerializeField]
        private float _teleportThreshold = 1f;
        /// <summary>
        /// Type of prediction movement which is being used.
        /// </summary>
        [Tooltip("Type of prediction movement which is being used.")]
        [SerializeField]
        private PredictionType _predictionType;
        /// <summary>
        /// Rigidbody to predict.
        /// </summary>
        [Tooltip("Rigidbody to predict.")]
        [SerializeField]
        private Rigidbody _rigidbody;
        /// <summary>
        /// Rigidbody2D to predict.
        /// </summary>
        [Tooltip("Rigidbody2D to predict.")]
        [SerializeField]
        private Rigidbody2D _rigidbody2d;
        /// <summary>
        /// NetworkTransform to configure.
        /// </summary>
        [Tooltip("NetworkTransform to configure.")]
        [SerializeField]
        private NetworkTransform _networkTransform;
        /// <summary>
        /// How much of the previous velocity to retain when predicting. Default value is 0f. Increasing this value may result in overshooting with rigidbodies that do not behave naturally, such as controllers or vehicles.
        /// </summary>
        [Tooltip("How much of the previous velocity to retain when predicting. Default value is 0f. Increasing this value may result in overshooting with rigidbodies that do not behave naturally, such as controllers or vehicles.")]
        [Range(0f, 1f)]
        [SerializeField]
        private float _predictionRatio = 0f;
        #endregion

        #region Private.
        /// <summary>
        /// True if subscribed to events.
        /// </summary>
        private bool _subscribed;
        /// <summary>
        /// World position before transform was predicted or reset.
        /// </summary>
        private Vector3 _previousPosition;
        /// <summary>
        /// World rotation before transform was predicted or reset.
        /// </summary>
        private Quaternion _previousRotation;
        /// <summary>
        /// Local position of transform when instantiated.
        /// </summary>
        private Vector3 _instantiatedLocalPosition;
        /// <summary>
        /// How quickly to move towards TargetPosition.
        /// </summary>
        private float _positionMoveRate = -2;
        /// <summary>
        /// Local rotation of transform when instantiated.
        /// </summary>
        private Quaternion _instantiatedLocalRotation;
        /// <summary>
        /// How quickly to move towards TargetRotation.
        /// </summary>
        private float _rotationMoveRate = -2;
        /// <summary>
        /// PredictedObjects that are spawned for each NetworkManager.
        /// Ideally PredictedObjects will be under the RollbackManager but that requires cross-linking assemblies which isn't possible.
        /// Until codegen can be made to run on the Runtime folder without breaking user code updates this will have to do.
        /// </summary>
        [System.NonSerialized]
        private static Dictionary<NetworkManager, List<PredictedObject>> _predictedObjects = new Dictionary<NetworkManager, List<PredictedObject>>();
        /// <summary>
        /// Current state of this PredictedObject within PredictedObjects collection.
        /// </summary>
        private CollectionState _collectionState = CollectionState.Unset;
        #endregion

        private struct MovedTracker
        {
            public uint LocalTick;
            public bool Moved;

            public MovedTracker(uint localTick, bool moved)
            {
                LocalTick = localTick;
                Moved = moved;
            }
        }

        private void Awake()
        {
            if (Application.isPlaying)
            {
                if (!InitializeOnce())
                {
                    this.enabled = false;
                    return;
                }
            }

            ConfigureRigidbodies();
            ConfigureNetworkTransform();
            //Set in awake so they are default.
            SetGraphicalPreviousProperties();
        }

        private void OnEnable()
        {
            /* Only subscribe if client. Client may not be set
             * yet but that's okay because the OnStartClient
             * callback will catch the subscription. This is here
             * should the user disable then re-enable the object after
             * it's initialized. */
            if (base.IsClient)
                ChangeSubscriptions(true);

            if (_predictionType != PredictionType.Other)
                InstantiatedRigidbodyCountInternal++;
        }
        private void OnDisable()
        {
            //Only unsubscribe if client.
            if (base.IsClient)
                ChangeSubscriptions(false);

            if (_predictionType != PredictionType.Other)
                InstantiatedRigidbodyCountInternal--;
        }

        public override void OnStartNetwork()
        {
            base.OnStartNetwork();

            if (base.IsServer)
            {
                _collectionState = CollectionState.Added;
                List<PredictedObject> collection;
                //Add new list to dictionary collection if needed.
                if (!_predictedObjects.TryGetValue(base.NetworkManager, out collection))
                {
                    collection = new List<PredictedObject>();
                    _predictedObjects.Add(base.NetworkManager, collection);
                }

                collection.Add(this);
            }

            base.TimeManager.OnPostTick += TimeManager_OnPostTick;
            _instantiatedLocalPosition = _graphicalObject.localPosition;
            _instantiatedLocalRotation = _graphicalObject.localRotation;
        }

        public override void OnSpawnServer(NetworkConnection connection)
        {
            base.OnSpawnServer(connection);
            Rigidbodies_OnSpawnServer(connection);
        }

        public override void OnStartClient()
        {
            base.OnStartClient();
            ChangeSubscriptions(true);
        }

        public override void OnStopClient()
        {
            base.OnStopClient();
            ChangeSubscriptions(false);
        }

        public override void OnStopNetwork()
        {
            base.OnStopNetwork();
            if (base.IsServer)
            {
                if (_collectionState == CollectionState.Added)
                {
                    if (_predictedObjects.TryGetValue(base.NetworkManager, out List<PredictedObject> collection))
                    {
                        _collectionState = CollectionState.Removed;
                        collection.Remove(this);
                        if (collection.Count == 0)
                            _predictedObjects.Remove(base.NetworkManager);
                    }
                }
            }

            if (base.TimeManager != null)
                base.TimeManager.OnPostTick -= TimeManager_OnPostTick;
        }

        private void OnDestroy()
        {
            RemoveFromPrefabObjects();
        }

        /// <summary>
        /// Removes this script from _predictedObjects.
        /// </summary>
        private void RemoveFromPrefabObjects()
        {
            //Already removed.
            if (_collectionState != CollectionState.Added)
                return;

            NetworkManager nm = base.NetworkManager;
            //If found then remove normally.
            if (nm != null)
            {
                if (_predictedObjects.TryGetValue(base.NetworkManager, out List<PredictedObject> collection))
                {
                    _collectionState = CollectionState.Removed;
                    collection.Remove(this);
                    if (collection.Count == 0)
                        _predictedObjects.Remove(base.NetworkManager);
                }
            }
            //NetworkManager isn't found, must check all entries. This would only happen if object didnt clean up from network properly.
            else
            {
                List<NetworkManager> removedEntries = new List<NetworkManager>();
                foreach (KeyValuePair<NetworkManager, List<PredictedObject>> item in _predictedObjects)
                {
                    NetworkManager key = item.Key;
                    if (key == null)
                    {
                        removedEntries.Add(key);
                    }
                    else
                    {
                        List<PredictedObject> collection = item.Value;
                        collection.Remove(this);
                        if (collection.Count == 0)
                            removedEntries.Add(key);
                    }
                }

                //Remove entries as needed.
                for (int i = 0; i < removedEntries.Count; i++)
                    _predictedObjects.Remove(removedEntries[i]);
            }
        }

        private void TimeManager_OnUpdate()
        {
            MoveToTarget();
        }

        private void TimeManager_OnPreTick()
        {

            if (CanSmooth())
            {
                /* Only snap to destination if using tick smoothing.
                 * This ensures the graphics will be at the proper location
                 * before the next movement rates are calculated. */
                if (_durationType == SmoothingDurationType.Tick)
                {
                    _graphicalObject.localPosition = _instantiatedLocalPosition;
                    _graphicalObject.localRotation = _instantiatedLocalRotation;
                }
                SetGraphicalPreviousProperties();
            }
        }

        protected void TimeManager_OnPostTick()
        {
            if (CanSmooth())
            {
                ResetGraphicalToPreviousProperties();
                SetGraphicalMoveRates();
            }
            Rigidbodies_TimeManager_OnPostTick();
        }

        /// <summary>
        /// Called before physics is simulated when replaying a replicate method.
        /// Contains the PhysicsScene and PhysicsScene2D which was simulated.
        /// </summary>
        protected virtual void TimeManager_OnPreReplicateReplay(PhysicsScene ps, PhysicsScene2D ps2d)
        {
            Rigidbodies_TimeManager_OnPreReplicateReplay(ps, ps2d);
        }

        /// <summary>
        /// Subscribes to events needed to function.
        /// </summary>
        /// <param name="subscribe"></param>
        private void ChangeSubscriptions(bool subscribe)
        {
            if (base.TimeManager == null)
                return;
            if (subscribe == _subscribed)
                return;

            if (subscribe)
            {
                base.TimeManager.OnUpdate += TimeManager_OnUpdate;
                base.TimeManager.OnPreTick += TimeManager_OnPreTick;
                base.TimeManager.OnPreReplicateReplay += TimeManager_OnPreReplicateReplay;
                base.TimeManager.OnPreReconcile += TimeManager_OnPreReconcile;
                base.TimeManager.OnPostReconcile += TimeManager_OnPostReconcile;
            }
            else
            {
                base.TimeManager.OnUpdate -= TimeManager_OnUpdate;
                base.TimeManager.OnPreTick -= TimeManager_OnPreTick;
                base.TimeManager.OnPreReplicateReplay -= TimeManager_OnPreReplicateReplay;
                base.TimeManager.OnPreReconcile -= TimeManager_OnPreReconcile;
                base.TimeManager.OnPostReconcile -= TimeManager_OnPostReconcile;
            }

            _subscribed = subscribe;
        }

        /// <summary>
        /// Called before performing a reconcile on NetworkBehaviour.
        /// </summary>
        private void TimeManager_OnPreReconcile(NetworkBehaviour nb)
        {
            Rigidbodies_TimeManager_OnPreReconcile(nb);
        }

        /// <summary>
        /// Called after performing a reconcile on a NetworkBehaviour.
        /// </summary>
        private void TimeManager_OnPostReconcile(NetworkBehaviour nb)
        {
            Rigidbodies_TimeManager_OnPostReconcile(nb);
        }

        /// <summary>
        /// Initializes this script for use. Returns true for success.
        /// </summary>
        private bool InitializeOnce()
        {
            //No graphical object, cannot smooth.
            if (_graphicalObject == null)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Error))
                    Debug.LogError($"GraphicalObject is not set on {gameObject.name}. Initialization will fail.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns if prediction can be used on this rigidbody.
        /// </summary>
        /// <returns></returns>
        private bool CanSmooth()
        {
            if (!_smoothTicks)
                return false;
            //Only client needs smoothing.
            if (base.IsServerOnly)
                return false;

            return true;
        }

        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        private void MoveToTarget()
        {
            //Not set, meaning movement doesnt need to happen or completed.
            if (_positionMoveRate == -2f && _rotationMoveRate == -2f)
                return;

            /* Only try to update properties if they have a valid move rate.
             * Properties may have 0f move rate if they did not change. */

            Transform t = _graphicalObject;
            float delta = Time.deltaTime;
            //Position.
            if (_positionMoveRate == -1f)
                t.localPosition = _instantiatedLocalPosition;
            else if (_positionMoveRate > 0f)
                t.localPosition = Vector3.MoveTowards(t.localPosition, _instantiatedLocalPosition, _positionMoveRate * delta);
            //Rotation.
            if (_rotationMoveRate == -1f)
                t.localRotation = _instantiatedLocalRotation;
            else if (_rotationMoveRate > 0f)
                t.localRotation = Quaternion.RotateTowards(t.localRotation, _instantiatedLocalRotation, _rotationMoveRate * delta);

            if (GraphicalObjectMatches(_instantiatedLocalPosition, _instantiatedLocalRotation))
            {
                _positionMoveRate = -2f;
                _rotationMoveRate = -2f;
            }
        }

        /// <summary>
        /// Sets Position and Rotation move rates to reach Target datas.
        /// </summary>
        private void SetGraphicalMoveRates()
        {
            float timeManagerDelta = (float)base.TimeManager.TickDelta;
            float delta = (_durationType == SmoothingDurationType.Tick) ? timeManagerDelta : _smoothingDuration;
            
            /* delta can never be faster than tick rate, otherwise the object will always 
             * get to smoothing goal before the next tick. */
            if (delta < timeManagerDelta)
                delta = timeManagerDelta;

            float distance;
            distance = Vector3.Distance(_instantiatedLocalPosition, _graphicalObject.localPosition);
            //If qualifies for teleporting.
            if (_enableTeleport && distance >= _teleportThreshold)
            {
                _positionMoveRate = -1f;
                _rotationMoveRate = -1f;
            }
            //Smoothing.
            else
            {
                _positionMoveRate = (distance / delta);
                distance = Quaternion.Angle(_instantiatedLocalRotation, _graphicalObject.localRotation);
                if (distance > 0f)
                    _rotationMoveRate = (distance / delta);
            }
        }

        /// <summary>
        /// Caches the transforms current position and rotation.
        /// </summary>
        private void SetGraphicalPreviousProperties()
        {
            _previousPosition = _graphicalObject.position;
            _previousRotation = _graphicalObject.rotation;
        }

        /// <summary>
        /// Resets the transform to cached position and rotation of the transform.
        /// </summary>
        private void ResetGraphicalToPreviousProperties()
        {
            _graphicalObject.SetPositionAndRotation(_previousPosition, _previousRotation);
        }

        /// <summary>
        /// Returns if this transform matches arguments.
        /// </summary>
        /// <returns></returns>
        protected bool GraphicalObjectMatches(Vector3 position, Quaternion rotation)
        {
            return (_graphicalObject.localPosition == position && _graphicalObject.localRotation == rotation);
        }

        /// <summary>
        /// Configures RigidbodyPauser with settings.
        /// </summary>
        private void ConfigureRigidbodies()
        {
            if (!IsRigidbodyPrediction)
                return;

            _rigidbodyPauser = new RigidbodyPauser();
            if (_predictionType == PredictionType.Rigidbody)
            {
                _rigidbody.collisionDetectionMode = CollisionDetectionMode.Continuous;
                _rigidbodyPauser.UpdateRigidbodies(transform, RigidbodyType.Rigidbody, true);
            }
            else
            {
                _rigidbody2d.collisionDetectionMode = CollisionDetectionMode2D.Continuous;
                _rigidbodyPauser.UpdateRigidbodies(transform, RigidbodyType.Rigidbody2D, true);
            }
        }

        /// <summary>
        /// Configures NetworkTransform for prediction.
        /// </summary>
        private void ConfigureNetworkTransform()
        {
            if (!IsRigidbodyPrediction)
                _networkTransform?.ConfigureForCSP();
        }

#if UNITY_EDITOR
        protected override void OnValidate()
        {
            if (_graphicalObject != null && _graphicalObject.parent == null)
            {
                Debug.LogError($"The graphical object may not be the root of the transform. Your graphical objects must be beneath your prediction scripts so that they may be smoothed independently during desynchronizations.");
                _graphicalObject = null;
                return;
            }

            ConfigureNetworkTransform();
        }
#endif
    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/PredictedRigidbody.cs ---
﻿using FishNet.Documenting;
using FishNet.Object;
using FishNet.Transporting;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    [AddComponentMenu("")]
    [APIExclude]
    [Obsolete("PredictedRigidbody is obsolete. Please remove this component and use PredictedObject on your gameObject's root.")] 
    //Remove on 2023/01/01
    public class PredictedRigidbody : PredictedRigidbodyBase { }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/PredictedRigidbody2D.cs ---
﻿using FishNet.Documenting;
using FishNet.Object;
using FishNet.Transporting;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    [AddComponentMenu("")]
    [APIExclude]
    [Obsolete("PredictedRigidbody2D is obsolete. Please remove this component and use PredictedObject on your gameObject's root.")]  
    //Remove on 2023/01/01
    public class PredictedRigidbody2D : PredictedRigidbodyBase { }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/PredictedRigidbodyBase.cs ---
﻿using FishNet.Documenting;
using FishNet.Managing.Timing;
using FishNet.Object;
using UnityEngine;

namespace FishNet.Component.Prediction
{

    /// <summary>
    /// Base class for predicting rigidbodies for non-owners.
    /// </summary>
    [AddComponentMenu("")]
    [APIExclude]
    public abstract class PredictedRigidbodyBase : MonoBehaviour { }  
    //Remove on 2023/01/01

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/RigidbodyPauser.cs ---
﻿using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    /// <summary>
    /// Pauses and unpauses rigidbodies. While paused rigidbodies cannot be interacted with or simulated.
    /// </summary>
    public class RigidbodyPauser
    {
        #region Types.
        /// <summary>
        /// Data for a rigidbody before being set kinematic.
        /// </summary>
        private struct RigidbodyData
        {
            /// <summary>
            /// Rigidbody for data.
            /// </summary>
            public Rigidbody Rigidbody;
            /// <summary>
            /// Cached velocity when being set kinematic.
            /// </summary>
            public Vector3 Velocity;
            /// <summary>
            /// Cached velocity when being set kinematic.
            /// </summary>
            public Vector3 AngularVelocity;

            public RigidbodyData(Rigidbody rigidbody)
            {
                Rigidbody = rigidbody;
                Rigidbody.collisionDetectionMode = CollisionDetectionMode.Continuous;
                Velocity = Vector3.zero;
                AngularVelocity = Vector3.zero;
            }
        }
        /// <summary>
        /// Data for a rigidbody2d before being set kinematic.
        /// </summary>
        private struct Rigidbody2DData
        {
            /// <summary>
            /// Rigidbody for data.
            /// </summary>
            public Rigidbody2D Rigidbody2d;
            /// <summary>
            /// Cached velocity when being set kinematic.
            /// </summary>
            public Vector2 Velocity;
            /// <summary>
            /// Cached velocity when being set kinematic.
            /// </summary>
            public float AngularVelocity;

            public Rigidbody2DData(Rigidbody2D rigidbody)
            {
                Rigidbody2d = rigidbody;
                Rigidbody2d.collisionDetectionMode = CollisionDetectionMode2D.Continuous;
                Velocity = Vector2.zero;
                AngularVelocity = 0f;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Last value set while calling ChangeKinematic.
        /// </summary>
        public bool LastChangeKinematicValue { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// Rigidbody datas for found rigidbodies.
        /// </summary>
        private List<RigidbodyData> _rigidbodyDatas = new List<RigidbodyData>();
        /// <summary>
        /// Rigidbody2D datas for found rigidbodies;
        /// </summary>
        private List<Rigidbody2DData> _rigidbody2dDatas = new List<Rigidbody2DData>();
        /// <summary>
        /// Colliders to disable and enable.
        /// </summary>
        private List<Collider> _colliders = new List<Collider>();
        /// <summary>
        /// Colliders2D to eable and disable.
        /// </summary>
        private List<Collider2D> _colliders2d = new List<Collider2D>();
        /// <summary>
        /// Type of prediction movement which is being used.
        /// </summary>
        private RigidbodyType _rigidbodyType;
        #endregion

        /// <summary>
        /// Assigns rigidbodies.
        /// </summary>
        /// <param name="rbs">Rigidbodies2D to use.</param>
        public void UpdateRigidbodies(Transform t, RigidbodyType rbType, bool getInChildren)
        {
            _rigidbodyType = rbType;
            _rigidbodyDatas.Clear();
            _rigidbody2dDatas.Clear();

            //3D.
            if (rbType == RigidbodyType.Rigidbody)
            {
                if (getInChildren)
                {
                    Rigidbody[] rbs = t.GetComponentsInChildren<Rigidbody>();
                    for (int i = 0; i < rbs.Length; i++)
                        _rigidbodyDatas.Add(new RigidbodyData(rbs[i]));
                }
                else
                {
                    Rigidbody rb = t.GetComponent<Rigidbody>();
                    if (rb != null)
                        _rigidbodyDatas.Add(new RigidbodyData(rb));
                }
            }
            //2D.
            else
            {
                if (getInChildren)
                {
                    Rigidbody2D[] rbs = t.GetComponentsInChildren<Rigidbody2D>();
                    for (int i = 0; i < rbs.Length; i++)
                        _rigidbody2dDatas.Add(new Rigidbody2DData(rbs[i]));
                }
                else
                {
                    Rigidbody2D rb = t.GetComponent<Rigidbody2D>();
                    if (rb != null)
                        _rigidbody2dDatas.Add(new Rigidbody2DData(rb));
                }
            }

            UpdateColliders(t, rbType, getInChildren);
        }

        /// <summary>
        /// Updates colliders on root and children depending upon settings.
        /// </summary>
        private void UpdateColliders(Transform t, RigidbodyType rbType, bool getInChildren)
        {
            _colliders.Clear();
            _colliders2d.Clear();

            //3D.
            if (rbType == RigidbodyType.Rigidbody)
            {
                Collider[] cs;
                if (getInChildren)
                    cs = t.GetComponentsInChildren<Collider>();
                else
                    cs = t.GetComponents<Collider>();

                foreach (Collider item in cs)
                {
                    //Only add if enabled. We do not want to toggle intentionally disabled colliders on.
                    if (item.enabled)
                        _colliders.Add(item);
                }
            }
            //2D.
            else
            {
                Collider2D[] cs;
                if (getInChildren)
                    cs = t.GetComponentsInChildren<Collider2D>();
                else
                    cs = t.GetComponents<Collider2D>();

                foreach (Collider2D item in cs)
                {
                    //Only add if enabled. We do not want to toggle intentionally disabled colliders on.
                    if (item.enabled)
                        _colliders2d.Add(item);
                }
            }
        }

        /// <summary>
        /// Changes IsKinematic for rigidbodies.
        /// </summary>
        /// <param name="isKinematic"></param>
        public void ChangeKinematic(bool isKinematic)
        {
            if (isKinematic == LastChangeKinematicValue)
                return;
            LastChangeKinematicValue = isKinematic;

            //3D.
            if (_rigidbodyType == RigidbodyType.Rigidbody)
            {
                //Enable or disable colliders.
                for (int i = 0; i < _colliders.Count; i++)
                    _colliders[i].enabled = !isKinematic;

                for (int i = 0; i < _rigidbodyDatas.Count; i++)
                {
                    if (!SetIsKinematic(i))
                    {
                        _rigidbodyDatas.RemoveAt(i);
                        i--;
                    }
                }

                //Sets isKinematic status and returns if successful.
                bool SetIsKinematic(int index)
                {
                    RigidbodyData rbData = _rigidbodyDatas[index];
                    Rigidbody rb = rbData.Rigidbody;
                    if (rb == null)
                        return false;

                    //IsKinematic.
                    if (isKinematic)
                    {
                        rbData.Velocity = rb.velocity;
                        rbData.AngularVelocity = rb.angularVelocity;
                        rb.isKinematic = true;
                        //Update data.
                        _rigidbodyDatas[index] = rbData;
                    }
                    else
                    {
                        rb.isKinematic = false;
                        rb.AddForce(rbData.Velocity, ForceMode.Impulse);
                        rb.AddTorque(rbData.AngularVelocity, ForceMode.Impulse);
                    }

                    return true;
                }
            }
            //2D.
            else
            {
                bool simulated = !isKinematic;
                //Enable or disable colliders.
                for (int i = 0; i < _colliders2d.Count; i++)
                    _colliders2d[i].enabled = simulated;

                for (int i = 0; i < _rigidbodyDatas.Count; i++)
                {
                    if (!SetSimulated(i))
                    {
                        _rigidbody2dDatas.RemoveAt(i);
                        i--;
                    }
                }

                //Sets isKinematic status and returns if successful.
                bool SetSimulated(int index)
                {
                    Rigidbody2DData rbData = _rigidbody2dDatas[index];
                    Rigidbody2D rb = rbData.Rigidbody2d;
                    if (rb == null)
                        return false;

                    if (!simulated)
                    {
                        rbData.Velocity = rb.velocity;
                        rbData.AngularVelocity = rb.angularVelocity;
                        rb.isKinematic = true;
                        rb.simulated = false;
                        //Update data.
                        _rigidbody2dDatas[index] = rbData;
                    }
                    else
                    {
                        rb.isKinematic = false;
                        rb.simulated = true;
                        rb.AddForce(rbData.Velocity, ForceMode2D.Impulse);
                        rb.AddTorque(rbData.AngularVelocity, ForceMode2D.Impulse);
                    }

                    return true;
                }
            }
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/RigidbodyState.cs ---
﻿using FishNet.Component.Prediction;
using FishNet.Serializing;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    public struct RigidbodyState
    {
        public uint LastReplicateTick;
        public Vector3 Position;
        public Quaternion Rotation;
        public bool IsKinematic;
        public Vector3 Velocity;
        public Vector3 AngularVelocity;

        public RigidbodyState(Rigidbody rb, uint tick)
        {
            Position = rb.transform.position;
            Rotation = rb.transform.rotation;
            IsKinematic = rb.isKinematic;
            Velocity = rb.velocity;
            AngularVelocity = rb.angularVelocity;
            LastReplicateTick = tick;
        }
    }

    public struct Rigidbody2DState
    {
        public uint LastReplicateTick;
        public Vector3 Position;
        public Quaternion Rotation;
        public bool Simulated;
        public Vector2 Velocity;
        public float AngularVelocity;

        public Rigidbody2DState(Rigidbody2D rb, uint tick)
        {
            Position = rb.transform.position;
            Rotation = rb.transform.rotation;
            Simulated = rb.simulated;
            Velocity = rb.velocity;
            AngularVelocity = rb.angularVelocity;
            LastReplicateTick = tick;
        }
    }
}

public static class RigidbodyStateSerializers
{

    public static void WriteRigidbodyState(this Writer writer, RigidbodyState value)
    {
        writer.WriteUInt32(value.LastReplicateTick, AutoPackType.Unpacked);
        writer.WriteVector3(value.Position);
        writer.WriteQuaternion(value.Rotation);
        writer.WriteBoolean(value.IsKinematic);
        if (!value.IsKinematic)
        {
            writer.WriteVector3(value.Velocity);
            writer.WriteVector3(value.AngularVelocity);
        }
    }

    public static RigidbodyState ReadRigidbodyState(this Reader reader)
    {
        RigidbodyState state = new RigidbodyState()
        {
            LastReplicateTick = reader.ReadUInt32(AutoPackType.Unpacked),
            Position = reader.ReadVector3(),
            Rotation = reader.ReadQuaternion(),
            IsKinematic = reader.ReadBoolean()
        };

        if (!state.IsKinematic)
        {
            state.Velocity = reader.ReadVector3();
            state.AngularVelocity = reader.ReadVector3();
        }

        return state;
    }

    public static void WriteRigidbody2DState(this Writer writer, Rigidbody2DState value)
    {
        writer.WriteUInt32(value.LastReplicateTick, AutoPackType.Unpacked);
        writer.WriteVector3(value.Position);
        writer.WriteQuaternion(value.Rotation);
        writer.WriteBoolean(value.Simulated);

        if (value.Simulated)
        {
            writer.WriteVector3(value.Velocity);
            writer.WriteSingle(value.AngularVelocity);
        }
    }

    public static Rigidbody2DState ReadRigidbody2DState(this Reader reader)
    {
        Rigidbody2DState state = new Rigidbody2DState()
        {
            LastReplicateTick = reader.ReadUInt32(AutoPackType.Unpacked),
            Position = reader.ReadVector3(),
            Rotation = reader.ReadQuaternion(),
            Simulated = reader.ReadBoolean(),
        };

        if (state.Simulated)
        {
            state.Velocity = reader.ReadVector3();
            state.AngularVelocity = reader.ReadSingle();
        }

        return state;
    }

}

'''
'''--- Assets/FishNet/Runtime/Generated/Component/Prediction/RigidbodyType.cs ---
﻿namespace FishNet.Component.Prediction
{
    /// <summary>
    /// Type of prediction movement being used.
    /// </summary>
    public enum RigidbodyType : byte
    {
        Rigidbody = 0,
        Rigidbody2D = 1
    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Spawning/PlayerSpawner.cs ---
﻿using FishNet.Connection;
using FishNet.Managing;
using FishNet.Object;
using System;
using UnityEngine;
using UnityEngine.Serialization;

namespace FishNet.Component.Spawning
{

    /// <summary>
    /// Spawns a player object for clients when they connect.
    /// Must be placed on or beneath the NetworkManager object.
    /// </summary>
    [AddComponentMenu("FishNet/Component/PlayerSpawner")]
    public class PlayerSpawner : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called on the server when a player is spawned.
        /// </summary>
        public event Action<NetworkObject> OnSpawned;
        #endregion

        #region Serialized.
        /// <summary>
        /// Prefab to spawn for the player.
        /// </summary>
        [Tooltip("Prefab to spawn for the player.")]
        [SerializeField]
        private NetworkObject _playerPrefab;
        /// <summary>
        /// True to add player to the active scene when no global scenes are specified through the SceneManager.
        /// </summary>
        [Tooltip("True to add player to the active scene when no global scenes are specified through the SceneManager.")]
        [SerializeField]
        private bool _addToDefaultScene = true;
        /// <summary>
        /// Areas in which players may spawn.
        /// </summary>
        [Tooltip("Areas in which players may spawn.")]
        [FormerlySerializedAs("_spawns")]
        public Transform[] Spawns = new Transform[0];
        #endregion

        #region Private.
        /// <summary>
        /// NetworkManager on this object or within this objects parents.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Next spawns to use.
        /// </summary>
        private int _nextSpawn;
        #endregion

        private void Start()
        {
            InitializeOnce();
        }

        private void OnDestroy()
        {
            if (_networkManager != null)
                _networkManager.SceneManager.OnClientLoadedStartScenes -= SceneManager_OnClientLoadedStartScenes;
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void InitializeOnce()
        {
            _networkManager = InstanceFinder.NetworkManager;
            if (_networkManager == null)
            {
                Debug.LogWarning($"PlayerSpawner on {gameObject.name} cannot work as NetworkManager wasn't found on this object or within parent objects.");
                return;
            }

            _networkManager.SceneManager.OnClientLoadedStartScenes += SceneManager_OnClientLoadedStartScenes;
        }

        /// <summary>
        /// Called when a client loads initial scenes after connecting.
        /// </summary>
        private void SceneManager_OnClientLoadedStartScenes(NetworkConnection conn, bool asServer)
        {
            if (!asServer)
                return;
            if (_playerPrefab == null)
            {
                Debug.LogWarning($"Player prefab is empty and cannot be spawned for connection {conn.ClientId}.");
                return;
            }

            Vector3 position;
            Quaternion rotation;
            SetSpawn(_playerPrefab.transform, out position, out rotation);

            NetworkObject nob = _networkManager.GetPooledInstantiated(_playerPrefab, true);
            nob.transform.SetPositionAndRotation(position, rotation);
            _networkManager.ServerManager.Spawn(nob, conn);

            //If there are no global scenes 
            if (_addToDefaultScene)
                _networkManager.SceneManager.AddOwnerToDefaultScene(nob);

            OnSpawned?.Invoke(nob);
        }

        /// <summary>
        /// Sets a spawn position and rotation.
        /// </summary>
        /// <param name="pos"></param>
        /// <param name="rot"></param>
        private void SetSpawn(Transform prefab, out Vector3 pos, out Quaternion rot)
        {
            //No spawns specified.
            if (Spawns.Length == 0)
            {
                SetSpawnUsingPrefab(prefab, out pos, out rot);
                return;
            }

            Transform result = Spawns[_nextSpawn];
            if (result == null)
            {
                SetSpawnUsingPrefab(prefab, out pos, out rot);
            }
            else
            {
                pos = result.position;
                rot = result.rotation;
            }

            //Increase next spawn and reset if needed.
            _nextSpawn++;
            if (_nextSpawn >= Spawns.Length)
                _nextSpawn = 0;
        }

        /// <summary>
        /// Sets spawn using values from prefab.
        /// </summary>
        /// <param name="prefab"></param>
        /// <param name="pos"></param>
        /// <param name="rot"></param>
        private void SetSpawnUsingPrefab(Transform prefab, out Vector3 pos, out Quaternion rot)
        {
            pos = prefab.position;
            rot = prefab.rotation;
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Utility/BandwidthDisplay.cs ---
﻿using FishNet.Managing.Statistic;
using UnityEngine;

namespace FishNet.Component.Utility
{
    /// <summary>
    /// Add to any object to display current ping(round trip time).
    /// </summary>
    [AddComponentMenu("FishNet/Component/BandwidthDisplay")]
    public class BandwidthDisplay : MonoBehaviour
    {
        #region Types.
        private enum Corner
        {
            TopLeft,
            TopRight,
            BottomLeft,
            BottomRight
        }
        #endregion

        #region Serialized.
        /// <summary>
        /// Color for text.
        /// </summary>
        [Tooltip("Color for text.")]
        [SerializeField]
        private Color _color = Color.white;
        /// <summary>
        /// Which corner to display network statistics in.
        /// </summary>
        [Tooltip("Which corner to display network statistics in.")]
        [SerializeField]
        private Corner _placement = Corner.TopRight;
        /// <summary>
        /// rue to show outgoing data bytes.
        /// </summary>
        [Tooltip("True to show outgoing data bytes.")]
        [SerializeField]
        private bool _showOutgoing = true;
        /// <summary>
        /// Sets ShowOutgoing value.
        /// </summary>
        /// <param name="value"></param>
        public void SetShowOutgoing(bool value) => _showOutgoing = value;
        /// <summary>
        /// True to show incoming data bytes.
        /// </summary>
        [Tooltip("True to show incoming data bytes.")]
        [SerializeField]
        private bool _showIncoming = true;
        /// <summary>
        /// Sets ShowIncoming value.
        /// </summary>
        /// <param name="value"></param>
        public void SetShowIncoming(bool value) => _showIncoming = value;
        #endregion

        #region Private.
        /// <summary>
        /// Style for drawn ping.
        /// </summary>
        private GUIStyle _style = new GUIStyle();
        /// <summary>
        /// Text to display OnGui.
        /// </summary>
        private string _displayedText;
        /// <summary>
        /// First found NetworkTrafficStatistics.
        /// </summary>
        private NetworkTraficStatistics _networkTrafficStatistics;
        #endregion

        private void Start()
        {
            _networkTrafficStatistics = InstanceFinder.NetworkManager.StatisticsManager.NetworkTraffic;
            _networkTrafficStatistics.OnClientNetworkTraffic += NetworkTraffic_OnClientNetworkTraffic;
            if (!_networkTrafficStatistics.UpdateClient && !_networkTrafficStatistics.UpdateServer)
                Debug.LogWarning($"StatisticsManager.NetworkTraffic is not updating for client nor server. To see results ensure your NetworkManager has a StatisticsManager component added with the NetworkTraffic values configured.");
        }

        private void OnDestroy()
        {
            if (_networkTrafficStatistics != null)
                _networkTrafficStatistics.OnClientNetworkTraffic -= NetworkTraffic_OnClientNetworkTraffic;
        }

        /// <summary>
        /// Called when client network traffic is updated.
        /// </summary>
        private void NetworkTraffic_OnClientNetworkTraffic(NetworkTrafficArgs obj)
        {
            string nl = System.Environment.NewLine;
            string result = string.Empty;
            if (_showIncoming)
                result += $"In: {NetworkTraficStatistics.FormatBytesToLargest(obj.FromServerBytes)}/s{nl}";
            if (_showOutgoing)
                result += $"Out: {NetworkTraficStatistics.FormatBytesToLargest(obj.ToServerBytes)}/s{nl}";

            _displayedText = result;
        }

        private void OnGUI()
        {
            //No need to perform these actions on server.
#if !UNITY_EDITOR && UNITY_SERVER
            return;
#endif

            _style.normal.textColor = _color;
            _style.fontSize = 15;
            float width = 100f;
            float height = 0f;
            if (_showIncoming)
                height += 15f;
            if (_showOutgoing)
                height += 15f;

            float edge = 10f;

            float horizontal;
            float vertical;

            if (_placement == Corner.TopLeft)
            {
                horizontal = 10f;
                vertical = 10f;
            }
            else if (_placement == Corner.TopRight)
            {
                horizontal = Screen.width - width - edge;
                vertical = 10f;
            }
            else if (_placement == Corner.BottomLeft)
            {
                horizontal = 10f;
                vertical = Screen.height - height - edge;
            }
            else
            {
                horizontal = Screen.width - width - edge;
                vertical = Screen.height - height - edge;
            }

            GUI.Label(new Rect(horizontal, vertical, width, height), _displayedText, _style);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/Component/Utility/DefaultScene.cs ---
﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Scened;
using FishNet.Transporting;
using FishNet.Utility;
using System.IO;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnitySceneManager = UnityEngine.SceneManagement.SceneManager;

/// <summary>
/// Add to a NetworkManager object to change between Online and Offline scene based on connection states of the server or client.
/// </summary>
[AddComponentMenu("FishNet/Component/DefaultScene")]
public class DefaultScene : MonoBehaviour
{

    #region Serialized.
    /// <summary>
    /// True to replace all scenes with the offline scene immediately.
    /// </summary>
    [Tooltip("True to replace all scenes with the offline scene immediately.")]
    [SerializeField]
    private bool _startInOffline;
    /// <summary>
    /// Scene to load when disconnected. Server and client will load this scene.
    /// </summary>
    [Tooltip("Scene to load when disconnected. Server and client will load this scene.")]
    [SerializeField, Scene]
    private string _offlineScene;
    /// <summary>
    /// Sets which offline scene to use.
    /// </summary>
    /// <param name="sceneName">Scene name to use as the offline scene.</param>
    public void SetOfflineScene(string sceneName) => _offlineScene = sceneName;
    /// <summary>
    /// Scene to load when connected. Server and client will load this scene.
    /// </summary>
    [Tooltip("Scene to load when connected. Server and client will load this scene.")]
    [SerializeField, Scene]
    private string _onlineScene;
    /// <summary>
    /// Sets which online scene to use.
    /// </summary>
    /// <param name="sceneName">Scene name to use as the online scene.</param>
    public void SetOnlineScene(string sceneName) => _onlineScene = sceneName;
    /// <summary>
    /// Which scenes to replace when loading into OnlineScene.
    /// </summary>
    [Tooltip("Which scenes to replace when loading into OnlineScene.")]
    [SerializeField]
    private ReplaceOption _replaceScenes = ReplaceOption.All;
    #endregion

    #region Private.
    /// <summary>
    /// NetworkManager for this component.
    /// </summary>
    private NetworkManager _networkManager;
    #endregion

    private void Awake()
    {
        InitializeOnce();
    }

    private void OnDestroy()
    {

        if (!ApplicationState.IsQuitting() && _networkManager != null && _networkManager.Initialized)
        {
            _networkManager.ClientManager.OnClientConnectionState -= ClientManager_OnClientConnectionState;
            _networkManager.ServerManager.OnServerConnectionState -= ServerManager_OnServerConnectionState;
            _networkManager.SceneManager.OnLoadEnd -= SceneManager_OnLoadEnd;
        }
    }

    /// <summary>
    /// Initializes this script for use.
    /// </summary>
    private void InitializeOnce()
    {
        _networkManager = GetComponentInParent<NetworkManager>();
        if (_networkManager == null)
        {
            if (NetworkManager.StaticCanLog(LoggingType.Error))
                Debug.LogError($"NetworkManager not found on {gameObject.name} or any parent objects. DefaultScene will not work.");
            return;
        }
        //A NetworkManager won't be initialized if it's being destroyed.
        if (!_networkManager.Initialized)
            return;
        if (_onlineScene == string.Empty || _offlineScene == string.Empty)
        {
            if (_networkManager.CanLog(LoggingType.Warning))
                Debug.LogWarning("Online or Offline scene is not specified. Default scenes will not load.");
            return;
        }

        _networkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;
        _networkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
        _networkManager.SceneManager.OnLoadEnd += SceneManager_OnLoadEnd;
        if (_startInOffline)
            LoadOfflineScene();
    }

    /// <summary>
    /// Called when a scene load ends.
    /// </summary>
    private void SceneManager_OnLoadEnd(SceneLoadEndEventArgs obj)
    {
        bool onlineLoaded = false;
        foreach (Scene s in obj.LoadedScenes)
        {
            if (s.name == GetSceneName(_onlineScene))
            {
                onlineLoaded = true;
                break;
            }
        }

        //If online scene was loaded then unload offline.
        if (onlineLoaded)
            UnloadOfflineScene();
    }

    /// <summary>
    /// Called after the local server connection state changes.
    /// </summary>
    private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
    {
        /* When server starts load online scene as global.
         * Since this is a global scene clients will automatically
         * join it when connecting. */
        if (obj.ConnectionState == LocalConnectionState.Started)
        {
            /* If not exactly one server is started then
             * that means either none are started, which isnt true because
             * we just got a started callback, or two+ are started.
             * When a server has already started there's no reason to load
             * scenes again. */
            if (!_networkManager.ServerManager.OneServerStarted())
                return;

            //If here can load scene.
            SceneLoadData sld = new SceneLoadData(GetSceneName(_onlineScene));
            sld.ReplaceScenes = _replaceScenes;
            _networkManager.SceneManager.LoadGlobalScenes(sld);
        }
        //When server stops load offline scene.
        else if (obj.ConnectionState == LocalConnectionState.Stopped)
        {
            LoadOfflineScene();
        }
    }

    /// <summary>
    /// Called after the local client connection state changes.
    /// </summary>
    private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
    {
        if (obj.ConnectionState == LocalConnectionState.Stopped)
        {
            //Only load offline scene if not also server.
            if (!_networkManager.IsServer)
                LoadOfflineScene();
        }
    }

    /// <summary>
    /// Loads offlineScene as single.
    /// </summary>
    private void LoadOfflineScene()
    {
        //Already in offline scene.
        if (UnitySceneManager.GetActiveScene().name == GetSceneName(_offlineScene))
            return;
        //Only use scene manager if networking scenes. I may add something in later to do both local and networked.
        UnitySceneManager.LoadScene(_offlineScene);
    }

    /// <summary>
    /// Unloads the offline scene.
    /// </summary>
    private void UnloadOfflineScene()
    {
        Scene s = UnitySceneManager.GetSceneByName(GetSceneName(_offlineScene));
        if (string.IsNullOrEmpty(s.name))
            return;

        UnitySceneManager.UnloadSceneAsync(s);
    }

    /// <summary>
    /// Returns a scene name from fullPath.
    /// </summary>
    /// <param name="fullPath"></param>
    /// <returns></returns>
    private string GetSceneName(string fullPath)
    {
        return Path.GetFileNameWithoutExtension(fullPath);
    }
}

'''
'''--- Assets/FishNet/Runtime/Generated/Component/Utility/PingDisplay.cs ---
﻿using FishNet.Managing.Timing;
using UnityEngine;

namespace FishNet.Component.Utility
{
    /// <summary>
    /// Add to any object to display current ping(round trip time).
    /// </summary>
    [AddComponentMenu("FishNet/Component/PingDisplay")]
    public class PingDisplay : MonoBehaviour
    {
        #region Types.
        private enum Corner
        {
            TopLeft,
            TopRight,
            BottomLeft,
            BottomRight
        }
        #endregion

        #region Serialized.
        /// <summary>
        /// Color for text.
        /// </summary>
        [Tooltip("Color for text.")]
        [SerializeField]
        private Color _color = Color.white;
        /// <summary>
        /// Which corner to display ping in.
        /// </summary>
        [Tooltip("Which corner to display ping in.")]
        [SerializeField]
        private Corner _placement = Corner.TopRight;
        /// <summary>
        /// True to show the real ping. False to include tick rate latency within the ping.
        /// </summary>
        [Tooltip("True to show the real ping. False to include tick rate latency within the ping.")]
        [SerializeField]
        private bool _hideTickRate = true;
        #endregion

        #region Private.
        /// <summary>
        /// Style for drawn ping.
        /// </summary>
        private GUIStyle _style = new GUIStyle();
        #endregion

        private void OnGUI()
        {
            //No need to perform these actions on server.
#if !UNITY_EDITOR && UNITY_SERVER
            return;
#endif

            //Only clients can see pings.
            if (!InstanceFinder.IsClient)
                return;

            _style.normal.textColor = _color;
            _style.fontSize = 15;
            float width = 85f;
            float height = 15f;
            float edge = 10f;

            float horizontal;
            float vertical;

            if (_placement == Corner.TopLeft)
            {
                horizontal = 10f;
                vertical = 10f;
            }
            else if (_placement == Corner.TopRight)
            {
                horizontal = Screen.width - width - edge;
                vertical = 10f;
            }
            else if (_placement == Corner.BottomLeft)
            {
                horizontal = 10f;
                vertical = Screen.height - height - edge;
            }
            else
            {
                horizontal = Screen.width - width - edge;
                vertical = Screen.height - height - edge;
            }

            long ping;
            TimeManager tm = InstanceFinder.TimeManager;
            if (tm == null)
            {
                ping = 0;
            }
            else
            {
                ping = tm.RoundTripTime;
                long deduction = 0;
                if (_hideTickRate)
                {
                    deduction = (long)(tm.TickDelta * 1000d);
                    /* If host subtract two ticks, if client only subtract one tick.
                    * This will reflect the users real ping without the tick rate latency. */
                    if (InstanceFinder.IsHost)
                        deduction *= 2;
                }

                ping = (long)Mathf.Max(0, ping - deduction);
            }

            GUI.Label(new Rect(horizontal, vertical, width, height), $"Ping: {ping}ms", _style);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Generated/ReaderAndWriters/ConnectionReaderWriters.cs ---
﻿using FishNet.Documenting;
using FishNet.Managing.Server;
using FishNet.Serializing;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace FishNet.Runtime
{
    [APIExclude]
    [StructLayout(LayoutKind.Auto, CharSet = CharSet.Auto)]
    public static class ConnectionReadersAndWriters
    {
        public static void WriteClientConnectionChangeBroadcast(this Writer writer, ClientConnectionChangeBroadcast value)
        {
            writer.WriteBoolean(value.Connected);
            writer.WriteNetworkConnectionId((short)value.Id);
        }

        public static ClientConnectionChangeBroadcast ReadClientConnectionChangeBroadcast(this Reader reader)
        {
            return new ClientConnectionChangeBroadcast()
            {
                Connected = reader.ReadBoolean(),
                Id = reader.ReadNetworkConnectionId()
            };
        }

        public static void WriteConnectedClientsBroadcast(this Writer writer, ConnectedClientsBroadcast value)
        {
            ushort count = (ushort)value.ListCache.Written;
            writer.WriteUInt16(count);

            List<int> collection = value.ListCache.Collection;
            for (int i = 0; i < count; i++)
                writer.WriteNetworkConnectionId((short)collection[i]);
        }

        public static ConnectedClientsBroadcast ReadConnectedClientsBroadcast(this Reader reader)
        {
            int count = reader.ReadUInt16();
            List<int> collection = new List<int>(count);
            ConnectedClientsBroadcast result = new ConnectedClientsBroadcast()
            {
                Ids = collection 
            };

            for (int i = 0; i < count; i++)
                collection.Add(reader.ReadNetworkConnectionId());

            return result;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Generated/ReaderAndWriters/ScenedReaderWriters.cs ---
﻿// Decompiled with JetBrains decompiler
// Type: FishNet.Runtime.ScenedReadersAndWriters
// Assembly: FishNet.Runtime, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 398967D9-11C0-455C-B750-DCE87EFCCBEC
// Assembly location: D:DevelopmentPersonalFishNetsFishNet - DeveloperLibraryScriptAssembliesFishNet.Runtime.dll

using FishNet.Documenting;
using FishNet.Managing.Scened;
using FishNet.Object;
using FishNet.Serializing;
using System;
using System.Runtime.InteropServices;
using UnityEngine;

namespace FishNet.Runtime
{
    [APIExclude]
    [StructLayout(LayoutKind.Auto, CharSet = CharSet.Auto)]
    public static class ScenedReadersAndWriters
    {

        public static void Write___FishNetu002EManagingu002EScenedu002EBroadcastu002ELoadScenesBroadcast(
          this Writer writer,
          LoadScenesBroadcast value)
        {
            ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadQueueData(writer, value.QueueData);
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadQueueData(
          this Writer writer,
          LoadQueueData value)
        {
            if (value == null)
            {
                writer.WriteBoolean(true);
            }
            else
            {
                writer.WriteBoolean(false);
                ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLoadData(writer, value.SceneLoadData);
                ScenedReadersAndWriters.Write___Systemu002EStringu005Bu005D(writer, value.GlobalScenes);
            }
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLoadData(
          this Writer writer,
          SceneLoadData value)
        {
            if (value == null)
            {
                writer.WriteBoolean(true);
            }
            else
            {
                writer.WriteBoolean(false);
                ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D(writer, value.SceneLookupDatas);
                ScenedReadersAndWriters.Write___FishNetu002EObjectu002ENetworkObjectu005Bu005D(writer, value.MovedNetworkObjects);
                writer.WriteByte((byte)value.ReplaceScenes);
                ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadParams(writer, value.Params);
                ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadOptions(writer, value.Options);
            }
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D(
          this Writer writer,
          SceneLookupData[] value)
        {
            if (value == null)
            {
                int num = -1;
                writer.WritePackedWhole((ulong)(uint)num);
            }
            else
            {
                int length = value.Length;
                writer.WritePackedWhole((ulong)(uint)length);
                for (int index = 0; index < length; ++index)
                    ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupData(writer, value[index]);
            }
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupData(
          this Writer writer,
          SceneLookupData value)
        {
            if ((object)value == null)
            {
                writer.WriteBoolean(true);
            }
            else
            {
                writer.WriteBoolean(false);
                writer.WriteInt32(value.Handle);
                writer.WriteString(value.Name);
            }
        }

        public static void Write___FishNetu002EObjectu002ENetworkObjectu005Bu005D(
          this Writer writer,
          NetworkObject[] value)
        {
            if (value == null)
            {
                int num = -1;
                writer.WritePackedWhole((ulong)(uint)num);
            }
            else
            {
                int length = value.Length;
                writer.WritePackedWhole((ulong)(uint)length);
                for (int index = 0; index < length; ++index)
                    writer.WriteNetworkObject(value[index]);
            }
        }

        public static void Write___EmptyStartScenesBroadcast(this Writer write, EmptyStartScenesBroadcast value) { }
        public static EmptyStartScenesBroadcast Read___EmptyStartScenesBroadcast(this Reader reader) { return new EmptyStartScenesBroadcast(); }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadParams(
          this Writer writer,
          LoadParams value)
        {
            if (value == null)
            {
                writer.WriteBoolean(true);
            }
            else
            {
                writer.WriteBoolean(false);
                writer.WriteBytesAndSize(value.ClientParams);
            }
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadOptions(
          this Writer writer,
          LoadOptions value)
        {
            if (value == null)
                writer.WriteBoolean(true);
            else
                writer.WriteBoolean(false);
        }

        public static void Write___Systemu002EStringu005Bu005D(this Writer writer, string[] value)
        {
            if (value == null)
            {
                int num = -1;
                writer.WritePackedWhole((ulong)(uint)num);
            }
            else
            {
                int length = value.Length;
                writer.WritePackedWhole((ulong)(uint)length);
                for (int index = 0; index < length; ++index)
                    writer.WriteString(value[index]);
            }
        }

        public static LoadScenesBroadcast Read___FishNetu002EManagingu002EScenedu002EBroadcastu002ELoadScenesBroadcast(
          this Reader reader)
        {
            return new LoadScenesBroadcast()
            {
                QueueData = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadQueueData(reader)
            };
        }

        public static LoadQueueData Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadQueueData(
          this Reader reader)
        {
            if (reader.ReadBoolean())
                return (LoadQueueData)null;
            return new LoadQueueData()
            {
                SceneLoadData = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLoadData(reader),
                GlobalScenes = ScenedReadersAndWriters.Read___Systemu002EStringu005Bu005D(reader)
            };
        }

        public static SceneLoadData Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLoadData(
          this Reader reader)
        {
            if (reader.ReadBoolean())
                return (SceneLoadData)null;
            return new SceneLoadData()
            {
                SceneLookupDatas = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D(reader),
                MovedNetworkObjects = ScenedReadersAndWriters.Read___FishNetu002EObjectu002ENetworkObjectu005Bu005D(reader),
                ReplaceScenes = (ReplaceOption)reader.ReadByte(),
                Params = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadParams(reader),
                Options = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadOptions(reader)
            };
        }

        public static SceneLookupData[] Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D(
          this Reader reader)
        {
            int length = (int)reader.ReadPackedWhole();
            if (length == -1)
                return (SceneLookupData[])null;
            SceneLookupData[] sceneLookupDataArray = new SceneLookupData[length];
            for (int index = 0; index < length; ++index)
                sceneLookupDataArray[index] = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupData(reader);
            return sceneLookupDataArray;
        }

        public static SceneLookupData Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupData(
          this Reader reader)
        {
            if (reader.ReadBoolean())
                return (SceneLookupData)null;
            return new SceneLookupData()
            {
                Handle = reader.ReadInt32(),
                Name = reader.ReadString()
            };
        }

        public static NetworkObject[] Read___FishNetu002EObjectu002ENetworkObjectu005Bu005D(
          this Reader reader)
        {
            int length = (int)reader.ReadPackedWhole();
            if (length == -1)
                return (NetworkObject[])null;
            NetworkObject[] networkObjectArray = new NetworkObject[length];
            for (int index = 0; index < length; ++index)
                networkObjectArray[index] = reader.ReadNetworkObject();
            return networkObjectArray;
        }

        public static LoadParams Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadParams(
          this Reader reader)
        {
            if (reader.ReadBoolean())
                return (LoadParams)null;
            return new LoadParams()
            {
                ClientParams = reader.ReadBytesAndSizeAllocated()
            };
        }

        public static LoadOptions Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadOptions(
          this Reader reader)
        {
            return reader.ReadBoolean() ? (LoadOptions)null : new LoadOptions();
        }

        public static string[] Read___Systemu002EStringu005Bu005D(this Reader reader)
        {
            int length = (int)reader.ReadPackedWhole();
            if (length == -1)
                return (string[])null;
            string[] strArray = new string[length];
            for (int index = 0; index < length; ++index)
                strArray[index] = reader.ReadString();
            return strArray;
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EBroadcastu002EUnloadScenesBroadcast(
          this Writer writer,
          UnloadScenesBroadcast value)
        {
            ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadQueueData(writer, value.QueueData);
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadQueueData(
          this Writer writer,
          UnloadQueueData value)
        {
            if (value == null)
            {
                writer.WriteBoolean(true);
            }
            else
            {
                writer.WriteBoolean(false);
                ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneUnloadData(writer, value.SceneUnloadData);
                ScenedReadersAndWriters.Write___Systemu002EStringu005Bu005D(writer, value.GlobalScenes);
            }
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneUnloadData(
          this Writer writer,
          SceneUnloadData value)
        {
            if (value == null)
            {
                writer.WriteBoolean(true);
            }
            else
            {
                writer.WriteBoolean(false);
                ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D(writer, value.SceneLookupDatas);
                ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadParams(writer, value.Params);
                ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadOptions(writer, value.Options);
            }
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadParams(
          this Writer writer,
          UnloadParams value)
        {
            if (value == null)
            {
                writer.WriteBoolean(true);
            }
            else
            {
                writer.WriteBoolean(false);
                writer.WriteBytesAndSize(value.ClientParams);
            }
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadOptions(
          this Writer writer,
          UnloadOptions value)
        {
            if (value == null)
                writer.WriteBoolean(true);
            else
                writer.WriteBoolean(false);
        }

        public static UnloadScenesBroadcast Read___FishNetu002EManagingu002EScenedu002EBroadcastu002EUnloadScenesBroadcast(
          this Reader reader)
        {
            return new UnloadScenesBroadcast()
            {
                QueueData = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadQueueData(reader)
            };
        }

        public static UnloadQueueData Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadQueueData(
          this Reader reader)
        {
            if (reader.ReadBoolean())
                return (UnloadQueueData)null;
            return new UnloadQueueData()
            {
                SceneUnloadData = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneUnloadData(reader),
                GlobalScenes = ScenedReadersAndWriters.Read___Systemu002EStringu005Bu005D(reader)
            };
        }

        public static SceneUnloadData Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneUnloadData(
          this Reader reader)
        {
            if (reader.ReadBoolean())
                return (SceneUnloadData)null;
            return new SceneUnloadData()
            {
                SceneLookupDatas = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D(reader),
                Params = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadParams(reader),
                Options = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadOptions(reader)
            };
        }

        public static UnloadParams Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadParams(
          this Reader reader)
        {
            if (reader.ReadBoolean())
                return (UnloadParams)null;
            return new UnloadParams()
            {
                ClientParams = reader.ReadBytesAndSizeAllocated()
            };
        }

        public static UnloadOptions Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadOptions(
          this Reader reader)
        {
            return reader.ReadBoolean() ? (UnloadOptions)null : new UnloadOptions();
        }

        public static void Write___FishNetu002EManagingu002EScenedu002EBroadcastu002EClientScenesLoadedBroadcast(
          this Writer writer,
          ClientScenesLoadedBroadcast value)
        {
            ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D(writer, value.SceneLookupDatas);
        }

        public static ClientScenesLoadedBroadcast Read___FishNetu002EManagingu002EScenedu002EBroadcastu002EClientScenesLoadedBroadcast(
          this Reader reader)
        {
            return new ClientScenesLoadedBroadcast()
            {
                SceneLookupDatas = ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D(reader)
            };
        }

        [RuntimeInitializeOnLoadMethod]
        static void InitializeOnce()
        {
            GenericWriter<SceneLookupData>.Write = new Action<Writer, SceneLookupData>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupData);
            GenericWriter<SceneLookupData[]>.Write = new Action<Writer, SceneLookupData[]>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D);
            GenericWriter<LoadParams>.Write = new Action<Writer, LoadParams>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadParams);
            GenericWriter<LoadOptions>.Write = new Action<Writer, LoadOptions>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadOptions);
            GenericWriter<SceneLoadData>.Write = new Action<Writer, SceneLoadData>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneLoadData);
            GenericWriter<LoadQueueData>.Write = new Action<Writer, LoadQueueData>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ELoadQueueData);
            GenericWriter<LoadScenesBroadcast>.Write = new Action<Writer, LoadScenesBroadcast>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EBroadcastu002ELoadScenesBroadcast);
            GenericWriter<UnloadParams>.Write = new Action<Writer, UnloadParams>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadParams);
            GenericWriter<UnloadOptions>.Write = new Action<Writer, UnloadOptions>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadOptions);
            GenericWriter<SceneUnloadData>.Write = new Action<Writer, SceneUnloadData>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002ESceneUnloadData);
            GenericWriter<UnloadQueueData>.Write = new Action<Writer, UnloadQueueData>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EDatau002EUnloadQueueData);
            GenericWriter<UnloadScenesBroadcast>.Write = new Action<Writer, UnloadScenesBroadcast>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EBroadcastu002EUnloadScenesBroadcast);
            GenericWriter<ClientScenesLoadedBroadcast>.Write = new Action<Writer, ClientScenesLoadedBroadcast>(ScenedReadersAndWriters.Write___FishNetu002EManagingu002EScenedu002EBroadcastu002EClientScenesLoadedBroadcast);
            GenericReader<SceneLookupData>.Read = new Func<Reader, SceneLookupData>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupData);
            GenericReader<SceneLookupData[]>.Read = new Func<Reader, SceneLookupData[]>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLookupDatau005Bu005D);
            GenericReader<LoadParams>.Read = new Func<Reader, LoadParams>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadParams);
            GenericReader<LoadOptions>.Read = new Func<Reader, LoadOptions>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadOptions);
            GenericReader<SceneLoadData>.Read = new Func<Reader, SceneLoadData>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneLoadData);
            GenericReader<LoadQueueData>.Read = new Func<Reader, LoadQueueData>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ELoadQueueData);
            GenericReader<LoadScenesBroadcast>.Read = new Func<Reader, LoadScenesBroadcast>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EBroadcastu002ELoadScenesBroadcast);
            GenericReader<UnloadParams>.Read = new Func<Reader, UnloadParams>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadParams);
            GenericReader<UnloadOptions>.Read = new Func<Reader, UnloadOptions>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadOptions);
            GenericReader<SceneUnloadData>.Read = new Func<Reader, SceneUnloadData>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002ESceneUnloadData);
            GenericReader<UnloadQueueData>.Read = new Func<Reader, UnloadQueueData>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EDatau002EUnloadQueueData);
            GenericReader<UnloadScenesBroadcast>.Read = new Func<Reader, UnloadScenesBroadcast>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EBroadcastu002EUnloadScenesBroadcast);
            GenericReader<ClientScenesLoadedBroadcast>.Read = new Func<Reader, ClientScenesLoadedBroadcast>(ScenedReadersAndWriters.Read___FishNetu002EManagingu002EScenedu002EBroadcastu002EClientScenesLoadedBroadcast);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/InstanceFinder.cs ---
using FishNet.Component.ColliderRollback;
using FishNet.Managing;
using FishNet.Managing.Client;
using FishNet.Managing.Logging;
using FishNet.Managing.Scened;
using FishNet.Managing.Server;
using FishNet.Managing.Statistic;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using FishNet.Utility;
using System.Linq;
using UnityEngine;

namespace FishNet
{

    /// <summary>
    /// Used to globally get information from the first found instance of NetworkManager.
    /// </summary>
    public static class InstanceFinder
    {

        #region Public.
        /// <summary>
        /// Returns the first found NetworkManager instance.
        /// </summary>
        public static NetworkManager NetworkManager
        {
            get
            {
                if (_networkManager == null)
                {
                    int managersCount = NetworkManager.Instances.Count;
                    //At least one manager.
                    if (managersCount > 0)
                    {
                        _networkManager = NetworkManager.Instances.First();
                        if (managersCount > 1)
                        {
                            if (_networkManager.CanLog(LoggingType.Warning))
                                Debug.LogWarning($"Multiple NetworkManagers found, the first result will be returned. If you only wish to have one NetworkManager then uncheck 'Allow Multiple' within your NetworkManagers.");
                        }
                    }
                    //No managers.
                    else
                    {
                        //If application is quitting return null without logging.
                        if (ApplicationState.IsQuitting())
                            return null;

                        Debug.Log($"NetworkManager not found in any open scenes.");
                    }
                }

                return _networkManager;
            }
        }

        /// <summary>
        /// Returns the first instance of ServerManager.
        /// </summary>
        public static ServerManager ServerManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.ServerManager;
            }
        }

        /// <summary>
        /// Returns the first instance of ClientManager.
        /// </summary>
        public static ClientManager ClientManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.ClientManager;
            }
        }

        /// <summary>
        /// Returns the first instance of TransportManager.
        /// </summary>
        public static TransportManager TransportManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.TransportManager;
            }
        }

        /// <summary>
        /// Returns the first instance of TimeManager.
        /// </summary>
        public static TimeManager TimeManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.TimeManager;
            }
        }

        /// <summary>
        /// Returns the first instance of SceneManager.
        /// </summary>
        public static SceneManager SceneManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.SceneManager;
            }
        }
        /// <summary>
        /// Returns the first instance of RollbackManager.
        /// </summary>
        public static RollbackManager RollbackManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.RollbackManager;
            }
        }
        /// <summary>
        /// Returns the first instance of StatisticsManager.
        /// </summary>
        public static StatisticsManager StatisticsManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.StatisticsManager;
            }
        }

        /// <summary>
        /// True if the server is active.
        /// </summary>
        public static bool IsServer => (NetworkManager == null) ? false : NetworkManager.IsServer;
        /// <summary>
        /// True if only the server is active.
        /// </summary>
        public static bool IsServerOnly => (NetworkManager == null) ? false : NetworkManager.IsServerOnly;
        /// <summary>
        /// True if the client is active and authenticated.
        /// </summary>
        public static bool IsClient => (NetworkManager == null) ? false : NetworkManager.IsClient;
        /// <summary>
        /// True if only the client is active and authenticated.
        /// </summary>
        public static bool IsClientOnly => (NetworkManager == null) ? false : NetworkManager.IsClientOnly;
        /// <summary>
        /// True if client and server are active.
        /// </summary>
        public static bool IsHost => (NetworkManager == null) ? false : NetworkManager.IsHost;
        /// <summary>
        /// True if client nor server are active.
        /// </summary>
        public static bool IsOffline => (NetworkManager == null) ? true : (!NetworkManager.IsServer && !NetworkManager.IsClient);
        #endregion

        #region Private.
        /// <summary>
        /// NetworkManager instance.
        /// </summary>
        private static NetworkManager _networkManager;
        #endregion

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Client/ClientManager.Broadcast.cs ---
﻿using FishNet.Broadcast;
using FishNet.Broadcast.Helping;
using FishNet.Managing.Logging;
using FishNet.Managing.Utility;
using FishNet.Object.Helping;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Client
{
    public sealed partial class ClientManager : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// Delegate to read received broadcasts.
        /// </summary>
        /// <param name="reader"></param>
        private delegate void ServerBroadcastDelegate(PooledReader reader);
        /// <summary>
        /// Delegates for each key.
        /// </summary>
        private readonly Dictionary<ushort, HashSet<ServerBroadcastDelegate>> _broadcastHandlers = new Dictionary<ushort, HashSet<ServerBroadcastDelegate>>();
        /// <summary>
        /// Delegate targets for each key.
        /// </summary>
        private Dictionary<ushort, HashSet<(int, ServerBroadcastDelegate)>> _handlerTargets = new Dictionary<ushort, HashSet<(int, ServerBroadcastDelegate)>>();
        #endregion

        /// <summary>
        /// Registers a method to call when a Broadcast arrives.
        /// </summary>
        /// <typeparam name="T">Type of broadcast being registered.</typeparam>
        /// <param name="handler">Method to call.</param>
        public void RegisterBroadcast<T>(Action<T> handler) where T : struct, IBroadcast
        {
            ushort key = typeof(T).FullName.GetStableHash16();
            /* Create delegate and add for
             * handler method. */
            HashSet<ServerBroadcastDelegate> handlers;
            if (!_broadcastHandlers.TryGetValueIL2CPP(key, out handlers))
            {
                handlers = new HashSet<ServerBroadcastDelegate>();
                _broadcastHandlers.Add(key, handlers);
            }
            ServerBroadcastDelegate del = CreateBroadcastDelegate(handler);
            handlers.Add(del);

            /* Add hashcode of target for handler.
             * This is so we can unregister the target later. */
            int handlerHashCode = handler.GetHashCode();
            HashSet<(int, ServerBroadcastDelegate)> targetHashCodes;
            if (!_handlerTargets.TryGetValueIL2CPP(key, out targetHashCodes))
            {
                targetHashCodes = new HashSet<(int, ServerBroadcastDelegate)>();
                _handlerTargets.Add(key, targetHashCodes);
            }

            targetHashCodes.Add((handlerHashCode, del));
        }

        /// <summary>
        /// Unregisters a method call from a Broadcast type.
        /// </summary>
        /// <typeparam name="T">Type of broadcast being unregistered.</typeparam>
        /// <param name="handler">Method to unregister.</param>
        public void UnregisterBroadcast<T>(Action<T> handler) where T : struct, IBroadcast
        {
            ushort key = BroadcastHelper.GetKey<T>();

            /* If key is found for T then look for
             * the appropriate handler to remove. */
            if (_broadcastHandlers.TryGetValueIL2CPP(key, out HashSet<ServerBroadcastDelegate> handlers))
            {
                HashSet<(int, ServerBroadcastDelegate)> targetHashCodes;
                if (_handlerTargets.TryGetValueIL2CPP(key, out targetHashCodes))
                {
                    int handlerHashCode = handler.GetHashCode();
                    ServerBroadcastDelegate result = null;
                    foreach ((int targetHashCode, ServerBroadcastDelegate del) in targetHashCodes)
                    {
                        if (targetHashCode == handlerHashCode)
                        {
                            result = del;
                            targetHashCodes.Remove((targetHashCode, del));
                            break;
                        }
                    }
                    //If no more in targetHashCodes then remove from handlerTarget.
                    if (targetHashCodes.Count == 0)
                        _handlerTargets.Remove(key);

                    if (result != null)
                        handlers.Remove(result);
                }

                //If no more in handlers then remove broadcastHandlers.
                if (handlers.Count == 0)
                    _broadcastHandlers.Remove(key);
            }
        }

        /// <summary>
        /// Creates a ServerBroadcastDelegate.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="handler"></param>
        /// <param name="requireAuthentication"></param>
        /// <returns></returns>
        private ServerBroadcastDelegate CreateBroadcastDelegate<T>(Action<T> handler)
        {
            void LogicContainer(PooledReader reader)
            {
                T broadcast = reader.Read<T>();
                handler?.Invoke(broadcast);
            }
            return LogicContainer;
        }

        /// <summary>
        /// Parses a received broadcast.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ParseBroadcast(PooledReader reader, Channel channel)
        {
            ushort key = reader.ReadUInt16();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.Broadcast, reader, channel);
            // try to invoke the handler for that message
            if (_broadcastHandlers.TryGetValueIL2CPP(key, out HashSet<ServerBroadcastDelegate> handlers))
            {
                int readerStartPosition = reader.Position;
                /* //muchlater resetting the position could be better by instead reading once and passing in
                 * the object to invoke with. */
                foreach (ServerBroadcastDelegate handler in handlers)
                {
                    reader.Position = readerStartPosition;
                    handler.Invoke(reader);
                }
            }
            else
            {
                reader.Skip(dataLength);
            }
        }

        /// <summary>
        /// Sends a Broadcast to the server.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(T message, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            //Check local connection state.
            if (!Started)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to server because client is not active.");
                return;
            }

            using (PooledWriter writer = WriterPool.GetWriter())
            {
                Broadcasts.WriteBroadcast<T>(writer, message, channel);
                ArraySegment<byte> segment = writer.GetArraySegment();

                NetworkManager.TransportManager.SendToServer((byte)channel, segment);
            }
        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Managing/Client/ClientManager.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Debugging;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Managing.Transporting;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Managing.Client
{
    /// <summary>
    /// A container for local client data and actions.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/ClientManager")]
    public sealed partial class ClientManager : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called after local client has authenticated.
        /// </summary>
        public event Action OnAuthenticated;
        /// <summary>
        /// Called after the local client connection state changes.
        /// </summary>
        public event Action<ClientConnectionStateArgs> OnClientConnectionState;
        /// <summary>
        /// Called when a client other than self connects.
        /// This is only available when using ServerManager.ShareIds.
        /// </summary>
        public event Action<RemoteConnectionStateArgs> OnRemoteConnectionState;
        /// <summary>
        /// True if the client connection is connected to the server.
        /// </summary>
        public bool Started { get; private set; }
        /// <summary>
        /// NetworkConnection the local client is using to send data to the server.
        /// </summary>
        public NetworkConnection Connection = NetworkManager.EmptyConnection;
        /// <summary>
        /// Handling and information for objects known to the local client.
        /// </summary>
        public ClientObjects Objects { get; private set; }
        /// <summary>
        /// All currently connected clients. This field only contains data while ServerManager.ShareIds is enabled.
        /// </summary>
        public Dictionary<int, NetworkConnection> Clients = new Dictionary<int, NetworkConnection>();
        /// <summary>
        /// NetworkManager for client.
        /// </summary>
        [HideInInspector]
        public NetworkManager NetworkManager { get; private set; }
        #endregion

        #region Serialized.
        /// <summary>
        /// True to automatically set the frame rate when the client connects.
        /// </summary>
        [Tooltip("True to automatically set the frame rate when the client connects.")]
        [SerializeField]
        private bool _changeFrameRate = true;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Maximum frame rate the client may run at. When as host this value runs at whichever is higher between client and server.")]
        [Range(1, NetworkManager.MAXIMUM_FRAMERATE)]
        [SerializeField]
        private ushort _frameRate = NetworkManager.MAXIMUM_FRAMERATE;
        /// <summary>
        /// Maximum frame rate the client may run at. When as host this value runs at whichever is higher between client and server.
        /// </summary>
        internal ushort FrameRate => (_changeFrameRate) ? _frameRate : (ushort)0;
        #endregion

        #region Private.
        /// <summary>
        /// Used to read splits.
        /// </summary>
        private SplitReader _splitReader = new SplitReader();
#if UNITY_EDITOR || DEVELOPMENT_BUILD
        /// <summary>
        /// Logs data about parser to help debug.
        /// </summary>
        private ParseLogger _parseLogger = new ParseLogger();
#endif
        #endregion

        private void OnDestroy()
        {
            Objects?.SubscribeToSceneLoaded(false);
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnceInternal(NetworkManager manager)
        {
            NetworkManager = manager;
            Objects = new ClientObjects(manager);
            Objects.SubscribeToSceneLoaded(true);
            /* Unsubscribe before subscribing.
             * Shouldn't be an issue but better safe than sorry. */
            SubscribeToEvents(false);
            SubscribeToEvents(true);
            //Listen for client connections from server.
            RegisterBroadcast<ClientConnectionChangeBroadcast>(OnClientConnectionBroadcast);
            RegisterBroadcast<ConnectedClientsBroadcast>(OnConnectedClientsBroadcast);
        }

        /// <summary>
        /// Called when the server sends a connection state change for any client.
        /// </summary>
        /// <param name="args"></param>
        private void OnClientConnectionBroadcast(ClientConnectionChangeBroadcast args)
        {
            //If connecting invoke after added to clients, otherwise invoke before removed.
            RemoteConnectionStateArgs rcs = new RemoteConnectionStateArgs((args.Connected) ? RemoteConnectionState.Started : RemoteConnectionState.Stopped, args.Id, -1);

            if (args.Connected)
            {
                Clients[args.Id] = new NetworkConnection(NetworkManager, args.Id);
                OnRemoteConnectionState?.Invoke(rcs);
            }
            else
            {
                OnRemoteConnectionState?.Invoke(rcs);
                Clients.Remove(args.Id);
            }
        }

        /// <summary>
        /// Called when the server sends all currently connected clients.
        /// </summary>
        /// <param name="args"></param>
        private void OnConnectedClientsBroadcast(ConnectedClientsBroadcast args)
        {
            Clients.Clear();

            List<int> collection = args.Ids;
            int count = collection.Count;
            for (int i = 0; i < count; i++)
            {
                int id = collection[i];
                Clients[id] = new NetworkConnection(NetworkManager, id);
            }
        }

        /// <summary>
        /// Changes subscription status to transport.
        /// </summary>
        /// <param name="subscribe"></param>
        private void SubscribeToEvents(bool subscribe)
        {
            if (NetworkManager == null || NetworkManager.TransportManager == null || NetworkManager.TransportManager.Transport == null)
                return;

            if (!subscribe)
            {
                NetworkManager.TransportManager.OnIterateIncomingEnd -= TransportManager_OnIterateIncomingEnd;
                NetworkManager.TransportManager.Transport.OnClientReceivedData -= Transport_OnClientReceivedData;
                NetworkManager.TransportManager.Transport.OnClientConnectionState -= Transport_OnClientConnectionState;
            }
            else
            {
                NetworkManager.TransportManager.OnIterateIncomingEnd += TransportManager_OnIterateIncomingEnd;
                NetworkManager.TransportManager.Transport.OnClientReceivedData += Transport_OnClientReceivedData;
                NetworkManager.TransportManager.Transport.OnClientConnectionState += Transport_OnClientConnectionState;
            }
        }

        /// <summary>
        /// Stops the local client connection.
        /// </summary>
        public void StopConnection()
        {
            NetworkManager.TransportManager.Transport.StopConnection(false);
        }

        /// <summary>
        /// Starts the local client connection.
        /// </summary>
        public void StartConnection()
        {
            NetworkManager.TransportManager.Transport.StartConnection(false);
        }

        /// <summary>
        /// Sets the transport address and starts the local client connection.
        /// </summary>
        public void StartConnection(string address)
        {
            StartConnection(address, NetworkManager.TransportManager.Transport.GetPort());
        }
        /// <summary>
        /// Sets the transport address and port, and starts the local client connection.
        /// </summary>
        public void StartConnection(string address, ushort port)
        {
            NetworkManager.TransportManager.Transport.SetClientAddress(address);
            NetworkManager.TransportManager.Transport.SetPort(port);
            StartConnection();
        }

        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        /// <param name="args"></param>
        private void Transport_OnClientConnectionState(ClientConnectionStateArgs args)
        {
            LocalConnectionState state = args.ConnectionState;
            Started = (state == LocalConnectionState.Started);
            Objects.OnClientConnectionState(args);

            //Clear connection after so objects can update using current Connection value.
            if (!Started)
            {
                Connection = NetworkManager.EmptyConnection;
                Clients.Clear();
            }

            if (NetworkManager.CanLog(LoggingType.Common))
            {
                Transport t = NetworkManager.TransportManager.GetTransport(args.TransportIndex);
                string tName = (t == null) ? "Unknown" : t.GetType().Name;
                Debug.Log($"Local client is {state.ToString().ToLower()} for {tName}.");
            }

            NetworkManager.UpdateFramerate();
            OnClientConnectionState?.Invoke(args);
        }

        /// <summary>
        /// Called when a socket receives data.
        /// </summary>
        private void Transport_OnClientReceivedData(ClientReceivedDataArgs args)
        {
            ParseReceived(args);
        }

        /// <summary>
        /// Called after IterateIncoming has completed.
        /// </summary>
        private void TransportManager_OnIterateIncomingEnd(bool server)
        {
            /* Should the last packet received be a spawn or despawn
             * then the cache won't yet be iterated because it only
             * iterates when a packet is anything but those two. Because
             * of such if any object caches did come in they must be iterated
             * at the end of the incoming cycle. This isn't as clean as I'd
             * like but it does ensure there will be no missing network object
             * references on spawned objects. */
            if (Started && !server)
                Objects.IterateObjectCache();
        }

        /// <summary>
        /// Parses received data.
        /// </summary>
        private void ParseReceived(ClientReceivedDataArgs args)
        {
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            _parseLogger.Reset();
#endif

            ArraySegment<byte> segment = args.Data;
            NetworkManager.StatisticsManager.NetworkTraffic.LocalClientReceivedData((ulong)segment.Count);
            if (segment.Count <= TransportManager.TICK_BYTES)
                return;

            PacketId packetId = PacketId.Unset;
#if !UNITY_EDITOR && !DEVELOPMENT_BUILD
            try
            {
#endif
            using (PooledReader reader = ReaderPool.GetReader(segment, NetworkManager))
            {
                NetworkManager.TimeManager.LastPacketTick = reader.ReadUInt32(AutoPackType.Unpacked);
                /* This is a special condition where a message may arrive split.
                * When this occurs buffer each packet until all packets are
                * received. */
                if (reader.PeekPacketId() == PacketId.Split)
                {
                    //Skip packetId.
                    reader.ReadPacketId();
                    int expectedMessages;
                    _splitReader.GetHeader(reader, out expectedMessages);
                    _splitReader.Write(NetworkManager.TimeManager.LastPacketTick, reader, expectedMessages);
                    /* If fullMessage returns 0 count then the split
                     * has not written fully yet. Otherwise, if there is
                     * data within then reinitialize reader with the
                     * full message. */
                    ArraySegment<byte> fullMessage = _splitReader.GetFullMessage();
                    if (fullMessage.Count == 0)
                        return;

                    //Initialize reader with full message.
                    reader.Initialize(fullMessage, NetworkManager);
                }

                while (reader.Remaining > 0)
                {
                    packetId = reader.ReadPacketId();
#if UNITY_EDITOR || DEVELOPMENT_BUILD
                    _parseLogger.AddPacket(packetId);
#endif
                    bool spawnOrDespawn = (packetId == PacketId.ObjectSpawn || packetId == PacketId.ObjectDespawn);
                    /* Length of data. Only available if using unreliable. Unreliable packets
                     * can arrive out of order which means object orientated messages such as RPCs may
                     * arrive after the object for which they target has already been destroyed. When this happens
                     * on lesser solutions they just dump the entire packet. However, since FishNet batches data.
                     * it's very likely a packet will contain more than one packetId. With this mind, length is
                     * sent as well so if any reason the data does have to be dumped it will only be dumped for
                     * that single packetId  but not the rest. Broadcasts don't need length either even if unreliable
                     * because they are not object bound. */

                    //Is spawn or despawn; cache packet.
                    if (spawnOrDespawn)
                    {
                        if (packetId == PacketId.ObjectSpawn)
                            Objects.CacheSpawn(reader);
                        else if (packetId == PacketId.ObjectDespawn)
                            Objects.CacheDespawn(reader);
                    }
                    //Not spawn or despawn.
                    else
                    {
                        /* Iterate object cache should any of the
                         * incoming packets rely on it. Objects
                         * in cache will always be received before any messages
                         * that use them. */
                        Objects.IterateObjectCache();
                        //Then process packet normally.
                        if ((ushort)packetId >= NetworkManager.StartingRpcLinkIndex)
                        {
                            Objects.ParseRpcLink(reader, (ushort)packetId, args.Channel);
                        }
                        else if (packetId == PacketId.Reconcile)
                        {
                            Objects.ParseReconcileRpc(reader, args.Channel);
                        }
                        else if (packetId == PacketId.ObserversRpc)
                        {
                            Objects.ParseObserversRpc(reader, args.Channel);
                        }
                        else if (packetId == PacketId.TargetRpc)
                        {
                            Objects.ParseTargetRpc(reader, args.Channel);
                        }
                        else if (packetId == PacketId.Broadcast)
                        {
                            ParseBroadcast(reader, args.Channel);
                        }
                        else if (packetId == PacketId.PingPong)
                        {
                            ParsePingPong(reader);
                        }
                        else if (packetId == PacketId.SyncVar)
                        {
                            Objects.ParseSyncType(reader, false, args.Channel);
                        }
                        else if (packetId == PacketId.SyncObject)
                        {
                            Objects.ParseSyncType(reader, true, args.Channel);
                        }
                        else if (packetId == PacketId.TimingUpdate)
                        {
                            NetworkManager.TimeManager.ParseTimingUpdate();
                        }
                        else if (packetId == PacketId.OwnershipChange)
                        {
                            Objects.ParseOwnershipChange(reader);
                        }
                        else if (packetId == PacketId.Authenticated)
                        {
                            ParseAuthenticated(reader);
                        }
                        else if (packetId == PacketId.Disconnect)
                        {
                            reader.Skip(reader.Remaining);
                            StopConnection();
                        }
                        else
                        {
                            if (NetworkManager.CanLog(LoggingType.Error))
                            {
                                Debug.LogError($"Client received an unhandled PacketId of {(ushort)packetId}. Remaining data has been purged.");
#if UNITY_EDITOR || DEVELOPMENT_BUILD
                                _parseLogger.Print(NetworkManager);
#endif
                            }
                            return;
                        }
                    }
                }

                /* Iterate cache when reader is emptied.
                 * This is incase the last packet received
                 * was a spawned, which wouldn't trigger
                 * the above iteration. There's no harm
                 * in doing this check multiple times as there's
                 * an exit early check. */
                Objects.IterateObjectCache();
            }
#if !UNITY_EDITOR && !DEVELOPMENT_BUILD
            }
            catch (Exception e)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Client encountered an error while parsing data for packetId {packetId}. Message: {e.Message}.");
            }
#endif
        }

        /// <summary>
        /// Parses a PingPong packet.
        /// </summary>
        /// <param name="reader"></param>
        private void ParsePingPong(PooledReader reader)
        {
            uint clientTick = reader.ReadUInt32(AutoPackType.Unpacked);
            NetworkManager.TimeManager.ModifyPing(clientTick);
        }

        /// <summary>
        /// Parses a received connectionId. This is received before client receives connection state change.
        /// </summary>
        /// <param name="reader"></param>
        private void ParseAuthenticated(PooledReader reader)
        {
            NetworkManager networkManager = NetworkManager;
            int connectionId = reader.ReadNetworkConnectionId();
            //If only a client then make a new connection.
            if (!networkManager.IsServer)
            {
                Clients.TryGetValueIL2CPP(connectionId, out Connection);
            }
            /* If also the server then use the servers connection
             * for the connectionId. This is to resolve host problems
             * where LocalConnection for client differs from the server Connection
             * reference, which results in different field values. */
            else
            {
                if (networkManager.ServerManager.Clients.TryGetValueIL2CPP(connectionId, out NetworkConnection conn))
                {
                    Connection = conn;
                }
                else
                {
                    if (networkManager.CanLog(LoggingType.Error))
                        Debug.LogError($"Unable to lookup LocalConnection for {connectionId} as host.");

                    Connection = new NetworkConnection(networkManager, connectionId);
                }
            }

            /* Set the TimeManager tick to lastReceivedTick.
             * This still doesn't account for latency but
             * it's the best we can do until the client gets
             * a ping response. */
            networkManager.TimeManager.Tick = networkManager.TimeManager.LastPacketTick;

            //Mark as authenticated.
            Connection.ConnectionAuthenticated();
            OnAuthenticated?.Invoke();
            /* Register scene objects for all scenes
             * after being authenticated. This is done after
             * authentication rather than when the connection
             * is started because if also as server an online
             * scene may already be loaded on server, but not
             * for client. This means the sceneLoaded unity event
             * won't fire, and since client isn't authenticated
            * at the connection start phase objects won't be added. */
            Objects.RegisterAndDespawnSceneObjects();
        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Managing/Client/Editor/ClientManagerEditor.cs ---
﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Client.Editing
{

    [CustomEditor(typeof(ClientManager), true)]
    [CanEditMultipleObjects]
    public class ClientManagerEditor : Editor
    {
        private SerializedProperty _changeFrameRate;
        private SerializedProperty _frameRate;

        protected virtual void OnEnable()
        {
            _changeFrameRate = serializedObject.FindProperty("_changeFrameRate");
            _frameRate = serializedObject.FindProperty("_frameRate");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((ClientManager)target), typeof(ClientManager), false);
            GUI.enabled = true;

            EditorGUILayout.PropertyField(_changeFrameRate);
            if (_changeFrameRate.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_frameRate);
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.Space();

            serializedObject.ApplyModifiedProperties();
        }

    }
}
#endif
'''
'''--- Assets/FishNet/Runtime/Managing/Client/Object/ClientObjects.RpcLinks.cs ---
﻿using FishNet.Managing.Logging;
using FishNet.Managing.Object;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Object.Helping;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Client
{
    /// <summary>
    /// Handles objects and information about objects for the local client. See ManagedObjects for inherited options.
    /// </summary>
    public partial class ClientObjects : ManagedObjects
    {

        #region Private.
        /// <summary>
        /// RPCLinks of currently spawned objects.
        /// </summary>
        private Dictionary<ushort, RpcLink> _rpcLinks = new Dictionary<ushort, RpcLink>();
        #endregion

        /// <summary>
        /// Parses a received RPCLink.
        /// </summary>
        /// <param name="reader"></param>
        /// <param name="index"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ParseRpcLink(PooledReader reader, ushort index, Channel channel)
        {
            int dataLength = Packets.GetPacketLength(ushort.MaxValue, reader, channel);

            //Link index isn't stored.
            if (!_rpcLinks.TryGetValueIL2CPP(index, out RpcLink link))
            {
                SkipDataLength(index, reader, dataLength);
                return;
            }
            else
            //Found NetworkObject for link.
            if (Spawned.TryGetValueIL2CPP(link.ObjectId, out NetworkObject nob))
            {
                NetworkBehaviour nb = nob.NetworkBehaviours[link.ComponentIndex];
                if (link.RpcType == RpcType.Target)
                    nb.OnTargetRpc(link.RpcHash, reader, channel);
                else if (link.RpcType == RpcType.Observers)
                    nb.OnObserversRpc(link.RpcHash, reader, channel);
                else if (link.RpcType == RpcType.Reconcile)
                    nb.OnReconcileRpc(link.RpcHash, reader, channel);
            }
            //Could not find NetworkObject.
            else
            {
                SkipDataLength(index, reader, dataLength, link.ObjectId);
            }
        }

        /// <summary>
        /// Sets link to rpcLinks key linkIndex.
        /// </summary>
        /// <param name="linkIndex"></param>
        /// <param name="link"></param>
        internal void SetRpcLink(ushort linkIndex, RpcLink link)
        {
            _rpcLinks[linkIndex] = link;
        }

        /// <summary>
        /// Removes link index keys from rpcLinks.
        /// </summary>
        internal void RemoveLinkIndexes(List<ushort> values)
        {
            if (values == null)
                return;

            for (int i = 0; i < values.Count; i++)
                _rpcLinks.Remove(values[i]);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Client/Object/ClientObjects.cs ---
﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Managing.Object;
using FishNet.Managing.Server;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Client
{
    /// <summary>
    /// Handles objects and information about objects for the local client. See ManagedObjects for inherited options.
    /// </summary>
    public partial class ClientObjects : ManagedObjects
    {
        #region Private.
        /// <summary>
        /// NetworkObjects which are cached to be spawned or despawned.
        /// </summary>
        private ClientObjectCache _objectCache;
        #endregion

        internal ClientObjects(NetworkManager networkManager)
        {
            base.NetworkManager = networkManager;
            _objectCache = new ClientObjectCache(this, networkManager);
        }

        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        internal void OnServerConnectionState(ServerConnectionStateArgs args)
        {
            //Nothing needs to be done if started.
            if (args.ConnectionState == LocalConnectionState.Started)
                return;

            /* If not started and client is active then deinitialize
             * client objects first. This will let the deinit calls
             * perform before the server destroys them. Ideally this
             * would be done when the user shows intent to shutdown
             * the server, but realistically planning for server socket
             * drops is a much more universal solution.
             *
             * Calling StopConnection on the client will set it's local state
             * to Stopping which will result in a deinit. */
            if (NetworkManager.IsClient)
                base.NetworkManager.ClientManager.StopConnection();
        }

        /// <summary>
        /// Called when the connection state changes for the local client.
        /// </summary>
        /// <param name="args"></param>
        internal void OnClientConnectionState(ClientConnectionStateArgs args)
        {
            /* If new state is not started then reset
             * environment. */
            if (args.ConnectionState != LocalConnectionState.Started)
            {
                _objectCache.Reset();

                //If not server then deinitialize normally.
                if (!base.NetworkManager.IsServer)
                {
                    base.DespawnSpawnedWithoutSynchronization(false);
                }
                //Otherwise invoke stop callbacks only for client side.
                else
                {                    
                    foreach (NetworkObject n in Spawned.Values)
                        n.InvokeStopCallbacks(false);
                }
                /* Clear spawned and scene objects as they will be rebuilt.
                 * Spawned would have already be cleared if DespawnSpawned
                 * was called but it won't hurt anything clearing an empty collection. */
                base.Spawned.Clear();
                base.SceneObjects.Clear();
            }
        }

        /// <summary>
        /// Called when a scene is loaded.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="arg1"></param>
        [APIExclude]
        protected internal override void SceneManager_sceneLoaded(Scene s, LoadSceneMode arg1)
        {
            base.SceneManager_sceneLoaded(s, arg1);

            if (!base.NetworkManager.IsClient)
                return;
            /* When a scene first loads for a client it should disable
             * all network objects in that scene. The server will send
             * spawn messages once it's aware client has loaded the scene. */
            RegisterAndDespawnSceneObjects(s);
        }

        /// <summary>
        /// Registers NetworkObjects in all scenes and despawns them.
        /// </summary>
        internal void RegisterAndDespawnSceneObjects()
        {
            for (int i = 0; i < SceneManager.sceneCount; i++)
                RegisterAndDespawnSceneObjects(SceneManager.GetSceneAt(i));
        }

        /// <summary>
        /// Adds NetworkObjects within s to SceneObjects, and despawns them.
        /// </summary>
        /// <param name="s"></param>
        private void RegisterAndDespawnSceneObjects(Scene s)
        {
            ListCache<NetworkObject> nobs;
            SceneFN.GetSceneNetworkObjects(s, false, out nobs);

            for (int i = 0; i < nobs.Written; i++)
            {
                NetworkObject nob = nobs.Collection[i];
                base.UpdateNetworkBehaviours(nob, false);
                if (nob.IsNetworked && nob.IsSceneObject && nob.IsNetworked)
                {
                    base.AddToSceneObjects(nob);
                    //Only run if not also server, as this already ran on server.
                    if (!base.NetworkManager.IsServer)
                        nob.gameObject.SetActive(false);
                }
            }

            ListCaches.StoreCache(nobs);
        }

        /// <summary>
        /// Called when a NetworkObject runs Deactivate.
        /// </summary>
        /// <param name="nob"></param>
        internal override void NetworkObjectUnexpectedlyDestroyed(NetworkObject nob)
        {
            nob.RemoveClientRpcLinkIndexes();
            base.NetworkObjectUnexpectedlyDestroyed(nob);
        }

        /// <summary>
        /// Parses an OwnershipChange packet.
        /// </summary>
        /// <param name="reader"></param>
        internal void ParseOwnershipChange(PooledReader reader)
        {
            NetworkObject nob = reader.ReadNetworkObject();
            NetworkConnection newOwner = reader.ReadNetworkConnection();
            if (nob != null)
            {
                nob.GiveOwnership(newOwner, false);
            }
            else
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"NetworkBehaviour could not be found when trying to parse OwnershipChange packet.");
            }
        }

        /// <summary>
        /// Parses a received syncVar.
        /// </summary>
        /// <param name="reader"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ParseSyncType(PooledReader reader, bool isSyncObject, Channel channel)
        {
            //cleanup this is unique to synctypes where length comes first.
            //this will change once I tidy up synctypes.
            ushort packetId = (isSyncObject) ? (ushort)PacketId.SyncObject : (ushort)PacketId.SyncVar;
            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength(packetId, reader, channel);

            if (nb != null)
            {
                /* Length of data to be read for syncvars.
                 * This is important because syncvars are never
                 * a set length and data must be read through completion.
                 * The only way to know where completion of syncvar is, versus
                 * when another packet starts is by including the length. */
                if (dataLength > 0)
                    nb.OnSyncType(reader, dataLength, isSyncObject);
            }
            else
            {
                SkipDataLength(packetId, reader, dataLength);
            }
        }

        /// <summary>
        /// Parses a ReconcileRpc.
        /// </summary>
        /// <param name="reader"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ParseReconcileRpc(PooledReader reader, Channel channel)
        {
            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.Reconcile, reader, channel);

            if (nb != null)
                nb.OnReconcileRpc(null, reader, channel);
            else
                SkipDataLength((ushort)PacketId.ObserversRpc, reader, dataLength);
        }

        /// <summary>
        /// Parses an ObserversRpc.
        /// </summary>
        /// <param name="reader"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ParseObserversRpc(PooledReader reader, Channel channel)
        {
            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.ObserversRpc, reader, channel);

            if (nb != null)
                nb.OnObserversRpc(null, reader, channel);
            else
                SkipDataLength((ushort)PacketId.ObserversRpc, reader, dataLength);
        }
        /// <summary>
        /// Parses a TargetRpc.
        /// </summary>
        /// <param name="reader"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ParseTargetRpc(PooledReader reader, Channel channel)
        {
            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.TargetRpc, reader, channel);

            if (nb != null)
                nb.OnTargetRpc(null, reader, channel);
            else
                SkipDataLength((ushort)PacketId.TargetRpc, reader, dataLength);
        }

        /// <summary>
        /// Caches a received spawn to be processed after all spawns and despawns are received for the tick.
        /// </summary>
        /// <param name="reader"></param>
        internal void CacheSpawn(PooledReader reader)
        {
            int objectId = reader.ReadNetworkObjectId();
            int ownerId = reader.ReadNetworkConnectionId();
            SpawnType st = (SpawnType)reader.ReadByte();
            byte componentIndex = reader.ReadByte();
            bool nested = (componentIndex > 0);
            bool sceneObject = (st == SpawnType.Scene);
            int rootObjectId = (nested) ? reader.ReadNetworkObjectId() : -1;

            int? parentObjectId = null;
            byte? parentComponentIndex = null;
            short? prefabId = null;

            Vector3? localPosition;
            Quaternion? localRotation;
            Vector3? localScale;
            ulong sceneId = 0;

            if (nested)
                ReadNestedObject(reader, out localPosition, out localRotation, out localScale);
            else if (sceneObject)
                ReadSceneObject(reader, out sceneId, out localPosition, out localRotation, out localScale);
            else
                ReadSpawnedObject(reader, out parentObjectId, out parentComponentIndex, out prefabId, out localPosition, out localRotation, out localScale);

            ArraySegment<byte> rpcLinks = reader.ReadArraySegmentAndSize();
            ArraySegment<byte> syncValues = reader.ReadArraySegmentAndSize();

            _objectCache.AddSpawn(base.NetworkManager, objectId, ownerId, st, componentIndex, rootObjectId, parentObjectId, parentComponentIndex, prefabId, localPosition, localRotation, localScale, sceneId, rpcLinks, syncValues);
        }

        ///// <summary>
        ///// Caches a received spawn to be processed after all spawns and despawns are received for the tick.
        ///// </summary>
        ///// <param name="reader"></param>
        //internal void CacheSpawn(PooledReader reader)
        //{
        //    int objectId = reader.ReadNetworkObjectId();
        //    int ownerId = reader.ReadNetworkConnectionId();
        //    ObjectSpawnType ost = (ObjectSpawnType)reader.ReadByte();
        //    byte componentIndex = reader.ReadByte();
        //    bool nested = (componentIndex > 0);
        //    bool sceneObject = (ost == ObjectSpawnType.Scene);
        //    int parentObjectId = (nested) ? reader.ReadNetworkObjectId() : -1;
        //    NetworkObject nob;

        //    if (nested)
        //        nob = ReadNestedObject(reader, parentObjectId, componentIndex);
        //    else if (sceneObject)
        //        nob = ReadSceneObject(reader, componentIndex);
        //    else
        //        nob = ReadSpawnedObject(reader, objectId, ost);

        //    ArraySegment<byte> rpcLinks = reader.ReadArraySegmentAndSize();
        //    ArraySegment<byte> syncValues = reader.ReadArraySegmentAndSize();

        //    /* If nob is null and is host see if it's in pending destroy.
        //     * This can occur when the networkobject is spawned and despawned on
        //     * the server before it's sent to the client. This happens because the
        //     * server spawns the object, queues spawn package, despawns, queues despawn packet,
        //     * then removes it from Spawned. By the time the packet sends the object cannot be found
        //     * except in pending. */
        //    if (nob == null && NetworkManager.IsHost)
        //        nob = NetworkManager.ServerManager.Objects.GetFromPending(objectId);
        //    /*If nob is null then exit method. Since ClientObjects gets nob from
        //     * server objects as host this can occur sometimes
        //     * when the object is destroyed on server before client gets
        //     * spawn packet. */
        //    if (nob == null)
        //    {
        //        //Only error if client only.
        //        if (!NetworkManager.IsHost)
        //        {
        //            if (NetworkManager.CanLog(LoggingType.Error))
        //                Debug.LogError($"Spawn object could not be found or created for Id {objectId}; scene object: {sceneObject}.");
        //        }
        //        return;
        //    }
        //    else
        //    {
        //        nob.SetIsNetworked(true);
        //    }
        //    /* If not host then pre-initialize. Pre-initializing applies
        //     * values needed to run such as owner, network manager, and completes
        //     * other reference creating functions. */
        //    if (!base.NetworkManager.IsHost)
        //    {
        //        //If local client is owner then use localconnection reference.
        //        NetworkConnection localConnection = base.NetworkManager.ClientManager.Connection;
        //        NetworkConnection owner;
        //        //If owner is self.
        //        if (ownerId == localConnection.ClientId)
        //        {
        //            owner = localConnection;
        //        }
        //        else
        //        {
        //            /* If owner cannot be found then share owners
        //             * is disabled */
        //            if (!base.NetworkManager.ClientManager.Clients.TryGetValueIL2CPP(ownerId, out owner))
        //                owner = NetworkManager.EmptyConnection;
        //        }
        //        nob.PreinitializeInternal(NetworkManager, objectId, owner, false);
        //    }

        //    _objectCache.AddSpawn(nob, rpcLinks, syncValues, NetworkManager);
        //}

        /// <summary>
        /// Caches a received despawn to be processed after all spawns and despawns are received for the tick.
        /// </summary>
        /// <param name="reader"></param>
        internal void CacheDespawn(PooledReader reader)
        {
            int objectId = reader.ReadNetworkObjectId();
            DespawnType despawnType = (DespawnType)reader.ReadByte();
            _objectCache.AddDespawn(objectId, despawnType);
        }

        /// <summary>
        /// Iterates object cache which contains spawn and despawn messages.
        /// Parses the packets within the cache and ensures objects are spawned and despawned before their sync values are applied.
        /// This ensures there is no chance a sync value is referencing a spawned object which does not exist yet due to it normally being spawned later in the cache.
        /// </summary>
        internal void IterateObjectCache()
        {
            _objectCache.Iterate();
        }

        ///// <summary>
        ///// Finishes reading a nested object. Nested objects should always already exist beneath the parent.
        ///// </summary>
        //private NetworkObject ReadNestedObject(PooledReader reader, out Vector3? localPosition, out Quaternion? localRotation, out Vector3? localScale)
        //{
        //    ReadTransformProperties(reader,out localPosition, out localRotation, out localScale);
        //    Dictionary<int, NetworkObject> spawned = (base.NetworkManager.IsHost) ?
        //        NetworkManager.ServerManager.Objects.Spawned
        //        : NetworkManager.ClientManager.Objects.Spawned;

        //    NetworkObject parentNob;
        //    /* Spawns are processed after all spawns come in,
        //     * this ensures no reference race conditions. Turns out because of this
        //     * the parentNob may be in cache and not actually spawned, if it was spawned the same packet
        //     * as this one. So when not found in the spawned collection try to
        //     * find it in Spawning before throwing. */
        //    if (!spawned.TryGetValueIL2CPP(parentObjectId, out parentNob))
        //        _objectCache.SpawningObjects.TryGetValue(parentObjectId, out parentNob);
        //    //If still null, that's not good.
        //    if (parentNob == null)
        //    {
        //        /* Purge reader of expected values.
        //        * Use networkmanager transform, it doesn't really matter
        //        * since values are discarded anyway. */
        //        ReadTransformProperties(reader, base.NetworkManager.transform, out _, out _, out _);
        //        if (NetworkManager.CanLog(LoggingType.Error))
        //            Debug.LogError($"Nested spawned object with componentIndex of {componentIndex} and a parentId of {parentObjectId} could not be spawned because parent was not found.");
        //        return null;
        //    }

        //    NetworkObject nob = null;
        //    List<NetworkObject> childNobs = parentNob.ChildNetworkObjects;
        //    //Find nob with component index.
        //    for (int i = 0; i < childNobs.Count; i++)
        //    {
        //        if (childNobs[i].ComponentIndex == componentIndex)
        //        {
        //            nob = childNobs[i];
        //            break;
        //        }
        //    }
        //    //If child nob was not found.
        //    if (nob == null)
        //    {
        //        /* Purge reader of expected values.
        //        * Use networkmanager transform, it doesn't really matter
        //        * since values are discarded anyway. */
        //        ReadTransformProperties(reader, base.NetworkManager.transform, out _, out _, out _);
        //        if (NetworkManager.CanLog(LoggingType.Error))
        //            Debug.LogError($"Nested spawned object with componentIndex of {componentIndex} could not be found as a child NetworkObject of {parentNob.name}.");
        //        return null;
        //    }

        //    ReadTransformProperties(reader, nob.transform, out Vector3 pos, out Quaternion rot, out Vector3 scale);
        //    nob.transform.SetLocalPositionRotationAndScale(pos, rot, scale);

        //    return nob;
        //}

        /// <summary>
        /// Gets a nested NetworkObject within it's root.
        /// </summary>
        /// <param name="cnob"></param>
        /// <returns></returns>
        internal NetworkObject GetNestedNetworkObject(CachedNetworkObject cnob)
        {
            NetworkObject rootNob;
            int rootObjectId = cnob.RootObjectId;
            byte componentIndex = cnob.ComponentIndex;

            /* Spawns are processed after all spawns come in,
             * this ensures no reference race conditions. Turns out because of this
             * the parentNob may be in cache and not actually spawned, if it was spawned the same packet
             * as this one. So when not found in the spawned collection try to
             * find it in Spawning before throwing. */
            rootNob = _objectCache.GetSpawnedObject(rootObjectId);
            //If still null, that's not good.
            if (rootNob == null)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Nested spawned object with componentIndex of {componentIndex} and a parentId of {rootObjectId} could not be spawned because parent was not found.");
                return null;
            }

            NetworkObject nob = null;
            List<NetworkObject> childNobs = rootNob.ChildNetworkObjects;
            //Find nob with component index.
            for (int i = 0; i < childNobs.Count; i++)
            {
                if (childNobs[i].ComponentIndex == componentIndex)
                {
                    nob = childNobs[i];
                    break;
                }
            }
            //If child nob was not found.
            if (nob == null)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Nested spawned object with componentIndex of {componentIndex} could not be found as a child NetworkObject of {rootNob.name}.");
                return null;
            }

            GetTransformProperties(cnob, nob.transform, out Vector3 pos, out Quaternion rot, out Vector3 scale);
            nob.transform.SetLocalPositionRotationAndScale(pos, rot, scale);

            return nob;
        }

        /// <summary>
        /// Finds a scene NetworkObject and sets transform values.
        /// </summary>
        internal NetworkObject GetSceneNetworkObject(CachedNetworkObject cnob)
        {
            ulong sceneId = cnob.SceneId;
            NetworkObject nob;
            base.SceneObjects.TryGetValueIL2CPP(sceneId, out nob);
            //If found in scene objects.
            if (nob != null)
            {
                Transform t = nob.transform;
                GetTransformProperties(cnob, t, out Vector3 pos, out Quaternion rot, out Vector3 scale);
                t.SetLocalPositionRotationAndScale(pos, rot, scale);
                return nob;
            }
            //Not found in scene objects. Shouldn't ever happen.
            else
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"SceneId of {sceneId} not found in SceneObjects. This may occur if your scene differs between client and server, if client does not have the scene loaded, or if networked scene objects do not have a SceneCondition. See ObserverManager in the documentation for more on conditions.");
                return null;
            }
        }

        /// <summary>
        /// Instantiates a NetworkObject if required and sets transform values.
        /// </summary>
        internal NetworkObject GetInstantiatedNetworkObject(CachedNetworkObject cnob)
        {
            if (cnob.PrefabId == null)
            {
                if (base.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"PrefabId for {cnob.ObjectId} is null. Object will not spawn.");
                return null;
            }

            NetworkManager networkManager = base.NetworkManager;
            short prefabId = cnob.PrefabId.Value;
            NetworkObject result = null;

            if (prefabId == -1)
            {
                if (networkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Spawned object has an invalid prefabId. Make sure all objects which are being spawned over the network are within SpawnableObjects on the NetworkManager.");
            }
            else
            {
                //Only instantiate if not host.
                if (!networkManager.IsHost)
                {
                    Transform parentTransform = null;
                    bool hasParent = (cnob.ParentObjectId != null);
                    //Set parentTransform if there's a parent object.
                    if (hasParent)
                    {
                        int objectId = cnob.ParentObjectId.Value;
                        NetworkObject nob = _objectCache.GetSpawnedObject(objectId);

                        if (nob == null)
                        {
                            NetworkObject prefab = networkManager.SpawnablePrefabs.GetObject(false, prefabId);
                            networkManager.LogError($"NetworkObject not found for ObjectId {objectId}. Prefab {prefab.name} will be instantiated without parent synchronization.");
                        }
                        else
                        {
                            //If parent object is a network behaviour then find the component.
                            if (cnob.ParentIsNetworkBehaviour)
                            {
                                byte componentIndex = cnob.ComponentIndex;
                                NetworkBehaviour nb = nob.GetNetworkBehaviour(componentIndex, false);
                                if (nb != null)
                                {
                                    parentTransform = nb.transform;
                                }
                                else
                                {
                                    NetworkObject prefab = networkManager.SpawnablePrefabs.GetObject(false, prefabId);
                                    networkManager.LogError($"NetworkBehaviour on index {componentIndex} could nto be found within NetworkObject {nob.name} with ObjectId {objectId}. Prefab {prefab.name} will be instantiated without parent synchronization.");
                                }
                            }
                            //The networkObject is the parent.
                            else
                            {
                                parentTransform = nob.transform;
                            }
                        }
                    }

                    result = networkManager.GetPooledInstantiated(prefabId, false);
                    Transform t = result.transform;
                    t.SetParent(parentTransform, true);
                    GetTransformProperties(cnob, t, out Vector3 pos, out Quaternion rot, out Vector3 scale);
                    t.SetLocalPositionRotationAndScale(pos, rot, scale);
                    //Only need to set IsGlobal also if not host.
                    result.SetIsGlobal(cnob.SpawnType == SpawnType.InstantiatedGlobal);
                }
                //If host then find server instantiated object.
                else
                {
                    ServerObjects so = networkManager.ServerManager.Objects;
                    if (!so.Spawned.TryGetValueIL2CPP(cnob.ObjectId, out result))
                        result = so.GetFromPending(cnob.ObjectId);

                    if (result == null)
                        networkManager.LogError($"ObjectId {cnob.ObjectId} could not be found in Server spawned, nor Server pending despawn.");
                }
            }

            return result;
        }

        /// <summary>
        /// Gets a NetworkObject from Spawned, or object cache.
        /// </summary>
        /// <param name="cnob"></param>
        /// <returns></returns>
        internal NetworkObject GetSpawnedNetworkObject(CachedNetworkObject cnob)
        {
            NetworkObject nob;
            //Try checking already spawned objects first.
            if (base.Spawned.TryGetValueIL2CPP(cnob.ObjectId, out nob))
            {
                return nob;
            }
            /* If not found in already spawned objects see if
             * the networkObject is in the objectCache. It's possible the despawn
             * came immediately or shortly after the spawn message, before
             * the object has been initialized. */
            else
            {
                nob = _objectCache.GetInCached(cnob.ObjectId, ClientObjectCache.CacheSearchType.Any);
                /* Nob may be null if it's a child object being despawned, and the
                 * parent despawn already occurred. */
                return nob;
            }
        }

        /// <summary>
        /// Gets transform properties from a CachedNetworkObject, and applying defaultTransform values if properties are not found within the cached objet.
        /// </summary>
        private void GetTransformProperties(CachedNetworkObject cnob, Transform defaultTransform, out Vector3 pos, out Quaternion rot, out Vector3 scale)
        {
            pos = (cnob.LocalPosition == null) ? defaultTransform.localPosition : cnob.LocalPosition.Value;
            rot = (cnob.LocalRotation == null) ? defaultTransform.localRotation : cnob.LocalRotation.Value;
            scale = (cnob.LocalScale == null) ? defaultTransform.localScale : cnob.LocalScale.Value;
        }

        /// <summary>
        /// Finishes reading a nested object. Nested objects should always already exist beneath the parent.
        /// </summary>
        private void ReadNestedObject(PooledReader reader, out Vector3? localPosition, out Quaternion? localRotation, out Vector3? localScale)
        {
            ReadTransformProperties(reader, out localPosition, out localRotation, out localScale);
        }

        /// <summary>
        /// Finishes reading a scene object.
        /// </summary>
        private void ReadSceneObject(PooledReader reader, out ulong sceneId, out Vector3? localPosition, out Quaternion? localRotation, out Vector3? localScale)
        {
            sceneId = reader.ReadUInt64(AutoPackType.Unpacked);
            ReadTransformProperties(reader, out localPosition, out localRotation, out localScale);
        }

        /// <summary>
        /// Finishes reading a spawned object, and instantiates the object.
        /// </summary>
        private void ReadSpawnedObject(PooledReader reader, out int? parentObjectId, out byte? parentComponentIndex, out short? prefabId, out Vector3? localPosition, out Quaternion? localRotation, out Vector3? localScale)
        {
            //Parent.
            SpawnParentType spt = (SpawnParentType)reader.ReadByte();

            //Defaults.
            parentObjectId = null;
            parentComponentIndex = null;

            if (spt == SpawnParentType.NetworkObject)
            {
                int objectId = reader.ReadNetworkObjectId();
                if (objectId != -1)
                    parentObjectId = objectId;
            }
            else if (spt == SpawnParentType.NetworkBehaviour)
            {
                reader.ReadNetworkBehaviour(out int objectId, out byte componentIndex);
                if (objectId != -1)
                {
                    parentObjectId = objectId;
                    parentComponentIndex = componentIndex;
                }
            }

            prefabId = reader.ReadInt16();
            ReadTransformProperties(reader, out localPosition, out localRotation, out localScale);
        }

        ///// <summary>
        ///// Finishes reading a spawned object, and instantiates the object.
        ///// </summary>
        //private NetworkObject ReadSpawnedObject(PooledReader reader, int objectId, ObjectSpawnType ost)
        //{
        //    //Parent.
        //    SpawnParentType spt = (SpawnParentType)reader.ReadByte();
        //    Transform parentTransform = null;
        //    if (spt == SpawnParentType.NetworkObject)
        //    {
        //        NetworkObject n = reader.ReadNetworkObject();
        //        if (n != null)
        //            parentTransform = n.transform;
        //    }
        //    else if (spt == SpawnParentType.NetworkBehaviour)
        //    {
        //        NetworkBehaviour n = reader.ReadNetworkBehaviour();
        //        if (n != null)
        //            parentTransform = n.transform;
        //    }

        //    short prefabId = reader.ReadInt16();
        //    NetworkObject result = null;

        //    if (prefabId == -1)
        //    {
        //        /* Purge reader of expected values.
        //         * Use networkmanager transform, it doesn't really matter
        //         * since values are discarded anyway. */
        //        ReadTransformProperties(reader, base.NetworkManager.transform, out _, out _, out _);
        //        if (NetworkManager.CanLog(LoggingType.Error))
        //            Debug.LogError($"Spawned object has an invalid prefabId. Make sure all objects which are being spawned over the network are within SpawnableObjects on the NetworkManager.");
        //    }
        //    else
        //    {
        //        NetworkObject prefab = NetworkManager.SpawnablePrefabs.GetObject(false, prefabId);
        //        ReadTransformProperties(reader, prefab.transform, out Vector3 pos, out Quaternion rot, out Vector3 scale);

        //        //Only instantiate if not host.
        //        if (!base.NetworkManager.IsHost)
        //        {
        //            result = MonoBehaviour.Instantiate<NetworkObject>(prefab);
        //            Transform t = result.transform;
        //            t.SetParent(parentTransform, true);
        //            t.SetLocalPositionRotationAndScale(pos, rot, scale);
        //            //Only need to set IsGlobal also if not host.
        //            result.SetIsGlobal((ost == ObjectSpawnType.InstantiatedGlobal));
        //        }
        //        //If host then find server instantiated object.
        //        else
        //        {
        //            NetworkManager.ServerManager.Objects.Spawned.TryGetValueIL2CPP(objectId, out result);
        //        }
        //    }

        //    return result;
        //}

        /// <summary>
        /// Reads transform properties and applies them to a transform.
        /// </summary>
        private void ReadTransformProperties(PooledReader reader, out Vector3? localPosition, out Quaternion? localRotation, out Vector3? localScale)
        {
            //Read changed.
            ChangedTransformProperties ctp = (ChangedTransformProperties)reader.ReadByte();
            //Position.
            if (Enums.TransformPropertiesContains(ctp, ChangedTransformProperties.LocalPosition))
                localPosition = reader.ReadVector3();
            else
                localPosition = null;
            //Rotation.
            if (Enums.TransformPropertiesContains(ctp, ChangedTransformProperties.LocalRotation))
                localRotation = reader.ReadQuaternion(base.NetworkManager.ServerManager.SpawnPacking.Rotation);
            else
                localRotation = null;
            //Scale.
            if (Enums.TransformPropertiesContains(ctp, ChangedTransformProperties.LocalScale))
                localScale = reader.ReadVector3();
            else
                localScale = null;
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Client/Object/ObjectCaching.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Object;
using FishNet.Object;
using FishNet.Object.Helping;
using FishNet.Serializing;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Scripting;

namespace FishNet.Managing.Client
{

    /// <summary>
    /// Information about cached network objects.
    /// </summary>
    internal class ClientObjectCache
    {
        #region Types.
        public enum CacheSearchType
        {
            Any = 0,
            Spawning = 1,
            Despawning = 2
        }
        #endregion

        #region Internal.
        /// <summary>
        /// Objets which are being spawned during iteration.
        /// </summary>
        internal Dictionary<int, NetworkObject> SpawningObjects = new Dictionary<int, NetworkObject>();
        #endregion

        #region Private.
        /// <summary>
        /// Cached objects buffer. Contains spawns and despawns.
        /// </summary>
        private ListCache<CachedNetworkObject> _cachedObjects = new ListCache<CachedNetworkObject>();
        /// <summary>
        /// NetworkObjects which have been spawned already during the current iteration.
        /// </summary>
        private HashSet<NetworkObject> _iteratedSpawns = new HashSet<NetworkObject>();
        /// <summary>
        /// Despawns which are occurring the same tick as their spawn.
        /// </summary>
        private HashSet<int> _conflictingDespawns = new HashSet<int>();
        /// <summary>
        /// ClientObjects reference.
        /// </summary>
        private ClientObjects _clientObjects;
        /// <summary>
        /// NetworkManager for this cache.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// True if logged the warning about despawning on the same tick as the spawn.
        /// This exist to prevent excessive spam of the warning.
        /// </summary>
        private bool _loggedSameTickWarning;
        #endregion

        public ClientObjectCache(ClientObjects cobs, NetworkManager networkManager)
        {
            _clientObjects = cobs;
            _networkManager = networkManager;
        }

        /// <summary>
        /// Returns a NetworkObject found in spawned cache using objectId.
        /// </summary>
        /// <param name="objectId"></param>
        /// <returns></returns>
        public NetworkObject GetInCached(int objectId, CacheSearchType searchType)
        {
            int count = _cachedObjects.Written;
            List<CachedNetworkObject> collection = _cachedObjects.Collection;
            for (int i = 0; i < count; i++)
            {
                CachedNetworkObject cnob = collection[i];
                if (cnob.ObjectId == objectId)
                {
                    //Any condition always returns.
                    if (searchType == CacheSearchType.Any)
                        return cnob.NetworkObject;

                    bool spawning = (searchType == CacheSearchType.Spawning);
                    bool spawnAction = (cnob.Action == CachedNetworkObject.ActionType.Spawn);
                    if (spawning == spawnAction)
                        return cnob.NetworkObject;
                    else
                        return null;
                }
            }

            //Fall through.
            return null;
        }

        /// <summary>
        /// Initializes for a spawned NetworkObject.
        /// </summary>
        /// <param name="nob"></param>
        /// <param name="syncValues"></param>
        /// <param name="manager"></param>
        public void AddSpawn(NetworkManager manager, int objectId, int ownerId, SpawnType ost, byte componentIndex, int rootObjectId, int? parentObjectId, byte? parentComponentIndex
            , short? prefabId, Vector3? localPosition, Quaternion? localRotation, Vector3? localScale, ulong sceneId, ArraySegment<byte> rpcLinks, ArraySegment<byte> syncValues)
        {
            CachedNetworkObject cnob = _cachedObjects.AddReference();
            cnob.InitializeSpawn(manager, objectId, ownerId, ost, componentIndex, rootObjectId, parentObjectId, parentComponentIndex
                , prefabId, localPosition, localRotation, localScale, sceneId, rpcLinks, syncValues);
        }

        public void AddDespawn(int objectId, DespawnType despawnType)
        {
            CachedNetworkObject cnob = _cachedObjects.AddReference();
            cnob.InitializeDespawn(objectId, despawnType);
        }

        /// <summary>
        /// Iterates any written objects.
        /// </summary>
        public void Iterate()
        {
            int written = _cachedObjects.Written;
            if (written == 0)
                return;

            try
            {
                //Indexes which have already been processed.
                HashSet<int> processedIndexes = new HashSet<int>();
                List<CachedNetworkObject> collection = _cachedObjects.Collection;
                _conflictingDespawns.Clear();
                /* The next iteration will set rpclinks,
                 * synctypes, and so on. */
                for (int i = 0; i < written; i++)
                {
                    /* An index may already be processed if it was pushed ahead.
                     * This can occur if a nested object spawn exists but the root
                     * object has not spawned yet. In this situation the root spawn is
                     * found and performed first. */
                    if (processedIndexes.Contains(i))
                        continue;
                    CachedNetworkObject cnob = collection[i];
                    bool spawn = (cnob.Action == CachedNetworkObject.ActionType.Spawn);

                    /* See if nested, and if so check if root is already spawned.
                     * If parent is not spawned then find it and process the parent first. */
                    if (spawn)
                    {
                        /* When an object is nested or has a parent it is
                         * dependent upon either the root of nested, or the parent,
                         * being spawned to setup properly.
                         * 
                         * When either of these are true check spawned objects first
                         * to see if the objects exist. If not check if they are appearing
                         * later in the cache. Root or parent objects can appear later
                         * in the cache depending on the order of which observers are rebuilt.
                         * While it is possible to have the server ensure spawns always send
                         * root/parents first, that's a giant can of worms that's not worth getting into.
                         * Not only are there many scenarios to cover, but it also puts more work
                         * on the server. It's more effective to have the client handle the sorting. */

                        //Nested.
                        if (cnob.IsNested || cnob.HasParent)
                        {
                            bool nested = cnob.IsNested;
                            //It's not possible to be nested and have a parent. Set the Id to look for based on if nested or parented.
                            int targetObjectId = (nested) ? cnob.RootObjectId : cnob.ParentObjectId.Value;
                            NetworkObject nob = GetSpawnedObject(targetObjectId);
                            //If not spawned yet.
                            if (nob == null)
                            {
                                bool found = false;
                                for (int z = (i + 1); z < written; z++)
                                {
                                    CachedNetworkObject zCnob = collection[z];
                                    if (zCnob.ObjectId == targetObjectId)
                                    {
                                        found = true;
                                        if (cnob.Action != CachedNetworkObject.ActionType.Spawn)
                                        {
                                            if (_networkManager.CanLog(LoggingType.Error))
                                            {
                                                string errMsg = (nested)
                                                    ? $"ObjectId {targetObjectId} was found for a nested spawn, but ActionType is not spawn. ComponentIndex {cnob.ComponentIndex} will not be spawned."
                                                    : $"ObjectId {targetObjectId} was found for a parented spawn, but ActionType is not spawn. ObjectId {cnob.ObjectId} will not be spawned.";
                                                Debug.LogError(errMsg);
                                            }
                                            break;
                                        }
                                        else
                                        {
                                            ProcessObject(zCnob, true, z);
                                            break;
                                        }
                                    }
                                }
                                //Root nob could not be found.
                                if (!found && _networkManager.CanLog(LoggingType.Error))
                                {
                                    string errMsg = (nested)
                                        ? $"ObjectId {targetObjectId} could not be found for a nested spawn. ComponentIndex {cnob.ComponentIndex} will not be spawned."
                                        : $"ObjectId {targetObjectId} was found for a parented spawn. ObjectId {cnob.ObjectId} will not be spawned.";
                                    Debug.LogError(errMsg);
                                }
                            }
                        }
                    }

                    ProcessObject(cnob, spawn, i);
                }

                void ProcessObject(CachedNetworkObject cnob, bool spawn, int index)
                {
                    processedIndexes.Add(index);

                    if (spawn)
                    {
                        if (cnob.IsSceneObject)
                            cnob.NetworkObject = _clientObjects.GetSceneNetworkObject(cnob);
                        else if (cnob.IsNested)
                            cnob.NetworkObject = _clientObjects.GetNestedNetworkObject(cnob);
                        else
                            cnob.NetworkObject = _clientObjects.GetInstantiatedNetworkObject(cnob);
                    }
                    else
                    {
                        cnob.NetworkObject = _clientObjects.GetSpawnedNetworkObject(cnob);
                        /* Do not log unless not nested. Nested nobs sometimes
                         * could be destroyed if parent was first. */
                        if (!_networkManager.IsHost && cnob.NetworkObject == null && !cnob.IsNested)
                            _networkManager.LogError($"NetworkObject for ObjectId of {cnob.ObjectId} was found null. Unable to despawn object.");
                    }
                    NetworkObject nob = cnob.NetworkObject;
                    //No need to error here, the other Gets above would have.
                    if (nob == null)
                        return;

                    if (spawn)
                    {
                        //If not also server then object also has to be preinitialized.
                        if (!_networkManager.IsServer)
                        {
                            int ownerId = cnob.OwnerId;
                            //If local client is owner then use localconnection reference.
                            NetworkConnection localConnection = _networkManager.ClientManager.Connection;
                            NetworkConnection owner;
                            //If owner is self.
                            if (ownerId == localConnection.ClientId)
                            {
                                owner = localConnection;
                            }
                            else
                            {
                                /* If owner cannot be found then share owners
                                 * is disabled */
                                if (!_networkManager.ClientManager.Clients.TryGetValueIL2CPP(ownerId, out owner))
                                    owner = NetworkManager.EmptyConnection;
                            }
                            nob.PreinitializeInternal(_networkManager, cnob.ObjectId, owner, false);
                        }

                        _clientObjects.AddToSpawned(cnob.NetworkObject, false);
                        SpawningObjects.Add(cnob.ObjectId, cnob.NetworkObject);

                        IterateSpawn(cnob);
                        _iteratedSpawns.Add(cnob.NetworkObject);
                    }
                    else
                    {
                        /* If spawned already this iteration then the nob
                         * must be initialized so that the start/stop cycles
                         * complete normally. Otherwise, the despawn callbacks will
                         * fire immediately while the start callbacks will run after all
                         * spawns have been iterated.
                         * The downside to this is that synctypes
                         * for spawns later in this iteration will not be initialized
                         * yet, and if the nob being spawned/despawned references
                         * those synctypes the values will be default.
                         * 
                         * The alternative is to delay the despawning until after
                         * all spawns are iterated, but that will break the order
                         * reliability. This is unfortunately a lose/lose situation so
                         * the best we can do is let the user know the risk. */
                        if (_iteratedSpawns.Contains(cnob.NetworkObject))
                        {
                            if (!_loggedSameTickWarning)
                            {
                                _loggedSameTickWarning = true;
                                _networkManager.LogWarning($"NetworkObject {cnob.NetworkObject.name} is being despawned on the same tick it's spawned." +
                                               $" When this occurs SyncTypes will not be set on other objects during the time of this despawn." +
                                               $" In result, if NetworkObject {cnob.NetworkObject.name} is referencing a SyncType of another object being spawned this tick, the returned values will be default.");
                            }

                            _conflictingDespawns.Add(cnob.ObjectId);
                            cnob.NetworkObject.gameObject.SetActive(true);
                            cnob.NetworkObject.Initialize(false);
                        }
                        //Now being initialized, despawn the object.
                        IterateDespawn(cnob);
                    }
                }

                /* Lastly activate the objects after all data
                 * has been synchronized. This will execute callbacks,
                 * and any synctype hooks after the callbacks. */
                for (int i = 0; i < written; i++)
                {
                    CachedNetworkObject cnob = collection[i];
                    if (cnob.Action == CachedNetworkObject.ActionType.Spawn)
                    {
                        /* Apply syncTypes. It's very important to do this after all
                         * spawns have been processed and added to the manager.Objects collection.
                         * Otherwise, the synctype may reference an object spawning the same tick
                         * and the result would be null due to said object not being in spawned. */
                        foreach (NetworkBehaviour nb in cnob.NetworkObject.NetworkBehaviours)
                        {
                            PooledReader reader = cnob.SyncValuesReader;
                            //SyncVars.
                            int length = reader.ReadInt32();
                            nb.OnSyncType(reader, length, false);
                            //SyncObjects
                            length = reader.ReadInt32();
                            nb.OnSyncType(reader, length, true);
                        }

                        /* Only continue with the initialization if it wasn't initialized
                         * early to prevent a despawn conflict. */
                        bool canInitialize = (!_conflictingDespawns.Contains(cnob.ObjectId) || !_iteratedSpawns.Contains(cnob.NetworkObject));
                        if (canInitialize)
                        {
                            cnob.NetworkObject.gameObject.SetActive(true);
                            cnob.NetworkObject.Initialize(false);
                        }
                    }
                }
            }
            finally
            {
                //Once all have been iterated reset.
                Reset();
            }
        }

        /// <summary>
        /// Initializes an object on clients and spawns the NetworkObject.
        /// </summary>
        /// <param name="cnob"></param>
        private void IterateSpawn(CachedNetworkObject cnob)
        {
            /* All nob spawns have been added to spawned before
            * they are processed. This ensures they will be found if
            * anything is referencing them before/after initialization. */
            /* However, they have to be added again here should an ItereteDespawn
             * had removed them. This can occur if an object is set to be spawned,
             * thus added to spawned before iterations, then a despawn runs which
             * removes it from spawn. */
            _clientObjects.AddToSpawned(cnob.NetworkObject, false);

            List<ushort> rpcLinkIndexes = new List<ushort>();
            //Apply rpcLinks.
            foreach (NetworkBehaviour nb in cnob.NetworkObject.NetworkBehaviours)
            {
                PooledReader reader = cnob.RpcLinkReader;
                int length = reader.ReadInt32();

                int readerStart = reader.Position;
                while (reader.Position - readerStart < length)
                {
                    //Index of RpcLink.
                    ushort linkIndex = reader.ReadUInt16();
                    RpcLink link = new RpcLink(
                        cnob.NetworkObject.ObjectId, nb.ComponentIndex,
                        //RpcHash.
                        reader.ReadUInt16(),
                        //ObserverRpc.
                        (RpcType)reader.ReadByte());
                    //Add to links.
                    _clientObjects.SetRpcLink(linkIndex, link);

                    rpcLinkIndexes.Add(linkIndex);
                }
            }
            cnob.NetworkObject.SetRpcLinkIndexes(rpcLinkIndexes);
        }

        /// <summary>
        /// Deinitializes an object on clients and despawns the NetworkObject.
        /// </summary>
        /// <param name="cnob"></param>
        private void IterateDespawn(CachedNetworkObject cnob)
        {
            _clientObjects.Despawn(cnob.NetworkObject, cnob.DespawnType, false);
        }

        /// <summary>
        /// Returns a NetworkObject found in spawn cache, or Spawned.
        /// </summary>
        /// <param name="objectId"></param>
        internal NetworkObject GetSpawnedObject(int objectId)
        {
            NetworkObject result;
            //If not found in Spawning then check Spawned.
            if (!SpawningObjects.TryGetValue(objectId, out result))
            {
                Dictionary<int, NetworkObject> spawned = (_networkManager.IsHost) ?
                    _networkManager.ServerManager.Objects.Spawned
                    : _networkManager.ClientManager.Objects.Spawned;
                spawned.TryGetValue(objectId, out result);
            }

            return result;
        }

        /// <summary>
        /// Resets cache.
        /// </summary>
        public void Reset()
        {
            _cachedObjects.Reset();
            _iteratedSpawns.Clear();
            SpawningObjects.Clear();
        }
    }

    /// <summary>
    /// A cached network object which exist in world but has not been Initialized yet.
    /// </summary>
    [Preserve]
    internal class CachedNetworkObject
    {
        #region Types.
        public enum ActionType
        {
            Unset = 0,
            Spawn = 1,
            Despawn = 2,
        }
        #endregion

        /// <summary>
        /// True if cached object is nested.
        /// </summary>
        public bool IsNested => (ComponentIndex > 0);
        /// <summary>
        /// True if a scene object.
        /// </summary>
        public bool IsSceneObject => (SceneId > 0);
        /// <summary>
        /// True if this object has a parent.
        /// </summary>
        public bool HasParent => (ParentObjectId != null);
        /// <summary>
        /// True if the parent object is a NetworkBehaviour.
        /// </summary>
        public bool ParentIsNetworkBehaviour => (HasParent && (ParentComponentIndex != null));

        public int ObjectId;
        public int OwnerId;
        public SpawnType SpawnType;
        public DespawnType DespawnType;
        public byte ComponentIndex;
        public int RootObjectId;
        public int? ParentObjectId;
        public byte? ParentComponentIndex;
        public short? PrefabId;
        public Vector3? LocalPosition;
        public Quaternion? LocalRotation;
        public Vector3? LocalScale;
        public ulong SceneId;
        public ArraySegment<byte> RpcLinks;
        public ArraySegment<byte> SyncValues;

        /// <summary>
        /// True if spawning.
        /// </summary>
        public ActionType Action { get; private set; }
        /// <summary>
        /// Cached NetworkObject.
        /// </summary>
#pragma warning disable 0649
        public NetworkObject NetworkObject;
        /// <summary>
        /// Reader containing rpc links for the network object.
        /// </summary>
        public PooledReader RpcLinkReader { get; private set; }
        /// <summary>
        /// Reader containing sync values for the network object.
        /// </summary>
        public PooledReader SyncValuesReader { get; private set; }
#pragma warning restore 0649

        public void InitializeSpawn(NetworkManager manager, int objectId, int ownerId, SpawnType objectSpawnType, byte componentIndex, int rootObjectId, int? parentObjectId, byte? parentComponentIndex
    , short? prefabId, Vector3? localPosition, Quaternion? localRotation, Vector3? localScale, ulong sceneId, ArraySegment<byte> rpcLinks, ArraySegment<byte> syncValues)
        {
            ResetValues();
            Action = ActionType.Spawn;
            ObjectId = objectId;
            OwnerId = ownerId;
            SpawnType = objectSpawnType;
            ComponentIndex = componentIndex;
            RootObjectId = rootObjectId;
            ParentObjectId = parentObjectId;
            ParentComponentIndex = parentComponentIndex;
            PrefabId = prefabId;
            LocalPosition = localPosition;
            LocalRotation = localRotation;
            LocalScale = localScale;
            SceneId = sceneId;
            RpcLinks = rpcLinks;
            SyncValues = syncValues;

            RpcLinkReader = ReaderPool.GetReader(rpcLinks, manager);
            SyncValuesReader = ReaderPool.GetReader(syncValues, manager);
        }

        /// <summary>
        /// Initializes for a despawned NetworkObject.
        /// </summary>
        /// <param name="nob"></param>
        public void InitializeDespawn(int objectId, DespawnType despawnType)
        {
            ResetValues();
            Action = ActionType.Despawn;
            DespawnType = despawnType;
            ObjectId = objectId;
        }

        /// <summary>
        /// Resets values which could malform identify the cached object.
        /// </summary>
        private void ResetValues()
        {
            NetworkObject = null;
        }

        ~CachedNetworkObject()
        {
            if (RpcLinkReader != null)
                RpcLinkReader.Dispose();
            if (SyncValuesReader != null)
                SyncValuesReader.Dispose();
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Debugging/DebugManager.cs ---
﻿using UnityEngine;

namespace FishNet.Managing.Debugging
{
    /// <summary>
    /// A container for debugging.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/DebugManager")]
    public class DebugManager : MonoBehaviour
    {
        public bool ObserverRpcLinks = true;
        public bool TargetRpcLinks = true;
        public bool ReplicateRpcLinks = true;
        public bool ReconcileRpcLinks = true;
        public bool ServerRpcLinks = true;
    }

}

'''
'''--- Assets/FishNet/Runtime/Managing/Debugging/ParseLogger.cs ---
﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
using FishNet.Managing.Logging;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace FishNet.Managing.Debugging
{

    internal class ParseLogger
    {
        /// <summary>
        /// Contains the last several non-split packets to arrive. This is used for debugging.
        /// </summary>
        private Queue<PacketId> _incomingPacketIds = new Queue<PacketId>();
        /// <summary>
        /// Maximum number of packets allowed to be queued.
        /// </summary>
        private const int PACKET_COUNT = 5;

        /// <summary>
        /// Resets data.
        /// </summary>
        internal void Reset()
        {
            _incomingPacketIds.Clear();
        }

        /// <summary>
        /// Adds a packet to data.
        /// </summary>
        /// <param name="pId"></param>
        internal void AddPacket(PacketId pId)
        {
            _incomingPacketIds.Enqueue(pId);
            if (_incomingPacketIds.Count > PACKET_COUNT)
                _incomingPacketIds.Dequeue();
        }

        /// <summary>
        /// Prints current data.
        /// </summary>
        internal void Print(NetworkManager nm)
        {
            if (nm == null)
            {
                if (!NetworkManager.StaticCanLog(LoggingType.Error))
                    return;
            }
            else
            {
                if (!nm.CanLog(LoggingType.Error))
                    return;
            }
            
            StringBuilder sb = new StringBuilder();
            foreach (PacketId item in _incomingPacketIds)
                sb.Insert(0, $"{item.ToString()}{Environment.NewLine}");

            NetworkObject lastNob = Reader.LastNetworkObject;
            string nobData = (lastNob == null) ? "Unset" : $"Id {lastNob.ObjectId} on gameObject {lastNob.name}";
            NetworkBehaviour lastNb = Reader.LastNetworkBehaviour;
            string nbData = (lastNb == null) ? "Unset" : lastNb.GetType().Name;

            Debug.LogError($"The last {_incomingPacketIds.Count} packets to arrive are: {Environment.NewLine}{sb.ToString()}");
            Debug.LogError($"The last parsed NetworkObject is {nobData}, and NetworkBehaviour {nbData}.");

            Reset();
        }
    }

}
#endif
'''
'''--- Assets/FishNet/Runtime/Managing/Editor/NetworkManagerEditor.cs ---
﻿#if UNITY_EDITOR
using FishNet.Managing.Object;
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Editing
{
    [CustomEditor(typeof(NetworkManager))]
    public class NetworkManagerEditor : Editor
    {
        private SerializedProperty _logging;
        private SerializedProperty _refreshDefaultPrefabs;
        private SerializedProperty _runInBackground;
        private SerializedProperty _dontDestroyOnLoad;
        private SerializedProperty _persistence;
        private SerializedProperty _spawnablePrefabs;
        private SerializedProperty _objectPool;

        private void OnEnable()
        {
            _logging = serializedObject.FindProperty("_logging");
            _refreshDefaultPrefabs = serializedObject.FindProperty("_refreshDefaultPrefabs");
            _runInBackground = serializedObject.FindProperty("_runInBackground");
            _dontDestroyOnLoad = serializedObject.FindProperty("_dontDestroyOnLoad");
            _persistence = serializedObject.FindProperty("_persistence");
            _spawnablePrefabs = serializedObject.FindProperty("_spawnablePrefabs");
            _objectPool = serializedObject.FindProperty("_objectPool");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            NetworkManager networkManager = (NetworkManager)target;

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour(networkManager), typeof(NetworkManager), false);
            GUI.enabled = true;

            //EditorGUILayout.BeginVertical(GUI.skin.box);
            //EditorGUILayout.EndVertical();

            EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_runInBackground);
            EditorGUILayout.PropertyField(_dontDestroyOnLoad);
            EditorGUILayout.PropertyField(_persistence);
            EditorGUILayout.Space();
            EditorGUI.indentLevel--;

            EditorGUILayout.LabelField("Logging", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_logging);
            EditorGUILayout.Space();
            EditorGUI.indentLevel--;

            EditorGUILayout.LabelField("Prefabs", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_spawnablePrefabs);
            EditorGUILayout.PropertyField(_objectPool);
            EditorGUILayout.PropertyField(_refreshDefaultPrefabs);

            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            serializedObject.ApplyModifiedProperties();
        }
    }
}
#endif
'''
'''--- Assets/FishNet/Runtime/Managing/Logging/LoggingConfiguration.cs ---
﻿using FishNet.Documenting;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Logging
{

    /// <summary>
    /// Configuration ScriptableObject specifying which data to log. Used in conjuction with NetworkManager.
    /// </summary>
    [CreateAssetMenu(fileName = "New LoggingConfiguration", menuName = "FishNet/Logging/Logging Configuration")]
    public class LoggingConfiguration : ScriptableObject
    {

        #region Serialized.
        /// <summary>
        /// True to use logging features. False to disable all logging.
        /// </summary>
        [Tooltip("True to use logging features. False to disable all logging.")]
        [SerializeField]
        private bool _loggingEnabled = true;
        /// <summary>
        /// Type of logging to use for development builds and editor.
        /// </summary>
        [Tooltip("Type of logging to use for development builds and editor.")]
        [SerializeField]
        private LoggingType _developmentLogging = LoggingType.Common;
        /// <summary>
        /// Type of logging to use for GUI builds.
        /// </summary>
        [Tooltip("Type of logging to use for GUI builds.")]
        [SerializeField]
        private LoggingType _guiLogging = LoggingType.Warning;
        /// <summary>
        /// Type of logging to use for headless builds.
        /// </summary>
        [Tooltip("Type of logging to use for headless builds.")]
        [SerializeField]
        private LoggingType _headlessLogging = LoggingType.Error;
        #endregion

        #region Private.
        /// <summary>
        /// True when initialized.
        /// </summary>
        private bool _initialized;
        /// <summary>
        /// Highest type which can be logged.
        /// </summary>
        private LoggingType _highestLoggingType = LoggingType.Off;
        #endregion

        [APIExclude]
        public void LoggingConstructor(bool loggingEnabled, LoggingType development, LoggingType gui, LoggingType headless)
        {
            _loggingEnabled = loggingEnabled;
            _developmentLogging = development;
            _guiLogging = gui;
            _headlessLogging = headless;
        }

        /// <summary>
        /// Initializes script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnceInternal()
        {
            byte currentHighest = (byte)LoggingType.Off;
#if UNITY_SERVER //if headless.
            currentHighest = Math.Max(currentHighest, (byte)_headlessLogging);
#endif
#if UNITY_EDITOR || DEVELOPMENT_BUILD //if editor or development.
            currentHighest = Math.Max(currentHighest, (byte)_developmentLogging);
#endif
#if !UNITY_EDITOR && !UNITY_SERVER //if a build.
            currentHighest = Math.Max(currentHighest, (byte)_guiLogging);
#endif
            _highestLoggingType = (LoggingType)currentHighest;
            _initialized = true;
        }

        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        /// <param name="loggingType">Type of logging being filtered.</param>
        /// <returns></returns>
        public bool CanLog(LoggingType loggingType)
        {
            if (!_loggingEnabled)
                return false;

            if (!_initialized)
            {
#if UNITY_EDITOR || DEVELOPMENT_BUILD
                if (Application.isPlaying)
                    Debug.LogError("CanLog called before being initialized.");
                else
                    return true;
#endif
                return false;
            }

            return ((byte)loggingType <= (byte)_highestLoggingType);
        }

        /// <summary>
        /// Logs a common value if can log.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public virtual void Log(string value)
        {
            if (CanLog(LoggingType.Common))
                Debug.Log(value);
        }

        /// <summary>
        /// Logs a warning value if can log.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public virtual void LogWarning(string value)
        {
            if (CanLog(LoggingType.Warning))
                Debug.LogWarning(value);
        }

        /// <summary>
        /// Logs an error value if can log.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public virtual void LogError(string value)
        {
            if (CanLog(LoggingType.Error))
                Debug.LogError(value);
        }

        /// <summary>
        /// Clones this logging configuration.
        /// </summary>
        /// <returns></returns>
        public virtual LoggingConfiguration Clone()
        {
            LoggingConfiguration copy = ScriptableObject.CreateInstance<LoggingConfiguration>();
            copy.LoggingConstructor(_loggingEnabled, _developmentLogging, _guiLogging, _headlessLogging);
            return copy;
        }
    }
}
'''
'''--- Assets/FishNet/Runtime/Managing/Logging/LoggingType.cs ---
﻿namespace FishNet.Managing.Logging
{
    /// <summary>
    /// Type of logging being filtered.
    /// </summary>
    public enum LoggingType : byte
    {
        /// <summary>
        /// Disable logging.
        /// </summary>
        Off = 0,
        /// <summary>
        /// Only log errors.
        /// </summary>
        Error = 1,
        /// <summary>
        /// Log warnings and errors.
        /// </summary>
        Warning = 2,
        /// <summary>
        /// Log all common activities, warnings, and errors.
        /// </summary>
        Common = 3
    }
}
'''
'''--- Assets/FishNet/Runtime/Managing/NetworkManager.Logging.cs ---
﻿using FishNet.Documenting;
using FishNet.Managing.Logging;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing
{
    public partial class NetworkManager : MonoBehaviour
    {
        #region Serialized.
        /// <summary>
        /// Logging configuration to use. When empty default logging settings will be used.
        /// </summary>
        [Tooltip("Logging configuration to use. When empty default logging settings will be used.")]
        [SerializeField]
        private LoggingConfiguration _logging;
        #endregion

        #region Const.
        private const string ERROR_LOGGING_PREFIX = "Error - ";
        private const string WARNING_LOGGING_PREFIX = "Warning - ";
        private const string COMMON_LOGGING_PREFIX = "Log - ";
        #endregion

        /// <summary>
        /// Initializes logging settings.
        /// </summary>
        private void InitializeLogging()
        {
            if (_logging == null)
                _logging = ScriptableObject.CreateInstance<LoggingConfiguration>();
            else
                _logging = _logging.Clone();

            _logging.InitializeOnceInternal();
        }

        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        /// <param name="loggingType"></param>
        /// <returns></returns>
        [APIExclude]
        public static bool StaticCanLog(LoggingType loggingType)
        {
            NetworkManager nm = InstanceFinder.NetworkManager;
            return (nm == null) ? false : nm.CanLog(loggingType);
        }

        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        /// <param name="loggingType">Type of logging being filtered.</param>
        /// <returns></returns>
        public bool CanLog(LoggingType loggingType)
        {
            return _logging.CanLog(loggingType);
        }

        /// <summary>
        /// Performs a common log, should logging settings permit it.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StaticLog(string value) => InstanceFinder.NetworkManager?.Log(value);
        /// <summary>
        /// Performs a common log, should logging settings permit it.
        /// </summary>
        public void Log(string value)
        {
            _logging.Log(value);
        }

        /// <summary>
        /// Performs a warning log, should logging settings permit it.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StaticLogWarning(string value) => InstanceFinder.NetworkManager?.LogWarning(value);
        /// <summary>
        /// Performs a warning log, should logging settings permit it.
        /// </summary>
        public void LogWarning(string value)
        {
            _logging.LogWarning(value);
        }

        /// <summary>
        /// Performs an error log, should logging settings permit it.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StaticLogError(string value) => InstanceFinder.NetworkManager?.LogError(value);
        /// <summary>
        /// Performs an error log, should logging settings permit it.
        /// </summary>
        public void LogError(string value)
        {
            _logging.LogError(value);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/NetworkManager.Pro.cs ---
﻿using FishNet.Component.ColliderRollback;
using UnityEngine;

namespace FishNet.Managing
{
    public sealed partial class NetworkManager : MonoBehaviour
    {

        #region Public.
        /// <summary>
        /// RollbackManager for this NetworkManager.
        /// </summary>
        public RollbackManager RollbackManager { get; private set; }
        #endregion

        /// <summary>
        /// Adds RollbackManager.
        /// </summary>
        private void AddRollbackManager()
        {
            if (gameObject.TryGetComponent<RollbackManager>(out RollbackManager result))
                RollbackManager = result;
            else
                RollbackManager = gameObject.AddComponent<RollbackManager>();
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/NetworkManager.QOL.cs ---
﻿using FishNet.Managing.Object;
using FishNet.Object;
using System;
using UnityEngine;

namespace FishNet.Managing
{
    public partial class NetworkManager : MonoBehaviour
    {
        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Collection to use for spawnable objects.")]
        [SerializeField]
        private PrefabObjects _spawnablePrefabs;
        /// <summary>
        /// Collection to use for spawnable objects.
        /// </summary>
        public PrefabObjects SpawnablePrefabs { get => _spawnablePrefabs; set => _spawnablePrefabs = value; }
        #endregion

        /// <summary>
        /// Gets the index a prefab uses. Can be used in conjuction with GetPrefab.
        /// </summary>
        /// <param name="prefab"></param>
        /// <param name="asServer">True if to get from the server collection.</param>
        /// <returns>Returns index if found, and -1 if not found.</returns>
        public int GetPrefabIndex(GameObject prefab, bool asServer)
        {
            int count = SpawnablePrefabs.GetObjectCount();
            for (int i = 0; i < count; i++)
            {
                GameObject go = SpawnablePrefabs.GetObject(asServer, i).gameObject;
                if (go == prefab)
                    return i;
            }

            //Fall through, not found.
            return -1;
        }

        /// <summary>
        /// Returns a prefab with prefabId.
        /// This method will bypass object pooling.
        /// </summary>
        /// <param name="prefabId">PrefabId to get.</param>
        /// <param name="asServer">True if getting the prefab asServer.</param>
        public NetworkObject GetPrefab(int prefabId, bool asServer)
        {
            return GetPooledInstantiated(prefabId, asServer);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/NetworkManager.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Client;
using FishNet.Managing.Server;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using UnityEngine;
using FishNet.Managing.Scened;
using FishNet.Authenticating;
using FishNet.Object;
using FishNet.Documenting;
using FishNet.Managing.Logging;
using System.Collections.Generic;
using System;
using FishNet.Managing.Observing;
using System.Linq;
using FishNet.Managing.Debugging;
using FishNet.Managing.Object;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using FishNet.Managing.Statistic;
using FishNet.Utility.Performance;
#if UNITY_EDITOR
using FishNet.Editing.PrefabCollectionGenerator;
#endif

namespace FishNet.Managing
{
    /// <summary>
    /// Acts as a container for all things related to your networking session.
    /// </summary>
    [DefaultExecutionOrder(short.MinValue)]
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/NetworkManager")]
    public sealed partial class NetworkManager : MonoBehaviour
    {
        #region Types.
        /// <summary>
        /// Which socket to iterate data on first when as host.
        /// </summary>
        public enum HostIterationOrder
        {
            ServerFirst,
            ClientFirst
        }
        /// <summary>
        /// How to persist with multiple NetworkManagers.
        /// </summary>
        public enum PersistenceType
        {
            /// <summary>
            /// Destroy any new NetworkManagers.
            /// </summary>
            DestroyNewest,
            /// <summary>
            /// Destroy previous NetworkManager when a new NetworkManager occurs.
            /// </summary>
            DestroyOldest,
            /// <summary>
            /// Allow multiple NetworkManagers, do not destroy any automatically.
            /// </summary>
            AllowMultiple
        }

        #endregion

        #region Public.
        /// <summary>
        /// True if this instance of the NetworkManager is initialized.
        /// </summary>
        public bool Initialized { get; private set; }
        /// <summary>
        /// 
        /// </summary>
        private static List<NetworkManager> _instances = new List<NetworkManager>();
        /// <summary>
        /// Currently initialized NetworkManagers.
        /// </summary>
        public static IReadOnlyCollection<NetworkManager> Instances
        {
            get
            {
                /* Remove null instances of NetworkManager.
                * This shouldn't happen because instances are removed
                * OnDestroy but none the less something is causing
                * it. */
                for (int i = 0; i < _instances.Count; i++)
                {
                    if (_instances[i] == null)
                    {
                        _instances.RemoveAt(i);
                        i--;
                    }
                }
                return _instances;
            }
        }

        /// <summary>
        /// True if server is active.
        /// </summary>
        public bool IsServer => ServerManager.Started;
        /// <summary>
        /// True if only the server is active.
        /// </summary>
        public bool IsServerOnly => (IsServer && !IsClient);
        /// <summary>
        /// True if the client is active and authenticated.
        /// </summary>
        public bool IsClient => (ClientManager.Started && ClientManager.Connection.Authenticated);
        /// <summary>
        /// True if only the client is active and authenticated.
        /// </summary>
        public bool IsClientOnly => (!IsServer && IsClient);
        /// <summary>
        /// True if client and server are active.
        /// </summary>
        public bool IsHost => (IsServer && IsClient);
        /// <summary>
        /// True if client nor server are active.
        /// </summary>
        public bool IsOffline => (!IsServer && !IsClient);
        /// <summary>
        /// ServerManager for this NetworkManager.
        /// </summary>
        public ServerManager ServerManager { get; private set; }
        /// <summary>
        /// ClientManager for this NetworkManager.
        /// </summary>
        public ClientManager ClientManager { get; private set; }
        /// <summary>
        /// TransportManager for this NetworkManager.
        /// </summary>
        public TransportManager TransportManager { get; private set; }
        /// <summary>
        /// TimeManager for this NetworkManager.
        /// </summary>
        public TimeManager TimeManager { get; private set; }
        /// <summary>
        /// SceneManager for this NetworkManager.
        /// </summary>
        public SceneManager SceneManager { get; private set; }
        /// <summary>
        /// ObserverManager for this NetworkManager.
        /// </summary>
        public ObserverManager ObserverManager { get; private set; }
        /// <summary>
        /// Authenticator for this NetworkManager. May be null if no Authenticator is used.
        /// </summary>
        [Obsolete("Use ServerManager.GetAuthenticator or ServerManager.SetAuthenticator instead.")]
        public Authenticator Authenticator => ServerManager.Authenticator;
        /// <summary>
        /// DebugManager for this NetworkManager.
        /// </summary>
        public DebugManager DebugManager { get; private set; }
        /// <summary>
        /// StatisticsManager for this NetworkManager.
        /// </summary>
        public StatisticsManager StatisticsManager { get; private set; }
        /// <summary>
        /// An empty connection reference. Used when a connection cannot be found to prevent object creation.
        /// </summary>
        [APIExclude]
        public static NetworkConnection EmptyConnection { get; private set; } = new NetworkConnection();
        #endregion

        #region Internal.
        /// <summary>
        /// Starting index for RpcLinks.
        /// </summary>
        internal static ushort StartingRpcLinkIndex;
        #endregion

        #region Serialized.
        /// <summary>
        /// True to refresh the DefaultPrefabObjects collection whenever the editor enters play mode. This is an attempt to alleviate the DefaultPrefabObjects scriptable object not refreshing when using multiple editor applications such as ParrelSync.
        /// </summary>
        [Tooltip("True to refresh the DefaultPrefabObjects collection whenever the editor enters play mode. This is an attempt to alleviate the DefaultPrefabObjects scriptable object not refreshing when using multiple editor applications such as ParrelSync.")]
        [SerializeField]
        private bool _refreshDefaultPrefabs = false;
        /// <summary>
        /// True to have your application run while in the background.
        /// </summary>
        [Tooltip("True to have your application run while in the background.")]
        [SerializeField]
        private bool _runInBackground = true;
        /// <summary>
        /// True to make this instance DontDestroyOnLoad. This is typical if you only want one NetworkManager.
        /// </summary>
        [Tooltip("True to make this instance DontDestroyOnLoad. This is typical if you only want one NetworkManager.")]
        [SerializeField]
        private bool _dontDestroyOnLoad = true;
        /// <summary>
        /// Object pool to use for this NetworkManager. Value may be null.
        /// </summary>
        [Tooltip("Object pool to use for this NetworkManager. Value may be null.")]
        [SerializeField]
        private ObjectPool _objectPool;
        /// <summary>
        /// How to persist when other NetworkManagers are introduced.
        /// </summary>
        [Tooltip("How to persist when other NetworkManagers are introduced.")]
        [SerializeField]
        private PersistenceType _persistence = PersistenceType.DestroyNewest;
        #endregion

        #region Private.
        /// <summary>
        /// True if this NetworkManager can persist after Awake checks.
        /// </summary>
        private bool _canPersist;
        #endregion

        #region Const.
        /// <summary>
        /// Maximum framerate allowed.
        /// </summary>
        internal const ushort MAXIMUM_FRAMERATE = 500;
        #endregion

        private void Awake()
        {
            InitializeLogging();
            if (!ValidateSpawnablePrefabs(true))
                return;

            if (StartingRpcLinkIndex == 0)
                StartingRpcLinkIndex = (ushort)(EnumFN.GetHighestValue<PacketId>() + 1);

            bool isDefaultPrefabs = (SpawnablePrefabs != null && SpawnablePrefabs is DefaultPrefabObjects);
#if UNITY_EDITOR
            /* If first instance then force
             * default prefabs to repopulate.
             * This is only done in editor because
             * cloning tools sometimes don't synchronize
             * scriptable object changes, which is what
             * the default prefabs is. */
            if (_refreshDefaultPrefabs && _instances.Count == 0 && isDefaultPrefabs)
            {
                Generator.IgnorePostProcess = true;
                Debug.Log("DefaultPrefabCollection is being refreshed.");
                Generator.GenerateFull();
                Generator.IgnorePostProcess = false;
            }
#endif
            //If default prefabs then also make a new instance and sort them.
            if (isDefaultPrefabs)
            {
                DefaultPrefabObjects originalDpo = (DefaultPrefabObjects)SpawnablePrefabs;
                //If not editor then a new instance must be made and sorted.
                DefaultPrefabObjects instancedDpo = ScriptableObject.CreateInstance<DefaultPrefabObjects>();
                instancedDpo.AddObjects(originalDpo.Prefabs.ToList(), false);
                instancedDpo.Sort();
                SpawnablePrefabs = instancedDpo;
            }

            _canPersist = CanInitialize();
            if (!_canPersist)
                return;

            if (TryGetComponent<NetworkObject>(out _))
            {
                if (CanLog(LoggingType.Error))
                    Debug.LogError($"NetworkObject component found on the NetworkManager object {gameObject.name}. This is not allowed and will cause problems. Remove the NetworkObject component from this object.");
            }

            SpawnablePrefabs.InitializePrefabRange(0);
            SetDontDestroyOnLoad();
            SetRunInBackground();
            AddDebugManager();
            AddTransportManager();
            AddServerAndClientManagers();
            AddTimeManager();
            AddSceneManager();
            AddObserverManager();
            AddRollbackManager();
            AddStatisticsManager();
            AddObjectPool();
            InitializeComponents();

            _instances.Add(this);
            Initialized = true;
        }

        private void Start()
        {
            ServerManager.StartForHeadless();
        }

        private void OnDestroy()
        {
            _instances.Remove(this);
        }

        /// <summary>
        /// Initializes components. To be called after all components are added.
        /// </summary>
        private void InitializeComponents()
        {
            TimeManager.InitializeOnceInternal(this);
            TimeManager.OnLateUpdate += TimeManager_OnLateUpdate;
            SceneManager.InitializeOnceInternal(this);
            TransportManager.InitializeOnceInternal(this);
            ServerManager.InitializeOnceInternal(this);
            ClientManager.InitializeOnceInternal(this);
            ObserverManager.InitializeOnceInternal(this);
            RollbackManager.InitializeOnceInternal(this);
            StatisticsManager.InitializeOnceInternal(this);
            _objectPool.InitializeOnce(this);
        }

        /// <summary>
        /// Updates the frame rate based on server and client status.
        /// </summary>
        internal void UpdateFramerate()
        {
            bool clientStarted = ClientManager.Started;
            bool serverStarted = ServerManager.Started;

            int frameRate = 0;
            //If both client and server are started then use whichever framerate is higher.
            if (clientStarted && serverStarted)
                frameRate = Math.Max(ServerManager.FrameRate, ClientManager.FrameRate);
            else if (clientStarted)
                frameRate = ClientManager.FrameRate;
            else if (serverStarted)
                frameRate = ServerManager.FrameRate;

            /* Make sure framerate isn't set to max on server.
             * If it is then default to tick rate. If framerate is
             * less than tickrate then also set to tickrate. */
#if UNITY_SERVER
            ushort minimumServerFramerate = (ushort)(TimeManager.TickRate + 1);
            if (frameRate == MAXIMUM_FRAMERATE)
                frameRate = minimumServerFramerate;
            else if (frameRate < TimeManager.TickRate)
                frameRate = minimumServerFramerate;
#endif
            //If there is a framerate to set.
            if (frameRate > 0)
                Application.targetFrameRate = frameRate;
        }

        /// <summary>
        /// Called when MonoBehaviours call LateUpdate.
        /// </summary>
        private void TimeManager_OnLateUpdate()
        {
            /* Some reason runinbackground becomes unset
            * or the setting goes ignored some times when it's set
            * in awake. Rather than try to fix or care why Unity
            * does this just set it in LateUpdate(or Update). */
            SetRunInBackground();
        }

        /// <summary>
        /// Returns if this NetworkManager can initialize.
        /// </summary>
        /// <returns></returns>
        private bool CanInitialize()
        {
            /* If allow multiple then any number of
             * NetworkManagers are allowed. Don't
             * automatically destroy any. */
            if (_persistence == PersistenceType.AllowMultiple)
                return true;

            List<NetworkManager> instances = Instances.ToList();
            //This is the first instance, it may initialize.
            if (instances.Count == 0)
                return true;

            //First instance of NM.
            NetworkManager firstInstance = instances[0];

            //If to destroy the newest.
            if (_persistence == PersistenceType.DestroyNewest)
            {
                if (CanLog(LoggingType.Common))
                    Debug.Log($"NetworkManager on object {gameObject.name} is being destroyed due to persistence type {_persistence}. A NetworkManager instance already exist on {firstInstance.name}.");
                Destroy(gameObject);
                //This one is being destroyed because its the newest.
                return false;
            }
            //If to destroy the oldest.
            else if (_persistence == PersistenceType.DestroyOldest)
            {
                if (CanLog(LoggingType.Common))
                    Debug.Log($"NetworkManager on object {firstInstance.name} is being destroyed due to persistence type {_persistence}. A NetworkManager instance has been created on {gameObject.name}.");
                Destroy(firstInstance.gameObject);
                //This being the new one will persist, allow initialization.
                return true;
            }
            //Unhandled.
            else
            {
                if (CanLog(LoggingType.Error))
                    Debug.Log($"Persistance type of {_persistence} is unhandled on {gameObject.name}. Initialization will not proceed.");

                return false;
            }
        }

        /// <summary>
        /// Validates SpawnablePrefabs field and returns if validated successfully.
        /// </summary>
        /// <returns></returns>
        private bool ValidateSpawnablePrefabs(bool print)
        {
            //If null and object is in a scene.
            if (SpawnablePrefabs == null && !string.IsNullOrEmpty(gameObject.scene.name))
            {
                //Always throw an error as this would cause failure.
                if (print)
                    Debug.LogError($"SpawnablePrefabs is null on {gameObject.name}. Select the NetworkManager in scene {gameObject.scene.name} and choose a prefabs file. Choosing DefaultPrefabObjects will automatically populate prefabs for you.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Sets DontDestroyOnLoad if configured to.
        /// </summary>
        private void SetDontDestroyOnLoad()
        {
            if (_dontDestroyOnLoad)
                DontDestroyOnLoad(this);
        }

        /// <summary>
        /// Sets Application.runInBackground to runInBackground.
        /// </summary>
        private void SetRunInBackground()
        {
            Application.runInBackground = _runInBackground;
        }

        /// <summary>
        /// Adds DebugManager.
        /// </summary>
        private void AddDebugManager()
        {
            if (gameObject.TryGetComponent<DebugManager>(out DebugManager result))
                DebugManager = result;
            else
                DebugManager = gameObject.AddComponent<DebugManager>();
        }

        /// <summary>
        /// Adds TransportManager.
        /// </summary>
        private void AddTransportManager()
        {
            if (gameObject.TryGetComponent<TransportManager>(out TransportManager result))
                TransportManager = result;
            else
                TransportManager = gameObject.AddComponent<TransportManager>();
        }

        /// <summary>
        /// Adds TimeManager.
        /// </summary>
        private void AddTimeManager()
        {
            if (gameObject.TryGetComponent<TimeManager>(out TimeManager result))
                TimeManager = result;
            else
                TimeManager = gameObject.AddComponent<TimeManager>();
        }

        /// <summary>
        /// Adds SceneManager.
        /// </summary>
        private void AddSceneManager()
        {
            if (gameObject.TryGetComponent<SceneManager>(out SceneManager result))
                SceneManager = result;
            else
                SceneManager = gameObject.AddComponent<SceneManager>();
        }

        /// <summary>
        /// Adds ObserverManager.
        /// </summary>
        private void AddObserverManager()
        {
            if (gameObject.TryGetComponent<ObserverManager>(out ObserverManager result))
                ObserverManager = result;
            else
                ObserverManager = gameObject.AddComponent<ObserverManager>();
        }

        /// <summary>
        /// Adds StatisticsManager
        /// </summary>
        private void AddStatisticsManager()
        {
            if (gameObject.TryGetComponent<StatisticsManager>(out StatisticsManager result))
                StatisticsManager = result;
            else
                StatisticsManager = gameObject.AddComponent<StatisticsManager>();
        }

        /// <summary>
        /// Adds DefaultObjectPool if no ObjectPool is specified.
        /// </summary>
        private void AddObjectPool()
        {
            if (_objectPool == null)
            {
                if (gameObject.TryGetComponent<DefaultObjectPool>(out DefaultObjectPool result))
                    _objectPool = result;
                else
                    _objectPool = gameObject.AddComponent<DefaultObjectPool>();
            }
        }

        /// <summary>
        /// Adds and assigns NetworkServer and NetworkClient if they are not already setup.
        /// </summary>
        private void AddServerAndClientManagers()
        {
            //Add servermanager.
            if (gameObject.TryGetComponent<ServerManager>(out ServerManager sm))
                ServerManager = sm;
            else
                ServerManager = gameObject.AddComponent<ServerManager>();

            //Add clientmanager.
            if (gameObject.TryGetComponent<ClientManager>(out ClientManager cm))
                ClientManager = cm;
            else
                ClientManager = gameObject.AddComponent<ClientManager>();
        }

        #region Object pool.
        /// <summary>
        /// Returns an instantiated copy of prefab.
        /// </summary>
        public NetworkObject GetPooledInstantiated(NetworkObject prefab, bool asServer)
        {
            return _objectPool.RetrieveObject(prefab.PrefabId, asServer);
        }
        /// <summary>
        /// Returns an instantiated copy of prefab.
        /// </summary>
        public NetworkObject GetPooledInstantiated(GameObject prefab, bool asServer)
        {
            NetworkObject nob = prefab.GetComponent<NetworkObject>();
            if (nob == null)
            {
                LogError($"NetworkObject was not found on {prefab}. An instantiated NetworkObject cannot be returned.");
                return null;
            }
            else
            {
                return _objectPool.RetrieveObject(nob.PrefabId, asServer);
            }
        }
        /// <summary>
        /// Returns an instantiated object that has prefabId.
        /// </summary>
        public NetworkObject GetPooledInstantiated(int prefabId, bool asServer)
        {
            return _objectPool.RetrieveObject(prefabId, asServer);
        }
        /// <summary>
        /// Stores an instantiated object.
        /// </summary>
        public void StorePooledInstantiated(NetworkObject instantiated, int prefabId, bool asServer)
        {
            _objectPool.StoreObject(instantiated, prefabId, asServer);
        }
        #endregion

        #region Editor.
#if UNITY_EDITOR
        private void OnValidate()
        {
            if (SpawnablePrefabs == null)
                Reset();
        }
        private void Reset()
        {
            ValidateSpawnablePrefabs(true);
        }

#endif

        #endregion

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Object/DualPrefab.cs ---
using FishNet.Object;

namespace FishNet.Managing.Object
{

    /// <summary>
    /// When using dual prefabs, defines which prefab to spawn for server, and which for clients.
    /// </summary>
    [System.Serializable]
    public struct DualPrefab
    {
        public NetworkObject Server;
        public NetworkObject Client;
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Object/ManagedObjects.cs ---
﻿using FishNet.Component.Observing;
using FishNet.Managing.Logging;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Object
{
    public abstract class ManagedObjects
    {
        #region Public.
        /// <summary>
        /// NetworkObjects which are currently active.
        /// </summary>
        public Dictionary<int, NetworkObject> Spawned = new Dictionary<int, NetworkObject>();
        #endregion

        #region Protected.
        /// <summary>
        /// Returns the next ObjectId to use.
        /// </summary>
        protected internal virtual int GetNextNetworkObjectId() { return -1; }
        /// <summary>
        /// NetworkManager handling this.
        /// </summary>
        protected NetworkManager NetworkManager = null;
        /// <summary>
        /// Objects in currently loaded scenes. These objects can be active or inactive.
        /// Key is the objectId while value is the object. Key is not the same as NetworkObject.ObjectId.
        /// </summary>
        protected Dictionary<ulong, NetworkObject> SceneObjects = new Dictionary<ulong, NetworkObject>();
        #endregion

        /// <summary>
        /// Subscribes to SceneManager.SceneLoaded event.
        /// </summary>
        /// <param name="subscribe"></param>
        internal void SubscribeToSceneLoaded(bool subscribe)
        {
            if (subscribe)
                SceneManager.sceneLoaded += SceneManager_sceneLoaded;
            else
                SceneManager.sceneLoaded -= SceneManager_sceneLoaded;
        }

        /// <summary>
        /// Called when a scene is loaded.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="arg1"></param>
        protected internal virtual void SceneManager_sceneLoaded(Scene s, LoadSceneMode arg1) { }

        /// <summary>
        /// Called when a NetworkObject runs Deactivate.
        /// </summary>
        /// <param name="nob"></param>
        internal virtual void NetworkObjectUnexpectedlyDestroyed(NetworkObject nob)
        {
            if (nob == null)
                return;

            RemoveFromSpawned(nob, true);
        }

        /// <summary>
        /// Removes a NetworkedObject from spawned.
        /// </summary>
        /// <param name="nob"></param>
        private void RemoveFromSpawned(NetworkObject nob, bool unexpectedlyDestroyed)
        {
            Spawned.Remove(nob.ObjectId);
            //Do the same with SceneObjects.
            if (unexpectedlyDestroyed && nob.IsSceneObject)
                RemoveFromSceneObjects(nob);
        }

        /// <summary>
        /// Removes a NetworkedObject from spawned.
        /// </summary>
        /// <param name="nob"></param>
        private void RemoveFromSpawned(int objectId, bool unexpectedlyDestroyed, ulong sceneId)
        {
            Spawned.Remove(objectId);
            //Do the same with SceneObjects.
            if (unexpectedlyDestroyed && (sceneId != 0))
                RemoveFromSceneObjects(sceneId);
        }

        /// <summary>
        /// Despawns a NetworkObject.
        /// </summary>
        internal virtual void Despawn(NetworkObject nob, DespawnType despawnType, bool asServer)
        {
            if (nob == null)
            {
                NetworkManager.LogWarning($"Cannot despawn a null NetworkObject.");
                return;
            }

            //True if should be destroyed, false if deactivated.
            bool destroy = false;
            /* Only modify object state if asServer,
             * or !asServer and not host. This is so clients, when acting as
             * host, don't destroy objects they lost observation of. */

            /* Nested prefabs can never be destroyed. Only check to 
             * destroy if not nested. By nested prefab, this means the object
             * despawning is part of another prefab that is also a spawned
             * network object. */
            if (!nob.IsNested)
            {
                //If as server.
                if (asServer)
                {
                    //Scene object.
                    if (!nob.IsSceneObject)
                    {
                        /* If client-host has visibility
                         * then disable and wait for client-host to get destroy
                         * message. Otherwise destroy immediately. */
                        if (nob.Observers.Contains(NetworkManager.ClientManager.Connection))
                            NetworkManager.ServerManager.Objects.AddToPending(nob);
                        else
                            destroy = true;
                    }
                }
                //Not as server.
                else
                {
                    bool isServer = NetworkManager.IsServer;
                    //Only check to destroy if not a scene object.
                    if (!nob.IsSceneObject)
                    {
                        /* If was removed from pending then also destroy.
                        * Pending objects are ones that exist on the server
                        * side only to await destruction from client side.
                        * Objects can also be destroyed if server is not
                        * active. */
                        destroy = (!isServer || NetworkManager.ServerManager.Objects.RemoveFromPending(nob.ObjectId));
                    }
                }
            }

            //Deinitialize to invoke callbacks.
            nob.Deinitialize(asServer);
            //Remove from match condition only if server.
            if (asServer)
                MatchCondition.RemoveFromMatchWithoutRebuild(nob, NetworkManager);
            RemoveFromSpawned(nob, false);

            //If to destroy.
            if (destroy)
            {
                if (despawnType == DespawnType.Destroy)
                    MonoBehaviour.Destroy(nob.gameObject);
                else
                    NetworkManager.StorePooledInstantiated(nob, nob.PrefabId, asServer);
            }
            /* If to potentially disable instead of destroy.
             * This is such as something is despawning server side
             * but a clientHost is present, or if a scene object. */
            else
            {
                //If as server.
                if (asServer)
                {
                    //If not clientHost then the object can be disabled.
                    if (!NetworkManager.IsClient)
                        nob.gameObject.SetActive(false);
                }
                //Not as server.
                else
                {
                    //If the server is not active then the object can be disabled.
                    if (!NetworkManager.IsServer)
                    {
                        nob.gameObject.SetActive(false);
                    }
                    //If also server then checks must be done.
                    else
                    {
                        /* Object is still spawned on the server side. This means
                         * the clientHost likely lost visibility. When this is the case
                         * update clientHost renderers. */
                        if (NetworkManager.ServerManager.Objects.Spawned.ContainsKey(nob.ObjectId))
                            nob.SetRenderersVisible(false);
                        /* No longer spawned on the server, can
                         * deactivate on the client. */
                        else
                            nob.gameObject.SetActive(false);
                    }
                }

                /* Also despawn child objects.
                 * This only must be done when not destroying
                 * as destroying would result in the despawn being
                 * forced. 
                 *
                 * Only run if asServer as well. The server will send
                 * individual despawns for each child. */
                if (asServer)
                {
                    foreach (NetworkObject childNob in nob.ChildNetworkObjects)
                    {
                        if (childNob != null && !childNob.IsDeinitializing)
                            Despawn(childNob, despawnType, asServer);
                    }
                }
            }

        }

        /// <summary>
        /// Updates NetworkBehaviours on nob.
        /// </summary>
        /// <param name="asServer"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected void UpdateNetworkBehaviours(NetworkObject nob, bool asServer)
        {
            //Would have already been done on server side.
            if (!asServer && NetworkManager.IsServer)
                return;

            InitializePrefab(nob, -1);
        }

        /// <summary>
        /// Initializes a prefab, not to be mistaken for initializing a spawned object.
        /// </summary>
        /// <param name="prefab">Prefab to initialize.</param>
        /// <param name="index">Index within spawnable prefabs.</param>
        public static void InitializePrefab(NetworkObject prefab, int index)
        {
            if (prefab == null)
                return;
            /* Only set the Id if not -1. 
             * A value of -1 would indicate it's a scene
             * object. */
            if (index != -1)
                prefab.PrefabId = (short)index;

            byte componentIndex = 0;
            prefab.UpdateNetworkBehaviours(null, ref componentIndex);
        }

        /// <summary>
        /// Despawns Spawned NetworkObjects. Scene objects will be disabled, others will be destroyed.
        /// </summary>
        protected virtual void DespawnSpawnedWithoutSynchronization(bool asServer)
        {
            foreach (NetworkObject nob in Spawned.Values)
                DespawnWithoutSynchronization(nob, asServer, nob.GetDefaultDespawnType(), false);

            Spawned.Clear();
        }

        /// <summary>
        /// Despawns a network object.
        /// </summary>
        /// <param name="nob"></param>
        protected virtual void DespawnWithoutSynchronization(NetworkObject nob, bool asServer, DespawnType despawnType, bool removeFromSpawned)
        {
            //Null can occur when running as host and server already despawns such as wehen stopping.
            if (nob == null)
                return;

            nob.Deinitialize(asServer);
            /* Only run if asServer, or not 
            * asServer and server isn't running. This
            * prevents objects from affecting the server
            * as host* when being modified client side. */
            if (asServer || (!asServer && !NetworkManager.IsServer))
            {
                if (removeFromSpawned)
                    RemoveFromSpawned(nob, false);
                if (nob.IsSceneObject)
                {
                    nob.gameObject.SetActive(false);
                }
                else
                {
                    if (despawnType == DespawnType.Destroy)
                        MonoBehaviour.Destroy(nob.gameObject);
                    else
                        NetworkManager.StorePooledInstantiated(nob, nob.PrefabId, asServer);
                }
            }
        }

        /// <summary>
        /// Adds a NetworkObject to Spawned.
        /// </summary>
        /// <param name="nob"></param>
        internal void AddToSpawned(NetworkObject nob, bool asServer)
        {
            Spawned[nob.ObjectId] = nob;

            //If being added as client and is also server.
            if (!asServer && NetworkManager.IsServer)
                nob.SetRenderersVisible(true);
        }

        /// <summary>
        /// Adds a NetworkObject to SceneObjects.
        /// </summary>
        /// <param name="nob"></param>
        protected internal void AddToSceneObjects(NetworkObject nob)
        {
            SceneObjects[nob.SceneId] = nob;
        }

        /// <summary>
        /// Removes a NetworkObject from SceneObjects.
        /// </summary>
        /// <param name="nob"></param>
        protected internal void RemoveFromSceneObjects(NetworkObject nob)
        {
            SceneObjects.Remove(nob.SceneId);
        }

        /// <summary>
        /// Removes a NetworkObject from SceneObjects.
        /// </summary>
        /// <param name="nob"></param>
        protected internal void RemoveFromSceneObjects(ulong sceneId)
        {
            SceneObjects.Remove(sceneId);
        }

        /// <summary>
        /// Finds a NetworkObject within Spawned.
        /// </summary>
        /// <param name="objectId"></param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected internal NetworkObject GetSpawnedNetworkObject(int objectId)
        {
            NetworkObject r;
            if (!Spawned.TryGetValueIL2CPP(objectId, out r))
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Spawned NetworkObject not found for ObjectId {objectId}.");
            }

            return r;
        }

        /// <summary>
        /// Tries to skip data length for a packet.
        /// </summary>
        /// <param name="packetId"></param>
        /// <param name="reader"></param>
        /// <param name="dataLength"></param>
        protected internal void SkipDataLength(ushort packetId, PooledReader reader, int dataLength, int rpcLinkObjectId = -1)
        {
            /* -1 means length wasn't set, which would suggest a reliable packet.
            * Object should never be missing for reliable packets since spawns
            * and despawns are reliable in order. */
            if (dataLength == (int)MissingObjectPacketLength.Reliable)
            {
                string msg;
                bool isRpcLink = (packetId >= NetworkManager.StartingRpcLinkIndex);
                if (isRpcLink)
                {
                    msg = (rpcLinkObjectId == -1) ?
                        $"RPCLink of Id {(PacketId)packetId} could not be found. Remaining data will be purged." :
                        $"ObjectId {rpcLinkObjectId} for RPCLink {(PacketId)packetId} could not be found.";
                }
                else
                {
                    msg = $"NetworkBehaviour could not be found for packetId {(PacketId)packetId}. Remaining data will be purged.";
                }

                /* Default logging for server is errors only. Use error on client and warning
                 * on servers to reduce chances of allocation attacks. */
#if DEVELOPMENT_BUILD || UNITY_EDITOR || !UNITY_SERVER
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError(msg);
#else
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning(msg);
#endif
                reader.Skip(reader.Remaining);
            }
            /* If length is known then is unreliable packet. It's possible
             * this packetId arrived before or after the object was spawned/destroyed.
             * Skip past the data for this packet and use rest in reader. With non-linked
             * RPCs length is sent before object information. */
            else if (dataLength >= 0)
            {
                reader.Skip(Math.Min(dataLength, reader.Remaining));
            }
            /* -2 indicates the length is very long. Don't even try saving
             * the packet, user shouldn't be sending this much data over unreliable. */
            else if (dataLength == (int)MissingObjectPacketLength.PurgeRemaiming)
            {
                reader.Skip(reader.Remaining);
            }
        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Managing/Object/ObjectSpawnType.cs ---
﻿namespace FishNet.Managing.Object
{
    internal enum SpawnType : byte
    {
        Unset = 0,
        Scene = 1,
        Instantiated = 2,
        InstantiatedGlobal = 3,
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Object/PrefabObjects/DefaultPrefabObjects.cs ---
using FishNet.Documenting;
using FishNet.Object.Helping;
using System.Collections.Generic;
using UnityEngine;
#if UNITY_EDITOR
using FishNet.Editing;
using UnityEditor;
#endif
using FishNet.Object;

namespace FishNet.Managing.Object
{

    [APIExclude]
    //[CreateAssetMenu(fileName = "New DefaultPrefabObjects", menuName = "FishNet/Spawnable Prefabs/Default Prefab Objects")]
    public class DefaultPrefabObjects : SinglePrefabObjects
    {
        /// <summary>
        /// Sets asset path hashes for prefabs starting at index, or if missing.
        /// </summary
        /// <return>Returns true if one or more NetworkObjects were updated.</return>
        internal bool SetAssetPathHashes(int index)
        {
#if UNITY_EDITOR
            bool dirtied = false;
            int count = base.GetObjectCount();

            if (count == 0)
                return false;
            if (index < 0 || index >= count)
            {
                Debug.LogError($"Index {index} is out of range when trying to set asset path hashes. Collection length is {count}. Defaulf prefabs may need to be rebuilt.");
                return false;
            }

            for (int i = 0; i < count; i++)
            {
                NetworkObject n = base.Prefabs[i];
                if (i < index)
                    continue;

                string pathAndName = $"{AssetDatabase.GetAssetPath(n.gameObject)}{n.gameObject.name}";
                ulong hashcode = Hashing.GetStableHash64(pathAndName);
                //Already set.
                if (n.AssetPathHash == hashcode)
                    continue;

                n.SetAssetPathHash(hashcode);
                EditorUtility.SetDirty(n);
                dirtied = true;
            }

            return dirtied;
#else
            return false;
#endif
        }

        /// <summary> 
        /// Sorts prefabs by name and path hashcode.
        /// </summary>
        internal void Sort()
        {
            if (base.GetObjectCount() == 0)
                return;

            Dictionary<ulong, NetworkObject> hashcodesAndNobs = new Dictionary<ulong, NetworkObject>();
            List<ulong> hashcodes = new List<ulong>();

            bool error = false;
            foreach (NetworkObject n in base.Prefabs)
            {
                hashcodes.Add(n.AssetPathHash);
                //If hashcode is 0 something is wrong
                if (n.AssetPathHash == 0)
                {
                    error = true;
                    Debug.LogError($"AssetPathHash is not set for GameObject {n.name}.");
                    
                }
                hashcodesAndNobs.Add(n.AssetPathHash, n);
            }
            //An error occured, no reason to continue.
            if (error)
            {
                Debug.LogError($"One or more NetworkObject prefabs did not have their AssetPathHash set. This usually occurs when a prefab cannot be saved. Check the specified prefabs for missing scripts or serialization errors and correct them, then use Fish-Networking -> Refresh Default Prefabs.");
                return;
            }

            //Once all hashes have been made re-add them to prefabs sorted.
            hashcodes.Sort();
            //Build to a new list using sorted hashcodes.
            List<NetworkObject> sortedNobs = new List<NetworkObject>();
            foreach (ulong hc in hashcodes)
                sortedNobs.Add(hashcodesAndNobs[hc]);

            base.Clear();
            base.AddObjects(sortedNobs, false);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Object/PrefabObjects/DualPrefabObjects.cs ---
using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Object;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Object
{

    //document
    [APIExclude]
    [CreateAssetMenu(fileName = "New DualPrefabObjects", menuName = "FishNet/Spawnable Prefabs/Dual Prefab Objects")]
    public class DualPrefabObjects : PrefabObjects
    {
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Prefabs which may be spawned.")]
        [SerializeField]
        private List<DualPrefab> _prefabs = new List<DualPrefab>();
        /// <summary>
        /// Prefabs which may be spawned.
        /// </summary>
        public IReadOnlyCollection<DualPrefab> Prefabs => _prefabs;

        public override void Clear()
        {
            _prefabs.Clear();
        }
        public override int GetObjectCount()
        {
            return _prefabs.Count;
        }

        public override NetworkObject GetObject(bool asServer, int id)
        {
            if (id < 0 || id >= _prefabs.Count)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Error))
                    Debug.LogError($"PrefabId {id} is out of range.");
                return null;
            }
            else
            {
                DualPrefab dp = _prefabs[id];
                NetworkObject nob = (asServer) ? dp.Server : dp.Client;
                if (nob == null)
                {
                    if (NetworkManager.StaticCanLog(LoggingType.Error))
                    {
                        string lookupSide = (asServer) ? "server" : "client";
                        Debug.LogError($"Prefab for {lookupSide} on id {id} is null ");
                    }
                }

                return nob;
            }
        }

        public override void RemoveNull()
        {
            for (int i = 0; i < _prefabs.Count; i++)
            {
                if (_prefabs[i].Server == null || _prefabs[i].Client == null)
                {
                    _prefabs.RemoveAt(i);
                    i--;
                }
            }

            if (Application.isPlaying)
                InitializePrefabRange(0);
        }

        public override void AddObject(DualPrefab dualPrefab, bool checkForDuplicates = false)
        {
            AddObjects(new DualPrefab[] { dualPrefab }, checkForDuplicates);
        }

        public override void AddObjects(List<DualPrefab> dualPrefabs, bool checkForDuplicates = false)
        {
            AddObjects(dualPrefabs.ToArray(), checkForDuplicates);
        }

        public override void AddObjects(DualPrefab[] dualPrefabs, bool checkForDuplicates = false)
        {
            if (!checkForDuplicates)
            {
                _prefabs.AddRange(dualPrefabs);
            }
            else
            {
                foreach (DualPrefab dp in dualPrefabs)
                    AddUniqueNetworkObjects(dp);
            }

            if (Application.isPlaying)
                InitializePrefabRange(0);
        }

        private void AddUniqueNetworkObjects(DualPrefab dp)
        {
            for (int i = 0; i < _prefabs.Count; i++)
            {
                if (_prefabs[i].Server == dp.Server && _prefabs[i].Client == dp.Client)
                    return;
            }

            _prefabs.Add(dp);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override void InitializePrefabRange(int startIndex)
        {
            for (int i = startIndex; i < _prefabs.Count; i++)
            {
                ManagedObjects.InitializePrefab(_prefabs[i].Server, i);
                ManagedObjects.InitializePrefab(_prefabs[i].Client, i);
            }
        }

        #region Unused.
        public override void AddObject(NetworkObject networkObject, bool checkForDuplicates = false)
        {
            if (NetworkManager.StaticCanLog(LoggingType.Error))
                Debug.LogError($"Single prefabs are not supported with DualPrefabObjects. Make a SinglePrefabObjects asset instead.");
        }

        public override void AddObjects(List<NetworkObject> networkObjects, bool checkForDuplicates = false)
        {
            if (NetworkManager.StaticCanLog(LoggingType.Error))
                Debug.LogError($"Single prefabs are not supported with DualPrefabObjects. Make a SinglePrefabObjects asset instead.");
        }

        public override void AddObjects(NetworkObject[] networkObjects, bool checkForDuplicates = false)
        {
            if (NetworkManager.StaticCanLog(LoggingType.Error))
                Debug.LogError($"Single prefabs are not supported with DualPrefabObjects. Make a SinglePrefabObjects asset instead.");
        }
        #endregion
    }
}
'''
'''--- Assets/FishNet/Runtime/Managing/Object/PrefabObjects/PrefabObjects.cs ---
using FishNet.Documenting;
using FishNet.Object;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Managing.Object
{
    //document
    [APIExclude]
    public abstract class PrefabObjects : ScriptableObject
    {
        public abstract void Clear();
        public abstract int GetObjectCount();
        public abstract NetworkObject GetObject(bool asServer, int id);
        public abstract void RemoveNull();
        public abstract void AddObject(NetworkObject networkObject, bool checkForDuplicates = false);
        public abstract void AddObjects(List<NetworkObject> networkObjects, bool checkForDuplicates = false);
        public abstract void AddObjects(NetworkObject[] networkObjects, bool checkForDuplicates = false);
        public abstract void AddObject(DualPrefab dualPrefab, bool checkForDuplicates = false);
        public abstract void AddObjects(List<DualPrefab> dualPrefab, bool checkForDuplicates = false);
        public abstract void AddObjects(DualPrefab[] dualPrefab, bool checkForDuplicates = false);
        public abstract void InitializePrefabRange(int startIndex);
    }
}
'''
'''--- Assets/FishNet/Runtime/Managing/Object/PrefabObjects/SinglePrefabObjects.cs ---
using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Object
{
    //document
    [APIExclude]
    [CreateAssetMenu(fileName = "New SinglePrefabObjects", menuName = "FishNet/Spawnable Prefabs/Single Prefab Objects")]
    public class SinglePrefabObjects : PrefabObjects
    {
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Prefabs which may be spawned.")]
        [SerializeField]
        private List<NetworkObject> _prefabs = new List<NetworkObject>();
        /// <summary>
        /// Prefabs which may be spawned.
        /// </summary>
        public IReadOnlyList<NetworkObject> Prefabs => _prefabs;

        public override void Clear()
        {
            _prefabs.Clear();
        }
        public override int GetObjectCount()
        {
            return _prefabs.Count;
        }
        public override NetworkObject GetObject(bool asServer, int id)
        {
            if (id < 0 || id >= _prefabs.Count)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Error))
                    Debug.LogError($"PrefabId {id} is out of range.");
                return null;
            }
            else
            {
                NetworkObject nob = _prefabs[id];
                if (nob == null)
                {
                    if (NetworkManager.StaticCanLog(LoggingType.Error))
                        Debug.LogError($"Prefab on id {id} is null.");
                }

                return nob;
            }
        }

        public override void RemoveNull()
        {
            for (int i = 0; i < _prefabs.Count; i++)
            {
                if (_prefabs[i] == null)
                {
                    _prefabs.RemoveAt(i);
                    i--;
                }
            }

            if (Application.isPlaying)
                InitializePrefabRange(0);
        }

        public override void AddObject(NetworkObject networkObject, bool checkForDuplicates = false)
        {
            if (!checkForDuplicates)
                _prefabs.Add(networkObject);
            else
                AddUniqueNetworkObject(networkObject);

            if (Application.isPlaying)
                InitializePrefabRange(0);
        }

        public override void AddObjects(List<NetworkObject> networkObjects, bool checkForDuplicates = false)
        {
            if (!checkForDuplicates)
            {
                _prefabs.AddRange(networkObjects);
            }
            else
            {
                foreach (NetworkObject nob in networkObjects)
                    AddUniqueNetworkObject(nob);
            }

            if (Application.isPlaying)
                InitializePrefabRange(0);
        }
        public override void AddObjects(NetworkObject[] networkObjects, bool checkForDuplicates = false)
        {
            AddObjects(networkObjects.ToList(), checkForDuplicates);
        }

        private void AddUniqueNetworkObject(NetworkObject nob)
        {
            if (!_prefabs.Contains(nob))
                _prefabs.Add(nob);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override void InitializePrefabRange(int startIndex)
        {
            for (int i = startIndex; i < _prefabs.Count; i++)
                ManagedObjects.InitializePrefab(_prefabs[i], i);
        }

        #region Unused.
        public override void AddObject(DualPrefab dualPrefab, bool checkForDuplicates = false)
        {
            if (NetworkManager.StaticCanLog(LoggingType.Error))
                Debug.LogError($"Dual prefabs are not supported with SinglePrefabObjects. Make a DualPrefabObjects asset instead.");
        }

        public override void AddObjects(List<DualPrefab> dualPrefab, bool checkForDuplicates = false)
        {
            if (NetworkManager.StaticCanLog(LoggingType.Error))
                Debug.LogError($"Dual prefabs are not supported with SinglePrefabObjects. Make a DualPrefabObjects asset instead.");
        }

        public override void AddObjects(DualPrefab[] dualPrefab, bool checkForDuplicates = false)
        {
            if (NetworkManager.StaticCanLog(LoggingType.Error))
                Debug.LogError($"Dual prefabs are not supported with SinglePrefabObjects. Make a DualPrefabObjects asset instead.");
        }
        #endregion
    }
}
'''
'''--- Assets/FishNet/Runtime/Managing/Object/SpawnParentType.cs ---
﻿namespace FishNet.Managing.Object
{
    public enum SpawnParentType : byte
    {
        Unset = 0,
        NetworkObject = 1,
        NetworkBehaviour = 2
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/ObserverManager.cs ---
﻿using FishNet.Connection; //remove on 2023/01/01 move to correct folder.
using FishNet.Object;
using FishNet.Observing;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

namespace FishNet.Managing.Observing
{

    /// <summary>
    /// Additional options for managing the observer system.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/ObserverManager")]
    public sealed class ObserverManager : MonoBehaviour
    {
        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to update visibility for clientHost based on if they are an observer or not.")]
        [FormerlySerializedAs("_setHostVisibility")]
        [SerializeField]
        private bool _updateHostVisibility = true;
        /// <summary>
        /// True to update visibility for clientHost based on if they are an observer or not.
        /// </summary>
        public bool UpdateHostVisibility
        {
            get => _updateHostVisibility;
            private set => _updateHostVisibility = value;
        }
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Default observer conditions for networked objects.")]
        [SerializeField]
        private List<ObserverCondition> _defaultConditions = new List<ObserverCondition>();
        /// <summary>
        /// NetworkManager on object.
        /// </summary>
        private NetworkManager _networkManager;
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnceInternal(NetworkManager manager)
        {
            _networkManager = manager;
        }

        /// <summary>
        /// Sets a new value for UpdateHostVisibility.
        /// </summary>
        /// <param name="value">New value.</param>
        /// <param name="updateType">Which objects to update.</param>
        public void SetUpdateHostVisibility(bool value, HostVisibilityUpdateTypes updateType)
        {
            //Unchanged.
            if (value == UpdateHostVisibility)
                return;

            /* Update even if server state is not known.
             * The setting should be updated so when the server
             * does start spawned objects have latest setting. */
            if (HostVisibilityUpdateContains(updateType, HostVisibilityUpdateTypes.Manager))
                UpdateHostVisibility = value;

            /* If to update spawned as well then update all networkobservers
             * with the setting and also update renderers. */
            if (_networkManager.IsServer && HostVisibilityUpdateContains(updateType, HostVisibilityUpdateTypes.Spawned))
            {
                NetworkConnection clientConn = _networkManager.ClientManager.Connection;
                foreach (NetworkObject n in _networkManager.ServerManager.Objects.Spawned.Values)
                {
                    n.NetworkObserver.SetUpdateHostVisibility(value);

                    //Only check to update renderers if clientHost. If not client then clientConn won't be active.
                    if (clientConn.IsActive)
                        n.SetRenderersVisible(n.Observers.Contains(clientConn), true);
                }
            }

            bool HostVisibilityUpdateContains(HostVisibilityUpdateTypes whole, HostVisibilityUpdateTypes part)
            {
                return (whole & part) == part;
            }
        }

        /// <summary>
        /// Adds default observer conditions to nob and returns the NetworkObserver used.
        /// </summary>
        internal NetworkObserver AddDefaultConditions(NetworkObject nob)
        {
            bool isGlobal = (nob.IsGlobal && !nob.IsSceneObject);
            bool obsAdded;

            NetworkObserver result;
            if (!nob.TryGetComponent<NetworkObserver>(out result))
            {
                obsAdded = true;
                result = nob.gameObject.AddComponent<NetworkObserver>();
            }
            else
            {
                obsAdded = false;
            }

            /* NetworkObserver is null and there are no
             * conditions to add. Nothing will change by adding
             * the NetworkObserver component so exit early. */
            if (!obsAdded && _defaultConditions.Count == 0)
                return result;

            //If the NetworkObserver component was just added.
            if (obsAdded)
            {
                /* Global nobs do not need a NetworkObserver.
                 * Ultimately, a global NetworkObject is one without
                 * any conditions. */
                if (isGlobal)
                    return result;
                //If there are no conditions then there's nothing to add.
                if (_defaultConditions.Count == 0)
                    return result;
                /* If here then there not a global networkobject and there are conditions to use.
                 * Since the NetworkObserver is being added fresh, set OverrideType to UseManager
                 * so that the NetworkObserver is populated with the manager conditions. */
                result.OverrideType = NetworkObserver.ConditionOverrideType.UseManager;
            }
            //NetworkObject has a NetworkObserver already on it.
            else
            {
                //If global the NetworkObserver has to be cleared and set to ignore manager.
                if (isGlobal)
                {
                    result.ObserverConditionsInternal.Clear();
                    result.OverrideType = NetworkObserver.ConditionOverrideType.IgnoreManager;
                }
            }

            //If ignoring manager then use whatever is already configured.
            if (result.OverrideType == NetworkObserver.ConditionOverrideType.IgnoreManager)
            {
                //Do nothing.
            }
            //If using manager then replace all with conditions.
            else if (result.OverrideType == NetworkObserver.ConditionOverrideType.UseManager)
            {
                result.ObserverConditionsInternal.Clear();
                AddMissing(result);
            }
            //Adding only new.
            else if (result.OverrideType == NetworkObserver.ConditionOverrideType.AddMissing)
            {
                AddMissing(result);
            }

            void AddMissing(NetworkObserver networkObserver)
            {
                int count = _defaultConditions.Count;
                for (int i = 0; i < count; i++)
                {
                    ObserverCondition oc = _defaultConditions[i];
                    if (!networkObserver.ObserverConditionsInternal.Contains(oc))
                        networkObserver.ObserverConditionsInternal.Add(oc);
                }
            }

            return result;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/Broadcast/SceneBroadcasts.cs ---
﻿using FishNet.Broadcast;
using FishNet.Documenting;

namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Sent when there are starting scenes for the client to load.
    /// </summary>
    public struct EmptyStartScenesBroadcast : IBroadcast { }
    /// <summary>
    /// Sent to clients to load networked scenes.
    /// </summary>
    [APIExclude]
    public struct LoadScenesBroadcast : IBroadcast
    {
        public LoadQueueData QueueData;
    }

    /// <summary>       
    /// Sent to clients to unload networked scenes.
    /// </summary>     
    [APIExclude]
    public struct UnloadScenesBroadcast : IBroadcast
    {
        public UnloadQueueData QueueData;
    }

    /// <summary> 
    /// Sent to server to indicate which scenes a client has loaded.
    /// </summary>
    [APIExclude]
    public struct ClientScenesLoadedBroadcast : IBroadcast
    {
        public SceneLookupData[] SceneLookupDatas;
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/DefaultSceneProcessor.cs ---
﻿using System.Collections.Generic;
using UnityEngine;
using UnitySceneManager = UnityEngine.SceneManagement.SceneManager;
using UnityScene = UnityEngine.SceneManagement.Scene;
using System.Collections;

namespace FishNet.Managing.Scened
{

    public class DefaultSceneProcessor : SceneProcessorBase
    {
        #region Private.
        /// <summary>
        /// Currently active loading AsyncOperations.
        /// </summary>
        private List<AsyncOperation> _loadingAsyncOperations = new List<AsyncOperation>();
        /// <summary>
        /// A collection of scenes used both for loading and unloading.
        /// </summary>
        private List<UnityScene> _scenes = new List<UnityScene>();
        /// <summary>
        /// Current AsyncOperation being processed.
        /// </summary>
        private AsyncOperation _currentAsyncOperation;
        #endregion

        /// <summary>
        /// Called when scene loading has begun.
        /// </summary>
        public override void LoadStart(LoadQueueData queueData)
        {
            base.LoadStart(queueData);
            ResetValues();
        }

        public override void LoadEnd(LoadQueueData queueData)
        {
            base.LoadEnd(queueData);
            ResetValues();
        }

        /// <summary>
        /// Resets values for a fresh load or unload.
        /// </summary>
        private void ResetValues()
        {
            _currentAsyncOperation = null;
            _loadingAsyncOperations.Clear();
        }

        /// <summary>
        /// Called when scene unloading has begun within an unload operation.
        /// </summary>
        /// <param name="queueData"></param>
        public override void UnloadStart(UnloadQueueData queueData)
        {
            base.UnloadStart(queueData);
            _scenes.Clear();
        }

        /// <summary>
        /// Begin loading a scene using an async method.
        /// </summary>
        /// <param name="sceneName">Scene name to load.</param>
        public override void BeginLoadAsync(string sceneName, UnityEngine.SceneManagement.LoadSceneParameters parameters)
        {
            AsyncOperation ao = UnitySceneManager.LoadSceneAsync(sceneName, parameters);
            _loadingAsyncOperations.Add(ao);
            
            _currentAsyncOperation = ao;
            _currentAsyncOperation.allowSceneActivation = false;
        }

        /// <summary>
        /// Begin unloading a scene using an async method.
        /// </summary>
        /// <param name="sceneName">Scene name to unload.</param>
        public override void BeginUnloadAsync(UnityScene scene)
        {
            _currentAsyncOperation = UnitySceneManager.UnloadSceneAsync(scene);
        }

        /// <summary>
        /// Returns if a scene load or unload percent is done.
        /// </summary>
        /// <returns></returns>
        public override bool IsPercentComplete()
        {
            return (GetPercentComplete() >= 0.9f);
        }

        /// <summary>
        /// Returns the progress on the current scene load or unload.
        /// </summary>
        /// <returns></returns>
        public override float GetPercentComplete()
        {
            return (_currentAsyncOperation == null) ? 1f : _currentAsyncOperation.progress;
        }

        /// <summary>
        /// Adds a loaded scene.
        /// </summary>
        /// <param name="scene">Scene loaded.</param>
        public override void AddLoadedScene(UnityScene scene)
        {
            base.AddLoadedScene(scene);
            _scenes.Add(scene);
        }

        /// <summary>
        /// Returns scenes which were loaded during a load operation.
        /// </summary>
        public override List<UnityScene> GetLoadedScenes()
        {
            return _scenes;
        }

        /// <summary>
        /// Activates scenes which were loaded.
        /// </summary>
        public override void ActivateLoadedScenes()
        {
            foreach (AsyncOperation ao in _loadingAsyncOperations)
                ao.allowSceneActivation = true;
        }

        /// <summary>
        /// Returns if all asynchronized tasks are considered IsDone.
        /// </summary>
        /// <returns></returns>
        public override IEnumerator AsyncsIsDone()
        {
            bool notDone;
            do
            {
                notDone = false;
                foreach (AsyncOperation ao in _loadingAsyncOperations)
                {

                    if (!ao.isDone)
                    {
                        notDone = true;
                        break;
                    }
                }
                yield return null;
            } while (notDone);

            yield break;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/Events/ClientPresenceChangeEventArgs.cs ---
﻿using FishNet.Connection;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Data container about a scene presence change for a client.
    /// </summary>
    public struct ClientPresenceChangeEventArgs
    {

        /// <summary>
        /// Scene on the server which the client's presence has changed.
        /// </summary>
        public Scene Scene;
        /// <summary>
        /// Connection to client.
        /// </summary>
        public NetworkConnection Connection;
        /// <summary>
        /// True if the client was added to the scene, false is removed.
        /// </summary>
        public bool Added;

        internal ClientPresenceChangeEventArgs(Scene scene, NetworkConnection conn, bool added)
        {
            Scene = scene;
            Connection = conn;
            Added = added;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/Events/LoadSceneEventArgs.cs ---
﻿using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Data container about a scene load start.
    /// </summary>
    public struct SceneLoadStartEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly LoadQueueData QueueData;

        internal SceneLoadStartEventArgs(LoadQueueData lqd)
        {
            QueueData = lqd;
        }
    }

    /// <summary>
    /// Data container about a scene load percent change.
    /// </summary>
    public struct SceneLoadPercentEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly LoadQueueData QueueData;
        /// <summary>
        /// Percentage of change completion. 1f is equal to 100% complete.
        /// </summary>
        public readonly float Percent;

        internal SceneLoadPercentEventArgs(LoadQueueData lqd, float percent)
        {
            QueueData = lqd;
            Percent = percent;
        }
    }

    /// <summary>
    /// Data container about a scene load end.
    /// </summary>
    public struct SceneLoadEndEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly LoadQueueData QueueData;
        /// <summary>
        /// Scenes which were loaded.
        /// </summary>
        public readonly Scene[] LoadedScenes;
        /// <summary>
        /// Scenes which were skipped because they were already loaded.
        /// </summary>
        public readonly string[] SkippedSceneNames;
        /// <summary>
        /// Scenes which were unloaded.
        /// </summary>
        public readonly string[] UnloadedSceneNames;

        internal SceneLoadEndEventArgs(LoadQueueData lqd, string[] skipped, Scene[] loaded, string[] unloadedSceneNames)
        {
            QueueData = lqd;
            SkippedSceneNames = skipped;
            LoadedScenes = loaded;
            UnloadedSceneNames = unloadedSceneNames;
        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Managing/Scened/Events/UnloadSceneEventArgs.cs ---
﻿using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Data container about a scene unload start.
    /// </summary>
    public struct SceneUnloadStartEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly UnloadQueueData QueueData;

        internal SceneUnloadStartEventArgs(UnloadQueueData sqd)
        {
            QueueData = sqd;
        }
    }

    /// <summary>
    /// Data container about a scene unload end.
    /// </summary>
    public struct SceneUnloadEndEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly UnloadQueueData QueueData;
        /// <summary>
        /// Handles of scenes which were successfully unloaded.
        /// This collection may be populated with empty scenes depending on engine version.
        /// </summary>
        public int[] UnloadedSceneHandles
        {
            get
            {
                if (_unloadedSceneHandlesCache == null)
                {
                    _unloadedSceneHandlesCache = new int[UnloadedScenes.Count];
                    for (int i = 0; i < _unloadedSceneHandlesCache.Length; i++)
                        _unloadedSceneHandlesCache[i] = UnloadedScenes[i].handle;
                }

                return _unloadedSceneHandlesCache;
            }
        }
        /// <summary>
        /// Scenes which were successfully unloaded.
        /// This collection may be populated with empty scenes depending on engine version.
        /// </summary>
        public List<Scene> UnloadedScenes;
        /// <summary>
        /// Cache result of UnloadedSceneHandles.
        /// </summary>
        private int[] _unloadedSceneHandlesCache;

        internal SceneUnloadEndEventArgs(UnloadQueueData sqd, List<Scene> unloadedScenes)
        {
            QueueData = sqd;
            UnloadedScenes = unloadedScenes;
            _unloadedSceneHandlesCache = null;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/LoadOptions.cs ---
﻿using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Settings to apply when loading a scene.
    /// </summary>
    public class LoadOptions
    {
        /// <summary>
        /// True if to automatically unload the loaded scenes when they are no longer being used by clients. This field only applies to scenes loaded for connections, not globally loaded scenes.
        /// </summary>
        [System.NonSerialized]
        public bool AutomaticallyUnload = true;
        /// <summary>
        /// False if to only load scenes which are not yet loaded. When true a scene may load multiple times; this is known as scene stacking. Only the server is able to stack scenes; clients will load a single instance. Global scenes cannot be stacked.
        /// </summary>
        [System.NonSerialized]
        public bool AllowStacking;
        /// <summary>
        /// LocalPhysics mode to use when loading this scene. Generally this will only be used when applying scene stacking. Only used by the server.
        /// https://docs.unity3d.com/ScriptReference/SceneManagement.LocalPhysicsMode.html
        /// </summary>
        [System.NonSerialized]
        public LocalPhysicsMode LocalPhysics = LocalPhysicsMode.None;
        /// <summary>
        /// True if scenes should be loaded using addressables. This field only exists for optional use so the user may know if their queue data is using addressables.
        /// </summary>
        public bool Addressables;
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/LoadParams.cs ---
﻿namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Additional user-crafted data which can be included in scene load callbacks.
    /// </summary>
    public class LoadParams
    {
        /// <summary>
        /// Objects which are included in callbacks on the server when loading a scene. Can be useful for including unique information about the scene, such as match id. These are not sent to clients; use ClientParams for this.
        /// </summary>
        [System.NonSerialized]
        public object[] ServerParams = new object[0];
        /// <summary>
        /// Bytes which are sent to clients during scene loads. Can contain any information.
        /// </summary>
        public byte[] ClientParams = new byte[0];
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/LoadQueueData.cs ---
﻿using FishNet.Connection;
using FishNet.Utility.Constant;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Data generated when loading a scene.
    /// </summary>
    public class LoadQueueData
    {
        /// <summary>
        /// Clients which receive this SceneQueueData. If Networked, all clients do. If Connections, only the specified Connections do.
        /// </summary>
        [System.NonSerialized]
        public SceneScopeType ScopeType;
        /// <summary>
        /// Connections to load scenes for. Only valid on the server and when ScopeType is Connections.
        /// </summary>
        [System.NonSerialized]
        public NetworkConnection[] Connections = new NetworkConnection[0];
        /// <summary>
        /// SceneLoadData to use.
        /// </summary>
        public SceneLoadData SceneLoadData = null;
        /// <summary>
        /// Current global scenes.
        /// </summary>
        public string[] GlobalScenes = new string[0];
        /// <summary>
        /// True if to iterate this queue data as server.
        /// </summary>
        [System.NonSerialized]
        public readonly bool AsServer;

        internal LoadQueueData() { }
        internal LoadQueueData(SceneScopeType scopeType, NetworkConnection[] conns, SceneLoadData sceneLoadData, string[] globalScenes, bool asServer)
        {
            ScopeType = scopeType;
            Connections = conns;
            SceneLoadData = sceneLoadData;
            GlobalScenes = globalScenes;
            AsServer = asServer;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/ReplaceOption.cs ---
﻿
namespace FishNet.Managing.Scened
{
    /// <summary>
    /// How to replace scenes when loading.
    /// </summary>
    public enum ReplaceOption : byte
    { 
        /// <summary>
        /// Replace all scenes, online and offline.
        /// </summary>
        All,
        /// <summary>
        /// Only replace scenes loaded using the SceneManager.
        /// </summary>
        OnlineOnly,
        /// <summary>
        /// Do not replace any scenes, additional scenes will be loaded as additive.
        /// </summary>
        None
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/SceneLoadData.cs ---
﻿using FishNet.Object;
using FishNet.Serializing.Helping;
using System.Collections.Generic;
using System.IO;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Data about which scenes to load.
    /// </summary>
    public class SceneLoadData
    {
        /// <summary>
        /// SceneLookupData for each scene to load.
        /// </summary>
        public SceneLookupData[] SceneLookupDatas = new SceneLookupData[0];
        /// <summary>
        /// NetworkObjects to move to the new scenes. Objects will be moved to the first scene.
        /// </summary>
        public NetworkObject[] MovedNetworkObjects = new NetworkObject[0];
        /// <summary>
        /// How to replace current scenes with new ones. When replacing scenes the first scene loaded will be set as the active scene, and the rest additive.
        /// </summary>
        public ReplaceOption ReplaceScenes = ReplaceOption.None;
        /// <summary>
        /// Parameters which may be set and will be included in load callbacks.
        /// </summary>
        public LoadParams Params = new LoadParams();
        /// <summary>
        /// Additional options to use for loaded scenes.
        /// </summary>
        public LoadOptions Options = new LoadOptions();

        public SceneLoadData() { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scene">Scene to load.</param>
        public SceneLoadData(Scene scene) : this(new Scene[] { scene }, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneName">Scene to load by name.</param>
        public SceneLoadData(string sceneName) : this(new string[] { sceneName }, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandle">Scene to load by handle.</param>
        public SceneLoadData(int sceneHandle) : this(new int[] { sceneHandle }, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandle">Scene to load by handle.</param>
        /// <param name="sceneName">Scene to load by name.</param>
        public SceneLoadData(int sceneHandle, string sceneName) : this(new SceneLookupData(sceneHandle, sceneName)) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupData">Scene to load by SceneLookupData.</param>
        public SceneLoadData(SceneLookupData sceneLookupData) : this(new SceneLookupData[] { sceneLookupData }) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to load.</param>
        public SceneLoadData(List<Scene> scenes) : this(scenes.ToArray(), null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to load by name.</param>
        public SceneLoadData(List<string> sceneNames) : this(sceneNames.ToArray(), null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to load by handle.</param>
        public SceneLoadData(List<int> sceneHandles) : this(sceneHandles.ToArray(), null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to load.</param>
        public SceneLoadData(Scene[] scenes) : this(scenes, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to load by name.</param>
        public SceneLoadData(string[] sceneNames) : this(sceneNames, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to load by handle.</param>
        public SceneLoadData(int[] sceneHandles) : this(sceneHandles, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupDatas">Scenes to load by SceneLookupDatas.</param>
        public SceneLoadData(SceneLookupData[] sceneLookupDatas) : this(sceneLookupDatas, null) { }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="scene">Scene to load.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(Scene scene, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupData data = SceneLookupData.CreateData(scene);
            Construct(new SceneLookupData[] { data }, movedNetworkObjects);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to load.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(Scene[] scenes, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupData[] datas = SceneLookupData.CreateData(scenes);
            Construct(datas, movedNetworkObjects);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to load by Name.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(string[] sceneNames, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupData[] datas = SceneLookupData.CreateData(sceneNames);
            Construct(datas, movedNetworkObjects);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to load by handle.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(int[] sceneHandles, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupData[] datas = SceneLookupData.CreateData(sceneHandles);
            Construct(datas, movedNetworkObjects);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupDatas">Scenes to load by SceneLookupDatas.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(SceneLookupData[] sceneLookupDatas, NetworkObject[] movedNetworkObjects)
        {
            Construct(sceneLookupDatas, movedNetworkObjects);
        }

        /// <summary>
        /// Called at the end of every constructor.
        /// </summary>
        private void Construct(SceneLookupData[] datas, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupDatas = datas;
            if (movedNetworkObjects == null)
                movedNetworkObjects = new NetworkObject[0];
            MovedNetworkObjects = movedNetworkObjects;
        }

        /// <summary>
        /// Returns if any data is invalid, such as null entries.
        /// </summary>
        /// <returns></returns>
        internal bool DataInvalid()
        {
            //Null values.
            if (Params == null || MovedNetworkObjects == null || SceneLookupDatas == null ||
                Options == null)
                return true;
            //No lookups.
            if (SceneLookupDatas.Length == 0)
                return true;

            return false;
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/SceneScopeTypes.cs ---
﻿namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Type of scopes for a scene load or unload.
    /// </summary> 
    public enum SceneScopeType : byte
    {
        /// <summary>
        /// Scene action occured for all clients.
        /// </summary>
        Global = 0,
        /// <summary>
        /// Scene action occurred for specified clients.
        /// </summary>
        Connections = 1
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/SceneUnloadData.cs ---
﻿using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Data about which scenes to unload.
    /// </summary>    
    public class SceneUnloadData
    {
        /// <summary>
        /// SceneLookupData for each scene to load.
        /// </summary>
        public SceneLookupData[] SceneLookupDatas = new SceneLookupData[0];
        /// <summary>
        /// Parameters which may be set and will be included in load callbacks.
        /// </summary>
        public UnloadParams Params = new UnloadParams();
        /// <summary>
        /// Additional options to use for loaded scenes.
        /// </summary>
        public UnloadOptions Options = new UnloadOptions();

        /// <summary>
        /// 
        /// </summary>
        public SceneUnloadData() { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scene">Scene to unload.</param>
        public SceneUnloadData(Scene scene) : this(new Scene[] { scene }) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneName">Scene to unload by name.</param>
        public SceneUnloadData(string sceneName) : this(new string[] { sceneName }) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandle">Scene to unload by handle.</param>
        public SceneUnloadData(int sceneHandle) : this(new int[] { sceneHandle }) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to unload.</param>
        public SceneUnloadData(List<Scene> scenes) : this(scenes.ToArray()) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to unload by names.</param>
        public SceneUnloadData(List<string> sceneNames) : this(sceneNames.ToArray()) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to unload by handles.</param>
        public SceneUnloadData(List<int> sceneHandles) : this(sceneHandles.ToArray()) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to unload.</param>
        public SceneUnloadData(Scene[] scenes)
        {
            SceneLookupDatas = SceneLookupData.CreateData(scenes);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to unload by names.</param>
        public SceneUnloadData(string[] sceneNames)
        {
            SceneLookupDatas = SceneLookupData.CreateData(sceneNames);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to unload by handles.</param>
        public SceneUnloadData(int[] sceneHandles)
        {
            SceneLookupDatas = SceneLookupData.CreateData(sceneHandles);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupDatas">Scenes to unload by SceneLookupDatas.</param>
        public SceneUnloadData(SceneLookupData[] sceneLookupDatas)
        {
            SceneLookupDatas = sceneLookupDatas;
        }

        /// <summary>
        /// Returns if any data is invalid, such as null entries.
        /// </summary>
        /// <returns></returns>
        internal bool DataInvalid()
        {
            //Null values.
            if (Params == null || SceneLookupDatas == null ||
                Options == null)
                return true;
            //No lookups.
            if (SceneLookupDatas.Length == 0)
                return true;

            return false;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/UnloadOptions.cs ---
﻿
namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Settings to apply when loading a scene.
    /// </summary>
    public class UnloadOptions
    {
        /// <summary>
        /// Conditions to unloading a scene on the server.
        /// </summary>
        public enum ServerUnloadMode
        {
            /// <summary>
            /// Unloads the scene if no more connections are within it.
            /// </summary>
            UnloadUnused = 0,
            /// <summary>
            /// Unloads scenes for connections but keeps scene loaded on server even if no connections are within it.
            /// </summary>
            KeepUnused = 1,
        }

        /// <summary>
        /// How to unload scenes on the server. UnloadUnused will unload scenes which have no more clients in them. KeepUnused will not unload a scene even when empty. ForceUnload will unload a scene regardless of if clients are still connected to it.
        /// </summary>
        [System.NonSerialized]
        public ServerUnloadMode Mode = ServerUnloadMode.UnloadUnused;
        /// <summary>
        /// True if scenes should be loaded using addressables. This field only exists for optional use so the user may know if their queue data is using addressables.
        /// </summary>
        public bool Addressables;
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/UnloadParams.cs ---
﻿namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Additional user-crafted data which can be included in scene unload callbacks.
    /// </summary>
    public class UnloadParams
    {
        /// <summary>
        /// Objects which are included in callbacks on the server when unloading a scene. Can be useful for including unique information about the scene, such as match id. These are not sent to clients; use ClientParams for this.
        /// </summary>
        [System.NonSerialized]
        public object[] ServerParams = new object[0];
        /// <summary>
        /// Bytes which are sent to clients during scene unloads. Can contain any information.
        /// </summary>
        public byte[] ClientParams = new byte[0];
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/LoadUnloadDatas/UnloadQueueData.cs ---
﻿using FishNet.Connection;
using FishNet.Utility.Constant;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Data generated when unloading a scene.
    /// </summary>
    public class UnloadQueueData
    {
        /// <summary>
        /// Clients which receive this SceneQueueData. If Networked, all clients do. If Connections, only the specified Connections do.
        /// </summary>
        [System.NonSerialized]
        public readonly SceneScopeType ScopeType;
        /// <summary>
        /// Connections to unload scenes for. Only valid on the server and when ScopeType is Connections.
        /// </summary>
        [System.NonSerialized]
        public NetworkConnection[] Connections;
        /// <summary>
        /// SceneUnloadData to use.
        /// </summary>
        public SceneUnloadData SceneUnloadData = null;
        /// <summary>
        /// Current global scenes.
        /// </summary>
        public string[] GlobalScenes = new string[0];
        /// <summary>
        /// True if to iterate this queue data as server.
        /// </summary>
        [System.NonSerialized]
        public readonly bool AsServer;

        internal UnloadQueueData() { }
        internal UnloadQueueData(SceneScopeType scopeType, NetworkConnection[] conns, SceneUnloadData sceneUnloadData, string[] globalScenes, bool asServer)
        {
            ScopeType = scopeType;
            Connections = conns;
            SceneUnloadData = sceneUnloadData;
            GlobalScenes = globalScenes;
            AsServer = asServer;
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/SceneLookupData.cs ---
﻿using FishNet.Managing.Logging;
using FishNet.Serializing.Helping;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Extensions for SceneLookupData.
    /// </summary>
    internal static class SceneLookupDataExtensions
    {
        /// <summary>
        /// Returns Names from SceneLookupData.
        /// </summary>
        /// <param name="datas"></param>
        /// <returns></returns>
        public static string[] GetNames(this SceneLookupData[] datas)
        {
            string[] names = new string[datas.Length];
            for (int i = 0; i < datas.Length; i++)
                names[i] = datas[i].Name;

            return names;
        }
    }

    /// <summary>
    /// Data container for looking up, loading, or unloading a scene.
    /// </summary>
    public class SceneLookupData
    {
        /// <summary>
        /// Handle of the scene. If value is 0, then handle is not used.
        /// </summary>
        public int Handle;
        /// <summary>
        /// Name of the scene.
        /// </summary>
        public string Name = string.Empty;
        /// <summary>
        /// Returns the scene name without a directory path should one exist.
        /// </summary>
        public string NameOnly => System.IO.Path.GetFileNameWithoutExtension(Name);

        #region Const
        /// <summary>
        /// String to display when scene data is invalid.
        /// </summary>
        private const string INVALID_SCENE = "One or more scene information entries contain invalid data and have been skipped.";
        #endregion

        /// <summary>
        /// 
        /// </summary>
        public SceneLookupData() { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scene">Scene to generate from.</param>
        public SceneLookupData(Scene scene)
        {
            Handle = scene.handle;
            Name = scene.name;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="name">Scene name to generate from.</param>
        public SceneLookupData(string name)
        {
            Name = name;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="handle">Scene handle to generate from.</param>
        public SceneLookupData(int handle)
        {
            Handle = handle;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="handle">Scene handle to generate from.</param>
        /// <param name="name">Name to generate from if handle is 0.</param>
        public SceneLookupData(int handle, string name)
        {
            Handle = handle;
            Name = name;
        }

        #region Comparers.
        public static bool operator ==(SceneLookupData sldA, SceneLookupData sldB)
        {
            //One is null while the other is not.
            if ((sldA is null) != (sldB is null))
                return false;

            /*If here both are either null or have value. */
            if (!(sldA is null))
                return sldA.Equals(sldB);
            else if (!(sldB is null))
                return sldB.Equals(sldA);

            //Fall through indicates both are null.
            return true;
        }

        public static bool operator !=(SceneLookupData sldA, SceneLookupData sldB)
        {
            //One is null while the other is not.
            if ((sldA is null) != (sldB is null))
                return true;

            /*If here both are either null or have value. */
            if (!(sldA is null))
                return !sldA.Equals(sldB);
            else if (!(sldB is null))
                return !sldB.Equals(sldA);

            //Fall through indicates both are null.
            return true;
        }

        public bool Equals(SceneLookupData sld)
        {
            //Comparing instanced against null.
            if (sld is null)
                return false;

            //True if both handles are empty.
            bool bothHandlesEmpty = (
                (this.Handle == 0) &&
                (sld.Handle == 0)
                );

            //If both have handles and they match.
            if (!bothHandlesEmpty && sld.Handle == this.Handle)
                return true;
            //If neither have handles and name matches.
            else if (bothHandlesEmpty && sld.Name == this.Name)
                return true;

            //Fall through.
            return false;
        }

        public override int GetHashCode()
        {
            int hashCode = 2053068273;
            hashCode = hashCode * -1521134295 + Handle.GetHashCode();
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Name);
            return hashCode;
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override string ToString()
        {
            return base.ToString();
        }
        #endregion

        #region CreateData.
        /// <summary>
        /// Returns a new SceneLookupData.
        /// </summary>
        /// <param name="scene">Scene to create from.</param>
        /// <returns></returns>
        public static SceneLookupData CreateData(Scene scene) => new SceneLookupData(scene);
        /// <summary>
        /// Returns a new SceneLookupData.
        /// </summary>
        /// <param name="scene">Scene name to create from.</param>
        /// <returns></returns>
        public static SceneLookupData CreateData(string name) => new SceneLookupData(name);
        /// <summary>
        /// Returns a new SceneLookupData.
        /// </summary>
        /// <param name="scene">Scene handle to create from.</param>
        /// <returns></returns>
        public static SceneLookupData CreateData(int handle) => new SceneLookupData(handle);
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="scenes">Scenes to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(List<Scene> scenes) => CreateData(scenes.ToArray());
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="names">Scene names to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(List<string> names) => CreateData(names.ToArray());
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="handles">Scene handles to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(List<int> handles) => CreateData(handles.ToArray());
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="scenes">Scenes to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(Scene[] scenes)
        {
            bool invalidFound = false;
            List<SceneLookupData> result = new List<SceneLookupData>();
            foreach (Scene item in scenes)
            {
                if (!item.IsValid())
                {
                    invalidFound = true;
                    continue;
                }

                result.Add(CreateData(item));
            }

            if (invalidFound)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Warning))
                    Debug.LogWarning(INVALID_SCENE);
            }
            return result.ToArray();
        }
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="names">Scene names to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(string[] names)
        {
            bool invalidFound = false;
            List<SceneLookupData> result = new List<SceneLookupData>();
            foreach (string item in names)
            {
                if (string.IsNullOrEmpty(item))
                {
                    invalidFound = true;
                    continue;
                }

                string nameOnly = System.IO.Path.GetFileNameWithoutExtension(item);
                result.Add(CreateData(nameOnly));
            }

            if (invalidFound)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Warning))
                    Debug.LogWarning(INVALID_SCENE);
            }
            return result.ToArray();
        }
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="handles">Scene handles to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(int[] handles)
        {
            bool invalidFound = false;
            List<SceneLookupData> result = new List<SceneLookupData>();
            foreach (int item in handles)
            {
                if (item == 0)
                {
                    invalidFound = true;
                    continue;
                }

                result.Add(CreateData(item));
            }

            if (invalidFound)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Warning))
                    Debug.LogWarning(INVALID_SCENE);
            }
            return result.ToArray();
        }
        #endregion

        /// <summary>
        /// Returns the first scene found using Handle or Name, preferring Handle.
        /// </summary>
        /// <returns></returns>
        /// <param name="foundByHandle">True if scene was found by handle. Handle is always checked first.</param>
        public Scene GetScene(out bool foundByHandle)
        {
            foundByHandle = false;

            if (Handle == 0 && string.IsNullOrEmpty(Name))
            {
                if (NetworkManager.StaticCanLog(LoggingType.Warning))
                    Debug.LogWarning("Scene handle and name is unset; scene cannot be returned.");
                return default;
            }

            Scene result = default;

            //Lookup my handle.
            if (Handle != 0)
            {
                result = SceneManager.GetScene(Handle);
                if (result.handle != 0)
                    foundByHandle = true;
            }

            //If couldnt find handle try by string.
            if (!foundByHandle)
                result = SceneManager.GetScene(NameOnly);

            return result;
        }

    }
}

'''
'''--- Assets/FishNet/Runtime/Managing/Scened/SceneManager.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Client;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnitySceneManager = UnityEngine.SceneManagement.SceneManager;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Handles loading, unloading, and scene visibility for clients.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/SceneManager")]
    public sealed class SceneManager : MonoBehaviour
    {
        #region Types.
        internal enum LightProbeUpdateType
        {
            Asynchronous = 0,
            BlockThread = 1,
            Off = 2,
        }
        #endregion

        #region Public.
        /// <summary>
        /// Called after the active scene has been set, immediately after scene loads. This will occur before NetworkBehaviour callbacks run for the scene's objects.
        /// </summary>
        public event Action OnActiveSceneSet;
        /// <summary>
        /// Called when a client loads initial scenes after connecting. Boolean will be true if asServer.
        /// </summary>
        public event Action<NetworkConnection, bool> OnClientLoadedStartScenes;
        /// <summary>
        /// Called when a scene change queue has begun. This will only call if a scene has succesfully begun to load or unload. The queue may process any number of scene events. For example: if a scene is told to unload while a load is still in progress, then the unload will be placed in the queue.
        /// </summary>
        public event Action OnQueueStart;
        /// <summary>
        /// Called when the scene queue is emptied.
        /// </summary>
        public event Action OnQueueEnd;
        /// <summary>
        /// Called when a scene load starts.
        /// </summary>
        public event Action<SceneLoadStartEventArgs> OnLoadStart;
        /// <summary>
        /// Called when completion percentage changes while loading a scene. Value is between 0f and 1f, while 1f is 100% done. Can be used for custom progress bars when loading scenes.
        /// </summary>
        public event Action<SceneLoadPercentEventArgs> OnLoadPercentChange;
        /// <summary>
        /// Called when a scene load ends.
        /// </summary>
        public event Action<SceneLoadEndEventArgs> OnLoadEnd;
        /// <summary>
        /// Called when a scene unload starts.
        /// </summary>
        public event Action<SceneUnloadStartEventArgs> OnUnloadStart;
        /// <summary>
        /// Called when a scene unload ends.
        /// </summary>
        public event Action<SceneUnloadEndEventArgs> OnUnloadEnd;
        /// <summary>
        /// Called when a client presence changes within a scene, before the server rebuilds observers.
        /// </summary>
        public event Action<ClientPresenceChangeEventArgs> OnClientPresenceChangeStart;
        /// <summary>
        /// Called when a client presence changes within a scene, after the server rebuilds observers.
        /// </summary>
        public event Action<ClientPresenceChangeEventArgs> OnClientPresenceChangeEnd;
        /// <summary>
        /// Connections within each scene.
        /// </summary>
        public Dictionary<Scene, HashSet<NetworkConnection>> SceneConnections { get; private set; } = new Dictionary<Scene, HashSet<NetworkConnection>>();
        #endregion

        #region Internal.
        /// <summary>
        /// Called after the active scene has been set, immediately after scene loads.
        /// </summary>
        internal event Action OnActiveSceneSetInternal;
        #endregion

        #region Serialized.
        /// <summary>
        /// Script to handle addressables loading and unloading. This field may be blank if addressables are not being used.
        /// </summary>
        [Tooltip("Script to handle addressables loading and unloading. This field may be blank if addressables are not being used.")]
        [SerializeField]
        private SceneProcessorBase _sceneProcessor;
        /// <summary>
        /// How to update light probes after loading or unloading scenes.
        /// </summary>
        [Tooltip("How to update light probes after loading or unloading scenes.")]
        [SerializeField]
        private LightProbeUpdateType _lightProbeUpdating = LightProbeUpdateType.Asynchronous;
        /// <summary>
        /// True to move objects visible to clientHost that are within an unloading scene. This ensures the objects are despawned on the client side rather than when the scene is destroyed.
        /// </summary>
        [Tooltip("True to move objects visible to clientHost that are within an unloading scene. This ensures the objects are despawned on the client side rather than when the scene is destroyed.")]
        [SerializeField]
        private bool _moveClientHostObjects = true;
        /// <summary>
        /// True to automatically set active scenes when loading and unloading scenes.
        /// </summary>
        [Tooltip("True to automatically set active scenes when loading and unloading scenes.")]
        [SerializeField]
        private bool _setActiveScene = true;
        #endregion

        #region Private.
        /// <summary>
        /// NetworkManager for this script.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// ServerManager for this script.
        /// </summary>
        private ServerManager _serverManager => _networkManager.ServerManager;
        /// <summary>
        /// ClientManager for this script.
        /// </summary>
        private ClientManager _clientManager => _networkManager.ClientManager;
        /// <summary>
        /// Scenes which are currently loaded as networked scenes. All players should have networked scenes loaded.
        /// </summary>
        private string[] _globalScenes = new string[0];
        /// <summary>
        /// Lastest SceneLoadData for a global load.
        /// </summary>
        private SceneLoadData _globalSceneLoadData = new SceneLoadData();
        /// <summary>
        /// Scenes to load or unload, in order.
        /// </summary>
        private List<object> _queuedOperations = new List<object>();
        /// <summary>
        /// Scenes which must be manually unloaded, even when emptied.
        /// </summary>
        private HashSet<Scene> _manualUnloadScenes = new HashSet<Scene>();
        /// <summary>
        /// Scene containing moved objects when changing single scene. On client this will contain all objects moved until the server destroys them.
        /// The network only sends spawn messages once per-client, per server side scene load. If a scene load is performed only for specific connections
        /// then the server is not resetting their single scene, but rather the single scene for those connections only. Because of this, any objects
        /// which are to be moved will not receive a second respawn message, as they are never destroyed on server, only on client.
        /// While on server only this scene contains objects being moved temporarily, before being moved to the new scene.
        /// </summary>
        private Scene _movedObjectsScene;
        /// <summary>
        /// Scene containing objects awaiting to be destroyed by the client-host.
        /// This is required when unloading scenes where the client-host has visibility.
        /// Otherwise the objects would become destroyed when the scene unloads on the server
        /// which would cause missing networkobjects on clients when receiving despawn messages.
        /// </summary>
        private Scene _delayedDestroyScene;
        /// <summary>
        /// A scene to be set as the active scene where there are no global scenes.
        /// This is used to prevent connection scenes and MovedObjectsScene from becoming the active scene.
        /// </summary>
        private Scene _fallbackActiveScene;
        /// <summary>
        /// Becomes true when when a scene first successfully begins to load or unload. Value is reset to false when the scene queue is emptied.
        /// </summary>
        private bool _sceneQueueStartInvoked;
        /// <summary>
        /// Objects being moved from MovedObjects scene to another. 
        /// </summary>
        private List<GameObject> _movingObjects = new List<GameObject>();
        /// <summary>
        /// How many scene load confirmations the server is expecting from a client.
        /// Unloads do not need to be checked because server does not require confirmation for those.
        /// This is used to prevent attacks.
        /// </summary>
        private Dictionary<NetworkConnection, int> _pendingClientSceneChanges = new Dictionary<NetworkConnection, int>();
        #endregion

        #region Consts.
        /// <summary>
        /// String to use when scene data used to load is invalid.
        /// </summary>
        private const string INVALID_SCENELOADDATA = "One or more datas in SceneLoadData are invalid.This generally occurs when calling this method without specifying any scenes or when data fields are null.";
        /// <summary>
        /// String to use when scene data used to unload is invalid.
        /// </summary>
        private const string INVALID_SCENEUNLOADDATA = "One or more datas in SceneLoadData are invalid.This generally occurs when calling this method without specifying any scenes or when data fields are null.";
        #endregion

        #region Unity callbacks and initialization.
        private void Awake()
        {
            UnitySceneManager.sceneUnloaded += SceneManager_SceneUnloaded;
            if (_sceneProcessor == null)
                _sceneProcessor = gameObject.AddComponent<DefaultSceneProcessor>();
            _sceneProcessor.Initialize(this);
        }

        private void Start()
        {
            //No need to unregister since managers are on the same object.
            _networkManager.ServerManager.OnRemoteConnectionState += ServerManager_OnRemoteConnectionState;
            _networkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
            _clientManager.RegisterBroadcast<LoadScenesBroadcast>(OnLoadScenes);
            _clientManager.RegisterBroadcast<UnloadScenesBroadcast>(OnUnloadScenes);
            _serverManager.RegisterBroadcast<ClientScenesLoadedBroadcast>(OnClientLoadedScenes);

            _clientManager.RegisterBroadcast<EmptyStartScenesBroadcast>(OnClientEmptyStartScenes);
            _serverManager.RegisterBroadcast<EmptyStartScenesBroadcast>(OnServerEmptyStartScenes);
        }

        private void OnDestroy()
        {
            UnitySceneManager.sceneUnloaded -= SceneManager_SceneUnloaded;
        }

        /// <summary>
        /// Called when the server connection state changes.
        /// </summary>
        private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
        {
            //If no servers are started.
            if (!_networkManager.ServerManager.AnyServerStarted())
                ResetValues();

        }
        /// <summary>
        /// Resets as if first use.
        /// </summary>
        private void ResetValues()
        {
            SceneConnections.Clear();
            _globalScenes = new string[0];
            _globalSceneLoadData = new SceneLoadData();
            _queuedOperations.Clear();
            _manualUnloadScenes.Clear();
            _sceneQueueStartInvoked = false;
            _movingObjects.Clear();
        }

        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        private void ServerManager_OnRemoteConnectionState(NetworkConnection arg1, RemoteConnectionStateArgs arg2)
        {
            if (arg2.ConnectionState == RemoteConnectionState.Stopped)
                ClientDisconnected(arg1);
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnceInternal(NetworkManager manager)
        {
            _networkManager = manager;
        }

        /// <summary>
        /// Received when a scene is unloaded.
        /// </summary>
        /// <param name="arg0"></param>
        private void SceneManager_SceneUnloaded(Scene scene)
        {
            if (!_networkManager.IsServer)
                return;

            /* Remove any unloaded scenes from local variables. This shouldn't
             * be needed if the user properly utilizes this scene manager,
             * but just incase, we don't want a memory leak. */
            SceneConnections.Remove(scene);
            _manualUnloadScenes.Remove(scene);
            RemoveFromGlobalScenes(scene);
        }
        #endregion

        #region Initial synchronizing.
        /// <summary>
        /// Invokes OnClientLoadedStartScenes if connection just loaded start scenes.
        /// </summary>
        /// <param name="connection"></param>
        private void TryInvokeLoadedStartScenes(NetworkConnection connection, bool asServer)
        {
            if (connection.SetLoadedStartScenes(asServer))
                OnClientLoadedStartScenes?.Invoke(connection, asServer);
        }

        /// <summary>
        /// Called when authenitcator has concluded a result for a connection. Boolean is true if authentication passed, false if failed. This invokes before OnClientAuthenticated so FishNet may run operations on authenticated clients before user code does.
        /// </summary>
        /// <param name="obj"></param>
        internal void OnClientAuthenticated(NetworkConnection connection)
        {
            AddPendingLoad(connection);

            //No global scenes to load.
            if (_globalScenes.Length == 0)
            {
                EmptyStartScenesBroadcast msg = new EmptyStartScenesBroadcast();
                connection.Broadcast(msg);
            }
            else
            {
                SceneLoadData sld = new SceneLoadData(_globalScenes);
                sld.Params = _globalSceneLoadData.Params;
                sld.Options = _globalSceneLoadData.Options;
                sld.ReplaceScenes = _globalSceneLoadData.ReplaceScenes;

                LoadQueueData qd = new LoadQueueData(SceneScopeType.Global, new NetworkConnection[0], sld, _globalScenes, false);
                //Send message to load the networked scenes.
                LoadScenesBroadcast msg = new LoadScenesBroadcast()
                {
                    QueueData = qd
                };

                connection.Broadcast(msg, true);
            }
        }

        /// <summary>
        /// Received on client when the server has no start scenes.
        /// </summary>
        private void OnClientEmptyStartScenes(EmptyStartScenesBroadcast msg)
        {
            _clientManager.Broadcast(msg);
        }
        /// <summary>
        /// Received on server when client confirms there are no start scenes.
        /// </summary>
        private void OnServerEmptyStartScenes(NetworkConnection conn, EmptyStartScenesBroadcast msg)
        {
            //Already received, shouldn't be happening again.
            if (conn.LoadedStartScenes)
            {
                if (_networkManager.CanLog(LoggingType.Common))
                    Debug.LogError($"Received multiple EmptyStartSceneBroadcast from connectionId {conn.ClientId}. Connection will be kicked immediately.");
                _networkManager.TransportManager.Transport.StopConnection(conn.ClientId, true);
            }
            else
            {
                OnClientLoadedScenes(conn, new ClientScenesLoadedBroadcast());
            }
        }
        #endregion

        #region Player disconnect.
        /// <summary>
        /// Received when a player disconnects from the server.
        /// </summary>
        /// <param name="conn"></param> //finish.
        private void ClientDisconnected(NetworkConnection conn)
        {
            _pendingClientSceneChanges.Remove(conn);
            /* Remove connection from all scenes. While doing so check
             * if scene should be unloaded provided there are no more clients
             * in the scene, and it's set to automatically unload. This situation is a bit
             * unique since a client disconnect happens outside the manager, so there
             * isn't much code we can re-use to perform this operation. */
            List<Scene> scenesToUnload = new List<Scene>();
            //Current active scene.
            Scene activeScene = UnitySceneManager.GetActiveScene();
            foreach (KeyValuePair<Scene, HashSet<NetworkConnection>> item in SceneConnections)
            {
                Scene scene = item.Key;
                HashSet<NetworkConnection> hs = item.Value;

                bool removed = hs.Remove(conn);
                /* If no more observers for scene, not a global scene, and not to be manually unloaded
                 * then remove scene from SceneConnections and unload it. */
                if (removed && hs.Count == 0 &&
                    !IsGlobalScene(scene) && !_manualUnloadScenes.Contains(scene) &&
                    (scene != activeScene))
                    scenesToUnload.Add(scene);
            }

            //If scenes should be unloaded.
            if (scenesToUnload.Count > 0)
            {
                foreach (Scene s in scenesToUnload)
                    SceneConnections.Remove(s);
                SceneUnloadData sud = new SceneUnloadData(SceneLookupData.CreateData(scenesToUnload));
                UnloadConnectionScenes(new NetworkConnection[0], sud);
            }
        }
        #endregion

        #region Server received messages.
        /// <summary>
        /// Received on server when a client loads scenes.
        /// </summary>
        /// <param name="conn"></param>
        /// <param name="msg"></param>
        private void OnClientLoadedScenes(NetworkConnection conn, ClientScenesLoadedBroadcast msg)
        {
            int pendingLoads;
            _pendingClientSceneChanges.TryGetValueIL2CPP(conn, out pendingLoads);

            //There's no loads or unloads pending, kick client.
            if (pendingLoads == 0)
            {
                if (_networkManager.CanLog(LoggingType.Common))
                    Debug.LogError($"Received excessive ClientScenesLoadedBroadcast from connectionId {conn.ClientId}. Connection will be kicked immediately.");
                _networkManager.TransportManager.Transport.StopConnection(conn.ClientId, true);

                return;
            }
            //If there is a load pending then update pending count.
            else
            {
                pendingLoads--;
                if (pendingLoads == 0)
                    _pendingClientSceneChanges.Remove(conn);
                else
                    _pendingClientSceneChanges[conn] = pendingLoads;
            }

            if (!Comparers.IsDefault(msg))
            {
                foreach (SceneLookupData item in msg.SceneLookupDatas)
                {
                    Scene s = item.GetScene(out _);
                    if (s.IsValid())
                        AddConnectionToScene(conn, s);
                }
            }

            TryInvokeLoadedStartScenes(conn, true);
        }
        #endregion

        #region Events.
        /// <summary>
        /// Checks if OnQueueStart should invoke, and if so invokes.
        /// </summary>
        private void TryInvokeOnQueueStart()
        {
            if (_sceneQueueStartInvoked)
                return;

            _sceneQueueStartInvoked = true;
            OnQueueStart?.Invoke();
        }
        /// <summary>
        /// Checks if OnQueueEnd should invoke, and if so invokes.
        /// </summary>
        private void TryInvokeOnQueueEnd()
        {
            if (!_sceneQueueStartInvoked)
                return;

            _sceneQueueStartInvoked = false;
            OnQueueEnd?.Invoke();
        }
        /// <summary>
        /// Invokes that a scene load has started. Only called when valid scenes will be loaded.
        /// </summary>
        /// <param name="qd"></param>
        private void InvokeOnSceneLoadStart(LoadQueueData qd)
        {
            TryInvokeOnQueueStart();
            OnLoadStart?.Invoke(new SceneLoadStartEventArgs(qd));
        }
        /// <summary>
        /// Invokes that a scene load has ended. Only called after a valid scene has loaded.
        /// </summary>
        /// <param name="qd"></param>
        private void InvokeOnSceneLoadEnd(LoadQueueData qd, List<string> requestedLoadScenes, List<Scene> loadedScenes, string[] unloadedSceneNames)
        {
            //Make new list to not destroy original data.
            List<string> skippedScenes = requestedLoadScenes.ToList();
            //Remove loaded scenes from requested scenes.
            for (int i = 0; i < loadedScenes.Count; i++)
                skippedScenes.Remove(loadedScenes[i].name);

            SceneLoadEndEventArgs args = new SceneLoadEndEventArgs(qd, skippedScenes.ToArray(), loadedScenes.ToArray(), unloadedSceneNames);
            OnLoadEnd?.Invoke(args);
        }
        /// <summary>
        /// Invokes that a scene unload has started. Only called when valid scenes will be unloaded.
        /// </summary>
        /// <param name="sqd"></param>
        private void InvokeOnSceneUnloadStart(UnloadQueueData sqd)
        {
            TryInvokeOnQueueStart();
            OnUnloadStart?.Invoke(new SceneUnloadStartEventArgs(sqd));
        }
        /// <summary>
        /// Invokes that a scene unload has ended. Only called after a valid scene has unloaded.
        /// </summary>
        /// <param name="sqd"></param>
        private void InvokeOnSceneUnloadEnd(UnloadQueueData sqd, List<Scene> unloadedScenes)
        {
            OnUnloadEnd?.Invoke(new SceneUnloadEndEventArgs(sqd, unloadedScenes));
        }
        /// <summary>
        /// Invokes when completion percentage changes while unloading or unloading a scene. Value is between 0f and 1f, while 1f is 100% done.
        /// </summary>
        /// <param name="value"></param>
        private void InvokeOnScenePercentChange(LoadQueueData qd, float value)
        {
            value = Mathf.Clamp(value, 0f, 1f);
            SceneLoadPercentEventArgs slp = new SceneLoadPercentEventArgs(qd, value);
            OnLoadPercentChange?.Invoke(slp);
        }
        #endregion

        #region Scene queue processing.
        /// <summary>
        /// Queues a load or unload operation and starts queue if needed.
        /// </summary>
        /// <param name="data"></param>
        private void QueueOperation(object data)
        {
            //Add to scene queue data.        
            _queuedOperations.Add(data);
            /* If only one entry then scene operations are not currently in progress.
             * Should there be more than one entry then scene operations are already 
             * occuring. The coroutine will automatically load in order. */

            if (_queuedOperations.Count == 1)
                StartCoroutine(__ProcessSceneQueue());
        }
        /// <summary>
        /// Processes queued scene operations.
        /// </summary>
        /// <param name="asServer"></param>
        /// <returns></returns>
        private IEnumerator __ProcessSceneQueue()
        {
            /* Queue start won't invoke unless a scene load or unload actually occurs.
             * For example: if a scene is already loaded, and nothing needs to be loaded,
             * queue start will not invoke. */

            while (_queuedOperations.Count > 0)
            {
                //If a load scene.
                if (_queuedOperations[0] is LoadQueueData)
                    yield return StartCoroutine(__LoadScenes());
                //If an unload scene.
                else if (_queuedOperations[0] is UnloadQueueData)
                    yield return StartCoroutine(__UnloadScenes());

                if (_queuedOperations.Count > 0)
                    _queuedOperations.RemoveAt(0);
            }

            TryInvokeOnQueueEnd();
        }
        #endregion

        #region LoadScenes
        /// <summary>
        /// Loads scenes on the server and for all clients. Future clients will automatically load these scenes.
        /// </summary>
        /// <param name="sceneLoadData">Data about which scenes to load.</param>
        public void LoadGlobalScenes(SceneLoadData sceneLoadData)
        {
            LoadGlobalScenesInternal(sceneLoadData, _globalScenes, true);
        }
        /// <summary>
        /// Adds to load scene queue.
        /// </summary>
        /// <param name="sceneLoadData"></param>
        /// <param name="asServer"></param>
        private void LoadGlobalScenesInternal(SceneLoadData sceneLoadData, string[] globalScenes, bool asServer)
        {
            if (!CanExecute(asServer, true))
                return;
            if (SceneDataInvalid(sceneLoadData, true))
                return;

            LoadQueueData lqd = new LoadQueueData(SceneScopeType.Global, new NetworkConnection[0], sceneLoadData, globalScenes, asServer);
            QueueOperation(lqd);
        }

        /// <summary>
        /// Loads scenes on server and tells connections to load them as well. Other connections will not load this scene.
        /// </summary>
        /// <param name="conn">Connections to load scenes for.</param>
        /// <param name="sceneLoadData">Data about which scenes to load.</param>
        public void LoadConnectionScenes(NetworkConnection conn, SceneLoadData sceneLoadData)
        {
            LoadConnectionScenes(new NetworkConnection[] { conn }, sceneLoadData);
        }
        /// <summary>
        /// Loads scenes on server and tells connections to load them as well. Other connections will not load this scene.
        /// </summary>
        /// <param name="conns">Connections to load scenes for.</param>
        /// <param name="sceneLoadData">Data about which scenes to load.</param>
        public void LoadConnectionScenes(NetworkConnection[] conns, SceneLoadData sceneLoadData)
        {
            LoadConnectionScenesInternal(conns, sceneLoadData, _globalScenes, true);
        }
        /// <summary>
        /// Loads scenes on server without telling clients to load the scenes.
        /// </summary>
        /// <param name="sceneLoadData">Data about which scenes to load.</param>
        public void LoadConnectionScenes(SceneLoadData sceneLoadData)
        {
            LoadConnectionScenesInternal(new NetworkConnection[0], sceneLoadData, _globalScenes, true);
        }

        /// <summary>
        /// Adds to load scene queue.
        /// </summary>
        /// <param name="sceneLoadData"></param>
        /// <param name="asServer"></param>
        private void LoadConnectionScenesInternal(NetworkConnection[] conns, SceneLoadData sceneLoadData, string[] globalScenes, bool asServer)
        {
            if (!CanExecute(asServer, true))
                return;
            if (SceneDataInvalid(sceneLoadData, true))
                return;

            LoadQueueData lqd = new LoadQueueData(SceneScopeType.Connections, conns, sceneLoadData, globalScenes, asServer);
            QueueOperation(lqd);
        }

        /// <summary>
        /// Returns if a NetworkObject can be moved.
        /// </summary>
        /// <param name="warn"></param>
        /// <returns></returns>
        private bool CanMoveNetworkObject(NetworkObject nob)
        {
            bool canLog = _networkManager.CanLog(LoggingType.Warning);

            //Null.
            if (nob == null)
            {
                if (canLog)
                    Debug.LogWarning($"NetworkObject is null.");
                return false;
            }
            //Not networked.
            if (!nob.IsNetworked)
            {
                if (canLog)
                    Debug.LogWarning($"NetworkObject {nob.name} cannot be moved as it is not networked.");
                return false;
            }

            //Not spawned.
            if (!nob.IsSpawned)
            {
                if (canLog)
                    Debug.LogWarning($"NetworkObject {nob.name} canot be moved as it is not spawned.");
                return false;
            }
            //SceneObject.
            if (nob.IsSceneObject)
            {
                if (canLog)
                    Debug.LogWarning($"NetworkObject {nob.name} cannot be moved as it is a scene object.");
                return false;
            }
            //Not root.
            if (nob.transform.parent != null)
            {
                if (canLog)
                    Debug.LogWarning($"NetworkObject {nob.name} cannot be moved because it is not the root object. Unity can only move root objects between scenes.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Loads a connection scene queue data. This behaves just like a networked scene load except it sends only to the specified connections, and it always loads as an additive scene on server.
        /// </summary>
        /// <returns></returns>
        private IEnumerator __LoadScenes()
        {
            LoadQueueData data = _queuedOperations[0] as LoadQueueData;
            //True if running as server.
            bool asServer = data.AsServer;
            //True if running as client, while network server is active.
            bool asHost = (!asServer && _networkManager.IsServer);

            //If connection went inactive.
            if (!ConnectionActive(asServer))
                yield break;

            /* Scene sanity checks. */
            if (data.SceneLoadData.SceneLookupDatas.Length == 0)
            {
                if (_networkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"No scenes specified to load.");
                yield break;
            }

            //True if replacing scenes with specified ones.
            ReplaceOption replaceScenes = data.SceneLoadData.ReplaceScenes;

            /* Immediately set new global scenes. If on client this is whatever
             * server passes in. This should be set even if scope type
             * is not global because clients might get a connection scene first.
             */
            if (!asServer)
            {
                if (!asHost)
                    _globalScenes = data.GlobalScenes;
            }
            /* However, if server, then only update global scenes if scope
             * is global. */
            else if (asServer && data.ScopeType == SceneScopeType.Global)
            {
                _globalSceneLoadData = data.SceneLoadData;
                string[] names = data.SceneLoadData.SceneLookupDatas.GetNames();
                //If replacing.
                if (replaceScenes != ReplaceOption.None)
                {
                    _globalScenes = names;
                }
                //Add onto.
                else
                {
                    int index = _globalScenes.Length;
                    Array.Resize(ref _globalScenes, _globalScenes.Length + names.Length);
                    Array.Copy(names, 0, _globalScenes, index, names.Length);
                }

                data.GlobalScenes = _globalScenes;
            }

            /* Scene queue data scenes.
            * All scenes in the scene queue data whether they will be loaded or not. */
            List<string> requestedLoadSceneNames = new List<string>();
            List<int> requestedLoadSceneHandles = new List<int>();

            /* Make a null filled array. This will be populated
             * using loaded scenes, or already loaded (eg cannot be loaded) scenes. */
            SceneLookupData[] broadcastLookupDatas = new SceneLookupData[data.SceneLoadData.SceneLookupDatas.Length];

            /* LoadableScenes and SceneReferenceDatas.
            /* Will contain scenes which may be loaded.
             * Scenes might not be added to loadableScenes
             * if for example loadOnlyUnloaded is true and
             * the scene is already loaded. */
            List<SceneLookupData> loadableScenes = new List<SceneLookupData>();
            for (int i = 0; i < data.SceneLoadData.SceneLookupDatas.Length; i++)
            {
                SceneLookupData sld = data.SceneLoadData.SceneLookupDatas[i];
                //Scene to load.
                bool byHandle;
                Scene s = sld.GetScene(out byHandle);
                //If found then add it to requestedLoadScenes.
                if (s.IsValid())
                {
                    requestedLoadSceneNames.Add(s.name);
                    if (byHandle)
                        requestedLoadSceneHandles.Add(s.handle);
                }

                if (CanLoadScene(data, sld))
                {
                    //Don't load if as host, server side would have loaded already.
                    if (!asHost)
                        loadableScenes.Add(sld);
                }
                //Only the server needs to find scene handles to send to client. Client will send these back to the server.
                else if (asServer)
                {
                    /* If here then scene cannot be loaded, which
                     * can only happen if the scene already exists.
                     * Find the scene using sld and set to datas. */
                    /* Set at the index of i. This way should the current
                     * SLD not be the first scene it won't fill the
                     * first slot in broadcastLookupDatas. This is important
                     * because the first slot is used for the single scene
                     * when using replace scenes. */
                    broadcastLookupDatas[i] = new SceneLookupData(s);
                }
            }

            /* Move identities
             * to holder scene to preserve them. 
             * Required if a single scene is specified. Cannot rely on
             * loadSingleScene since it is only true if the single scene
             * must be loaded, which may be false if it's already loaded on
             * the server. */
            //Do not run if running as client, and server is active. This would have already run as server.
            if (!asHost)
            {
                foreach (NetworkObject nob in data.SceneLoadData.MovedNetworkObjects)
                {
                    //NetworkObject might be null if client lost observation of it.
                    if (nob != null && CanMoveNetworkObject(nob))
                        UnitySceneManager.MoveGameObjectToScene(nob.gameObject, GetMovedObjectsScene());
                }
            }

            /* Resetting SceneConnections. */
            /* If server and replacing scenes.
             * It's important to run this AFTER moving MovedNetworkObjects
             * so that they are no longer in the scenes they are leaving. Otherwise
             * the scene condition would pick them up as still in the leaving scene. */
            if (asServer && (replaceScenes != ReplaceOption.None))
            {
                //If global then remove all connections from all scenes.
                if (data.ScopeType == SceneScopeType.Global)
                {
                    Scene[] scenes = SceneConnections.Keys.ToArray();
                    foreach (Scene s in scenes)
                        RemoveAllConnectionsFromScene(s);
                }
                //Connections.
                else if (data.ScopeType == SceneScopeType.Connections)
                {
                    RemoveConnectionsFromNonGlobalScenes(data.Connections);
                }
            }

            /* Scene unloading if replacing scenes.
             * 
            * Unload all scenes except MovedObjectsHolder. Also don't
            * unload GlobalScenes if loading as connection. */
            List<Scene> unloadableScenes = new List<Scene>();
            //Do not run if running as client, and server is active. This would have already run as server.
            if ((replaceScenes != ReplaceOption.None) && !asHost)
            {
                //Unload all other scenes.
                for (int i = 0; i < UnitySceneManager.sceneCount; i++)
                {
                    Scene s = UnitySceneManager.GetSceneAt(i);
                    //MovedObjectsScene will never be unloaded.
                    if (s == GetMovedObjectsScene())
                        continue;
                    /* Scene is in one of the scenes being loaded.
                    * This can occur when trying to load additional clients
                    * into an existing scene. */
                    if (requestedLoadSceneNames.Contains(s.name))
                        continue;
                    //Same as above but using handles.
                    if (requestedLoadSceneHandles.Contains(s.handle))
                        continue;
                    /* Cannot unload global scenes. If
                     * replace scenes was used for a global
                     * load then global scenes would have been reset
                     * before this. */
                    if (IsGlobalScene(s))
                        continue;
                    //If scene must be manually unloaded then it cannot be unloaded here.
                    if (_manualUnloadScenes.Contains(s))
                        continue;

                    HashSet<NetworkConnection> conns;
                    if (SceneConnections.TryGetValueIL2CPP(s, out conns))
                    {
                        //Still has clients in scene.
                        if (conns != null && conns.Count > 0)
                            continue;
                    }
                    //An offline scene.
                    else
                    {
                        //If not replacing all scenes then skip offline scenes.
                        if (replaceScenes != ReplaceOption.All)
                            continue;
                    }

                    unloadableScenes.Add(s);
                }
            }

            /* Start event. */
            if (unloadableScenes.Count > 0 || loadableScenes.Count > 0)
            {
                InvokeOnSceneLoadStart(data);
                _sceneProcessor.LoadStart(data);
            }
            //Unloaded scenes by name. Only used for information within callbacks.
            string[] unloadedNames = new string[unloadableScenes.Count];
            for (int i = 0; i < unloadableScenes.Count; i++)
                unloadedNames[i] = unloadableScenes[i].name;
            /* Before unloading if !asServer and !asHost and replacing scenes
             * then move all non scene networked objects to the moved
             * objects holder. Otherwise network objects would get destroyed
             * on the scene change and never respawned if server doesn't
             * have a reason to update visibility. */
            if (!data.AsServer && !asHost && (replaceScenes != ReplaceOption.None))
            {
                Scene s = GetMovedObjectsScene();
                foreach (NetworkObject nob in _networkManager.ClientManager.Objects.Spawned.Values)
                {
                    if (!nob.IsSceneObject)
                        UnitySceneManager.MoveGameObjectToScene(nob.gameObject, s);
                }
            }
            /* Unloading scenes. */
            _sceneProcessor.UnloadStart(data);
            for (int i = 0; i < unloadableScenes.Count; i++)
            {
                MoveClientHostObjects(unloadableScenes[i], asServer);
                //Unload one at a time.
                _sceneProcessor.BeginUnloadAsync(unloadableScenes[i]);
                while (!_sceneProcessor.IsPercentComplete())
                    yield return null;
            }
            _sceneProcessor.UnloadEnd(data);

            //Scenes loaded.
            List<Scene> loadedScenes = new List<Scene>();
            /* Scene loading.
            /* Use additive to not thread lock server. */
            for (int i = 0; i < loadableScenes.Count; i++)
            {
                //Start load async and wait for it to finish.
                LoadSceneParameters loadSceneParameters = new LoadSceneParameters()
                {
                    loadSceneMode = LoadSceneMode.Additive,
                    localPhysicsMode = data.SceneLoadData.Options.LocalPhysics
                };

                /* How much percentage each scene load can be worth
                * at maximum completion. EG: if there are two scenes
                * 1f / 2f is 0.5f. */
                float maximumIndexWorth = (1f / (float)loadableScenes.Count);

                _sceneProcessor.BeginLoadAsync(loadableScenes[i].Name, loadSceneParameters);
                while (!_sceneProcessor.IsPercentComplete())
                {
                    float percent = _sceneProcessor.GetPercentComplete();
                    InvokePercentageChange(i, maximumIndexWorth, percent);
                    yield return null;
                }    

                //Invokes OnScenePercentChange with progress.
                void InvokePercentageChange(int index, float maximumWorth, float currentScenePercent)
                {
                    /* Total percent will be how much percentage is complete
                    * in total. Initialize it with a value based on how many
                    * scenes are already fully loaded. */
                    float totalPercent = (index * maximumWorth);
                    //Add this scenes progress onto total percent.
                    totalPercent += Mathf.Lerp(0f, maximumWorth, currentScenePercent);
                    //Dispatch with total percent.
                    InvokeOnScenePercentChange(data, totalPercent);
                }

                //Add to loaded scenes.
                Scene loaded = UnitySceneManager.GetSceneAt(UnitySceneManager.sceneCount - 1);
                loadedScenes.Add(loaded);
                _sceneProcessor.AddLoadedScene(loaded);
            }
            //When all scenes are loaded invoke with 100% done.
            InvokeOnScenePercentChange(data, 1f);

            /* Add to ManuallyUnloadScenes. */
            if (data.AsServer && !data.SceneLoadData.Options.AutomaticallyUnload)
            {
                foreach (Scene s in loadedScenes)
                    _manualUnloadScenes.Add(s);
            }
            /* Move identities to first scene. */
            if (!asHost)
            {
                //Find the first valid scene to move objects to.
                Scene firstValidScene = default;
                //If to stack scenes.
                if (data.SceneLoadData.Options.AllowStacking)
                {
                    Scene firstScene = GetFirstLookupScene(data.SceneLoadData.SceneLookupDatas);
                    /* If the first lookup data contains a handle and the scene
                     * is found for that handle then use that as the moved to scene.
                     * Nobs always move to the first specified scene. */
                    if (data.SceneLoadData.SceneLookupDatas[0].Handle != 0 && !string.IsNullOrEmpty(firstScene.name))
                    {
                        firstValidScene = firstScene;
                    }
                    //If handle is not specified then used the last scene that has the same name as the first lookupData.
                    else
                    {
                        Scene lastSameSceneName = default;
                        for (int i = 0; i < UnitySceneManager.sceneCount; i++)
                        {
                            Scene s = UnitySceneManager.GetSceneAt(i);
                            if (s.name == firstScene.name)
                                lastSameSceneName = s;
                        }

                        /* Shouldn't be possible since the scene will always exist either by 
                         * just being loaded or already loaded. */
                        if (string.IsNullOrEmpty(lastSameSceneName.name))
                        {
                            if (_networkManager.CanLog(LoggingType.Error))
                                Debug.LogError($"Scene {data.SceneLoadData.SceneLookupDatas[0].Name} could not be found in loaded scenes.");
                        }
                        else
                        {
                            firstValidScene = lastSameSceneName;
                        }
                    }
                }
                //Not stacking.
                else
                {
                    firstValidScene = GetFirstLookupScene(data.SceneLoadData.SceneLookupDatas);
                    //If not found by look then try firstloaded.
                    if (string.IsNullOrEmpty(firstValidScene.name))
                        firstValidScene = GetFirstLoadedScene();
                }

                //Gets first scene loaded this method call.
                Scene GetFirstLoadedScene()
                {
                    if (loadedScenes.Count > 0)
                        return loadedScenes[0];
                    else
                        return default;
                }
                //Gets first found scene in datas.
                Scene GetFirstLookupScene(SceneLookupData[] datas)
                {
                    foreach (SceneLookupData sld in datas)
                    {
                        Scene result = sld.GetScene(out _);
                        if (!string.IsNullOrEmpty(result.name))
                            return result;
                    }

                    return default;
                }

                //If firstValidScene is still invalid then throw.
                if (string.IsNullOrEmpty(firstValidScene.name))
                {
                    if (_networkManager.CanLog(LoggingType.Error))
                        Debug.LogError($"Unable to move objects to a new scene because new scene lookup has failed.");
                }
                //Move objects.
                else
                {
                    Scene s = GetMovedObjectsScene();
                    s.GetRootGameObjects(_movingObjects);

                    foreach (GameObject go in _movingObjects)
                        UnitySceneManager.MoveGameObjectToScene(go, firstValidScene);
                }
            }

            _sceneProcessor.ActivateLoadedScenes();
            //Wait until everything is loaded (done).
            yield return _sceneProcessor.AsyncsIsDone();
            _sceneProcessor.LoadEnd(data);

            /* Wait until loadedScenes are all marked as done.
             * This is an extra precautionary step because on some devices
             * the AsyncIsDone returns true before scenes are actually loaded. */
            bool allScenesLoaded = true;
            do
            {
                foreach (Scene s in loadedScenes)
                {
                    if (!s.isLoaded)
                    {
                        allScenesLoaded = false;
                        break;
                    }
                }
                yield return null;
            } while (!allScenesLoaded);

            SetActiveScene();

            //Only the server needs to find scene handles to send to client. Client will send these back to the server.
            if (asServer)
            {
                //Populate broadcastLookupDatas with any loaded scenes.
                foreach (Scene s in loadedScenes)
                {
                    SetInFirstNullIndex(s);

                    //Sets scene in the first null index of broadcastLookupDatas.
                    void SetInFirstNullIndex(Scene scene)
                    {
                        for (int i = 0; i < broadcastLookupDatas.Length; i++)
                        {
                            if (broadcastLookupDatas[i] == null)
                            {
                                broadcastLookupDatas[i] = new SceneLookupData(scene);
                                return;
                            }
                        }

                        //If here there are no null entries.
                        if (_networkManager.CanLog(LoggingType.Error))
                            Debug.LogError($"Cannot add scene to broadcastLookupDatas, collection is full.");
                    }
                }
            }

            /* If running as server and server is
             * active then send scene changes to client.
             * Making sure server is still active should it maybe
             * have dropped during scene loading. */
            if (data.AsServer && _networkManager.IsServer)
            {
                //Tell clients to load same scenes.
                LoadScenesBroadcast msg = new LoadScenesBroadcast()
                {
                    QueueData = data
                };
                //Replace scene lookup datas with ones intended to broadcast to client.
                msg.QueueData.SceneLoadData.SceneLookupDatas = broadcastLookupDatas;
                //If networked scope then send to all.
                if (data.ScopeType == SceneScopeType.Global)
                {
                    NetworkConnection[] conns = _serverManager.Clients.Values.ToArray();
                    AddPendingLoad(conns);
                    _serverManager.Broadcast(msg, true);
                }
                //If connections scope then only send to connections.
                else if (data.ScopeType == SceneScopeType.Connections)
                {
                    AddPendingLoad(data.Connections);
                    for (int i = 0; i < data.Connections.Length; i++)
                    {
                        if (data.Connections[i].Authenticated)
                            data.Connections[i].Broadcast(msg, true);
                    }
                }
            }
            /* If running as client then send a message
             * to the server to tell them the scene was loaded.
             * This allows the server to add the client
             * to the scene for checkers. */
            else if (!data.AsServer && _networkManager.IsClient)
            {
                ClientScenesLoadedBroadcast msg = new ClientScenesLoadedBroadcast()
                {
                    SceneLookupDatas = data.SceneLoadData.SceneLookupDatas
                };
                _clientManager.Broadcast(msg);
            }

            InvokeOnSceneLoadEnd(data, requestedLoadSceneNames, loadedScenes, unloadedNames);
        }

        /// <summary>
        /// Received on client when connection scenes must be loaded.
        /// </summary>
        /// <param name="conn"></param>
        /// <param name="msg"></param>
        private void OnLoadScenes(LoadScenesBroadcast msg)
        {
            //Null data is sent by the server when there are no start scenes to load.
            if (msg.QueueData == null)
            {
                TryInvokeLoadedStartScenes(_clientManager.Connection, false);
                return;
            }

            LoadQueueData qd = msg.QueueData;
            if (qd.ScopeType == SceneScopeType.Global)
                LoadGlobalScenesInternal(qd.SceneLoadData, qd.GlobalScenes, false);
            else
                LoadConnectionScenesInternal(new NetworkConnection[0], qd.SceneLoadData, qd.GlobalScenes, false);
        }
        #endregion

        #region UnloadScenes.
        /// <summary>
        /// Unloads scenes on the server and for all clients.
        /// </summary>
        /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
        public void UnloadGlobalScenes(SceneUnloadData sceneUnloadData)
        {
            if (!CanExecute(true, true))
                return;

            UnloadGlobalScenesInternal(sceneUnloadData, _globalScenes, true);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scope"></param>
        /// <param name="conns"></param>
        /// <param name="additiveScenes"></param>
        /// <param name="asServer"></param>
        private void UnloadGlobalScenesInternal(SceneUnloadData sceneUnloadData, string[] globalScenes, bool asServer)
        {
            UnloadQueueData uqd = new UnloadQueueData(SceneScopeType.Global, new NetworkConnection[0], sceneUnloadData, globalScenes, asServer);
            QueueOperation(uqd);
        }

        /// <summary>
        /// Unloads scenes on server and tells a connection to unload them as well. Other connections will not unload this scene.
        /// </summary>
        /// <param name="connection">Connection to unload scenes for.</param>
        /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
        public void UnloadConnectionScenes(NetworkConnection connection, SceneUnloadData sceneUnloadData)
        {
            UnloadConnectionScenes(new NetworkConnection[] { connection }, sceneUnloadData);
        }
        /// <summary>
        /// Unloads scenes on server and tells connections to unload them as well. Other connections will not unload this scene.
        /// </summary>
        /// <param name="connections">Connections to unload scenes for.</param>
        /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
        public void UnloadConnectionScenes(NetworkConnection[] connections, SceneUnloadData sceneUnloadData)
        {
            UnloadConnectionScenesInternal(connections, sceneUnloadData, _globalScenes, true);
        }

        /// <summary>
        /// Unloads scenes on server without telling any connections to unload them.
        /// </summary>
        /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
        public void UnloadConnectionScenes(SceneUnloadData sceneUnloadData)
        {
            UnloadConnectionScenesInternal(new NetworkConnection[0], sceneUnloadData, _globalScenes, true);
        }
        /// <summary>
        /// Unloads scenes for connections.
        /// </summary>
        /// <param name="connections"></param>
        /// <param name="sceneUnloadData"></param>
        /// <param name="globalScenes"></param>
        /// <param name="asServer"></param>
        private void UnloadConnectionScenesInternal(NetworkConnection[] connections, SceneUnloadData sceneUnloadData, string[] globalScenes, bool asServer)
        {
            if (!CanExecute(asServer, true))
                return;
            if (SceneDataInvalid(sceneUnloadData, true))
                return;

            UnloadQueueData uqd = new UnloadQueueData(SceneScopeType.Connections, connections, sceneUnloadData, globalScenes, asServer);
            QueueOperation(uqd);
        }
        /// <summary>
        /// Loads scenes within QueuedSceneLoads.
        /// </summary>
        /// <returns></returns>
        private IEnumerator __UnloadScenes()
        {
            UnloadQueueData data = _queuedOperations[0] as UnloadQueueData;

            //If connection went inactive.
            if (!ConnectionActive(data.AsServer))
                yield break;

            /* Some actions should not run as client if server is also active.
            * This is to keep things from running twice. */
            bool asClientHost = (!data.AsServer && _networkManager.IsServer);
            ///True if running asServer.
            bool asServer = data.AsServer;

            //Get scenes to unload.
            Scene[] scenes = GetScenes(data.SceneUnloadData.SceneLookupDatas);
            /* No scenes found. Only run this if not asHost.
             * While asHost scenes will possibly not exist because
             * server side has already unloaded them. But rest of
             * the unload should continue. */
            if (scenes.Length == 0 && !asClientHost)
            {
                if (_networkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"No scenes were found to unload.");
                yield break;
            }

            /* Remove from global scenes
            * if server and scope is global.
            * All passed in scenes should be removed from global
            * regardless of if they're valid or not. If they are invalid,
            * then they shouldn't be in global to begin with. */
            if (asServer && data.ScopeType == SceneScopeType.Global)
            {
                RemoveFromGlobalScenes(data.SceneUnloadData.SceneLookupDatas);
                //Update queue data.
                data.GlobalScenes = _globalScenes;
            }

            /* Remove connections. */
            if (asServer)
            {
                foreach (Scene s in scenes)
                {
                    //If global then remove all connections.
                    if (data.ScopeType == SceneScopeType.Global)
                        RemoveAllConnectionsFromScene(s);
                    //Connections.
                    else if (data.ScopeType == SceneScopeType.Connections)
                        RemoveConnectionsFromScene(data.Connections, s);
                }
            }

            /* This will contain all scenes which can be unloaded.
             * The collection will be modified through various checks. */
            List<Scene> unloadableScenes = scenes.ToList();
            /* If asServer and KeepUnused then clear all unloadables.
             * The clients will still unload the scenes. */
            if ((asServer || asClientHost) && data.SceneUnloadData.Options.Mode == UnloadOptions.ServerUnloadMode.KeepUnused)
                unloadableScenes.Clear();
            /* Check to remove global scenes unloadableScenes.
             * This will need to be done if scenes are being unloaded
             * for connections. Global scenes cannot be unloaded as
             * connection. */
            if (data.ScopeType == SceneScopeType.Connections)
                RemoveGlobalScenes(unloadableScenes);
            //If set to unload unused only.
            if (data.SceneUnloadData.Options.Mode == UnloadOptions.ServerUnloadMode.UnloadUnused)
                RemoveOccupiedScenes(unloadableScenes);

            //If there are scenes to unload.
            if (unloadableScenes.Count > 0)
            {
                InvokeOnSceneUnloadStart(data);
                _sceneProcessor.UnloadStart(data);

                //Begin unloading.
                foreach (Scene s in unloadableScenes)
                {
                    MoveClientHostObjects(s, asServer);
                    /* Remove from manualUnloadedScenes.
                     * Scene may not be in this collection
                     * but removing is one call vs checking
                    * then removing. */
                    _manualUnloadScenes.Remove(s);

                    _sceneProcessor.BeginUnloadAsync(s);
                    while (!_sceneProcessor.IsPercentComplete())
                        yield return null;
                }

                _sceneProcessor.UnloadEnd(data);
            }

            /* Must yield after sceneProcessor handles things.
            * This is a Unity bug of sorts. I'm not entirely sure what
            * is happening, but without the yield it seems as though
            * the processor logic doesn't complete. This doesn't make much
            * sense given unity is supposed to be single threaded. Must be
            * something to do with the coroutine. */
            yield return null;
            SetActiveScene();

            /* If running as server then make sure server
             * is still active after the unloads. If so
             * send out unloads to clients. */
            if (asServer && ConnectionActive(true))
            {
                //Tell clients to unload same scenes.
                UnloadScenesBroadcast msg = new UnloadScenesBroadcast()
                {
                    QueueData = data
                };
                //Global.
                if (data.ScopeType == SceneScopeType.Global)
                {
                    _serverManager.Broadcast(msg, true);
                }
                //Connections.
                else if (data.ScopeType == SceneScopeType.Connections)
                {
                    if (data.Connections != null)
                    {
                        for (int i = 0; i < data.Connections.Length; i++)
                        {
                            if (data.Connections[i] != null)
                                data.Connections[i].Broadcast(msg, true);
                        }
                    }
                }
            }

            InvokeOnSceneUnloadEnd(data, unloadableScenes);
        }

        /// <summary>
        /// Received on clients when networked scenes must be unloaded.
        /// </summary>
        /// <param name="conn"></param>
        /// <param name="msg"></param>
        private void OnUnloadScenes(UnloadScenesBroadcast msg)
        {
            UnloadQueueData qd = msg.QueueData;
            if (qd.ScopeType == SceneScopeType.Global)
                UnloadGlobalScenesInternal(qd.SceneUnloadData, qd.GlobalScenes, false);
            else
                UnloadConnectionScenesInternal(new NetworkConnection[0], qd.SceneUnloadData, qd.GlobalScenes, false);
        }
        #endregion

        /// <summary>
        /// Move objects visible to clientHost that are within an unloading scene.This ensures the objects are despawned on the client side rather than when the scene is destroyed.
        /// </summary>
        /// <param name="scene"></param>
        private void MoveClientHostObjects(Scene scene, bool asServer)
        {
            if (!_moveClientHostObjects)
                return;
            /* The asServer isn't really needed. I could only call
             * this method when asServer is true. But for the sake
             * of preventing user-error (me being the user this time)
             * I've included it into the parameters. */
            if (!asServer)
                return;
            //Don't need to perform if not host.
            if (!_networkManager.IsClient)
                return;

            NetworkConnection clientConn = _networkManager.ClientManager.Connection;
            /* It would be nice to see if the client wasn't even in the scene
             * here using SceneConnections but it's possible that the scene had been
             * wiped from SceneConnections earlier depending on how scenes are
             * loaded or unloaded. Instead we must iterate through spawned objects. */

            ListCache<NetworkObject> movingNobs = ListCaches.GetNetworkObjectCache();
            /* Rather than a get all networkobjects in scene
             * let's iterate the spawned objects instead. I imagine
             * in most scenarios iterating spawned would be faster.
             * That's a long one! */
            foreach (NetworkObject nob in _networkManager.ServerManager.Objects.Spawned.Values)
            {
                //Not in the scene being destroyed.
                if (nob.gameObject.scene != scene)
                    continue;
                //ClientHost doesn't have visibility.
                if (!nob.Observers.Contains(clientConn))
                    continue;
                //Cannot move if not root.
                if (nob.transform.root != null)
                    continue;

                /* If here nob is in the same being
                 * destroyed and clientHost has visiblity. */
                movingNobs.AddValue(nob);
            }

            int count = movingNobs.Written;
            if (count > 0)
            {
                Scene moveScene = GetDelayedDestroyScene();
                List<NetworkObject> collection = movingNobs.Collection;

                for (int i = 0; i < count; i++)
                {
                    NetworkObject nob = collection[i];
                    /* Force as not a scene object
                     * so that it becomes destroyed
                     * rather than disabled. */
                    nob.ClearRuntimeSceneObject();
                    /* If the object is already being despawned then
                     *just disable and move it. Otherwise despawn it
                    * on the server then move it. */
                    //Not deinitializing, despawn it then.
                    if (!nob.IsDeinitializing)
                        nob.Despawn();
                    else
                        nob.gameObject.SetActive(false);

                    UnitySceneManager.MoveGameObjectToScene(nob.gameObject, moveScene);
                }
            }
            ListCaches.StoreCache(movingNobs);
        }

        /// <summary>
        /// Returns if a connection is in a scene using SceneConnections.
        /// </summary>
        /// <param name="conn"></param>
        /// <param name="scene"></param>
        /// <returns></returns>
        internal bool InSceneConnections(NetworkConnection conn, Scene scene)
        {
            if (!SceneConnections.TryGetValueIL2CPP(scene, out HashSet<NetworkConnection> hs))
                return false;
            else
                return hs.Contains(conn);
        }

        /// <summary>
        /// Adds the owner of nob to the gameObjects scene if there are no global scenes.
        /// </summary>
        public void AddOwnerToDefaultScene(NetworkObject nob)
        {
            //No owner.
            if (!nob.Owner.IsValid)
            {
                if (_networkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"NetworkObject {nob.name} does not have an owner.");
                return;
            }
            //Won't add to default if there are globals.
            if (_globalScenes != null && _globalScenes.Length > 0)
                return;

            AddConnectionToScene(nob.Owner, nob.gameObject.scene);
        }

        /// <summary>
        /// Adds a connection to a scene. This will always be called one connection at a time because connections are only added after they invidually validate loading the scene.
        /// </summary>
        /// <param name="sceneName"></param>
        /// <param name="conn"></param>
        private void AddConnectionToScene(NetworkConnection conn, Scene scene)
        {
            HashSet<NetworkConnection> hs;
            //Scene doesn't have any connections yet.
            bool inSceneConnections = SceneConnections.TryGetValueIL2CPP(scene, out hs);
            if (!inSceneConnections)
                hs = new HashSet<NetworkConnection>();

            bool added = hs.Add(conn);
            if (added)
            {
                conn.AddToScene(scene);

                //If not yet added to scene connections.
                if (!inSceneConnections)
                    SceneConnections[scene] = hs;

                NetworkConnection[] arrayConn = new NetworkConnection[] { conn };
                InvokeClientPresenceChange(scene, arrayConn, true, true);
                RebuildObservers(arrayConn.ToArray());
                InvokeClientPresenceChange(scene, arrayConn, true, false);

                /* Also need to rebuild all networkobjects
                * for connection so other players can
                * see them. */
                RebuildObservers(conn.Objects.ToArray());
            }
        }

        /// <summary>
        /// Removes connections from any scene which is not global.
        /// </summary>
        /// <param name="conns"></param>
        /// <param name="asd"></param>
        private void RemoveConnectionsFromNonGlobalScenes(NetworkConnection[] conns)
        {
            List<Scene> removedScenes = new List<Scene>();

            foreach (KeyValuePair<Scene, HashSet<NetworkConnection>> item in SceneConnections)
            {
                Scene scene = item.Key;
                //Cannot remove from globla scenes.
                if (IsGlobalScene(scene))
                    continue;

                HashSet<NetworkConnection> hs = item.Value;
                List<NetworkConnection> connectionsRemoved = new List<NetworkConnection>();
                //Remove every connection from the scene.
                foreach (NetworkConnection c in conns)
                {
                    bool removed = hs.Remove(c);
                    if (removed)
                    {
                        c.RemoveFromScene(scene);
                        connectionsRemoved.Add(c);
                    }
                }

                //If hashset is empty then remove scene from SceneConnections.
                if (hs.Count == 0)
                    removedScenes.Add(scene);

                if (connectionsRemoved.Count > 0)
                {
                    NetworkConnection[] connectionsRemovedArray = connectionsRemoved.ToArray();
                    InvokeClientPresenceChange(scene, connectionsRemovedArray, false, true);
                    RebuildObservers(connectionsRemovedArray);
                    InvokeClientPresenceChange(scene, connectionsRemovedArray, false, false);
                }
            }

            foreach (Scene s in removedScenes)
                SceneConnections.Remove(s);

            /* Also rebuild observers for objects owned by connection.
             * This ensures other connections will lose visibility if
             * they no longer share a scene. */
            foreach (NetworkConnection c in conns)
                RebuildObservers(c.Objects.ToArray());
        }

        /// <summary>
        /// Removes connections from specified scenes.
        /// </summary>
        /// <param name="conns"></param>
        /// <param name="asd"></param>
        private void RemoveConnectionsFromScene(NetworkConnection[] conns, Scene scene)
        {
            HashSet<NetworkConnection> hs;
            //No hashset for scene, so no connections are in scene.
            if (!SceneConnections.TryGetValueIL2CPP(scene, out hs))
                return;

            List<NetworkConnection> connectionsRemoved = new List<NetworkConnection>();
            //Remove every connection from the scene.
            foreach (NetworkConnection c in conns)
            {
                bool removed = hs.Remove(c);
                if (removed)
                {
                    c.RemoveFromScene(scene);
                    connectionsRemoved.Add(c);
                }
            }

            //If hashset is empty then remove scene from SceneConnections.
            if (hs.Count == 0)
                SceneConnections.Remove(scene);

            if (connectionsRemoved.Count > 0)
            {
                NetworkConnection[] connectionsRemovedArray = connectionsRemoved.ToArray();
                InvokeClientPresenceChange(scene, connectionsRemovedArray, false, true);
                RebuildObservers(connectionsRemovedArray);
                InvokeClientPresenceChange(scene, connectionsRemovedArray, false, false);
            }

            /* Also rebuild observers for objects owned by connection.
            * This ensures other connections will lose visibility if
            * they no longer share a scene. */
            foreach (NetworkConnection c in conns)
                RebuildObservers(c.Objects.ToArray());
        }

        /// <summary>
        /// Removes all connections from a scene.
        /// </summary>
        /// <param name="scene"></param>
        private void RemoveAllConnectionsFromScene(Scene scene)
        {
            HashSet<NetworkConnection> hs;
            //No hashset for scene, so no connections are in scene.
            if (!SceneConnections.TryGetValueIL2CPP(scene, out hs))
                return;

            //On each connection remove them from specified scene.
            foreach (NetworkConnection c in hs)
                c.RemoveFromScene(scene);
            //Make hashset into list for presence change.
            NetworkConnection[] connectionsRemoved = hs.ToArray();

            //Clear hashset and remove entry from sceneconnections.
            hs.Clear();
            SceneConnections.Remove(scene);

            if (connectionsRemoved.Length > 0)
            {
                InvokeClientPresenceChange(scene, connectionsRemoved, false, true);
                RebuildObservers(connectionsRemoved);
                InvokeClientPresenceChange(scene, connectionsRemoved, false, false);
            }

            /* Also rebuild observers for objects owned by connection.
             * This ensures other connections will lose visibility if
             * they no longer share a scene. */
            foreach (NetworkConnection c in connectionsRemoved)
                RebuildObservers(c.Objects.ToArray());
        }

        #region Can Load/Unload Scene.
        /// <summary>
        /// Returns if a scene can be loaded locally.
        /// </summary>
        /// <returns></returns>
        private bool CanLoadScene(LoadQueueData qd, SceneLookupData sld)
        {
            bool foundByHandle;
            Scene s = sld.GetScene(out foundByHandle);
            //Try to find if scene is already loaded.
            bool alreadyLoaded = !string.IsNullOrEmpty(s.name);

            if (alreadyLoaded)
            {
                //Only servers can load the same scene multiple times for stacking.
                if (!qd.AsServer)
                    return false;
                //If can only load scenes which aren't loaded yet and scene is already loaded.
                if (!qd.SceneLoadData.Options.AllowStacking)
                    return false;
                /* Found by handle, this means the user is trying to specify
                 * exactly which scene to load into. When a handle is specified
                 * new instances will not be created, so a new scene cannot
                 * be loaded. */
                if (alreadyLoaded && foundByHandle)
                    return false;
            }

            //Fall through.
            return true;
        }
        #endregion

        #region Helpers.
        /// <summary>
        /// Rebuilds observers for networkObjects.
        /// </summary>
        /// <param name="networkObjects"></param>
        private void RebuildObservers(NetworkObject[] networkObjects)
        {
            foreach (NetworkObject nob in networkObjects)
            {
                if (nob != null && nob.IsSpawned)
                    _serverManager.Objects.RebuildObservers(nob);
            }
        }
        /// <summary>
        /// Rebuilds all NetworkObjects for connection.
        /// </summary>
        internal void RebuildObservers(NetworkConnection connection)
        {
            RebuildObservers(new NetworkConnection[] { connection });
        }
        /// <summary>
        /// Rebuilds all NetworkObjects for connections.
        /// </summary>
        internal void RebuildObservers(NetworkConnection[] connections)
        {
            foreach (NetworkConnection c in connections)
                _serverManager.Objects.RebuildObservers(c);
        }
        /// <summary>
        /// Invokes OnClientPresenceChange start or end.
        /// </summary>
        /// <param name="scene"></param>
        /// <param name="conns"></param>
        /// <param name="added"></param>
        /// <param name="start"></param>
        private void InvokeClientPresenceChange(Scene scene, NetworkConnection[] conns, bool added, bool start)
        {
            foreach (NetworkConnection c in conns)
            {
                ClientPresenceChangeEventArgs cpc = new ClientPresenceChangeEventArgs(scene, c, added);
                if (start)
                    OnClientPresenceChangeStart?.Invoke(cpc);
                else
                    OnClientPresenceChangeEnd?.Invoke(cpc);
            }
        }
        #endregion

        #region GetScene.
        /// <summary>
        /// Gets scenes from SceneLookupData.
        /// </summary>
        /// <param name="datas"></param>
        /// <returns></returns>
        private Scene[] GetScenes(SceneLookupData[] datas)
        {
            List<Scene> result = new List<Scene>();
            foreach (SceneLookupData sld in datas)
            {
                Scene s = sld.GetScene(out _);
                if (!string.IsNullOrEmpty(s.name))
                    result.Add(s);
            }

            return result.ToArray();
        }

        /// <summary>
        /// Returns a scene by name.
        /// </summary>
        /// <param name="sceneName"></param>
        /// <returns></returns>
        public static Scene GetScene(string sceneName)
        {
            return UnityEngine.SceneManagement.SceneManager.GetSceneByName(sceneName);
        }
        /// <summary>
        /// Returns a scene by handle.
        /// </summary>
        /// <param name="sceneHandle"></param>
        /// <returns></returns>
        public static Scene GetScene(int sceneHandle)
        {
            int count = UnityEngine.SceneManagement.SceneManager.sceneCount;
            for (int i = 0; i < count; i++)
            {
                Scene s = UnityEngine.SceneManagement.SceneManager.GetSceneAt(i);
                if (s.handle == sceneHandle)
                    return s;
            }

            return new Scene();
        }
        #endregion

        /// <summary>
        /// Returns if GlobalScenes contains scene.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        private bool IsGlobalScene(Scene scene)
        {
            for (int i = 0; i < _globalScenes.Length; i++)
            {
                if (_globalScenes[i] == scene.name)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Removes datas from GlobalScenes.
        /// </summary>
        /// <param name="scenes"></param>
        private void RemoveFromGlobalScenes(Scene scene)
        {
            RemoveFromGlobalScenes(new SceneLookupData[] { SceneLookupData.CreateData(scene) });
        }
        /// <summary>
        /// Removes datas from GlobalScenes.
        /// </summary>
        /// <param name="scenes"></param>
        private void RemoveFromGlobalScenes(SceneLookupData[] datas)
        {
            List<string> newGlobalScenes = _globalScenes.ToList();
            int startCount = newGlobalScenes.Count;
            //Remove scenes.
            for (int i = 0; i < datas.Length; i++)
                newGlobalScenes.Remove(datas[i].Name);

            //If any were removed remake globalscenes.
            if (startCount != newGlobalScenes.Count)
                _globalScenes = newGlobalScenes.ToArray();
        }

        /// <summary>
        /// Removes GlobalScenes from scenes.
        /// </summary>
        /// <param name="scenes"></param>
        /// <returns></returns>
        private void RemoveGlobalScenes(List<Scene> scenes)
        {
            for (int i = 0; i < scenes.Count; i++)
            {
                foreach (string gs in _globalScenes)
                {
                    if (gs == scenes[i].name)
                    {
                        scenes.RemoveAt(i);
                        i--;
                    }
                }
            }
        }

        /// <summary>
        /// Removes occupied scenes from scenes.
        /// </summary>
        /// <param name="scenes"></param>
        private void RemoveOccupiedScenes(List<Scene> scenes)
        {
            for (int i = 0; i < scenes.Count; i++)
            {
                if (SceneConnections.TryGetValueIL2CPP(scenes[i], out _))
                {
                    scenes.RemoveAt(i);
                    i--;
                }
            }
        }

        /// <summary>
        /// Adds a pending load for a connection.
        /// </summary>
        private void AddPendingLoad(NetworkConnection conn)
        {
            AddPendingLoad(new NetworkConnection[] { conn });
        }
        /// <summary>
        /// Adds a pending load for a connection.
        /// </summary>
        private void AddPendingLoad(NetworkConnection[] conns)
        {
            foreach (NetworkConnection c in conns)
            {
                /* Make sure connection is active. This should always be true
                 * but perhaps disconnect happened as scene was loading on server
                * therefor it cannot be sent to the client. 
                * Also only authenticated clients can load scenes. */
                if (!c.IsActive || !c.Authenticated)
                    continue;

                if (_pendingClientSceneChanges.TryGetValue(c, out int result))
                    _pendingClientSceneChanges[c] = (result + 1);
                else
                    _pendingClientSceneChanges[c] = 1;
            }
        }
        /// <summary>
        /// Sets the first global scene as the active scene.
        /// If a global scene is not available then FallbackActiveScene is used.
        /// </summary>
        private void SetActiveScene()
        {
            if (!_setActiveScene)
                return;

            Scene s = default;
            if (_globalScenes != null && _globalScenes.Length > 0)
                s = GetScene(_globalScenes[0]);

            /* If scene isn't set from global then make
             * sure currently active isn't the movedobjectscene.
             * If it is, then use the fallback scene. */
            if (string.IsNullOrEmpty(s.name) && UnitySceneManager.GetActiveScene() == _movedObjectsScene)
                s = GetFallbackActiveScene();

            //If was changed then update active scene.
            if (!string.IsNullOrEmpty(s.name))
                UnitySceneManager.SetActiveScene(s);

            OnActiveSceneSet?.Invoke();
            OnActiveSceneSetInternal?.Invoke();

            //Also update light probes.
            if (_lightProbeUpdating == LightProbeUpdateType.Asynchronous)
                LightProbes.TetrahedralizeAsync();
            else if (_lightProbeUpdating == LightProbeUpdateType.BlockThread)
                LightProbes.Tetrahedralize();
        }

        /// <summary>
        /// Returns the FallbackActiveScene.
        /// </summary>
        /// <returns></returns>
        private Scene GetFallbackActiveScene()
        {
            if (string.IsNullOrEmpty(_fallbackActiveScene.name))
                _fallbackActiveScene = UnitySceneManager.CreateScene("FallbackActiveScene");

            return _fallbackActiveScene;
        }

        /// <summary>
        /// Returns the MovedObejctsScene.
        /// </summary>
        /// <returns></returns>
        private Scene GetMovedObjectsScene()
        {
            //Create moved objects scene. It will probably be used eventually. If not, no harm either way.
            if (string.IsNullOrEmpty(_movedObjectsScene.name))
                _movedObjectsScene = UnitySceneManager.CreateScene("MovedObjectsHolder");

            return _movedObjectsScene;
        }

        /// <summary>
        /// Returns the DelayedDestroyScene.
        /// </summary>
        /// <returns></returns>
        private Scene GetDelayedDestroyScene()
        {
            //Create moved objects scene. It will probably be used eventually. If not, no harm either way.
            if (string.IsNullOrEmpty(_delayedDestroyScene.name))
                _delayedDestroyScene = UnityEngine.SceneManagement.SceneManager.CreateScene("DelayedDestroy");

            return _delayedDestroyScene;
        }

        #region Sanity checks.
        /// <summary>
        /// Returns if a SceneLoadData is valid.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="error"></param>
        /// <returns></returns>
        private bool SceneDataInvalid(SceneLoadData data, bool error)
        {
            bool result = data.DataInvalid();

            if (result && error)
            {
                if (_networkManager.CanLog(LoggingType.Error))
                    Debug.LogError(INVALID_SCENELOADDATA);
            }

            return result;
        }
        /// <summary>
        /// Returns if a SceneLoadData is valid.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="error"></param>
        /// <returns></returns>
        private bool SceneDataInvalid(SceneUnloadData data, bool error)
        {
            bool result = data.DataInvalid();
            if (result && error)
            {
                if (_networkManager.CanLog(LoggingType.Error))
                    Debug.LogError(INVALID_SCENEUNLOADDATA);
            }

            return result;
        }
        /// <summary>
        /// Returns if connection is active for server or client in association with AsServer.
        /// </summary>
        /// <param name="asServer"></param>
        /// <returns></returns>
        private bool ConnectionActive(bool asServer)
        {
            return (asServer) ? _networkManager.IsServer : _networkManager.IsClient;
        }
        /// <summary>
        /// Returns if a method can execute.
        /// </summary>
        /// <param name="asServer"></param>
        /// <param name="warn"></param>
        /// <returns></returns>
        private bool CanExecute(bool asServer, bool warn)
        {
            bool result;
            if (asServer)
            {
                result = _networkManager.IsServer;
                if (!result && warn)
                {
                    if (_networkManager.CanLog(LoggingType.Warning))
                        Debug.LogWarning($"Method cannot be called as the server is not active.");
                }
            }
            else
            {
                result = _networkManager.IsClient;
                if (!result && warn)
                {
                    if (_networkManager.CanLog(LoggingType.Warning))
                        Debug.LogWarning($"Method cannot be called as the client is not active.");
                }
            }

            return result;
        }
        #endregion

    }
}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/SceneProcessorBase.cs ---
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityScene = UnityEngine.SceneManagement.Scene;

namespace FishNet.Managing.Scened
{

    public abstract class SceneProcessorBase : MonoBehaviour
    {
        #region Protected.
        /// <summary>
        /// SceneManager for this processor.
        /// </summary>
        protected SceneManager SceneManager;
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager">SceneManager which will be utilizing this class.</param>
        public virtual void Initialize(SceneManager manager)
        {
            SceneManager = manager;
        }
        /// <summary>
        /// Called when scene loading has begun.
        /// </summary>
        public virtual void LoadStart(LoadQueueData queueData) { }
        /// <summary>
        /// Called when scene loading has ended.
        /// </summary>
        public virtual void LoadEnd(LoadQueueData queueData) { }
        /// <summary>
        /// Called when scene unloading has begun within a load operation.
        /// </summary>
        public virtual void UnloadStart(LoadQueueData queueData) { }
        /// <summary>
        /// Called when scene unloading has ended within a load operation.
        /// </summary>
        public virtual void UnloadEnd(LoadQueueData queueData) { }
        /// <summary>
        /// Called when scene unloading has begun within an unload operation.
        /// </summary>
        public virtual void UnloadStart(UnloadQueueData queueData) { }
        /// <summary>
        /// Called when scene unloading has ended within an unload operation.
        /// </summary>
        public virtual void UnloadEnd(UnloadQueueData queueData) { }
        /// <summary>
        /// Begin loading a scene using an async method.
        /// </summary>
        /// <param name="sceneName">Scene name to load.</param>
        public abstract void BeginLoadAsync(string sceneName, LoadSceneParameters parameters);
        /// <summary>
        /// Begin unloading a scene using an async method.
        /// </summary>
        /// <param name="sceneName">Scene name to unload.</param>
        public abstract void BeginUnloadAsync(Scene scene);
        /// <summary>
        /// Returns if a scene load or unload percent is done.
        /// </summary>
        /// <returns></returns>
        public abstract bool IsPercentComplete();
        /// <summary>
        /// Returns the progress on the current scene load or unload.
        /// </summary>
        /// <returns></returns>
        public abstract float GetPercentComplete();
        /// <summary>
        /// Adds a scene to loaded scenes.
        /// </summary>
        /// <param name="scene">Scene loaded.</param>
        public virtual void AddLoadedScene(Scene scene) { }
        /// <summary>
        /// Returns scenes which were loaded during a load operation.
        /// </summary>
        public abstract List<Scene> GetLoadedScenes();
        /// <summary>
        /// Activates scenes which were loaded.
        /// </summary>
        public abstract void ActivateLoadedScenes();
        /// <summary>
        /// Returns if all asynchronized tasks are considered IsDone.
        /// </summary>
        /// <returns></returns>
        public abstract IEnumerator AsyncsIsDone();

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Scened/SceneSpawner.cs ---
﻿
//using FishNet.Managing.Scened.Data;
//using System;
//using UnityEngine;
//using UnityEngine.SceneManagement;

//namespace FishNet.Managing.Scened
//{

//    public static class SceneSpawner
//    {

//        #region Prefab.
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(Scene scene, GameObject prefab)
//        {
//            return Instantiate<GameObject>(scene, prefab);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(Scene scene, GameObject prefab)
//        {
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(SceneReferenceData sceneReferenceData, GameObject prefab)
//        {
//            return Instantiate<GameObject>(sceneReferenceData, prefab);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(SceneReferenceData sceneReferenceData, GameObject prefab)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneReferenceData);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(int sceneHandle, GameObject prefab)
//        {
//            return Instantiate<GameObject>(sceneHandle, prefab, prefab.transform.position, prefab.transform.rotation, null);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(int sceneHandle, GameObject prefab)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneHandle);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(string sceneName, GameObject prefab)
//        {
//            return Instantiate<GameObject>(sceneName, prefab);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(string sceneName, GameObject prefab)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneName);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, null, true);
//        }
//        #endregion

//        #region Prefab, Parent, WorldSpace
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(Scene scene, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<GameObject>(scene, prefab, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(Scene scene, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(SceneReferenceData sceneReferenceData, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<GameObject>(sceneReferenceData, prefab, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(SceneReferenceData sceneReferenceData, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneReferenceData);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(int sceneHandle, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<GameObject>(sceneHandle, prefab, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(int sceneHandle, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneHandle);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(string sceneName, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<GameObject>(sceneName, prefab, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(string sceneName, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneName);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, parent, instantiateInWorldSpace);
//        }
//        #endregion

//        #region Prefab, Position, Rotation.
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<GameObject>(scene, prefab, position, rotation);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<T>(scene, prefab, position, rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(SceneReferenceData sceneReferenceData, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<GameObject>(sceneReferenceData, prefab, position, rotation);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(SceneReferenceData sceneReferenceData, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneReferenceData);
//            return Instantiate<T>(scene, prefab, position, rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(int sceneHandle, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<GameObject>(sceneHandle, prefab, position, rotation);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(int sceneHandle, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneHandle);
//            return Instantiate<T>(scene, prefab, position, rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(string sceneName, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<GameObject>(sceneName, prefab, position, rotation);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(string sceneName, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneName);
//            return Instantiate<T>(scene, prefab, position, rotation, null, true);
//        }
//        #endregion

//        #region Prefab, Position, Rotation, Parent.
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns> 
//        public static GameObject Instantiate(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<GameObject>(scene, prefab, position, rotation, parent);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<T>(scene, prefab, position, rotation, parent, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(SceneReferenceData sceneReferenceData, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<GameObject>(sceneReferenceData, prefab, position, rotation, parent);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(SceneReferenceData sceneReferenceData, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneReferenceData);
//            return Instantiate<T>(scene, prefab, position, rotation, parent, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(int sceneHandle, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<GameObject>(sceneHandle, prefab, position, rotation, parent);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(int sceneHandle, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneHandle);
//            return Instantiate<T>(scene, prefab, position, rotation, parent, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(string sceneName, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<GameObject>(sceneName, prefab, position, rotation, parent);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(string sceneName, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneName);
//            return Instantiate<T>(scene, prefab, position, rotation, parent, true);
//        }
//        #endregion

//        #region Instantiator.
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        private static T Instantiate<T>(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent, bool instantiateInWorldSpace)
//        {
//            if (string.IsNullOrEmpty(scene.name))
//            {
//                Debug.LogWarning("Scene does not exist. Prefab cannot be instantiated.");
//                return default(T);
//            }

//            GameObject result = MonoBehaviour.Instantiate(prefab, position, rotation);
//            if (result != null)
//            {
//                //Move to new scene first.
//                UnityEngine.SceneManagement.SceneManager.MoveGameObjectToScene(result, scene);

//                //Set parent and spaces.
//                if (parent != null)
//                {
//                    result.transform.SetParent(parent);
//                    //If to not instantiate in world space then update pos/rot to localspace.
//                    if (!instantiateInWorldSpace)
//                    {
//                        result.transform.localPosition = position;
//                        result.transform.localRotation = rotation;
//                    }
//                }

//                //If was a gameobject then return as GO.
//                if (typeof(T) == typeof(GameObject))
//                    return (T)Convert.ChangeType(result, typeof(GameObject));
//                //Otherwise use getcomponent on the type.
//                else
//                    return result.GetComponent<T>();
//            }
//            //Couldn't be instantiated, return default of T.
//            else
//            {
//                return default(T);
//            }

//        }
//        #endregion

//    }

//}
'''
'''--- Assets/FishNet/Runtime/Managing/Server/ClientConnectionBroadcast.cs ---
﻿
using FishNet.Broadcast;
using FishNet.Utility.Performance;
using System.Collections.Generic;

namespace FishNet.Managing.Server
{

    public struct ClientConnectionChangeBroadcast : IBroadcast
    {
        public bool Connected;
        public int Id;
    }

    public struct ConnectedClientsBroadcast : IBroadcast
    {
        public ListCache<int> ListCache;
        public List<int> Ids;
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Server/Editor/ServerManagerEditor.cs ---
﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Server.Editing
{

    [CustomEditor(typeof(ServerManager), true)]
    [CanEditMultipleObjects]
    public class ServerManagerEditor : Editor
    {
        private SerializedProperty _authenticator;
        private SerializedProperty _spawnPacking;
        private SerializedProperty _changeFrameRate;
        private SerializedProperty _frameRate;
        private SerializedProperty _shareIds;
        private SerializedProperty _startOnHeadless;
        private SerializedProperty _limitClientMTU;

        protected virtual void OnEnable()
        {
            _authenticator = serializedObject.FindProperty("_authenticator");
            _spawnPacking = serializedObject.FindProperty("SpawnPacking");
            _changeFrameRate = serializedObject.FindProperty("_changeFrameRate");
            _frameRate = serializedObject.FindProperty("_frameRate");
            _shareIds = serializedObject.FindProperty("_shareIds");
            _startOnHeadless = serializedObject.FindProperty("_startOnHeadless");
            _limitClientMTU = serializedObject.FindProperty("_limitClientMTU");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((ServerManager)target), typeof(ServerManager), false);
            GUI.enabled = true;

            EditorGUILayout.PropertyField(_authenticator);
            EditorGUILayout.PropertyField(_spawnPacking);
            EditorGUILayout.PropertyField(_changeFrameRate);
            if (_changeFrameRate.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_frameRate);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.PropertyField(_shareIds);
            EditorGUILayout.PropertyField(_startOnHeadless);
            EditorGUILayout.PropertyField(_limitClientMTU);

            EditorGUILayout.Space();

            serializedObject.ApplyModifiedProperties();
        }

    }
}
#endif
'''
'''--- Assets/FishNet/Runtime/Managing/Server/Object/ServerObjects.Observers.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Object;
using FishNet.Managing.Transporting;
using FishNet.Object;
using FishNet.Observing;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Performance;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Server
{
    public partial class ServerObjects : ManagedObjects
    {
        #region Private.
        /// <summary>
        /// Cache filled with objects which observers are being updated.
        /// This is primarily used to invoke events after all observers are updated, rather than as each is updated.
        /// </summary>
        private List<NetworkObject> _observerChangedObjectsCache = new List<NetworkObject>(100);
        /// <summary>
        /// NetworkObservers which require regularly iteration.
        /// </summary>
        private List<NetworkObject> _timedNetworkObservers = new List<NetworkObject>();
        /// <summary>
        /// Index in TimedNetworkObservers to start on next cycle.
        /// </summary>
        private int _nextTimedObserversIndex;
        #endregion

        /// <summary>
        /// Called when MonoBehaviours call Update.
        /// </summary>
        private void Observers_OnUpdate()
        {
            UpdateTimedObservers();
        }

        /// <summary>
        /// Progressively updates NetworkObservers with timed conditions.
        /// </summary>
        private void UpdateTimedObservers()
        {
            if (!base.NetworkManager.IsServer)
                return;
            //No point in updating if the timemanager isn't going to tick this frame.
            if (!base.NetworkManager.TimeManager.FrameTicked)
                return;
            int observersCount = _timedNetworkObservers.Count;
            if (observersCount == 0)
                return;

            ServerManager serverManager = base.NetworkManager.ServerManager;
            TransportManager transportManager = NetworkManager.TransportManager;
            /* Try to iterate all timed observers every half a second.
             * This value will increase as there's more observers. */
            int completionTicks = Mathf.Max(1, (base.NetworkManager.TimeManager.TickRate * 2));
            /* Multiply required ticks based on connection count and nob count. This will
             * reduce how quickly observers update slightly but will drastically
             * improve performance. */
            float tickMultiplier = 1f + (float)(
                (serverManager.Clients.Count * 0.005f) +
                (serverManager.Objects.Spawned.Count * 0.0005f)
                );
            /* Add an additional iteration to prevent
             * 0 iterations */
            int iterations = (observersCount / (int)(completionTicks * tickMultiplier)) + 1;
            if (iterations > observersCount)
                iterations = observersCount;

            PooledWriter everyoneWriter = WriterPool.GetWriter();
            PooledWriter ownerWriter = WriterPool.GetWriter();

            //Index to perform a check on.
            int observerIndex = 0;
            foreach (NetworkConnection conn in serverManager.Clients.Values)
            {
                int cacheIndex = 0;
                using (PooledWriter largeWriter = WriterPool.GetWriter())
                {
                    //Reset index to start on for every connection.
                    observerIndex = 0;
                    /* Run the number of calculated iterations.
                     * This is spaced out over frames to prevent
                     * fps spikes. */
                    for (int i = 0; i < iterations; i++)
                    {
                        observerIndex = _nextTimedObserversIndex + i;
                        /* Compare actual collection size not cached value.
                         * This is incase collection is modified during runtime. */
                        if (observerIndex >= _timedNetworkObservers.Count)
                            observerIndex -= _timedNetworkObservers.Count;

                        /* If still out of bounds something whack is going on.
                        * Reset index and exit method. Let it sort itself out
                        * next iteration. */
                        if (observerIndex < 0 || observerIndex >= _timedNetworkObservers.Count)
                        {
                            _nextTimedObserversIndex = 0;
                            break;
                        }

                        NetworkObject nob = _timedNetworkObservers[observerIndex];
                        ObserverStateChange osc = nob.RebuildObservers(conn, true);
                        if (osc == ObserverStateChange.Added)
                        {
                            everyoneWriter.Reset();
                            ownerWriter.Reset();
                            WriteSpawn(nob, conn, ref everyoneWriter, ref ownerWriter);
                            CacheObserverChange(nob, ref cacheIndex);
                        }
                        else if (osc == ObserverStateChange.Removed)
                        {
                            everyoneWriter.Reset();
                            WriteDespawn(nob, nob.GetDefaultDespawnType(), ref everyoneWriter);

                        }
                        else
                        {
                            continue;
                        }
                        /* Only use ownerWriter if an add, and if owner. Owner
                         * doesn't matter if not being added because no owner specific
                         * information would be included. */
                        PooledWriter writerToUse = (osc == ObserverStateChange.Added && nob.Owner == conn) ?
                            ownerWriter : everyoneWriter;

                        largeWriter.WriteArraySegment(writerToUse.GetArraySegment());
                    }

                    if (largeWriter.Length > 0)
                    {
                        transportManager.SendToClient(
                            (byte)Channel.Reliable,
                            largeWriter.GetArraySegment(), conn);
                    }

                    //Invoke spawn callbacks on nobs.
                    for (int i = 0; i < cacheIndex; i++)
                        _observerChangedObjectsCache[i].InvokePostOnServerStart(conn);
                }
            }

            everyoneWriter.Dispose();
            ownerWriter.Dispose();
            _nextTimedObserversIndex = (observerIndex + 1);
        }

        /// <summary>
        /// Indicates that a networkObserver component should be updated regularly. This is done automatically.
        /// </summary>
        /// <param name="networkObject">NetworkObject to be updated.</param>
        public void AddTimedNetworkObserver(NetworkObject networkObject)
        {
            _timedNetworkObservers.Add(networkObject);
        }

        /// <summary>
        /// Indicates that a networkObserver component no longer needs to be updated regularly. This is done automatically.
        /// </summary>
        /// <param name="networkObject">NetworkObject to be updated.</param>
        public void RemoveTimedNetworkObserver(NetworkObject networkObject)
        {
            _timedNetworkObservers.Remove(networkObject);
        }

        /// <summary>
        /// Caches an observer change.
        /// </summary>
        /// <param name="cacheIndex"></param>
        private void CacheObserverChange(NetworkObject nob, ref int cacheIndex)
        {
            /* If this spawn would exceed cache size then
            * add instead of set value. */
            if (_observerChangedObjectsCache.Count <= cacheIndex)
                _observerChangedObjectsCache.Add(nob);
            else
                _observerChangedObjectsCache[cacheIndex] = nob;

            cacheIndex++;
        }

        /// <summary>
        /// Removes a connection from observers without synchronizing changes.
        /// </summary>
        /// <param name="connection"></param>
        private void RemoveFromObserversWithoutSynchronization(NetworkConnection connection)
        {
            int cacheIndex = 0;

            foreach (NetworkObject nob in Spawned.Values)
            {
                if (nob.RemoveObserver(connection))
                    CacheObserverChange(nob, ref cacheIndex);
            }

            //Invoke despawn callbacks on nobs.
            for (int i = 0; i < cacheIndex; i++)
                _observerChangedObjectsCache[i].InvokeOnServerDespawn(connection);
        }

        /// <summary>
        /// Rebuilds observers on all NetworkObjects for all connections.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers()
        {
            ListCache<NetworkObject> nobCache = GetOrderedSpawnedObjects();
            ListCache<NetworkConnection> connCache = ListCaches.GetNetworkConnectionCache();
            foreach (NetworkConnection conn in base.NetworkManager.ServerManager.Clients.Values)
                connCache.AddValue(conn);

            RebuildObservers(nobCache, connCache);
            ListCaches.StoreCache(nobCache);
            ListCaches.StoreCache(connCache);
        }

        /// <summary>
        /// Rebuilds observers on NetworkObjects.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(NetworkObject[] nobs)
        {
            int count = nobs.Length;
            for (int i = 0; i < count; i++)
                RebuildObservers(nobs[i]);
        }

        /// <summary>
        /// Rebuilds observers on NetworkObjects.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(List<NetworkObject> nobs)
        {
            int count = nobs.Count;
            for (int i = 0; i < count; i++)
                RebuildObservers(nobs[i]);
        }

        /// <summary>
        /// Rebuilds observers on NetworkObjects.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(ListCache<NetworkObject> nobs)
        {
            int count = nobs.Written;
            List<NetworkObject> collection = nobs.Collection;
            for (int i = 0; i < count; i++)
                RebuildObservers(collection[i]);
        }
        /// <summary>
        /// Rebuilds observers on NetworkObjects for connections.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(ListCache<NetworkObject> nobs, NetworkConnection conn)
        {
            RebuildObservers(nobs.Collection, conn, nobs.Written);
        }
        /// <summary>
        /// Rebuilds observers on NetworkObjects for connections.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(ListCache<NetworkObject> nobs, ListCache<NetworkConnection> conns)
        {
            int count = nobs.Written;
            List<NetworkObject> collection = nobs.Collection;
            for (int i = 0; i < count; i++)
                RebuildObservers(collection[i], conns);
        }
        /// <summary>
        /// Rebuilds observers on all objects for a connections.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(ListCache<NetworkConnection> connections)
        {
            int count = connections.Written;
            List<NetworkConnection> collection = connections.Collection;
            for (int i = 0; i < count; i++)
                RebuildObservers(collection[i]);
        }
        /// <summary>
        /// Rebuilds observers on all objects for connections.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(NetworkConnection[] connections)
        {
            int count = connections.Length;
            for (int i = 0; i < count; i++)
                RebuildObservers(connections[i]);
        }
        /// <summary>
        /// Rebuilds observers on all objects for connections.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(List<NetworkConnection> connections)
        {
            int count = connections.Count;
            for (int i = 0; i < count; i++)
                RebuildObservers(connections[i]);
        }

        /// <summary>
        /// Rebuilds observers on all NetworkObjects for a connection.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(NetworkConnection connection)
        {
            ListCache<NetworkObject> cache = GetOrderedSpawnedObjects();
            RebuildObservers(cache, connection);
            ListCaches.StoreCache(cache);
        }

        /// <summary>
        /// Gets all spawned objects with root objects first.
        /// </summary>
        /// <returns></returns>
        private ListCache<NetworkObject> GetOrderedSpawnedObjects()
        {
            ListCache<NetworkObject> cache = ListCaches.GetNetworkObjectCache();
            foreach (NetworkObject networkObject in Spawned.Values)
            {
                if (networkObject.IsNested)
                    continue;

                //Add nob and children recursively.
                AddChildNetworkObjects(networkObject);
            }

            void AddChildNetworkObjects(NetworkObject n)
            {
                cache.AddValue(n);
                foreach (NetworkObject nob in n.ChildNetworkObjects)
                    AddChildNetworkObjects(nob);
            }

            return cache;
        }

        /// <summary>
        /// Rebuilds observers for a connection on NetworkObjects.
        /// </summary>               
        /// <param name="nobs">NetworkObjects to rebuild.</param>
        /// <param name="connection">Connection to rebuild for.</param>
        /// <param name="count">Number of iterations to perform collection. Entire collection is iterated when value is -1.</param>
        public void RebuildObservers(IEnumerable<NetworkObject> nobs, NetworkConnection connection, int count = -1)
        {
            PooledWriter everyoneWriter = WriterPool.GetWriter();
            PooledWriter ownerWriter = WriterPool.GetWriter();

            //If there's no limit on how many can be written set count to the maximum.
            if (count == -1)
                count = int.MaxValue;

            int iterations;
            int observerCacheIndex;
            using (PooledWriter largeWriter = WriterPool.GetWriter())
            {
                iterations = 0;
                observerCacheIndex = 0;
                foreach (NetworkObject n in nobs)
                {
                    iterations++;
                    if (iterations > count)
                        break;

                    //If observer state changed then write changes.
                    ObserverStateChange osc = n.RebuildObservers(connection, false);
                    if (osc == ObserverStateChange.Added)
                    {
                        everyoneWriter.Reset();
                        ownerWriter.Reset();
                        WriteSpawn(n, connection, ref everyoneWriter, ref ownerWriter);
                        CacheObserverChange(n, ref observerCacheIndex);
                    }
                    else if (osc == ObserverStateChange.Removed)
                    {
                        everyoneWriter.Reset();
                        WriteDespawn(n, n.GetDefaultDespawnType(), ref everyoneWriter);
                    }
                    else
                    {
                        continue;
                    }
                    /* Only use ownerWriter if an add, and if owner. Owner //cleanup see if rebuild timed and this can be joined or reuse methods.
                     * doesn't matter if not being added because no owner specific
                     * information would be included. */
                    PooledWriter writerToUse = (osc == ObserverStateChange.Added && n.Owner == connection) ?
                        ownerWriter : everyoneWriter;

                    largeWriter.WriteArraySegment(writerToUse.GetArraySegment());
                }

                if (largeWriter.Length > 0)
                {
                    NetworkManager.TransportManager.SendToClient(
                        (byte)Channel.Reliable,
                        largeWriter.GetArraySegment(), connection);
                }
            }

            //Dispose of writers created in this method.
            everyoneWriter.Dispose();
            ownerWriter.Dispose();

            //Invoke spawn callbacks on nobs.
            for (int i = 0; i < observerCacheIndex; i++)
                _observerChangedObjectsCache[i].InvokePostOnServerStart(connection);
        }

        /// <summary>
        /// Rebuilds observers for connections on a NetworkObject.
        /// </summary>
        private void RebuildObservers(NetworkObject nob, ListCache<NetworkConnection> conns)
        {
            PooledWriter everyoneWriter = WriterPool.GetWriter();
            PooledWriter ownerWriter = WriterPool.GetWriter();

            int written = conns.Written;
            for (int i = 0; i < written; i++)
            {
                NetworkConnection conn = conns.Collection[i];

                everyoneWriter.Reset();
                ownerWriter.Reset();
                //If observer state changed then write changes.
                ObserverStateChange osc = nob.RebuildObservers(conn, false);
                if (osc == ObserverStateChange.Added)
                    WriteSpawn(nob, conn, ref everyoneWriter, ref ownerWriter);
                else if (osc == ObserverStateChange.Removed)
                    WriteDespawn(nob, nob.GetDefaultDespawnType(), ref everyoneWriter);
                else
                    continue;

                /* Only use ownerWriter if an add, and if owner. Owner
                 * doesn't matter if not being added because no owner specific
                 * information would be included. */
                PooledWriter writerToUse = (osc == ObserverStateChange.Added && nob.Owner == conn) ?
                    ownerWriter : everyoneWriter;

                if (writerToUse.Length > 0)
                {
                    NetworkManager.TransportManager.SendToClient(
                        (byte)Channel.Reliable,
                        writerToUse.GetArraySegment(), conn);

                    //If a spawn is being sent.
                    if (osc == ObserverStateChange.Added)
                        nob.InvokePostOnServerStart(conn);
                }

            }

            //Dispose of writers created in this method.
            everyoneWriter.Dispose();
            ownerWriter.Dispose();
        }

        /// <summary>
        /// Rebuilds observers for all connections for a NetworkObject.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void RebuildObservers(NetworkObject nob)
        {
            ListCache<NetworkConnection> cache = ListCaches.GetNetworkConnectionCache();
            foreach (NetworkConnection item in NetworkManager.ServerManager.Clients.Values)
                cache.AddValue(item);

            RebuildObservers(nob, cache);
            ListCaches.StoreCache(cache);
        }
        /// <summary>
        /// Rebuilds observers for a connection on NetworkObject.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void RebuildObservers(NetworkObject nob, NetworkConnection conn)
        {
            ListCache<NetworkConnection> cache = ListCaches.GetNetworkConnectionCache();
            cache.AddValue(conn);

            RebuildObservers(nob, cache);
            ListCaches.StoreCache(cache);
        }
        /// <summary>
        /// Rebuilds observers for connections on NetworkObject.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(NetworkObject networkObject, NetworkConnection[] connections)
        {
            ListCache<NetworkConnection> cache = ListCaches.GetNetworkConnectionCache();
            cache.AddValues(connections);
            RebuildObservers(networkObject, cache);
            ListCaches.StoreCache(cache);
        }

        /// <summary>
        /// Rebuilds observers for connections on NetworkObject.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RebuildObservers(NetworkObject networkObject, List<NetworkConnection> connections)
        {
            ListCache<NetworkConnection> cache = ListCaches.GetNetworkConnectionCache();
            cache.AddValues(connections);
            RebuildObservers(networkObject, cache);
            ListCaches.StoreCache(cache);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Server/Object/ServerObjects.Parsing.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Object;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using System.Runtime.CompilerServices;

namespace FishNet.Managing.Server
{
    public partial class ServerObjects : ManagedObjects
    {

        /// <summary>
        /// Parses a ReplicateRpc.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ParseReplicateRpc(PooledReader reader, NetworkConnection conn, Channel channel)
        {
            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.ServerRpc, reader, channel);

            if (nb != null)
                nb.OnReplicateRpc(null, reader, conn, channel);
            else
                SkipDataLength((ushort)PacketId.ServerRpc, reader, dataLength);
        }

        /// <summary>
        /// Parses a ServerRpc.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ParseServerRpc(PooledReader reader, NetworkConnection conn, Channel channel)
        {
            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.ServerRpc, reader, channel);

            if (nb != null)
                nb.OnServerRpc(reader, conn, channel);
            else
                SkipDataLength((ushort)PacketId.ServerRpc, reader, dataLength);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Server/Object/ServerObjects.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Object;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Server
{
    /// <summary>
    /// Handles objects and information about objects for the server. See ManagedObjects for inherited options.
    /// </summary>
    public partial class ServerObjects : ManagedObjects
    {
        #region Public.
        /// <summary>
        /// Called right before client objects are destroyed when a client disconnects.
        /// </summary>
        public event Action<NetworkConnection> OnPreDestroyClientObjects;
        #endregion

        #region Private.
        /// <summary>
        /// Cached ObjectIds which may be used when exceeding available ObjectIds.
        /// </summary>
        private Queue<int> _objectIdCache = new Queue<int>();
        /// <summary>
        /// NetworkBehaviours which have dirty SyncVars.
        /// </summary>
        private List<NetworkBehaviour> _dirtySyncVarBehaviours = new List<NetworkBehaviour>(20);
        /// <summary>
        /// NetworkBehaviours which have dirty SyncObjects.
        /// </summary>
        private List<NetworkBehaviour> _dirtySyncObjectBehaviours = new List<NetworkBehaviour>(20);
        /// <summary>
        /// Objects which need to be destroyed next tick.
        /// This is needed when running as host so host client will get any final messages for the object before they're destroyed.
        /// </summary>
        private Dictionary<int, NetworkObject> _pendingDestroy = new Dictionary<int, NetworkObject>();
        /// <summary>
        /// Scenes which were loaded that need to be setup.
        /// </summary>
        private List<(int, Scene)> _loadedScenes = new List<(int frame, Scene scene)>();
        /// <summary>
        /// Cache of spawning objects, used for recursively spawning nested NetworkObjects.
        /// </summary>
        private ListCache<NetworkObject> _spawnCache = new ListCache<NetworkObject>();
        /// <summary>
        /// True if one or more scenes are currently loading through the SceneManager.
        /// </summary>
        private bool _scenesLoading;
        #endregion

        internal ServerObjects(NetworkManager networkManager)
        {
            base.NetworkManager = networkManager;
            networkManager.SceneManager.OnLoadStart += SceneManager_OnLoadStart;
            networkManager.SceneManager.OnActiveSceneSetInternal += SceneManager_OnActiveSceneSet;
            networkManager.TimeManager.OnUpdate += TimeManager_OnUpdate;
        }

        /// <summary>
        /// Called when MonoBehaviours call Update.
        /// </summary>
        private void TimeManager_OnUpdate()
        {
            if (!base.NetworkManager.IsServer)
            {
                _scenesLoading = false;
                _loadedScenes.Clear();
                return;
            }

            if (!_scenesLoading)
                IterateLoadedScenes(false);
            Observers_OnUpdate();
        }

        #region Checking dirty SyncTypes.
        /// <summary>
        /// Iterates NetworkBehaviours with dirty SyncTypes.
        /// </summary>
        internal void WriteDirtySyncTypes()
        {
            /* Tells networkbehaviours to check their
             * dirty synctypes. */
            IterateCollection(_dirtySyncVarBehaviours, false);
            IterateCollection(_dirtySyncObjectBehaviours, true);

            void IterateCollection(List<NetworkBehaviour> collection, bool isSyncObject)
            {
                for (int i = 0; i < collection.Count; i++)
                {
                    bool dirtyCleared = collection[i].WriteDirtySyncTypes(isSyncObject);
                    if (dirtyCleared)
                    {
                        collection.RemoveAt(i);
                        i--;
                    }
                }
            }
        }
        /// <summary>
        /// Sets that a NetworkBehaviour has a dirty syncVars.
        /// </summary>
        /// <param name="nb"></param>
        internal void SetDirtySyncType(NetworkBehaviour nb, bool isSyncObject)
        {
            if (isSyncObject)
                _dirtySyncObjectBehaviours.Add(nb);
            else
                _dirtySyncVarBehaviours.Add(nb);
        }
        #endregion

        #region Connection Handling.
        /// <summary>
        /// Called when the connection state changes for the local server.
        /// </summary>
        /// <param name="args"></param>
        internal void OnServerConnectionState(ServerConnectionStateArgs args)
        {

            //If server just connected.
            if (args.ConnectionState == LocalConnectionState.Started)
            {
                /* If there's no servers started besides the one
                 * that just started then build Ids and setup scene objects. */
                if (base.NetworkManager.ServerManager.OneServerStarted())
                {
                    BuildObjectIdCache();
                    SetupSceneObjects();
                }
            }
            //Server in anything but started state.
            else
            {
                //If no servers are started then reset.
                if (!base.NetworkManager.ServerManager.AnyServerStarted())
                {
                    base.DespawnSpawnedWithoutSynchronization(true);
                    base.SceneObjects.Clear();
                    _objectIdCache.Clear();
                    base.NetworkManager.ServerManager.Clients.Clear();
                }
            }
        }

        /// <summary>
        /// Called when a client disconnects.
        /// </summary>
        /// <param name="connection"></param>
        internal void ClientDisconnected(NetworkConnection connection)
        {
            RemoveFromObserversWithoutSynchronization(connection);

            OnPreDestroyClientObjects?.Invoke(connection);

            /* A cache is made because the Objects
             * collection would end up modified during
             * iteration from removing ownership and despawning. */
            ListCache<NetworkObject> cache = ListCaches.GetNetworkObjectCache();
            foreach (NetworkObject nob in connection.Objects)
                cache.AddValue(nob);

            int written = cache.Written;
            List<NetworkObject> collection = cache.Collection;
            for (int i = 0; i < written; i++)
            {
                /* Objects may already be deinitializing when a client disconnects
                 * because the root object could have been despawned first, and in result
                 * all child objects would have been recursively despawned. 
                 * 
                 * EG: object is:
                 *      A (nob)
                 *          B (nob)
                 * 
                 * Both A and B are owned by the client so they will both be
                 * in collection. Should A despawn first B will recursively despawn
                 * from it. Then once that finishes and the next index of collection
                 * is run, which would B, the object B would have already been deinitialized. */
                if (!collection[i].IsDeinitializing)
                    base.NetworkManager.ServerManager.Despawn(collection[i]);
            }

            ListCaches.StoreCache(cache);
        }
        #endregion

        #region ObjectIds.
        /// <summary>
        /// Builds the ObjectId cache with all possible Ids.
        /// </summary>
        private void BuildObjectIdCache()
        {
            _objectIdCache.Clear();

            /* Shuffle Ids to make it more difficult
             * for clients to track spawned object
             * count. */
            List<int> shuffledCache = new List<int>();
            for (int i = 0; i < short.MaxValue; i++)
                shuffledCache.Add(i);
            /* Only shuffle when NOT in editor and not
             * development build.
             * Debugging could be easier when Ids are ordered. */
#if !UNITY_EDITOR && !DEVELOPMENT_BUILD
            shuffledCache.Shuffle();
#endif
            //Add shuffled to objectIdCache.
            //Build Id cache.
            int cacheCount = shuffledCache.Count;
            for (int i = 0; i < cacheCount; i++)
                _objectIdCache.Enqueue(shuffledCache[i]);
        }
        /// <summary>
        /// Caches a NetworkObject ObjectId.
        /// </summary>
        /// <param name="nob"></param>
        private void CacheObjectId(NetworkObject nob)
        {
            if (nob.ObjectId >= 0)
                _objectIdCache.Enqueue(nob.ObjectId);
        }

        /// <summary>
        /// Gets the next ObjectId to use for NetworkObjects.
        /// </summary>
        /// <returns></returns>
        protected internal override int GetNextNetworkObjectId()
        {
            //Either something went wrong or user actually managed to spawn ~32K networked objects.
            if (_objectIdCache.Count == 0)
            {
                if (base.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"No more available ObjectIds. How the heck did you manage to have {short.MaxValue} objects spawned at once?");
                return -1;
            }
            else
            {
                return _objectIdCache.Dequeue();
            }
        }
        #endregion

        #region Initializing Objects In Scenes.
        /// <summary>
        /// Called when a scene load starts.
        /// </summary>
        private void SceneManager_OnLoadStart(Scened.SceneLoadStartEventArgs obj)
        {
            _scenesLoading = true;
        }
        /// <summary>
        /// Called after the active scene has been scene, immediately after scene loads.
        /// </summary>
        private void SceneManager_OnActiveSceneSet()
        {
            _scenesLoading = false;
            IterateLoadedScenes(true);
        }
        /// <summary>
        /// Iterates loaded scenes and sets them up.
        /// </summary>
        /// <param name="ignoreFrameRestriction">True to ignore the frame restriction when iterating.</param>
        internal void IterateLoadedScenes(bool ignoreFrameRestriction)
        {
            //Not started, clear loaded scenes.
            if (!NetworkManager.ServerManager.Started)
                _loadedScenes.Clear();

            for (int i = 0; i < _loadedScenes.Count; i++)
            {
                (int frame, Scene scene) value = _loadedScenes[i];
                if (ignoreFrameRestriction || (Time.frameCount > value.frame))
                {
                    SetupSceneObjects(value.scene);
                    _loadedScenes.RemoveAt(i);
                    i--;
                }
            }
        }

        /// <summary>
        /// Called when a scene loads on the server.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="arg1"></param>
        protected internal override void SceneManager_sceneLoaded(Scene s, LoadSceneMode arg1)
        {
            base.SceneManager_sceneLoaded(s, arg1);

            if (!NetworkManager.ServerManager.Started)
                return;
            //Add to loaded scenes so that they are setup next frame.
            _loadedScenes.Add((Time.frameCount, s));
        }

        /// <summary>
        /// Setup all NetworkObjects in scenes. Should only be called when server is active.
        /// </summary>
        protected internal void SetupSceneObjects()
        {
            for (int i = 0; i < SceneManager.sceneCount; i++)
                SetupSceneObjects(SceneManager.GetSceneAt(i));

            Scene ddolScene = DDOLFinder.GetDDOL().gameObject.scene;
            if (ddolScene.isLoaded)
                SetupSceneObjects(ddolScene);
        }

        /// <summary>
        /// Setup NetworkObjects in a scene. Should only be called when server is active.
        /// </summary>
        /// <param name="s"></param>
        private void SetupSceneObjects(Scene s)
        {
            ListCache<NetworkObject> nobs;
            SceneFN.GetSceneNetworkObjects(s, false, out nobs);

            bool isHost = base.NetworkManager.IsHost;

            for (int i = 0; i < nobs.Written; i++)
            {
                NetworkObject nob = nobs.Collection[i];
                //Only setup if a scene object and not initialzied.
                if (nob.IsNetworked && nob.IsSceneObject && nob.IsDeinitializing)
                {
                    base.UpdateNetworkBehaviours(nob, true);
                    base.AddToSceneObjects(nob);
                    /* If was active in the editor (before hitting play), or currently active
                     * then PreInitialize without synchronizing to clients. There is no reason
                     * to synchronize to clients because the scene just loaded on server,
                     * which means clients are not yet in the scene. */
                    if (nob.ActiveDuringEdit || nob.gameObject.activeInHierarchy)
                    {
                        //If not host then object doesn't need to be spawned until a client joins.
                        if (!isHost)
                            SetupWithoutSynchronization(nob);
                        //Otherwise spawn object so observers update for clientHost.
                        else
                            SpawnWithoutChecks(nob);
                    }
                }
            }

            ListCaches.StoreCache(nobs);
        }

        /// <summary>
        /// Performs setup on a NetworkObject without synchronizing the actions to clients.
        /// </summary>
        private void SetupWithoutSynchronization(NetworkObject nob, NetworkConnection ownerConnection = null)
        {
            if (nob.IsNetworked)
            {
                int objectId = GetNextNetworkObjectId();
                nob.PreinitializeInternal(NetworkManager, objectId, ownerConnection, true);
                base.AddToSpawned(nob, true);
                nob.gameObject.SetActive(true);
                nob.Initialize(true);
            }
        }
        #endregion

        #region Spawning.
        /// <summary>
        /// Spawns an object over the network.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void Spawn(NetworkObject networkObject, NetworkConnection ownerConnection = null)
        {
            if (!NetworkManager.ServerManager.Started)
            {
                if (base.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning("Cannot spawn object because the server is not active.");
                return;
            }
            if (networkObject == null)
            {
                if (base.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Specified networkObject is null.");
                return;
            }
            if (!networkObject.gameObject.scene.IsValid())
            {
                if (base.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"{networkObject.name} is a prefab. You must instantiate the prefab first, then use Spawn on the instantiated copy.");
                return;
            }
            if (ownerConnection != null && ownerConnection.IsActive && !ownerConnection.LoadedStartScenes)
            {
                if (base.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"{networkObject.name} was spawned but it's recommended to not spawn objects for connections until they have loaded start scenes. You can be notified when a connection loads start scenes by using connection.OnLoadedStartScenes on the connection, or SceneManager.OnClientLoadStartScenes.");
            }
            if (networkObject.IsSpawned)
            {
                if (base.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"{networkObject.name} is already spawned.");
                return;
            }
            if (networkObject.ParentNetworkObject != null && !networkObject.ParentNetworkObject.IsSpawned)
            {
                if (base.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"{networkObject.name} cannot be spawned because it has a parent NetworkObject {networkObject.ParentNetworkObject} which is not spawned.");
                return;
            }

            SpawnWithoutChecks(networkObject, ownerConnection);
        }

        /// <summary>
        /// Spawns networkObject without any checks.
        /// </summary>
        private void SpawnWithoutChecks(NetworkObject networkObject, NetworkConnection ownerConnection = null)
        {
            /* Setup locally without sending to clients.
            * When observers are built for the network object
            * during initialization spawn messages will
            * be sent. */
            networkObject.SetIsNetworked(true);
            _spawnCache.AddValue(networkObject);
            SetupWithoutSynchronization(networkObject, ownerConnection);

            foreach (NetworkObject item in networkObject.ChildNetworkObjects)
            {
                /* Only spawn recursively if the nob state is unset.
                 * Unset indicates that the nob has not been */
                if (item.gameObject.activeInHierarchy || item.State == NetworkObjectState.Spawned)
                    SpawnWithoutChecks(item, ownerConnection);
            }

            /* Copy to a new cache then reset _spawnCache
             * just incase rebuilding observers would lead to 
             * more additions into _spawnCache. EG: rebuilding
             * may result in additional objects being spawned
             * for clients and if _spawnCache were not reset
             * the same objects would be rebuilt again. This likely
             * would not affect anything other than perf but who
             * wants that. */
            ListCache<NetworkObject> spawnCacheCopy = ListCaches.GetNetworkObjectCache();
            spawnCacheCopy.AddValues(_spawnCache);
            _spawnCache.Reset();
            //Also rebuild observers for the object so it spawns for others.
            RebuildObservers(spawnCacheCopy);

            /* If also client then we need to make sure the object renderers have correct visibility.
             * Set visibility based on if the observers contains the clientHost connection. */
            if (NetworkManager.IsClient)
            {
                int count = spawnCacheCopy.Written;
                List<NetworkObject> collection = spawnCacheCopy.Collection;
                for (int i = 0; i < count; i++)
                    collection[i].SetRenderersVisible(networkObject.Observers.Contains(NetworkManager.ClientManager.Connection));
            }

            ListCaches.StoreCache(spawnCacheCopy);
        }

        /// <summary>
        /// Writes a spawn into writers.
        /// </summary>
        /// <param name="nob"></param>
        /// <param name="connection">Connection spawn is being written for.</param>
        /// <param name="everyoneWriter"></param>
        /// <param name="ownerWriter"></param>
        private void WriteSpawn(NetworkObject nob, NetworkConnection connection, ref PooledWriter everyoneWriter, ref PooledWriter ownerWriter)
        {
            /* Using a number of writers to prevent rebuilding the
             * packets excessively for values that are owner only
             * vs values that are everyone. To save performance the
             * owner writer is only written to if owner is valid.
             * This makes the code a little uglier but will scale
             * significantly better with more connections.
             * 
             * EG:
             * with this technique networkBehaviours are iterated
             * twice if there is an owner; once for data to send to everyone
             * and again for data only going to owner. 
             *
             * The alternative would be to iterate the networkbehaviours
             * for every connection it's going to and filling a single
             * writer with values based on if owner or not. This would
             * result in significantly more iterations. */
            PooledWriter headerWriter = WriterPool.GetWriter();
            headerWriter.WritePacketId(PacketId.ObjectSpawn);
            headerWriter.WriteNetworkObject(nob);
            if (base.NetworkManager.ServerManager.ShareIds || connection == nob.Owner)
                headerWriter.WriteNetworkConnection(nob.Owner);
            else
                headerWriter.WriteInt16(-1);

            bool nested = nob.IsNested;
            bool sceneObject = nob.IsSceneObject;
            //Write type of spawn.
            SpawnType st;
            if (sceneObject)
                st = SpawnType.Scene;
            else
                st = (nob.IsGlobal) ? SpawnType.InstantiatedGlobal : SpawnType.Instantiated;
            headerWriter.WriteByte((byte)st);
            //ComponentIndex for the nob. 0 is root but more appropriately there's a IsNested boolean as shown above.
            headerWriter.WriteByte(nob.ComponentIndex);

            /* When nested the parent nob needs to be written. */
            if (nested)
            {
                headerWriter.WriteNetworkObject(nob.ParentNetworkObject);
            }
            //If not nested see if has a parent other than one configured at edit.
            else
            {
                /* Writing a scene object. */
                if (sceneObject)
                {
                    //Write Guid.
                    headerWriter.WriteUInt64(nob.SceneId, AutoPackType.Unpacked);
                }
                /* Writing a spawned object. */
                else
                {
                    //Check to write parent behaviour or nob.
                    NetworkBehaviour parentNb;
                    Transform t = nob.transform.parent;
                    if (t != null)
                    {
                        parentNb = t.GetComponent<NetworkBehaviour>();
                        /* Check for a NetworkObject if there is no NetworkBehaviour.
                         * There is a small chance the parent object will only contain
                         * a NetworkObject. */
                        if (parentNb == null)
                        {
                            //If null check if there is a nob.
                            NetworkObject parentNob = t.GetComponent<NetworkObject>();
                            //ParentNob is null or not spawned.
                            if (!ParentIsSpawned(parentNob))
                            {
                                headerWriter.WriteByte((byte)SpawnParentType.Unset);
                            }
                            else
                            {
                                headerWriter.WriteByte((byte)SpawnParentType.NetworkObject);
                                headerWriter.WriteNetworkObject(parentNob);
                            }
                        }
                        //NetworkBehaviour found on parent.
                        else
                        {
                            //ParentNb is null or not spawned.
                            if (!ParentIsSpawned(parentNb.NetworkObject))
                            {
                                headerWriter.WriteByte((byte)SpawnParentType.Unset);
                            }
                            else
                            {
                                headerWriter.WriteByte((byte)SpawnParentType.NetworkBehaviour);
                                headerWriter.WriteNetworkBehaviour(parentNb);
                            }
                        }

                        //True if pNob is not null, and is spawned.
                        bool ParentIsSpawned(NetworkObject pNob)
                        {
                            bool isNull = (pNob == null);
                            if (isNull || !pNob.IsSpawned)
                            {
                                /* Only log if pNob exist. Otherwise this would print if the user 
                                 * was parenting any object, which may not be desirable as they could be
                                 * simply doing it for organization reasons. */
                                if (!isNull && base.NetworkManager.CanLog(LoggingType.Warning))
                                    Debug.LogWarning($"Parent {t.name} is not spawned. {nob.name} will not have it's parent sent in the spawn message.");
                                return false;
                            }

                            return true;
                        }

                    }
                    //No parent.
                    else
                    {
                        headerWriter.WriteByte((byte)SpawnParentType.Unset);
                    }

                    headerWriter.WriteInt16(nob.PrefabId);
                }
            }

            /* Write changed transform properties. */
            ChangedTransformProperties ctp;
            //If a scene object then get it from scene properties.
            if (sceneObject || nested)
                ctp = nob.GetTransformChanges(nob.SerializedTransformProperties);
            else
                ctp = nob.GetTransformChanges(base.NetworkManager.SpawnablePrefabs.GetObject(true, nob.PrefabId).gameObject);
            headerWriter.WriteByte((byte)ctp);
            //If properties have changed.
            if (ctp != ChangedTransformProperties.Unset)
            {
                //Write any changed properties.
                if (Enums.TransformPropertiesContains(ctp, ChangedTransformProperties.LocalPosition))
                    headerWriter.WriteVector3(nob.transform.localPosition);
                if (Enums.TransformPropertiesContains(ctp, ChangedTransformProperties.LocalRotation))
                    headerWriter.WriteQuaternion(nob.transform.localRotation, base.NetworkManager.ServerManager.SpawnPacking.Rotation);
                if (Enums.TransformPropertiesContains(ctp, ChangedTransformProperties.LocalScale))
                    headerWriter.WriteVector3(nob.transform.localScale);
            }

            //Write headers first.
            everyoneWriter.WriteBytes(headerWriter.GetBuffer(), 0, headerWriter.Length);
            if (nob.Owner.IsValid)
                ownerWriter.WriteBytes(headerWriter.GetBuffer(), 0, headerWriter.Length);

            /* Used to write latest data which must be sent to
             * clients, such as SyncTypes and RpcLinks. */
            PooledWriter tempWriter = WriterPool.GetWriter();
            //Send RpcLinks first.
            foreach (NetworkBehaviour nb in nob.NetworkBehaviours)
                nb.WriteRpcLinks(tempWriter);
            //Add to everyone/owner.
            everyoneWriter.WriteBytesAndSize(tempWriter.GetBuffer(), 0, tempWriter.Length);
            if (nob.Owner.IsValid)
                ownerWriter.WriteBytesAndSize(tempWriter.GetBuffer(), 0, tempWriter.Length);

            //Add most recent sync type values.
            /* SyncTypes have to be populated for owner and everyone.
            * The data may be unique for owner if synctypes are set
            * to only go to owner. */
            tempWriter.Reset();
            foreach (NetworkBehaviour nb in nob.NetworkBehaviours)
                nb.WriteSyncTypesForSpawn(tempWriter, false);
            everyoneWriter.WriteBytesAndSize(tempWriter.GetBuffer(), 0, tempWriter.Length);
            //If owner is valid then populate owner writer as well.
            if (nob.Owner.IsValid)
            {
                tempWriter.Reset();
                foreach (NetworkBehaviour nb in nob.NetworkBehaviours)
                    nb.WriteSyncTypesForSpawn(tempWriter, true);
                ownerWriter.WriteBytesAndSize(tempWriter.GetBuffer(), 0, tempWriter.Length);
            }

            //Dispose of writers created in this method.
            headerWriter.Dispose();
            tempWriter.Dispose();
        }
        #endregion

        #region Despawning.
        internal void AddToPending(NetworkObject nob)
        {
            _pendingDestroy[nob.ObjectId] = nob;
        }
        /// <summary>
        /// Tries to removes objectId from PendingDestroy and returns if successful.
        /// </summary>
        internal bool RemoveFromPending(int objectId)
        {
            return _pendingDestroy.Remove(objectId);
        }
        /// <summary>
        /// Returns a NetworkObject in PendingDestroy.
        /// </summary>
        internal NetworkObject GetFromPending(int objectId)
        {
            NetworkObject nob;
            _pendingDestroy.TryGetValue(objectId, out nob);
            return nob;
        }
        /// <summary>
        /// Destroys NetworkObjects pending for destruction.
        /// </summary>
        internal void DestroyPending()
        {
            foreach (NetworkObject item in _pendingDestroy.Values)
            {
                if (item != null)
                    MonoBehaviour.Destroy(item.gameObject);
            }

            _pendingDestroy.Clear();
        }

        /// <summary>
        /// Despawns an object over the network.
        /// </summary>
        internal override void Despawn(NetworkObject nob, DespawnType despawnType, bool asServer)
        {
            if (nob.CanSpawnOrDespawn(true))
            {
                FinalizeDespawn(nob, despawnType);
                base.Despawn(nob, despawnType, true);
            }
        }

        /// <summary>
        /// Called when a NetworkObject is destroyed without being deactivated first.
        /// </summary>
        /// <param name="nob"></param>
        internal override void NetworkObjectUnexpectedlyDestroyed(NetworkObject nob)
        {
            FinalizeDespawn(nob, DespawnType.Destroy);
            base.NetworkObjectUnexpectedlyDestroyed(nob);
        }

        /// <summary>
        /// Finalizes the despawn process. By the time this is called the object is considered unaccessible.
        /// </summary>
        /// <param name="nob"></param>
        private void FinalizeDespawn(NetworkObject nob, DespawnType despawnType)
        {
            if (nob != null && nob.ObjectId != -1)
            {
                nob.WriteDirtySyncTypes();
                WriteDespawnAndSend(nob, despawnType);
                CacheObjectId(nob);
            }
        }

        /// <summary>
        /// Writes a despawn and sends it to clients.
        /// </summary>
        /// <param name="nob"></param>
        private void WriteDespawnAndSend(NetworkObject nob, DespawnType despawnType)
        {
            PooledWriter everyoneWriter = WriterPool.GetWriter();
            WriteDespawn(nob, despawnType, ref everyoneWriter);

            ArraySegment<byte> despawnSegment = everyoneWriter.GetArraySegment();

            //Add observers to a list cache.
            ListCache<NetworkConnection> cache = ListCaches.GetNetworkConnectionCache();
            cache.Reset();
            cache.AddValues(nob.Observers);
            int written = cache.Written;
            for (int i = 0; i < written; i++)
            {
                //Invoke ondespawn and send despawn.
                NetworkConnection conn = cache.Collection[i];
                nob.InvokeOnServerDespawn(conn);
                NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, despawnSegment, conn);
                //Remove from observers.
                //nob.Observers.Remove(conn);
            }

            everyoneWriter.Dispose();
            ListCaches.StoreCache(cache);
        }
        /// <summary>
        /// Writes a despawn.
        /// </summary>
        /// <param name="nob"></param>
        private void WriteDespawn(NetworkObject nob, DespawnType despawnType, ref PooledWriter everyoneWriter)
        {
            everyoneWriter.WritePacketId(PacketId.ObjectDespawn);
            everyoneWriter.WriteNetworkObject(nob);
            everyoneWriter.WriteByte((byte)despawnType);
        }

    }
    #endregion

}

'''
'''--- Assets/FishNet/Runtime/Managing/Server/ServerManager.Broadcast.cs ---
﻿using FishNet.Broadcast;
using FishNet.Broadcast.Helping;
using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Server
{
    public sealed partial class ServerManager : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// Delegate to read received broadcasts.
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="reader"></param>
        private delegate void ClientBroadcastDelegate(NetworkConnection connection, PooledReader reader);
        /// <summary>
        /// Delegates for each key.
        /// </summary>
        private readonly Dictionary<ushort, HashSet<ClientBroadcastDelegate>> _broadcastHandlers = new Dictionary<ushort, HashSet<ClientBroadcastDelegate>>();
        /// <summary>
        /// Delegate targets for each key.
        /// </summary>
        private Dictionary<ushort, HashSet<(int, ClientBroadcastDelegate)>> _handlerTargets = new Dictionary<ushort, HashSet<(int, ClientBroadcastDelegate)>>();
        /// <summary>
        /// Connections which can be broadcasted to after having excluded removed.
        /// </summary>
        private HashSet<NetworkConnection> _connectionsWithoutExclusions = new HashSet<NetworkConnection>();
        #endregion

        /// <summary>
        /// Registers a method to call when a Broadcast arrives.
        /// </summary>
        /// <typeparam name="T">Type of broadcast being registered.</typeparam>
        /// <param name="handler">Method to call.</param>
        /// <param name="requireAuthentication">True if the client must be authenticated for the method to call.</param>
        public void RegisterBroadcast<T>(Action<NetworkConnection, T> handler, bool requireAuthentication = true) where T : struct, IBroadcast
        {
            ushort key = BroadcastHelper.GetKey<T>();

            /* Create delegate and add for
             * handler method. */
            HashSet<ClientBroadcastDelegate> handlers;
            if (!_broadcastHandlers.TryGetValueIL2CPP(key, out handlers))
            {
                handlers = new HashSet<ClientBroadcastDelegate>();
                _broadcastHandlers.Add(key, handlers);
            }
            ClientBroadcastDelegate del = CreateBroadcastDelegate(handler, requireAuthentication);
            handlers.Add(del);

            /* Add hashcode of target for handler.
             * This is so we can unregister the target later. */
            int handlerHashCode = handler.GetHashCode();
            HashSet<(int, ClientBroadcastDelegate)> targetHashCodes;
            if (!_handlerTargets.TryGetValueIL2CPP(key, out targetHashCodes))
            {
                targetHashCodes = new HashSet<(int, ClientBroadcastDelegate)>();
                _handlerTargets.Add(key, targetHashCodes);
            }

            targetHashCodes.Add((handlerHashCode, del));
        }

        /// <summary>
        /// Unregisters a method call from a Broadcast type.
        /// </summary>
        /// <typeparam name="T">Type of broadcast being unregistered.</typeparam>
        /// <param name="handler">Method to unregister.</param>
        public void UnregisterBroadcast<T>(Action<NetworkConnection, T> handler) where T : struct, IBroadcast
        {
            ushort key = BroadcastHelper.GetKey<T>();

            /* If key is found for T then look for
             * the appropriate handler to remove. */
            if (_broadcastHandlers.TryGetValueIL2CPP(key, out HashSet<ClientBroadcastDelegate> handlers))
            {
                HashSet<(int, ClientBroadcastDelegate)> targetHashCodes;
                if (_handlerTargets.TryGetValueIL2CPP(key, out targetHashCodes))
                {
                    int handlerHashCode = handler.GetHashCode();
                    ClientBroadcastDelegate result = null;
                    foreach ((int targetHashCode, ClientBroadcastDelegate del) in targetHashCodes)
                    {
                        if (targetHashCode == handlerHashCode)
                        {
                            result = del;
                            targetHashCodes.Remove((targetHashCode, del));
                            break;
                        }
                    }
                    //If no more in targetHashCodes then remove from handlerTarget.
                    if (targetHashCodes.Count == 0)
                        _handlerTargets.Remove(key);

                    if (result != null)
                        handlers.Remove(result);
                }

                //If no more in handlers then remove broadcastHandlers.
                if (handlers.Count == 0)
                    _broadcastHandlers.Remove(key);
            }
        }

        /// <summary>
        /// Creates a ClientBroadcastDelegate.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="handler"></param>
        /// <param name="requireAuthentication"></param>
        /// <returns></returns>
        private ClientBroadcastDelegate CreateBroadcastDelegate<T>(Action<NetworkConnection, T> handler, bool requireAuthentication)
        {
            void LogicContainer(NetworkConnection connection, PooledReader reader)
            {
                //If requires authentication and client isn't authenticated.
                if (requireAuthentication && !connection.Authenticated)
                {
                    if (NetworkManager.CanLog(LoggingType.Warning))
                        Debug.LogWarning($"ConnectionId {connection.ClientId} sent broadcast {typeof(T).Name} which requires authentication, but client was not authenticated. Client has been disconnected.");
                    NetworkManager.TransportManager.Transport.StopConnection(connection.ClientId, true);
                    return;
                }

                T broadcast = reader.Read<T>();
                handler?.Invoke(connection, broadcast);
            }
            return LogicContainer;
        }

        /// <summary>
        /// Parses a received broadcast.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ParseBroadcast(PooledReader reader, NetworkConnection conn, Channel channel)
        {
            ushort key = reader.ReadUInt16();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.Broadcast, reader, channel);

            //Try to invoke the handler for that message
            if (_broadcastHandlers.TryGetValueIL2CPP(key, out HashSet<ClientBroadcastDelegate> handlers))
            {
                int readerStartPosition = reader.Position;
                /* //muchlater resetting the position could be better by instead reading once and passing in
                 * the object to invoke with. */
                bool rebuildHandlers = false;
                //True if data is read at least once. Otherwise it's length will have to be purged.
                bool dataRead = false;
                foreach (ClientBroadcastDelegate handler in handlers)
                {
                    if (handler.Target == null && NetworkManager.CanLog(LoggingType.Warning))
                    {
                        Debug.LogWarning($"A Broadcast handler target is null. This can occur when a script is destroyed but does not unregister from a Broadcast.");
                        rebuildHandlers = true;
                    }
                    else
                    {
                        reader.Position = readerStartPosition;
                        handler.Invoke(conn, reader);
                        dataRead = true;
                    }
                }

                //If rebuilding handlers...
                if (rebuildHandlers)
                {
                    List<ClientBroadcastDelegate> dels = handlers.ToList();
                    handlers.Clear();
                    for (int i = 0; i < dels.Count; i++)
                    {
                        if (dels[i].Target != null)
                            handlers.Add(dels[i]);
                    }
                }
                //Make sure data was read as well.
                if (!dataRead)
                    reader.Skip(dataLength);
            }
            else
            {
                reader.Skip(dataLength);
            }
        }

        /// <summary>
        /// Sends a broadcast to a connection.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="connection">Connection to send to.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the client must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(NetworkConnection connection, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }
            if (requireAuthenticated && !connection.Authenticated)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to client because they are not authenticated.");
                return;
            }

            using (PooledWriter writer = WriterPool.GetWriter())
            {
                Broadcasts.WriteBroadcast<T>(writer, message, channel);
                ArraySegment<byte> segment = writer.GetArraySegment();
                NetworkManager.TransportManager.SendToClient((byte)channel, segment, connection);
            }
        }

        /// <summary>
        /// Sends a broadcast to connections.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="connections">Connections to send to.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(HashSet<NetworkConnection> connections, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            bool failedAuthentication = false;
            using (PooledWriter writer = WriterPool.GetWriter())
            {
                Broadcasts.WriteBroadcast<T>(writer, message, channel);
                ArraySegment<byte> segment = writer.GetArraySegment();

                foreach (NetworkConnection conn in connections)
                {
                    if (requireAuthenticated && !conn.Authenticated)
                        failedAuthentication = true;
                    else
                        NetworkManager.TransportManager.SendToClient((byte)channel, segment, conn);
                }
            }

            if (failedAuthentication)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"One or more broadcast did not send to a client because they were not authenticated.");
                return;
            }
        }

        
        /// <summary>
        /// Sends a broadcast to connections except excluded.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="connections">Connections to send to.</param>
        /// <param name="excludedConnection">Connection to exclude.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void BroadcastExcept<T>(HashSet<NetworkConnection> connections, NetworkConnection excludedConnection, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            //Fast exit if no exclusions.
            if (excludedConnection == null || !excludedConnection.IsValid)
            {
                Broadcast(connections, message, requireAuthenticated, channel);
                return;
            }

            connections.Remove(excludedConnection);
            Broadcast(connections, message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends a broadcast to connections except excluded.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="connections">Connections to send to.</param>
        /// <param name="excludedConnections">Connections to exclude.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void BroadcastExcept<T>(HashSet<NetworkConnection> connections, HashSet<NetworkConnection> excludedConnections, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            //Fast exit if no exclusions.
            if (excludedConnections == null || excludedConnections.Count == 0)
            {
                Broadcast(connections, message, requireAuthenticated, channel);
                return;
            }

            /* I'm not sure if the hashset API such as intersect generates
             * GC or not but I'm betting doing remove locally is faster, or
             * just as fast. */
            foreach (NetworkConnection ec in excludedConnections)
                connections.Remove(ec);

            Broadcast(connections,message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends a broadcast to all connections except excluded.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="excludedConnection">Connection to exclude.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void BroadcastExcept<T>(NetworkConnection excludedConnection, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            //Fast exit if there are no excluded.
            if (excludedConnection == null || !excludedConnection.IsValid)
            {
                Broadcast(message, requireAuthenticated, channel);
                return;
            }

            _connectionsWithoutExclusions.Clear();
            /* It will be faster to fill the entire list then
             * remove vs checking if each connection is contained within excluded. */
            foreach (NetworkConnection c in Clients.Values)
                _connectionsWithoutExclusions.Add(c);
            //Remove
            _connectionsWithoutExclusions.Remove(excludedConnection);

            Broadcast(_connectionsWithoutExclusions, message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends a broadcast to all connections except excluded.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="excludedConnections">Connections to send to.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void BroadcastExcept<T>(HashSet<NetworkConnection> excludedConnections, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            //Fast exit if there are no excluded.
            if (excludedConnections == null || excludedConnections.Count == 0)
            {
                Broadcast(message, requireAuthenticated, channel);
                return;
            }

            _connectionsWithoutExclusions.Clear();
            /* It will be faster to fill the entire list then
             * remove vs checking if each connection is contained within excluded. */
            foreach (NetworkConnection c in Clients.Values)
                _connectionsWithoutExclusions.Add(c);
            //Remove
            foreach (NetworkConnection c in excludedConnections)
                _connectionsWithoutExclusions.Remove(c);

            Broadcast(_connectionsWithoutExclusions, message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends a broadcast to observers.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="networkObject">NetworkObject to use Observers from.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Broadcast<T>(NetworkObject networkObject, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (networkObject == null)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast because networkObject is null.");
                return;
            }

            Broadcast(networkObject.Observers, message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends a broadcast to all clients.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            bool failedAuthentication = false;
            using (PooledWriter writer = WriterPool.GetWriter())
            {
                Broadcasts.WriteBroadcast<T>(writer, message, channel);
                ArraySegment<byte> segment = writer.GetArraySegment();

                foreach (NetworkConnection conn in Clients.Values)
                {
                    //
                    if (requireAuthenticated && !conn.Authenticated)
                        failedAuthentication = true;
                    else
                        NetworkManager.TransportManager.SendToClient((byte)channel, segment, conn);
                }
            }

            if (failedAuthentication)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"One or more broadcast did not send to a client because they were not authenticated.");
                return;
            }
        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Managing/Server/ServerManager.QOL.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Object;
using FishNet.Transporting;
using FishNet.Transporting.Multipass;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Server
{
    public sealed partial class ServerManager : MonoBehaviour
    {
        /// <summary>
        /// Returns true if only one server is started.
        /// </summary>
        /// <returns></returns>
        internal bool OneServerStarted()
        {
            int startedCount = 0;
            TransportManager tm = NetworkManager.TransportManager;
            //If using multipass check all transports.
            if (tm.Transport is Multipass mp)
            {
                
                foreach (Transport t in mp.Transports)
                {
                    //Another transport is started, no need to load start scenes again.
                    if (t.GetConnectionState(true) == LocalConnectionState.Started)
                        startedCount++;
                }
            }
            //Not using multipass.
            else
            {
                if (tm.Transport.GetConnectionState(true) == LocalConnectionState.Started)
                    startedCount = 1;
            }

            return (startedCount == 1);
        }

        /// <summary>
        /// Returns true if any server socket is in the started state.
        /// </summary>
        /// <param name="excludedIndex">When set the transport on this index will be ignored. This value is only used with Multipass.</param>
        /// <returns></returns>
        internal bool AnyServerStarted(int? excludedIndex = null)
        {
            TransportManager tm = NetworkManager.TransportManager;
            //If using multipass check all transports.
            if (tm.Transport is Multipass mp)
            {
                //Get transport which had state changed.
                Transport excludedTransport = (excludedIndex == null) ? null : mp.GetTransport(excludedIndex.Value);

                foreach (Transport t in mp.Transports)
                {
                    /* Skip t if is the transport that had it's state changed.
                     * We are looking for other transports already in started. */
                    if (t == excludedTransport)
                        continue;
                    //Another transport is started, no need to load start scenes again.
                    if (t.GetConnectionState(true) == LocalConnectionState.Started)
                        return true;
                }
            }
            //Not using multipass.
            else
            {
                return (tm.Transport.GetConnectionState(true) == LocalConnectionState.Started);
            }

            //Fall through, none started.
            return false;
        }

        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="go">GameObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Spawn(GameObject go, NetworkConnection ownerConnection = null)
        {
            if (!CanSpawnOrDespawn(true))
                return;
            if (go == null)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"GameObject cannot be spawned because it is null.");
                return;
            }

            NetworkObject nob = go.GetComponent<NetworkObject>();
            Spawn(nob, ownerConnection);
        }

        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="nob">MetworkObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        public void Spawn(NetworkObject nob, NetworkConnection ownerConnection = null)
        {
            if (!CanSpawnOrDespawn(true))
                return;
            if (nob == null)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"NetworkObject cannot be spawned because it is null.");
                return;
            }

            Objects.Spawn(nob, ownerConnection);
        }

        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="nob">MetworkObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        /// <param name="synchronizeParent">True to synchronize the parent object in the spawn message. The parent must have a NetworkObject or NetworkBehaviour component for this to work.</param>
        [Obsolete("SynchronizeParent is now automatic, and no longer optional. Use Spawn(NetworkObject, NetworkConnection) instead.")] //Remove 2023/01/01.
        public void Spawn(NetworkObject nob, NetworkConnection ownerConnection, bool synchronizeParent)
        {
            if (!CanSpawnOrDespawn(true))
                return;
            if (nob == null)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"NetworkObject cannot be spawned because it is null.");
                return;
            }

            Objects.Spawn(nob, ownerConnection);
        }

        /// <summary>
        /// Returns if Spawn can be called.
        /// </summary>
        /// <param name="warn">True to warn if not able to execute spawn or despawn.</param>
        /// <returns></returns>
        private bool CanSpawnOrDespawn(bool warn)
        {
            bool canLog = (warn && NetworkManager.CanLog(LoggingType.Warning));
            if (!Started)
            {
                if (canLog)
                    Debug.Log($"The server must be active to spawn or despawn networked objects.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Despawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="go">GameObject instance to despawn.</param>
        /// <param name="cacheOnDespawnOverride">Overrides the default DisableOnDespawn value for this single despawn. Scene objects will never be destroyed.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Despawn(GameObject go, DespawnType? despawnType = null)
        {
            if (!CanSpawnOrDespawn(true))
                return;

            if (go == null)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"GameObject cannot be despawned because it is null.");
                return;
            }

            NetworkObject nob = go.GetComponent<NetworkObject>();
            Despawn(nob, despawnType);
        }

        /// <summary>
        /// Despawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="networkObject">NetworkObject instance to despawn.</param>
        /// <param name="cacheOnDespawnOverride">Overrides the default DisableOnDespawn value for this single despawn. Scene objects will never be destroyed.</param>
        public void Despawn(NetworkObject networkObject, DespawnType? despawnType = null)
        {
            if (!CanSpawnOrDespawn(true))
                return;
            if (networkObject == null)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"NetworkObject cannot be despawned because it is null.");
                return;
            }

            DespawnType resolvedDespawnType = (despawnType == null)
                ? networkObject.GetDefaultDespawnType() 
                : despawnType.Value;
            Objects.Despawn(networkObject, resolvedDespawnType, true);
        }
    }

}

'''
'''--- Assets/FishNet/Runtime/Managing/Server/ServerManager.RpcLinks.cs ---
﻿using FishNet.Object;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Managing.Server
{

    public sealed partial class ServerManager : MonoBehaviour
    {

        #region Internal
        /// <summary>
        /// Current RPCLinks.
        /// </summary>
        internal Dictionary<ushort, RpcLink> RpcLinks = new Dictionary<ushort, RpcLink>();
        /// <summary>
        /// RPCLink indexes which can be used.
        /// </summary>
        private Queue<ushort> _availableRpcLinkIndexes = new Queue<ushort>();
        #endregion

        /// <summary>
        /// Initializes RPC Links for NetworkBehaviours.
        /// </summary>
        private void InitializeRpcLinks()
        {
            /* Brute force enum values. 
             * Linq Last/Max lookup throws for IL2CPP. */
            ushort highestValue = 0;
            Array pidValues = Enum.GetValues(typeof(PacketId));
            foreach (PacketId pid in pidValues)
                highestValue = Math.Max(highestValue, (ushort)pid);

            highestValue += 1;
            for (ushort i = highestValue; i < ushort.MaxValue; i++)
                _availableRpcLinkIndexes.Enqueue(i);
        }

        /// <summary>
        /// Sets the next RPC Link to use.
        /// </summary>
        /// <returns>True if a link was available and set.</returns>
        internal bool GetRpcLink(out ushort value)
        {
            if (_availableRpcLinkIndexes.Count > 0)
            {
                value = _availableRpcLinkIndexes.Dequeue();
                return true;
            }
            else
            {
                value = 0;
                return false;
            }
        }

        /// <summary>
        /// Sets data to RpcLinks for linkIndex.
        /// </summary>
        internal void SetRpcLink(ushort linkIndex, RpcLink data)
        {
            RpcLinks[linkIndex] = data;
        }

        /// <summary>
        /// Returns RPCLinks to availableRpcLinkIndexes.
        /// </summary>
        internal void ReturnRpcLinks(Dictionary<uint, RpcLinkType> links)
        {
            foreach (ushort linkId in links.Keys)
                _availableRpcLinkIndexes.Enqueue(linkId);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Server/ServerManager.cs ---
﻿using FishNet.Authenticating;
using FishNet.Component.Observing;
using FishNet.Connection;
using FishNet.Managing.Debugging;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

namespace FishNet.Managing.Server
{
    /// <summary>
    /// A container for server data and actions.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/ServerManager")]
    public sealed partial class ServerManager : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called after the local server connection state changes.
        /// </summary>
        public event Action<ServerConnectionStateArgs> OnServerConnectionState;
        /// <summary>
        /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed.
        /// </summary>
        public event Action<NetworkConnection, bool> OnAuthenticationResult;
        /// <summary>
        /// Called when a remote client state changes with the server.
        /// </summary>
        public event Action<NetworkConnection, RemoteConnectionStateArgs> OnRemoteConnectionState;
        /// <summary>
        /// True if the server connection has started.
        /// </summary>
        public bool Started { get; private set; }
        /// <summary>
        /// Handling and information for objects on the server.
        /// </summary>
        public ServerObjects Objects { get; private set; }
        /// <summary>
        /// Authenticated and non-authenticated connected clients.
        /// </summary>
        [HideInInspector]
        public Dictionary<int, NetworkConnection> Clients = new Dictionary<int, NetworkConnection>();
        /// <summary>
        /// NetworkManager for server.
        /// </summary>
        [HideInInspector]
        public NetworkManager NetworkManager { get; private set; }
        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Authenticator for this ServerManager. May be null if not using authentication.")]
        [SerializeField]
        private Authenticator _authenticator;
        /// <summary>
        /// Authenticator for this ServerManager. May be null if not using authentication.
        /// </summary>
        [Obsolete("Use GetAuthenticator and SetAuthenticator.")]
        public Authenticator Authenticator
        {
            get => GetAuthenticator();
            set => SetAuthenticator(value);
        }
        /// <summary>
        /// Gets the Authenticator for this manager.
        /// </summary>
        /// <returns></returns>
        public Authenticator GetAuthenticator() => _authenticator;
        /// <summary>
        /// Gets the Authenticator for this manager, and initializes it.
        /// </summary>
        /// <returns></returns>
        public void SetAuthenticator(Authenticator value)
        {
            _authenticator = value;
            InitializeAuthenticator();
        }
        /// <summary>
        /// How to pack object spawns.
        /// </summary>
        [Tooltip("How to pack object spawns.")]
        [SerializeField]
        internal TransformPackingData SpawnPacking = new TransformPackingData()
        {
            Position = AutoPackType.Unpacked,
            Rotation = AutoPackType.PackedLess,
            Scale = AutoPackType.PackedLess
        };
        /// <summary>
        /// True to automatically set the frame rate when the client connects.
        /// </summary>
        [Tooltip("True to automatically set the frame rate when the client connects.")]
        [SerializeField]
        private bool _changeFrameRate = true;
        /// <summary>
        ///  
        /// </summary>
        [Tooltip("Maximum frame rate the server may run at. When as host this value runs at whichever is higher between client and server.")]
        [Range(1, NetworkManager.MAXIMUM_FRAMERATE)]
        [SerializeField]
        private ushort _frameRate = NetworkManager.MAXIMUM_FRAMERATE;
        /// <summary>
        /// Maximum frame rate the server may run at. When as host this value runs at whichever is higher between client and server.
        /// </summary>
        internal ushort FrameRate => (_changeFrameRate) ? _frameRate : (ushort)0;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to share the Ids of clients and the objects they own with other clients. No sensitive information is shared.")]
        [SerializeField]
        private bool _shareIds = true;
        /// <summary>
        /// True to share the Ids of clients and the objects they own with other clients. No sensitive information is shared.
        /// </summary>
        internal bool ShareIds => _shareIds;
        /// <summary>
        /// True to automatically start the server connection when running as headless.
        /// </summary>
        [Tooltip("True to automatically start the server connection when running as headless.")]
        [SerializeField]
        private bool _startOnHeadless = true;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to kick clients which send data larger than the MTU.")]
        [SerializeField]
        private bool _limitClientMTU = true;
        /// <summary>
        /// True to kick clients which send data larger than the MTU.
        /// </summary>
        internal bool LimitClientMTU => _limitClientMTU;
        #endregion

        #region Private.
        /// <summary>
        /// Used to read splits.
        /// </summary>
        private SplitReader _splitReader = new SplitReader();
#if UNITY_EDITOR || DEVELOPMENT_BUILD
        /// <summary>
        /// Logs data about parser to help debug.
        /// </summary>
        private ParseLogger _parseLogger = new ParseLogger();
#endif
        #endregion

        private void OnDestroy()
        {
            Objects?.SubscribeToSceneLoaded(false);
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnceInternal(NetworkManager manager)
        {
            NetworkManager = manager;
            Objects = new ServerObjects(manager);
            Objects.SubscribeToSceneLoaded(true);
            InitializeRpcLinks();
            //Unsubscribe first incase already subscribed.
            SubscribeToTransport(false);
            SubscribeToTransport(true);
            NetworkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;
            NetworkManager.SceneManager.OnClientLoadedStartScenes += SceneManager_OnClientLoadedStartScenes;

            if (_authenticator == null)
                _authenticator = GetComponent<Authenticator>();
            if (_authenticator != null)
                InitializeAuthenticator();
        }

        /// <summary>
        /// Initializes the authenticator to this manager.
        /// </summary>
        private void InitializeAuthenticator()
        {
            Authenticator auth = GetAuthenticator();
            if (auth == null || auth.Initialized)
                return;
            if (NetworkManager == null)
                return;

            auth.InitializeOnce(NetworkManager);
            auth.OnAuthenticationResult += _authenticator_OnAuthenticationResult;
        }

        /// <summary>
        /// Starts the server if configured to for headless.
        /// </summary>
        internal void StartForHeadless()
        {
            if (_startOnHeadless)
            {
                //Wrapping logic in check instead of everything so _startOnHeadless doesnt warn as unused in editor.
#if UNITY_SERVER
                StartConnection();
#endif
            }
        }

        /// <summary>
        /// Stops the local server connection.
        /// </summary>
        /// <param name="sendDisconnectMessage">True to send a disconnect message to all clients first.</param>
        public bool StopConnection(bool sendDisconnectMessage)
        {
            if (sendDisconnectMessage)
                SendDisconnectMessages(Clients.Values.ToList(), true);

            //Return stop connection result.
            return NetworkManager.TransportManager.Transport.StopConnection(true);
        }

        /// <summary>
        /// Sends a disconnect messge to connectionIds.
        /// This does not iterate outgoing automatically.
        /// </summary>
        /// <param name="connectionIds"></param>
        internal void SendDisconnectMessages(int[] connectionIds)
        {
            List<NetworkConnection> conns = new List<NetworkConnection>();
            foreach (int item in connectionIds)
            {
                if (Clients.TryGetValueIL2CPP(item, out NetworkConnection c))
                    conns.Add(c);
            }

            if (conns.Count > 0)
                SendDisconnectMessages(conns, false);
        }
        /// <summary>
        /// Sends a disconnect message to all clients and immediately iterates outgoing.
        /// </summary>
        private void SendDisconnectMessages(List<NetworkConnection> conns, bool iterate)
        {
            PooledWriter writer = WriterPool.GetWriter();
            writer.WritePacketId(PacketId.Disconnect);
            ArraySegment<byte> segment = writer.GetArraySegment();
            //Send segment to each client, authenticated or not.
            foreach (NetworkConnection c in conns)
                c.SendToClient((byte)Channel.Reliable, segment);
            //Recycle writer.
            writer.Dispose();

            if (iterate)
                NetworkManager.TransportManager.IterateOutgoing(true);
        }

        /// <summary>
        /// Starts the local server connection.
        /// </summary>
        public bool StartConnection()
        {
            return NetworkManager.TransportManager.Transport.StartConnection(true);
        }
        /// <summary>
        /// Starts the local server using port.
        /// </summary>
        /// <param name="port">Port to start on.</param>
        /// <returns></returns>
        public bool StartConnection(ushort port)
        {
            Transport t = NetworkManager.TransportManager.Transport;
            t.SetPort(port);
            return t.StartConnection(true);
        }

        /// <summary>
        /// Called after the local client connection state changes.
        /// </summary>
        private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
        {
            /* If client is doing anything but started destroy pending.
             * Pending is only used for host mode. */
            if (obj.ConnectionState != LocalConnectionState.Started)
                Objects.DestroyPending();
        }

        /// <summary>
        /// Called when a client loads initial scenes after connecting.
        /// </summary>
        private void SceneManager_OnClientLoadedStartScenes(NetworkConnection conn, bool asServer)
        {
            if (asServer)
            {
                Objects.RebuildObservers(conn);
                /* If connection is host then renderers must be hidden
                 * for all objects not visible to the host. The observer system
                 * does handle this but only after an initial state is set.
                 * If the clientHost joins without observation of an object
                 * then the initial state will never be set. */
                if (conn.IsLocalClient)
                {
                    foreach (NetworkObject nob in Objects.Spawned.Values)
                    {
                        if (!nob.Observers.Contains(conn))
                            nob.SetRenderersVisible(false);
                    }
                }
            }
        }

        /// <summary>
        /// Changes subscription status to transport.
        /// </summary>
        /// <param name="subscribe"></param>
        private void SubscribeToTransport(bool subscribe)
        {
            if (NetworkManager == null || NetworkManager.TransportManager == null || NetworkManager.TransportManager.Transport == null)
                return;

            if (!subscribe)
            {
                NetworkManager.TransportManager.Transport.OnServerReceivedData -= Transport_OnServerReceivedData;
                NetworkManager.TransportManager.Transport.OnServerConnectionState -= Transport_OnServerConnectionState;
                NetworkManager.TransportManager.Transport.OnRemoteConnectionState -= Transport_OnRemoteConnectionState;
            }
            else
            {
                NetworkManager.TransportManager.Transport.OnServerReceivedData += Transport_OnServerReceivedData;
                NetworkManager.TransportManager.Transport.OnServerConnectionState += Transport_OnServerConnectionState;
                NetworkManager.TransportManager.Transport.OnRemoteConnectionState += Transport_OnRemoteConnectionState;
            }
        }

        /// <summary>
        /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed.
        /// Server listens for this event automatically.
        /// </summary>
        private void _authenticator_OnAuthenticationResult(NetworkConnection conn, bool authenticated)
        {
            if (!authenticated)
                conn.Disconnect(false);
            else
                ClientAuthenticated(conn);
        }

        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        private void Transport_OnServerConnectionState(ServerConnectionStateArgs args)
        {
            /* Let the client manager know the server state is changing first.
             * This gives the client an opportunity to clean-up or prepare
             * before the server completes it's actions. */
            Started = AnyServerStarted();
            NetworkManager.ClientManager.Objects.OnServerConnectionState(args);
            //If no servers are started then reset match conditions.
            if (!Started)
                MatchCondition.ClearMatchesWithoutRebuilding();

            Objects.OnServerConnectionState(args);

            LocalConnectionState state = args.ConnectionState;

            if (NetworkManager.CanLog(LoggingType.Common))
            {
                Transport t = NetworkManager.TransportManager.GetTransport(args.TransportIndex);
                string tName = (t == null) ? "Unknown" : t.GetType().Name;
                Debug.Log($"Local server is {state.ToString().ToLower()} for {tName}.");
            }

            NetworkManager.UpdateFramerate();
            OnServerConnectionState?.Invoke(args);
        }

        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        private void Transport_OnRemoteConnectionState(RemoteConnectionStateArgs args)
        {
            //Sanity check to make sure transports are following proper types/ranges.
            int id = args.ConnectionId;
            int maxIdValue = short.MaxValue;
            if (id < 0 || id > maxIdValue)
            {
                NetworkManager.TransportManager.Transport.StopConnection(args.ConnectionId, true);
                NetworkManager.LogError($"The transport you are using supplied an invalid connection Id of {id}. Connection Id values must range between 0 and {maxIdValue}. The client has been disconnected.");
                return;
            }
            //Valid Id.
            else
            {
                //If started then add to authenticated clients.
                if (args.ConnectionState == RemoteConnectionState.Started)
                {
                    NetworkManager.Log($"Remote connection started for Id {id}.");
                    NetworkConnection conn = new NetworkConnection(NetworkManager, id);
                    Clients.Add(args.ConnectionId, conn);

                    OnRemoteConnectionState?.Invoke(conn, args);
                    //Connection is no longer valid. This can occur if the user changes the state using the OnRemoteConnectionState event.
                    if (!conn.IsValid)
                        return;
                    /* If there is an authenticator
                     * and the transport is not a local transport. */
                    Authenticator auth = GetAuthenticator();
                    if (auth != null && !NetworkManager.TransportManager.IsLocalTransport(id))
                        auth.OnRemoteConnection(conn);
                    else
                        ClientAuthenticated(conn);
                }
                //If stopping.
                else if (args.ConnectionState == RemoteConnectionState.Stopped)
                {
                    /* If client's connection is found then clean
                     * them up from server. */
                    if (Clients.TryGetValueIL2CPP(id, out NetworkConnection conn))
                    {
                        conn.SetDisconnecting(true);
                        OnRemoteConnectionState?.Invoke(conn, args);
                        Clients.Remove(id);
                        MatchCondition.RemoveFromMatchWithoutRebuild(conn, NetworkManager);
                        Objects.ClientDisconnected(conn);
                        BroadcastClientConnectionChange(false, conn);
                        conn.Reset();

                        NetworkManager.Log($"Remote connection stopped for Id {id}.");
                    }
                }
            }
        }

        /// <summary>
        /// Sends client their connectionId.
        /// </summary>
        /// <param name="connectionid"></param>
        private void SendAuthenticated(NetworkConnection conn)
        {
            using (PooledWriter writer = WriterPool.GetWriter())
            {
                writer.WritePacketId(PacketId.Authenticated);
                writer.WriteNetworkConnection(conn);
                NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, writer.GetArraySegment(), conn);
            }
        }
        /// <summary>
        /// Called when the server socket receives data.
        /// </summary>
        private void Transport_OnServerReceivedData(ServerReceivedDataArgs args)
        {
            ParseReceived(args);
        }

        /// <summary>
        /// Called when the server receives data.
        /// </summary>
        /// <param name="args"></param>
        private void ParseReceived(ServerReceivedDataArgs args)
        {
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            _parseLogger.Reset();
#endif

            //Not from a valid connection.
            if (args.ConnectionId < 0)
                return;
            ArraySegment<byte> segment = args.Data;
            NetworkManager.StatisticsManager.NetworkTraffic.LocalServerReceivedData((ulong)segment.Count);
            if (segment.Count <= TransportManager.TICK_BYTES)
                return;

            //FishNet internally splits packets so nothing should ever arrive over MTU.
            int channelMtu = NetworkManager.TransportManager.Transport.GetMTU((byte)args.Channel);
            //If over MTU kick client immediately.
            if (segment.Count > channelMtu && !NetworkManager.TransportManager.IsLocalTransport(args.ConnectionId))
            {
                ExceededMTUKick();
                return;
            }

            PacketId packetId = PacketId.Unset;
#if !UNITY_EDITOR && !DEVELOPMENT_BUILD
            try
            {
#endif
            using (PooledReader reader = ReaderPool.GetReader(segment, NetworkManager))
            {
                uint tick = reader.ReadUInt32(AutoPackType.Unpacked);
                NetworkManager.TimeManager.LastPacketTick = tick;
                /* This is a special condition where a message may arrive split.
                * When this occurs buffer each packet until all packets are
                * received. */
                if (reader.PeekPacketId() == PacketId.Split)
                {
                    //Skip packetId.
                    reader.ReadPacketId();

                    int expectedMessages;
                    _splitReader.GetHeader(reader, out expectedMessages);
                    //If here split message can be written.
                    _splitReader.Write(NetworkManager.TimeManager.LastPacketTick, reader, expectedMessages);

                    /* If fullMessage returns 0 count then the split
                     * has not written fully yet. Otherwise, if there is
                     * data within then reinitialize reader with the
                     * full message. */
                    ArraySegment<byte> fullMessage = _splitReader.GetFullMessage();
                    if (fullMessage.Count == 0)
                        return;

                    /* If here then all data has been received.
                     * It's possible the client could have exceeded 
                     * maximum MTU but not the maximum number of splits.
                     * This is because the length of each split
                     * is not written, so we don't know how much data of the
                     * final message actually belonged to the split vs
                     * unrelated data added afterwards. We're going to cut
                     * the client some slack in this situation for the sake
                     * of keeping things simple. */
                    //Initialize reader with full message.
                    reader.Initialize(fullMessage, NetworkManager);
                }

                //Parse reader.
                while (reader.Remaining > 0)
                {
                    packetId = reader.ReadPacketId();
#if UNITY_EDITOR || DEVELOPMENT_BUILD
                    _parseLogger.AddPacket(packetId);
#endif
                    NetworkConnection conn;

                    /* Connection isn't available. This should never happen.
                     * Force an immediate disconnect. */
                    if (!Clients.TryGetValueIL2CPP(args.ConnectionId, out conn))
                    {
                        if (NetworkManager.CanLog(LoggingType.Common))
                            Debug.LogError($"ConnectionId {conn.ClientId} not found within Clients. Connection will be kicked immediately.");
                        NetworkManager.TransportManager.Transport.StopConnection(args.ConnectionId, true);
                        return;
                    }
                    conn.LastPacketTick = tick;
                    /* If connection isn't authenticated and isn't a broadcast
                     * then disconnect client. If a broadcast then process
                     * normally; client may still become disconnected if the broadcast
                     * does not allow to be called while not authenticated. */
                    if (!conn.Authenticated && packetId != PacketId.Broadcast)
                    {
                        if (NetworkManager.CanLog(LoggingType.Common))
                            Debug.LogError($"ConnectionId {conn.ClientId} send a Broadcast without being authenticated. Connection will be kicked immediately.");
                        conn.Disconnect(true);
                        return;
                    }

                    if (packetId == PacketId.Replicate)
                    {
                        Objects.ParseReplicateRpc(reader, conn, args.Channel);
                    }
                    else if (packetId == PacketId.ServerRpc)
                    {
                        Objects.ParseServerRpc(reader, conn, args.Channel);
                    }
                    else if (packetId == PacketId.Broadcast)
                    {
                        ParseBroadcast(reader, conn, args.Channel);
                    }
                    else if (packetId == PacketId.PingPong)
                    {
                        ParsePingPong(reader, conn);
                    }
                    else
                    {
                        if (NetworkManager.CanLog(LoggingType.Error))
                        {
#if UNITY_EDITOR || DEVELOPMENT_BUILD
                            Debug.LogError($"Server received an unhandled PacketId of {(ushort)packetId} from connectionId {args.ConnectionId}. Remaining data has been purged.");
                            _parseLogger.Print(NetworkManager);
#else
                            Debug.LogError($"Server received an unhandled PacketId of {(ushort)packetId} from connectionId {args.ConnectionId}. Connection will be kicked immediately.");
                            NetworkManager.TransportManager.Transport.StopConnection(args.ConnectionId, true);
#endif
                        }
                        return;
                    }
                }
            }
#if !UNITY_EDITOR && !DEVELOPMENT_BUILD
            }
            catch (Exception e)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Server encountered an error while parsing data for packetId {packetId} from connectionId {args.ConnectionId}. Connection will be kicked immediately. Message: {e.Message}.");
                //Kick client immediately.
                NetworkManager.TransportManager.Transport.StopConnection(args.ConnectionId, true);
            }
#endif

            //Kicks connection for exceeding MTU.
            void ExceededMTUKick()
            {
                NetworkManager.TransportManager.Transport.StopConnection(args.ConnectionId, true);
                if (NetworkManager.CanLog(LoggingType.Common))
                    Debug.Log($"ConnectionId {args.ConnectionId} sent a message larger than allowed amount. Connection will be kicked immediately.");
            }

        }

        /// <summary>
        /// Parses a received PingPong.
        /// </summary>
        /// <param name="reader"></param>
        /// <param name="conn"></param>
        private void ParsePingPong(PooledReader reader, NetworkConnection conn)
        {
            /* //security limit how often clients can send pings.
             * have clients use a stopwatch rather than frame time
             * for checks to ensure it's not possible to send
             * excessively should their game stutter then catch back up. */
            uint clientTick = reader.ReadUInt32(AutoPackType.Unpacked);
            if (conn.CanPingPong())
                NetworkManager.TimeManager.SendPong(conn, clientTick);
        }

        /// <summary>
        /// Called when a remote client authenticates with the server.
        /// </summary>
        /// <param name="connectionId"></param>
        private void ClientAuthenticated(NetworkConnection connection)
        {
            /* Immediately send connectionId to client. Some transports
            * don't give clients their remoteId, therefor it has to be sent
            * by the ServerManager. This packet is very simple and can be built
            * on the spot. */
            connection.ConnectionAuthenticated();
            /* Send client Ids before telling the client
             * they are authenticated. This is important because when the client becomes
             * authenticated they set their LocalConnection using Clients field in ClientManager,
             * which is set after getting Ids. */
            BroadcastClientConnectionChange(true, connection);
            SendAuthenticated(connection);

            OnAuthenticationResult?.Invoke(connection, true);
            NetworkManager.SceneManager.OnClientAuthenticated(connection);
        }

        /// <summary>
        /// Sends a client connection state change.
        /// </summary>
        /// <param name="connected"></param>
        /// <param name="id"></param>
        private void BroadcastClientConnectionChange(bool connected, NetworkConnection conn)
        {
            //If sharing Ids then send all connected client Ids first if is a connected state.
            if (ShareIds)
            {
                /* Send a broadcast to all authenticated clients with the clientId
                 * that just connected. The conn client will also get this. */
                ClientConnectionChangeBroadcast changeMsg = new ClientConnectionChangeBroadcast()
                {
                    Connected = connected,
                    Id = conn.ClientId
                };
                Broadcast(changeMsg);

                /* If state is connected then the conn client
                 * must also receive all currently connected client ids. */
                if (connected)
                {
                    //Send already connected clients to the connection that just joined.
                    ListCache<int> lc = ListCaches.IntCache;
                    lc.Reset();
                    foreach (int key in Clients.Keys)
                        lc.AddValue(key);

                    ConnectedClientsBroadcast allMsg = new ConnectedClientsBroadcast()
                    {
                        ListCache = lc
                    };
                    conn.Broadcast(allMsg);
                }
            }
            //If not sharing Ids then only send ConnectionChange to conn.
            else
            {
                if (connected)
                {
                    /* Send broadcast only to the client which just disconnected.
                     * Only send if connecting. If the client is disconnected there's no reason
                     * to send them a disconnect msg. */
                    ClientConnectionChangeBroadcast changeMsg = new ClientConnectionChangeBroadcast()
                    {
                        Connected = connected,
                        Id = conn.ClientId
                    };
                    Broadcast(conn, changeMsg, true, Channel.Reliable);
                }
            }

        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Managing/Statistic/NetworkTrafficArgs.cs ---
namespace FishNet.Managing.Statistic
{

    public struct NetworkTrafficArgs
    {
        /// <summary>
        /// Number of bytes sent to the server.
        /// </summary>
        public readonly ulong ToServerBytes;
        /// <summary>
        /// Number of bytes sent by the server.
        /// </summary>
        public readonly ulong FromServerBytes;

        public NetworkTrafficArgs(ulong toServerBytes, ulong fromServerBytes)
        {
            ToServerBytes = toServerBytes;
            FromServerBytes = fromServerBytes;
        }
    }
}
'''
'''--- Assets/FishNet/Runtime/Managing/Statistic/NetworkTrafficStatistics.cs ---

using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Statistic
{
    [System.Serializable]
    public class NetworkTraficStatistics
    {
        #region Public.
        /// <summary>
        /// Called when NetworkTraffic is updated for the client.
        /// </summary>
        public event Action<NetworkTrafficArgs> OnClientNetworkTraffic;
        /// <summary>
        /// Called when NetworkTraffic is updated for the server.
        /// </summary>
        public event Action<NetworkTrafficArgs> OnServerNetworkTraffic;
        #endregion

        #region Serialized.
        /// <summary>
        /// How often to update traffic statistics.
        /// </summary>
        [Tooltip("How often to update traffic statistics.")]
        [SerializeField]
        [Range(0f, 10f)]
        private float _updateInteval = 1f;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to update client statistics.")]
        [SerializeField]
        private bool _updateClient;
        /// <summary>
        /// True to update client statistics.
        /// </summary>
        public bool UpdateClient
        {
            get => _updateClient;
            private set => _updateClient = value;
        }
        /// <summary>
        /// Sets UpdateClient value.
        /// </summary>
        /// <param name="update"></param>
        public void SetUpdateClient(bool update)
        {
            UpdateClient = update;
        }
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to update server statistics.")]
        [SerializeField]
        private bool _updateServer;
        /// <summary>
        /// True to update client statistics.
        /// </summary>
        public bool UpdateServer
        {
            get => _updateServer;
            private set => _updateServer = value;
        }
        /// <summary>
        /// Sets UpdateServer value.
        /// </summary>
        /// <param name="update"></param>
        public void SetUpdateServer(bool update)
        {
            UpdateServer = update;
        }
        #endregion

        #region Private.
        /// <summary>
        /// NetworkManager for this statistics.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Bytes sent to the server from local client.
        /// </summary>
        private ulong _client_toServerBytes;
        /// <summary>
        /// Bytes received on the local client from the server.
        /// </summary>
        private ulong _client_fromServerBytes;
        /// <summary>
        /// Bytes sent to all clients from the local server.
        /// </summary>
        private ulong _server_toClientsBytes;
        /// <summary>
        /// Bytes received on the local server from all clients.
        /// </summary>
        private ulong _server_fromClientsBytes;
        /// <summary>
        /// Next time network traffic updates may invoke.
        /// </summary>
        private float _nextUpdateTime;
        /// <summary>
        /// Size suffixes as text.
        /// </summary>
        private static readonly string[] _sizeSuffixes = { "bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB" };
        #endregion

        internal void InitializeOnceInternal(NetworkManager manager)
        {
            _networkManager = manager;
            manager.TimeManager.OnPreTick += TimeManager_OnPreTick;
        }

        /// <summary>
        /// Called before the TimeManager ticks.
        /// </summary>
        private void TimeManager_OnPreTick()
        {
            if (Time.unscaledTime < _nextUpdateTime)
                return;
            _nextUpdateTime = Time.unscaledTime + _updateInteval;

            if (UpdateClient && _networkManager.IsClient)
                OnClientNetworkTraffic?.Invoke(new NetworkTrafficArgs(_client_toServerBytes, _client_fromServerBytes));
            if (UpdateServer && _networkManager.IsServer)
                OnServerNetworkTraffic?.Invoke(new NetworkTrafficArgs(_server_fromClientsBytes, _server_toClientsBytes));

            _client_toServerBytes = 0;
            _client_fromServerBytes = 0;
            _server_toClientsBytes = 0;
            _server_fromClientsBytes = 0;
        }

        /// <summary>
        /// Called when the local client sends data.
        /// </summary>
        internal void LocalClientSentData(ulong dataLength)
        {
            _client_toServerBytes = Math.Min(_client_toServerBytes + dataLength, ulong.MaxValue);
        }
        /// <summary>
        /// Called when the local client receives data.
        /// </summary>
        public void LocalClientReceivedData(ulong dataLength)
        {
            _client_fromServerBytes = Math.Min(_client_fromServerBytes + dataLength, ulong.MaxValue);
        }

        /// <summary>
        /// Called when the local client sends data.
        /// </summary>
        internal void LocalServerSentData(ulong dataLength)
        {
            _server_toClientsBytes = Math.Min(_server_toClientsBytes + dataLength, ulong.MaxValue);
        }
        /// <summary>
        /// Called when the local client receives data.
        /// </summary>
        public void LocalServerReceivedData(ulong dataLength)
        {
            _server_fromClientsBytes = Math.Min(_server_fromClientsBytes + dataLength, ulong.MaxValue);
        }

        //Attribution: https://stackoverflow.com/questions/14488796/does-net-provide-an-easy-way-convert-bytes-to-kb-mb-gb-etc
        /// <summary>
        /// Formats passed in bytes value to the largest possible data type with 2 decimals.
        /// </summary>
        public static string FormatBytesToLargest(ulong bytes)
        {
            int decimalPlaces = 2;
            if (bytes == 0)
            {
                decimalPlaces = 0;
                return string.Format("{0:n" + decimalPlaces + "} bytes", 0);
            }

            // mag is 0 for bytes, 1 for KB, 2, for MB, etc.
            int mag = (int)Math.Log(bytes, 1024);

            // 1L << (mag * 10) == 2 ^ (10 * mag) 
            // [i.e. the number of bytes in the unit corresponding to mag]
            decimal adjustedSize = (decimal)bytes / (1L << (mag * 10));

            // make adjustment when the value is large enough that
            // it would round up to 1000 or more
            if (Math.Round(adjustedSize, decimalPlaces) >= 1000)
            {
                mag += 1;
                adjustedSize /= 1024;
            }

            //Don't show decimals for bytes.
            if (mag == 0)
                decimalPlaces = 0;

            return string.Format("{0:n" + decimalPlaces + "} {1}", adjustedSize, _sizeSuffixes[mag]);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Statistic/StatisticsManager.cs ---
using UnityEngine;

namespace FishNet.Managing.Statistic
{

    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/StatisticsManager")]
    public class StatisticsManager : MonoBehaviour
    {
        /// <summary>
        /// Statistics for NetworkTraffic.
        /// </summary>
        public NetworkTraficStatistics NetworkTraffic = new NetworkTraficStatistics();

        internal void InitializeOnceInternal(NetworkManager manager)
        {
            NetworkTraffic.InitializeOnceInternal(manager);
        }
  
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Timing/Editor/TimeManagerEditor.cs ---
﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Timing.Editing
{

    [CustomEditor(typeof(TimeManager), true)]
    [CanEditMultipleObjects]
    public class TimeManagerEditor : Editor
    {
        private SerializedProperty _tickRate;
        private SerializedProperty _allowTickDropping;
        private SerializedProperty _maximumFrameTicks;
        private SerializedProperty _pingInterval;
        private SerializedProperty _timingInterval;
        private SerializedProperty _physicsMode;
        private SerializedProperty _maximumBufferedInputs;

        protected virtual void OnEnable()
        {
            _tickRate = serializedObject.FindProperty("_tickRate");
            _allowTickDropping = serializedObject.FindProperty("_allowTickDropping");
            _maximumFrameTicks = serializedObject.FindProperty("_maximumFrameTicks");
            _pingInterval = serializedObject.FindProperty("_pingInterval");
            _timingInterval = serializedObject.FindProperty("_timingInterval");
            _physicsMode = serializedObject.FindProperty("_physicsMode");
            _maximumBufferedInputs = serializedObject.FindProperty("_maximumBufferedInputs");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((TimeManager)target), typeof(TimeManager), false);
            GUI.enabled = true;

            //Timing.
            EditorGUILayout.LabelField("Timing", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_allowTickDropping);
            if (_allowTickDropping.boolValue == true)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_maximumFrameTicks);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.PropertyField(_tickRate);
            EditorGUILayout.PropertyField(_pingInterval);
            EditorGUILayout.PropertyField(_timingInterval);            
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Physics.
            EditorGUILayout.LabelField("Physics", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_physicsMode);
            if (_physicsMode.intValue != (int)FishNet.Managing.Timing.PhysicsMode.TimeManager)
                EditorGUILayout.HelpBox("If you are using physics interactions be sure to change the PhysicsMode to TimeManager and implement physics within the TimeManager tick events.", MessageType.None);
            EditorGUI.indentLevel--;

            //Prediction.
            EditorGUILayout.LabelField("Prediction", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_maximumBufferedInputs);
            EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }
    }

}
#endif
'''
'''--- Assets/FishNet/Runtime/Managing/Timing/MovingAverage.cs ---
﻿using FishNet.Documenting;
using System;
using UnityEngine;

namespace FishNet.Managing.Timing
{

    [APIExclude]
    public class MovingAverage
    {
        #region Public.
        /// <summary>
        /// Average from samples favoring the most recent sample.
        /// </summary>
        public float Average { get; private set; }
        #endregion

        /// <summary>
        /// Next index to write a sample to.
        /// </summary>
        private int _writeIndex;
        /// <summary>
        /// Collected samples.
        /// </summary>
        private float[] _samples;
        /// <summary>
        /// Number of samples written. Will be at most samples size.
        /// </summary>
        private int _writtenSamples;
        /// <summary>
        /// Samples accumulated over queue.
        /// </summary>
        private float _sampleAccumulator;

        public MovingAverage(int sampleSize)
        {
            if (sampleSize < 0)
            { 
                sampleSize = 0;
            }
            else if (sampleSize < 2)
            {
                if (NetworkManager.StaticCanLog(Logging.LoggingType.Warning))
                    Debug.LogWarning("Using a sampleSize of less than 2 will always return the most recent value as Average.");
            }
            
            _samples = new float[sampleSize];
        }

        /// <summary>
        /// Computes a new windowed average each time a new sample arrives
        /// </summary>
        /// <param name="newSample"></param>
        public void ComputeAverage(float newSample)
        {
            if (_samples.Length <= 1)
            {
                Average = newSample;
                return;
            }

            _sampleAccumulator += newSample;
            _samples[_writeIndex] = newSample;

            //Increase writeIndex.
            _writeIndex++;
            _writtenSamples = Math.Max(_writtenSamples, _writeIndex);
            if (_writeIndex >= _samples.Length)
                _writeIndex = 0;

            Average = _sampleAccumulator / _writtenSamples;

            /* If samples are full then drop off
            * the oldest sample. This will always be
            * the one just after written. The entry isn't
            * actually removed from the array but will
            * be overwritten next sample. */
            if (_writtenSamples >= _samples.Length)
                _sampleAccumulator -= _samples[_writeIndex];

        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Timing/PhysicsMode.cs ---
﻿namespace FishNet.Managing.Timing
{
    /// <summary>
    /// How to simulate physics.
    /// </summary>
    public enum PhysicsMode
    {
        /// <summary>
        /// Unity performs physics every FixedUpdate.
        /// </summary>
        Unity = 0,
        /// <summary>
        /// TimeManager performs physics each tick.
        /// </summary>
        TimeManager = 1,
        /// <summary>
        /// Physics will be disabled.
        /// </summary>
        Disabled = 2
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Timing/PreciseTick.cs ---
﻿using FishNet.Serializing;
using FishNet.Utility.Extension;
using System;
using UnityEngine;

namespace FishNet.Managing.Timing
{

    public struct PreciseTick
    {
        /// <summary>
        /// The current tick.
        /// </summary>
        public uint Tick;
        /// <summary>
        /// Percentage into the next tick.
        /// </summary>
        public double Percent;

        public PreciseTick(uint tick, double percent)
        {
            Tick = tick;
            Percent = percent;
        }
    }

    public static class PreciseTickSerializer
    {
        public static void WritePreciseTick(this Writer writer, PreciseTick value)
        {
            writer.WriteUInt32(value.Tick, AutoPackType.Unpacked);
            /* No reason percent should exist beyond these values, but better to be safe.
             * There is also no double clamp in Unity so... */
            double percent = MathFN.ClampDouble(value.Percent, 0d, 1f);
            byte percentByte = (byte)(percent * 100);
            writer.WriteByte(percentByte);
        }

        public static PreciseTick ReadPreciseTick(this Reader reader)
        {
            uint tick = reader.ReadUInt32(AutoPackType.Unpacked);
            byte percentByte = reader.ReadByte();
            double percent = MathFN.ClampDouble((percentByte / 100f), 0d, 1d);
            return new PreciseTick(tick, percent);
        }
    }
}
'''
'''--- Assets/FishNet/Runtime/Managing/Timing/SceneComparer.cs ---
﻿using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Timing
{
	internal sealed class SceneHandleEqualityComparer : EqualityComparer<Scene>
	{
		public override bool Equals(Scene a, Scene b)
		{
			return (a.handle == b.handle);
		}

        public override int GetHashCode(Scene obj)
        {
			return obj.handle;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Managing/Timing/TickRounding.cs ---
﻿namespace FishNet.Managing.Timing
{
    /// <summary>
    /// How ticks are rounded when using time.
    /// </summary>
    public enum TickRounding
    {
        /// <summary>
        /// Rounds up.
        /// </summary>
        RoundUp,
        /// <summary>
        /// Rounds down.
        /// </summary>
        RoundDown,
        /// <summary>
        /// Rounds to the nearest whole.
        /// </summary>
        RoundNearest
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Timing/TickType.cs ---
﻿namespace FishNet.Managing.Timing
{
    public enum TickType : byte
    {
        Tick = 0,
        LocalTick = 1,
        LastPacketTick = 2
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Timing/TimeManager.cs ---
﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility;
using FishNet.Utility.Extension;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using SystemStopwatch = System.Diagnostics.Stopwatch;
using UnityScene = UnityEngine.SceneManagement.Scene;

namespace FishNet.Managing.Timing
{

    /// <summary>
    /// Provides data and actions for network time and tick based systems.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/TimeManager")]
    public sealed partial class TimeManager : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called before performing a reconcile on NetworkBehaviour.
        /// </summary>
        public event Action<NetworkBehaviour> OnPreReconcile;
        /// <summary>
        /// Called after performing a reconcile on a NetworkBehaviour.
        /// </summary>
        public event Action<NetworkBehaviour> OnPostReconcile;
        /// <summary>
        /// Called before physics is simulated when replaying a replicate method.
        /// Contains the PhysicsScene and PhysicsScene2D which was simulated.
        /// </summary>
        public event Action<PhysicsScene, PhysicsScene2D> OnPreReplicateReplay;
        /// <summary>
        /// Called after physics is simulated when replaying a replicate method.
        /// Contains the PhysicsScene and PhysicsScene2D which was simulated.
        /// </summary>
        public event Action<PhysicsScene, PhysicsScene2D> OnPostReplicateReplay;
        /// <summary>
        /// Called right before a tick occurs, as well before data is read.
        /// </summary>
        public event Action OnPreTick;
        /// <summary>
        /// Called when a tick occurs.
        /// </summary>
        public event Action OnTick;
        /// <summary>
        /// When using TimeManager for physics timing, this is called immediately before physics simulation will occur for the tick.
        /// While using Unity for physics timing, this is called during FixedUpdate.
        /// This may be useful if you wish to run physics differently for stacked scenes.
        /// </summary>
        [Obsolete("Use OnPrePhysicsSimulation.")] //Remove on 2023/01/01
        public event Action<float> OnPhysicsSimulation;
        /// <summary>
        /// When using TimeManager for physics timing, this is called immediately before physics simulation will occur for the tick.
        /// While using Unity for physics timing, this is called during FixedUpdate.
        /// This may be useful if you wish to run physics differently for stacked scenes.
        /// </summary>
        public event Action<float> OnPrePhysicsSimulation;
        /// <summary>
        /// When using TimeManager for physics timing, this is called immediately after the physics simulation has occured for the tick.
        /// While using Unity for physics timing, this is called during Update, only if a physics frame.
        /// This may be useful if you wish to run physics differently for stacked scenes.
        /// </summary>
        public event Action<float> OnPostPhysicsSimulation;
        /// <summary>
        /// Called after a tick occurs; physics would have simulated if using PhysicsMode.TimeManager.
        /// </summary>
        public event Action OnPostTick;
        /// <summary>
        /// Called when MonoBehaviours call Update.
        /// </summary>
        public event Action OnUpdate;
        /// <summary>
        /// Called when MonoBehaviours call LateUpdate.
        /// </summary>
        public event Action OnLateUpdate;
        /// <summary>
        /// Called when MonoBehaviours call FixedUpdate.
        /// </summary>
        public event Action OnFixedUpdate;
        /// <summary>
        /// RoundTripTime in milliseconds. This value includes latency from the tick rate.
        /// </summary>
        public long RoundTripTime { get; private set; }
        /// <summary>
        /// True if the number of frames per second are less than the number of expected ticks per second.
        /// </summary>
        internal bool LowFrameRate => ((Time.unscaledTime - _lastMultipleTicksTime) < 1f);
        /// <summary>
        /// Tick on the last received packet, be it from server or client.
        /// </summary>
        public uint LastPacketTick { get; internal set; }
        /// <summary>
        /// Last tick any object reconciled.
        /// </summary>
        public uint LastReconcileTick { get; internal set; }
        /// <summary>
        /// Last tick any object replicated.
        /// </summary>
        public uint LastReplicateTick { get; internal set; }
        /// <summary>
        /// Current approximate network tick as it is on server.
        /// When running as client only this is an approximation to what the server tick is.
        /// The value of this field may increase and decrease as timing adjusts.
        /// This value is reset upon disconnecting.
        /// Tick can be used to get the server time by using TicksToTime().
        /// Use LocalTick for values that only increase.
        /// </summary>
        public uint Tick { get; internal set; }
        /// <summary>
        /// Percentage as 0-100 of how much into next tick the time is.
        /// </summary>
        [Obsolete("Use GetPreciseTick or GetTickPercent instead.")] //Remove on 2023/01/01
        public byte TickPercent
        {
            get
            {
                if (_networkManager == null)
                    return 0;

                double delta = (_networkManager.IsServer) ? TickDelta : _adjustedTickDelta;
                double percent = (_elapsedTickTime / delta) * 100;
                return (byte)Mathf.Clamp((float)percent, 0, 100);
            }
        }
        /// <summary>
        /// A fixed deltaTime for TickRate.
        /// </summary>
        [HideInInspector]
        public double TickDelta { get; private set; }
        /// <summary>
        /// True if the TimeManager will or has ticked this frame.
        /// </summary>
        public bool FrameTicked { get; private set; }
        /// <summary>
        /// How long the local server has been connected.
        /// </summary>
        public float ServerUptime { get; private set; }
        /// <summary>
        /// How long the local client has been connected.
        /// </summary>
        public float ClientUptime { get; private set; }
        /// <summary>
        /// 
        /// </summary>
        private bool _isReplaying;
        /// <summary>
        /// Returns if any prediction is replaying.
        /// </summary>
        /// <returns></returns>
        public bool IsReplaying() => _isReplaying;
        /// <summary>
        /// Returns if scene is replaying.
        /// </summary>
        /// <param name="scene"></param>
        /// <returns></returns>
        public bool IsReplaying(UnityScene scene) => _replayingScenes.Contains(scene);
        /// <summary>
        /// True if any predictions are replaying.
        /// </summary>
        #endregion

        #region Serialized.
        /// <summary>
        /// While true clients may drop local ticks if their devices are unable to maintain the tick rate.
        /// This could result in a temporary desynchronization but will prevent the client falling further behind on ticks by repeatedly running the logic cycle multiple times per frame.
        /// </summary>
        [Tooltip("While true clients may drop local ticks if their devices are unable to maintain the tick rate. This could result in a temporary desynchronization but will prevent the client falling further behind on ticks by repeatedly running the logic cycle multiple times per frame.")]
        [SerializeField]
        private bool _allowTickDropping;
        /// <summary>
        /// Maximum number of ticks which may occur in a single frame before remainder are dropped for the frame.
        /// </summary>
        [Tooltip("Maximum number of ticks which may occur in a single frame before remainder are dropped for the frame.")]
        [Range(1, 25)]
        [SerializeField]
        private byte _maximumFrameTicks = 3;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("How many times per second the server will simulate. This does not limit server frame rate.")]
        [Range(1, 240)]
        [SerializeField]
        private ushort _tickRate = 30;
        /// <summary>
        /// How many times per second the server will simulate. This does not limit server frame rate.
        /// </summary>
        public ushort TickRate { get => _tickRate; private set => _tickRate = value; }
        /// <summary>
        /// 
        /// </summary>        
        [Tooltip("How often in seconds to a connections ping. This is also responsible for approximating server tick. This value does not affect prediction.")]
        [Range(1, 15)]
        [SerializeField]
        private byte _pingInterval = 1;
        /// <summary>
        /// How often in seconds to a connections ping. This is also responsible for approximating server tick. This value does not affect prediction.
        /// </summary>
        internal byte PingInterval => _pingInterval;
        /// <summary>
        /// How often in seconds to update prediction timing. Lower values will result in marginally more accurate timings at the cost of bandwidth.
        /// </summary>        
        [Tooltip("How often in seconds to update prediction timing. Lower values will result in marginally more accurate timings at the cost of bandwidth.")]
        [Range(1, 15)]
        [SerializeField]
        private byte _timingInterval = 2;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("How to perform physics.")]
        [SerializeField]
        private PhysicsMode _physicsMode = PhysicsMode.Unity;
        /// <summary>
        /// How to perform physics.
        /// </summary>
        public PhysicsMode PhysicsMode => _physicsMode;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Maximum number of buffered inputs which will be accepted from client before old inputs are discarded.")]
        [Range(1, 100)]
        [SerializeField]
        private byte _maximumBufferedInputs = 15;
        /// <summary>
        /// Maximum number of buffered inputs which will be accepted from client before old inputs are discarded.
        /// </summary>
        public byte MaximumBufferedInputs => _maximumBufferedInputs;
        #endregion

        #region Private.
        /// <summary>
        /// Scenes which are currently replaying prediction.
        /// </summary>
        private HashSet<UnityScene> _replayingScenes = new HashSet<UnityScene>(new SceneHandleEqualityComparer());
        /// <summary>
        /// Ticks that have passed on client since the last time server sent an UpdateTicksBroadcast.
        /// </summary>
        private uint _clientTicks = 0;
        /// <summary>
        /// Last Tick the server sent out UpdateTicksBroadcast.
        /// </summary>
        private uint _lastUpdateTicks = 0;
        /// <summary>
        /// 
        /// </summary>
        private uint _localTick;
        /// <summary>
        /// A tick that is not synchronized. This value will only increment. May be used for indexing or Ids with custom logic.
        /// When called on the server Tick is returned, otherwise LocalTick is returned.
        /// This value resets upon disconnecting.
        /// </summary>
        public uint LocalTick
        {
            get => (_networkManager.IsServer) ? Tick : _localTick;
            private set => _localTick = value;
        }
        /// <summary>
        /// Stopwatch used for pings.
        /// </summary>
        SystemStopwatch _pingStopwatch = new SystemStopwatch();
        /// <summary>
        /// Ticks passed since last ping.
        /// </summary>
        private uint _pingTicks;
        /// <summary>
        /// MovingAverage instance used to calculate mean ping.
        /// </summary>
        private MovingAverage _pingAverage = new MovingAverage(5);
        /// <summary>
        /// Time elapsed after ticks. This is extra time beyond the simulation rate.
        /// </summary>
        private double _elapsedTickTime;
        /// <summary>
        /// NetworkManager used with this.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Internal deltaTime for clients. Controlled by the server.
        /// </summary>
        private double _adjustedTickDelta;
        /// <summary>
        /// Range which client timing may reside within.
        /// </summary>
        private double[] _clientTimingRange;
        /// <summary>
        /// Last frame an iteration occurred for incoming.
        /// </summary>
        private int _lastIncomingIterationFrame = -1;
        /// <summary>
        /// True if client received Pong since last ping.
        /// </summary>
        private bool _receivedPong = true;
        /// <summary>
        /// Last unscaledTime multiple ticks occurred in a single frame.
        /// </summary>
        private float _lastMultipleTicksTime;
        /// <summary>
        /// Number of times ticks would have increased last frame.
        /// </summary>
        private int _lastTicksCount;
        /// <summary>
        /// Number of TimeManagers open which are using manual physics.
        /// </summary>
        private static uint _manualPhysics;
        #endregion

        #region Const.
        /// <summary>
        /// Maximum percentage timing may vary from SimulationInterval for clients.
        /// </summary>
        private const float CLIENT_TIMING_PERCENT_RANGE = 0.5f;
        /// <summary>
        /// Percentage of TickDelta client will adjust when needing to speed up.
        /// </summary>
        private const double CLIENT_SPEEDUP_PERCENT = 0.003d;
        /// <summary>
        /// Percentage of TickDelta client will adjust when needing to slow down.
        /// </summary>
        private const double CLIENT_SLOWDOWN_PERCENT = 0.005d;
        /// <summary>
        /// When steps to be sent to clients are equal to or higher than this value in either direction a reset steps will be sent.
        /// </summary>
        private const byte RESET_STEPS_THRESHOLD = 5;
        /// <summary>
        /// Playerprefs string to load and save user fixed time.
        /// </summary>
        private const string SAVED_FIXED_TIME_TEXT = "SavedFixedTimeFN";
        #endregion
        private void OnEnable()
        {
            UnityEngine.SceneManagement.SceneManager.sceneUnloaded += SceneManager_sceneUnloaded;
        }

#if UNITY_EDITOR
        private void OnDisable()
        {
            UnityEngine.SceneManagement.SceneManager.sceneUnloaded -= SceneManager_sceneUnloaded;

            //If closing/stopping.
            if (ApplicationState.IsQuitting())
            {
                _manualPhysics = 0;
                UnsetSimulationSettings();
            }
            else if (PhysicsMode == PhysicsMode.TimeManager)
            {
                _manualPhysics = Math.Max(0, _manualPhysics - 1);
            }
        }
#endif

        /// <summary>
        /// Called when FixedUpdate ticks. This is called before any other script.
        /// </summary>
        internal void TickFixedUpdate()
        {
            OnFixedUpdate?.Invoke();
            /* Invoke onsimulation if using Unity time.
             * Otherwise let the tick cycling part invoke. */
            if (PhysicsMode == PhysicsMode.Unity)
            {
                OnPhysicsSimulation?.Invoke(Time.fixedDeltaTime);
                OnPrePhysicsSimulation?.Invoke(Time.fixedDeltaTime);
            }
        }

        /// <summary>
        /// Called when Update ticks. This is called before any other script.
        /// </summary>
        internal void TickUpdate()
        {
            if (_networkManager.IsServer)
                ServerUptime += Time.deltaTime;
            if (_networkManager.IsClient)
                ClientUptime += Time.deltaTime;

            IncreaseTick();

            /* Invoke onsimulation if using Unity time.
            * Otherwise let the tick cycling part invoke. */
            if (PhysicsMode == PhysicsMode.Unity && Time.inFixedTimeStep)
                OnPostPhysicsSimulation?.Invoke(Time.fixedDeltaTime);

            OnUpdate?.Invoke();
        }

        /// <summary>
        /// Called when LateUpdate ticks. This is called after all other scripts.
        /// </summary>
        internal void TickLateUpdate()
        {
            OnLateUpdate?.Invoke();
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        internal void InitializeOnceInternal(NetworkManager networkManager)
        {
            _networkManager = networkManager;
            SetInitialValues();
            _networkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
            _networkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;

            AddNetworkLoops();
        }

        /// <summary>
        /// Adds network loops to gameObject.
        /// </summary>
        private void AddNetworkLoops()
        {
            //Writer.
            if (!gameObject.TryGetComponent<NetworkWriterLoop>(out _))
                gameObject.AddComponent<NetworkWriterLoop>();
            //Reader.
            if (!gameObject.TryGetComponent<NetworkReaderLoop>(out _))
                gameObject.AddComponent<NetworkReaderLoop>();
        }

        /// <summary>
        /// Called when a scene unloads.
        /// </summary>
        /// <param name="arg0"></param>
        private void SceneManager_sceneUnloaded(UnityScene s)
        {
            _replayingScenes.Remove(s);
        }

        /// <summary>
        /// Called after the local client connection state changes.
        /// </summary>
        private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
        {
            if (obj.ConnectionState != LocalConnectionState.Started)
            {
                _replayingScenes.Clear();
                _pingStopwatch.Stop();
                ClientUptime = 0f;
                LocalTick = 0;
                //Also reset Tick if not running as host.
                if (!_networkManager.IsServer)
                    Tick = 0;
            }
            //Started.
            else
            {
                _pingStopwatch.Restart();
            }
        }

        /// <summary>
        /// Called after the local server connection state changes.
        /// </summary>
        private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
        {
            //If no servers are running.
            if (!_networkManager.ServerManager.AnyServerStarted())
            {
                ServerUptime = 0f;
                Tick = 0;
            }
        }

        /// <summary>
        /// Invokes OnPre/PostReconcile events.
        /// Internal use.
        /// </summary>
        [APIExclude]
        [CodegenMakePublic] //To internal.
        public void InvokeOnReconcile(NetworkBehaviour nb, bool before)
        {
            nb.IsReconciling = before;
            if (before)
                OnPreReconcile?.Invoke(nb);
            else
                OnPostReconcile?.Invoke(nb);
        }

        /// <summary>
        /// Invokes OnReplicateReplay.
        /// Internal use.
        /// </summary>
        [APIExclude]
        [CodegenMakePublic] //To internal.
        public void InvokeOnReplicateReplay(UnityScene scene, PhysicsScene ps, PhysicsScene2D ps2d, bool before)
        {
            _isReplaying = before;
            if (before)
            {
                _replayingScenes.Add(scene);
                OnPreReplicateReplay?.Invoke(ps, ps2d);
            }
            else
            {
                _replayingScenes.Remove(scene);
                OnPostReplicateReplay?.Invoke(ps, ps2d);
            }
        }

        /// <summary>
        /// Sets values to use based on settings.
        /// </summary>
        private void SetInitialValues()
        {
            SetTickRate(TickRate);
            InitializePhysicsMode(PhysicsMode);
        }

        /// <summary>
        /// Sets simulation settings to Unity defaults.
        /// </summary>
        private void UnsetSimulationSettings()
        {
            Physics.autoSimulation = true;
#if !UNITY_2020_2_OR_NEWER
            Physics2D.autoSimulation = true;
#else
            Physics2D.simulationMode = SimulationMode2D.FixedUpdate;
#endif

            float simulationTime = PlayerPrefs.GetFloat(SAVED_FIXED_TIME_TEXT, float.MinValue);
            if (simulationTime != float.MinValue)
                Time.fixedDeltaTime = simulationTime;
        }

        /// <summary>
        /// Initializes physics mode when starting.
        /// </summary>
        /// <param name="automatic"></param>
        private void InitializePhysicsMode(PhysicsMode mode)
        {
            //Disable.
            if (mode == PhysicsMode.Disabled)
            {
                SetPhysicsMode(mode);
            }
            //Do not automatically simulate.
            else if (mode == PhysicsMode.TimeManager)
            {
#if UNITY_EDITOR
                //Preserve user tick rate.
                PlayerPrefs.SetFloat(SAVED_FIXED_TIME_TEXT, Time.fixedDeltaTime);
                //Let the player know.
                if (Time.fixedDeltaTime != (float)TickDelta)
                    Debug.LogWarning("Time.fixedDeltaTime is being overriden with TimeManager.TickDelta");
#endif
                Time.fixedDeltaTime = (float)TickDelta;
                /* Only check this if network manager
                 * is not null. It would be null via
                 * OnValidate. */
                if (_networkManager != null)
                {
                    //If at least one time manager is already running manual physics.
                    if (_manualPhysics > 0)
                    {
                        if (_networkManager.CanLog(LoggingType.Error))
                            Debug.LogError($"There are multiple TimeManagers instantiated which are using manual physics. Manual physics with multiple TimeManagers is not supported.");
                    }
                    _manualPhysics++;
                }

                SetPhysicsMode(mode);
            }
            //Automatically simulate.
            else
            {
#if UNITY_EDITOR
                float savedTime = PlayerPrefs.GetFloat(SAVED_FIXED_TIME_TEXT, float.MinValue);
                if (savedTime != float.MinValue && Time.fixedDeltaTime != savedTime)
                {
                    Debug.LogWarning("Time.fixedDeltaTime has been set back to user values.");
                    Time.fixedDeltaTime = savedTime;
                }

                PlayerPrefs.DeleteKey(SAVED_FIXED_TIME_TEXT);
#endif
                SetPhysicsMode(mode);
            }
        }

        /// <summary>
        /// Updates physics based on which physics mode to use.
        /// </summary>
        /// <param name="enabled"></param>
        public void SetPhysicsMode(PhysicsMode mode)
        {
            //Disable.
            if (mode == PhysicsMode.Disabled || mode == PhysicsMode.TimeManager)
            {
                Physics.autoSimulation = false;
#if !UNITY_2020_2_OR_NEWER
                Physics2D.autoSimulation = false;
#else
                Physics2D.simulationMode = SimulationMode2D.Script;
#endif
            }
            //Automatically simulate.
            else
            {
                Physics.autoSimulation = true;
#if !UNITY_2020_2_OR_NEWER
                Physics2D.autoSimulation = true;
#else
                Physics2D.simulationMode = SimulationMode2D.FixedUpdate;
#endif
            }
        }

        #region PingPong.
        /// <summary>
        /// Modifies client ping based on LocalTick and clientTIck.
        /// </summary>
        /// <param name="clientTick"></param>
        internal void ModifyPing(uint clientTick)
        {
            uint tickDifference = (LocalTick - clientTick);
            _pingAverage.ComputeAverage(tickDifference);
            double averageInTime = (_pingAverage.Average * TickDelta * 1000);
            RoundTripTime = (long)Math.Round(averageInTime);
            _receivedPong = true;
        }

        /// <summary>
        /// Sends a ping to the server.
        /// </summary>
        private void TrySendPing(uint? tickOverride = null)
        {
            byte pingInterval = PingInterval;

            /* How often client may send ping is based on if
             * the server responded to the last ping.
             * A response may not be received if the server
             * believes the client is pinging too fast, or if the 
             * client is having difficulties reaching the server. */
            long requiredTime = (pingInterval * 1000);
            float multiplier = (_receivedPong) ? 1f : 1.5f;

            requiredTime = (long)(requiredTime * multiplier);
            uint requiredTicks = TimeToTicks(pingInterval * multiplier);

            _pingTicks++;
            /* We cannot just consider time because ticks might run slower
             * from adjustments. We also cannot only consider ticks because
             * they might run faster from adjustments. Therefor require both
             * to have pass checks. */
            if (_pingTicks < requiredTicks || _pingStopwatch.ElapsedMilliseconds < requiredTime)
                return;

            _pingTicks = 0;
            _pingStopwatch.Restart();
            //Unset receivedPong, wait for new response.
            _receivedPong = false;

            uint tick = (tickOverride == null) ? LocalTick : tickOverride.Value;
            using (PooledWriter writer = WriterPool.GetWriter())
            {
                writer.WriteUInt16((ushort)PacketId.PingPong);
                writer.WriteUInt32(tick, AutoPackType.Unpacked);
                _networkManager.TransportManager.SendToServer((byte)Channel.Unreliable, writer.GetArraySegment());
            }
        }

        /// <summary>
        /// Sends a pong to a client.
        /// </summary>
        internal void SendPong(NetworkConnection conn, uint clientTick)
        {
            if (!conn.IsActive || !conn.Authenticated)
                return;

            using (PooledWriter writer = WriterPool.GetWriter())
            {
                writer.WriteUInt16((ushort)PacketId.PingPong);
                writer.WriteUInt32(clientTick, AutoPackType.Unpacked);
                conn.SendToClient((byte)Channel.Unreliable, writer.GetArraySegment());
            }
        }
        #endregion

        /// <summary>
        /// Increases the tick based on simulation rate.
        /// </summary>
        private void IncreaseTick()
        {
            bool isClient = _networkManager.IsClient;

            double timePerSimulation = (_networkManager.IsServer) ? TickDelta : _adjustedTickDelta;
            double time = Time.unscaledDeltaTime;
            _elapsedTickTime += time;
            FrameTicked = (_elapsedTickTime >= timePerSimulation);

            //Number of ticks to occur this frame.
            int ticksCount = Mathf.FloorToInt((float)(_elapsedTickTime / timePerSimulation));
            if (ticksCount > 1)
                _lastMultipleTicksTime = Time.unscaledDeltaTime;

            if (_allowTickDropping && !_networkManager.IsServer)
            {
                //If ticks require dropping. Set exactly to maximum ticks.
                if (ticksCount > _maximumFrameTicks)
                    _elapsedTickTime = (timePerSimulation * (double)_maximumFrameTicks);
            }

            while (_elapsedTickTime >= timePerSimulation)
            {
                _elapsedTickTime -= timePerSimulation;

                OnPreTick?.Invoke();
                /* This has to be called inside the loop because
                 * OnPreTick promises data hasn't been read yet.
                 * Therefor iterate must occur after OnPreTick.
                 * Iteration will only run once per frame. */
                TryIterateData(true);
                OnTick?.Invoke();

                if (PhysicsMode == PhysicsMode.TimeManager)
                {
                    float tick = (float)TickDelta;
                    OnPhysicsSimulation?.Invoke(tick);
                    OnPrePhysicsSimulation?.Invoke(tick);
                    Physics.Simulate(tick);
                    Physics2D.Simulate(tick);
                    OnPostPhysicsSimulation?.Invoke(tick);
                }

                OnPostTick?.Invoke();

                /* If isClient this is the
                 * last tick during this loop. */
                if (isClient && (_elapsedTickTime < timePerSimulation))
                    TrySendPing(LocalTick + 1);

                if (_networkManager.IsServer)
                    SendTimingAdjustment();

                //Send out data.
                TryIterateData(false);

                if (_networkManager.IsClient)
                    _clientTicks++;

                Tick++;
                LocalTick++;
            }

        }

        #region TicksToTime.
        /// <summary>
        /// Returns the percentage of how far the TimeManager is into the next tick.
        /// </summary>
        /// <returns></returns>
        public double GetTickPercent()
        {
            if (_networkManager == null)
                return default;

            double delta = (_networkManager.IsServer) ? TickDelta : _adjustedTickDelta;
            double percent = (_elapsedTickTime / delta) * 100d;
            return percent;
        }
        /// <summary>
        /// Returns a PreciseTick.
        /// </summary>
        /// <param name="tick">Tick to set within the returned PreciseTick.</param>
        /// <returns></returns>
        public PreciseTick GetPreciseTick(uint tick)
        {
            if (_networkManager == null)
                return default;

            double delta = (_networkManager.IsServer) ? TickDelta : _adjustedTickDelta;
            double percent = (_elapsedTickTime / delta) * 100;

            return new PreciseTick(tick, percent);
        }
        /// <summary>
        /// Returns a PreciseTick.
        /// </summary>
        /// <param name="tickType">Tick to use within PreciseTick.</param>
        /// <returns></returns>
        public PreciseTick GetPreciseTick(TickType tickType)
        {
            if (_networkManager == null)
                return default;

            if (tickType == TickType.Tick)
            {
                return GetPreciseTick(Tick);
            }
            else if (tickType == TickType.LocalTick)
            {
                return GetPreciseTick(LocalTick);
            }
            else if (tickType == TickType.LastPacketTick)
            {
                return GetPreciseTick(LastPacketTick);
            }
            else
            {
                if (_networkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"TickType {tickType.ToString()} is unhandled.");
                return default;
            }
        }

        /// <summary>
        /// Converts current ticks to time.
        /// </summary>
        /// <param name="tickType">TickType to compare against.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double TicksToTime(TickType tickType = TickType.LocalTick)
        {
            if (tickType == TickType.LocalTick)
            {
                return TicksToTime(LocalTick);
            }
            else if (tickType == TickType.Tick)
            {
                return TicksToTime(Tick);
            }
            else if (tickType == TickType.LastPacketTick)
            {
                return TicksToTime(LastPacketTick);
            }
            else
            {
                if (_networkManager != null && _networkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"TickType {tickType} is unhandled.");
                return 0d;
            }
        }

        /// <summary>
        /// Converts current ticks to time.
        /// </summary>
        /// <param name="useLocalTick">True to use the LocalTick, false to use Tick.</param>
        /// <returns></returns>
        [Obsolete("Use TicksToTime(TickType) instead.")]
        [MethodImpl(MethodImplOptions.AggressiveInlining)] //Remove on 2023/01/01
        public double TicksToTime(bool useLocalTick = true)
        {
            if (useLocalTick)
                return TicksToTime(LocalTick);
            else
                return TicksToTime(Tick);
        }
        /// <summary>
        /// Converts a number ticks to time.
        /// </summary>
        /// <param name="ticks">Ticks to convert.</param>
        /// <returns></returns>
        public double TicksToTime(uint ticks)
        {
            return (TickDelta * (double)ticks);
        }
        /// <summary>
        /// Converts time passed from currentTick to previous. Value will be negative if previousTick is larger than currentTick.
        /// </summary>
        /// <param name="currentTick">The current tick.</param>
        /// <param name="previousTick">The previous tick.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [Obsolete("Use TimePassed(uint, uint).")] //remove 2023/01/01.
        public double TicksToTime(uint currentTick, uint previousTick)
        {
            return TimePassed(currentTick, previousTick);
        }

        /// <summary>
        /// Gets time passed from currentTick to previousTick.
        /// </summary>
        /// <param name="currentTick">The current tick.</param>
        /// <param name="previousTick">The previous tick.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double TimePassed(uint currentTick, uint previousTick)
        {
            double multiplier;
            double result;
            if (currentTick >= previousTick)
            {
                multiplier = 1f;
                result = TicksToTime(currentTick - previousTick);
            }
            else
            {
                multiplier = -1f;
                result = TicksToTime(previousTick - currentTick);
            }

            return (result * multiplier);
        }

        /// <summary>
        /// Gets time passed from Tick to preciseTick.
        /// </summary>
        /// <param name="preciseTick">PreciseTick value to compare against.</param>
        /// <param name="allowNegative">True to allow negative values. When false and value would be negative 0 is returned.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double TimePassed(PreciseTick preciseTick, bool allowNegative = false)
        {
            PreciseTick currentPt = GetPreciseTick(TickType.Tick);

            long tickDifference = (currentPt.Tick - preciseTick.Tick);
            double percentDifference = (currentPt.Percent - preciseTick.Percent);

            /* If tickDifference is less than 0 or tickDifference and percentDifference are 0 or less
             * then the result would be negative. */
            bool negativeValue = (tickDifference < 0 || (tickDifference <= 0 && percentDifference <= 0));

            if (!allowNegative && negativeValue)
                return 0d;

            double tickTime = TimePassed(preciseTick.Tick, true);
            double percent = (percentDifference / 100);
            double percentTime = (percent * TickDelta);

            return (tickTime + percentTime);
        }
        /// <summary>
        /// Gets time passed from Tick to previousTick.
        /// </summary>
        /// <param name="previousTick">The previous tick.</param>
        /// <param name="allowNegative">True to allow negative values. When false and value would be negative 0 is returned.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double TimePassed(uint previousTick, bool allowNegative = false)
        {
            uint currentTick = Tick;
            //Difference will be positive.
            if (currentTick >= previousTick)
            {
                return TicksToTime(currentTick - previousTick);
            }
            //Difference would be negative.
            else
            {
                if (!allowNegative)
                {
                    return 0d;
                }
                else
                {
                    double difference = TicksToTime(previousTick - currentTick);
                    return (difference * -1d);
                }
            }
        }
        #endregion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        /// <summary>
        /// Converts time to ticks.
        /// </summary>
        /// <param name="time">Time to convert.</param>
        /// <returns></returns>
        public uint TimeToTicks(double time, TickRounding rounding = TickRounding.RoundNearest)
        {
            double result = (time / TickDelta);

            if (rounding == TickRounding.RoundNearest)
                return (uint)Math.Round(result);
            else if (rounding == TickRounding.RoundDown)
                return (uint)Math.Floor(result);
            else
                return (uint)Math.Ceiling(result);
        }

        /// <summary>
        /// Tries to iterate incoming or outgoing data.
        /// </summary>
        /// <param name="incoming">True to iterate incoming.</param>
        private void TryIterateData(bool incoming)
        {
            if (incoming)
            {
                /* It's not possible for data to come in
                 * more than once per frame but there could
                 * be new data going out each tick, since
                 * movement is often based off the tick system.
                 * Because of this don't iterate incoming if
                 * it's the same frame but the outgoing
                 * may iterate multiple times per frame. */
                int frameCount = Time.frameCount;
                if (frameCount == _lastIncomingIterationFrame)
                    return;
                _lastIncomingIterationFrame = frameCount;

                _networkManager.TransportManager.IterateIncoming(true);
                _networkManager.TransportManager.IterateIncoming(false);
            }
            else
            {
                _networkManager.TransportManager.IterateOutgoing(true);
                _networkManager.TransportManager.IterateOutgoing(false);
            }
        }

        #region Timing adjusting.    
        /// <summary>
        /// Sends a TimingUpdate packet to clients.
        /// </summary>
        private void SendTimingAdjustment()
        {
            uint requiredTicks = TimeToTicks(_timingInterval);
            uint tick = Tick;
            if (tick - _lastUpdateTicks >= requiredTicks)
            {
                //Now send using a packetId.
                PooledWriter writer = WriterPool.GetWriter();
                writer.WritePacketId(PacketId.TimingUpdate);
                _networkManager.TransportManager.SendToClients((byte)Channel.Unreliable, writer.GetArraySegment());
                writer.Dispose();

                _lastUpdateTicks = tick;
            }
        }

        /// <summary>
        /// Called on client when server sends a timing update.
        /// </summary>
        /// <param name="ta"></param>
        internal void ParseTimingUpdate()
        {
            //Don't adjust timing on server.
            if (_networkManager.IsServer)
                return;

            //Add half of rtt onto tick.
            uint rttTicks = TimeToTicks((RoundTripTime / 2) / 1000f);
            Tick = LastPacketTick + rttTicks;

            uint expected = (uint)(TickRate * _timingInterval);
            long difference;
            //If ticking too fast.
            if (_clientTicks > expected)
                difference = (long)(_clientTicks - expected);
            //Not ticking fast enough.
            else
                difference = (long)((expected - _clientTicks) * -1);

            //If difference is unusually off then reset timings.
            if (Mathf.Abs(difference) >= RESET_STEPS_THRESHOLD)
            {
                _adjustedTickDelta = TickDelta;
            }
            else
            {
                sbyte steps = (sbyte)Mathf.Clamp(difference, sbyte.MinValue, sbyte.MaxValue);
                double percent = (steps < 0) ? CLIENT_SPEEDUP_PERCENT : CLIENT_SLOWDOWN_PERCENT;
                double change = (steps * (percent * TickDelta));

                _adjustedTickDelta = MathFN.ClampDouble(_adjustedTickDelta + change, _clientTimingRange[0], _clientTimingRange[1]);
            }

            _clientTicks = 0;
        }
        #endregion

        /// <summary>
        /// Sets the TickRate to use. This value is not synchronized, it must be set on client and server independently.
        /// </summary>
        /// <param name="value">New TickRate to use.</param>
        public void SetTickRate(ushort value)
        {
            TickRate = value;
            TickDelta = (1d / TickRate);
            _adjustedTickDelta = TickDelta;
            _clientTimingRange = new double[]
            {
                TickDelta * (1f - CLIENT_TIMING_PERCENT_RANGE),
                TickDelta * (1f + CLIENT_TIMING_PERCENT_RANGE)
            };
        }

        #region UNITY_EDITOR
        private void OnValidate()
        {
            SetInitialValues();
        }
        #endregion

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Transporting/LatencySimulator.cs ---
﻿using FishNet.Transporting;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using UnityEngine;

//Thanks to TiToMoskito originally creating this as a Transport.
//https://github.com/TiToMoskito/FishyLatency
namespace FishNet.Managing.Transporting
{
    [System.Serializable]
    public class LatencySimulator
    {
        #region Types.
        /// <summary>
        /// A message affected by latency.
        /// </summary>
        private struct Message
        {
            public readonly int ConnectionId;
            public readonly byte[] Data;
            public readonly int Length;
            public readonly float SendTime;

            public Message(int connectionId, ArraySegment<byte> segment, float latency)
            {
                this.ConnectionId = connectionId;
                this.SendTime = (Time.unscaledTime + latency);
                this.Length = segment.Count;
                this.Data = ByteArrayPool.Retrieve(this.Length);
                Buffer.BlockCopy(segment.Array, segment.Offset, this.Data, 0, this.Length);
            }

            public ArraySegment<byte> GetSegment()
            {
                return new ArraySegment<byte>(Data, 0, Length);
            }
        }
        #endregion

        #region Internal.
        /// <summary>
        /// True if latency can be simulated.
        /// </summary>
        internal bool CanSimulate => (GetEnabled() && (GetLatency() > 0 || GetPacketLost() > 0 || GetOutOfOrder() > 0));
        #endregion

        #region Serialized
        [Header("Settings")]
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True if latency simulator is enabled.")]
        [SerializeField]
        private bool _enabled;
        /// <summary>
        /// Gets the enabled value of simulator.
        /// </summary>
        public bool GetEnabled() => _enabled;
        /// <summary>
        /// Sets the enabled value of simulator.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetEnabled(bool value)
        {
            if (value == _enabled)
                return;

            _enabled = value;
            Reset();
        }
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to add latency on clientHost as well.")]
        [SerializeField]
        private bool _simulateHost = true;
        /// <summary>
        /// Milliseconds to add between packets. When acting as host this value will be doubled. Added latency will be a minimum of tick rate.
        /// </summary>
        [Tooltip("Milliseconds to add between packets. When acting as host this value will be doubled. Added latency will be a minimum of tick rate.")]
        [Range(0, 60000)]
        [SerializeField]
        private long _latency = 0;
        /// <summary>
        /// Gets the latency value.
        /// </summary>
        /// <returns></returns>
        public long GetLatency() => _latency;
        /// <summary>
        /// Sets a new latency value.
        /// </summary>
        /// <param name="value">Latency as milliseconds.</param>
        public void SetLatency(long value) => _latency = value;

        [Header("Unreliable")]
        /// <summary>
        /// Percentage of unreliable packets which should arrive out of order.
        /// </summary>
        [Tooltip("Percentage of unreliable packets which should arrive out of order.")]
        [Range(0f, 1f)]
        [SerializeField]
        private double _outOfOrder = 0;
        /// <summary>
        /// Out of order chance, 1f is a 100% chance to occur.
        /// </summary>
        /// <returns></returns>
        public double GetOutOfOrder() => _outOfOrder;
        /// <summary>
        /// Sets out of order chance. 1f is a 100% chance to occur.
        /// </summary>
        /// <param name="value">New Value.</param>
        public void SetOutOfOrder(double value) => _outOfOrder = value;
        /// <summary>
        /// Percentage of packets which should drop.
        /// </summary>
        [Tooltip("Percentage of packets which should drop.")]
        [Range(0, 1)]
        [SerializeField]
        private double _packetLoss = 0;
        /// <summary>
        /// Gets packet loss chance. 1f is a 100% chance to occur.
        /// </summary>
        /// <returns></returns>
        public double GetPacketLost() => _packetLoss;
        /// <summary>
        /// Sets packet loss chance. 1f is a 100% chance to occur.
        /// </summary>
        /// <param name="value">New Value.</param>
        public void SetPacketLoss(double value) => _packetLoss = value;
        #endregion

        #region Private
        /// <summary>
        /// Transport to send data on.
        /// </summary>
        private Transport _transport;
        /// <summary>
        /// Reliable messages to the server.
        /// </summary>
        private List<Message> _toServerReliable = new List<Message>();
        /// <summary>
        /// Unreliable messages to the server.
        /// </summary>
        private List<Message> _toServerUnreliable = new List<Message>();
        /// <summary>
        /// Reliable messages to clients.
        /// </summary>
        private List<Message> _toClientReliable = new List<Message>();
        /// <summary>
        /// Unreliable messages to clients.
        /// </summary>
        private List<Message> _toClientUnreliable = new List<Message>();
        /// <summary>
        /// NetworkManager for this instance.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Used to generate chances of latency.
        /// </summary>
        private readonly System.Random _random = new System.Random();
        #endregion

        #region Initialization and Unity
        public void Initialize(NetworkManager manager, Transport transport)
        {
            _networkManager = manager;
            _transport = transport;
        }
        #endregion        

        /// <summary>
        /// Stops both client and server.
        /// </summary>
        public void Reset()
        {
            bool enabled = GetEnabled();
            if (_transport != null && enabled)
            { 
                IterateAndStore(_toServerReliable);
                IterateAndStore(_toServerUnreliable);
                IterateAndStore(_toClientReliable);
                IterateAndStore(_toClientUnreliable);
            }

            void IterateAndStore(List<Message> messages)
            {
                foreach (Message m in messages)
                {
                    _transport.SendToServer((byte)Channel.Reliable, m.GetSegment());
                    ByteArrayPool.Store(m.Data);
                }
            }

            _toServerReliable.Clear();
            _toServerUnreliable.Clear();
            _toClientReliable.Clear();
            _toClientUnreliable.Clear();
        }

        #region Simulation
        /// <summary>
        /// Returns long latency as a float.
        /// </summary>
        /// <param name="ms"></param>
        /// <returns></returns>
        private float GetLatencyAsFloat()
        {
            return (float)(_latency / 1000f);
        }

        /// <summary>
        /// Adds a packet for simulation.
        /// </summary>
        public void AddOutgoing(byte channelId, ArraySegment<byte> segment, bool toServer = true, int connectionId = -1)
        {
            /* If to not simulate for host see if this packet
             * should be sent normally. */
            if (!_simulateHost && _networkManager != null && _networkManager.IsHost)
            {
                /* If going to the server and is host then
                 * it must be sent from clientHost. */
                if (toServer)
                {
                    _transport.SendToServer(channelId, segment);
                    return;
                }
                //Not to server, see if going to clientHost.
                else
                {
                    //If connId is the same as clientHost id.
                    if (_networkManager.ClientManager.Connection.ClientId == connectionId)
                    {
                        _transport.SendToClient(channelId, segment, connectionId);
                        return;
                    }
                }
            }

            List<Message> collection;
            Channel c = (Channel)channelId;

            if (toServer)
                collection = (c == Channel.Reliable) ? _toServerReliable : _toServerUnreliable;
            else
                collection = (c == Channel.Reliable) ? _toClientReliable : _toClientUnreliable;

            float latency = GetLatencyAsFloat();
            //If dropping check to add extra latency if reliable, or discard if not.
            if (DropPacket())
            {
                if (c == Channel.Reliable)
                {
                    latency += latency; //add extra for resend.
                }
                //If not reliable then return the segment array to pool.
                else
                {
                    return;
                }
            }

            Message msg = new Message(connectionId, segment, latency);
            int count = collection.Count;
            if (c == Channel.Unreliable && count > 0 && OutOfOrderPacket(c))
                collection.Insert(count - 1, msg);
            else
                collection.Add(msg);
        }

        /// <summary>
        /// Simulates pending outgoing packets.
        /// </summary>
        /// <param name="toServer">True if sending to the server.</param>
        public void IterateOutgoing(bool toServer)
        {
            if (_transport == null)
            {
                Reset();
                return;
            }

            if (toServer)
            {
                IterateCollection(_toServerReliable, Channel.Reliable);
                IterateCollection(_toServerUnreliable, Channel.Unreliable);
            }
            else
            {
                IterateCollection(_toClientReliable, Channel.Reliable);
                IterateCollection(_toClientUnreliable, Channel.Unreliable);
            }

            void IterateCollection(List<Message> collection, Channel channel)
            {
                byte cByte = (byte)channel;
                float unscaledTime = Time.unscaledTime;

                int count = collection.Count;
                int iterations = 0;
                for (int i = 0; i < count; i++)
                {
                    Message msg = collection[i];
                    //Not enough time has passed.
                    if (unscaledTime < msg.SendTime)
                        break;

                    if (toServer)
                        _transport.SendToServer(cByte, msg.GetSegment());
                    else
                        _transport.SendToClient(cByte, msg.GetSegment(), msg.ConnectionId);

                    iterations++;
                }

                if (iterations > 0)
                {
                    for (int i = 0; i < iterations; i++)
                        ByteArrayPool.Store(collection[i].Data);
                    collection.RemoveRange(0, iterations);
                }
            }

            _transport.IterateOutgoing(toServer);
        }

        /// <summary>
        /// Returns if a packet should drop.
        /// </summary>
        /// <returns></returns>
        private bool DropPacket()
        {
            return (_packetLoss > 0d && (_random.NextDouble() < _packetLoss));
        }

        /// <summary>
        /// Returns if a packet should be out of order.
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        private bool OutOfOrderPacket(Channel c)
        {
            if (c == Channel.Reliable)
                return false;

            return (_outOfOrder > 0d && (_random.NextDouble() < _outOfOrder));
        }
        #endregion
    }
}

'''
'''--- Assets/FishNet/Runtime/Managing/Transporting/SplitReader.cs ---
﻿using FishNet.Serializing;
using System;
using UnityEngine;

namespace FishNet.Managing.Transporting
{

    internal class SplitReader
    {
        #region Private.
        /// <summary>
        /// Tick split is for.
        /// Tick must be a negative value so that it's impossible for the first tick to align.
        /// </summary>
        private long _tick = -1;
        /// <summary>
        /// Expected number of splits.
        /// </summary>
        private int _expectedMessages;
        /// <summary>
        /// Number of splits received so far.
        /// </summary>
        private ushort _receivedMessages;
        /// <summary>
        /// Writer containing split packet combined.
        /// </summary>
        private PooledWriter _writer = WriterPool.GetWriter();
        #endregion

        internal SplitReader()
        {
            //Increase capacity to reduce the chance of resizing.
            _writer.EnsureBufferCapacity(20000);
        }

        /// <summary>
        /// Gets split header values.
        /// </summary>
        internal void GetHeader(PooledReader reader, out int expectedMessages)
        {
            expectedMessages = reader.ReadInt32();
        }

        /// <summary>
        /// Combines split data.
        /// </summary>
        internal void Write(uint tick, PooledReader reader, int expectedMessages)
        {
            //New tick which means new split.
            if (tick != _tick)
                Reset(tick, expectedMessages);

            /* This is just a guess as to how large the end
             * message could be. If the writer is not the minimum
             * of this length then resize it. */
            int estimatedBufferSize = (expectedMessages * 1500);
            if (_writer.Capacity < estimatedBufferSize)
                _writer.EnsureBufferCapacity(estimatedBufferSize);
            /* Empty remainder of reader into the writer.
             * It does not matter if parts of the reader
             * contain data added after the split because
             * once the split is fully combined the data
             * is parsed as though it came in as one message,
             * which is how data is normally read. */
            ArraySegment<byte> data = reader.ReadArraySegment(reader.Remaining);
            _writer.WriteArraySegment(data);
            _receivedMessages++;
        }

        /// <summary>
        /// Returns if all split messages have been received.
        /// </summary>
        /// <returns></returns>
        internal ArraySegment<byte> GetFullMessage()
        {
            if (_receivedMessages < _expectedMessages)
            {
                return default(ArraySegment<byte>);
            }
            else
            {
                ArraySegment<byte> segment = _writer.GetArraySegment();
                Reset();
                return segment;
            }
        }

        private void Reset(uint tick = 0, int expectedMessages = 0)
        {
            _tick = tick;
            _receivedMessages = 0;
            _expectedMessages = expectedMessages;
            _writer.Reset();
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Transporting/TransportManager.QOL.cs ---
﻿using FishNet.Transporting;
using FishNet.Transporting.Multipass;
using UnityEngine;

namespace FishNet.Managing.Transporting
{

    /// <summary>
    /// Communicates with the Transport to send and receive data.
    /// </summary>
    public sealed partial class TransportManager : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Returns IsLocalTransport for the current transport.
        /// </summary>
        public bool IsLocalTransport(int connectionId) => (Transport == null) ? false : Transport.IsLocalTransport(connectionId);
        #endregion

        /// <summary>
        /// Gets transport on index.
        /// Commonly index will be 0 unless using Multipass.
        /// </summary>
        /// <returns></returns>
        public Transport GetTransport(int index)
        {
            //If using multipass try to find the correct transport.
            if (Transport is Multipass mp)
            {
                return mp.GetTransport(index);
            }
            //Not using multipass.
            else
            {
                return Transport;
            }
        }

        /// <summary>
        /// Gets transport of type T.
        /// </summary>
        /// <returns>Returns the found transport which is of type T. Returns default of T if not found.</returns>
        public T GetTransport<T>() where T : Transport
        {
            //If using multipass try to find the correct transport.
            if (Transport is Multipass mp)
            {
                if (typeof(T) == typeof(Multipass))
                    return (T)(object)mp;
                else
                    return mp.GetTransport<T>();
            }
            //Not using multipass.
            else
            {
                if (Transport.GetType() == typeof(T))
                    return (T)(object)Transport;
                else
                    return default(T);
            }
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Transporting/TransportManager.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Transporting
{

    /// <summary>
    /// Communicates with the Transport to send and receive data.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/TransportManager")]
    public sealed partial class TransportManager : MonoBehaviour
    {
        #region Types.
        private struct DisconnectingClient
        {
            public uint Tick;
            public NetworkConnection Connection;

            public DisconnectingClient(uint tick, NetworkConnection connection)
            {
                Tick = tick;
                Connection = connection;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Called before IterateOutgoing has started.
        /// </summary>
        internal event Action OnIterateOutgoingStart;
        /// <summary>
        /// Called after IterateOutgoing has completed.
        /// </summary>
        internal event Action OnIterateOutgoingEnd;
        /// <summary>
        /// Called before IterateIncoming has started. True for on server, false for on client.
        /// </summary>
        internal event Action<bool> OnIterateIncomingStart;
        /// <summary>
        /// Called after IterateIncoming has completed. True for on server, false for on client.
        /// </summary>
        internal event Action<bool> OnIterateIncomingEnd;
        /// <summary>
        /// The current Transport being used.
        /// </summary>
        [Tooltip("The current Transport being used.")]
        public Transport Transport;
        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Latency simulation settings.")]
        [SerializeField]
        private LatencySimulator _latencySimulator = new LatencySimulator();
        /// <summary>
        /// Latency simulation settings.
        /// </summary>
        public LatencySimulator LatencySimulator
        {
            get
            {
                //Shouldn't ever be null unless the user nullifies it.
                if (_latencySimulator == null)
                    _latencySimulator = new LatencySimulator();
                return _latencySimulator;
            }
        }
        #endregion

        #region Private.
        /// <summary>
        /// NetworkConnections on the server which have to send data to clients.
        /// </summary>
        private List<NetworkConnection> _dirtyToClients = new List<NetworkConnection>();
        /// <summary>
        /// PacketBundles to send to the server.
        /// </summary>
        private List<PacketBundle> _toServerBundles = new List<PacketBundle>();
        /// <summary>
        /// NetworkManager handling this TransportManager.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Clients which are pending disconnects.
        /// </summary>
        private List<DisconnectingClient> _disconnectingClients = new List<DisconnectingClient>();
        #endregion

        #region Consts.
        /// <summary>
        /// Number of bytes sent for PacketId.
        /// </summary>
        public const byte PACKET_ID_BYTES = 2;
        /// <summary>
        /// Number of bytes sent for ObjectId.
        /// </summary>
        public const byte OBJECT_ID_BYTES = 2;
        /// <summary>
        /// Number of bytes sent for ComponentIndex.
        /// </summary>
        public const byte COMPONENT_INDEX_BYTES = 1;
        /// <summary>
        /// Number of bytes sent for Tick.
        /// </summary>
        public const byte TICK_BYTES = 4;
        /// <summary>
        /// Number of bytes sent to indicate split count.
        /// </summary>
        private const byte SPLIT_COUNT_BYTES = 4;
        /// <summary>
        /// Number of bytes required for split data. 
        /// </summary>
        public const byte SPLIT_INDICATOR_SIZE = (PACKET_ID_BYTES + SPLIT_COUNT_BYTES);
        /// <summary>
        /// Number of channels supported.
        /// </summary>
        public const byte CHANNEL_COUNT = 2;
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        internal void InitializeOnceInternal(NetworkManager manager)
        {
            _networkManager = manager;
            /* If transport isn't specified then add default
             * transport. */
            if (Transport == null && !gameObject.TryGetComponent<Transport>(out Transport))
                Transport = gameObject.AddComponent<FishNet.Transporting.Tugboat.Tugboat>();

            Transport.Initialize(_networkManager, 0);
            InitializeToServerBundles();
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            _latencySimulator.Initialize(manager, Transport);
#endif
        }

        /// <summary>
        /// Sets a connection from server to client dirty.
        /// </summary>
        /// <param name="conn"></param>
        internal void ServerDirty(NetworkConnection conn)
        {
            _dirtyToClients.Add(conn);
        }

        /// <summary>
        /// Initializes ToServerBundles for use.
        /// </summary>
        private void InitializeToServerBundles()
        {
            /* For ease of use FishNet will always have
             * only two channels, reliable and unreliable. 
             * Even if the transport only supports reliable
             * also setup for unreliable. */
            for (byte i = 0; i < CHANNEL_COUNT; i++)
            {
                int mtu = Transport.GetMTU(i);
                _toServerBundles.Add(new PacketBundle(_networkManager, mtu));
            }
        }

        /// <summary>
        /// Sends data to a client.
        /// </summary>
        /// <param name="channelId">Channel to send on.</param>
        /// <param name="segment">Data to send.</param>
        /// <param name="connection">Connection to send to. Use null for all clients.</param>
        /// <param name="splitLargeMessages">True to split large packets which exceed MTU and send them in order on the reliable channel.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void SendToClient(byte channelId, ArraySegment<byte> segment, NetworkConnection connection, bool splitLargeMessages = true)
        {
            if (connection == null)
                return;

            //Split is needed.
            if (splitLargeMessages && SplitRequired(channelId, segment.Count, out int requiredMessages, out int maxMessageSize))
                SendSplitData(connection, ref segment, requiredMessages, maxMessageSize);
            //Split not needed.
            else
                connection.SendToClient(channelId, segment);
        }

        /// <summary>
        /// Sends data to observers.
        /// </summary>
        /// <param name="channelId"></param>
        /// <param name="segment"></param>
        /// <param name="observers"></param>
        /// <param name="splitLargeIntoReliable">True to split large packets which exceed MTU and send them in order on the reliable channel.</param>
        internal void SendToClients(byte channelId, ArraySegment<byte> segment, HashSet<NetworkConnection> observers, bool splitLargeIntoReliable = true)
        {
            foreach (NetworkConnection conn in observers)
                SendToClient(channelId, segment, conn, splitLargeIntoReliable);
        }

        /// <summary>
        /// Sends data to all clients if networkObject has no observers, otherwise sends to observers.
        /// </summary>
        /// <param name="channelId">Channel to send on.</param>
        /// <param name="segment">Data to send.</param>
        /// <param name="nob">NetworkObject being used to send data.</param>
        /// <param name="splitLargeMessages">True to split large packets which exceed MTU and send them in order on the reliable channel.</param>
        internal void SendToClients(byte channelId, ArraySegment<byte> segment, NetworkObject networkObject, bool excludeOwner = false, bool splitLargeMessages = true)
        {
            if (!excludeOwner)
            {
                SendToClients(channelId, segment, networkObject.Observers, splitLargeMessages);
            }
            else
            {
                foreach (NetworkConnection conn in networkObject.Observers)
                {
                    if (conn != networkObject.Owner)
                        SendToClient(channelId, segment, conn, splitLargeMessages);
                }
            }
        }

        /// <summary>
        /// Sends data to all clients.
        /// </summary>
        /// <param name="channelId">Channel to send on.</param>
        /// <param name="segment">Data to send.</param>
        /// <param name="splitLargeIntoReliable">True to split large packets which exceed MTU and send them in order on the reliable channel.</param>
        internal void SendToClients(byte channelId, ArraySegment<byte> segment, bool splitLargeMessages = true)
        {
            /* To ensure proper order everything must be tossed into each
             * NetworkConnection rather than batch send. This is because there
             * is no way to know if batch send must iterate before or
             * after connection sends. By sending to each connection order
             * is maintained. */
            foreach (NetworkConnection conn in _networkManager.ServerManager.Clients.Values)
                SendToClient(channelId, segment, conn, splitLargeMessages);
        }

        /// <summary>
        /// Sends data to the server.
        /// </summary>
        /// <param name="channelId">Channel to send on.</param>
        /// <param name="segment">Data to send.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void SendToServer(byte channelId, ArraySegment<byte> segment, bool splitMessages = true)
        {
            if (channelId >= _toServerBundles.Count)
                channelId = (byte)Channel.Reliable;

            //Split is needed.
            if (splitMessages && SplitRequired(channelId, segment.Count, out int requiredMessages, out int maxMessageSize))
            {
                //Client is not allowed to send data sizes beyond MTU.
                //if (_networkManager.ServerManager.LimitClientMTU) //todo uncomment and finish
                //{
                //    if (_networkManager.CanLog(LoggingType.Error))
                //        Debug.LogError($"Local client attempted to send a packet size of {segment.Count} which would exceed the MTU, and settings do not allow this. To allow clients to send packets beyond MTU add a ServerManager component to your NetworkManager uncheck LimitClientMTU.");

                //    _networkManager.ClientManager.StopConnection();
                //    return;
                //}
                //If here split can be sent.
                SendSplitData(null, ref segment, requiredMessages, maxMessageSize);
            }
            //Split not needed.
            else
            {
                _toServerBundles[channelId].Write(segment);
            }
        }

        #region Splitting.     
        /// <summary>
        /// True if data must be split.
        /// </summary>
        /// <param name="channelId"></param>
        /// <param name="segmentSize"></param>
        /// <returns></returns>
        private bool SplitRequired(byte channelId, int segmentSize, out int requiredMessages, out int maxMessageSize)
        {
            maxMessageSize = Transport.GetMTU(channelId) - (TransportManager.TICK_BYTES + SPLIT_INDICATOR_SIZE);
            requiredMessages = Mathf.CeilToInt((float)segmentSize / maxMessageSize);

            return (requiredMessages > 1);
        }

        /// <summary>
        /// Splits data going to which is too large to fit within the transport MTU.
        /// </summary>
        /// <param name="conn">Connection to send to. If null data will be sent to the server.</param>
        /// <returns>True if data was sent split.</returns>
        private void SendSplitData(NetworkConnection conn, ref ArraySegment<byte> segment, int requiredMessages, int maxMessageSize)
        {
            if (requiredMessages <= 1)
            {
                if (_networkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"SendSplitData was called with {requiredMessages} required messages. This method should only be called if messages must be split into 2 pieces or more.");
                return;
            }

            byte channelId = (byte)Channel.Reliable;
            PooledWriter headerWriter = WriterPool.GetWriter();
            headerWriter.WritePacketId(PacketId.Split);
            headerWriter.WriteInt32(requiredMessages);
            ArraySegment<byte> headerSegment = headerWriter.GetArraySegment();

            int writeIndex = 0;
            bool firstWrite = true;
            //Send to connection until everything is written.
            while (writeIndex < segment.Count)
            {
                bool wasFirst = firstWrite;
                int headerReduction = 0;
                if (firstWrite)
                {
                    headerReduction = headerSegment.Count;
                    firstWrite = false;
                }
                int chunkSize = Mathf.Min(segment.Count - writeIndex - headerReduction, maxMessageSize);
                //Make a new array segment for the chunk that is getting split.
                ArraySegment<byte> splitSegment = new ArraySegment<byte>(
                    segment.Array, segment.Offset + writeIndex, chunkSize);

                //If connection is specified then it's going to a client.
                if (conn != null)
                {
                    conn.SendToClient(channelId, headerSegment, true);
                    conn.SendToClient(channelId, splitSegment);
                }
                //Otherwise it's going to the server.
                else
                {
                    _toServerBundles[channelId].Write(headerSegment, true);
                    _toServerBundles[channelId].Write(splitSegment, false);
                }

                writeIndex += chunkSize;
            }

            headerWriter.Dispose();
        }
        #endregion

        /// <summary>
        /// Processes data received by the socket.
        /// </summary>
        /// <param name="server">True to process data received on the server.</param>
        internal void IterateIncoming(bool server)
        {
            OnIterateIncomingStart?.Invoke(server);
            Transport.IterateIncoming(server);
            OnIterateIncomingEnd?.Invoke(server);
        }

        /// <summary>
        /// Processes data to be sent by the socket.
        /// </summary>
        /// <param name="toServer">True to process data received on the server.</param>
        internal void IterateOutgoing(bool toServer)
        {
            OnIterateOutgoingStart?.Invoke();
            int channelCount = CHANNEL_COUNT;
            ulong sentBytes = 0;
            bool latencySimulatorEnabled = LatencySimulator.CanSimulate;

            /* If sending to the client. */
            if (!toServer)
            {
                TimeManager tm = _networkManager.TimeManager;
                uint localTick = tm.LocalTick;
                //Write any dirty syncTypes.
                _networkManager.ServerManager.Objects.WriteDirtySyncTypes();

                int dirtyCount = _dirtyToClients.Count;

                //Run through all dirty connections to send data to.
                for (int z = 0; z < dirtyCount; z++)
                {
                    NetworkConnection conn = _dirtyToClients[z];
                    if (conn == null || !conn.IsValid)
                        continue;

                    //Get packets for every channel.
                    for (byte channel = 0; channel < channelCount; channel++)
                    {
                        if (conn.GetPacketBundle(channel, out PacketBundle pb))
                        {
                            for (int i = 0; i < pb.WrittenBuffers; i++)
                            {
                                //Length should always be more than 0 but check to be safe.
                                if (pb.GetBuffer(i, out ByteBuffer bb))
                                {
                                    ArraySegment<byte> segment = new ArraySegment<byte>(bb.Data, 0, bb.Length);
#if UNITY_EDITOR || DEVELOPMENT_BUILD
                                    if (latencySimulatorEnabled)
                                        _latencySimulator.AddOutgoing(channel, segment, false, conn.ClientId);
                                    else
#endif
                                        Transport.SendToClient(channel, segment, conn.ClientId);
                                    sentBytes += (ulong)segment.Count;
                                }
                            }

                            pb.Reset();
                        }
                    }

                    /* When marked as disconnecting data will still be sent
                     * this iteration but the connection will be marked as invalid.
                     * This will prevent future data from going out/coming in.
                     * Also the connection will be added to a disconnecting collection
                     * so it will it disconnected briefly later to allow data from
                     * this tick to send. */
                    if (conn.Disconnecting)
                    {
                        uint requiredTicks = tm.TimeToTicks(0.1d, TickRounding.RoundUp);
                        /* Require 100ms or 2 ticks to pass
                         * before disconnecting to allow for the
                         * higher chance of success that remaining
                         * data is sent. */
                        requiredTicks = Math.Max(requiredTicks, 2);
                        _disconnectingClients.Add(new DisconnectingClient(requiredTicks + localTick, conn));
                    }

                    conn.ResetServerDirty();
                }

                //Iterate disconnects.
                for (int i = 0; i < _disconnectingClients.Count; i++)
                {
                    DisconnectingClient dc = _disconnectingClients[i];
                    if (localTick >= dc.Tick)
                    {
                        _networkManager.TransportManager.Transport.StopConnection(dc.Connection.ClientId, true);
                        _disconnectingClients.RemoveAt(i);
                        i--;
                    }
                }

                _networkManager.StatisticsManager.NetworkTraffic.LocalServerSentData(sentBytes);

                if (dirtyCount == _dirtyToClients.Count)
                    _dirtyToClients.Clear();
                else if (dirtyCount > 0)
                    _dirtyToClients.RemoveRange(0, dirtyCount);
            }
            /* If sending to the server. */
            else
            {
                for (byte channel = 0; channel < channelCount; channel++)
                {
                    if (PacketBundle.GetPacketBundle(channel, _toServerBundles, out PacketBundle pb))
                    {
                        for (int i = 0; i < pb.WrittenBuffers; i++)
                        {
                            if (pb.GetBuffer(i, out ByteBuffer bb))
                            {
                                ArraySegment<byte> segment = new ArraySegment<byte>(bb.Data, 0, bb.Length);
#if UNITY_EDITOR || DEVELOPMENT_BUILD
                                if (latencySimulatorEnabled)
                                    _latencySimulator.AddOutgoing(channel, segment);
                                else
#endif
                                    Transport.SendToServer(channel, segment);
                                sentBytes += (ulong)segment.Count;
                            }
                        }
                        pb.Reset();
                    }
                }

                _networkManager.StatisticsManager.NetworkTraffic.LocalClientSentData(sentBytes);
            }

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            if (latencySimulatorEnabled)
                _latencySimulator.IterateOutgoing(toServer);
#endif

            Transport.IterateOutgoing(toServer);
            OnIterateOutgoingEnd?.Invoke();
        }

        #region Editor.
#if UNITY_EDITOR
        private void OnValidate()
        {
            if (Transport == null)
                Transport = GetComponent<Transport>();

            /* Update enabled state to force a reset if needed.
             * This may be required if the user checked the enabled
             * tick box at runtime. If enabled value didn't change
             * then the Get will be the same as the Set and nothing
             * will happen. */
            _latencySimulator.SetEnabled(_latencySimulator.GetEnabled());
        }
#endif
        #endregion

    }

}
'''
'''--- Assets/FishNet/Runtime/Managing/Utility/Utility.cs ---
﻿using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using UnityEngine;

namespace FishNet.Managing.Utility
{

    public class Packets
    {
        /// <summary>
        /// Returns written data length for packet.
        /// </summary>
        internal static int GetPacketLength(ushort packetId, PooledReader reader, Channel channel)
        {
            /* Broadcast is a special circumstance where data
            * will not be purged even if unreliable.
            * This is because a broadcast receiver may not
            * be set, which could be intentional. Because of this
            * length is always sent to skip
            * past the broadcast data. 
            *
            * Reliables also need length read in the instance a client
            * sends data to an object which server is despawning. Without
            * parsing length the remainer data from client will be corrupt. */
            PacketId pid = (PacketId)packetId;
            if (channel == Channel.Reliable ||
                pid == PacketId.Broadcast ||
                pid == PacketId.SyncVar
                )
            {
                return reader.ReadInt32();
            }
            //Unreliable purges remaining.
            else if (channel == Channel.Unreliable)
            {
                return (int)MissingObjectPacketLength.PurgeRemaiming;
            }
            /* Unhandled. This shouldn't be possible
             * since both reliable and unreliable is checked.
             * There are no other options. This is merely here
             * for a sanity check. */
            else
            {
                LogError($"Operation is unhandled for packetId {(PacketId)packetId} on channel {channel}.");
                return (int)MissingObjectPacketLength.PurgeRemaiming;
            }

            //Logs an error message.
            void LogError(string message)
            {
                bool canLog;
                if (reader.NetworkManager != null)
                    canLog = reader.NetworkManager.CanLog(Logging.LoggingType.Error);
                else
                    canLog = NetworkManager.StaticCanLog(Logging.LoggingType.Error);

                if (canLog)
                    Debug.LogError(message);
            }

        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Attributes.cs ---
﻿using FishNet.Managing.Logging;
using FishNet.Transporting;
using System;
using UnityEngine;

namespace FishNet.Object
{

    /// <summary>
    /// ServerRpc methods will send messages to the server.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ServerRpcAttribute : Attribute
    {
        /// <summary>
        /// True to only allow the owning client to call this RPC.
        /// </summary>
        public bool RequireOwnership = true;
        /// <summary>
        /// True to also run the RPC logic locally.
        /// </summary>
        public bool RunLocally = false;
        /// <summary>
        /// Estimated length of data being sent.
        /// When a value other than -1 the minimum length of the used serializer will be this value.
        /// This is useful for writing large packets which otherwise resize the serializer.
        /// </summary>
        public int DataLength = -1;
    }

    /// <summary>
    /// ObserversRpc methods will send messages to all observers.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ObserversRpcAttribute : Attribute
    {
        /// <summary>
        /// True to also send data to the owner of object.
        /// </summary>
        public bool IncludeOwner = true;
        /// <summary>
        /// True to buffer the last value and send it to new players when the object is spawned for them.
        /// RPC will be sent on the same channel as the original RPC, and immediately before the OnSpawnServer override.
        /// </summary>
        public bool BufferLast = false;
        /// <summary>
        /// True to also run the RPC logic locally.
        /// </summary>
        public bool RunLocally = false;
        /// <summary>
        /// Estimated length of data being sent.
        /// When a value other than -1 the minimum length of the used serializer will be this value.
        /// This is useful for writing large packets which otherwise resize the serializer.
        /// </summary>
        public int DataLength = -1;
    }

    /// <summary>
    /// TargetRpc methods will send messages to a single client.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class TargetRpcAttribute : Attribute 
    {
        /// <summary>
        /// True to also run the RPC logic locally.
        /// </summary>
        public bool RunLocally = false;
        /// <summary>
        /// True to validate the target is possible and output debug when not.
        /// Use this field with caution as it may create undesired results when set to false.
        /// </summary>
        public bool ValidateTarget = true;
        /// <summary>
        /// Estimated length of data being sent.
        /// When a value other than -1 the minimum length of the used serializer will be this value.
        /// This is useful for writing large packets which otherwise resize the serializer.
        /// </summary>
        public int DataLength = -1;
    }

    /// <summary>
    /// Prevents a method from running if server is not active.
    /// <para>Can only be used inside a NetworkBehaviour</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ServerAttribute : Attribute
    {
        /// <summary>
        /// Type of logging to use when the IsServer check fails.
        /// </summary>
        public LoggingType Logging = LoggingType.Warning;
    }

    /// <summary>
    /// Prevents this method from running if client is not active.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ClientAttribute : Attribute
    {
        /// <summary>
        /// Type of logging to use when the IsClient check fails.
        /// </summary>
        public LoggingType Logging = LoggingType.Warning;
        /// <summary>
        /// True to only allow a client to run the method if they are owner of the object.
        /// </summary>
        public bool RequireOwnership = false;
    }
}

namespace FishNet.Object.Synchronizing
{

    /// <summary>
    /// Synchronizes collections or objects from the server to clients. Can be used with custom SyncObjects.
    /// Value must be changed on server.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public class SyncObjectAttribute : PropertyAttribute
    {
        /// <summary>
        /// How often values may update over the network.
        /// </summary>
        public float SendRate = 0.1f;
        /// <summary>
        /// Clients which may receive value updates.
        /// </summary>
        public ReadPermission ReadPermissions = ReadPermission.Observers;
    }

    /// <summary>
    /// Synchronizes a variable from server to clients automatically.
    /// Value must be changed on server.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public class SyncVarAttribute : PropertyAttribute
    {
        /// <summary>
        /// How often values may update over the network.
        /// </summary>
        public float SendRate = 0.1f;
        /// <summary>
        /// Clients which may receive value updates.
        /// </summary>
        public ReadPermission ReadPermissions = ReadPermission.Observers;
        /// <summary>
        /// Channel to use. Unreliable SyncVars will use eventual consistency.
        /// </summary>
        public Channel Channel;
        ///<summary>
        /// Method which will be called on the server and clients when the value changes.
        ///</summary>
        public string OnChange;
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/ChangedTransformProperties.cs ---
﻿using FishNet.Documenting;

namespace FishNet.Object
{
    /// <summary>
    /// Properties which have changed on a transform.
    /// </summary>
    [System.Flags]
    [APIExclude]
    internal enum ChangedTransformProperties : byte
    {
        Unset = 0,
        LocalPosition = 2,
        LocalRotation = 4,
        LocalScale = 8
    }

    [APIExclude]
    internal static partial class Enums
    {
        /// <summary>
        /// Returns if whole contains part.
        /// </summary>
        /// <param name="whole"></param>
        /// <param name="part"></param>
        /// <returns></returns>
        public static bool TransformPropertiesContains(ChangedTransformProperties whole, ChangedTransformProperties part)
        {
            return (whole & part) == part;
        }
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/Delegates.cs ---
﻿using FishNet.Connection;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Constant;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.Object.Delegating
{
    public delegate void ServerRpcDelegate(NetworkBehaviour obj, PooledReader reader, Channel channel, NetworkConnection sender);
    public delegate void ClientRpcDelegate(NetworkBehaviour obj, PooledReader reader, Channel channel);

}
'''
'''--- Assets/FishNet/Runtime/Object/DespawnType.cs ---
﻿using FishNet.Object.Helping;

namespace FishNet.Object
{

    public enum DespawnType : byte
    {
        Destroy = 0,
        Pool = 1,
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/EmptyNetworkBehaviour.cs ---
﻿
namespace FishNet.Object
{
    /// <summary>
    /// This may be added at runtime to find objects without any network scripts, beneath a NetworkObject.
    /// </summary>
    public class EmptyNetworkBehaviour : NetworkBehaviour
    {

    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Helping/Hashing.cs ---
﻿namespace FishNet.Object.Helping
{

    public static class Hashing
    {

        private const uint FNV_offset_basis32 = 2166136261;
        private const uint FNV_prime32 = 16777619;
        private const ulong FNV_offset_basis64 = 14695981039346656037;
        private const ulong FNV_prime64 = 1099511628211;

        /// <summary>
        /// non cryptographic stable hash code,  
        /// it will always return the same hash for the same
        /// string.  
        /// 
        /// This is simply an implementation of FNV-1 32 bit xor folded to 16 bit
        /// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        /// </summary>
        /// <returns>The stable hash32.</returns>
        /// <param name="txt">Text.</param>
        internal static ushort GetStableHash16(this string txt)
        {
            uint hash32 = txt.GetStableHash32();

            return (ushort)((hash32 >> 16) ^ hash32);
        }

        /// <summary>
        /// non cryptographic stable hash code,  
        /// it will always return the same hash for the same
        /// string.  
        /// 
        /// This is simply an implementation of FNV-1 32 bit
        /// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        /// </summary>
        /// <returns>The stable hash32.</returns>
        /// <param name="txt">Text.</param>
        public static uint GetStableHash32(this string txt)
        {
            unchecked
            {
                uint hash = FNV_offset_basis32;
                for (int i = 0; i < txt.Length; i++)
                {
                    uint ch = txt[i];
                    hash = hash * FNV_prime32;
                    hash = hash ^ ch;
                }
                return hash;
            }
        }

        /// <summary>
        /// non cryptographic stable hash code,  
        /// it will always return the same hash for the same
        /// string.  
        /// 
        /// This is simply an implementation of FNV-1  64 bit
        /// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        /// </summary>
        /// <returns>The stable hash32.</returns>
        /// <param name="txt">Text.</param>
        internal static ulong GetStableHash64(this string txt)
        {
            unchecked
            {
                ulong hash = FNV_offset_basis64;
                for (int i = 0; i < txt.Length; i++)
                {
                    ulong ch = txt[i];
                    hash = hash * FNV_prime64;
                    hash = hash ^ ch;
                }
                return hash;
            }
        }

        ///// <summary>
        ///// non cryptographic stable hash code,  
        ///// it will always return the same hash for the same
        ///// string.  
        ///// 
        ///// This is simply an implementation of FNV-1 32 bit xor folded to 16 bit
        ///// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        ///// </summary>
        ///// <returns>The stable hash32.</returns>
        ///// <param name="bytes">Text.</param>
        //internal static ushort GetStableHash16(this byte[] bytes)
        //{
        //    uint hash32 = bytes.GetStableHash32();

        //    return (ushort)((hash32 >> 16) ^ hash32);
        //}

        ///// <summary>
        ///// non cryptographic stable hash code,  
        ///// it will always return the same hash for the same
        ///// string.  
        ///// 
        ///// This is simply an implementation of FNV-1 32 bit
        ///// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        ///// </summary>
        ///// <returns>The stable hash32.</returns>
        ///// <param name="bytes">Text.</param>
        //internal static uint GetStableHash32(this byte[] bytes)
        //{
        //    unchecked
        //    {
        //        uint hash = FNV_offset_basis32;
        //        for (int i = 0; i < bytes.Length; i++)
        //        {
        //            uint bt = bytes[i];
        //            hash = hash * FNV_prime32;
        //            hash = hash ^ bt;
        //        }
        //        return hash;
        //    }
        //}

        ///// <summary>
        ///// non cryptographic stable hash code,  
        ///// it will always return the same hash for the same
        ///// string.  
        ///// 
        ///// This is simply an implementation of FNV-1  64 bit
        ///// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        ///// </summary>
        ///// <returns>The stable hash32.</returns>
        ///// <param name="bytes">Text.</param>
        //internal static ulong GetStableHash64(this byte[] bytes)
        //{
        //    unchecked
        //    {
        //        ulong hash = FNV_offset_basis64;
        //        for (int i = 0; i < bytes.Length; i++)
        //        {
        //            ulong bt = bytes[i];
        //            hash = hash * FNV_prime64;
        //            hash = hash ^ bt;
        //        }
        //        return hash;
        //    }
        //}

    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Helping/RpcLink.cs ---
﻿using FishNet.Object.Helping;

namespace FishNet.Object
{

    #region Types.
    /// <summary>
    /// Lookup data for a RPC Link.
    /// </summary>
    internal struct RpcLink
    {
        /// <summary>
        /// ObjectId for link.
        /// </summary>
        public int ObjectId;
        /// <summary>
        /// NetworkBehaviour component index on ObjectId.
        /// </summary>
        public byte ComponentIndex;
        /// <summary>
        /// RpcHash for link.
        /// </summary>
        public uint RpcHash;
        /// <summary>
        /// Type of Rpc link is for.
        /// </summary>
        public RpcType RpcType;

        public RpcLink(int objectId, byte componentIndex, uint rpcHash, RpcType rpcType)
        {
            ObjectId = objectId;
            ComponentIndex = componentIndex;
            RpcHash = rpcHash;
            RpcType = rpcType;
        }
    }
    #endregion

}
'''
'''--- Assets/FishNet/Runtime/Object/Helping/RpcType.cs ---
﻿namespace FishNet.Object.Helping
{
    public enum RpcType : int
    {
        None = 0,
        Server = 1,
        Observers = 2,
        Target = 4,
        Replicate = 8,
        Reconcile = 16
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Helping/StaticShortcuts.cs ---
﻿
namespace FishNet.Object.Helping
{

    public static class CodegenHelper
    {
        /// <summary>
        /// Returns if a NetworkObject is deinitializing.
        /// </summary>
        /// <param name="nb"></param>
        /// <returns></returns>
        public static bool NetworkObject_Deinitializing(NetworkBehaviour nb)
        {
            if (nb == null)
                return true;

            return nb.IsDeinitializing;
        }

        /// <summary>
        /// Returns if running as server.
        /// </summary>
        /// <param name="nb"></param>
        /// <returns></returns>
        public static bool IsServer(NetworkBehaviour nb)
        {
            if (nb == null)
                return false;

            return nb.IsServer;
        }

        /// <summary>
        /// Returns if running as client.
        /// </summary>
        /// <param name="nb"></param>
        /// <returns></returns>
        public static bool IsClient(NetworkBehaviour nb)
        {
            if (nb == null)
                return false;

            return nb.IsClient;
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Object/NetworkBehaviour.Callbacks.cs ---
﻿#if UNITY_2020_3_OR_NEWER
using FishNet.CodeAnalysis.Annotations;
#endif
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Object.Synchronizing.Internal;
using UnityEngine;

namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// True if OnStartServer has been called.
        /// </summary>
        [APIExclude]
        public bool OnStartServerCalled { get; private set; }
        /// <summary>
        /// True if OnStartClient has been called.
        /// </summary>
        [APIExclude]
        public bool OnStartClientCalled { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// True if OnStartNetwork has been called.
        /// </summary>
        private bool _onStartNetworkCalled;
        /// <summary>
        /// True if OnStopNetwork has been called.
        /// </summary>
        private bool _onStopNetworkCalled;
        #endregion

        /// <summary>
        /// Invokes cached callbacks on SyncTypes which were held until OnStartXXXXX was called.
        /// </summary>
        /// <param name="asServer"></param>
        internal void InvokeSyncTypeCallbacks(bool asServer)
        {
            foreach (SyncBase item in _syncVars.Values)
                item.OnStartCallback(asServer);
            foreach (SyncBase item in _syncObjects.Values)
                item.OnStartCallback(asServer);
        }
        /// <summary>
        /// Invokes the OnStart/StopNetwork.
        /// </summary>
        /// <param name="start"></param>
        internal void InvokeOnNetwork(bool start)
        {
            if (start)
            {
                if (_onStartNetworkCalled)
                    return;
                OnStartNetwork();
            }
            else
            {
                if (_onStopNetworkCalled)
                    return;
                OnStopNetwork();
            }
        }

        /// <summary>
        /// Called when the network has initialized this object. May be called for server or client but will only be called once.
        /// When as host or server this method will run before OnStartServer. 
        /// When as client only the method will run before OnStartClient.
        /// </summary>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnStartNetwork()
        {
            _onStartNetworkCalled = true;
            _onStopNetworkCalled = false;
        }
        /// <summary>
        /// Called when the network is deinitializing this object. May be called for server or client but will only be called once.
        /// When as host or server this method will run after OnStopServer.
        /// When as client only this method will run after OnStopClient.
        /// </summary>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnStopNetwork()
        {
            _onStopNetworkCalled = true;
            _onStartNetworkCalled = false;
        }

        /// <summary>
        /// Called on the server after initializing this object.
        /// SyncTypes modified before or during this method will be sent to clients in the spawn message.
        /// </summary> 
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnStartServer()
        {
            OnStartServerCalled = true;
        }
        /// <summary>
        /// Called on the server before deinitializing this object.
        /// </summary>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnStopServer()
        {
            OnStartServerCalled = false;
            ReturnRpcLinks();
        }
        /// <summary>
        /// Called on the server after ownership has changed.
        /// </summary>
        /// <param name="prevOwner">Previous owner of this object.</param>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnOwnershipServer(NetworkConnection prevOwner)
        {
            //When switching ownership always clear replicate cache on server.
            InternalClearReplicateCache(true);
        }
        /// <summary>
        /// Called on the server after a spawn message for this object has been sent to clients.
        /// Useful for sending remote calls or data to clients.
        /// </summary>
        /// <param name="connection">Connection the object is being spawned for.</param>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnSpawnServer(NetworkConnection connection) { }
        /// <summary>
        /// Called on the server before a despawn message for this object has been sent to connection.
        /// Useful for sending remote calls or actions to clients.
        /// </summary>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnDespawnServer(NetworkConnection connection) { }
        /// <summary>
        /// Called on the client after initializing this object.
        /// </summary>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnStartClient()
        {
            OnStartClientCalled = true;
        }
        /// <summary>
        /// Called on the client before deinitializing this object.
        /// </summary>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnStopClient()
        {
            OnStartClientCalled = false;
        }
        /// <summary>
        /// Called on the client after gaining or losing ownership.
        /// </summary>
        /// <param name="prevOwner">Previous owner of this object.</param>
#if UNITY_2020_3_OR_NEWER
        [OverrideMustCallBase(BaseCallMustBeFirstStatement = true)]
#endif
        public virtual void OnOwnershipClient(NetworkConnection prevOwner)
        {
            //If losing or gaining ownership then clear replicate cache.
            if (IsOwner || prevOwner == LocalConnection)
                InternalClearReplicateCache(false);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Object/NetworkBehaviour.Logging.cs ---
﻿using FishNet.Managing.Logging;
using UnityEngine;

namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {

        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        /// <param name="loggingType">Type of logging being filtered.</param>
        /// <returns></returns>
        public bool CanLog(LoggingType loggingType)
        {
            return (NetworkManager == null) ? false : NetworkManager.CanLog(loggingType);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/NetworkBehaviour.Prediction.cs ---
﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Object.Prediction.Delegating;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility.Constant;
using FishNet.Utility.Extension;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// 
        /// </summary>
        private uint _lastReconcileTick;
        /// <summary>
        /// Gets the last tick this NetworkBehaviour reconciled with.
        /// </summary>
        public uint GetLastReconcileTick() => _lastReconcileTick;
        /// <summary>
        /// Sets the last tick this NetworkBehaviour reconciled with.
        /// For internal use only.
        /// </summary>
        [CodegenMakePublic] //Internal only.
        protected internal void SetLastReconcileTick(uint value)
        {
            _lastReconcileTick = value;
            //Also set on the timemanager.
            TimeManager.LastReconcileTick = value;
        }
        /// <summary>
        /// 
        /// </summary>
        private uint _lastReplicateTick;
        /// <summary>
        /// Gets the last tick this NetworkBehaviour replicated with.
        /// </summary>
        public uint GetLastReplicateTick() => _lastReplicateTick;
        /// <summary>
        /// Sets the last tick this NetworkBehaviour replicated with.
        /// For internal use only.
        /// </summary>
        [CodegenMakePublic] //Make public.
        protected internal void SetLastReplicateTickInternal(uint value)
        {
            Owner.LocalReplicateTick = TimeManager.LocalTick;
            _lastReplicateTick = value;
            //Also set on the timemanager.
            TimeManager.LastReplicateTick = value;
        }
        /// <summary>
        /// True if this object is reconciling.
        /// </summary>
        public bool IsReconciling { get; internal set; }
        #endregion

        #region Private.
        /// <summary>
        /// Registered Replicate methods.
        /// </summary>
        private readonly Dictionary<uint, ReplicateRpcDelegate> _replicateRpcDelegates = new Dictionary<uint, ReplicateRpcDelegate>();
        /// <summary>
        /// Registered Reconcile methods.
        /// </summary>
        private readonly Dictionary<uint, ReconcileRpcDelegate> _reconcileRpcDelegates = new Dictionary<uint, ReconcileRpcDelegate>();
        /// <summary>
        /// True if initialized compnents for prediction.
        /// </summary>
        private bool _predictionInitialized;
        /// <summary>
        /// Rigidbody found on this object. This is used for prediction.
        /// </summary>
        private Rigidbody _predictionRigidbody;
        /// <summary>
        /// Rigidbody2D found on this object. This is used for prediction.
        /// </summary>
        private Rigidbody2D _predictionRigidbody2d;
        /// <summary>
        /// Last position for TransformMayChange.
        /// </summary>
        private Vector3 _lastMayChangePosition;
        /// <summary>
        /// Last rotation for TransformMayChange.
        /// </summary>
        private Quaternion _lastMayChangeRotation;
        /// <summary>
        /// Last scale for TransformMayChange.
        /// </summary>
        private Vector3 _lastMayChangeScale;
        #endregion

        /// <summary>
        /// Registers a RPC method.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [APIExclude] //codegen this can be made protected internal then set public via codegen
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected internal void RegisterReplicateRpc(uint hash, ReplicateRpcDelegate del)
        {
            _replicateRpcDelegates[hash] = del;
        }
        /// <summary>
        /// Registers a RPC method.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [APIExclude] //codegen this can be made protected internal then set public via codegen
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected internal void RegisterReconcileRpc(uint hash, ReconcileRpcDelegate del)
        {
            _reconcileRpcDelegates[hash] = del;
        }

        /// <summary>
        /// Called when a replicate is received.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void OnReplicateRpc(uint? methodHash, PooledReader reader, NetworkConnection sendingClient, Channel channel)
        {
            if (methodHash == null)
                methodHash = ReadRpcHash(reader);

            if (sendingClient == null)
            {
                if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"NetworkConnection is null. Replicate {methodHash.Value} on {gameObject.name}, behaviour {GetType().Name} will not complete. Remainder of packet may become corrupt.");
                return;
            }

            if (_replicateRpcDelegates.TryGetValueIL2CPP(methodHash.Value, out ReplicateRpcDelegate del))
            {
                del.Invoke(this, reader, sendingClient);
            }
            else
            {
                if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Replicate not found for hash {methodHash.Value} on {gameObject.name}, behaviour {GetType().Name}. Remainder of packet may become corrupt.");
            }
        }

        /// <summary>
        /// Called when a reconcile is received.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void OnReconcileRpc(uint? methodHash, PooledReader reader, Channel channel)
        {
            if (methodHash == null)
                methodHash = ReadRpcHash(reader);

            if (_reconcileRpcDelegates.TryGetValueIL2CPP(methodHash.Value, out ReconcileRpcDelegate del))
            {
                del.Invoke(this, reader);
            }
            else
            {
                if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Reconcile not found for hash {methodHash.Value}. Remainder of packet may become corrupt.");
            }
        }

        /// <summary>
        /// Clears cached replicates. This can be useful to call on server and client after teleporting.
        /// </summary>
        /// <param name="asServer">True to reset values for server, false to reset values for client.</param>
        public void ClearReplicateCache(bool asServer) { InternalClearReplicateCache(asServer); }
        /// <summary>
        /// Clears cached replicates for server and client. This can be useful to call on server and client after teleporting.
        /// </summary>
        public void ClearReplicateCache()
        {
            InternalClearReplicateCache(true);
            InternalClearReplicateCache(false);
        }
        /// <summary>
        /// Clears cached replicates.
        /// For internal use only.
        /// </summary>
        /// <param name="asServer"></param>
        [APIExclude]
        protected internal virtual void InternalClearReplicateCache(bool asServer) { }

        /// <summary>
        /// Writes number of past inputs from buffer to writer and sends it to the server.
        /// Internal use. 
        /// </summary> //codegen can be made internal, then public via codegen
        [APIExclude]
        public void SendReplicateRpc<T>(uint hash, List<T> replicateBuffer, int count)
        {
            if (!IsSpawnedWithWarning())
                return;

            int lastBufferIndex = (replicateBuffer.Count - 1);
            //Nothing to send; should never be possible.
            if (lastBufferIndex < 0)
                return;
            /* Where to start writing from. When passed
             * into the writer values from this offset
             * and forward will be written. */
            int offset = replicateBuffer.Count - count;
            if (offset < 0)
                offset = 0;

            Channel channel = Channel.Unreliable;
            //Write history to methodWriter.
            PooledWriter methodWriter = WriterPool.GetWriter(WriterPool.LENGTH_BRACKET);
            methodWriter.WriteList(replicateBuffer, offset);

            PooledWriter writer;
            //if (_rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
            //writer = CreateLinkedRpc(link, methodWriter, Channel.Unreliable);
            //else //todo add support for -> server rpc links.
            writer = CreateRpc(hash, methodWriter, PacketId.Replicate, channel);
            NetworkManager.TransportManager.SendToServer((byte)channel, writer.GetArraySegment(), false);

            methodWriter.DisposeLength();
            writer.DisposeLength();
        }

        /// <summary>
        /// Sends a RPC to target.
        /// Internal use.
        /// </summary>
        [APIExclude] //codegen this can be made internal then set public via codegen
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SendReconcileRpc<T>(uint hash, T reconcileData, Channel channel)
        {
            if (!IsSpawned)
                return;
            if (!Owner.IsActive)
                return;

            PooledWriter methodWriter = WriterPool.GetWriter();
            methodWriter.Write(reconcileData);

            PooledWriter writer;
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            if (NetworkManager.DebugManager.ReconcileRpcLinks && _rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#else
            if (_rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#endif
                writer = CreateLinkedRpc(link, methodWriter, channel);
            else
                writer = CreateRpc(hash, methodWriter, PacketId.Reconcile, channel);

            _networkObjectCache.NetworkManager.TransportManager.SendToClient((byte)channel, writer.GetArraySegment(), Owner);

            methodWriter.Dispose();
            writer.Dispose();
        }

        /// <summary>
        /// Returns if there is a chance the transform may change after the tick.
        /// </summary>
        /// <returns></returns>
        protected internal bool TransformMayChange()
        {
            if (!_predictionInitialized)
            {
                _predictionInitialized = true;
                _predictionRigidbody = GetComponentInParent<Rigidbody>();
                _predictionRigidbody2d = GetComponentInParent<Rigidbody2D>();
            }

            /* Use distance when checking if changed because rigidbodies can twitch
             * or move an extremely small amount. These small moves are not worth
             * resending over because they often fix themselves each frame. */
            float changeDistance = 0.000004f;

            bool positionChanged = (transform.position - _lastMayChangePosition).sqrMagnitude > changeDistance;
            bool rotationChanged = (transform.rotation.eulerAngles - _lastMayChangeRotation.eulerAngles).sqrMagnitude > changeDistance;
            bool scaleChanged = (transform.localScale - _lastMayChangeScale).sqrMagnitude > changeDistance;
            bool transformChanged = (positionChanged || rotationChanged || scaleChanged);
            /* Returns true if transform.hasChanged, or if either
             * of the rigidbodies have velocity. */
            bool changed = (
                transformChanged ||
                (_predictionRigidbody != null && (_predictionRigidbody.velocity != Vector3.zero || _predictionRigidbody.angularVelocity != Vector3.zero)) ||
                (_predictionRigidbody2d != null && (_predictionRigidbody2d.velocity != Vector2.zero || _predictionRigidbody2d.angularVelocity != 0f))
                );

            //If transform changed update last values.
            if (transformChanged)
            {
                _lastMayChangePosition = transform.position;
                _lastMayChangeRotation = transform.rotation;
                _lastMayChangeScale = transform.localScale;
            }

            return changed;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/NetworkBehaviour.QOL.cs ---
﻿#if UNITY_2020_3_OR_NEWER
using FishNet.CodeAnalysis.Annotations;
#endif
using FishNet.Component.ColliderRollback;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Client;
using FishNet.Managing.Logging;
using FishNet.Managing.Observing;
using FishNet.Managing.Scened;
using FishNet.Managing.Server;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        /// <summary>
        /// True if the NetworkObject for this NetworkBehaviour is deinitializing.
        /// </summary>
        public bool IsDeinitializing => _networkObjectCache.IsDeinitializing;
        [Obsolete("Use IsDeinitializing instead.")]
        public bool Deinitializing => IsDeinitializing; //Remove on 2023/01/01.
        /// <summary>
        /// NetworkManager for this object.
        /// </summary>
        public NetworkManager NetworkManager => _networkObjectCache.NetworkManager;
        /// <summary>
        /// ServerManager for this object.
        /// </summary>
        public ServerManager ServerManager => _networkObjectCache.ServerManager;
        /// <summary>
        /// ClientManager for this object.
        /// </summary>
        public ClientManager ClientManager => _networkObjectCache.ClientManager;
        /// <summary>
        /// ObserverManager for this object.
        /// </summary>
        public ObserverManager ObserverManager => _networkObjectCache.ObserverManager;
        /// <summary>
        /// TransportManager for this object.
        /// </summary>
        public TransportManager TransportManager => _networkObjectCache.TransportManager;
        /// <summary>
        /// TimeManager for this object.
        /// </summary>
        public TimeManager TimeManager => _networkObjectCache.TimeManager;
        /// <summary>
        /// SceneManager for this object.
        /// </summary>
        public SceneManager SceneManager => _networkObjectCache.SceneManager;
        /// <summary>
        /// RollbackManager for this object.
        /// </summary>
        public RollbackManager RollbackManager => _networkObjectCache.RollbackManager;
        /// <summary>
        /// True if the client is active and authenticated.
        /// </summary>
        public bool IsClient => _networkObjectCache.IsClient;
        /// <summary>
        /// True if only the client is active and authenticated.
        /// </summary>
        public bool IsClientOnly => _networkObjectCache.IsClientOnly;
        /// <summary>
        /// True if server is active.
        /// </summary>
        public bool IsServer => _networkObjectCache.IsServer;
        /// <summary>
        /// True if only the server is active.
        /// </summary>
        public bool IsServerOnly => _networkObjectCache.IsServerOnly;
        /// <summary>
        /// True if client and server are active.
        /// </summary>
        public bool IsHost => _networkObjectCache.IsHost;
        /// <summary>
        /// True if client nor server are active.
        /// </summary>
        public bool IsOffline => _networkObjectCache.IsOffline;
        /// <summary>
        /// Observers for this NetworkBehaviour.
        /// </summary>
        public HashSet<NetworkConnection> Observers => _networkObjectCache.Observers;
        /// <summary>
        /// True if the local client is the owner of this object.
        /// </summary>
#if UNITY_2020_3_OR_NEWER
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartServer", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartNetwork", " Use base.Owner.IsLocalClient instead.")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Awake", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Start", "")]
#endif
        public bool IsOwner => _networkObjectCache.IsOwner;
        /// <summary>
        /// Owner of this object.
        /// </summary>
        public NetworkConnection Owner
        {
            get
            {
                //Ensures a null Owner is never returned.
                if (_networkObjectCache == null)
                    return FishNet.Managing.NetworkManager.EmptyConnection;

                return _networkObjectCache.Owner;
            }
        }
        /// <summary>
        /// ClientId for this NetworkObject owner.
        /// </summary>
        public int OwnerId => _networkObjectCache.OwnerId;
        /// <summary>
        /// Unique Id for this _networkObjectCache. This does not represent the object owner.
        /// </summary>
        public int ObjectId => _networkObjectCache.ObjectId;
        /// <summary>
        /// The local connection of the client calling this method.
        /// </summary>
        public NetworkConnection LocalConnection => _networkObjectCache.LocalConnection;
        /// <summary>
        /// Returns if a connection is the owner of this object.
        /// Internal use.
        /// </summary>
        /// <param name="connection"></param>
        /// <returns></returns>
        public bool CompareOwner(NetworkConnection connection)
        {
            return (_networkObjectCache.Owner == connection);
        }
        /// <summary>
        /// Despawns this _networkObjectCache. Can only be called on the server.
        /// </summary>
        /// <param name="cacheOnDespawnOverride">Overrides the default DisableOnDespawn value for this single despawn. Scene objects will never be destroyed.</param>
        public void Despawn(DespawnType? despawnType = null)
        {
            if (!IsNetworkObjectNull(true))
                _networkObjectCache.Despawn(despawnType);
        }
        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="go">GameObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        public void Spawn(GameObject go, NetworkConnection ownerConnection = null)
        {
            if (IsNetworkObjectNull(true))
                return;
            _networkObjectCache.Spawn(go, ownerConnection);
        }
        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="nob">GameObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        public void Spawn(NetworkObject nob, NetworkConnection ownerConnection = null)
        {
            if (IsNetworkObjectNull(true))
                return;
            _networkObjectCache.Spawn(nob, ownerConnection);
        }
        /// <summary>
        /// Returns if NetworkObject is null.
        /// </summary>
        /// <param name="warn">True to throw a warning if null.</param>
        /// <returns></returns>
        private bool IsNetworkObjectNull(bool warn)
        {
            bool isNull = (_networkObjectCache == null);
            if (isNull && warn)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"NetworkObject is null. This can occur if this object is not spawned, or initialized yet.");
            }

            return isNull;
        }
        /// <summary>
        /// Removes ownership from all clients.
        /// </summary>
        public void RemoveOwnership()
        {
            _networkObjectCache.GiveOwnership(null, true);
        }
        /// <summary>
        /// Gives ownership to newOwner.
        /// </summary>
        /// <param name="newOwner"></param>
        public void GiveOwnership(NetworkConnection newOwner)
        {
            _networkObjectCache.GiveOwnership(newOwner, true);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/NetworkBehaviour.RPCLinks.cs ---
﻿using FishNet.Managing.Server;
using FishNet.Object.Helping;
using FishNet.Serializing;
using FishNet.Transporting;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Private.        
        /// <summary>
        /// Link indexes for RPCs.
        /// </summary>
        private Dictionary<uint, RpcLinkType> _rpcLinks = new Dictionary<uint, RpcLinkType>();
        #endregion

        /// <summary>
        /// Initializes RpcLinks. This will only call once even as host.
        /// </summary>
        private void InitializeOnceRpcLinks()
        {
            if (NetworkManager.IsServer)
            {
                /* Link only data from server to clients. While it is
                 * just as easy to link client to server it's usually
                 * not needed because server out data is more valuable
                 * than server in data. */
                /* Links will be stored in the NetworkBehaviour so that
                 * when the object is destroyed they can be added back
                 * into availableRpcLinks, within the ServerManager. */

                ServerManager serverManager = NetworkManager.ServerManager;
                //ObserverRpcs.
                foreach (uint rpcHash in _observersRpcDelegates.Keys)
                {
                    if (!MakeLink(rpcHash, RpcType.Observers))
                        return;
                }
                //TargetRpcs.
                foreach (uint rpcHash in _targetRpcDelegates.Keys)
                {
                    if (!MakeLink(rpcHash, RpcType.Target))
                        return;
                }
                //ReconcileRpcs.
                foreach (uint rpcHash in _reconcileRpcDelegates.Keys)
                {
                    if (!MakeLink(rpcHash, RpcType.Reconcile))
                        return;
                }

                /* Tries to make a link and returns if
                 * successful. When a link cannot be made the method
                 * should exit as no other links will be possible. */
                bool MakeLink(uint rpcHash, RpcType rpcType)
                {
                    if (serverManager.GetRpcLink(out ushort linkIndex))
                    {
                        _rpcLinks[rpcHash] = new RpcLinkType(linkIndex, rpcType);
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        /// <summary>
        /// Returns an estimated length for any Rpc header.
        /// </summary>
        /// <returns></returns>
        private int GetEstimatedRpcHeaderLength()
        {
            /* Imaginary number for how long RPC headers are.
            * They are well under this value but this exist to
            * ensure a writer of appropriate length is pulled
            * from the pool. */
            return 20;
        }

        /// <summary>
        /// Creates a PooledWriter and writes the header for a rpc.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private PooledWriter CreateLinkedRpc(RpcLinkType link, PooledWriter methodWriter, Channel channel)
        {
            int rpcHeaderBufferLength = GetEstimatedRpcHeaderLength();
            int methodWriterLength = methodWriter.Length;
            //Writer containing full packet.
            PooledWriter writer = WriterPool.GetWriter(rpcHeaderBufferLength + methodWriterLength);
            writer.WriteUInt16(link.LinkIndex);
            //Write length only if reliable.
            if (channel == Channel.Reliable)
                writer.WriteLength(methodWriter.Length);
            //Data.
            writer.WriteArraySegment(methodWriter.GetArraySegment());

            return writer;
        }

        /// <summary>
        /// Returns RpcLinks the ServerManager.
        /// </summary>
        private void ReturnRpcLinks()
        {
            if (_rpcLinks.Count == 0)
                return;

            ServerManager?.ReturnRpcLinks(_rpcLinks);
            _rpcLinks.Clear();
        }

        /// <summary>
        /// Writes rpcLinks to writer.
        /// </summary>
        internal void WriteRpcLinks(PooledWriter writer)
        {
            PooledWriter rpcLinkWriter = WriterPool.GetWriter();
            foreach (KeyValuePair<uint, RpcLinkType> item in _rpcLinks)
            {
                //RpcLink index.
                rpcLinkWriter.WriteUInt16(item.Value.LinkIndex);
                //Hash.
                rpcLinkWriter.WriteUInt16((ushort)item.Key);
                //True/false if observersRpc.
                rpcLinkWriter.WriteByte((byte)item.Value.RpcType);
            }

            writer.WriteBytesAndSize(rpcLinkWriter.GetBuffer(), 0, rpcLinkWriter.Length);
            rpcLinkWriter.Dispose();
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkBehaviour.RPCs.cs ---
﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Object.Delegating;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// Registered ServerRpc methods.
        /// </summary>
        private readonly Dictionary<uint, ServerRpcDelegate> _serverRpcDelegates = new Dictionary<uint, ServerRpcDelegate>();
        /// <summary>
        /// Registered ObserversRpc methods.
        /// </summary>
        private readonly Dictionary<uint, ClientRpcDelegate> _observersRpcDelegates = new Dictionary<uint, ClientRpcDelegate>();
        /// <summary>
        /// Registered TargetRpc methods.
        /// </summary>
        private readonly Dictionary<uint, ClientRpcDelegate> _targetRpcDelegates = new Dictionary<uint, ClientRpcDelegate>();
        /// <summary>
        /// Number of total RPC methods for scripts in the same inheritance tree for this instance.
        /// </summary>
        private uint _rpcMethodCount;
        /// <summary>
        /// Size of every rpcHash for this networkBehaviour.
        /// </summary>
        private byte _rpcHashSize = 1;
        /// <summary>
        /// RPCs buffered for new clients.
        /// </summary>
        private Dictionary<uint, (PooledWriter, Channel)> _bufferedRpcs = new Dictionary<uint, (PooledWriter, Channel)>();
        #endregion

        /// <summary>
        /// Called when buffered RPCs should be sent.
        /// </summary>
        internal void SendBufferedRpcs(NetworkConnection conn)
        {
            TransportManager tm = _networkObjectCache.NetworkManager.TransportManager;
            foreach ((PooledWriter writer, Channel ch) in _bufferedRpcs.Values)
                tm.SendToClient((byte)ch, writer.GetArraySegment(), conn);
        }

        /// <summary>
        /// Registers a RPC method.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [APIExclude] //codegen this can be made protected internal then set public via codegen
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected internal void RegisterServerRpc(uint hash, ServerRpcDelegate del)
        {
            bool contains = _serverRpcDelegates.ContainsKey(hash);
            _serverRpcDelegates[hash] = del;
            if (!contains)
                IncreaseRpcMethodCount();
        }
        /// <summary>
        /// Registers a RPC method.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [APIExclude] //codegen this can be made protected internal then set public via codegen
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected internal void RegisterObserversRpc(uint hash, ClientRpcDelegate del)
        {
            bool contains = _observersRpcDelegates.ContainsKey(hash);
            _observersRpcDelegates[hash] = del;
            if (!contains)
                IncreaseRpcMethodCount();
        }
        /// <summary>
        /// Registers a RPC method.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [APIExclude] //codegen this can be made protected internal then set public via codegen
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected internal void RegisterTargetRpc(uint hash, ClientRpcDelegate del)
        {
            bool contains = _targetRpcDelegates.ContainsKey(hash);
            _targetRpcDelegates[hash] = del;
            if (!contains)
                IncreaseRpcMethodCount();
        }

        /// <summary>
        /// Increases rpcMethodCount and rpcHashSize.
        /// </summary>
        private void IncreaseRpcMethodCount()
        {
            _rpcMethodCount++;
            if (_rpcMethodCount <= byte.MaxValue)
                _rpcHashSize = 1;
            else
                _rpcHashSize = 2;
        }

        /// <summary>
        /// Clears all buffered RPCs for this NetworkBehaviour.
        /// </summary>
        public void ClearBuffedRpcs()
        {
            foreach ((PooledWriter writer, Channel _) in _bufferedRpcs.Values)
                writer.Dispose();
            _bufferedRpcs.Clear();
        }

        /// <summary>
        /// Reads a RPC hash.
        /// </summary>
        /// <param name="reader"></param>
        /// <returns></returns>
        private uint ReadRpcHash(PooledReader reader)
        {
            if (_rpcHashSize == 1)
                return reader.ReadByte();
            else
                return reader.ReadUInt16();
        }
        /// <summary>
        /// Called when a ServerRpc is received.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void OnServerRpc(PooledReader reader, NetworkConnection sendingClient, Channel channel)
        {
            uint methodHash = ReadRpcHash(reader);

            if (sendingClient == null)
            {
                if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"NetworkConnection is null. ServerRpc {methodHash} on object {gameObject.name} [id {ObjectId}] will not complete. Remainder of packet may become corrupt.");
                return;
            }

            if (_serverRpcDelegates.TryGetValueIL2CPP(methodHash, out ServerRpcDelegate data))
            {
                data.Invoke(this, reader, channel, sendingClient);
            }
            else
            {
                if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"ServerRpc not found for hash {methodHash} on object {gameObject.name} [id {ObjectId}]. Remainder of packet may become corrupt.");
            }
        }

        /// <summary>
        /// Called when an ObserversRpc is received.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void OnObserversRpc(uint? methodHash, PooledReader reader, Channel channel)
        {
            if (methodHash == null)
                methodHash = ReadRpcHash(reader);

            if (_observersRpcDelegates.TryGetValueIL2CPP(methodHash.Value, out ClientRpcDelegate del))
            {
                del.Invoke(this, reader, channel);
            }
            else
            {
                if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"ObserversRpc not found for hash {methodHash.Value} on object {gameObject.name} [id {ObjectId}] . Remainder of packet may become corrupt.");
            }
        }

        /// <summary>
        /// Called when an TargetRpc is received.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void OnTargetRpc(uint? methodHash, PooledReader reader, Channel channel)
        {
            if (methodHash == null)
                methodHash = ReadRpcHash(reader);

            if (_targetRpcDelegates.TryGetValueIL2CPP(methodHash.Value, out ClientRpcDelegate del))
            {
                del.Invoke(this, reader, channel);
            }
            else
            {
                if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"TargetRpc not found for hash {methodHash.Value} on object {gameObject.name} [id {ObjectId}] . Remainder of packet may become corrupt.");
            }
        }

        /// <summary>
        /// Sends a RPC to server.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="methodWriter"></param>
        /// <param name="channel"></param>
        [CodegenMakePublic] //Make internal.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SendServerRpc(uint hash, PooledWriter methodWriter, Channel channel)
        {
            if (!IsSpawnedWithWarning())
                return;

            PooledWriter writer = CreateRpc(hash, methodWriter, PacketId.ServerRpc, channel);
            _networkObjectCache.NetworkManager.TransportManager.SendToServer((byte)channel, writer.GetArraySegment());
            writer.DisposeLength();
        }

        /// <summary>
        /// Sends a RPC to observers.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="methodWriter"></param>
        /// <param name="channel"></param>
        [APIExclude]
        [CodegenMakePublic] //Make internal.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SendObserversRpc(uint hash, PooledWriter methodWriter, Channel channel, bool buffered)
        {
            if (!IsSpawnedWithWarning())
                return;

            PooledWriter writer;
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            if (NetworkManager.DebugManager.ObserverRpcLinks && _rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#else
            if (_rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#endif
                writer = CreateLinkedRpc(link, methodWriter, channel);
            else
                writer = CreateRpc(hash, methodWriter, PacketId.ObserversRpc, channel);

            _networkObjectCache.NetworkManager.TransportManager.SendToClients((byte)channel, writer.GetArraySegment(), _networkObjectCache.Observers);
            /* If buffered then dispose of any already buffered
             * writers and replace with new one. Writers should
             * automatically dispose when references are lost
             * anyway but better safe than sorry. */
            if (buffered)
            {
                if (_bufferedRpcs.TryGetValueIL2CPP(hash, out (PooledWriter pw, Channel ch) result))
                    result.pw.DisposeLength();
                _bufferedRpcs[hash] = (writer, channel);
            }
            //If not buffered then dispose immediately.
            else
            {
                writer.DisposeLength();
            }
        }

        /// <summary>
        /// Sends a RPC to target.
        /// Internal use.
        /// </summary>
        [CodegenMakePublic] //Make internal.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SendTargetRpc(uint hash, PooledWriter methodWriter, Channel channel, NetworkConnection target, bool validateTarget = true)
        {
            if (!IsSpawnedWithWarning())
                return;

            if (validateTarget)
            {
                if (target == null)
                {
                    if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Warning))
                        Debug.LogWarning($"Action cannot be completed as no Target is specified.");
                    return;
                }
                else
                {
                    //If target is not an observer.
                    if (!_networkObjectCache.Observers.Contains(target))
                    {
                        if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Warning))
                            Debug.LogWarning($"Action cannot be completed as Target is not an observer for object {gameObject.name} [id {ObjectId}].");
                        return;
                    }
                }
            }

            PooledWriter writer;

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            if (NetworkManager.DebugManager.TargetRpcLinks && _rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#else
            if (_rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#endif
                writer = CreateLinkedRpc(link, methodWriter, channel);
            else
                writer = CreateRpc(hash, methodWriter, PacketId.TargetRpc, channel);

            _networkObjectCache.NetworkManager.TransportManager.SendToClient((byte)channel, writer.GetArraySegment(), target);
            writer.DisposeLength();
        }

        /// <summary>
        /// Returns if spawned and throws a warning if not.
        /// </summary>
        /// <returns></returns>
        private bool IsSpawnedWithWarning()
        {
            bool result = this.IsSpawned;
            if (!result)
            {
                if (_networkObjectCache.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Action cannot be completed as object {gameObject.name} [Id {ObjectId}] is not spawned.");
            }

            return result;
        }

        /// <summary>
        /// Writes a full RPC and returns the writer.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private PooledWriter CreateRpc(uint hash, PooledWriter methodWriter, PacketId packetId, Channel channel)
        {
            int rpcHeaderBufferLength = GetEstimatedRpcHeaderLength();
            int methodWriterLength = methodWriter.Length;
            //Writer containing full packet.
            PooledWriter writer = WriterPool.GetWriter(rpcHeaderBufferLength + methodWriterLength);
            writer.WritePacketId(packetId);
            writer.WriteNetworkBehaviour(this);
            //Only write length if reliable.
            if (channel == Channel.Reliable)
                writer.WriteLength(methodWriterLength + _rpcHashSize);
            //Hash and data.
            WriteRpcHash(hash, writer);
            writer.WriteArraySegment(methodWriter.GetArraySegment());
            return writer;
        }

        /// <summary>
        /// Writes rpcHash to writer.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="writer"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void WriteRpcHash(uint hash, PooledWriter writer)
        {
            if (_rpcHashSize == 1)
                writer.WriteByte((byte)hash);
            else
                writer.WriteUInt16((byte)hash);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/NetworkBehaviour.SyncTypes.cs ---
﻿using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Object.Synchronizing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Types.
        /// <summary>
        /// Used to generate data sent from synctypes.
        /// </summary>
        private class SyncTypeWriter
        {
            /// <summary>
            /// Clients which can be synchronized.
            /// </summary>
            public ReadPermission ReadPermission;
            /// <summary>
            /// Writers for each channel.
            /// </summary>
            public PooledWriter[] Writers { get; private set; }

            public SyncTypeWriter(ReadPermission readPermission)
            {
                ReadPermission = readPermission;
                Writers = new PooledWriter[TransportManager.CHANNEL_COUNT];
                for (int i = 0; i < Writers.Length; i++)
                    Writers[i] = WriterPool.GetWriter();
            }

            /// <summary>
            /// Resets Writers.
            /// </summary>
            public void Reset()
            {
                if (Writers == null)
                    return;

                for (int i = 0; i < Writers.Length; i++)
                    Writers[i].Reset();
            }
        }
        #endregion

        #region Private.
        /// <summary>
        /// Writers for syncTypes. A writer will exist for every ReadPermission type.
        /// </summary>
        private SyncTypeWriter[] _syncTypeWriters;
        /// <summary>
        /// SyncVars within this NetworkBehaviour.
        /// </summary>
        private Dictionary<uint, SyncBase> _syncVars = new Dictionary<uint, SyncBase>();
        /// <summary>
        /// True if at least one syncVar is dirty.
        /// </summary>
        private bool _syncVarDirty;
        /// <summary>
        /// SyncVars within this NetworkBehaviour.
        /// </summary>
        private Dictionary<uint, SyncBase> _syncObjects = new Dictionary<uint, SyncBase>();
        /// <summary>
        /// True if at least one syncObject is dirty.
        /// </summary>
        private bool _syncObjectDirty;
        /// <summary>
        /// All ReadPermission values.
        /// </summary>
        private static ReadPermission[] _readPermissions;
        #endregion

        /// <summary>
        /// Registers a SyncType.
        /// </summary>
        /// <param name="sb"></param>
        /// <param name="index"></param>
        internal void RegisterSyncType(SyncBase sb, uint index)
        {
            if (sb.IsSyncObject)
                _syncObjects.Add(index, sb);
            else
                _syncVars.Add(index, sb);
        }
        /// <summary>
        /// Sets a SyncVar as dirty.
        /// </summary>
        /// <param name="isSyncObject">True if dirtying a syncObject.</param>
        /// <returns>True if able to dirty SyncType.</returns>
        internal bool DirtySyncType(bool isSyncObject)
        {
            if (!IsServer)
                return false;
            /* No reason to dirty if there are no observers.
             * This can happen even if a client is going to see
             * this object because the server side initializes
             * before observers are built. */
            if (_networkObjectCache.Observers.Count == 0)
                return false;

            bool alreadyDirtied = (isSyncObject) ? _syncObjectDirty : _syncVarDirty;
            if (isSyncObject)
                _syncObjectDirty = true;
            else
                _syncVarDirty = true;

            if (!alreadyDirtied)
                _networkObjectCache.NetworkManager.ServerManager.Objects.SetDirtySyncType(this, isSyncObject);

            return true;
        }

        /// <summary>
        /// Initializes SyncTypes. This will only call once even as host.
        /// </summary>
        private void InitializeOnceSyncTypes()
        {
            if (_readPermissions == null)
            {
                System.Array arr = System.Enum.GetValues(typeof(ReadPermission));
                _readPermissions = new ReadPermission[arr.Length];

                int count = 0;
                foreach (ReadPermission rp in arr)
                {
                    _readPermissions[count] = rp;
                    count++;
                }
            }

            //Build writers for observers and owner.
            _syncTypeWriters = new SyncTypeWriter[_readPermissions.Length];
            for (int i = 0; i < _syncTypeWriters.Length; i++)
                _syncTypeWriters[i] = new SyncTypeWriter(_readPermissions[i]);

            foreach (SyncBase sb in _syncVars.Values)
                sb.PreInitialize(_networkObjectCache.NetworkManager);
            foreach (SyncBase sb in _syncObjects.Values)
                sb.PreInitialize(_networkObjectCache.NetworkManager);
        }

        /// <summary>
        /// Reads a SyncVar.
        /// </summary>
        /// <param name="reader"></param>
        internal void OnSyncType(PooledReader reader, int length, bool isSyncObject)
        {
            int readerStart = reader.Position;
            while (reader.Position - readerStart < length)
            {
                byte index = reader.ReadByte();
                if (isSyncObject)
                {
                    if (_syncObjects.TryGetValueIL2CPP(index, out SyncBase sb))
                    {
                        sb.Read(reader);
                    }
                    else
                    {
                        if (NetworkManager.CanLog(LoggingType.Warning))
                            Debug.LogWarning($"SyncObject not found for index {index} on {transform.name}. Remainder of packet may become corrupt.");
                    }
                }
                else
                {
                    if (_syncVars.ContainsKey(index))
                    {
                        ReadSyncVar(reader, index);
                    }
                    else
                    {
                        if (NetworkManager.CanLog(LoggingType.Warning))
                            Debug.LogWarning($"SyncVar not found for index {index} on {transform.name}. Remainder of packet may become corrupt.");
                    }
                }
            }
        }

        /// <summary>
        /// Codegen overrides this method to read syncVars for each script which inherits NetworkBehaviour.
        /// </summary>
        /// <param name="reader"></param>
        /// <param name="index"></param>
        [APIExclude]
        internal virtual bool ReadSyncVar(PooledReader reader, uint index) { return false; }

        /// <summary>
        /// Writers dirty SyncTypes if their write tick has been met.
        /// </summary>
        /// <returns>True if there are no pending dirty sync types.</returns>
        internal bool WriteDirtySyncTypes(bool isSyncObject, bool ignoreInterval = false)
        {
            /* Can occur when a synctype is queued after
             * the object is marked for destruction. This should not
             * happen under most conditions since synctypes will be
             * pushed through when despawn is called. */
            if (!IsSpawned)
            {
                Dictionary<uint, SyncBase> c1 = (isSyncObject) ? _syncObjects : _syncVars;
                foreach (SyncBase sb in c1.Values)
                    sb.ResetDirty();

                return true;
            }

            /* If there is nothing dirty then return true, indicating no more
             * pending dirty checks. */
            if (isSyncObject && (!_syncObjectDirty || _syncObjects.Count == 0))
                return true;
            else if (!isSyncObject && (!_syncVarDirty || _syncVars.Count == 0))
                return true;

            /* True if writers have been reset for this check.
             * For perf writers are only reset when data is to be written. */
            bool writersReset = false;
            uint tick = _networkObjectCache.NetworkManager.TimeManager.Tick;

            //True if a syncvar is found to still be dirty.
            bool dirtyFound = false;
            //True if data has been written and is ready to send.
            bool dataWritten = false;
            Dictionary<uint, SyncBase> collection = (isSyncObject) ? _syncObjects : _syncVars;

            foreach (SyncBase sb in collection.Values)
            {
                if (!sb.IsDirty)
                    continue;

                dirtyFound = true;
                if (ignoreInterval || sb.WriteTimeMet(tick))
                {
                    //If writers still need to be reset.
                    if (!writersReset)
                    {
                        writersReset = true;
                        //Reset writers.
                        for (int i = 0; i < _syncTypeWriters.Length; i++)
                            _syncTypeWriters[i].Reset();
                    }

                    //Find channel.
                    byte channel = (byte)sb.Channel;
                    sb.ResetDirty();
                    //If ReadPermission is owner but no owner skip this syncvar write.
                    if (sb.Settings.ReadPermission == ReadPermission.OwnerOnly && !_networkObjectCache.Owner.IsValid)
                        continue;

                    dataWritten = true;
                    //Find PooledWriter to use.
                    PooledWriter writer = null;
                    for (int i = 0; i < _syncTypeWriters.Length; i++)
                    {
                        if (_syncTypeWriters[i].ReadPermission == sb.Settings.ReadPermission)
                        {
                            /* Channel for syncVar is beyond available channels in transport.
                             * Use default reliable. */
                            if (channel >= _syncTypeWriters[i].Writers.Length)
                                channel = (byte)Channel.Reliable;

                            writer = _syncTypeWriters[i].Writers[channel];
                            break;
                        }
                    }

                    if (writer == null)
                    {
                        if (NetworkManager.CanLog(LoggingType.Error))
                            Debug.LogError($"Writer couldn't be found for permissions {sb.Settings.ReadPermission} on channel {channel}.");
                    }
                    else
                    {
                        sb.WriteDelta(writer);
                    }
                }
            }

            //If no dirty were found.
            if (!dirtyFound)
            {
                if (isSyncObject)
                    _syncObjectDirty = false;
                else
                    _syncVarDirty = false;
                return true;
            }
            //At least one sync type was dirty.
            else if (dataWritten)
            {
                for (int i = 0; i < _syncTypeWriters.Length; i++)
                {
                    for (byte channel = 0; channel < _syncTypeWriters[i].Writers.Length; channel++)
                    {
                        PooledWriter channelWriter = _syncTypeWriters[i].Writers[channel];
                        //If there is data to send.
                        if (channelWriter.Length > 0)
                        {
                            using (PooledWriter headerWriter = WriterPool.GetWriter())
                            {
                                //Write the packetId and NB information.
                                PacketId packetId = (isSyncObject) ? PacketId.SyncObject : PacketId.SyncVar;
                                headerWriter.WritePacketId(packetId);
                                PooledWriter dataWriter = WriterPool.GetWriter();
                                dataWriter.WriteNetworkBehaviour(this);

                                /* SyncVars need length written regardless because amount
                                 * of data being sent per syncvar is unknown, and the packet may have
                                 * additional data after the syncvars. Because of this we should only
                                 * read up to syncvar length then assume the remainder is another packet. 
                                 * 
                                 * Reliable always has data written as well even if syncObject. This is so
                                 * if an object does not exist for whatever reason the packet can be
                                 * recovered by skipping the data.
                                 * 
                                 * Realistically everything will be a syncvar or on the reliable channel unless
                                 * the user makes a custom syncobject that utilizes unreliable. */
                                if (!isSyncObject || (Channel)channel == Channel.Reliable)
                                    dataWriter.WriteBytesAndSize(channelWriter.GetBuffer(), 0, channelWriter.Length);
                                else
                                    dataWriter.WriteBytes(channelWriter.GetBuffer(), 0, channelWriter.Length);

                                //Attach data onto packetWriter.
                                headerWriter.WriteArraySegment(dataWriter.GetArraySegment());
                                dataWriter.Dispose();

                                //If sending to observers.
                                bool excludeOwnerPermission = (_syncTypeWriters[i].ReadPermission == ReadPermission.ExcludeOwner);
                                if (excludeOwnerPermission || _syncTypeWriters[i].ReadPermission == ReadPermission.Observers)
                                    _networkObjectCache.NetworkManager.TransportManager.SendToClients((byte)channel, headerWriter.GetArraySegment(), _networkObjectCache, excludeOwnerPermission);
                                //Sending only to owner.
                                else
                                    _networkObjectCache.NetworkManager.TransportManager.SendToClient(channel, headerWriter.GetArraySegment(), _networkObjectCache.Owner);
                            }
                        }
                    }
                }
            }

            /* Fall through. If here then sync types are still pending
             * being written or were just written this frame. */
            return false;
        }

        /// <summary>
        /// Resets all SyncTypes for this NetworkBehaviour for server and client side.
        /// </summary>
        internal void ResetSyncTypes()
        {
            foreach (SyncBase item in _syncVars.Values)
                item.Reset();
            foreach (SyncBase item in _syncObjects.Values)
                item.Reset();
        }

        /// <summary>
        /// Resets all SyncTypes for this NetworkBehaviour.
        /// </summary>
        internal void ResetSyncTypes(bool asServer)
        {
            if (asServer || (!asServer && !IsServer))
            {
                foreach (SyncBase item in _syncVars.Values)
                    item.Reset();
                foreach (SyncBase item in _syncObjects.Values)
                    item.Reset();
            }
        }

        /// <summary>
        /// Writers syncVars for a spawn message.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="forOwner">True to also include syncVars which are for owner only.</param>
        internal void WriteSyncTypesForSpawn(PooledWriter writer, bool forOwner)
        {
            WriteSyncType(_syncVars);
            WriteSyncType(_syncObjects);

            void WriteSyncType(Dictionary<uint, SyncBase> collection)
            {
                using (PooledWriter syncTypeWriter = WriterPool.GetWriter())
                {
                    /* Since all values are being written everything is
                     * written in order so there's no reason to pass
                     * indexes. */
                    foreach (SyncBase sb in collection.Values)
                    {
                        //If not for owner and syncvar is owner only.
                        if (!forOwner && sb.Settings.ReadPermission == ReadPermission.OwnerOnly)
                        {
                            //If there is an owner then skip.
                            if (_networkObjectCache.Owner.IsValid)
                                continue;
                        }

                        sb.WriteFull(syncTypeWriter);
                    }

                    writer.WriteBytesAndSize(syncTypeWriter.GetBuffer(), 0, syncTypeWriter.Length);
                }
            }
        }

        /// <summary>
        /// Manually marks a SyncType as dirty, be it SyncVar or SyncObject.
        /// </summary>
        /// <param name="syncType">SyncType variable to dirty.</param>
        protected void DirtySyncType(object syncType)
        {
            /* This doesn't actually do anything.
             * The codegen replaces calls to this method
             * with a Dirty call for syncType. */
        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkBehaviour.cs ---
﻿using FishNet.Documenting;
using FishNet.Serializing.Helping;
using FishNet.Utility.Constant;
using System.Runtime.CompilerServices;
using UnityEngine;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.Object
{
    /// <summary>
    /// Scripts which inherit from NetworkBehaviour can be used to gain insight of, and perform actions on the network.
    /// </summary>
    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        /// <summary>
        /// True if this NetworkBehaviour is initialized for the network.
        /// </summary>
        public bool IsSpawned => _networkObjectCache.IsSpawned;
        /// <summary>
        /// 
        /// </summary>
        [SerializeField, HideInInspector]
        private byte _componentIndexCache = byte.MaxValue;
        /// <summary>
        /// ComponentIndex for this NetworkBehaviour.
        /// </summary>
        public byte ComponentIndex
        {
            get => _componentIndexCache;
            private set => _componentIndexCache = value;
        }
#if UNITY_EDITOR
        /// <summary>
        /// NetworkObject automatically added or discovered during edit time.
        /// </summary>
        [SerializeField, HideInInspector]
        private NetworkObject _addedNetworkObject;
#endif 
        /// <summary>
        /// 
        /// </summary>
        [SerializeField, HideInInspector]
        private NetworkObject _networkObjectCache;
        /// <summary>
        /// NetworkObject this behaviour is for.
        /// </summary>
        public NetworkObject NetworkObject => _networkObjectCache;

        /// <summary>
        /// Initializes this script. This will only run once even as host.
        /// </summary>
        /// <param name="networkObject"></param>
        /// <param name="componentIndex"></param>
        internal void InitializeOnceInternal()
        {
            InitializeOnceSyncTypes();
            InitializeOnceRpcLinks();
        }

        /// <summary>
        /// Serializes information for network components.
        /// </summary>
        internal void SerializeComponents(NetworkObject nob, byte componentIndex)
        {
            _networkObjectCache = nob;
            ComponentIndex = componentIndex;
        }

        /// <summary>
        /// Manually initializes network content for the NetworkBehaviour if the object it's on is disabled.
        /// </summary>
        internal void InitializeIfDisabled()
        {
            if (gameObject.activeInHierarchy)
                return;

            NetworkInitializeIfDisabledInternal();
        }
        /// <summary>
        /// Long name is to prevent users from potentially creating their own method named the same.
        /// </summary>
        [CodegenMakePublic] //internal.
        [APIExclude]
        protected internal virtual void NetworkInitializeIfDisabledInternal() { }
        #region Editor.
        protected virtual void Reset()
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
                return;

            //NetworkObject nob = TryAddNetworkObject();
            TryAddNetworkObject();
            //nob.UpdateNetworkBehaviours();
#endif
        }

        protected virtual void OnValidate()
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
                return;

            TryAddNetworkObject();
            //NetworkObject nob = TryAddNetworkObject();
            ////If componentIndex has not been set.
            //if (ComponentIndex == byte.MaxValue)
            //    nob.UpdateNetworkBehaviours();
#endif
        }

        /// <summary>
        /// Resets this NetworkBehaviour so that it may be added to an object pool.
        /// </summary>
        internal void ResetForObjectPool()
        {
            ResetSyncTypes();
            ClearReplicateCache();
            ClearBuffedRpcs();
        }

        /// <summary>
        /// Tries to add the NetworkObject component.
        /// </summary>
        private NetworkObject TryAddNetworkObject()
        {
#if UNITY_EDITOR
            if (Application.isPlaying || _addedNetworkObject != null)
                return _addedNetworkObject;

            /* Manually iterate up the chain because GetComponentInParent doesn't
             * work when modifying prefabs in the inspector. Unity, you're starting
             * to suck a lot right now. */
            NetworkObject result = null;
            Transform climb = transform;

            while (climb != null)
            {
                if (climb.TryGetComponent<NetworkObject>(out result))
                    break;
                else
                    climb = climb.parent;
            }

            _addedNetworkObject = (result != null) ? result : transform.root.gameObject.AddComponent<NetworkObject>();
            return _addedNetworkObject;
#else
            return null;
#endif
        }
        #endregion
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/NetworkObject.Broadcast.cs ---
﻿using FishNet.Broadcast;
using FishNet.Managing.Logging;
using FishNet.Transporting;
using UnityEngine;

namespace FishNet.Object
{
    public sealed partial class NetworkObject : MonoBehaviour
    {

        /// <summary>
        /// Sends a broadcast to Observers on this NetworkObject.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the client must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (NetworkManager == null)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot send broadcast from {gameObject.name}, NetworkManager reference is null. This may occur if the object is not spawned or initialized.");
                return;
            }

            NetworkManager.ServerManager.Broadcast(Observers, message, requireAuthenticated, channel);
        }
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkObject.Callbacks.cs ---
﻿using FishNet.Connection;
using UnityEngine;

namespace FishNet.Object
{
    public sealed partial class NetworkObject : MonoBehaviour
    {
        /// <summary>
        /// Called after all data is synchronized with this NetworkObject.
        /// </summary>
        private void InitializeCallbacks(bool asServer)
        {
            /* Note: When invoking OnOwnership here previous owner will
             * always be an empty connection, since the object is just
             * now initializing. */

            if (!asServer)
                ClientInitialized = true;

            //Set that client or server is active before callbacks.
            SetActiveStatus(true, asServer);

            //Invoke OnStartNetwork.
            for (int i = 0; i < NetworkBehaviours.Length; i++)
                NetworkBehaviours[i].InvokeOnNetwork(true);            

            //As server.
            if (asServer)
            {
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].OnStartServer();
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].InvokeSyncTypeCallbacks(true);

                if (Owner.IsValid)
                {
                    for (int i = 0; i < NetworkBehaviours.Length; i++)
                        NetworkBehaviours[i].OnOwnershipServer(FishNet.Managing.NetworkManager.EmptyConnection);
                }
            }
            //As client.
            else
            {
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].OnStartClient();
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].InvokeSyncTypeCallbacks(false);

                if (IsOwner)
                {
                    for (int i = 0; i < NetworkBehaviours.Length; i++)
                        NetworkBehaviours[i].OnOwnershipClient(FishNet.Managing.NetworkManager.EmptyConnection);
                }
            }
        }

        /// <summary>
        /// Invokes events to be called after OnServerStart.
        /// This is made one method to save instruction calls.
        /// </summary>
        /// <param name=""></param>
        internal void InvokePostOnServerStart(NetworkConnection conn)
        {
            for (int i = 0; i < NetworkBehaviours.Length; i++)
                NetworkBehaviours[i].SendBufferedRpcs(conn);

            for (int i = 0; i < NetworkBehaviours.Length; i++)
                NetworkBehaviours[i].OnSpawnServer(conn);
        }

        /// <summary>
        /// Called on the server before it sends a despawn message to a client.
        /// </summary>
        /// <param name="conn">Connection spawn was sent to.</param>
        internal void InvokeOnServerDespawn(NetworkConnection conn)
        {
            for (int i = 0; i < NetworkBehaviours.Length; i++)
                NetworkBehaviours[i].OnDespawnServer(conn);
        }

        /// <summary>
        /// Invokes OnStop callbacks.
        /// </summary>
        /// <param name="asServer"></param>
        internal void InvokeStopCallbacks(bool asServer)
        {
            if (asServer)
            {
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].OnStopServer();
            }
            else
            {
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].OnStopClient();
            }

            /* Invoke OnStopNetwork if server is calling
            * or if client and not as server. */
            if (asServer || (!asServer && !IsServer))
            {
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].InvokeOnNetwork(false);
            }

            if (asServer)
                IsServer = false;
            else
                IsClient = false;
        }

        /// <summary>
        /// Invokes OnOwnership callbacks.
        /// </summary>
        /// <param name="prevOwner"></param>
        private void InvokeOwnership(NetworkConnection prevOwner, bool asServer)
        {
            if (asServer)
            {
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].OnOwnershipServer(prevOwner);
            }
            else
            {
                for (int i = 0; i < NetworkBehaviours.Length; i++)
                    NetworkBehaviours[i].OnOwnershipClient(prevOwner);
            }
        }
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkObject.Observers.cs ---
﻿using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Observing;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object
{
    public sealed partial class NetworkObject : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called when this NetworkObject losses all observers or gains observers while previously having none.
        /// </summary>
        public event Action<NetworkObject> OnObserversActive;
        /// <summary>
        /// NetworkObserver on this object. May be null if not using observers.
        /// </summary>
        [HideInInspector]
        public NetworkObserver NetworkObserver = null;
        /// <summary>
        /// Clients which can see and get messages from this NetworkObject.
        /// </summary>
        public HashSet<NetworkConnection> Observers = new HashSet<NetworkConnection>();
        #endregion

        #region Private.
        /// <summary>
        /// True if NetworkObserver has been initialized.
        /// </summary>
        private bool _networkObserverInitiliazed = false;
        /// <summary>
        /// Found renderers on the NetworkObject and it's children. This is only used as clientHost to hide non-observers objects.
        /// </summary>
        [System.NonSerialized]
        private Renderer[] _renderers;
        /// <summary>
        /// True if renderers have been looked up.
        /// </summary>
        private bool _renderersPopulated;
        /// <summary>
        /// Last visibility value for clientHost on this object.
        /// </summary>
        private bool _lastClientHostVisibility;
        #endregion

        /// <summary>
        /// Updates cached renderers used to managing clientHost visibility.
        /// </summary>
        /// <param name="updateVisibility">True to also update visibility if clientHost.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UpdateRenderers(bool updateVisibility = true)
        {
            UpdateRenderersInternal(updateVisibility);
        }

        /// <summary>
        /// Sets the renderer visibility for clientHost.
        /// </summary>
        /// <param name="visible">True if renderers are to be visibile.</param>
        /// <param name="force">True to skip blocking checks.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetRenderersVisible(bool visible, bool force = false)
        {
            if (!force)
            {
                if (!NetworkObserver.UpdateHostVisibility)
                    return;
            }

            if (!_renderersPopulated)
            {
                UpdateRenderersInternal(true);
                _renderersPopulated = true;
            }
            else
            {
                UpdateRenderVisibility(visible);
            }
        }

        /// <summary>
        /// Clears and updates renderers.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void UpdateRenderersInternal(bool updateVisibility)
        {
            _renderers = GetComponentsInChildren<Renderer>(true);
            if (updateVisibility)
                UpdateRenderVisibility(_lastClientHostVisibility);
        }

        /// <summary>
        /// Updates visibilites on renders without checks.
        /// </summary>
        /// <param name="visible"></param>
        private void UpdateRenderVisibility(bool visible)
        {
            Renderer[] rs = _renderers;
            int count = rs.Length;
            for (int i = 0; i < count; i++)
                rs[i].enabled = visible;

            _lastClientHostVisibility = visible;
        }

        /// <summary>
        /// Adds the default NetworkObserver conditions using the ObserverManager.
        /// </summary>
        private void AddDefaultNetworkObserverConditions()
        {
            if (_networkObserverInitiliazed)
                return;

            NetworkObserver = NetworkManager.ObserverManager.AddDefaultConditions(this);
        }

        /// <summary>
        /// Removes a connection from observers for this object returning if the connection was removed.
        /// </summary>
        /// <param name="connection"></param>
        internal bool RemoveObserver(NetworkConnection connection)
        {
            int startCount = Observers.Count;
            bool removed = Observers.Remove(connection);
            if (removed)
                TryInvokeOnObserversActive(startCount);

            return removed;
        }

        /// <summary>
        /// Adds the connection to observers if conditions are met.
        /// </summary>
        /// <param name="connection"></param>
        /// <returns>True if added to Observers.</returns>
        internal ObserverStateChange RebuildObservers(NetworkConnection connection, bool timedOnly)
        {
            //If not a valid connection.
            if (!connection.IsValid)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"An invalid connection was used when rebuilding observers.");
                return ObserverStateChange.Unchanged;
            }
            //Valid not not active.
            else if (!connection.IsActive)
            {
                /* Just remove from observers since connection isn't active
                 * and return unchanged because nothing should process
                 * given the connection isnt active. */
                Observers.Remove(connection);
                return ObserverStateChange.Unchanged;
            }
            else if (IsDeinitializing)
            {
                /* If object is deinitializing it's either being despawned
                 * this frame or it's not spawned. If we've made it this far,
                 * it's most likely being despawned. */
                return ObserverStateChange.Unchanged;
            }

            int startCount = Observers.Count;
            ObserverStateChange osc = NetworkObserver.RebuildObservers(connection, timedOnly);
            if (osc == ObserverStateChange.Added)
                Observers.Add(connection);
            else if (osc == ObserverStateChange.Removed)
                Observers.Remove(connection);

            if (osc != ObserverStateChange.Unchanged)
                TryInvokeOnObserversActive(startCount);

            return osc;
        }

        /// <summary>
        /// Invokes OnObserversActive if observers are now 0 but previously were not, or if was previously 0 but now has observers.
        /// </summary>
        /// <param name="startCount"></param>
        private void TryInvokeOnObserversActive(int startCount)
        {
            if ((Observers.Count > 0 && startCount == 0) ||
                Observers.Count == 0 && startCount > 0)
                OnObserversActive?.Invoke(this);
        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkObject.QOL.cs ---
﻿using FishNet.Component.ColliderRollback;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Client;
using FishNet.Managing.Logging;
using FishNet.Managing.Observing;
using FishNet.Managing.Scened;
using FishNet.Managing.Server;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using System;
using UnityEngine;

namespace FishNet.Object
{
    public sealed partial class NetworkObject : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// True if this object has been initialized on the client side.
        /// This is set true right before client callbacks.
        /// </summary>
        public bool ClientInitialized { get; private set; }
        /// <summary>
        /// 
        /// </summary>
        private bool _isClient;
        /// <summary>
        /// True if the client is active and authenticated.
        /// </summary>
        public bool IsClient
        {
            /* This needs to use a special check when
             * player is acting as host. Clients won't
             * set IsClient until they receive the spawn message
             * but the user may expect this true after client
             * gains observation but before client gets spawn. */
            get
            {
                if (IsServer)
                    return (NetworkManager == null) ? false : NetworkManager.IsClient;
                else
                    return _isClient;
            }

            private set => _isClient = value;
        }

        /// <summary>
        /// True if only the client is active and authenticated.
        /// </summary>
        public bool IsClientOnly => (IsClient && !IsServer);
        /// <summary>
        /// True if server is active.
        /// </summary>
        public bool IsServer { get; private set; }
        /// <summary>
        /// True if only the server is active.
        /// </summary>
        public bool IsServerOnly => (IsServer && !IsClient);
        /// <summary>
        /// True if client and server are active.
        /// </summary>
        public bool IsHost => (IsClient && IsServer);
        /// <summary>
        /// True if client nor server are active.
        /// </summary>
        public bool IsOffline => (!IsClient && !IsServer);
        /// <summary>
        /// True if the local client is the owner of this object.
        /// </summary>
        public bool IsOwner
        {
            get
            {
                /* ClientInitialized becomes true when this
                 * NetworkObject has been initialized on the client side.
                 *
                 * This value is used to prevent IsOwner from returning true
                 * when running as host; primarily in Update or Tick callbacks
                 * where IsOwner would be true as host but OnStartClient has
                 * not called yet.
                 * 
                 * EG: server will set owner when it spawns the object.
                 * If IsOwner is checked before the object spawns on the
                 * client-host then it would also return true, since the
                 * Owner reference would be the same as what was set by server.
                 *
                 * This is however bad when the client hasn't initialized the object
                 * yet because it gives a false sense of execution order. 
                 * As a result, Update or Ticks may return IsOwner as true well before OnStartClient
                 * is called. Many users rightfully create code with the assumption the client has been
                 * initialized by the time IsOwner is true.
                 * 
                 * This is a double edged sword though because now IsOwner would return true
                 * within OnStartNetwork for clients only, but not for host given the client
                 * side won't be initialized yet as host. As a work around CodeAnalysis will
                 * inform users to instead use base.Owner.IsLocalClient within OnStartNetwork. */
                if (!ClientInitialized)
                    return false;

                return Owner.IsLocalClient;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private NetworkConnection _owner;
        /// <summary>
        /// Owner of this object.
        /// </summary>
        public NetworkConnection Owner
        {
            get
            {
                //Ensures a null Owner is never returned.
                if (_owner == null)
                    return FishNet.Managing.NetworkManager.EmptyConnection;

                return _owner;
            }
            private set { _owner = value; }
        }
        /// <summary>
        /// ClientId for this NetworkObject owner.
        /// </summary>
        public int OwnerId => (!Owner.IsValid) ? -1 : Owner.ClientId;
        /// <summary>
        /// True if the object is initialized for the network.
        /// </summary>
        public bool IsSpawned => (!IsDeinitializing && ObjectId >= 0);
        /// <summary>
        /// The local connection of the client calling this method.
        /// </summary>
        public NetworkConnection LocalConnection => (NetworkManager == null) ? new NetworkConnection() : NetworkManager.ClientManager.Connection;
        /// <summary>
        /// NetworkManager for this object.
        /// </summary>
        public NetworkManager NetworkManager { get; private set; }
        /// <summary>
        /// ServerManager for this object.
        /// </summary>
        public ServerManager ServerManager { get; private set; }
        /// <summary>
        /// ClientManager for this object.
        /// </summary>
        public ClientManager ClientManager { get; private set; }
        /// <summary>
        /// ObserverManager for this object.
        /// </summary>
        public ObserverManager ObserverManager { get; private set; }
        /// <summary>
        /// TransportManager for this object.
        /// </summary>
        public TransportManager TransportManager { get; private set; }
        /// <summary>
        /// TimeManager for this object.
        /// </summary>
        public TimeManager TimeManager { get; private set; }
        /// <summary>
        /// SceneManager for this object.
        /// </summary>
        public SceneManager SceneManager { get; private set; }
        /// <summary>
        /// RollbackManager for this object.
        /// </summary>
        public RollbackManager RollbackManager { get; private set; }
        #endregion

        /// <summary>
        /// Returns a NetworkBehaviour on this NetworkObject.
        /// </summary>
        /// <param name="componentIndex">ComponentIndex of the NetworkBehaviour.</param>
        /// <param name="error">True to error if not found.</param>
        /// <returns></returns>
        public NetworkBehaviour GetNetworkBehaviour(byte componentIndex, bool error)
        {
            if (componentIndex >= NetworkBehaviours.Length)
            {
                if (error)
                {
                    bool staticLog = (NetworkManager == null);
                    string errMsg = $"ComponentIndex of {componentIndex} is out of bounds on {gameObject.name} [id {ObjectId}]. This may occur if you have modified your gameObject/prefab without saving it, or the scene.";

                    if (staticLog && NetworkManager.StaticCanLog(LoggingType.Error))
                        Debug.LogError(errMsg);
                    else if (!staticLog && NetworkManager.CanLog(LoggingType.Error))
                        Debug.LogError(errMsg);
                }
            }

            return NetworkBehaviours[componentIndex];
        }
        /// <summary>
        /// Despawns this NetworkObject. Only call from the server.
        /// </summary>
        /// <param name="cacheOnDespawnOverride">Overrides the default DisableOnDespawn value for this single despawn. Scene objects will never be destroyed.</param>
        public void Despawn(DespawnType? despawnType = null)
        {
            NetworkObject nob = this;
            NetworkManager.ServerManager.Despawn(nob, despawnType);
        }
        /// <summary>
        /// Spawns an object over the network. Only call from the server.
        /// </summary>
        public void Spawn(GameObject go, NetworkConnection ownerConnection = null)
        {
            if (!CanSpawnOrDespawn(true))
                return;
            NetworkManager.ServerManager.Spawn(go, ownerConnection);
        }
        /// <summary>
        /// Spawns an object over the network. Only call from the server.
        /// </summary>
        public void Spawn(NetworkObject nob, NetworkConnection ownerConnection = null)
        {
            if (!CanSpawnOrDespawn(true))
                return;
            NetworkManager.ServerManager.Spawn(nob, ownerConnection);
        }

        /// <summary>
        /// Returns if Spawn or Despawn can be called.
        /// </summary>
        /// <param name="warn">True to warn if not able to execute spawn or despawn.</param>
        /// <returns></returns>
        internal bool CanSpawnOrDespawn(bool warn)
        {
            bool canExecute = true;

            if (NetworkManager == null)
            {
                canExecute = false;
                if (warn)
                {
                    if (NetworkManager.StaticCanLog(LoggingType.Warning))
                        Debug.LogWarning($"Cannot despawn {gameObject.name}, NetworkManager reference is null. This may occur if the object is not spawned or initialized.");
                }
            }
            else if (IsDeinitializing)
            {
                canExecute = false;
                if (warn)
                {
                    if (NetworkManager.CanLog(LoggingType.Warning))
                        Debug.LogWarning($"Cannot despawn {gameObject.name}, it is already deinitializing.");
                }
            }

            return canExecute;
        }

    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkObject.ReferenceIds.cs ---
﻿using UnityEngine;
using System.Collections.Generic;
using System;
using FishNet.Object.Helping;
using System.Linq;
#if UNITY_EDITOR
using UnityEditor.Experimental.SceneManagement;
using UnityEditor.SceneManagement;
using UnityEditor;
#endif

namespace FishNet.Object
{
    public sealed partial class NetworkObject : MonoBehaviour
    {
        #region Serialized.

        /// <summary>
        /// 
        /// </summary>
        [field: SerializeField, HideInInspector]
        public short PrefabId { get; internal set; } = -1;
#pragma warning disable 414 //Disabled because Unity thinks tihs is unused when building.
        /// <summary>
        /// Hash to the scene which this object resides.
        /// </summary>
        [SerializeField, HideInInspector]
        private uint _scenePathHash;
#pragma warning restore 414
        /// <summary>
        /// Network Id for this scene object.
        /// </summary>
        [field: SerializeField, HideInInspector]
        internal ulong SceneId { get; private set; }
        /// <summary>
        /// Hash for the path which this asset resides. This value is set during edit time.
        /// </summary> 
        [field: SerializeField, HideInInspector]
        public ulong AssetPathHash { get; private set; }
        /// <summary>
        /// Sets AssetPathhash value.
        /// </summary>
        /// <param name="value">Value to use.</param>
        public void SetAssetPathHash(ulong value) => AssetPathHash = value;
        #endregion

#if UNITY_EDITOR
        /// <summary>
        /// This is used to store NetworkObjects in the scene during edit time.
        /// SceneIds are compared against this collection to ensure there are no duplicated.
        /// </summary>
        [SerializeField, HideInInspector]
        private List<NetworkObject> _sceneNetworkObjects = new List<NetworkObject>();
#endif

        /// <summary>
        /// Removes SceneObject state.
        /// This may only be called at runtime.
        /// </summary>
        internal void ClearRuntimeSceneObject()
        {
            if (!Application.isPlaying)
            {
                Debug.LogError($"ClearRuntimeSceneObject may only be called at runtime.");
                return;
            }

            SceneId = 0;
        }

#if UNITY_EDITOR
        /// <summary>
        /// Tries to generate a SceneId.
        /// </summary>
        internal void TryCreateSceneID()
        {
            if (Application.isPlaying)
                return;
            //Unity bug, sometimes this can be null depending on editor callback orders.
            if (gameObject == null)
                return;
            //Not a scene object.
            if (string.IsNullOrEmpty(gameObject.scene.name))
            {
                SceneId = 0;
                return;
            }

            ulong startId = SceneId;
            uint startPath = _scenePathHash;

            ulong sceneId = 0;
            uint scenePathHash = 0;
            //If prefab or part of a prefab, not a scene object.            
            if (PrefabUtility.IsPartOfPrefabAsset(this) || IsEditingInPrefabMode() ||
             //Not in a scene, another prefab check.
             !gameObject.scene.IsValid() ||
             //Stored on disk, so is a prefab. Somehow prefabutility missed it.
             EditorUtility.IsPersistent(this))
            {
                //These are all failing conditions, don't do additional checks.
            }
            else
            {
                System.Random rnd = new System.Random();
                scenePathHash = gameObject.scene.path.ToLower().GetStableHash32();
                sceneId = SceneId;
                //Not a valid sceneId or is a duplicate. 
                if (scenePathHash != _scenePathHash || SceneId == 0 || IsDuplicateSceneId(SceneId))
                {
                    /* If a scene has not been opened since an id has been
                     * generated then it will not be serialized in editor. The id
                     * would be correct in build but not if running in editor. 
                     * Should conditions be true where scene is building without
                     * being opened then cancel build and request user to open and save
                     * scene. */
                    if (BuildPipeline.isBuildingPlayer)
                        throw new InvalidOperationException($"Networked GameObject {gameObject.name} in scene {gameObject.scene.path} is missing a SceneId. Open the scene, select the Fish-Networking menu, and choose Rebuild SceneIds. If the problem persist ensures {gameObject.name} does not have any missing script references on it's prefab or in the scene. Also ensure that you have any prefab changes for the object applied.");

                    ulong shiftedHash = (ulong)scenePathHash << 32;
                    ulong randomId = 0;
                    while (randomId == 0 || IsDuplicateSceneId(randomId))
                    {
                        uint next = (uint)(rnd.Next(int.MinValue, int.MaxValue) + int.MaxValue);
                        /* Since the collection is lost when a scene loads the it's possible to
                        * have a sceneid from another scene. Because of this the scene path is
                        * inserted into the sceneid. */
                        randomId = (next & 0xFFFFFFFF) | shiftedHash;
                    }

                    sceneId = randomId;
                }

            }

            bool idChanged = (sceneId != startId);
            bool pathChanged = (startPath != scenePathHash);
            //If either changed then dirty and set.
            if (idChanged || pathChanged)
            {
                //Set dirty so changes will be saved.
                EditorUtility.SetDirty(this);
                /* Add to sceneIds collection. This must be done
                 * even if a new sceneId was not generated because
                 * the collection information is lost when the
                 * scene is existed. Essentially, it gets repopulated
                 * when the scene is re-opened. */
                SceneId = sceneId;
                _scenePathHash = scenePathHash;
            }
        }

        private bool IsEditingInPrefabMode()
        {
            if (EditorUtility.IsPersistent(this))
            {
                // if the game object is stored on disk, it is a prefab of some kind, despite not returning true for IsPartOfPrefabAsset =/
                return true;
            }
            else
            {
                // If the GameObject is not persistent let's determine which stage we are in first because getting Prefab info depends on it
                StageHandle mainStage = StageUtility.GetMainStageHandle();
                StageHandle currentStage = StageUtility.GetStageHandle(gameObject);
                if (currentStage != mainStage)
                {
                    var prefabStage = PrefabStageUtility.GetPrefabStage(gameObject);
                    if (prefabStage != null)
                    {
                        return true;
                    }
                }
            }
            return false;

        }

        /// <summary>
        /// Returns if the Id used is a sceneId already belonging to another object.
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private bool IsDuplicateSceneId(ulong id)
        {
            //Find all nobs in scene.
            _sceneNetworkObjects = GameObject.FindObjectsOfType<NetworkObject>().ToList();
            foreach (NetworkObject nob in _sceneNetworkObjects)
            {
                if (nob != null && nob != this && nob.SceneId == id)
                    return true;
            }
            //If here all checks pass.
            return false;
        }

        private void ReferenceIds_OnValidate()
        {
            TryCreateSceneID();
        }
        private void ReferenceIds_Reset()
        {
            TryCreateSceneID();
        }
#endif
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkObject.RpcLinks.cs ---
﻿using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Object
{
    public sealed partial class NetworkObject : MonoBehaviour
    {

        #region Private.
        /// <summary>
        /// RpcLinks being used within this NetworkObject.
        /// </summary>
        private List<ushort> _rpcLinkIndexes;
        #endregion

        /// <summary>
        /// Sets rpcLinkIndexes to values.
        /// </summary>
        internal void SetRpcLinkIndexes(List<ushort> values)
        {
            _rpcLinkIndexes = values;
        }

        /// <summary>
        /// Removes used link indexes from ClientObjects.
        /// </summary>
        internal void RemoveClientRpcLinkIndexes()
        {
            NetworkManager.ClientManager.Objects.RemoveLinkIndexes(_rpcLinkIndexes);
        }
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkObject.SyncTypes.cs ---
﻿using UnityEngine;

namespace FishNet.Object
{
    public sealed partial class NetworkObject : MonoBehaviour
    {
        /// <summary>
        /// Writers dirty SyncTypes for all Networkbehaviours if their write tick has been met.
        /// </summary>
        internal void WriteDirtySyncTypes()
        {
            NetworkBehaviour[] nbs = NetworkBehaviours;
            int count = nbs.Length;
            for (int i = 0; i < count; i++)
            {
                //There was a null check here before, shouldn't be needed so it was removed.
                NetworkBehaviour nb = nbs[i];
                nb.WriteDirtySyncTypes(true, true);
                nb.WriteDirtySyncTypes(false, true);
            }
        }
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkObject.cs ---
﻿using FishNet.Managing;
using FishNet.Connection;
using UnityEngine;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Managing.Logging;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using FishNet.Utility.Performance;
using System;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FishNet.Object
{
    [DisallowMultipleComponent]
    public sealed partial class NetworkObject : MonoBehaviour
    {
        #region Public.
        [field: SerializeField, HideInInspector]
        public bool IsNested { get; private set; }
        /// <summary>
        /// True if this NetworkObject was active during edit. Will be true if placed in scene during edit, and was in active state on run.
        /// </summary>
        [System.NonSerialized]
        internal bool ActiveDuringEdit;
        /// <summary>
        /// Returns if this object was placed in the scene during edit-time.
        /// </summary>
        /// <returns></returns>
        public bool IsSceneObject => (SceneId > 0);
        [Obsolete("Use IsSceneObject instead.")] //Remove on 2023/01/01
        public bool SceneObject => IsSceneObject;
        /// <summary>
        /// ComponentIndex for this NetworkBehaviour.
        /// </summary>
        [field: SerializeField, HideInInspector]
        public byte ComponentIndex { get; private set; }
        /// <summary>
        /// Unique Id for this NetworkObject. This does not represent the object owner.
        /// </summary>
        public int ObjectId { get; private set; }
        /// <summary>
        /// True if this NetworkObject is deinitializing. Will also be true until Initialize is called. May be false until the object is cleaned up if object is destroyed without using Despawn.
        /// </summary>
        internal bool IsDeinitializing { get; private set; } = true;
        /// <summary>
        /// 
        /// </summary>
        [field: SerializeField, HideInInspector]
        private NetworkBehaviour[] _networkBehaviours;
        /// <summary>
        /// NetworkBehaviours within the root and children of this object.
        /// </summary>        
        public NetworkBehaviour[] NetworkBehaviours
        {
            get => _networkBehaviours;
            private set => _networkBehaviours = value;
        }
        /// <summary>
        /// NetworkObject parenting this instance. The parent NetworkObject will be null if there was no parent during serialization.
        /// </summary>
        [field: SerializeField, HideInInspector]
        public NetworkObject ParentNetworkObject { get; private set; }
        /// NetworkObjects nested beneath this one. Recursive NetworkObjects may exist within each entry of this field.
        /// </summary> 
        [field: SerializeField, HideInInspector]
        public List<NetworkObject> ChildNetworkObjects { get; private set; } = new List<NetworkObject>();
        /// <summary>
        /// 
        /// </summary>
        [SerializeField, HideInInspector]
        internal TransformProperties SerializedTransformProperties = new TransformProperties();
        /// <summary>
        /// Current state of the NetworkObject.
        /// </summary>
        [System.NonSerialized]
        internal NetworkObjectState State = NetworkObjectState.Unset;
        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True if the object will always initialize as a networked object. When false the object will not automatically initialize over the network. Using Spawn() on an object will always set that instance as networked.")]
        [SerializeField]
        private bool _isNetworked = true;
        /// <summary>
        /// True if the object will always initialize as a networked object. When false the object will not automatically initialize over the network. Using Spawn() on an object will always set that instance as networked.
        /// </summary>
        public bool IsNetworked
        {
            get => _isNetworked;
            private set => _isNetworked = value;
        }
        /// <summary>
        /// Sets IsNetworked value. This method must be called before Start.
        /// </summary>
        /// <param name="value">New IsNetworked value.</param>
        public void SetIsNetworked(bool value)
        {
            IsNetworked = value;
        }
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to make this object global, and added to the DontDestroyOnLoad scene. This value may only be set for instantiated objects, and can be changed if done immediately after instantiating.")]
        [SerializeField]
        private bool _isGlobal;
        /// <summary>
        /// True to make this object global, and added to the DontDestroyOnLoad scene. This value may only be set for instantiated objects, and can be changed if done immediately after instantiating.
        /// </summary>
        public bool IsGlobal
        {
            get => _isGlobal;
            private set => _isGlobal = value;
        }
        /// <summary>
        /// Sets IsGlobal value.
        /// </summary>
        /// <param name="value">New global value.</param>
        public void SetIsGlobal(bool value)
        {
            if (IsNested)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Warning))
                    Debug.LogWarning($"Object {gameObject.name} cannot change IsGlobal because it is nested. Only root objects may be set global.");
            }
            if (!IsDeinitializing)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Warning))
                    Debug.LogWarning($"Object {gameObject.name} cannot change IsGlobal as it's already initialized. IsGlobal may only be changed immediately after instantiating.");
                return;
            }
            if (IsSceneObject)
            {
                if (NetworkManager.StaticCanLog(LoggingType.Warning))
                    Debug.LogWarning($"Object {gameObject.name} cannot have be global because it is a scene object. Only instantiated objects may be global.");
                return;
            }

            _networkObserverInitiliazed = false;
            IsGlobal = value;
        }

        /// <summary>
        /// How to handle this object when it despawns. Scene objects are never destroyed when despawning.
        /// </summary>
        [SerializeField]
        [Tooltip("How to handle this object when it despawns. Scene objects are never destroyed when despawning.")]
        private DespawnType _defaultDespawnType = DespawnType.Destroy;
        /// <summary>
        /// True to use configured ObjectPool rather than destroy this NetworkObject when being despawned. Scene objects are never destroyed.
        /// </summary>
        public DespawnType GetDefaultDespawnType() => _defaultDespawnType;
        /// <summary>
        /// Sets DespawnType value.
        /// </summary>
        /// <param name="despawnType">Default despawn type for this NetworkObject.</param>
        public void SetDefaultDespawnType(DespawnType despawnType)
        {
            _defaultDespawnType = despawnType;
        }
        #endregion

        #region Private.
        /// <summary>
        /// True if disabled NetworkBehaviours have been initialized.
        /// </summary>
        private bool _disabledNetworkBehavioursInitialized;
        #endregion

        #region Editor Debug.
#if UNITY_EDITOR
        private int _editorOwnerId;
#endif
        #endregion

        private void Awake()
        {
            SetChildDespawnedState();
        }

        private void Start()
        {
            TryStartDeactivation();
            ////Also deactivate children.
            //foreach (NetworkObject nob in ChildNetworkObjects)
            //    nob.TryStartDeactivation();
        }

        /// <summary>
        /// Initializes NetworkBehaviours if they are disabled.
        /// </summary>
        private void InitializeNetworkBehavioursIfDisabled()
        {
            if (_disabledNetworkBehavioursInitialized)
                return;
            _disabledNetworkBehavioursInitialized = true;

            for (int i = 0; i < NetworkBehaviours.Length; i++)
                NetworkBehaviours[i].InitializeIfDisabled();
        }

        /// <summary>
        /// Sets Despawned on child NetworkObjects if they are not enabled.
        /// </summary>
        private void SetChildDespawnedState()
        {
            NetworkObject nob;
            for (int i = 0; i < ChildNetworkObjects.Count; i++)
            {
                nob = ChildNetworkObjects[i];
                if (!nob.gameObject.activeSelf)
                    nob.State = NetworkObjectState.Despawned;
            }
        }

        /// <summary>
        /// Deactivates this NetworkObject during it's start cycle if conditions are met.
        /// </summary>
        internal void TryStartDeactivation()
        {
            if (!IsNetworked)
                return;

            //Global.
            if (IsGlobal && !IsSceneObject)
                DontDestroyOnLoad(gameObject);

            if (NetworkManager == null || (!NetworkManager.IsClient && !NetworkManager.IsServer))
            {
                //ActiveDuringEdit is only used for scene objects.
                if (IsSceneObject)
                    ActiveDuringEdit = true;
                gameObject.SetActive(false);
            }
        }

        private void OnDisable()
        {
            /* If deinitializing and an owner exist
             * then remove object from owner. */
            if (IsDeinitializing && Owner.IsValid)
                Owner.RemoveObject(this);
            /* If not nested then check to despawn this OnDisable.
             * A nob may become disabled without being despawned if it's
             * beneath another deinitializing nob. This can be true even while
             * not nested because users may move a nob under another at runtime.
             * 
             * This object must also be activeSelf, meaning that it became disabled
             * because a parent was. If not activeSelf then it's possible the
             * user simply deactivated the object themselves. */
            else if (IsServer && !IsNested && gameObject.activeSelf)
            {
                bool canDespawn = false;
                Transform nextParent = transform.parent;
                while (nextParent != null)
                {
                    if (nextParent.TryGetComponent(out NetworkObject pNob))
                    {
                        /* If pNob is not the same as ParentNetworkObject
                         * then that means this object was moved around. It could be
                         * that this was previously a child of something else
                         * or that was given a parent later on in it's life cycle.
                         ^
                         * When this occurs do not send a despawn for this object.
                         * Rather, let it destroy from unity callbacks which will force
                        * the proper destroy/stop cycle. */
                        if (pNob != ParentNetworkObject)
                            break;
                        //If nob is deinitialized then this one cannot exist.
                        if (pNob.IsDeinitializing)
                        {
                            canDespawn = true;
                            break;
                        }
                    }
                    nextParent = nextParent.parent;
                }

                if (canDespawn)
                    Despawn();
            }
        }

        private void OnDestroy()
        {
            //Does this need to be here? I'm thinking no, remove it and examine later. //todo
            if (Owner.IsValid)
                Owner.RemoveObject(this);
            //Already being deinitialized by FishNet.
            if (IsDeinitializing)
                return;

            if (NetworkManager != null)
            {
                //Was destroyed without going through the proper methods.
                if (NetworkManager.IsServer)
                    NetworkManager.ServerManager.Objects.NetworkObjectUnexpectedlyDestroyed(this);
                if (NetworkManager.IsClient)
                    NetworkManager.ClientManager.Objects.NetworkObjectUnexpectedlyDestroyed(this);
            }

            /* When destroyed unexpectedly it's
             * impossible to know if this occurred on
             * the server or client side, so send callbacks
             * for both. */
            if (IsServer)
                InvokeStopCallbacks(true);
            if (IsClient)
                InvokeStopCallbacks(false);

            /* If owner exist then remove object from owner.
             * This has to be called here as well OnDisable because
             * the OnDisable will only remove the object if
             * deinitializing. This is because the object shouldn't
             * be removed from owner if the object is simply being
             * disabled, but not deinitialized. But in the scenario
             * the object is unexpectedly destroyed, which is how we
             * arrive here, the object needs to be removed from owner. */
            if (Owner.IsValid)
                Owner.RemoveObject(this);

            Observers.Clear();
            IsDeinitializing = true;

            SetActiveStatus(false);
            //Do not need to set state if being destroyed.
            //Don't need to reset sync types if object is being destroyed.
        }

        /// <summary>
        /// Sets IsClient or IsServer to isActive.
        /// </summary>
        private void SetActiveStatus(bool isActive, bool server)
        {
            if (server)
                IsServer = isActive;
            else
                IsClient = isActive;
        }
        /// <summary>
        /// Sets IsClient and IsServer to isActive.
        /// </summary>
        private void SetActiveStatus(bool isActive)
        {
            IsServer = isActive;
            IsClient = isActive;
        }
        /// <summary>
        /// Initializes this script. This is only called once even when as host.
        /// </summary>
        /// <param name="networkManager"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void PreinitializeInternal(NetworkManager networkManager, int objectId, NetworkConnection owner, bool asServer)
        {
            State = NetworkObjectState.Spawned;
            InitializeNetworkBehavioursIfDisabled();
            IsDeinitializing = false;
            //QOL references.
            NetworkManager = networkManager;
            ServerManager = networkManager.ServerManager;
            ClientManager = networkManager.ClientManager;
            ObserverManager = networkManager.ObserverManager;
            TransportManager = networkManager.TransportManager;
            TimeManager = networkManager.TimeManager;
            SceneManager = networkManager.SceneManager;
            RollbackManager = networkManager.RollbackManager;

            SetOwner(owner);
            ObjectId = objectId;

            /* This must be called at the beginning
             * so that all conditions are handled by the observer
             * manager prior to the preinitialize call on networkobserver. 
             * The method called is dependent on NetworkManager being set. */
            AddDefaultNetworkObserverConditions();

            for (int i = 0; i < NetworkBehaviours.Length; i++)
                NetworkBehaviours[i].InitializeOnceInternal();

            /* NetworkObserver uses some information from
             * NetworkBehaviour so it must be preinitialized
             * after NetworkBehaviours are. */
            if (asServer)
                NetworkObserver.PreInitialize(this);
            _networkObserverInitiliazed = true;

            //Add to connection objects if owner exist.
            if (owner != null)
                owner.AddObject(this);
        }

        /// <summary>
        /// Adds a NetworkBehaviour and serializes it's components.
        /// </summary>
        internal T AddAndSerialize<T>() where T : NetworkBehaviour //runtimeNB make public.
        {
            int startingLength = NetworkBehaviours.Length;
            T result = gameObject.AddComponent<T>();
            //Add to network behaviours.
            Array.Resize(ref _networkBehaviours, startingLength + 1);
            _networkBehaviours[startingLength] = result;
            //Serialize values and return.
            result.SerializeComponents(this, (byte)startingLength);
            return result;
        }

        /// <summary>
        /// Updates NetworkBehaviours and initializes them with serialized values.
        /// </summary>
        /// <param name="fromPrefabCollection">True if this call originated from a prefab collection, such as during it's initialization.</param>
        internal void UpdateNetworkBehaviours(NetworkObject parentNob, ref byte componentIndex) //runtimeNB make public.
        {
            /* This method can be called by the developer initializing prefabs, the prefab collection doing it automatically,
             * or when the networkobject is modified or added to an object.
             * 
             * Prefab collections generally contain all prefabs, meaning they will not only call this on the topmost
             * networkobject but also each child, as the child would be it's own prefab in the collection. This assumes
             * that is, the child is a nested prefab.
             * 
             * Because of this potential a check must be done where if the componentIndex is 0 we must look
             * for a networkobject above this one. If there is a networkObject above this one then we know the prefab
             * is being initialized individually, not part of a recursive check. In this case exit early
             * as the parent would have already resolved the needed information. */

            //If first componentIndex make sure there's no more than maximum allowed nested nobs.
            if (componentIndex == 0)
            {
                //Not possible for index to be 0 and nested.
                if (IsNested)
                    return;
                byte maxNobs = 255;
                if (GetComponentsInChildren<NetworkObject>(true).Length > maxNobs)
                {
                    Debug.LogError($"The number of child NetworkObjects on {gameObject.name} exceeds the maximum of {maxNobs}.");
                    return;
                }
            }

            ComponentIndex = componentIndex;
            ParentNetworkObject = parentNob;

            //Transforms which can be searched for networkbehaviours.
            ListCache<Transform> transformCache = ListCaches.GetTransformCache();
            transformCache.Reset();
            ChildNetworkObjects.Clear();

            transformCache.AddValue(transform);
            for (int z = 0; z < transformCache.Written; z++)
            {
                Transform currentT = transformCache.Collection[z];
                for (int i = 0; i < currentT.childCount; i++)
                {
                    Transform t = currentT.GetChild(i);
                    /* If contains a nob then do not add to transformsCache.
                     * Do add to ChildNetworkObjects so it can be initialized when
                     * parent is. */
                    if (t.TryGetComponent(out NetworkObject childNob))
                    {
                        /* Make sure both objects have the same value for
                         * IsSceneObject. It's possible the user instantiated
                         * an object and placed it beneath a scene object
                         * before the scene initialized. They may also
                         * add a scene object under an instantiated, even though
                         * this almost certainly will break things. */
                        if (IsSceneObject == childNob.IsSceneObject)
                            ChildNetworkObjects.Add(childNob);
                    }
                    else
                    {
                        transformCache.AddValue(t);
                    }
                }
            }

            int written;
            //Iterate all cached transforms and get networkbehaviours.
            ListCache<NetworkBehaviour> nbCache = ListCaches.GetNetworkBehaviourCache();
            nbCache.Reset();
            written = transformCache.Written;
            List<Transform> ts = transformCache.Collection;
            //
            for (int i = 0; i < written; i++)
                nbCache.AddValues(ts[i].GetNetworkBehaviours());

            //Copy to array.
            written = nbCache.Written;
            List<NetworkBehaviour> nbs = nbCache.Collection;
            NetworkBehaviours = new NetworkBehaviour[written];
            //
            for (int i = 0; i < written; i++)
            {
                NetworkBehaviours[i] = nbs[i];
                NetworkBehaviours[i].SerializeComponents(this, (byte)i);
            }

            ListCaches.StoreCache(transformCache);
            ListCaches.StoreCache(nbCache);

            //Tell children nobs to update their NetworkBehaviours.
            foreach (NetworkObject item in ChildNetworkObjects)
            {
                componentIndex++;
                item.UpdateNetworkBehaviours(this, ref componentIndex);
            }
        }

        /// <summary>
        /// Called after all data is synchronized with this NetworkObject.
        /// </summary>
        internal void Initialize(bool asServer)
        {
            InitializeCallbacks(asServer);
        }

        /// <summary>
        /// Called to prepare this object to be destroyed or disabled.
        /// </summary>
        internal void Deinitialize(bool asServer)
        {
            InvokeStopCallbacks(asServer);
            if (asServer)
            {
                IsDeinitializing = true;
            }
            else
            {
                //Client only.
                if (!NetworkManager.IsServer)
                    IsDeinitializing = true;

                RemoveClientRpcLinkIndexes();
            }

            SetActiveStatus(false, asServer);
            if (asServer)
                Observers.Clear();
        }

        /// <summary>
        /// Resets states for object to be pooled.
        /// </summary>
        /// <param name="asServer">True if performing as server.</param>
        public void ResetForObjectPool()
        {
            int count = NetworkBehaviours.Length;
            for (int i = 0; i < count; i++)
                NetworkBehaviours[i].ResetForObjectPool();

            State = NetworkObjectState.Unset;
            SetOwner(NetworkManager.EmptyConnection);
            NetworkObserver.Deinitialize();
            //QOL references.
            NetworkManager = null;
            ServerManager = null;
            ClientManager = null;
            ObserverManager = null;
            TransportManager = null;
            TimeManager = null;
            SceneManager = null;
            RollbackManager = null;
            //Misc sets.
            ObjectId = -1;
            ClientInitialized = false;
        }

        /// <summary>
        /// Removes ownership from all clients.
        /// </summary>
        public void RemoveOwnership()
        {
            GiveOwnership(null, true);
        }
        /// <summary>
        /// Gives ownership to newOwner.
        /// </summary>
        /// <param name="newOwner"></param>
        public void GiveOwnership(NetworkConnection newOwner)
        {
            GiveOwnership(newOwner, true);
        }
        /// <summary>
        /// Gives ownership to newOwner.
        /// </summary>
        /// <param name="newOwner"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void GiveOwnership(NetworkConnection newOwner, bool asServer)
        {
            /* Additional asServer checks. */
            if (asServer)
            {
                if (!NetworkManager.IsServer)
                {
                    if (NetworkManager.CanLog(LoggingType.Warning))
                        Debug.LogWarning($"Ownership cannot be given for object {gameObject.name}. Only server may give ownership.");
                    return;
                }

                //If the same owner don't bother sending a message, just ignore request.
                if (newOwner == Owner && asServer)
                    return;

                if (newOwner != null && newOwner.IsActive && !newOwner.LoadedStartScenes)
                {
                    if (NetworkManager.CanLog(LoggingType.Warning))
                        Debug.LogWarning($"Ownership has been transfered to ConnectionId {newOwner.ClientId} but this is not recommended until after they have loaded start scenes. You can be notified when a connection loads start scenes by using connection.OnLoadedStartScenes on the connection, or SceneManager.OnClientLoadStartScenes.");
                }
            }

            bool activeNewOwner = (newOwner != null && newOwner.IsActive);

            //Set prevOwner, disallowing null.
            NetworkConnection prevOwner = Owner;
            if (prevOwner == null)
                prevOwner = NetworkManager.EmptyConnection;

            SetOwner(newOwner);
            /* Only modify objects if asServer or not
             * host. When host, server would
             * have already modified objects
             * collection so there is no need
             * for client to as well. */
            if (asServer || !NetworkManager.IsHost)
            {
                if (activeNewOwner)
                    newOwner.AddObject(this);
                if (prevOwner.IsValid)
                    prevOwner.RemoveObject(this);
            }
            //After changing owners invoke callbacks.
            InvokeOwnership(prevOwner, asServer);

            //If asServer send updates to clients as needed.
            if (asServer)
            {
                if (activeNewOwner)
                    ServerManager.Objects.RebuildObservers(this, newOwner);

                using (PooledWriter writer = WriterPool.GetWriter())
                {
                    writer.WritePacketId(PacketId.OwnershipChange);
                    writer.WriteNetworkObject(this);
                    writer.WriteNetworkConnection(Owner);
                    //If sharing then send to all observers.
                    if (NetworkManager.ServerManager.ShareIds)
                    {
                        NetworkManager.TransportManager.SendToClients((byte)Channel.Reliable, writer.GetArraySegment(), this);
                    }
                    //Only sending to old / new.
                    else
                    {
                        if (prevOwner.IsActive)
                            NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, writer.GetArraySegment(), prevOwner);
                        if (activeNewOwner)
                            NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, writer.GetArraySegment(), newOwner);
                    }
                }

                if (prevOwner.IsActive)
                    ServerManager.Objects.RebuildObservers(prevOwner);
            }
        }

        /// <summary>
        /// Sets the owner of this object.
        /// </summary>
        /// <param name="owner"></param>
        /// <param name="allowNull"></param>
        private void SetOwner(NetworkConnection owner)
        {
            Owner = owner;
        }

        /// <summary>
        /// Returns if this NetworkObject is a scene object, and has changed.
        /// </summary>
        /// <returns></returns>
        internal ChangedTransformProperties GetTransformChanges(TransformProperties stp)
        {
            ChangedTransformProperties ctp = ChangedTransformProperties.Unset;
            if (transform.localPosition != stp.Position)
                ctp |= ChangedTransformProperties.LocalPosition;
            if (transform.localRotation != stp.Rotation)
                ctp |= ChangedTransformProperties.LocalRotation;
            if (transform.localScale != stp.LocalScale)
                ctp |= ChangedTransformProperties.LocalScale;

            return ctp;
        }

        /// <summary>
        /// Returns if this NetworkObject is a scene object, and has changed.
        /// </summary>
        /// <returns></returns>
        internal ChangedTransformProperties GetTransformChanges(GameObject prefab)
        {
            Transform t = prefab.transform;
            ChangedTransformProperties ctp = ChangedTransformProperties.Unset;
            if (transform.position != t.position)
                ctp |= ChangedTransformProperties.LocalPosition;
            if (transform.rotation != t.rotation)
                ctp |= ChangedTransformProperties.LocalRotation;
            if (transform.localScale != t.localScale)
                ctp |= ChangedTransformProperties.LocalScale;

            return ctp;
        }

        #region Editor.
#if UNITY_EDITOR

        /// <summary>
        /// Sets IsNested and returns the result.
        /// </summary>
        /// <returns></returns>
        private bool SetIsNestedThroughTraversal()
        {
            Transform parent = transform.parent;
            //Iterate long as parent isn't null, and isnt self.
            while (parent != null && parent != transform)
            {
                if (parent.TryGetComponent<NetworkObject>(out _))
                {
                    IsNested = true;
                    return IsNested;
                }

                parent = parent.parent;
            }

            //No NetworkObject found in parents, meaning this is not nested.
            IsNested = false;
            return IsNested;
        }

        private void OnValidate()
        {
            SetIsNestedThroughTraversal();
            SceneUpdateNetworkBehaviours();
            ReferenceIds_OnValidate();

            if (IsGlobal && IsSceneObject)
                Debug.LogWarning($"Object {gameObject.name} will have it's IsGlobal state ignored because it is a scene object. Instantiated copies will still be global. This warning is informative only.");
        }

        private void Reset()
        {
            SetIsNestedThroughTraversal();
            SerializeTransformProperties();
            SceneUpdateNetworkBehaviours();
            ReferenceIds_Reset();
        }

        private void SceneUpdateNetworkBehaviours()
        {
            //In a scene.
            if (!string.IsNullOrEmpty(gameObject.scene.name))
            {
                if (IsNested)
                    return;

                byte componentIndex = 0;
                UpdateNetworkBehaviours(null, ref componentIndex);
            }

        }
        private void OnDrawGizmosSelected()
        {
            _editorOwnerId = (Owner == null) ? -1 : Owner.ClientId;
            SerializeTransformProperties();
        }

        /// <summary>
        /// Serializes TransformProperties to current transform properties.
        /// </summary>
        private void SerializeTransformProperties()
        {
            /* Use this method to set scene data since it doesn't need to exist outside 
            * the editor and because its updated regularly while selected. */
            //If a scene object.
            if (!EditorApplication.isPlaying && !string.IsNullOrEmpty(gameObject.scene.name))
            {
                SerializedTransformProperties = new TransformProperties(
                    transform.localPosition, transform.localRotation, transform.localScale);
            }
        }
#endif
        #endregion
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/NetworkObjectState.cs ---
﻿
namespace FishNet.Object
{
    /// <summary>
    /// Current state of the NetworkObject.
    /// </summary>
    internal enum NetworkObjectState : byte
    {
        /// <summary>
        /// State has not been set. This occurs when the object has never been spawned or despawned.
        /// </summary>
        Unset = 0,
        /// <summary>
        /// Object is currently spawned.
        /// </summary>
        Spawned = 1,
        /// <summary>
        /// Object is currently despawned.
        /// </summary>
        Despawned = 2,
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/Prediction/Attributes.cs ---
﻿using System;

namespace FishNet.Object.Prediction
{
    /// <summary>
    /// Replicated methods are to be called from clients and will run the same data and logic on the server.
    /// Only data used as method arguments will be serialized.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ReplicateAttribute : Attribute 
    {
        /// <summary>
        /// How many past datas to resend.
        /// </summary>
        public byte Resends = 5;
    }
    /// <summary>
    /// Reconcile methods indicate how to reset your script or object after the server has replicated user data.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ReconcileAttribute : Attribute 
    {
        /// <summary>
        /// How many times to resend reconcile.
        /// </summary>
        public byte Resends = 3;
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Prediction/Delegates.cs ---
﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Serializing;
using FishNet.Utility.Constant;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.Object.Prediction.Delegating
{
    [APIExclude]
    public delegate void ReplicateRpcDelegate(NetworkBehaviour obj, PooledReader reader, NetworkConnection sender);
    [APIExclude]
    public delegate void ReconcileRpcDelegate(NetworkBehaviour obj, PooledReader reader);

}
'''
'''--- Assets/FishNet/Runtime/Object/RpcLinkType.cs ---
﻿using FishNet.Object.Helping;

namespace FishNet.Object
{

    internal struct RpcLinkType
    {
        /// <summary>
        /// Index of link.
        /// </summary>
        public ushort LinkIndex;
        /// <summary>
        /// Type of Rpc link is for.
        /// </summary>
        public RpcType RpcType;

        public RpcLinkType(ushort linkIndex, RpcType rpcType)
        {
            LinkIndex = linkIndex;
            RpcType = rpcType;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/ICustomSync.cs ---
﻿
namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// Custom SyncObjects must inherit from SyncBase and implement this interface.
    /// </summary>
    public interface ICustomSync
    {
        /// <summary>
        /// Get the serialized type.
        /// This must return the value type you are synchronizing, for example a struct or class.
        /// If you are not synchronizing a particular value but instead of supported values such as int, bool, ect, then you may return null on this method.
        /// </summary>
        /// <returns></returns>
        object GetSerializedType();
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/ISyncObject.cs ---
﻿using FishNet.Managing;
using FishNet.Serializing;
using System;

namespace FishNet.Object.Synchronizing.Internal
{
    /// <summary>
    /// A sync object is an object that can synchronize it's state
    /// between server and client, such as a SyncList
    /// </summary>
    public interface ISyncType
    {
        /// <summary>
        /// true if there are changes since the last flush
        /// </summary>
        bool IsDirty { get; }
        /// <summary>
        /// Sets index for the SyncType.
        /// </summary>
        void SetRegistered();
        /// <summary>
        /// PreInitializes this for use with the network.
        /// </summary>
        void PreInitialize(NetworkManager networkManager);
        /// <summary>
        /// Writes all changed values.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        void WriteDelta(PooledWriter writer, bool resetSyncTick = true);
        /// <summary>
        /// Writers all values if not initial values.
        /// </summary>
        /// <param name="writer"></param>
        void WriteFull(PooledWriter writer);
        /// <summary>
        /// Sets current values.
        /// </summary>
        /// <param name="reader"></param>
        void Read(PooledReader reader);
        /// <summary>
        /// Resets the SyncObject so that it can be re-used
        /// </summary>
        void Reset();
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/MissingObjectPacketLength.cs ---
﻿namespace FishNet.Object
{

    internal enum MissingObjectPacketLength : int
    {
        Reliable = -1,
        PurgeRemaiming = -2,
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/ReadPermissions.cs ---
namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// Which clients may receive synchronization updates.
    /// </summary>
    public enum ReadPermission
    {
        /// <summary>
        /// All observers will receive updates.
        /// </summary>
        Observers,
        /// <summary>
        /// Only owner will receive updates.
        /// </summary>
        OwnerOnly,
        /// <summary>
        /// Send to all observers except owner.
        /// </summary>
        ExcludeOwner
    }
}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SecretMenu/SyncVarExtensions.cs ---
﻿using FishNet.Documenting;

namespace FishNet.Object.Synchronizing.SecretMenu
{
    /// <summary>
    /// Internal SyncVar extensions.
    /// </summary>
    [APIExclude]
    public static class SyncVarExtensions
    {
        /// <summary>
        /// Dirties SyncVars.
        /// </summary>
        /// <param name="obj"></param>
        [APIExclude]
        public static void Dirty(this object obj) { }
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/Settings.cs ---
using FishNet.Transporting;

namespace FishNet.Object.Synchronizing.Internal
{
    public class Settings
    {
        /// <summary>
        /// Defines the write permissions for this var
        /// </summary>
        public WritePermission WritePermission = WritePermission.ServerOnly;
        /// <summary>
        /// Clients which may receive updated values.
        /// </summary>
        public ReadPermission ReadPermission = ReadPermission.Observers;
        /// <summary>
        /// How often this variable may synchronize.
        /// </summary>
        public float SendTickRate = 0f;
        /// <summary>
        /// Channel to send values on.
        /// </summary>
        public Channel Channel = Channel.Reliable;

        /// <summary>
        /// Constructs a new NetworkedVarSettings instance
        /// </summary>
        public Settings()
        {

        }

        public Settings(WritePermission writePermission, ReadPermission readPermission, float sendTickrate, Channel channel)
        {
            WritePermission = writePermission;
            ReadPermission = readPermission;
            SendTickRate = sendTickrate;
            Channel = channel;
        }

        public Settings(float sendTickrate)
        {
            SendTickRate = sendTickrate;
        }

        public Settings(ReadPermission readPermission, float sendTickrate, Channel channel)
        {
            ReadPermission = readPermission;
            SendTickRate = sendTickrate;
            Channel = channel;
        }

    }
}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SyncBase.cs ---
﻿using FishNet.Managing;
using FishNet.Managing.Timing;
using FishNet.Serializing;
using FishNet.Transporting;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing.Internal
{
    public class SyncBase : ISyncType
    {

        #region Public.
        /// <summary>
        /// True if this SyncBase has been registered within it's containing class.
        /// </summary>
        public bool IsRegistered { get; private set; }
        /// <summary>
        /// True if a SyncObject, false if a SyncVar.
        /// </summary>
        public bool IsSyncObject { get; private set; }
        /// <summary>
        /// The settings for this SyncVar.
        /// </summary>
        public Settings Settings = new Settings();
        /// <summary>
        /// How often updates may send.
        /// </summary>
        public float SendTickRate => Settings.SendTickRate;
        /// <summary>
        /// True if this SyncVar needs to send data.
        /// </summary>
        public bool IsDirty { get; private set; }
        /// <summary>
        /// NetworkManager this uses.
        /// </summary>
        public NetworkManager NetworkManager = null;
        /// <summary>
        /// NetworkBehaviour this SyncVar belongs to.
        /// </summary>
        public NetworkBehaviour NetworkBehaviour = null;
        /// <summary>
        /// Next time a SyncVar may send data/
        /// </summary>
        public uint NextSyncTick = 0;
        /// <summary>
        /// Index within the sync collection.
        /// </summary>
        public uint SyncIndex { get; protected set; } = 0;
        /// <summary>
        /// Channel to send on.
        /// </summary>
        internal Channel Channel => _currentChannel;
        #endregion

        #region Private.
        /// <summary>
        /// Sync interval converted to ticks.
        /// </summary>
        private uint _timeToTicks;
        /// <summary>
        /// Channel to use for next write. To ensure eventual consistency this eventually changes to reliable when Settings are unreliable.
        /// </summary>
        private Channel _currentChannel;
        #endregion

        /// <summary>
        /// Initializes this SyncBase.
        /// </summary>
        public void InitializeInstance(NetworkBehaviour nb, uint syncIndex, WritePermission writePermissions, ReadPermission readPermissions, float tickRate, Channel channel, bool isSyncObject)
        {
            NetworkBehaviour = nb;
            SyncIndex = syncIndex;
            _currentChannel = channel;
            IsSyncObject = isSyncObject;
            Settings = new Settings()
            {
                WritePermission = writePermissions,
                ReadPermission = readPermissions,
                SendTickRate = tickRate,
                Channel = channel
            };

            NetworkBehaviour.RegisterSyncType(this, SyncIndex);
        }

        /// <summary>
        /// Sets the SyncIndex.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetRegistered()
        {
            Registered();
        }

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected virtual void Registered()
        {
            IsRegistered = true;
        }

        /// <summary>
        /// PreInitializes this for use with the network.
        /// </summary>
        public void PreInitialize(NetworkManager networkManager)
        {
            NetworkManager = networkManager;
            _timeToTicks = NetworkManager.TimeManager.TimeToTicks(Settings.SendTickRate, TickRounding.RoundUp);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal virtual void OnStartCallback(bool asServer) { }

        /// <summary>
        /// Dirties this Sync and the NetworkBehaviour.
        /// </summary>
        public bool Dirty()
        {
            /* Reset channel even if already dirty.
             * This is because the value might have changed
             * which will reset the eventual consistency state. */
            _currentChannel = Settings.Channel;

            /* Once dirty don't undirty until it's
             * processed. This ensures that data
             * is flushed. */
            bool canDirty = NetworkBehaviour.DirtySyncType(IsSyncObject);
            IsDirty |= canDirty;

            return canDirty;
        }

        /// <summary>
        /// Sets IsDirty to false.
        /// </summary>
        internal void ResetDirty()
        {
            //If not a sync object and using unreliable channel.
            if (!IsSyncObject && Settings.Channel == Channel.Unreliable)
            {
                //Check if dirty can be unset or if another tick must be run using reliable.
                if (_currentChannel == Channel.Unreliable)
                    _currentChannel = Channel.Reliable;
                //Already sent reliable, can undirty. Channel will reset next time this dirties.
                else
                    IsDirty = false;
            }
            //If syncObject or using reliable unset dirty.
            else
            {
                IsDirty = false;
            }
        }
        /// <summary>
        /// True if dirty and enough time has passed to write changes.
        /// </summary>
        /// <param name="tick"></param>
        /// <returns></returns>
        internal bool WriteTimeMet(uint tick)
        {
            return (IsDirty && tick >= NextSyncTick);
        }
        /// <summary>
        /// Writes current value.
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="resetSyncTick">True to set the next time data may sync.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public virtual void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            WriteHeader(writer, resetSyncTick);
        }
        /// <summary>
        /// Writers the header for this SyncType.
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="resetSyncTick"></param>
        protected virtual void WriteHeader(PooledWriter writer, bool resetSyncTick = true)
        {
            if (resetSyncTick)
                NextSyncTick = NetworkManager.TimeManager.Tick + _timeToTicks;

            writer.WriteByte((byte)SyncIndex);
        }
        /// <summary>
        /// Writes current value if not initialized value.
        /// </summary>
        /// <param name="writer"></param>
        public virtual void WriteFull(PooledWriter writer) { }
        /// <summary>
        /// Sets current value.
        /// </summary>
        /// <param name="reader"></param>
        public virtual void Read(PooledReader reader) { }
        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        public virtual void Reset()
        {
            NextSyncTick = 0;
            ResetDirty();
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SyncDictionary.cs ---
﻿using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using FishNet.Utility.Extension;
using JetBrains.Annotations;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{

    public class SyncIDictionary<TKey, TValue> : SyncBase, IDictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue>
    {

        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncDictionaryOperation Operation;
            internal readonly TKey Key;
            internal readonly TValue Value;

            public CachedOnChange(SyncDictionaryOperation operation, TKey key, TValue value)
            {
                Operation = operation;
                Key = key;
                Value = value;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncDictionaryOperation Operation;
            internal readonly TKey Key;
            internal readonly TValue Value;

            public ChangeData(SyncDictionaryOperation operation, TKey key, TValue value)
            {
                this.Operation = operation;
                this.Key = key;
                this.Value = value;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from Dictionary<TKey,TValue>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;
        /// <summary>
        /// Delegate signature for when SyncDictionary changes.
        /// </summary>
        /// <param name="op">Operation being completed, such as Add, Set, Remove.</param>
        /// <param name="key">Key being modified.</param>
        /// <param name="value">Value of operation.</param>
        /// <param name="asServer">True if callback is on the server side. False is on the client side.</param>
        [APIExclude]
        public delegate void SyncDictionaryChanged(SyncDictionaryOperation op, TKey key, TValue value, bool asServer);
        /// <summary>
        /// Called when the SyncDictionary changes.
        /// </summary>
        public event SyncDictionaryChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public readonly IDictionary<TKey, TValue> Collection;
        /// <summary>
        /// Copy of objects on client portion when acting as a host.
        /// </summary>
        public readonly IDictionary<TKey, TValue> ClientHostCollection = new Dictionary<TKey, TValue>();
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        /// <summary>
        /// Keys within the collection.
        /// </summary>
        public ICollection<TKey> Keys => Collection.Keys;
        [APIExclude]
        IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => Collection.Keys;
        /// <summary>
        /// Values within the collection.
        /// </summary>
        public ICollection<TValue> Values => Collection.Values;
        [APIExclude]
        IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => Collection.Values;
        #endregion

        #region Private.
        /// <summary>
        /// Initial values for the dictionary.
        /// </summary>
        private IDictionary<TKey, TValue> _initialValues = new Dictionary<TKey, TValue>();
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private readonly List<ChangeData> _changed = new List<ChangeData>();
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private readonly List<CachedOnChange> _serverOnChanges = new List<CachedOnChange>();
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private readonly List<CachedOnChange> _clientOnChanges = new List<CachedOnChange>();
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        [APIExclude]
        public SyncIDictionary(IDictionary<TKey, TValue> objects)
        {
            this.Collection = objects;
            //Add to clienthostcollection.
            foreach (KeyValuePair<TKey, TValue> item in objects)
                this.ClientHostCollection[item.Key] = item.Value;
        }

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <param name="asServer">True if returning the server value, false if client value. The values will only differ when running as host. While asServer is true the most current values on server will be returned, and while false the latest values received by client will be returned.</param>
        /// <returns>The used collection.</returns>
        public Dictionary<TKey, TValue> GetCollection(bool asServer)
        {
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServer);
            IDictionary<TKey, TValue> collection = (asClientAndHost) ? ClientHostCollection : Collection;
            return (collection as Dictionary<TKey, TValue>);
        }

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Registered()
        {
            base.Registered();
            foreach (KeyValuePair<TKey, TValue> item in Collection)
                _initialValues[item.Key] = item.Value;
        }

        /// <summary>
        /// Adds an operation and invokes callback locally.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="operation"></param>
        /// <param name="key"></param>
        /// <param name="value"></param>
        [APIExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AddOperation(SyncDictionaryOperation operation, TKey key, TValue value)
        {
            if (!base.IsRegistered)
                return;

            if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot complete operation {operation} as server when server is not active.");
                return;
            }

            /* Set as changed even if cannot dirty.
            * Dirty is only set when there are observers,
            * but even if there are not observers
            * values must be marked as changed so when
            * there are observers, new values are sent. */
            _valuesChanged = true;

            /* If unable to dirty then do not add to changed.
             * A dirty may fail if the server is not started
             * or if there's no observers. Changed doesn't need
             * to be populated in this situations because clients
             * will get the full collection on spawn. If we
             * were to also add to changed clients would get the full
             * collection as well the changed, which would double results. */
            if (base.Dirty())
            {
                ChangeData change = new ChangeData(operation, key, value);
                _changed.Add(change);
            }

            bool asServer = true;
            InvokeOnChange(operation, key, value, asServer);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Key, item.Value, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        [APIExclude]
        public override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);

            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                //False for not full write.
                writer.WriteBoolean(false);
                writer.WriteUInt32((uint)_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteByte((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncDictionaryOperation.Add ||
                        change.Operation == SyncDictionaryOperation.Set)
                    {
                        writer.Write(change.Key);
                        writer.Write(change.Value);
                    }
                    else if (change.Operation == SyncDictionaryOperation.Remove)
                    {
                        writer.Write(change.Key);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writers all values if not initial values.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="writer"></param>
        [APIExclude]
        public override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //True for full write.
            writer.WriteBoolean(true);
            writer.WriteUInt32((uint)Collection.Count);
            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                writer.WriteByte((byte)SyncDictionaryOperation.Add);
                writer.Write(item.Key);
                writer.Write(item.Value);
            }
        }

        /// <summary>
        /// Sets current values.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="reader"></param>
        [APIExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override void Read(PooledReader reader)
        {
            bool asServer = false;
            /* When !asServer don't make changes if server is running.
            * This is because changes would have already been made on
            * the server side and doing so again would result in duplicates
            * and potentially overwrite data not yet sent. */
            bool asClientAndHost = (!asServer && base.NetworkBehaviour.IsServer);
            IDictionary<TKey, TValue> collection = (asClientAndHost) ? ClientHostCollection : Collection;

            //Clear collection since it's a full write.
            bool fullWrite = reader.ReadBoolean();
            if (fullWrite)
                collection.Clear();

            int changes = (int)reader.ReadUInt32();
            for (int i = 0; i < changes; i++)
            {
                SyncDictionaryOperation operation = (SyncDictionaryOperation)reader.ReadByte();
                TKey key = default;
                TValue value = default;

                /* Add, Set.
                 * Use the Set code for add and set,
                 * especially so collection doesn't throw
                 * if entry has already been added. */
                if (operation == SyncDictionaryOperation.Add || operation == SyncDictionaryOperation.Set)
                {
                    key = reader.Read<TKey>();
                    value = reader.Read<TValue>();
                    collection[key] = value;
                }
                //Clear.
                else if (operation == SyncDictionaryOperation.Clear)
                {
                    collection.Clear();
                }
                //Remove.
                else if (operation == SyncDictionaryOperation.Remove)
                {
                    key = reader.Read<TKey>();
                    collection.Remove(key);
                }

                InvokeOnChange(operation, key, value, false);
            }

            //If changes were made invoke complete after all have been read.
            if (changes > 0)
                InvokeOnChange(SyncDictionaryOperation.Complete, default, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncDictionaryOperation operation, TKey key, TValue value, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, key, value, asServer);
                else
                    _serverOnChanges.Add(new CachedOnChange(operation, key, value));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, key, value, asServer);
                else
                    _clientOnChanges.Add(new CachedOnChange(operation, key, value));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        [APIExclude]
        public override void Reset()
        {
            base.Reset();
            _sendAll = false;
            _changed.Clear();
            Collection.Clear();
            ClientHostCollection.Clear();
            _valuesChanged = false;

            foreach (KeyValuePair<TKey, TValue> item in _initialValues)
            {
                Collection[item.Key] = item.Value;
                ClientHostCollection[item.Key] = item.Value;
            }
        }

        /// <summary>
        /// Adds item.
        /// </summary>
        /// <param name="item">Item to add.</param>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }
        /// <summary>
        /// Adds key and value.
        /// </summary>
        /// <param name="key">Key to add.</param>
        /// <param name="value">Value for key.</param>
        public void Add(TKey key, TValue value)
        {
            Add(key, value, true);
        }
        private void Add(TKey key, TValue value, bool asServer)
        {
            Collection.Add(key, value);
            if (asServer)
                AddOperation(SyncDictionaryOperation.Add, key, value);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }
        private void Clear(bool asServer)
        {
            Collection.Clear();
            if (asServer)
                AddOperation(SyncDictionaryOperation.Clear, default, default);
        }

        /// <summary>
        /// Returns if key exist.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <returns>True if found.</returns>
        public bool ContainsKey(TKey key)
        {
            return Collection.ContainsKey(key);
        }
        /// <summary>
        /// Returns if item exist.
        /// </summary>
        /// <param name="item">Item to use.</param>
        /// <returns>True if found.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return TryGetValue(item.Key, out TValue value) && EqualityComparer<TValue>.Default.Equals(value, item.Value);
        }

        /// <summary>
        /// Copies collection to an array.
        /// </summary>
        /// <param name="array">Array to copy to.</param>
        /// <param name="offset">Offset of array data is copied to.</param>
        public void CopyTo([NotNull] KeyValuePair<TKey, TValue>[] array, int offset)
        {
            if (offset <= -1 || offset >= array.Length)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Index is out of range.");
                return;
            }

            int remaining = array.Length - offset;
            if (remaining < Count)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Array is not large enough to copy data. Array is of length {array.Length}, index is {offset}, and number of values to be copied is {Count.ToString()}.");
                return;
            }

            int i = offset;
            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                array[i] = item;
                i++;
            }
        }

        /// <summary>
        /// Removes a key.
        /// </summary>
        /// <param name="key">Key to remove.</param>
        /// <returns>True if removed.</returns>
        public bool Remove(TKey key)
        {
            if (Collection.Remove(key))
            {
                AddOperation(SyncDictionaryOperation.Remove, key, default);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Removes an item.
        /// </summary>
        /// <param name="item">Item to remove.</param>
        /// <returns>True if removed.</returns>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        /// <summary>
        /// Tries to get value from key.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <param name="value">Variable to output to.</param>
        /// <returns>True if able to output value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetValue(TKey key, out TValue value)
        {
            return Collection.TryGetValueIL2CPP(key, out value);
        }

        /// <summary>
        /// Gets or sets value for a key.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <returns>Value when using as Get.</returns>
        public TValue this[TKey key]
        {
            get => Collection[key];
            set
            {
                Collection[key] = value;
                AddOperation(SyncDictionaryOperation.Set, key, value);
            }
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsRegistered)
                return;

            if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot complete operation as server when server is not active.");
                return;
            }

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Dirties an entry by key.
        /// </summary>
        /// <param name="key">Key to dirty.</param>
        public void Dirty(TKey key)
        {
            if (Collection.TryGetValueIL2CPP(key, out TValue value))
                AddOperation(SyncDictionaryOperation.Set, key, value);
        }

        /// <summary>
        /// Dirties an entry by value.
        /// This operation can be very expensive, will cause allocations, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="value">Value to dirty.</param>
        /// <returns>True if value was found and marked dirty.</returns>
        public bool Dirty(TValue value, EqualityComparer<TValue> comparer = null)
        {
            if (comparer == null)
                comparer = EqualityComparer<TValue>.Default;

            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                if (comparer.Equals(item.Value, value))
                {
                    AddOperation(SyncDictionaryOperation.Set, item.Key, value);
                    return true;
                }
            }

            //Not found.
            return false;
        }

        /// <summary>
        /// Gets the IEnumerator for the collection.
        /// </summary>
        /// <returns></returns>
        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() => Collection.GetEnumerator();
        /// <summary>
        /// Gets the IEnumerator for the collection.
        /// </summary>
        /// <returns></returns>
        IEnumerator IEnumerable.GetEnumerator() => Collection.GetEnumerator();

    }

    [APIExclude]
    public class SyncDictionary<TKey, TValue> : SyncIDictionary<TKey, TValue>
    {
        [APIExclude]
        public SyncDictionary() : base(new Dictionary<TKey, TValue>()) { }
        [APIExclude]
        public SyncDictionary(IEqualityComparer<TKey> eq) : base(new Dictionary<TKey, TValue>(eq)) { }
        [APIExclude]
        public new Dictionary<TKey, TValue>.ValueCollection Values => ((Dictionary<TKey, TValue>)Collection).Values;
        [APIExclude]
        public new Dictionary<TKey, TValue>.KeyCollection Keys => ((Dictionary<TKey, TValue>)Collection).Keys;
        [APIExclude]
        public new Dictionary<TKey, TValue>.Enumerator GetEnumerator() => ((Dictionary<TKey, TValue>)Collection).GetEnumerator();

    }
}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SyncDictionaryOperation.cs ---
﻿
using FishNet.Documenting;

namespace FishNet.Object.Synchronizing
{
    [APIExclude]
    public enum SyncDictionaryOperation : byte
    {
        /// <summary>
        /// A key and value have been added to the collection.
        /// </summary>
        Add,
        /// <summary>
        /// Collection has been cleared.
        /// </summary>
        Clear,
        /// <summary>
        /// A key was removed from the collection.
        /// </summary>
        Remove,
        /// <summary>
        /// A value has been set for a key in the collection.
        /// </summary>
        Set,
        /// <summary>
        /// All operations for the tick have been processed.
        /// </summary>
        Complete
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SyncHashSetOperation.cs ---
﻿
using FishNet.Documenting;

namespace FishNet.Object.Synchronizing
{
    [APIExclude]
    public enum SyncHashSetOperation : byte
    {
        /// <summary>
        /// An item is added to the collection.
        /// </summary>
        Add,
        /// <summary>
        /// An item is removed from the collection.
        /// </summary>
        Remove,
        /// <summary>
        /// Collection is cleared.
        /// </summary>
        Clear,
        /// <summary>
        /// All operations for the tick have been processed. This only occurs on clients as the server is unable to be aware of when the user is done modifying the list.
        /// </summary>
        Complete,
        /// <summary>
        /// An item has been updated within the collection. This is generally used when modifying data within a container.
        /// </summary>
        Update,
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SyncHashset.cs ---
﻿using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Utility.Performance;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{

    public class SyncHashSet<T> : SyncBase, ISet<T>
    {
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncHashSetOperation Operation;
            internal readonly T Item;

            public CachedOnChange(SyncHashSetOperation operation, T item)
            {
                Operation = operation;
                Item = item;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncHashSetOperation Operation;
            internal readonly T Item;

            public ChangeData(SyncHashSetOperation operation, T item)
            {
                Operation = operation;

                Item = item;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from List<T>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;
        /// <summary>
        /// Delegate signature for when SyncList changes.
        /// </summary>
        /// <param name="op">Type of change.</param>
        /// <param name="item">Item which was modified.</param>
        /// <param name="asServer">True if callback is occuring on the server.</param>
        [APIExclude]
        public delegate void SyncHashSetChanged(SyncHashSetOperation op, T item, bool asServer);
        /// <summary>
        /// Called when the SyncList changes.
        /// </summary>
        public event SyncHashSetChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public readonly ISet<T> Collection;
        /// <summary>
        /// Copy of objects on client portion when acting as a host.
        /// </summary>
        public readonly ISet<T> ClientHostCollection = new HashSet<T>();
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        #endregion

        #region Private.        
        /// <summary>
        /// ListCache for comparing.
        /// </summary>
        private ListCache<T> _listCache;
        /// <summary>
        /// Values upon initialization.
        /// </summary>
        private ISet<T> _initialValues = new HashSet<T>();
        /// <summary>
        /// Comparer to see if entries change when calling public methods.
        /// </summary>
        private readonly IEqualityComparer<T> _comparer;
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private readonly List<ChangeData> _changed = new List<ChangeData>();
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private readonly List<CachedOnChange> _serverOnChanges = new List<CachedOnChange>();
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private readonly List<CachedOnChange> _clientOnChanges = new List<CachedOnChange>();
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        [APIExclude]
        public SyncHashSet() : this(new HashSet<T>(), EqualityComparer<T>.Default) { }
        [APIExclude]
        public SyncHashSet(IEqualityComparer<T> comparer) : this(new HashSet<T>(), (comparer == null) ? EqualityComparer<T>.Default : comparer) { }
        [APIExclude]
        public SyncHashSet(ISet<T> collection, IEqualityComparer<T> comparer = null)
        {
            this._comparer = (comparer == null) ? EqualityComparer<T>.Default : comparer;
            this.Collection = collection;
            //Add each in collection to clienthostcollection.
            foreach (T item in collection)
                ClientHostCollection.Add(item);
        }

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Registered()
        {
            base.Registered();
            foreach (T item in Collection)
                _initialValues.Add(item);
        }

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <returns></returns>
        public HashSet<T> GetCollection(bool asServer)
        {
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServer);
            ISet<T> collection = (asClientAndHost) ? ClientHostCollection : Collection;
            return (collection as HashSet<T>);
        }

        /// <summary>
        /// Adds an operation and invokes locally.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AddOperation(SyncHashSetOperation operation, T item)
        {
            if (!base.IsRegistered)
                return;

            if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot complete operation as server when server is not active.");
                return;
            }

            /* Set as changed even if cannot dirty.
            * Dirty is only set when there are observers,
            * but even if there are not observers
            * values must be marked as changed so when
            * there are observers, new values are sent. */
            _valuesChanged = true;

            /* If unable to dirty then do not add to changed.
             * A dirty may fail if the server is not started
             * or if there's no observers. Changed doesn't need
             * to be populated in this situations because clients
             * will get the full collection on spawn. If we
             * were to also add to changed clients would get the full
             * collection as well the changed, which would double results. */
            if (base.Dirty())
            {
                ChangeData change = new ChangeData(operation, item);
                _changed.Add(change);
            }

            bool asServer = true;
            InvokeOnChange(operation, item, asServer);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;
            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Item, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        public override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                base.WriteDelta(writer, resetSyncTick);
                //False for not full write.
                writer.WriteBoolean(false);
                writer.WriteUInt32((uint)_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteByte((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncHashSetOperation.Add || change.Operation == SyncHashSetOperation.Remove || change.Operation == SyncHashSetOperation.Update)
                    {
                        writer.Write(change.Item);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writes all values if not initial values.
        /// </summary>
        /// <param name="writer"></param>
        public override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //True for full write.
            writer.WriteBoolean(true);
            int count = Collection.Count;
            writer.WriteUInt32((uint)count);
            foreach (T item in Collection)
            {
                writer.WriteByte((byte)SyncHashSetOperation.Add);
                writer.Write(item);
            }
        }

        /// <summary>
        /// Sets current values.
        /// </summary>
        /// <param name="reader"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [APIExclude]
        public override void Read(PooledReader reader)
        {
            bool asServer = false;
            /* When !asServer don't make changes if server is running.
            * This is because changes would have already been made on
            * the server side and doing so again would result in duplicates
            * and potentially overwrite data not yet sent. */
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServer);
            ISet<T> collection = (asClientAndHost) ? ClientHostCollection : Collection;

            //Clear collection since it's a full write.
            bool fullWrite = reader.ReadBoolean();
            if (fullWrite)
                collection.Clear();

            int changes = (int)reader.ReadUInt32();
            for (int i = 0; i < changes; i++)
            {
                SyncHashSetOperation operation = (SyncHashSetOperation)reader.ReadByte();
                T next = default;

                //Add.
                if (operation == SyncHashSetOperation.Add)
                {
                    next = reader.Read<T>();
                    collection.Add(next);
                }
                //Clear.
                else if (operation == SyncHashSetOperation.Clear)
                {
                    collection.Clear();
                }
                //Remove.
                else if (operation == SyncHashSetOperation.Remove)
                {
                    next = reader.Read<T>();
                    collection.Remove(next);
                }
                //Updated.
                else if (operation == SyncHashSetOperation.Update)
                {
                    next = reader.Read<T>();
                    collection.Remove(next);
                    collection.Add(next);
                }

                InvokeOnChange(operation, next, false);
            }

            //If changes were made invoke complete after all have been read.
            if (changes > 0)
                InvokeOnChange(SyncHashSetOperation.Complete, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncHashSetOperation operation, T item, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, item, asServer);
                else
                    _serverOnChanges.Add(new CachedOnChange(operation, item));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, item, asServer);
                else
                    _clientOnChanges.Add(new CachedOnChange(operation, item));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        public override void Reset()
        {
            base.Reset();
            _sendAll = false;
            _changed.Clear();
            Collection.Clear();
            ClientHostCollection.Clear();

            foreach (T item in _initialValues)
            {
                Collection.Add(item);
                ClientHostCollection.Add(item);
            }
        }

        /// <summary>
        /// Adds value.
        /// </summary>
        /// <param name="item"></param>
        public bool Add(T item)
        {
            return Add(item, true);
        }
        private bool Add(T item, bool asServer)
        {
            bool result = Collection.Add(item);
            //Only process if remove was successful.
            if (result && asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Add(item);
                AddOperation(SyncHashSetOperation.Add, item);
            }

            return result;
        }
        /// <summary>
        /// Adds a range of values.
        /// </summary>
        /// <param name="range"></param>
        public void AddRange(IEnumerable<T> range)
        {
            foreach (T entry in range)
                Add(entry, true);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }
        private void Clear(bool asServer)
        {
            Collection.Clear();
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Clear();
                AddOperation(SyncHashSetOperation.Clear, default);
            }
        }

        /// <summary>
        /// Returns if value exist.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Contains(T item)
        {
            return Collection.Contains(item);
        }

        /// <summary>
        /// Removes a value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Remove(T item)
        {
            return Remove(item, true);
        }
        private bool Remove(T item, bool asServer)
        {
            bool result = Collection.Remove(item);
            //Only process if remove was successful.
            if (result && asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Remove(item);
                AddOperation(SyncHashSetOperation.Remove, item);
            }

            return result;
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsRegistered)
                return;

            if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot complete operation as server when server is not active.");
                return;
            }

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Looks up obj in Collection and if found marks it's index as dirty.
        /// This operation can be very expensive, will cause allocations, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="obj">Object to lookup.</param>
        public void Dirty(T obj)
        {
            foreach (T item in Collection)
            {
                if (item.Equals(obj))
                {
                    AddOperation(SyncHashSetOperation.Update, obj);
                    return;
                }
            }

            //Not found.
            if (base.NetworkManager.CanLog(LoggingType.Error))
                Debug.LogError($"Could not find object within SyncHashSet, dirty will not be set.");
        }

        /// <summary>
        /// Returns Enumerator for collection.
        /// </summary>
        /// <returns></returns>
        public IEnumerator GetEnumerator() => Collection.GetEnumerator();
        [APIExclude]
        IEnumerator<T> IEnumerable<T>.GetEnumerator() => Collection.GetEnumerator();
        [APIExclude]
        IEnumerator IEnumerable.GetEnumerator() => Collection.GetEnumerator();

        public void ExceptWith(IEnumerable<T> other)
        {
            //Again, removing from self is a clear.
            if (other == Collection)
            {
                Clear();
            }
            else
            {
                foreach (T item in other)
                    Remove(item);
            }
        }

        public void IntersectWith(IEnumerable<T> other)
        {
            ISet<T> set;
            if (other is ISet<T> setA)
                set = setA;
            else
                set = new HashSet<T>(other);

            IntersectWith(set);
        }

        private void IntersectWith(ISet<T> other)
        {
            Intersect(Collection);
            if (base.NetworkManager == null)
                Intersect(ClientHostCollection);

            void Intersect(ISet<T> collection)
            {
                if (_listCache == null)
                    _listCache = new ListCache<T>();
                else
                    _listCache.Reset();

                _listCache.AddValues(collection);

                int count = _listCache.Written;
                for (int i = 0; i < count; i++)
                {
                    T entry = _listCache.Collection[i];
                    if (!other.Contains(entry))
                        Remove(entry);
                }
            }

        }

        public bool IsProperSubsetOf(IEnumerable<T> other)
        {
            return Collection.IsProperSubsetOf(other);
        }

        public bool IsProperSupersetOf(IEnumerable<T> other)
        {
            return Collection.IsProperSupersetOf(other);
        }

        public bool IsSubsetOf(IEnumerable<T> other)
        {
            return Collection.IsSubsetOf(other);
        }

        public bool IsSupersetOf(IEnumerable<T> other)
        {
            return Collection.IsSupersetOf(other);
        }

        public bool Overlaps(IEnumerable<T> other)
        {
            bool result = Collection.Overlaps(other);
            return result;
        }

        public bool SetEquals(IEnumerable<T> other)
        {
            return Collection.SetEquals(other);
        }

        public void SymmetricExceptWith(IEnumerable<T> other)
        {
            //If calling except on self then that is the same as a clear.
            if (other == Collection)
            {
                Clear();
            }
            else
            {
                foreach (T item in other)
                    Remove(item);
            }
        }

        public void UnionWith(IEnumerable<T> other)
        {
            if (other == Collection)
                return;

            foreach (T item in other)
                Add(item);
        }

        /// <summary>
        /// Adds an item.
        /// </summary>
        /// <param name="item"></param>
        void ICollection<T>.Add(T item)
        {
            Add(item, true);
        }

        /// <summary>
        /// Copies values to an array.
        /// </summary>
        /// <param name="array"></param>
        /// <param name="index"></param>
        public void CopyTo(T[] array, int index)
        {
            Collection.CopyTo(array, index);
            if (base.NetworkManager == null)
                ClientHostCollection.CopyTo(array, index);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SyncList.cs ---
﻿using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{

    public class SyncList<T> : SyncBase, IList<T>, IReadOnlyList<T>
    {
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncListOperation Operation;
            internal readonly int Index;
            internal readonly T Previous;
            internal readonly T Next;

            public CachedOnChange(SyncListOperation operation, int index, T previous, T next)
            {
                Operation = operation;
                Index = index;
                Previous = previous;
                Next = next;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncListOperation Operation;
            internal readonly int Index;
            internal readonly T Item;

            public ChangeData(SyncListOperation operation, int index, T item)
            {
                Operation = operation;
                Index = index;
                Item = item;
            }
        }

        /// <summary>
        /// Custom enumerator to prevent garbage collection.
        /// </summary>
        [APIExclude]
        public struct Enumerator : IEnumerator<T>
        {
            public T Current { get; private set; }
            private readonly SyncList<T> _list;
            private int _index;

            public Enumerator(SyncList<T> list)
            {
                this._list = list;
                _index = -1;
                Current = default;
            }

            public bool MoveNext()
            {
                _index++;
                if (_index >= _list.Count)
                    return false;
                Current = _list[_index];
                return true;
            }

            public void Reset() => _index = -1;
            object IEnumerator.Current => Current;
            public void Dispose() { }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from List<T>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;
        /// <summary>
        /// Delegate signature for when SyncList changes.
        /// </summary>
        /// <param name="op"></param>
        /// <param name="index"></param>
        /// <param name="oldItem"></param>
        /// <param name="newItem"></param>
        [APIExclude]
        public delegate void SyncListChanged(SyncListOperation op, int index, T oldItem, T newItem, bool asServer);
        /// <summary>
        /// Called when the SyncList changes.
        /// </summary>
        public event SyncListChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public readonly IList<T> Collection;
        /// <summary>
        /// Copy of objects on client portion when acting as a host.
        /// </summary>
        public readonly IList<T> ClientHostCollection = new List<T>();
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        #endregion

        #region Private.        
        /// <summary>
        /// Values upon initialization.
        /// </summary>
        private IList<T> _initialValues = new List<T>();
        /// <summary>
        /// Comparer to see if entries change when calling public methods.
        /// </summary>
        private readonly IEqualityComparer<T> _comparer;
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private readonly List<ChangeData> _changed = new List<ChangeData>();
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private readonly List<CachedOnChange> _serverOnChanges = new List<CachedOnChange>();
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private readonly List<CachedOnChange> _clientOnChanges = new List<CachedOnChange>();
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        [APIExclude]
        public SyncList() : this(new List<T>(), EqualityComparer<T>.Default) { }
        [APIExclude]
        public SyncList(IEqualityComparer<T> comparer) : this(new List<T>(), (comparer == null) ? EqualityComparer<T>.Default : comparer) { }
        [APIExclude]
        public SyncList(IList<T> collection, IEqualityComparer<T> comparer = null)
        {
            this._comparer = (comparer == null) ? EqualityComparer<T>.Default : comparer;
            this.Collection = collection;
            //Add each in collection to clienthostcollection.
            foreach (T item in collection)
                this.ClientHostCollection.Add(item);
        }

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Registered()
        {
            base.Registered();
            foreach (T item in Collection)
                _initialValues.Add(item);
        }

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <param name="asServer">True if returning the server value, false if client value. The values will only differ when running as host. While asServer is true the most current values on server will be returned, and while false the latest values received by client will be returned.</param>
        /// <returns></returns>
        public List<T> GetCollection(bool asServer)
        {
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServer);
            IList<T> collection = (asClientAndHost) ? ClientHostCollection : Collection;
            return (collection as List<T>);
        }

        /// <summary>
        /// Adds an operation and invokes locally.
        /// </summary>
        /// <param name="operation"></param>
        /// <param name="index"></param>
        /// <param name="prev"></param>
        /// <param name="next"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AddOperation(SyncListOperation operation, int index, T prev, T next)
        {
            if (!base.IsRegistered)
                return;

            if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot complete operation as server when server is not active.");
                return;
            }

            /* Set as changed even if cannot dirty.
            * Dirty is only set when there are observers,
            * but even if there are not observers
            * values must be marked as changed so when
            * there are observers, new values are sent. */
            _valuesChanged = true;

            /* If unable to dirty then do not add to changed.
             * A dirty may fail if the server is not started
             * or if there's no observers. Changed doesn't need
             * to be populated in this situations because clients
             * will get the full collection on spawn. If we
             * were to also add to changed clients would get the full
             * collection as well the changed, which would double results. */
            if (base.Dirty())
            {
                ChangeData change = new ChangeData(operation, index, next);
                _changed.Add(change);
            }
            bool asServer = true;
            InvokeOnChange(operation, index, prev, next, asServer);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Index, item.Previous, item.Next, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        public override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                base.WriteDelta(writer, resetSyncTick);
                //False for not full write.
                writer.WriteBoolean(false);
                writer.WriteUInt32((uint)_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteByte((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncListOperation.Add)
                    {
                        writer.Write(change.Item);
                    }
                    else if (change.Operation == SyncListOperation.RemoveAt)
                    {
                        writer.WriteUInt32((uint)change.Index);
                    }
                    else if (change.Operation == SyncListOperation.Insert || change.Operation == SyncListOperation.Set)
                    {
                        writer.WriteUInt32((uint)change.Index);
                        writer.Write(change.Item);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writes all values if not initial values.
        /// </summary>
        /// <param name="writer"></param>
        public override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //True for full write.
            writer.WriteBoolean(true);
            writer.WriteUInt32((uint)Collection.Count);
            for (int i = 0; i < Collection.Count; i++)
            {
                writer.WriteByte((byte)SyncListOperation.Add);
                writer.Write(Collection[i]);
            }
        }

        /// <summary>
        /// Sets current values.
        /// </summary>
        /// <param name="reader"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [APIExclude]
        public override void Read(PooledReader reader)
        {
            bool asServer = false;
            /* When !asServer don't make changes if server is running.
            * This is because changes would have already been made on
            * the server side and doing so again would result in duplicates
            * and potentially overwrite data not yet sent. */
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServer);
            IList<T> collection = (asClientAndHost) ? ClientHostCollection : Collection;

            //Clear collection since it's a full write.
            bool fullWrite = reader.ReadBoolean();
            if (fullWrite)
                collection.Clear();

            int changes = (int)reader.ReadUInt32();

            for (int i = 0; i < changes; i++)
            {
                SyncListOperation operation = (SyncListOperation)reader.ReadByte();
                int index = -1;
                T prev = default;
                T next = default;

                //Add.
                if (operation == SyncListOperation.Add)
                {
                    next = reader.Read<T>();
                    index = collection.Count;
                    collection.Add(next);
                }
                //Clear.
                else if (operation == SyncListOperation.Clear)
                {
                    collection.Clear();
                }
                //Insert.
                else if (operation == SyncListOperation.Insert)
                {
                    index = (int)reader.ReadUInt32();
                    next = reader.Read<T>();
                    collection.Insert(index, next);
                }
                //RemoveAt.
                else if (operation == SyncListOperation.RemoveAt)
                {
                    index = (int)reader.ReadUInt32();
                    prev = collection[index];
                    collection.RemoveAt(index);
                }
                //Set
                else if (operation == SyncListOperation.Set)
                {
                    index = (int)reader.ReadUInt32();
                    next = reader.Read<T>();
                    prev = collection[index];
                    collection[index] = next;
                }

                InvokeOnChange(operation, index, prev, next, false);
            }

            //If changes were made invoke complete after all have been read.
            if (changes > 0)
                InvokeOnChange(SyncListOperation.Complete, -1, default, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncListOperation operation, int index, T prev, T next, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, index, prev, next, asServer);
                else
                    _serverOnChanges.Add(new CachedOnChange(operation, index, prev, next));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, index, prev, next, asServer);
                else
                    _clientOnChanges.Add(new CachedOnChange(operation, index, prev, next));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        public override void Reset()
        {
            base.Reset();
            _sendAll = false;
            _changed.Clear();
            ClientHostCollection.Clear();
            Collection.Clear();

            foreach (T item in _initialValues)
            {
                Collection.Add(item);
                ClientHostCollection.Add(item);
            }
        }

        /// <summary>
        /// Adds value.
        /// </summary>
        /// <param name="item"></param>
        public void Add(T item)
        {
            Add(item, true);
        }
        private void Add(T item, bool asServer)
        {
            Collection.Add(item);
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Add(item);
                AddOperation(SyncListOperation.Add, Collection.Count - 1, default, item);
            }
        }
        /// <summary>
        /// Adds a range of values.
        /// </summary>
        /// <param name="range"></param>
        public void AddRange(IEnumerable<T> range)
        {
            foreach (T entry in range)
                Add(entry, true);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }
        private void Clear(bool asServer)
        {
            Collection.Clear();
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Clear();
                AddOperation(SyncListOperation.Clear, -1, default, default);
            }
        }

        /// <summary>
        /// Returns if value exist.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Contains(T item)
        {
            return (IndexOf(item) >= 0);
        }

        /// <summary>
        /// Copies values to an array.
        /// </summary>
        /// <param name="array"></param>
        /// <param name="index"></param>
        public void CopyTo(T[] array, int index)
        {
            Collection.CopyTo(array, index);
        }

        /// <summary>
        /// Gets the index of value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public int IndexOf(T item)
        {
            for (int i = 0; i < Collection.Count; ++i)
                if (_comparer.Equals(item, Collection[i]))
                    return i;
            return -1;
        }

        /// <summary>
        /// Finds index using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public int FindIndex(Predicate<T> match)
        {
            for (int i = 0; i < Collection.Count; ++i)
                if (match(Collection[i]))
                    return i;
            return -1;
        }

        /// <summary>
        /// Finds value using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public T Find(Predicate<T> match)
        {
            int i = FindIndex(match);
            return (i != -1) ? Collection[i] : default;
        }

        /// <summary>
        /// Finds all values using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public List<T> FindAll(Predicate<T> match)
        {
            List<T> results = new List<T>();
            for (int i = 0; i < Collection.Count; ++i)
                if (match(Collection[i]))
                    results.Add(Collection[i]);
            return results;
        }

        /// <summary>
        /// Inserts value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="item"></param>
        public void Insert(int index, T item)
        {
            Insert(index, item, true);
        }
        private void Insert(int index, T item, bool asServer)
        {
            Collection.Insert(index, item);
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Insert(index, item);
                AddOperation(SyncListOperation.Insert, index, default, item);
            }
        }

        /// <summary>
        /// Inserts a range of values.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="range"></param>
        public void InsertRange(int index, IEnumerable<T> range)
        {
            foreach (T entry in range)
            {
                Insert(index, entry);
                index++;
            }
        }

        /// <summary>
        /// Removes a value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Remove(T item)
        {
            int index = IndexOf(item);
            bool result = index >= 0;
            if (result)
                RemoveAt(index);

            return result;
        }

        /// <summary>
        /// Removes value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="asServer"></param>
        public void RemoveAt(int index)
        {
            RemoveAt(index, true);
        }
        private void RemoveAt(int index, bool asServer)
        {
            T oldItem = Collection[index];
            Collection.RemoveAt(index);
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.RemoveAt(index);
                AddOperation(SyncListOperation.RemoveAt, index, oldItem, default);
            }
        }

        /// <summary>
        /// Removes all values within the collection.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public int RemoveAll(Predicate<T> match)
        {
            List<T> toRemove = new List<T>();
            for (int i = 0; i < Collection.Count; ++i)
                if (match(Collection[i]))
                    toRemove.Add(Collection[i]);

            foreach (T entry in toRemove)
                Remove(entry);

            return toRemove.Count;
        }

        /// <summary>
        /// Gets or sets value at an index.
        /// </summary>
        /// <param name="i"></param>
        /// <returns></returns>
        public T this[int i]
        {
            get => Collection[i];
            set => Set(i, value, true, true);
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// This will not invoke the callback on server.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsRegistered)
                return;

            if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot complete operation as server when server is not active.");
                return;
            }

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Looks up obj in Collection and if found marks it's index as dirty.
        /// While using this operation previous value will be the same as next.
        /// This operation can be very expensive, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="obj">Object to lookup.</param>
        public void Dirty(T obj)
        {
            int index = Collection.IndexOf(obj);
            if (index != -1)
            {
                Dirty(index);
            }
            else
            {
                if (base.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Could not find object within SyncList, dirty will not be set.");
            }
        }
        /// <summary>
        /// Marks an index as dirty.
        /// While using this operation previous value will be the same as next.
        /// </summary>
        /// <param name="index"></param>
        public void Dirty(int index)
        {
            bool asServer = true;

            T value = Collection[index];
            if (asServer)
                AddOperation(SyncListOperation.Set, index, value, value);
        }
        /// <summary>
        /// Sets value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="value"></param>
        public void Set(int index, T value, bool force = true)
        {
            Set(index, value, true, force);
        }
        private void Set(int index, T value, bool asServer, bool force)
        {
            bool sameValue = (!force && !_comparer.Equals(Collection[index], value));
            if (!sameValue)
            {
                T prev = Collection[index];
                Collection[index] = value;
                if (asServer)
                {
                    if (base.NetworkManager == null)
                        ClientHostCollection[index] = value;
                    AddOperation(SyncListOperation.Set, index, prev, value);
                }
            }
        }

        /// <summary>
        /// Returns Enumerator for collection.
        /// </summary>
        /// <returns></returns>
        public Enumerator GetEnumerator() => new Enumerator(this);
        [APIExclude]
        IEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this);
        [APIExclude]
        IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);

    }
}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SyncListOperation.cs ---
﻿
using FishNet.Documenting;

namespace FishNet.Object.Synchronizing
{
    [APIExclude]
    public enum SyncListOperation : byte
    {
        /// <summary>
        /// An item is added to the collection.
        /// </summary>
        Add,
        /// <summary>
        /// An item is inserted into the collection.
        /// </summary>
        Insert,
        /// <summary>
        /// An item is set in the collection.
        /// </summary>
        Set,
        /// <summary>
        /// An item is removed from the collection.
        /// </summary>
        RemoveAt,
        /// <summary>
        /// Collection is cleared.
        /// </summary>
        Clear,
        /// <summary>
        /// All operations for the tick have been processed. This only occurs on clients as the server is unable to be aware of when the user is done modifying the list.
        /// </summary>
        Complete
    }

}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/SyncVar.cs ---
﻿using FishNet.Documenting;
using FishNet.Object.Helping;
using FishNet.Object.Synchronizing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{
    [APIExclude]
    [StructLayout(LayoutKind.Auto, CharSet = CharSet.Auto)]
    public class SyncVar<T> : SyncBase
    {
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly T Previous;
            internal readonly T Next;

            public CachedOnChange(T previous, T next)
            {
                Previous = previous;
                Next = next;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Called when the SyncDictionary changes.
        /// </summary>
        public event Action<T, T, bool> OnChange;
        #endregion

        #region Private.
        /// <summary>
        /// Server OnChange event waiting for start callbacks.
        /// </summary>
        private CachedOnChange? _serverOnChange;
        /// <summary>
        /// Client OnChange event waiting for start callbacks.
        /// </summary>
        private CachedOnChange? _clientOnChange;
        /// <summary>
        /// Value before the network is initialized on the containing object.
        /// </summary>
        private T _initialValue;
        /// <summary>
        /// Previous value on the client.
        /// </summary>
        private T _previousClientValue;
        /// <summary>
        /// Current value on the server, or client.
        /// </summary>
        private T _value;
        #endregion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SyncVar(NetworkBehaviour nb, uint syncIndex, WritePermission writePermission, ReadPermission readPermission, float sendRate, Channel channel, T value)
        {
            SetInitialValues(value);
            base.InitializeInstance(nb, syncIndex, writePermission, readPermission, sendRate, channel, false);
        }

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Registered()
        {
            base.Registered();
            _initialValue = _value;
        }

        /// <summary>
        /// Sets initial values to next.
        /// </summary>
        /// <param name="next"></param>
        private void SetInitialValues(T next)
        {
            _initialValue = next;
            UpdateValues(next);
        }
        /// <summary>
        /// Sets current and previous values.
        /// </summary>
        /// <param name="next"></param>
        private void UpdateValues(T next)
        {
            _previousClientValue = next;
            _value = next;
        }
        /// <summary>
        /// Sets current value and marks the SyncVar dirty when able to. Returns if able to set value.
        /// </summary>
        /// <param name="calledByUser">True if SetValue was called in response to user code. False if from automated code.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetValue(T nextValue, bool calledByUser)
        {
            /* If not registered then that means Awake
             * has not completed on the owning class. This would be true
             * when setting values within awake on the owning class. Registered
             * is called at the end of awake, so it would be unset until awake completed.
             * 
             * Registered however will be true when setting from another script,
             * even if the owning class of this was just spawned. This is because
             * the unity cycle will fire awake on the object soon as it's spawned, 
             * completing awake, and the user would set the value after. */
            if (!base.IsRegistered)
                return;
            /* Don't include warning about setting values when not server.
             * SyncVars have an option to exclude owner when synchronizing
             * because the client may need to change values locally only. */

            bool isServer = base.NetworkBehaviour.IsServer;
            bool isClient = base.NetworkBehaviour.IsClient;
            /* If not client or server then set skipChecks
             * as true. When neither is true it's likely user is changing
             * value before object is initialized. This is allowed
             * but checks cannot be processed because they would otherwise
             * stop setting the value. */
            bool skipChecks = (!isClient && !isServer);

            //Object is deinitializing.
            if (!skipChecks && CodegenHelper.NetworkObject_Deinitializing(this.NetworkBehaviour))
                return;

            //If setting as server.
            if (calledByUser)
            {
                /* If skipping checks there's no need to dirty.
                 * Value is expected to be set on server and client since
                 * it's being set before the object is initialized. Should
                 * this not be the case then the user made a mistake. */
                //If skipping checks also update 
                if (skipChecks)
                {
                    T prev = _value;
                    UpdateValues(nextValue);
                    InvokeOnChange(prev, _value, calledByUser);
                }
                else
                {
                    /* //writepermission if using owner write permissions
                     * make sure caller is owner. */
                    if (Comparers.EqualityCompare<T>(this._value, nextValue))
                        return;

                    T prev = _value;
                    _value = nextValue;
                    InvokeOnChange(prev, _value, calledByUser);
                }

                TryDirty();
            }
            //Not called by user.
            else
            {

                /* Previously clients were not allowed to set values
                 * but this has been changed because clients may want
                 * to update values locally while occasionally
                 * letting the syncvar adjust their side. */
                T prev = _previousClientValue;
                /* If also server do not update value.
                 * Server side has say of the current value. */
                if (!base.NetworkManager.IsServer)
                    UpdateValues(nextValue);
                else
                    _previousClientValue = nextValue;

                InvokeOnChange(prev, nextValue, calledByUser);
                TryDirty();
            }

            /* Tries to dirty so update
             * is sent over network. This needs to be called
             * anytime the data changes because there is no way
             * to know if the user set the value on both server
             * and client or just one side. */
            void TryDirty()
            {
                //Cannot dirty when skipping checks.
                if (skipChecks)
                    return;

                if (calledByUser)
                    base.Dirty();
                //writepermission Once client write permissions are added this needs to be updated.
                //else if (!asServer && base.Settings.WritePermission == WritePermission.ServerOnly)
                //    base.Dirty();
            }
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(T prev, T next, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(prev, next, asServer);
                else
                    _serverOnChange = new CachedOnChange(prev, next);
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(prev, next, asServer);
                else
                    _clientOnChange = new CachedOnChange(prev, next);
            }
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);

            if (OnChange != null)
            {
                CachedOnChange? change = (asServer) ? _serverOnChange : _clientOnChange;
                if (change != null)
                    InvokeOnChange(change.Value.Previous, change.Value.Next, asServer);
            }

            if (asServer)
                _serverOnChange = null;
            else
                _clientOnChange = null;
        }

        /// <summary>
        /// Writes current value.
        /// </summary>
        /// <param name="resetSyncTick">True to set the next time data may sync.</param>
        public override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.Write<T>(_value);
        }

        /// <summary>
        /// Writes current value if not initialized value.
        /// </summary>m>
        public override void WriteFull(PooledWriter obj0)
        {
            if (Comparers.EqualityCompare<T>(_initialValue, _value))
                return;
            /* SyncVars only hold latest value, so just
             * write current delta. */
            WriteDelta(obj0, false);
        }

        //Read isn't used by SyncVar<T>, it's done within the NB.
        //public override void Read(PooledReader reader) { }

        /// <summary>
        /// Gets current value.
        /// </summary>
        /// <param name="calledByUser"></param>
        /// <returns></returns>
        public T GetValue(bool calledByUser) => (calledByUser) ? _value : _previousClientValue;

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        public override void Reset()
        {
            base.Reset();
            _value = _initialValue;
            _previousClientValue = _initialValue;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Object/Synchronizing/WritePermissions.cs ---
namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// Which clients or server may write updates.
    /// </summary>
    public enum WritePermission
    {
        ServerOnly
    }
}
'''
'''--- Assets/FishNet/Runtime/Object/TransformProperties.cs ---
﻿using UnityEngine;

namespace FishNet.Object
{
    [System.Serializable]
    public struct TransformProperties
    {
        public readonly Vector3 Position;
        public readonly Quaternion Rotation;
        public readonly Vector3 LocalScale;

        public TransformProperties(Vector3 position, Quaternion rotation, Vector3 localScale)
        {
            Position = position;
            Rotation = rotation;
            LocalScale = localScale;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Observing/Conditions/DistanceCondition.cs ---
﻿using FishNet.Connection;
using FishNet.Object;
using FishNet.Observing;
using FishNet.Utility.Extension;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Observing
{
    /// <summary>
    /// When this observer condition is placed on an object, a client must be within the specified distance to view the object.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Distance Condition", fileName = "New Distance Condition")]
    public class DistanceCondition : ObserverCondition
    {
        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Maximum distance a client must be within this object to see it.")]
        [SerializeField]
        private float _maximumDistance = 100f;
        /// <summary>
        /// Maximum distance a client must be within this object to see it.
        /// </summary>
        public float MaximumDistance { get => _maximumDistance; set => _maximumDistance = value; }
        /// <summary>
        /// Additional percent of distance client must be until this object is hidden. For example, if distance was 100f and percent was 0.5f the client must be 150f units away before this object is hidden again. This can be useful for keeping objects from regularly appearing and disappearing.
        /// </summary>
        [Tooltip("Additional percent of distance client must be until this object is hidden. For example, if distance was 100f and percent was 0.5f the client must be 150f units away before this object is hidden again. This can be useful for keeping objects from regularly appearing and disappearing.")]
        [Range(0f, 1f)]
        [SerializeField]
        private float _hideDistancePercent = 0.1f;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("How often this condition may change for a connection. This prevents objects from appearing and disappearing rapidly. A value of 0f will cause the object the update quickly as possible while any other value will be used as a delay.")]
        [Range(0f, 60f)]
        [SerializeField]
        private float _updateFrequency;
        /// <summary>
        /// How often this condition may change for a connection. This prevents objects from appearing and disappearing rapidly. A value of 0f will cause the object the update quickly as possible while any other value will be used as a delay.
        /// </summary>
        public float UpdateFrequency { get => _updateFrequency; set => _updateFrequency = value; }
        #endregion

        #region Private.
        /// <summary>
        /// Tracks when connections may be updated for this object.
        /// </summary>
        private Dictionary<NetworkConnection, float> _timedUpdates = new Dictionary<NetworkConnection, float>();
        #endregion

        public void ConditionConstructor(float maximumDistance, float updateFrequency)
        {
            MaximumDistance = maximumDistance;
            _updateFrequency = updateFrequency;
        }

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            if (_updateFrequency > 0f)
            {
                float nextAllowedUpdate;
                float currentTime = Time.time;
                if (!_timedUpdates.TryGetValueIL2CPP(connection, out nextAllowedUpdate))
                {
                    _timedUpdates[connection] = (currentTime + _updateFrequency);
                }
                else
                {
                    //Not enough time to process again.
                    if (currentTime < nextAllowedUpdate)
                    {
                        notProcessed = true;
                        //The return does not really matter since notProcessed is returned.
                        return false;
                    }
                    //Can process again.
                    else
                    {
                        _timedUpdates[connection] = (currentTime + _updateFrequency);
                    }
                }
            }
            //If here then checks are being processed.
            notProcessed = false;

            float sqrMaximumDistance;
            /* If already visible then use additional
             * distance to determine when to hide. */
            if (currentlyAdded)
            {
                float maxModified = (MaximumDistance * (1f + _hideDistancePercent));
                sqrMaximumDistance = (maxModified * maxModified);
            }
            //Not visible, use normal distance.
            else
            {
                sqrMaximumDistance = (MaximumDistance * MaximumDistance);
            }

            Vector3 thisPosition = NetworkObject.transform.position;
            foreach (NetworkObject nob in connection.Objects)
            {
                //If within distance.
                if (Vector3.SqrMagnitude(nob.transform.position - thisPosition) <= sqrMaximumDistance)
                    return true;
            }

            /* If here no client objects are within distance. */
            return false;
        }

        /// <summary>
        /// True if the condition requires regular updates.
        /// </summary>
        /// <returns></returns>
        public override bool Timed()
        {
            return true;
        }

        /// <summary>
        /// Clones referenced ObserverCondition. This must be populated with your conditions settings.
        /// </summary>
        /// <returns></returns>
        public override ObserverCondition Clone()
        {
            DistanceCondition copy = ScriptableObject.CreateInstance<DistanceCondition>();
            copy.ConditionConstructor(MaximumDistance, _updateFrequency);
            return copy;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Observing/Conditions/Editor/MatchConditionEditor.cs ---
﻿//#if UNITY_EDITOR //Remove on 2023/01/01
//using UnityEditor;
//using UnityEngine;

//namespace FishNet.Component.Observing
//{

//    namespace FishNet.Component.Prediction.Editing
//    {
//        [CustomEditor(typeof(MatchCondition), true)]
//        [CanEditMultipleObjects]
//        public class MatchConditionEditor : Editor
//        {
//            public override void OnInspectorGUI()
//            {

//                EditorGUILayout.HelpBox("This component is experimental. Documentation may not yet be available.", MessageType.Warning);
//                base.OnInspectorGUI();
//            }
//        }
//    }

//}

//#endif
'''
'''--- Assets/FishNet/Runtime/Observing/Conditions/MatchCondition.cs ---
﻿using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Observing;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Observing
{
    /// <summary>
    /// When this observer condition is placed on an object, a client must be within the same match to view the object.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Match Condition", fileName = "New Match Condition")]
    public class MatchCondition : ObserverCondition
    {
        #region Private.
        /// <summary>
        /// 
        /// </summary>
        private static Dictionary<int, HashSet<NetworkConnection>> _matchConnections = new Dictionary<int, HashSet<NetworkConnection>>();
        /// <summary>
        /// Matches and connections in each match.
        /// </summary>
        public static IReadOnlyDictionary<int, HashSet<NetworkConnection>> MatchConnections => _matchConnections;
        /// <summary>
        /// 
        /// </summary>
        /// //todo this needs to hold hashset so conns can be in multiple matches.
        private static Dictionary<NetworkConnection, int> _connectionMatch = new Dictionary<NetworkConnection, int>();
        /// <summary>
        /// Match a connection is in.
        /// </summary>
        public static IReadOnlyDictionary<NetworkConnection, int> ConnectionMatch => _connectionMatch;
        /// <summary>
        /// 
        /// </summary>
        private static Dictionary<int, HashSet<NetworkObject>> _matchObjects = new Dictionary<int, HashSet<NetworkObject>>();
        /// <summary>
        /// Matches and connections in each match.
        /// </summary>
        public static IReadOnlyDictionary<int, HashSet<NetworkObject>> MatchObjects => _matchObjects;
        /// <summary>
        /// 
        /// </summary>
        /// //todo this needs to hold hashset so conns can be in multiple matches.
        private static Dictionary<NetworkObject, int> _objectMatch = new Dictionary<NetworkObject, int>();
        /// <summary>
        /// Match a connection is in.
        /// </summary>
        public static IReadOnlyDictionary<NetworkObject, int> ObjectMatch => _objectMatch;
        #endregion

        public void ConditionConstructor() { }

        #region Add to match NetworkConnection.
        /// <summary>
        /// Adds a connection to a match.
        /// </summary>
        /// <param name="match">Match to add conn to.</param>
        /// <param name="conn">Connection to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, NetworkConnection conn, NetworkManager manager = null, bool replaceMatch = false)
        {
            if (replaceMatch)
                RemoveFromMatchWithoutRebuild(conn, manager);

            HashSet<NetworkConnection> results;
            if (!_matchConnections.TryGetValueIL2CPP(match, out results))
            {
                results = new HashSet<NetworkConnection>();
                _matchConnections.Add(match, results);
            }

            bool r = results.Add(conn);
            _connectionMatch[conn] = match;
            if (r)
                FinalizeChange(match, results, manager);
        }
        /// <summary>
        /// Adds connections to a match.
        /// </summary>
        /// <param name="match">Match to add conns to.</param>
        /// <param name="conns">Connections to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, NetworkConnection[] conns, NetworkManager manager = null, bool replaceMatch = false)
        {
            AddToMatch(match, conns.ToList(), manager, replaceMatch);
        }
        /// <summary>
        /// Adds connections to a match.
        /// </summary>
        /// <param name="match">Match to add conns to.</param>
        /// <param name="conns">Connections to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, List<NetworkConnection> conns, NetworkManager manager = null, bool replaceMatch = false)
        {
            if (replaceMatch)
            {
                foreach (NetworkConnection nc in conns)
                    RemoveFromMatchWithoutRebuild(nc, manager);
            }

            HashSet<NetworkConnection> results;
            if (!_matchConnections.TryGetValueIL2CPP(match, out results))
            {
                results = new HashSet<NetworkConnection>();
                _matchConnections.Add(match, results);
            }

            bool r = false;
            for (int i = 0; i < conns.Count; i++)
            {
                NetworkConnection c = conns[i];
                r |= results.Add(c);
                _connectionMatch[c] = match;
            }

            if (r)
                FinalizeChange(match, results, manager);
        }
        #endregion

        #region Add to match NetworkObject.
        /// <summary>
        /// Adds an object to a match.
        /// </summary>
        /// <param name="match">Match to add conn to.</param>
        /// <param name="nob">Connection to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, NetworkObject nob, NetworkManager manager = null, bool replaceMatch = false)
        {
            if (replaceMatch)
                RemoveFromMatchWithoutRebuild(nob, manager);

            HashSet<NetworkObject> results;
            if (!_matchObjects.TryGetValueIL2CPP(match, out results))
            {
                results = new HashSet<NetworkObject>();
                _matchObjects.Add(match, results);
            }

            bool r = results.Add(nob);
            _objectMatch[nob] = match;

            if (r)
                FinalizeChange(match, results, nob, manager);
        }
        /// <summary>
        /// Adds objects to a match.
        /// </summary>
        /// <param name="match">Match to add conns to.</param>
        /// <param name="nobs">Connections to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, NetworkObject[] nobs, NetworkManager manager = null, bool replaceMatch = false)
        {
            AddToMatch(match, nobs.ToList(), manager, replaceMatch);
        }
        /// <summary>
        /// Adds objects to a match.
        /// </summary>
        /// <param name="match">Match to add conns to.</param>
        /// <param name="nobs">Connections to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, List<NetworkObject> nobs, NetworkManager manager = null, bool replaceMatch = false)
        {
            if (replaceMatch)
            {
                foreach (NetworkObject n in nobs)
                    RemoveFromMatchWithoutRebuild(n, manager);
            }

            HashSet<NetworkObject> results;
            if (!_matchObjects.TryGetValueIL2CPP(match, out results))
            {
                results = new HashSet<NetworkObject>();
                _matchObjects.Add(match, results);
            }

            bool r = false;
            for (int i = 0; i < nobs.Count; i++)
            {
                NetworkObject n = nobs[i];
                r |= results.Add(n);
                _objectMatch[n] = match;
            }

            if (r)
                FinalizeChange(match, results, nobs, manager);
        }
        #endregion

        #region Remove from match NetworkConnection.
        /// <summary>
        /// Removes a connection from any match without rebuilding observers.
        /// </summary>
        /// <param name="conn">Connection to remove from matches.</param>
        /// <param name="manager">NetworkManager connection belongs to. This is not currently used.</param>
        internal static bool RemoveFromMatchWithoutRebuild(NetworkConnection conn, NetworkManager manager)
        {
            bool removed = false;
            //If found to be in a match.
            if (_connectionMatch.TryGetValueIL2CPP(conn, out int match))
            {
                //If match is found.
                if (_matchConnections.TryGetValue(match, out HashSet<NetworkConnection> conns))
                {
                    removed |= conns.Remove(conn);
                    //If no more in hashset remove match.
                    if (conns.Count == 0)
                        _matchConnections.Remove(match);
                }
            }

            //Remove from connectionMatch.
            _connectionMatch.Remove(conn);
            return removed;
        }
        /// <summary>
        /// Removes a connection from all matches.
        /// </summary>
        /// <param name="conn">NetworkConnection to remove.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        public static void RemoveFromMatch(NetworkConnection conn, NetworkManager manager)
        {
            bool removed = RemoveFromMatchWithoutRebuild(conn, manager);
            if (removed)
                GetServerObjects(manager).RebuildObservers();
        }
        /// <summary>
        /// Removes a connection from a match.
        /// </summary>
        /// <param name="match">Match to remove conn from.</param>
        /// <param name="conn">Connection to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RemoveFromMatch(int match, NetworkConnection conn, NetworkManager manager)
        {
            if (_matchConnections.TryGetValueIL2CPP(match, out HashSet<NetworkConnection> results))
            {
                bool r = results.Remove(conn);
                _connectionMatch.Remove(conn);
                if (r)
                    FinalizeChange(match, results, manager);
            }
        }
        /// <summary>
        /// Removes connections from a match.
        /// </summary>
        /// <param name="match">Match to remove conns from.</param>
        /// <param name="conns">Connections to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RemoveFromMatch(int match, NetworkConnection[] conns, NetworkManager manager)
        {
            if (_matchConnections.TryGetValueIL2CPP(match, out HashSet<NetworkConnection> results))
            {
                bool r = false;
                for (int i = 0; i < conns.Length; i++)
                {
                    NetworkConnection c = conns[i];
                    r |= results.Remove(c);
                    _connectionMatch.Remove(c);
                }

                if (r)
                    FinalizeChange(match, results, manager);
            }
        }
        /// <summary>
        /// Removes connections from a match.
        /// </summary>
        /// <param name="match">Match to remove conns from.</param>
        /// <param name="conns">Connections to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RemoveFromMatch(int match, List<NetworkConnection> conns, NetworkManager manager)
        {
            if (_matchConnections.TryGetValueIL2CPP(match, out HashSet<NetworkConnection> results))
            {
                bool r = false;
                for (int i = 0; i < conns.Count; i++)
                {
                    NetworkConnection c = conns[i];
                    r |= results.Remove(c);
                    _connectionMatch.Remove(c);
                }

                if (r)
                    FinalizeChange(match, results, manager);
            }
        }
        #endregion

        #region Remove from match NetworkObject.
        /// <summary>
        /// Removes a network object from any match without rebuilding observers.
        /// </summary>
        /// <param name="nob">NetworkObject to remove.</param>
        /// <param name="manager">Manager which the network object belongs to. This value is not yet used.</param>
        internal static bool RemoveFromMatchWithoutRebuild(NetworkObject nob, NetworkManager manager = null)
        {
            bool removed = false;
            //If found to be in a match.
            if (_objectMatch.TryGetValueIL2CPP(nob, out int match))
            {
                //If match is found.
                if (_matchObjects.TryGetValue(match, out HashSet<NetworkObject> nobs))
                {
                    removed |= nobs.Remove(nob);
                    //If no more in hashset remove match.
                    if (nobs.Count == 0)
                        _matchObjects.Remove(match);
                }
            }

            //Remove from connectionMatch.
            _objectMatch.Remove(nob);
            return removed;
        }
        /// <summary>
        /// Removes nob from all matches.
        /// </summary>
        /// <param name="nob">NetworkObject to remove.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        public static void RemoveFromMatch(NetworkObject nob, NetworkManager manager = null)
        {
            bool removed = RemoveFromMatchWithoutRebuild(nob, manager);
            if (removed)
                GetServerObjects(manager).RebuildObservers(nob);
        }
        /// <summary>
        /// Removes a network object from all matches.
        /// </summary>
        /// <param name="nobs">NetworkObjects to remove.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        public static void RemoveFromMatch(NetworkObject[] nobs, NetworkManager manager = null)
        {
            RemoveFromMatch(nobs.ToList(), manager);
        }
        /// <summary>
        /// Removes network objects from all matches.
        /// </summary>
        /// <param name="nobs">NetworkObjects to remove.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        public static void RemoveFromMatch(List<NetworkObject> nobs, NetworkManager manager = null)
        {
            bool removed = false;
            foreach (NetworkObject n in nobs)
                removed |= RemoveFromMatchWithoutRebuild(n, manager);

            if (removed)
                GetServerObjects(manager).RebuildObservers(nobs);
        }
        /// <summary>
        /// Removes a network object from a match.
        /// </summary>
        /// <param name="match">Match to remove conn from.</param>
        /// <param name="nob">NetworkObject to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RemoveFromMatch(int match, NetworkObject nob, NetworkManager manager = null)
        {
            if (_matchObjects.TryGetValueIL2CPP(match, out HashSet<NetworkObject> results))
            {
                bool r = results.Remove(nob);
                _objectMatch.Remove(nob);
                if (r)
                    FinalizeChange(match, results, nob, manager);
            }
        }
        /// <summary>
        /// Removes network objects from a match.
        /// </summary>
        /// <param name="match">Match to remove conns from.</param>
        /// <param name="nobs">NetworkObjects to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RemoveFromMatch(int match, NetworkObject[] nobs, NetworkManager manager = null)
        {
            if (_matchObjects.TryGetValueIL2CPP(match, out HashSet<NetworkObject> results))
            {
                bool r = false;
                for (int i = 0; i < nobs.Length; i++)
                {
                    NetworkObject n = nobs[i];
                    r |= results.Remove(n);
                    _objectMatch.Remove(n);
                }

                if (r)
                    FinalizeChange(match, results, nobs, manager);
            }
        }
        /// <summary>
        /// Removes network objects from a match.
        /// </summary>
        /// <param name="match">Match to remove conns from.</param>
        /// <param name="nobs">NetworkObjects to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RemoveFromMatch(int match, List<NetworkObject> nobs, NetworkManager manager = null)
        {
            if (_matchObjects.TryGetValueIL2CPP(match, out HashSet<NetworkObject> results))
            {
                bool r = false;
                for (int i = 0; i < nobs.Count; i++)
                {
                    NetworkObject n = nobs[i];
                    r |= results.Remove(n);
                    _objectMatch.Remove(n);
                }

                if (r)
                    FinalizeChange(match, results, nobs, manager);
            }
        }
        #endregion

        #region FinalizeChange NetworkConnection.
        /// <summary>
        /// Finalizes changes to observers.
        /// </summary>
        private static void FinalizeChange(int match, HashSet<NetworkConnection> remainingConnsInMatch, NetworkManager manager)
        {
            if (remainingConnsInMatch.Count == 0)
                _matchConnections.Remove(match);

            /* Observers on all objects and all conditions have to be rebuilt.
             * This is because the connection changing matches could
             * require the connection to be visible for other players in the match,
             * as well make other connections in the same match visible.
             * But also make all the objects not associated with connections
             * of that match visible. In result to tick all of those boxes
             * all objects need to be rebuilt for all connections. */
            GetServerObjects(manager).RebuildObservers();
        }
        #endregion

        #region FinalizeChange NetworkObject.
        /// <summary>
        /// Finalizes changes to observers.
        /// </summary>
        private static void FinalizeChange(int match, HashSet<NetworkObject> results, List<NetworkObject> nobs, NetworkManager manager)
        {
            ListCache<NetworkObject> cache = ListCaches.GetNetworkObjectCache();
            cache.AddValues(nobs);
            FinalizeChange(match, results, cache, manager);
            ListCaches.StoreCache(cache);
        }
        /// <summary>
        /// Finalizes changes to observers.
        /// </summary>
        private static void FinalizeChange(int match, HashSet<NetworkObject> results, NetworkObject[] nobs, NetworkManager manager)
        {
            ListCache<NetworkObject> cache = ListCaches.GetNetworkObjectCache();
            cache.AddValues(nobs);
            FinalizeChange(match, results, cache, manager);
            ListCaches.StoreCache(cache);
        }
        /// <summary>
        /// Finalizes changes to observers.
        /// </summary>
        private static void FinalizeChange(int match, HashSet<NetworkObject> results, NetworkObject nob, NetworkManager manager)
        {
            ListCache<NetworkObject> cache = ListCaches.GetNetworkObjectCache();
            cache.AddValue(nob);
            FinalizeChange(match, results, cache, manager);
            ListCaches.StoreCache(cache);
        }
        /// <summary>
        /// Finalizes changes to observers.
        /// </summary>
        private static void FinalizeChange(int match, HashSet<NetworkObject> results, ListCache<NetworkObject> nobs, NetworkManager manager)
        {
            if (results.Count == 0)
                _matchConnections.Remove(match);

            GetServerObjects(manager).RebuildObservers(nobs);
        }
        #endregion

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public override bool ConditionMet(NetworkConnection connection, bool alreadyAdded, out bool notProcessed)
        {
            //If here then checks are being processed.
            notProcessed = false;
            NetworkConnection owner = base.NetworkObject.Owner;
            /* If object is owned then check if owner
            * and connection share a match. */
            if (owner.IsValid)
            {
                //Connection isn't in a match.
                if (!_connectionMatch.TryGetValueIL2CPP(connection, out int match))
                {
                    //Return if this owner is also not in a match.
                    return !_connectionMatch.TryGetValueIL2CPP(owner, out int _);
                }
                //Match isn't found.
                if (!_matchConnections.TryGetValueIL2CPP(match, out HashSet<NetworkConnection> conns))
                    return false;
                //If owner is in same match return true.
                return conns.Contains(owner);
            }
            /* If no owner see if the object is in a match and if so
             * then compare that. */
            else
            {
                //Object isn't in a match.
                if (!_objectMatch.TryGetValueIL2CPP(base.NetworkObject, out int objectMatch))
                    return true;
                /* See if connection is in the same match as the object.
                 * If connection isn't in a match then it fails. */
                if (!_connectionMatch.TryGetValueIL2CPP(connection, out int connectionMatch))
                    return false;
                return (connectionMatch == objectMatch);
            }
        }

        /// <summary>
        /// Returns which ServerObjects to rebuild observers on.
        /// </summary>
        /// <param name="nm"></param>
        /// <returns></returns>
        private static ServerObjects GetServerObjects(NetworkManager manager)
        {
            return (manager == null) ? InstanceFinder.ServerManager.Objects : manager.ServerManager.Objects;
        }

        /* //todo this needs to be passing in the network manager to clear on,
         * otherwise only a single instance of NM is supported.
         * Users are already forced to specify which NM to add
         * matches for but the functionality separating different NMs in relation
         * to such isn't done yet. */
        /// <summary>
        /// Clears all match information without rebuilding.
        /// </summary>
        internal static void ClearMatchesWithoutRebuilding()
        {
            _connectionMatch.Clear();
            _matchConnections.Clear();
            _objectMatch.Clear();
            _matchObjects.Clear();
        }

        /// <summary>
        /// True if the condition requires regular updates.
        /// </summary>
        /// <returns></returns>
        public override bool Timed()
        {
            return false;
        }

        /// <summary>
        /// Clones referenced ObserverCondition. This must be populated with your conditions settings.
        /// </summary>
        /// <returns></returns>
        public override ObserverCondition Clone()
        {
            MatchCondition copy = ScriptableObject.CreateInstance<MatchCondition>();
            copy.ConditionConstructor();
            return copy;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Observing/Conditions/OwnerOnlyCondition.cs ---
﻿using FishNet.Connection;
using FishNet.Observing;
using UnityEngine;

namespace FishNet.Component.Observing
{
    /// <summary>
    /// This condition makes an object only visible to the owner.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Owner Only Condition", fileName = "New Owner Only Condition")]
    public class OwnerOnlyCondition : ObserverCondition
    {

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            notProcessed = false;
            /* Returning false immediately indicates no connection will
             * meet this condition. */
            return false;
        }

        /// <summary>
        /// True if the condition requires regular updates.
        /// </summary>
        /// <returns></returns>
        public override bool Timed()
        {
            return false;
        }

        /// <summary>
        /// Clones referenced ObserverCondition. This must be populated with your conditions settings.
        /// </summary>
        /// <returns></returns>
        public override ObserverCondition Clone()
        {
            OwnerOnlyCondition copy = ScriptableObject.CreateInstance<OwnerOnlyCondition>();
            return copy;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Observing/Conditions/SceneCondition.cs ---
﻿using FishNet.Connection;
using FishNet.Observing;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Component.Observing
{

    /// <summary>
    /// When this observer condition is placed on an object, a client must be within the same scene to view the object.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Scene Condition", fileName = "New Scene Condition")]
    public class SceneCondition : ObserverCondition
    {
        #region Serialized.
        ///// <summary>
        ///// True to synchronize which scene the object was spawned in to clients. When true this object will be moved to the clients equivelant of the scene it was spawned in on the server. This setting does not continously move this object to the same scene.
        ///// </summary>
        //[Tooltip("True to synchronize which scene the object was spawned in to clients. When true this object will be moved to the clients equivelant of the scene it was spawned in on the server. This setting does not continously move this object to the same scene.")]
        //[SerializeField]
        //private bool _synchronizeScene;
        #endregion

        public void ConditionConstructor()
        {
            //_synchronizeScene = synchronizeScene;
        }

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            notProcessed = false;
            /* If this objects connection is valid then check if
             * connection and this objects owner shares any scenes.
             * Don't check if the object resides in the same scene
             * because thats not reliable as server might be moving
             * objects. */
            if (base.NetworkObject.Owner.IsValid)
            {
                foreach (Scene s in base.NetworkObject.Owner.Scenes)
                {
                    //Scenes match.
                    if (connection.Scenes.Contains(s))
                        return true;
                }

                //Fall through, no scenes shared.
                return false;
            }
            /* If there is no owner as a fallback see if
             * the connection is in the same scene as this object. */
            else
            {
                /* When there is no owner only then is the gameobject
                 * scene checked. That's the only way to know at this point. */
                return connection.Scenes.Contains(base.NetworkObject.gameObject.scene);
            }
        }

        /// <summary>
        /// True if the condition requires regular updates.
        /// </summary>
        /// <returns></returns>
        public override bool Timed()
        {
            return false;
        }

        /// <summary>
        /// Clones referenced ObserverCondition. This must be populated with your conditions settings.
        /// </summary>
        /// <returns></returns>
        public override ObserverCondition Clone()
        {
            SceneCondition copy = ScriptableObject.CreateInstance<SceneCondition>();
            //copy.ConditionConstructor(_synchronizeScene);
            copy.ConditionConstructor();
            return copy;
        }

    }
}

'''
'''--- Assets/FishNet/Runtime/Observing/Conditions/ServerOnlyCondition.cs ---
﻿using FishNet.Connection;
using FishNet.Observing;
using System;
using UnityEngine;

namespace FishNet.Component.Observing
{
    /// <summary>
    /// This condition makes an object only visible to the server.
    /// </summary>
    //[CreateAssetMenu(menuName = "FishNet/Observers/Server Only Condition", fileName = "New Server Only Condition")]
    [Obsolete("Use OwnerOnlyCondition instead.")] //Remove on 2023/06/01
    public class ServerOnlyCondition : ObserverCondition
    {

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            notProcessed = false;
            /* Returning false immediately indicates no connection will
             * meet this condition. */
            return false;
        }

        /// <summary>
        /// True if the condition requires regular updates.
        /// </summary>
        /// <returns></returns>
        public override bool Timed()
        {
            return false;
        }

        /// <summary>
        /// Clones referenced ObserverCondition. This must be populated with your conditions settings.
        /// </summary>
        /// <returns></returns>
        public override ObserverCondition Clone()
        {
            ServerOnlyCondition copy = ScriptableObject.CreateInstance<ServerOnlyCondition>();
            return copy;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Observing/HostVisibilityUpdateTypes.cs ---
﻿
namespace FishNet.Observing
{
    [System.Flags]
    public enum HostVisibilityUpdateTypes : byte
    {
        /// <summary>
        /// Include this flag to update manager.
        /// </summary>
        Manager = 1,
        /// <summary>
        /// Include this flag to update spawned.
        /// </summary>
        Spawned = 2,
    }

}

'''
'''--- Assets/FishNet/Runtime/Observing/NetworkObserver.cs ---
﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Object;
using FishNet.Transporting;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Serialization;

namespace FishNet.Observing
{
    /// <summary>
    /// Controls which clients can see and get messages for an object.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Component/NetworkObserver")]
    public sealed class NetworkObserver : MonoBehaviour
    {
        #region Types.
        /// <summary>
        /// How ObserverManager conditions are used.
        /// </summary>
        public enum ConditionOverrideType
        {
            /// <summary>
            /// Keep current conditions, add new conditions from manager.
            /// </summary>
            AddMissing = 1,
            /// <summary>
            /// Replace current conditions with manager conditions.
            /// </summary>
            UseManager = 2,
            /// <summary>
            /// Keep current conditions, ignore manager conditions.
            /// </summary>
            IgnoreManager = 3,
        }
        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("How ObserverManager conditions are used.")]
        [SerializeField]
        private ConditionOverrideType _overrideType = ConditionOverrideType.IgnoreManager;
        /// <summary>
        /// How ObserverManager conditions are used.
        /// </summary>
        public ConditionOverrideType OverrideType
        {
            get => _overrideType;
            internal set => _overrideType = value;
        }

        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to update visibility for clientHost based on if they are an observer or not.")]
        [FormerlySerializedAs("_setHostVisibility")]
        [SerializeField]
        private bool _updateHostVisibility = true;
        /// <summary>
        /// True to update visibility for clientHost based on if they are an observer or not.
        /// </summary>
        public bool UpdateHostVisibility
        {
            get => _updateHostVisibility;
            private set => _updateHostVisibility = value;
        }
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Conditions connections must met to be added as an observer. Multiple conditions may be used.")]
        [SerializeField]
        internal List<ObserverCondition> _observerConditions = new List<ObserverCondition>();
        /// <summary>
        /// Conditions connections must met to be added as an observer. Multiple conditions may be used.
        /// </summary>
        public IReadOnlyList<ObserverCondition> ObserverConditions => _observerConditions;
        [APIExclude]
#if MIRROR
        public List<ObserverCondition> ObserverConditionsInternal
#else
        internal List<ObserverCondition> ObserverConditionsInternal
#endif
        {
            get => _observerConditions;
            set => _observerConditions = value;
        }
        #endregion

        #region Private.
        /// <summary>
        /// Conditions under this component which are timed.
        /// </summary>
        private List<ObserverCondition> _timedConditions = new List<ObserverCondition>();
        /// <summary>
        /// Connections which have all non-timed conditions met.
        /// </summary>
        private HashSet<NetworkConnection> _nonTimedMet = new HashSet<NetworkConnection>();
        /// <summary>
        /// NetworkObject this belongs to.
        /// </summary>
        private NetworkObject _networkObject;
        /// <summary>
        /// Becomes true when registered with ServerObjects as Timed observers.
        /// </summary>
        private bool _registeredAsTimed;
        /// <summary>
        /// True if already pre-initialized.
        /// </summary>
        private bool _preintiialized;
        #endregion

        private void OnEnable()
        {
            if (_networkObject != null && _networkObject.IsServer)
                RegisterTimedConditions();
        }
        private void OnDisable()
        {
            if (_networkObject != null && _networkObject.IsDeinitializing)
                UnregisterTimedConditions();
        }
        private void OnDestroy()
        {
            if (_networkObject != null)
                UnregisterTimedConditions();
        }

        internal void Deinitialize()
        {
            if (_networkObject != null && _networkObject.IsDeinitializing)
            {
                _networkObject.ServerManager.OnRemoteConnectionState -= ServerManager_OnRemoteConnectionState;
                UnregisterTimedConditions();
            }
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="networkManager"></param>
        internal void PreInitialize(NetworkObject networkObject)
        {
            if (!_preintiialized)
            {
                _preintiialized = true;
                _networkObject = networkObject;
                bool ignoringManager = (OverrideType == ConditionOverrideType.IgnoreManager);

                //Check to override SetHostVisibility.
                if (!ignoringManager)
                    UpdateHostVisibility = networkObject.ObserverManager.UpdateHostVisibility;

                bool observerFound = false;
                for (int i = 0; i < _observerConditions.Count; i++)
                {
                    if (_observerConditions[i] != null)
                    {
                        observerFound = true;

                        /* Make an instance of each condition so values are
                         * not overwritten when the condition exist more than
                         * once in the scene. Double edged sword of using scriptable
                         * objects for conditions. */
                        _observerConditions[i] = _observerConditions[i].Clone();
                        ObserverCondition oc = _observerConditions[i];
                        oc.InitializeOnce(_networkObject);
                        //If timed also register as containing timed conditions.
                        if (oc.Timed())
                            _timedConditions.Add(oc);
                    }
                    else
                    {
                        _observerConditions.RemoveAt(i);
                        i--;
                    }
                }

                //No observers specified, do not need to take further action.
                if (!observerFound)
                    return;

                _networkObject.ServerManager.OnRemoteConnectionState += ServerManager_OnRemoteConnectionState;
            }

            RegisterTimedConditions();
        }

        /// <summary>
        /// Returns a condition if found within Conditions.
        /// </summary>
        /// <returns></returns>
        public ObserverCondition GetObserverCondition<T>() where T : ObserverCondition
        {
            /* Do not bother setting local variables,
             * condition collections aren't going to be long
             * enough to make doing so worth while. */

            System.Type conditionType = typeof(T);
            for (int i = 0; i < _observerConditions.Count; i++)
            {
                if (_observerConditions[i].GetType() == conditionType)
                    return _observerConditions[i];
            }

            //Fall through, not found.
            return null;
        }

        /// <summary>
        /// Returns ObserverStateChange by comparing conditions for a connection.
        /// </summary>
        /// <returns>True if added to Observers.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal ObserverStateChange RebuildObservers(NetworkConnection connection, bool timedOnly)
        {
            bool currentlyAdded = (_networkObject.Observers.Contains(connection));
            //True if all conditions are met.
            bool allConditionsMet = true;

            //Only need to check beyond this if conditions exist.
            if (_observerConditions.Count > 0)
            {
                /* If cnnection is owner then they can see the object. */
                bool notOwner = (connection != _networkObject.Owner);

                /* Only check conditions if not owner. Owner will always
                * have visibility. */
                if (notOwner)
                {
                    //True if connection starts with meeting non-timed conditions.
                    bool startNonTimedMet = _nonTimedMet.Contains(connection);

                    /* If a timed update and nonTimed
                     * have not been met then there's
                     * no reason to check timed. */
                    if (timedOnly && !startNonTimedMet)
                    {
                        allConditionsMet = false;
                    }
                    else
                    {
                        //Return as failed if there is a parent nob which doesn't have visibility.
                        if (_networkObject.ParentNetworkObject != null && !_networkObject.ParentNetworkObject.Observers.Contains(connection))
                        {
                            allConditionsMet = false;
                        }
                        else
                        {
                            //Becomes true if a non-timed condition fails.
                            bool nonTimedMet = true;

                            List<ObserverCondition> collection = (timedOnly) ? _timedConditions : _observerConditions;
                            for (int i = 0; i < collection.Count; i++)
                            {
                                ObserverCondition condition = collection[i];
                                /* If any observer returns removed then break
                                 * from loop and return removed. If one observer has
                                 * removed then there's no reason to iterate
                                 * the rest. */
                                bool conditionMet = condition.ConditionMet(connection, currentlyAdded, out bool notProcessed);
                                if (notProcessed)
                                    conditionMet = currentlyAdded;

                                //Condition not met.
                                if (!conditionMet)
                                {
                                    allConditionsMet = false;
                                    if (!condition.Timed())
                                        nonTimedMet = false;
                                    break;
                                }
                            }

                            //If all conditions are being checked and nonTimedMet has updated.
                            if (!timedOnly && (startNonTimedMet != nonTimedMet))
                            {
                                if (nonTimedMet)
                                    _nonTimedMet.Add(connection);
                                else
                                    _nonTimedMet.Remove(connection);
                            }
                        }
                    }
                }
            }

            //If all conditions met.
            if (allConditionsMet)
                return ReturnPassedConditions(currentlyAdded);
            else
                return ReturnFailedCondition(currentlyAdded);
        }

        /// <summary>
        /// Registers timed observer conditions.
        /// </summary>
        private void RegisterTimedConditions()
        {
            if (_timedConditions.Count == 0)
                return;
            //Already registered or no timed conditions.
            if (_registeredAsTimed)
                return;

            _registeredAsTimed = true;
            _networkObject.NetworkManager.ServerManager.Objects.AddTimedNetworkObserver(_networkObject);
        }

        /// <summary>
        /// Unregisters timed conditions.
        /// </summary>
        private void UnregisterTimedConditions()
        {
            if (_timedConditions.Count == 0)
                return;
            if (!_registeredAsTimed)
                return;

            _registeredAsTimed = false;
            _networkObject.NetworkManager.ServerManager.Objects.RemoveTimedNetworkObserver(_networkObject);
        }

        /// <summary>
        /// Returns an ObserverStateChange when a condition fails.
        /// </summary>
        /// <param name="currentlyAdded"></param>
        /// <returns></returns>
        private ObserverStateChange ReturnFailedCondition(bool currentlyAdded)
        {
            if (currentlyAdded)
                return ObserverStateChange.Removed;
            else
                return ObserverStateChange.Unchanged;
        }

        /// <summary>
        /// Returns an ObserverStateChange when all conditions pass.
        /// </summary>
        /// <param name="currentlyAdded"></param>
        /// <returns></returns>
        private ObserverStateChange ReturnPassedConditions(bool currentlyAdded)
        {
            if (currentlyAdded)
                return ObserverStateChange.Unchanged;
            else
                return ObserverStateChange.Added;
        }

        /// <summary>
        /// Called when a remote client state changes with the server.
        /// </summary>
        private void ServerManager_OnRemoteConnectionState(NetworkConnection conn, RemoteConnectionStateArgs arg2)
        {
            if (arg2.ConnectionState == RemoteConnectionState.Stopped)
                _nonTimedMet.Remove(conn);
        }

        /// <summary>
        /// Sets a new value for UpdateHostVisibility.
        /// This does not immediately update renderers.
        /// You may need to combine with NetworkObject.SetRenderersVisible(bool).
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetUpdateHostVisibility(bool value)
        {
            //Unchanged.
            if (value == UpdateHostVisibility)
                return;

            UpdateHostVisibility = value;
        }

    }
}

'''
'''--- Assets/FishNet/Runtime/Observing/ObserverCondition.cs ---
﻿using FishNet.Connection;
using FishNet.Object;
using UnityEngine;

namespace FishNet.Observing
{
    /// <summary>
    /// Condition a connection must meet to be added as an observer.
    /// This class can be inherited from for custom conditions.
    /// </summary>
    public abstract class ObserverCondition : ScriptableObject
    {
        #region Public.
        /// <summary>
        /// NetworkObject this condition is for.
        /// </summary>
        [HideInInspector]
        public NetworkObject NetworkObject;
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="networkObject"></param>
        public virtual void InitializeOnce(NetworkObject networkObject)
        {
            NetworkObject = networkObject;
        }
        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public abstract bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed);
        /// <summary>
        /// True if the condition requires regular updates.
        /// </summary>
        /// <returns></returns>
        public abstract bool Timed();
        /// <summary>
        /// Creates a clone of this condition to be instantiated.
        /// </summary>
        /// <returns></returns>
        public abstract ObserverCondition Clone();

    }
}

'''
'''--- Assets/FishNet/Runtime/Observing/ObserverStateChange.cs ---
﻿namespace FishNet.Observing
{
    /// <summary>
    /// States which observer(s) can change to.
    /// </summary>
    internal enum ObserverStateChange : byte
    {
        Unchanged = 0,
        Added = 1,
        Removed = 2
    }
}
'''
'''--- Assets/FishNet/Runtime/Plugins/ColliderRollback/Attributions.txt ---
﻿Attribution to https://assetstore.unity.com/packages/3d/environments/landscapes/low-poly-simple-nature-pack-162153
"SimpleNaturePack"

Attribution to Kenny.nl
"Weapon Pack"
'''
'''--- Assets/FishNet/Runtime/Plugins/ColliderRollback/LICENSE.txt ---
﻿This software uses the license for Fish-Networking: https://github.com/FirstGearGames/FishNet/blob/main/LICENSE.md
'''
'''--- Assets/FishNet/Runtime/Plugins/ColliderRollback/Scripts/ColliderRollback.cs ---
﻿using FishNet.Object;
using UnityEngine;

namespace FishNet.Component.ColliderRollback
{

    public class ColliderRollback : NetworkBehaviour
    {
        

        #region Serialized.
        /// <summary>
        /// Objects holding colliders which can rollback.
        /// </summary>
        [Tooltip("Objects holding colliders which can rollback.")]
        [SerializeField]
        private GameObject[] _colliderParents = new GameObject[0];
        #endregion

        
    }

}

'''
'''--- Assets/FishNet/Runtime/Plugins/ColliderRollback/Scripts/RollbackManager.cs ---
﻿using FishNet.Managing;
using FishNet.Managing.Timing;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Component.ColliderRollback
{
    public class RollbackManager : MonoBehaviour
    {
        

        

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Maximum time in the past colliders can be rolled back to.")]
        [SerializeField]
        private float _maximumRollbackTime = 1.25f;
        /// <summary>
        /// Maximum time in the past colliders can be rolled back to.
        /// </summary>
        internal float MaximumRollbackTime => _maximumRollbackTime;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Interpolation value for the NetworkTransform or object being rolled back.")]
        [Range(0, 250)]
        [SerializeField]
        internal ushort Interpolation = 2;
        #endregion

        

        

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnceInternal(NetworkManager manager)
        {
            
        }

        
    }

}
'''
'''--- Assets/FishNet/Runtime/Plugins/Yak/CHANGELOG.txt ---
1.0.0
	- Initial release.
'''
'''--- Assets/FishNet/Runtime/Plugins/Yak/Core/ClientSocket.cs ---

'''
'''--- Assets/FishNet/Runtime/Plugins/Yak/Core/CommonSocket.cs ---

'''
'''--- Assets/FishNet/Runtime/Plugins/Yak/Core/LocalPacket.cs ---
﻿
'''
'''--- Assets/FishNet/Runtime/Plugins/Yak/Core/ServerSocket.cs ---

'''
'''--- Assets/FishNet/Runtime/Plugins/Yak/VERSION.txt ---
1.0.0
'''
'''--- Assets/FishNet/Runtime/Plugins/Yak/Yak.cs ---

'''
'''--- Assets/FishNet/Runtime/Serializing/AutoPackType.cs ---
namespace FishNet.Serializing
{
    /// <summary>
    /// How to pack data when using serialization.
    /// </summary>
    public enum AutoPackType
    {
        /// <summary>
        /// Data will not be compressed.
        /// </summary>
        Unpacked = 0,
        /// <summary>
        /// Data will be compressed to use the least amount of data possible.
        /// </summary>
        Packed = 1,
        /// <summary>
        /// Data will be compressed but not as much as Packed.
        /// </summary>
        PackedLess = 2
    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/Helping/Attributes.cs ---
﻿using FishNet.Utility.Constant;
using System;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.Serializing.Helping
{
    internal class CodegenMakePublicAttribute : Attribute { }
    public class CodegenExcludeAttribute : Attribute { }
    internal class CodegenIncludeInternalAttribute : Attribute { }

}
'''
'''--- Assets/FishNet/Runtime/Serializing/Helping/Broadcasts.cs ---
﻿using FishNet.Object.Helping;
using FishNet.Transporting;

namespace FishNet.Serializing.Helping
{

    internal static class Broadcasts
    {
        /// <summary>
        /// Writes a broadcast to writer.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="writer"></param>
        /// <param name="message"></param>
        /// <param name="channel"></param>
        /// <returns></returns>
        internal static PooledWriter WriteBroadcast<T>(PooledWriter writer, T message, Channel channel)
        {
            writer.WritePacketId(PacketId.Broadcast);
            writer.WriteUInt16(typeof(T).FullName.GetStableHash16()); //muchlater codegen this to pass in hash. use technique similar to rpcs to limit byte/shorts.            
            //Write data to a new writer.
            PooledWriter dataWriter = WriterPool.GetWriter();
            dataWriter.Write<T>(message);
            //Write length of data.
            writer.WriteLength(dataWriter.Length);
            //Write data.
            writer.WriteArraySegment(dataWriter.GetArraySegment());
            dataWriter.Dispose();

            return writer;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Serializing/Helping/Comparers.cs ---
﻿using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Serializing.Helping
{

    public class Comparers
    {
        /// <summary>
        /// Returns if A equals B using EqualityCompare.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool EqualityCompare<T>(T a, T b)
        {
            return (EqualityComparer<T>.Default.Equals(a, b));
        }

        public static bool IsDefault<T>(T t)
        {
            return t.Equals(default(T));
        }

    }

    internal class SceneComparer : IEqualityComparer<Scene>
    {
        public bool Equals(Scene a, Scene b)
        {
            if (!a.IsValid() || !b.IsValid())
                return false;

            if (a.handle != 0 || b.handle != 0)
                return (a.handle == b.handle);

            return (a.name == b.name);
        }

        public int GetHashCode(Scene obj)
        {
            return obj.GetHashCode();
        }
    }

}

'''
'''--- Assets/FishNet/Runtime/Serializing/Helping/Quaternion32.cs ---
﻿
using System;
using UnityEngine;

namespace FishNet.Serializing.Helping
{
    public static class Quaternion32Compression
    {
        private const float Maximum = +1.0f / 1.414214f;

        private const int BitsPerAxis = 10;
        private const int LargestComponentShift = BitsPerAxis * 3;
        private const int AShift = BitsPerAxis * 2;
        private const int BShift = BitsPerAxis * 1;
        private const int IntScale = (1 << (BitsPerAxis - 1)) - 1;
        private const int IntMask = (1 << BitsPerAxis) - 1;

        public static uint Compress(Quaternion quaternion)
        {
            float absX = Mathf.Abs(quaternion.x);
            float absY = Mathf.Abs(quaternion.y);
            float absZ = Mathf.Abs(quaternion.z);
            float absW = Mathf.Abs(quaternion.w);

            ComponentType largestComponent = ComponentType.X;
            float largestAbs = absX;
            float largest = quaternion.x;
            
            if (absY > largestAbs)
            {
                largestAbs = absY;
                largestComponent = ComponentType.Y;
                largest = quaternion.y;
            }
            if (absZ > largestAbs)
            {
                largestAbs = absZ;
                largestComponent = ComponentType.Z;
                largest = quaternion.z;
            }
            if (absW > largestAbs)
            {
                largestComponent = ComponentType.W;
                largest = quaternion.w;
            }

            float a = 0;
            float b = 0;
            float c = 0;
            switch (largestComponent)
            {
                case ComponentType.X:
                    a = quaternion.y;
                    b = quaternion.z;
                    c = quaternion.w;
                    break;
                case ComponentType.Y:
                    a = quaternion.x;
                    b = quaternion.z;
                    c = quaternion.w;
                    break;
                case ComponentType.Z:
                    a = quaternion.x;
                    b = quaternion.y;
                    c = quaternion.w;
                    break;
                case ComponentType.W:
                    a = quaternion.x;
                    b = quaternion.y;
                    c = quaternion.z;
                    break;
            }

            if (largest < 0)
            {
                a = -a;
                b = -b;
                c = -c;
            }

            uint integerA = ScaleToUint(a);
            uint integerB = ScaleToUint(b);
            uint integerC = ScaleToUint(c);

            return (((uint)largestComponent) << LargestComponentShift) | (integerA << AShift) | (integerB << BShift) | integerC;
        }

        private static uint ScaleToUint(float v)
        {
            float normalized = v / Maximum;
            return (uint)Mathf.RoundToInt(normalized * IntScale) & IntMask;
        }

        private static float ScaleToFloat(uint v)
        {
            float unscaled = v * Maximum / IntScale;

            if (unscaled > Maximum)
                unscaled -= Maximum * 2;
            return unscaled;
        }

        public static Quaternion Decompress(uint compressed)
        {
            var largestComponentType = (ComponentType)(compressed >> LargestComponentShift);
            uint integerA = (compressed >> AShift) & IntMask;
            uint integerB = (compressed >> BShift) & IntMask;
            uint integerC = compressed & IntMask;

            float a = ScaleToFloat(integerA);
            float b = ScaleToFloat(integerB);
            float c = ScaleToFloat(integerC);

            Quaternion rotation;
            switch (largestComponentType)
            {
                case ComponentType.X:
                    // (?) y z w
                    rotation.y = a;
                    rotation.z = b;
                    rotation.w = c;
                    rotation.x = Mathf.Sqrt(1 - rotation.y * rotation.y
                                               - rotation.z * rotation.z
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.Y:
                    // x (?) z w
                    rotation.x = a;
                    rotation.z = b;
                    rotation.w = c;
                    rotation.y = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.z * rotation.z
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.Z:
                    // x y (?) w
                    rotation.x = a;
                    rotation.y = b;
                    rotation.w = c;
                    rotation.z = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.y * rotation.y
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.W:
                    // x y z (?)
                    rotation.x = a;
                    rotation.y = b;
                    rotation.z = c;
                    rotation.w = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.y * rotation.y
                                               - rotation.z * rotation.z);
                    break;
                default:
                    // Should never happen!
                    throw new ArgumentOutOfRangeException("Unknown rotation component type: " +
                                                          largestComponentType);
            }

            return rotation;
        }

    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/Helping/Quaternion64.cs ---
﻿
using System;
using UnityEngine;

namespace FishNet.Serializing.Helping
{
    /// <summary>
    /// Credit to https://github.com/viliwonka
    /// https://github.com/FirstGearGames/FishNet/pull/23
    /// </summary>
    public static class Quaternion64Compression
    {
        // 64 bit quaternion compression
        // [4 bits] largest component
        // [21 bits] higher res  
        // [21 bits] higher res
        // [20 bits] higher res
        // sum is 64 bits
        private const float Maximum = +1.0f / 1.414214f;
        private const int BitsPerAxis_H = 21; // higher res, 21 bits
        private const int BitsPerAxis_L = 20; // lower res, 20 bits
        private const int LargestComponentShift = BitsPerAxis_H * 2 + BitsPerAxis_L * 1;
        private const int AShift = BitsPerAxis_H + BitsPerAxis_L;
        private const int BShift = BitsPerAxis_L;
        private const int IntScale_H = (1 << (BitsPerAxis_H - 1)) - 1;
        private const int IntMask_H = (1 << BitsPerAxis_H) - 1;
        private const int IntScale_L = (1 << (BitsPerAxis_L - 1)) - 1;
        private const int IntMask_L = (1 << BitsPerAxis_L) - 1;

        public static ulong Compress(Quaternion quaternion)
        {
            float absX = Mathf.Abs(quaternion.x);
            float absY = Mathf.Abs(quaternion.y);
            float absZ = Mathf.Abs(quaternion.z);
            float absW = Mathf.Abs(quaternion.w);

            ComponentType largestComponent = ComponentType.X;
            float largestAbs = absX;
            float largest = quaternion.x;

            if (absY > largestAbs)
            {
                largestAbs = absY;
                largestComponent = ComponentType.Y;
                largest = quaternion.y;
            }
            if (absZ > largestAbs)
            {
                largestAbs = absZ;
                largestComponent = ComponentType.Z;
                largest = quaternion.z;
            }
            if (absW > largestAbs)
            {
                largestComponent = ComponentType.W;
                largest = quaternion.w;
            }

            float a = 0;
            float b = 0;
            float c = 0;

            switch (largestComponent)
            {
                case ComponentType.X:
                    a = quaternion.y;
                    b = quaternion.z;
                    c = quaternion.w;
                    break;
                case ComponentType.Y:
                    a = quaternion.x;
                    b = quaternion.z;
                    c = quaternion.w;
                    break;
                case ComponentType.Z:
                    a = quaternion.x;
                    b = quaternion.y;
                    c = quaternion.w;
                    break;
                case ComponentType.W:
                    a = quaternion.x;
                    b = quaternion.y;
                    c = quaternion.z;
                    break;
            }

            if (largest < 0)
            {
                a = -a;
                b = -b;
                c = -c;
            }

            ulong integerA = ScaleToUint_H(a);
            ulong integerB = ScaleToUint_H(b);
            ulong integerC = ScaleToUint_L(c);

            return (((ulong)largestComponent) << LargestComponentShift) | (integerA << AShift) | (integerB << BShift) | integerC;
        }

        private static ulong ScaleToUint_H(float v)
        {
            float normalized = v / Maximum;
            return (ulong)Mathf.RoundToInt(normalized * IntScale_H) & IntMask_H;
        }

        private static ulong ScaleToUint_L(float v)
        {
            float normalized = v / Maximum;
            return (ulong)Mathf.RoundToInt(normalized * IntScale_L) & IntMask_L;
        }

        private static float ScaleToFloat_H(ulong v)
        {
            float unscaled = v * Maximum / IntScale_H;

            if (unscaled > Maximum)
                unscaled -= Maximum * 2;
            return unscaled;
        }

        private static float ScaleToFloat_L(ulong v)
        {
            float unscaled = v * Maximum / IntScale_L;

            if (unscaled > Maximum)
                unscaled -= Maximum * 2;
            return unscaled;
        }

        public static Quaternion Decompress(ulong compressed)
        {
            var largestComponentType = (ComponentType)(compressed >> LargestComponentShift);
            ulong integerA = (compressed >> AShift) & IntMask_H;
            ulong integerB = (compressed >> BShift) & IntMask_H;
            ulong integerC = compressed & IntMask_L;

            float a = ScaleToFloat_H(integerA);
            float b = ScaleToFloat_H(integerB);
            float c = ScaleToFloat_L(integerC);

            Quaternion rotation;
            switch (largestComponentType)
            {
                case ComponentType.X:
                    // (?) y z w
                    rotation.y = a;
                    rotation.z = b;
                    rotation.w = c;
                    rotation.x = Mathf.Sqrt(1 - rotation.y * rotation.y
                                               - rotation.z * rotation.z
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.Y:
                    // x (?) z w
                    rotation.x = a;
                    rotation.z = b;
                    rotation.w = c;
                    rotation.y = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.z * rotation.z
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.Z:
                    // x y (?) w
                    rotation.x = a;
                    rotation.y = b;
                    rotation.w = c;
                    rotation.z = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.y * rotation.y
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.W:
                    // x y z (?)
                    rotation.x = a;
                    rotation.y = b;
                    rotation.z = c;
                    rotation.w = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.y * rotation.y
                                               - rotation.z * rotation.z);
                    break;
                default:
                    // Should never happen!
                    throw new ArgumentOutOfRangeException("Unknown rotation component type: " +
                                                          largestComponentType);
            }

            return rotation;
        }

    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/Helping/QuaternionConverter.cs ---
﻿
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using UnityEngine;

namespace FishNet.Serializing.Helping
{
    /// <summary>
    /// Static class used for fast conversion of quaternion structs. Not thread safe!
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public struct QuaternionConverter
    {
        //    [FieldOffset(0)]
        //    public Quaternion Q;
        //    [FieldOffset(0)]
        //    public Quaternion64 Q64;
        //    [FieldOffset(0)]
        //    public Quaternion128 Q128;

        //    public static QuaternionConverter StaticRef = new QuaternionConverter();

        //    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        //    public static Quaternion64 QtoQ64(Quaternion quaternion64)
        //    {
        //        StaticRef.Q = quaternion64;
        //        return StaticRef.Q64;
        //    }

        //    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        //    public static Quaternion Q64toQ(Quaternion64 quaternion)
        //    {
        //        StaticRef.Q64 = quaternion;
        //        return StaticRef.Q;
        //    }

        //    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        //    public static Quaternion128 QtoQ128(Quaternion quaternion128)
        //    {
        //        StaticRef.Q = quaternion128;
        //        return StaticRef.Q128;
        //    }

        //    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        //    public static Quaternion Q128toQ(Quaternion128 quaternion)
        //    {
        //        StaticRef.Q128 = quaternion;
        //        return StaticRef.Q;
        //    }
        //}

        //public struct Quaternion64
        //{
        //    public float x;
        //    public float y;
        //    public float z;
        //    public float w;

        //    public Quaternion64(float x, float y, float z, float w)
        //    {
        //        this.x = x;
        //        this.y = y;
        //        this.z = z;
        //        this.w = w;
        //    }

        //    public Quaternion64(Quaternion q)
        //    {
        //        this.x = q.x;
        //        this.y = q.y;
        //        this.z = q.z;
        //        this.w = q.w;
        //    }

        //    /*[MethodImpl(MethodImplOptions.AggressiveInlining)]
        //    public static implicit operator Quaternion64(Quaternion q) => new Quaternion64(q);

        //    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        //    public static implicit operator Quaternion(Quaternion64 q) => new Quaternion(q.x, q.y, q.z, q.w);*/
        //}

        //public struct Quaternion128
        //{
        //    public float x;
        //    public float y;
        //    public float z;
        //    public float w;
        //    public Quaternion128(float x, float y, float z, float w)
        //    {
        //        this.x = x;
        //        this.y = y;
        //        this.z = z;
        //        this.w = w;
        //    }

        //    public Quaternion128(Quaternion q)
        //    {
        //        x = q.x;
        //        y = q.y;
        //        z = q.z;
        //        w = q.w;
        //    }

        //    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        //    public static implicit operator Quaternion128(Quaternion q) => new Quaternion128(q);

        //    [MethodImpl(MethodImplOptions.AggressiveInlining)]
        //    public static implicit operator Quaternion(Quaternion128 q) => new Quaternion(q.x, q.y, q.z, q.w);
        //}

        /// <summary>
        ///     Credit to this man for converting gaffer games c code to c#
        ///     https://gist.github.com/fversnel/0497ad7ab3b81e0dc1dd
        /// </summary>
    }

    public enum ComponentType : uint
    {
        X = 0,
        Y = 1,
        Z = 2,
        W = 3
    }

}
'''
'''--- Assets/FishNet/Runtime/Serializing/Helping/ValueConversions.cs ---
﻿using System.Runtime.InteropServices;

namespace FishNet.Serializing.Helping
{

    // -- helpers for float conversion without allocations --
    [StructLayout(LayoutKind.Explicit)]
    internal struct UIntFloat
    {
        [FieldOffset(0)]
        public float FloatValue;

        [FieldOffset(0)]
        public uint UIntValue;
    }

    [StructLayout(LayoutKind.Explicit)]
    internal struct UIntDouble
    {
        [FieldOffset(0)]
        public double DoubleValue;

        [FieldOffset(0)]
        public ulong LongValue;
    }

    [StructLayout(LayoutKind.Explicit)]
    internal struct UIntDecimal
    {
        [FieldOffset(0)]
        public ulong LongValue1;

        [FieldOffset(8)]
        public ulong LongValue2;

        [FieldOffset(0)]
        public decimal DecimalValue;
    }

}

'''
'''--- Assets/FishNet/Runtime/Serializing/Reader.cs ---
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Object;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility.Constant;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using UnityEngine;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
//Required for internal tests.
[assembly: InternalsVisibleTo(UtilityConstants.TEST_ASSEMBLY_NAME)]
namespace FishNet.Serializing
{
    /// <summary>
    /// Used for read references to generic types.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    [APIExclude]
    public static class GenericReader<T>
    {
        public static Func<Reader, T> Read { internal get; set; }
        public static Func<Reader, AutoPackType, T> ReadAutoPack { internal get; set; }
    }

    /// <summary>
    /// Reads data from a buffer.
    /// </summary>
    public class Reader
    {
        #region Public.
        /// <summary>
        /// Capacity of the buffer.
        /// </summary>
        public int Capacity => _buffer.Length;
        /// <summary>
        /// NetworkManager for this reader. Used to lookup objects.
        /// </summary>
        public NetworkManager NetworkManager;
        /// <summary>
        /// Offset within the buffer when the reader was created.
        /// </summary>
        public int Offset { get; private set; }
        /// <summary>
        /// Position for the next read.
        /// </summary>
        public int Position;
        /// <summary>
        /// Total number of bytes available within the buffer.
        /// </summary>
        public int Length { get; private set; }
        /// <summary>
        /// Bytes remaining to be read. This value is Length - Position.
        /// </summary>
        public int Remaining => ((Length + Offset) - Position);
        #endregion

        #region Internal.
#if UNITY_EDITOR || DEVELOPMENT_BUILD
        /// <summary>
        /// Last NetworkObject parsed.
        /// </summary>
        public static NetworkObject LastNetworkObject { get; private set; }
        /// <summary>
        /// Last NetworkBehaviour parsed. 
        /// </summary>
        public static NetworkBehaviour LastNetworkBehaviour { get; private set; }
#endif
        #endregion

        #region Private.
        /// <summary>
        /// Data being read.
        /// </summary>
        private byte[] _buffer;
        #endregion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Reader(byte[] bytes, NetworkManager networkManager)
        {
            Initialize(bytes, networkManager);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Reader(ArraySegment<byte> segment, NetworkManager networkManager)
        {
            Initialize(segment, networkManager);
        }

        /// <summary>
        /// Outputs reader to string.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return $"Position: {Position}, Length: {Length}, Buffer: {BitConverter.ToString(_buffer, Offset, Length)}.";
        }

        /// <summary>
        /// Initializes this reader with data.
        /// </summary>
        /// <param name="bytes"></param>
        /// <param name="networkManager"></param>
        internal void Initialize(ArraySegment<byte> bytes, NetworkManager networkManager)
        {
            if (bytes.Array == null)
            {
                if (_buffer == null)
                    _buffer = new byte[0];
            }
            else
            {
                _buffer = bytes.Array;
            }

            Position = bytes.Offset;
            Offset = bytes.Offset;
            Length = bytes.Count;
            NetworkManager = networkManager;
        }
        /// <summary>
        /// Initializes this reader with data.
        /// </summary>
        /// <param name="bytes"></param>
        /// <param name="networkManager"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void Initialize(byte[] bytes, NetworkManager networkManager)
        {
            Initialize(new ArraySegment<byte>(bytes), networkManager);
        }

        /// <summary>
        /// Writes a dictionary.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Dictionary<TKey, TValue> ReadDictionary<TKey, TValue>()
        {
            bool isNull = ReadBoolean();
            if (isNull)
                return null;

            int count = ReadInt32();

            Dictionary<TKey, TValue> result = new Dictionary<TKey, TValue>(count);
            for (int i = 0; i < count; i++)
            {
                TKey key = Read<TKey>();
                TValue value = Read<TValue>();
                result.Add(key, value);
            }

            return result;
        }

        /// <summary>
        /// Reads length. This method is used to make debugging easier.
        /// </summary>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal int ReadLength()
        {
            return ReadInt32();
        }

        /// <summary>
        /// Reads a packetId.
        /// </summary>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal PacketId ReadPacketId()
        {
            return (PacketId)ReadUInt16();
        }

        /// <summary>
        /// Returns a ushort without advancing the reader.
        /// </summary>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal PacketId PeekPacketId()
        {
            int currentPosition = Position;
            PacketId result = ReadPacketId();
            Position = currentPosition;
            return result;
        }

        /// <summary>
        /// Skips a number of bytes in the reader.
        /// </summary>
        /// <param name="value">Number of bytes to skip.</param>
        [CodegenExclude]
        public void Skip(int value)
        {
            if (value < 1 || Remaining < value)
                return;

            Position += value;
        }

        /// <summary>
        /// Returns the buffer as an ArraySegment.
        /// </summary>
        /// <returns></returns>
        public ArraySegment<byte> GetArraySegmentBuffer()
        {
            return new ArraySegment<byte>(_buffer, Offset, Length);
        }
        /// <summary>
        /// Returns the buffer as bytes. This does not trim excessive bytes.
        /// </summary>
        /// <returns></returns>
        public byte[] GetByteBuffer()
        {
            return _buffer;
        }
        /// <summary>
        /// Returns the buffer as bytes and allocates into a new array.
        /// </summary>
        /// <returns></returns>
        public byte[] GetByteBufferAllocated()
        {
            byte[] result = new byte[Length];
            Buffer.BlockCopy(_buffer, Offset, result, 0, Length);
            return result;
        }
        /// <summary>
        /// BlockCopies data from the reader to target and advances reader.
        /// </summary>
        /// <param name="target"></param>
        /// <param name="targetOffset"></param>
        /// <param name="count"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlockCopy(ref byte[] target, int targetOffset, int count)
        {
            Buffer.BlockCopy(_buffer, Position, target, targetOffset, count);
            Position += count;
        }

        /// <summary>
        /// Reads a byte.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte ReadByte()
        {
            byte r = _buffer[Position];
            Position += 1;
            return r;
        }

        /// <summary>
        /// Read bytes from position into target.
        /// </summary>
        /// <param name="buffer">Buffer to read bytes into.</param>
        /// <param name="count">Number of bytes to read.</param>
        [CodegenExclude]
        public void ReadBytes(ref byte[] buffer, int count)
        {
            if (buffer == null)
                throw new EndOfStreamException($"Target is null.");
            //Target isn't large enough.
            if (count > buffer.Length)
                throw new EndOfStreamException($"Count of {count} exceeds target length of {buffer.Length}.");

            BlockCopy(ref buffer, 0, count);
        }

        /// <summary>
        /// Creates an ArraySegment by reading a number of bytes from position.
        /// </summary>
        /// <param name="count"></param>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ArraySegment<byte> ReadArraySegment(int count)
        {
            ArraySegment<byte> result = new ArraySegment<byte>(_buffer, Position, count);
            Position += count;
            return result;
        }

        /// <summary>
        /// Reads a sbyte.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public sbyte ReadSByte()
        {
            return (sbyte)ReadByte();
        }

        /// <summary>
        /// Reads a char.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public char ReadChar() => (char)ReadUInt16();

        /// <summary>
        /// Reads a boolean.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ReadBoolean()
        {
            byte result = ReadByte();
            return (result == 1) ? true : false;
        }

        /// <summary>
        /// Reads an int16.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ushort ReadUInt16()
        {
            ushort result = 0;
            result |= _buffer[Position++];
            result |= (ushort)(_buffer[Position++] << 8);

            return result;
        }

        /// <summary>
        /// Reads a uint16.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public short ReadInt16() => (short)ReadUInt16();

        /// <summary>
        /// Reads an int32.
        /// </summary>
        /// <returns></returns> 
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadUInt32(AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Packed)
                return (uint)ReadPackedWhole();

            uint result = 0;
            result |= _buffer[Position++];
            result |= (uint)_buffer[Position++] << 8;
            result |= (uint)_buffer[Position++] << 16;
            result |= (uint)_buffer[Position++] << 24;

            return result;
        }
        /// <summary>
        /// Reads a uint32.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ReadInt32(AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Packed)
                return (int)(long)ZigZagDecode(ReadPackedWhole());

            return (int)ReadUInt32(packType);
        }

        /// <summary>
        /// Reads a uint64.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public long ReadInt64(AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Packed)
                return (long)ZigZagDecode(ReadPackedWhole());

            return (long)ReadUInt64(packType);
        }

        /// <summary>
        /// Reads an int64.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ulong ReadUInt64(AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Packed)
                return (ulong)ReadPackedWhole();

            ulong result = 0;
            result |= _buffer[Position++];
            result |= (ulong)_buffer[Position++] << 8;
            result |= (ulong)_buffer[Position++] << 16;
            result |= (ulong)_buffer[Position++] << 24;
            result |= (ulong)_buffer[Position++] << 32;
            result |= (ulong)_buffer[Position++] << 40;
            result |= (ulong)_buffer[Position++] << 48;
            result |= (ulong)_buffer[Position++] << 56;

            return result;
        }

        /// <summary>
        /// Reads a single.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float ReadSingle(AutoPackType packType = AutoPackType.Unpacked)
        {
            if (packType == AutoPackType.Unpacked)
            {
                UIntFloat converter = new UIntFloat();
                converter.UIntValue = ReadUInt32(AutoPackType.Unpacked);
                return converter.FloatValue;
            }
            else
            {
                long converter = (long)ReadPackedWhole();
                return (float)(converter / 100f);
            }
        }

        /// <summary>
        /// Reads a double.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double ReadDouble()
        {
            UIntDouble converter = new UIntDouble();
            converter.LongValue = ReadUInt64(AutoPackType.Unpacked);
            return converter.DoubleValue;
        }

        /// <summary>
        /// Reads a decimal.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public decimal ReadDecimal()
        {
            UIntDecimal converter = new UIntDecimal();
            converter.LongValue1 = ReadUInt64(AutoPackType.Unpacked);
            converter.LongValue2 = ReadUInt64(AutoPackType.Unpacked);
            return converter.DecimalValue;
        }

        /// <summary>
        /// Reads a string.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ReadString()
        {
            int size = ReadInt32();
            //Null string.
            if (size == -1)
                return null;
            else if (size == 0)
                return string.Empty;

            if (!CheckAllocationAttack(size))
                return string.Empty;
            ArraySegment<byte> data = ReadArraySegment(size);
            return ReaderStatics.GetString(data);
        }

        /// <summary>
        /// Creates a byte array and reads bytes and size into it.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte[] ReadBytesAndSizeAllocated()
        {
            int size = ReadInt32();
            if (size == -1)
                return null;
            else
                return ReadBytesAllocated(size);
        }

        /// <summary>
        /// Reads bytes and size and copies results into target. Returns -1 if null was written.
        /// </summary>
        /// <returns>Bytes read.</returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ReadBytesAndSize(ref byte[] target)
        {
            int size = ReadInt32();
            if (size > 0)
                ReadBytes(ref target, size);

            return size;
        }

        /// <summary>
        /// Reads bytes and size and returns as an ArraySegment.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ArraySegment<byte> ReadArraySegmentAndSize()
        {
            int size = ReadInt32();
            /* -1 would be written for null. But since
             * ArraySegments cannot be null return default if
             * length is 0 or less. */
            if (size <= 0)
                return default;

            return ReadArraySegment(size);
        }

        /// <summary>
        /// Reads a Vector2.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 ReadVector2()
        {
            return new Vector2(ReadSingle(), ReadSingle());
        }

        /// <summary>
        /// Reads a Vector3.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector3 ReadVector3()
        {
            return new Vector3(ReadSingle(), ReadSingle(), ReadSingle());
        }

        /// <summary>
        /// Reads a Vector4.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector4 ReadVector4()
        {
            return new Vector4(ReadSingle(), ReadSingle(), ReadSingle(), ReadSingle());
        }

        /// <summary>
        /// Reads a Vector2Int.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2Int ReadVector2Int(AutoPackType packType = AutoPackType.Packed)
        {
            return new Vector2Int(ReadInt32(packType), ReadInt32(packType));
        }

        /// <summary>
        /// Reads a Vector3Int.
        /// </summary>
        /// <returns></returns>      
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector3Int ReadVector3Int(AutoPackType packType = AutoPackType.Packed)
        {
            return new Vector3Int(ReadInt32(packType), ReadInt32(packType), ReadInt32(packType));
        }

        /// <summary>
        /// Reads a color.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Color ReadColor(AutoPackType packType = AutoPackType.Packed)
        {
            float r, g, b, a;
            if (packType == AutoPackType.Unpacked)
            {
                r = ReadSingle();
                g = ReadSingle();
                b = ReadSingle();
                a = ReadSingle();
            }
            else
            {
                r = (float)(ReadByte() / 100f);
                g = (float)(ReadByte() / 100f);
                b = (float)(ReadByte() / 100f);
                a = (float)(ReadByte() / 100f);
            }
            return new Color(r, g, b, a);
        }

        /// <summary>
        /// Reads a Color32.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Color32 ReadColor32()
        {
            return new Color32(ReadByte(), ReadByte(), ReadByte(), ReadByte());
        }

        /// <summary>
        /// Reads a Quaternion.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Quaternion ReadQuaternion(AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Packed)
            {
                uint result = ReadUInt32(AutoPackType.Unpacked);
                return Quaternion32Compression.Decompress(result);
            }
            else if (packType == AutoPackType.PackedLess)
            {
                ulong result = ReadUInt64(AutoPackType.Unpacked);
                return Quaternion64Compression.Decompress(result);
            }
            else
            {
                return new Quaternion(
                    ReadSingle(), ReadSingle(), ReadSingle(), ReadSingle()
                    );
            }
        }

        /// <summary>
        /// Reads a Rect.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Rect ReadRect()
        {
            return new Rect(ReadSingle(), ReadSingle(), ReadSingle(), ReadSingle());
        }

        /// <summary>
        /// Plane.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Plane ReadPlane()
        {
            return new Plane(ReadVector3(), ReadSingle());
        }

        /// <summary>
        /// Reads a Ray.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Ray ReadRay()
        {
            Vector3 position = ReadVector3();
            Vector3 direction = ReadVector3();
            return new Ray(position, direction);
        }

        /// <summary>
        /// Reads a Ray.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Ray2D ReadRay2D()
        {
            Vector3 position = ReadVector2();
            Vector2 direction = ReadVector2();
            return new Ray2D(position, direction);
        }

        /// <summary>
        /// Reads a Matrix4x4.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Matrix4x4 ReadMatrix4x4()
        {
            Matrix4x4 result = new Matrix4x4
            {
                m00 = ReadSingle(),
                m01 = ReadSingle(),
                m02 = ReadSingle(),
                m03 = ReadSingle(),
                m10 = ReadSingle(),
                m11 = ReadSingle(),
                m12 = ReadSingle(),
                m13 = ReadSingle(),
                m20 = ReadSingle(),
                m21 = ReadSingle(),
                m22 = ReadSingle(),
                m23 = ReadSingle(),
                m30 = ReadSingle(),
                m31 = ReadSingle(),
                m32 = ReadSingle(),
                m33 = ReadSingle()
            };

            return result;
        }

        /// <summary>
        /// Creates a new byte array and reads bytes into it.
        /// </summary>
        /// <param name="count"></param>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte[] ReadBytesAllocated(int count)
        {
            byte[] bytes = new byte[count];
            ReadBytes(ref bytes, count);
            return bytes;
        }

        /// <summary>
        /// Reads a Guid.
        /// </summary>
        /// <returns></returns>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public System.Guid ReadGuid()
        {
            byte[] buffer = ReaderStatics.GetGuidBuffer();
            ReadBytes(ref buffer, 16);
            return new System.Guid(buffer);
        }

        /// <summary>
        /// Reads a GameObject.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public GameObject ReadGameObject()
        {
            NetworkObject nob = ReadNetworkObject();
            return (nob == null) ? null : nob.gameObject;
        }

        /// <summary>
        /// Reads a Transform.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Transform ReadTransform()
        {
            NetworkObject nob = ReadNetworkObject();
            return (nob == null) ? null : nob.transform;
        }

        /// <summary>
        /// Reads a NetworkObject.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public NetworkObject ReadNetworkObject()
        {
            return ReadNetworkObject(out _);
        }

        /// <summary>
        /// Reads a NetworkObject.
        /// </summary>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public NetworkObject ReadNetworkObject(out int objectOrPrefabId)
        {
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            LastNetworkBehaviour = null;
#endif
            bool isSpawned = ReadBoolean();
            objectOrPrefabId = ReadInt16();
            /* -1 indicates that the object
             * is null or no PrefabId is set.
             * PrefabIds are set in Awake within
             * the NetworkManager so that should
             * never happen so long as nob isn't null. */
            if (objectOrPrefabId == -1)
                return null;

            bool isServer = NetworkManager.ServerManager.Started;
            bool isClient = NetworkManager.ClientManager.Started;

            NetworkObject result;
            //Is spawned.
            if (isSpawned)
            {
                result = null;
                /* Try to get the object client side first if client
                 * is running. When acting as a host generally the object
                 * will be available in the server and client list
                 * but there can be occasions where the server side
                 * deinitializes the object, making it unavailable, while
                 * it is still available in the client side. Since FishNet doesn't
                 * use a fake host connection like some lesser solutions the client
                 * has to always be treated as it's own entity. */
                if (isClient)
                    NetworkManager.ClientManager.Objects.Spawned.TryGetValueIL2CPP(objectOrPrefabId, out result);
                //If not found on client and server is running then try server.
                if (result == null && isServer)
                    NetworkManager.ServerManager.Objects.Spawned.TryGetValueIL2CPP(objectOrPrefabId, out result);
            }
            //Not spawned.
            else
            {
                //Only look up asServer if not client, otherwise use client.
                bool asServer = !isClient;
                //Look up prefab.
                result = NetworkManager.GetPooledInstantiated(objectOrPrefabId, asServer);
            }

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            LastNetworkObject = result;
#endif
            return result;
        }

        /// <summary>
        /// Reads a NetworkBehaviour.
        /// </summary>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public NetworkBehaviour ReadNetworkBehaviour(out int objectId, out byte componentIndex)
        {
            NetworkObject nob = ReadNetworkObject(out objectId);
            componentIndex = ReadByte();

            NetworkBehaviour result;
            if (nob == null)
            {
                result = null;
            }
            else
            {
                if (componentIndex >= nob.NetworkBehaviours.Length)
                {
                    if (NetworkManager.CanLog(LoggingType.Error))
                        Debug.LogError($"ComponentIndex of {componentIndex} is out of bounds on {nob.gameObject.name} [id {nob.ObjectId}]. This may occur if you have modified your gameObject/prefab without saving it, or the scene.");
                    result = null;
                }
                else
                {
                    result = nob.NetworkBehaviours[componentIndex];
                }
            }

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            LastNetworkBehaviour = result;
#endif
            return result;
        }

        /// <summary>
        /// Reads a NetworkBehaviour.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public NetworkBehaviour ReadNetworkBehaviour()
        {
            return ReadNetworkBehaviour(out _, out _);
        }

        /// <summary>
        /// Writes a transport channel.
        /// </summary>
        /// <param name="channel"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Channel ReadChannel()
        {
            return (Channel)ReadByte();
        }

        /// <summary>
        /// Reads the Id for a NetworkConnection.
        /// </summary>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ReadNetworkConnectionId()
        {
            return ReadInt16();
        }

        /// <summary>
        /// Reads the Id for a NetworkObject.
        /// </summary>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ReadNetworkObjectId()
        {
            //Clear spawned.
            ReadBoolean();
            return ReadInt16();
        }

        /// <summary>
        /// Writes a NetworkConnection.
        /// </summary>
        /// <param name="conn"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public NetworkConnection ReadNetworkConnection()
        {
            int value = ReadInt16();
            if (value == -1)
            {
                return FishNet.Managing.NetworkManager.EmptyConnection;
            }
            else
            {
                //Prefer server.
                if (NetworkManager.IsServer)
                {
                    NetworkConnection result;
                    if (NetworkManager.ServerManager.Clients.TryGetValueIL2CPP(value, out result))
                    {
                        return result;
                    }
                    //If also client then try client side data.
                    else if (NetworkManager.IsClient)
                    {
                        //If found in client collection then return.
                        if (NetworkManager.ClientManager.Clients.TryGetValueIL2CPP(value, out result))
                            return result;
                        //Otherwise make a new instance.
                        else
                            return new NetworkConnection(NetworkManager, value);

                    }
                    //Only server and not found.
                    else
                    {
                        if (NetworkManager.CanLog(LoggingType.Warning))
                            Debug.LogWarning($"Unable to find connection for read Id {value}. An empty connection will be returned.");
                        return FishNet.Managing.NetworkManager.EmptyConnection;
                    }
                }
                //Try client side, will only be able to fetch against local connection.
                else
                {
                    //If value is self then return self.
                    if (value == NetworkManager.ClientManager.Connection.ClientId)
                        return NetworkManager.ClientManager.Connection;
                    //Try client side dictionary.
                    else if (NetworkManager.ClientManager.Clients.TryGetValueIL2CPP(value, out NetworkConnection result))
                        return result;
                    //Otherwise return a new connection.
                    else
                        return new NetworkConnection(NetworkManager, value); //todo make and use NC cache.
                }

            }
        }

        /// <summary>
        /// Checks if the size could possibly be an allocation attack.
        /// </summary>
        /// <param name="size"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool CheckAllocationAttack(int size)
        {
            /* Possible attacks. Impossible size, or size indicates
            * more elements in collection or more bytes needed
            * than what bytes are available. */
            if (size < -1)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Size of {size} is invalid.");
                return false;
            }
            if (size > Remaining)
            {
                if (NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Read size of {size} is larger than remaining data of {Remaining}.");
                return false;
            }

            //Checks pass.
            return true;
        }

        #region Packed readers.        
        /// <summary>
        /// ZigZag decode an integer. Move the sign bit back to the left.
        /// </summary>
        public ulong ZigZagDecode(ulong value)
        {
            ulong sign = value << 63;
            if (sign > 0)
                return ~(value >> 1) | sign;
            return value >> 1;
        }
        /// <summary>
        /// Reads a packed whole number.
        /// </summary>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ulong ReadPackedWhole()
        {
            byte data = ReadByte();
            ulong result = (ulong)(data & 0x7F);
            if ((data & 0x80) == 0) return result;

            data = ReadByte();
            result |= (ulong)(data & 0x7F) << 7;
            if ((data & 0x80) == 0) return result;

            data = ReadByte();
            result |= (ulong)(data & 0x7F) << 14;
            if ((data & 0x80) == 0) return result;

            data = ReadByte();
            result |= (ulong)(data & 0x7F) << 21;
            if ((data & 0x80) == 0) return result;

            data = ReadByte();
            result |= (ulong)(data & 0x0F) << 28;
            int extraBytes = data >> 4;

            switch (extraBytes)
            {
                case 0:
                    break;
                case 1:
                    result |= (ulong)ReadByte() << 32;
                    break;
                case 2:
                    result |= (ulong)ReadByte() << 32;
                    result |= (ulong)ReadByte() << 40;
                    break;
                case 3:
                    result |= (ulong)ReadByte() << 32;
                    result |= (ulong)ReadByte() << 40;
                    result |= (ulong)ReadByte() << 48;
                    break;
                case 4:
                    result |= (ulong)ReadByte() << 32;
                    result |= (ulong)ReadByte() << 40;
                    result |= (ulong)ReadByte() << 48;
                    result |= (ulong)ReadByte() << 56;
                    break;
            }
            return result;
        }
        #endregion

        #region Generators.
        /// <summary>
        /// Reads a list.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public List<T> ReadListAllocated<T>()
        {
            List<T> result = null;
            ReadList<T>(ref result);
            return result;
        }
        /// <summary>
        /// Reads into collection and returns amount read.
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="allowNullification">True to allow the referenced collection to be nullified when receiving a null collection read.</param>
        /// <returns>Number of values read into the collection. -1 is returned if the collection were read as null.</returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ReadList<T>(ref List<T> collection, bool allowNullification = false)
        {
            int count = ReadInt32();
            if (count == -1)
            {
                if (allowNullification)
                    collection = null;
                return -1;
            }
            else
            {
                if (collection == null)
                    collection = new List<T>(count);
                else
                    collection.Clear();

                for (int i = 0; i < count; i++)
                    collection.Add(Read<T>());

                return count;
            }
        }
        /// <summary>
        /// Reads an array.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T[] ReadArrayAllocated<T>()
        {
            T[] result = null;
            ReadArray<T>(ref result);
            return result;
        }
        /// <summary>
        /// Reads into collection and returns amount read.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collection"></param>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ReadArray<T>(ref T[] collection)
        {
            int count = ReadInt32();
            if (count == -1)
            {
                return 0;
            }
            else if (count == 0)
            {
                if (collection == null)
                    collection = new T[0];

                return 0;
            }
            else
            {
                //Initialize buffer if not already done.
                if (collection == null)
                    collection = new T[count];
                else if (collection.Length < count)
                    Array.Resize(ref collection, count);

                for (int i = 0; i < count; i++)
                    collection[i] = Read<T>();

                return count;
            }
        }

        /// <summary>
        /// Reads any supported type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T Read<T>()
        {
            if (IsAutoPackType<T>(out AutoPackType packType))
            {
                Func<Reader, AutoPackType, T> del = GenericReader<T>.ReadAutoPack;
                if (del == null)
                {
                    if (NetworkManager.CanLog(LoggingType.Error))
                        Debug.LogError($"Read method not found for {typeof(T).Name}. Use a supported type or create a custom serializer.");
                    return default;
                }
                else
                {
                    return del.Invoke(this, packType);
                }
            }
            else
            {
                Func<Reader, T> del = GenericReader<T>.Read;
                if (del == null)
                {
                    if (NetworkManager.CanLog(LoggingType.Error))
                        Debug.LogError($"Read method not found for {typeof(T).Name}. Use a supported type or create a custom serializer.");
                    return default;
                }
                else
                {
                    return del.Invoke(this);
                }
            }

        }

        /// <summary>
        /// Returns if T takes AutoPackType argument.
        /// </summary>
        /// <param name="packType">Outputs the default pack type for T.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal bool IsAutoPackType<T>(out AutoPackType packType) => Writer.IsAutoPackType<T>(out packType);
        #endregion
    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/ReaderExtensions.cs ---
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Object;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using System;
using UnityEngine;

namespace FishNet.Serializing
{
    /// <summary>
    /// Extensions to Read methods. Used by Read<T>.
    /// Internal use.
    /// </summary>
    [APIExclude]
    public static class ReaderExtensions
    {

        public static byte ReadByte(this Reader reader) => reader.ReadByte();
        [CodegenExclude]
        public static void ReadBytes(this Reader reader, ref byte[] target, int count) => reader.ReadBytes(ref target, count);
        public static byte[] ReadBytesAndSizeAllocated(this Reader reader) => reader.ReadBytesAndSizeAllocated();
        [CodegenExclude]
        public static int ReadBytesAndSize(this Reader reader, ref byte[] target) => reader.ReadBytesAndSize(ref target);
        [CodegenExclude]
        public static ArraySegment<byte> ReadArraySegment(this Reader reader, int count) => reader.ReadArraySegment(count);
        public static ArraySegment<byte> ReadArraySegmentAndSize(this Reader reader) => reader.ReadArraySegmentAndSize();
        public static sbyte ReadSByte(this Reader reader) => reader.ReadSByte();
        public static char ReadChar(this Reader reader) => reader.ReadChar();
        public static bool ReadBoolean(this Reader reader) => reader.ReadBoolean();
        public static short ReadInt16(this Reader reader) => reader.ReadInt16();
        public static ushort ReadUInt16(this Reader reader) => reader.ReadUInt16();
        public static int ReadInt32(this Reader reader, AutoPackType packType = AutoPackType.Packed) => reader.ReadInt32(packType);
        public static uint ReadUInt32(this Reader reader, AutoPackType packType = AutoPackType.Packed) => reader.ReadUInt32(packType);
        public static long ReadInt64(this Reader reader, AutoPackType packType = AutoPackType.Packed) => reader.ReadInt64(packType);
        public static ulong ReadUInt64(this Reader reader, AutoPackType packType = AutoPackType.Packed) => reader.ReadUInt64(packType);
        public static float ReadSingle(this Reader reader, AutoPackType packType = AutoPackType.Unpacked) => reader.ReadSingle(packType);
        public static double ReadDouble(this Reader reader) => reader.ReadDouble();
        public static decimal ReadDecimal(this Reader reader) => reader.ReadDecimal();
        public static string ReadString(this Reader reader) => reader.ReadString();
        public static Vector2 ReadVector2(this Reader reader) => reader.ReadVector2();
        public static Vector3 ReadVector3(this Reader reader) => reader.ReadVector3();
        public static Vector4 ReadVector4(this Reader reader) => reader.ReadVector4();
        public static Vector2Int ReadVector2Int(this Reader reader, AutoPackType packType = AutoPackType.Packed) => reader.ReadVector2Int(packType);
        public static Vector3Int ReadVector3Int(this Reader reader, AutoPackType packType = AutoPackType.Packed) => reader.ReadVector3Int(packType);
        public static Color ReadColor(this Reader reader, AutoPackType packType = AutoPackType.Packed) => reader.ReadColor(packType);
        public static Color32 ReadColor32(this Reader reader) => reader.ReadColor32();
        public static Quaternion ReadQuaternion(this Reader reader, AutoPackType packType = AutoPackType.Packed) => reader.ReadQuaternion(packType);
        public static Rect ReadRect(this Reader reader) => reader.ReadRect();
        public static Plane ReadPlane(this Reader reader) => reader.ReadPlane();
        public static Ray ReadRay(this Reader reader) => reader.ReadRay();
        public static Ray2D ReadRay2D(this Reader reader) => reader.ReadRay2D();
        public static Matrix4x4 ReadMatrix4x4(this Reader reader) => reader.ReadMatrix4x4();
        [CodegenExclude]
        public static byte[] ReadBytesAllocated(this Reader reader, int count) => reader.ReadBytesAllocated(count);
        public static System.Guid ReadGuid(this Reader reader) => reader.ReadGuid();
        public static GameObject ReadGameObject(this Reader reader) => reader.ReadGameObject();
        public static Transform ReadTransform(this Reader reader) => reader.ReadTransform();
        public static NetworkObject ReadNetworkObject(this Reader reader) => reader.ReadNetworkObject();
        public static NetworkBehaviour ReadNetworkBehaviour(this Reader reader) => reader.ReadNetworkBehaviour();
        public static Channel ReadChannel(this Reader reader) => reader.ReadChannel();
        public static NetworkConnection ReadNetworkConnection(this Reader reader) => reader.ReadNetworkConnection();
        [CodegenExclude]
        public static T Read<T>(this Reader reader) => reader.Read<T>();
    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/ReaderPool.cs ---
using FishNet.Managing;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace FishNet.Serializing
{
    /// <summary>
    /// Reader which is reused to save on garbage collection and performance.
    /// </summary>
    public sealed class PooledReader : Reader, IDisposable
    {
        internal PooledReader(byte[] bytes, NetworkManager networkManager) : base(bytes, networkManager) { }
        internal PooledReader(ArraySegment<byte> segment, NetworkManager networkManager) : base(segment, networkManager) { }
        public void Dispose() => ReaderPool.Recycle(this);
    }

    /// <summary>
    /// Collection of PooledReader. Stores and gets PooledReader.
    /// </summary>
    public static class ReaderPool
    {
        #region Private.
        /// <summary>
        /// Pool of readers.
        /// </summary>
        private static readonly Stack<PooledReader> _pool = new Stack<PooledReader>();
        #endregion

        /// <summary>
        /// Get the next reader in the pool
        /// <para>If pool is empty, creates a new Reader</para>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PooledReader GetReader(byte[] bytes, NetworkManager networkManager)
        {
            return GetReader(new ArraySegment<byte>(bytes), networkManager);
        }

        /// <summary>
        /// Get the next reader in the pool or creates a new one if none are available.
        /// </summary>
        public static PooledReader GetReader(ArraySegment<byte> segment, NetworkManager networkManager)
        {
            PooledReader result;
            if (_pool.Count > 0)
            {
                result = _pool.Pop();
                result.Initialize(segment, networkManager);
            }
            else
            {
                result = new PooledReader(segment, networkManager);
            }

            return result;
        }

        /// <summary>
        /// Puts reader back into pool
        /// <para>When pool is full, the extra reader is left for the GC</para>
        /// </summary>
        public static void Recycle(PooledReader reader)
        {
            _pool.Push(reader);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/ReaderStatics.cs ---
using FishNet.Documenting;
using System;
using System.Text;

namespace FishNet.Serializing
{

    /// <summary>
    /// Writes data to a buffer.
    /// </summary>
    [APIExclude]
    internal class ReaderStatics
    {
        /* Since serializing occurs on the main thread this value may
        * be shared among all readers. //multithread
        */

        #region Private.
        /// <summary>
        /// Buffer to copy Guids into.
        /// </summary>
        private static byte[] _guidBuffer = new byte[16];
        /// <summary>
        /// Used to encode strings.
        /// </summary>
        private static readonly UTF8Encoding _encoding = new UTF8Encoding(false, true);
        #endregion

        /// <summary>
        /// Gets the GUID Buffer.
        /// </summary>
        /// <returns></returns>
        public static byte[] GetGuidBuffer()
        {
            return _guidBuffer;
        }

        /// <summary>
        /// Returns a string from data.
        /// </summary>
        public static string GetString(ArraySegment<byte> data)
        {
            return _encoding.GetString(data.Array, data.Offset, data.Count);
        }
   
    }
}
'''
'''--- Assets/FishNet/Runtime/Serializing/TransformPackingData.cs ---
namespace FishNet.Serializing
{
    [System.Serializable]
    internal class TransformPackingData
    {
        public AutoPackType Position = AutoPackType.Packed;
        public AutoPackType Rotation = AutoPackType.Packed;
        public AutoPackType Scale = AutoPackType.Packed;
    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/Writer.cs ---
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Object;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility.Constant;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
namespace FishNet.Serializing
{
    /// <summary>
    /// Used for write references to generic types.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    [APIExclude]
    public static class GenericWriter<T>
    {
        public static Action<Writer, T> Write { get; set; }
        public static Action<Writer, T, AutoPackType> WriteAutoPack { get; set; }
    }

    /// <summary>
    /// Writes data to a buffer.
    /// </summary>
    public class Writer
    {
        #region Public.
        /// <summary>
        /// Capacity of the buffer.
        /// </summary>
        public int Capacity => _buffer.Length;
        /// <summary>
        /// Current write position.
        /// </summary>
        public int Position;
        /// <summary>
        /// Number of bytes writen to the buffer.
        /// </summary>
        public int Length;
        /// <summary>
        /// NetworkManager associated with this writer. May be null.
        /// </summary>
        public NetworkManager NetworkManager;
        #endregion

        #region Private.
        /// <summary>
        /// Buffer to prevent new allocations. This will grow as needed.
        /// </summary>
        private byte[] _buffer = new byte[64];
        #endregion

        /// <summary>
        /// Resets the writer as though it was unused. Does not reset buffers.
        /// </summary>
        public void Reset(NetworkManager manager = null)
        {
            Length = 0;
            Position = 0;
            NetworkManager = manager;
        }

        /// <summary>
        /// Writes a dictionary.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteDictionary<TKey, TValue>(Dictionary<TKey, TValue> dict)
        {
            if (dict == null)
            {
                WriteBoolean(true);
                return;
            }
            else
            {
                WriteBoolean(false);
            }

            WriteInt32(dict.Count);
            foreach (KeyValuePair<TKey, TValue> item in dict)
            {
                Write(item.Key);
                Write(item.Value);
            }
        }

        /// <summary>
        /// Ensures the buffer Capacity is of minimum count.
        /// </summary>
        /// <param name="count"></param>
        public void EnsureBufferCapacity(int count)
        {
            if (Capacity < count)
                Array.Resize(ref _buffer, count);
        }

        /// <summary>
        /// Ensure a number of bytes to be available in the buffer from current position.
        /// </summary>
        /// <param name="count"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnsureBufferLength(int count)
        {
            if (Position + count > _buffer.Length)
            {
                int nextSize = (_buffer.Length * 2) + count;
                Array.Resize(ref _buffer, nextSize);
            }
        }

        /// <summary>
        /// Returns the buffer. The returned value will be the full buffer, even if not all of it is used.
        /// </summary>
        /// <returns></returns>
        public byte[] GetBuffer()
        {
            return _buffer;
        }

        /// <summary>
        /// Returns the used portion of the buffer as an ArraySegment.
        /// </summary>
        /// <returns></returns>
        public ArraySegment<byte> GetArraySegment()
        {
            return new ArraySegment<byte>(_buffer, 0, Length);
        }

        /// <summary>
        /// Reserves a number of bytes from current position.
        /// </summary>
        /// <param name="count"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Reserve(int count)
        {
            EnsureBufferLength(count);
            Position += count;
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes length. This method is used to make debugging easier.
        /// </summary>
        /// <param name="length"></param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void WriteLength(int length)
        {
            WriteInt32(length);
        }

        /// <summary>
        /// Sends a packetId.
        /// </summary>
        /// <param name="pid"></param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void WritePacketId(PacketId pid)
        {
            WriteUInt16((ushort)pid);
        }

        /// <summary>
        /// Inserts value at index within the buffer.
        /// This method does not perform error checks.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="index"></param>
        [CodegenExclude]
        public void FastInsertByte(byte value, int index)
        {
            _buffer[index] = value;
        }

        /// <summary>
        /// Writes a byte.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteByte(byte value)
        {
            EnsureBufferLength(1);
            _buffer[Position++] = value;

            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes bytes.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteBytes(byte[] value, int offset, int count)
        {
            EnsureBufferLength(count);
            Buffer.BlockCopy(value, offset, _buffer, Position, count);
            Position += count;
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes bytes and length of bytes.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteBytesAndSize(byte[] value, int offset, int count)
        {
            if (value == null)
            {
                WriteInt32(-1);
            }
            else
            {
                WriteInt32(count);
                WriteBytes(value, offset, count);
            }
        }

        /// <summary>
        /// Writes all bytes in value and length of bytes.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteBytesAndSize(byte[] value)
        {
            int size = (value == null) ? 0 : value.Length;
            // buffer might be null, so we can't use .Length in that case
            WriteBytesAndSize(value, 0, size);
        }

        /// <summary>
        /// Writes a sbyte.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteSByte(sbyte value)
        {
            EnsureBufferLength(1);
            _buffer[Position++] = (byte)value;
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a char.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteChar(char value)
        {
            EnsureBufferLength(2);
            _buffer[Position++] = (byte)value;
            _buffer[Position++] = (byte)(value >> 8);
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a boolean.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteBoolean(bool value)
        {
            EnsureBufferLength(1);
            _buffer[Position++] = (value) ? (byte)1 : (byte)0;
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a uint16.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteUInt16(ushort value)
        {
            EnsureBufferLength(2);
            _buffer[Position++] = (byte)value;
            _buffer[Position++] = (byte)(value >> 8);
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a int16.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteInt16(short value)
        {
            EnsureBufferLength(2);
            _buffer[Position++] = (byte)value;
            _buffer[Position++] = (byte)(value >> 8);
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a int32.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteInt32(int value, AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Packed)
                WritePackedWhole(ZigZagEncode((ulong)value));
            else
                WriteUInt32((uint)value, packType);
        }
        /// <summary>
        /// Writes a uint32.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteUInt32(uint value, AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Unpacked)
            {
                EnsureBufferLength(4);
                WriterExtensions.WriteUInt32(_buffer, value, ref Position);
                Length = Math.Max(Length, Position);
            }
            else
            {
                WritePackedWhole(value);
            }
        }

        /// <summary>
        /// Writes an int64.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteInt64(long value, AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Packed)
                WritePackedWhole(ZigZagEncode((ulong)value));
            else
                WriteUInt64((ulong)value, packType);
        }
        /// <summary>
        /// Writes a uint64.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteUInt64(ulong value, AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Unpacked)
            {
                EnsureBufferLength(8);
                _buffer[Position++] = (byte)value;
                _buffer[Position++] = (byte)(value >> 8);
                _buffer[Position++] = (byte)(value >> 16);
                _buffer[Position++] = (byte)(value >> 24);
                _buffer[Position++] = (byte)(value >> 32);
                _buffer[Position++] = (byte)(value >> 40);
                _buffer[Position++] = (byte)(value >> 48);
                _buffer[Position++] = (byte)(value >> 56);

                Length = Math.Max(Position, Length);
            }
            else
            {
                WritePackedWhole(value);
            }
        }

        /// <summary>
        /// Writes a single (float).
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteSingle(float value, AutoPackType packType = AutoPackType.Unpacked)
        {
            if (packType == AutoPackType.Unpacked)
            {
                UIntFloat converter = new UIntFloat { FloatValue = value };
                WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
            }
            else
            {
                long converter = (long)(value * 100f);
                WritePackedWhole((ulong)converter);
            }
        }

        /// <summary>
        /// Writes a double.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteDouble(double value)
        {
            UIntDouble converter = new UIntDouble { DoubleValue = value };
            WriteUInt64(converter.LongValue, AutoPackType.Unpacked);
        }

        /// <summary>
        /// Writes a decimal.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteDecimal(decimal value)
        {
            UIntDecimal converter = new UIntDecimal { DecimalValue = value };
            WriteUInt64(converter.LongValue1, AutoPackType.Unpacked);
            WriteUInt64(converter.LongValue2, AutoPackType.Unpacked);
        }

        /// <summary>
        /// Writes a string.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteString(string value)
        {
            if (value == null)
            {
                WriteInt32(-1);
                return;
            }
            else if (value.Length == 0)
            {
                WriteInt32(0);
                return;
            }

            /* Resize string buffer as needed. There's no harm in
             * increasing buffer on writer side because sender will
             * never intentionally inflict allocations on itself. 
             * Reader ensures string count cannot exceed received
             * packet size. */
            int size;
            byte[] stringBuffer = WriterStatics.GetStringBuffer(value, out size);
            WriteInt32(size);
            WriteBytes(stringBuffer, 0, size);
        }

        /// <summary>
        /// Writes a byte ArraySegment and it's size.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteArraySegmentAndSize(ArraySegment<byte> value)
        {
            WriteBytesAndSize(value.Array, value.Offset, value.Count);
        }

        /// <summary>
        /// Writes an ArraySegment without size.
        /// </summary>
        /// <param name="value"></param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteArraySegment(ArraySegment<byte> value)
        {
            WriteBytes(value.Array, value.Offset, value.Count);
        }

        /// <summary>
        /// Writes a Vector2.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteVector2(Vector2 value)
        {
            UIntFloat converter;
            converter = new UIntFloat { FloatValue = value.x };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
            converter = new UIntFloat { FloatValue = value.y };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
        }

        /// <summary>
        /// Writes a Vector3
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteVector3(Vector3 value)
        {
            UIntFloat converter;
            converter = new UIntFloat { FloatValue = value.x };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
            converter = new UIntFloat { FloatValue = value.y };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
            converter = new UIntFloat { FloatValue = value.z };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
        }

        /// <summary>
        /// Writes a Vector4.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteVector4(Vector4 value)
        {
            UIntFloat converter;
            converter = new UIntFloat { FloatValue = value.x };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
            converter = new UIntFloat { FloatValue = value.y };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
            converter = new UIntFloat { FloatValue = value.z };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
            converter = new UIntFloat { FloatValue = value.w };
            WriteUInt32(converter.UIntValue, AutoPackType.Unpacked);
        }

        /// <summary>
        /// Writes a Vector2Int.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteVector2Int(Vector2Int value, AutoPackType packType = AutoPackType.Packed)
        {
            WriteInt32(value.x, packType);
            WriteInt32(value.y, packType);
        }

        /// <summary>
        /// Writes a Vector3Int.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteVector3Int(Vector3Int value, AutoPackType packType = AutoPackType.Packed)
        {
            WriteInt32(value.x, packType);
            WriteInt32(value.y, packType);
            WriteInt32(value.z, packType);
        }

        /// <summary>
        /// Writes a Color.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteColor(Color value, AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Unpacked)
            {
                WriteSingle(value.r);
                WriteSingle(value.g);
                WriteSingle(value.b);
                WriteSingle(value.a);
            }
            else
            {
                EnsureBufferLength(4);
                _buffer[Position++] = (byte)(value.r * 100f);
                _buffer[Position++] = (byte)(value.g * 100f);
                _buffer[Position++] = (byte)(value.b * 100f);
                _buffer[Position++] = (byte)(value.a * 100f);

                Length = Math.Max(Length, Position);
            }
        }

        /// <summary>
        /// Writes a Color32.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteColor32(Color32 value)
        {
            EnsureBufferLength(4);
            _buffer[Position++] = value.r;
            _buffer[Position++] = value.g;
            _buffer[Position++] = value.b;
            _buffer[Position++] = value.a;

            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a Quaternion.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteQuaternion(Quaternion value, AutoPackType packType = AutoPackType.Packed)
        {
            if (packType == AutoPackType.Packed)
            {
                EnsureBufferLength(4);
                uint result = Quaternion32Compression.Compress(value);
                WriterExtensions.WriteUInt32(_buffer, result, ref Position);
                Length = Math.Max(Length, Position);
            }
            else if (packType == AutoPackType.PackedLess)
            {
                EnsureBufferLength(8);
                ulong result = Quaternion64Compression.Compress(value);
                WriterExtensions.WriteUInt64(_buffer, result, ref Position);
                Length = Math.Max(Length, Position);
            }
            else
            {
                EnsureBufferLength(16);
                WriteSingle(value.x);
                WriteSingle(value.y);
                WriteSingle(value.z);
                WriteSingle(value.w);
            }
        }

        /// <summary>
        /// Writes a rect.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteRect(Rect value)
        {
            WriteSingle(value.xMin);
            WriteSingle(value.yMin);
            WriteSingle(value.width);
            WriteSingle(value.height);
        }

        /// <summary>
        /// Writes a plane.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WritePlane(Plane value)
        {
            WriteVector3(value.normal);
            WriteSingle(value.distance);
        }

        /// <summary>
        /// Writes a Ray.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteRay(Ray value)
        {
            WriteVector3(value.origin);
            WriteVector3(value.direction);
        }

        /// <summary>
        /// Writes a Ray2D.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteRay2D(Ray2D value)
        {
            WriteVector2(value.origin);
            WriteVector2(value.direction);
        }

        /// <summary>
        /// Writes a Matrix4x4.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteMatrix4x4(Matrix4x4 value)
        {
            WriteSingle(value.m00);
            WriteSingle(value.m01);
            WriteSingle(value.m02);
            WriteSingle(value.m03);
            WriteSingle(value.m10);
            WriteSingle(value.m11);
            WriteSingle(value.m12);
            WriteSingle(value.m13);
            WriteSingle(value.m20);
            WriteSingle(value.m21);
            WriteSingle(value.m22);
            WriteSingle(value.m23);
            WriteSingle(value.m30);
            WriteSingle(value.m31);
            WriteSingle(value.m32);
            WriteSingle(value.m33);
        }

        /// <summary>
        /// Writes a Guid.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteGuidAllocated(System.Guid value)
        {
            byte[] data = value.ToByteArray();
            WriteBytes(data, 0, data.Length);
        }

        /// <summary>
        /// Writes a GameObject. GameObject must be spawned over the network already or be a prefab with a NetworkObject attached.
        /// </summary>
        /// <param name="go"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteGameObject(GameObject go)
        {
            if (go == null)
            {
                WriteNetworkObject(null);
            }
            else
            {
                NetworkObject nob = go.GetComponent<NetworkObject>();
                WriteNetworkObject(nob);
            }
        }

        /// <summary>
        /// Writes a Transform. Transform must be spawned over the network already or be a prefab with a NetworkObject attached.
        /// </summary>
        /// <param name="t"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteTransform(Transform t)
        {
            if (t == null)
            {
                WriteNetworkObject(null);
            }
            else
            {
                NetworkObject nob = t.GetComponent<NetworkObject>();
                WriteNetworkObject(nob);
            }
        }

        /// <summary>
        /// Writes a NetworkObject.
        /// </summary>
        /// <param name="nob"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteNetworkObject(NetworkObject nob)
        {
            bool isSpawned = (nob != null && nob.IsSpawned);
            WriteBoolean(isSpawned);

            if (isSpawned)
            {
                WriteInt16((short)nob.ObjectId);
            }
            else
            {
                if (nob == null)
                    WriteInt16(-1);
                else
                    WriteInt16(nob.PrefabId);
            }
        }

        /// <summary>
        /// Writes a NetworkBehaviour.
        /// </summary>
        /// <param name="nb"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteNetworkBehaviour(NetworkBehaviour nb)
        {
            if (nb == null)
            {
                WriteNetworkObject(null);
                WriteByte(0);
            }
            else
            {
                WriteNetworkObject(nb.NetworkObject);
                WriteByte(nb.ComponentIndex);
            }
        }

        /// <summary>
        /// Writes a transport channel.
        /// </summary>
        /// <param name="channel"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteChannel(Channel channel)
        {
            WriteByte((byte)channel);
        }

        /// <summary>
        /// Writes a NetworkConnection.
        /// </summary>
        /// <param name="connection"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteNetworkConnection(NetworkConnection connection)
        {
            int value = (connection == null) ? -1 : connection.ClientId;
            WriteInt16((short)value);
        }

        /// <summary>
        /// Writes a short for a connectionId.
        /// </summary>
        /// <returns></returns>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteNetworkConnectionId(short id)
        {
            WriteInt16(id);
        }

        #region Packed writers.
        /// <summary>
        /// ZigZag encode an integer. Move the sign bit to the right.
        /// </summary>
        [CodegenExclude]
        public ulong ZigZagEncode(ulong value)
        {
            if (value >> 63 > 0)
                return ~(value << 1) | 1;
            return value << 1;
        }
        /// <summary>
        /// Writes a packed whole number.
        /// </summary>
        /// <param name="value"></param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WritePackedWhole(ulong value)
        {
            if (value < 0x80UL)
            {
                EnsureBufferLength(1);
                _buffer[Position++] = (byte)(value & 0x7F);
            }
            else if (value < 0x4000UL)
            {
                EnsureBufferLength(2);
                _buffer[Position++] = (byte)(0x80 | (value & 0x7F));
                _buffer[Position++] = (byte)((value >> 7) & 0x7F);
            }
            else if (value < 0x200000UL)
            {
                EnsureBufferLength(3);
                _buffer[Position++] = (byte)(0x80 | (value & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 7) & 0x7F));
                _buffer[Position++] = (byte)((value >> 14) & 0x7F);
            }
            else if (value < 0x10000000UL)
            {
                EnsureBufferLength(4);
                _buffer[Position++] = (byte)(0x80 | (value & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 7) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 14) & 0x7F));
                _buffer[Position++] = (byte)((value >> 21) & 0x7F);
            }
            else if (value < 0x100000000UL)
            {
                EnsureBufferLength(5);
                _buffer[Position++] = (byte)(0x80 | (value & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 7) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 14) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 21) & 0x7F));
                _buffer[Position++] = (byte)((value >> 28) & 0x0F);
            }
            else if (value < 0x10000000000UL)
            {
                EnsureBufferLength(6);
                _buffer[Position++] = (byte)(0x80 | (value & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 7) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 14) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 21) & 0x7F));
                _buffer[Position++] = (byte)(0x10 | ((value >> 28) & 0x0F));
                _buffer[Position++] = (byte)((value >> 32) & 0xFF);
            }
            else if (value < 0x1000000000000UL)
            {
                EnsureBufferLength(7);
                _buffer[Position++] = (byte)(0x80 | (value & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 7) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 14) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 21) & 0x7F));
                _buffer[Position++] = (byte)(0x20 | ((value >> 28) & 0x0F));
                _buffer[Position++] = (byte)((value >> 32) & 0xFF);
                _buffer[Position++] = (byte)((value >> 40) & 0xFF);
            }
            else if (value < 0x100000000000000UL)
            {
                EnsureBufferLength(8);
                _buffer[Position++] = (byte)(0x80 | (value & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 7) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 14) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 21) & 0x7F));
                _buffer[Position++] = (byte)(0x30 | ((value >> 28) & 0x0F));
                _buffer[Position++] = (byte)((value >> 32) & 0xFF);
                _buffer[Position++] = (byte)((value >> 40) & 0xFF);
                _buffer[Position++] = (byte)((value >> 48) & 0xFF);
            }
            else
            {
                EnsureBufferLength(9);
                _buffer[Position++] = (byte)(0x80 | (value & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 7) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 14) & 0x7F));
                _buffer[Position++] = (byte)(0x80 | ((value >> 21) & 0x7F));
                _buffer[Position++] = (byte)(0x40 | ((value >> 28) & 0x0F));
                _buffer[Position++] = (byte)((value >> 32) & 0xFF);
                _buffer[Position++] = (byte)((value >> 40) & 0xFF);
                _buffer[Position++] = (byte)((value >> 48) & 0xFF);
                _buffer[Position++] = (byte)((value >> 56) & 0xFF);
            }

            Length = Math.Max(Length, Position);
        }
        #endregion

        #region Generators.
        /// <summary>
        /// Writes a list.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        /// <param name="offset">Offset to begin at.</param>
        /// <param name="count">Entries to write.</param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteList<T>(List<T> value, int offset, int count)
        {
            if (value == null)
            {
                WriteInt32(-1);
            }
            else
            {
                //Make sure values cannot cause out of bounds.
                if ((offset + count > value.Count))
                    count = 0;

                WriteInt32(count);
                for (int i = 0; i < count; i++)
                    Write<T>(value[i + offset]);
            }
        }
        /// <summary>
        /// Writes a list.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        /// <param name="offset">Offset to begin at.</param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteList<T>(List<T> value, int offset)
        {
            if (value == null)
                WriteList<T>(null, 0, 0);
            else
                WriteList<T>(value, offset, value.Count - offset);
        }
        /// <summary>
        /// Writes a list.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteList<T>(List<T> value)
        {
            if (value == null)
                WriteList<T>(null, 0, 0);
            else
                WriteList<T>(value, 0, value.Count);
        }

        /// <summary>
        /// Writes an array.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        /// <param name="offset">Offset to begin at.</param>
        /// <param name="count">Entries to write.</param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteArray<T>(T[] value, int offset, int count)
        {
            if (value == null)
            {
                WriteInt32(-1);
            }
            else
            {
                //If theres no values, or offset exceeds count then write 0 for count.
                if (value.Length == 0 || (offset >= count))
                {
                    WriteInt32(0);
                }
                else
                {
                    WriteInt32(count);
                    for (int i = offset; i < count; i++)
                        Write<T>(value[i]);
                }
            }
        }
        /// <summary>
        /// Writes an array.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        /// <param name="offset">Offset to begin at.</param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteArray<T>(T[] value, int offset)
        {
            if (value == null)
                WriteArray<T>(null, 0, 0);
            else
                WriteArray<T>(value, offset, value.Length - offset);
        }
        /// <summary>
        /// Writes an array.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        [CodegenExclude]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteArray<T>(T[] value)
        {
            if (value == null)
                WriteArray<T>(null, 0, 0);
            else
                WriteArray<T>(value, 0, value.Length);
        }

        /// <summary>
        /// Writers any supported type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Write<T>(T value)
        {
            if (IsAutoPackType<T>(out AutoPackType packType))
            {
                Action<Writer, T, AutoPackType> del = GenericWriter<T>.WriteAutoPack;
                if (del == null)
                {
                    if (NetworkManager.StaticCanLog(LoggingType.Error))
                        Debug.LogError($"Write method not found for {typeof(T).Name}. Use a supported type or create a custom serializer.");
                }
                else
                {
                    del.Invoke(this, value, packType);
                }
            }
            else
            {
                Action<Writer, T> del = GenericWriter<T>.Write;
                if (del == null)
                {
                    if (NetworkManager.StaticCanLog(LoggingType.Error))
                        Debug.LogError($"Write method not found for {typeof(T).Name}. Use a supported type or create a custom serializer.");
                }
                else
                {
                    del.Invoke(this, value);
                }
            }
        }

        /// <summary>
        /// Returns if T takes AutoPackType argument.
        /// </summary>
        /// <param name="packType">Outputs the default pack type for T.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool IsAutoPackType<T>(out AutoPackType packType)
        {
            //performance bench this against using a hash lookup.
            System.Type type = typeof(T);
            if (WriterExtensions.DefaultPackedTypes.Contains(type))
            {
                packType = AutoPackType.Packed;
                return true;
            }
            else if (type == typeof(float))
            {
                packType = AutoPackType.Unpacked;
                return true;
            }
            else
            {
                packType = AutoPackType.Unpacked;
                return false;
            }
        }
        #endregion

    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/WriterExtensions.cs ---
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Object;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Serializing
{

    /// <summary>
    /// Extensions to Write methods. Used by Write<T>.
    /// Internal use.
    /// </summary>
    [APIExclude]
    public static class WriterExtensions
    {

        /// <summary>
        /// Types which are are set to auto pack by default.
        /// </summary>
        internal static HashSet<System.Type> DefaultPackedTypes = new HashSet<System.Type>();

        static WriterExtensions()
        {
            DefaultPackedTypes.Add(typeof(int));
            DefaultPackedTypes.Add(typeof(uint));
            DefaultPackedTypes.Add(typeof(long));
            DefaultPackedTypes.Add(typeof(ulong));
            DefaultPackedTypes.Add(typeof(Color));
            DefaultPackedTypes.Add(typeof(Vector2Int));
            DefaultPackedTypes.Add(typeof(Vector3Int));
            DefaultPackedTypes.Add(typeof(Quaternion));
        }

        /// <summary>
        /// Writes value to dst without error checking.
        /// </summary>
        [CodegenExclude]
        internal static void WriteUInt32(byte[] dst, uint value, ref int position)
        {
            dst[position++] = (byte)value;
            dst[position++] = (byte)(value >> 8);
            dst[position++] = (byte)(value >> 16);
            dst[position++] = (byte)(value >> 24);
        }
        /// <summary>
        /// Writes value to dst without error checking.
        /// </summary>
        [CodegenExclude]
        internal static void WriteUInt64(byte[] dst, ulong value, ref int position)
        {
            dst[position++] = (byte)value;
            dst[position++] = (byte)(value >> 8);
            dst[position++] = (byte)(value >> 16);
            dst[position++] = (byte)(value >> 24);
            dst[position++] = (byte)(value >> 32);
            dst[position++] = (byte)(value >> 40);
            dst[position++] = (byte)(value >> 48);
            dst[position++] = (byte)(value >> 56);
        }

        public static void WriteDictionary<TKey, TValue>(this Writer writer, Dictionary<TKey, TValue> dict) => writer.WriteDictionary(dict);
        public static void WriteByte(this Writer writer, byte value) => writer.WriteByte(value);
        [CodegenExclude]
        public static void WriteBytes(this Writer writer, byte[] buffer, int offset, int count) => writer.WriteBytes(buffer, offset, count);
        [CodegenExclude]
        public static void WriteBytesAndSize(this Writer writer, byte[] buffer, int offset, int count) => writer.WriteBytesAndSize(buffer, offset, count);
        public static void WriteBytesAndSize(this Writer writer, byte[] value) => writer.WriteBytesAndSize(value);

        public static void WriteSByte(this Writer writer, sbyte value) => writer.WriteSByte(value);
        public static void WriteChar(this Writer writer, char value) => writer.WriteChar(value);
        public static void WriteBoolean(this Writer writer, bool value) => writer.WriteBoolean(value);
        public static void WriteUInt16(this Writer writer, ushort value) => writer.WriteUInt16(value);
        public static void WriteInt16(this Writer writer, short value) => writer.WriteInt16(value);
        public static void WriteInt32(this Writer writer, int value, AutoPackType packType = AutoPackType.Packed) => writer.WriteInt32(value, packType);
        public static void WriteUInt32(this Writer writer, uint value, AutoPackType packType = AutoPackType.Packed) => writer.WriteUInt32(value, packType);
        public static void WriteInt64(this Writer writer, long value, AutoPackType packType = AutoPackType.Packed) => writer.WriteInt64(value, packType);
        public static void WriteUInt64(this Writer writer, ulong value, AutoPackType packType = AutoPackType.Packed) => writer.WriteUInt64(value, packType);
        public static void WriteSingle(this Writer writer, float value, AutoPackType packType = AutoPackType.Unpacked) => writer.WriteSingle(value, packType);
        public static void WriteDouble(this Writer writer, double value) => writer.WriteDouble(value);
        public static void WriteDecimal(this Writer writer, decimal value) => writer.WriteDecimal(value);
        public static void WriteString(this Writer writer, string value) => writer.WriteString(value);
        public static void WriteArraySegmentAndSize(this Writer writer, ArraySegment<byte> value) => writer.WriteArraySegmentAndSize(value);
        [CodegenExclude]
        public static void WriteArraySegment(this Writer writer, ArraySegment<byte> value) => writer.WriteArraySegment(value);
        public static void WriteVector2(this Writer writer, Vector2 value) => writer.WriteVector2(value);
        public static void WriteVector3(this Writer writer, Vector3 value) => writer.WriteVector3(value);
        public static void WriteVector4(this Writer writer, Vector4 value) => writer.WriteVector4(value);
        public static void WriteVector2Int(this Writer writer, Vector2Int value, AutoPackType packType = AutoPackType.Packed) => writer.WriteVector2Int(value, packType);
        public static void WriteVector3Int(this Writer writer, Vector3Int value, AutoPackType packType = AutoPackType.Packed) => writer.WriteVector3Int(value, packType);
        public static void WriteColor(this Writer writer, Color value, AutoPackType packType) => writer.WriteColor(value, packType);
        public static void WriteColor32(this Writer writer, Color32 value) => writer.WriteColor32(value);
        public static void WriteQuaternion(this Writer writer, Quaternion value, AutoPackType packType = AutoPackType.Packed) => writer.WriteQuaternion(value, packType);
        public static void WriteRect(this Writer writer, Rect value) => writer.WriteRect(value);
        public static void WritePlane(this Writer writer, Plane value) => writer.WritePlane(value);
        public static void WriteRay(this Writer writer, Ray value) => writer.WriteRay(value);
        public static void WriteRay2D(this Writer writer, Ray2D value) => writer.WriteRay2D(value);
        public static void WriteMatrix4x4(this Writer writer, Matrix4x4 value) => writer.WriteMatrix4x4(value);
        public static void WriteGuidAllocated(this Writer writer, System.Guid value) => writer.WriteGuidAllocated(value);
        public static void WriteGameObject(this Writer writer, GameObject value) => writer.WriteGameObject(value);
        public static void WriteTransform(this Writer writer, Transform value) => writer.WriteTransform(value);
        public static void WriteNetworkObject(this Writer writer, NetworkObject value) => writer.WriteNetworkObject(value);
        public static void WriteNetworkBehaviour(this Writer writer, NetworkBehaviour value) => writer.WriteNetworkBehaviour(value);
        public static void WriteChannel(this Writer writer, Channel value) => writer.WriteChannel(value);
        public static void WriteNetworkConnection(this Writer writer, NetworkConnection value) => writer.WriteNetworkConnection(value);
        [CodegenExclude]
        public static void Write<T>(this Writer writer, T value) => writer.Write<T>(value);

    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/WriterPool.cs ---
using FishNet.Managing;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace FishNet.Serializing
{
    /// <summary>
    /// Writer which is reused to save on garbage collection and performance.
    /// </summary>
    public sealed class PooledWriter : Writer, IDisposable
    {
        public void Dispose() => WriterPool.Recycle(this);
        public void DisposeLength() => WriterPool.RecycleLength(this);
    }

    /// <summary>
    /// Collection of PooledWriter. Stores and gets PooledWriter.
    /// </summary>
    public static class WriterPool
    {
        #region Private.
        /// <summary>
        /// Pool of writers where length is the minimum and increased at runtime.
        /// </summary>
        private static readonly Stack<PooledWriter> _pool = new Stack<PooledWriter>();
        /// <summary>
        /// Pool of writers where length is of minimum key and may be increased at runtime.
        /// </summary>
        private static readonly Dictionary<int, Stack<PooledWriter>> _lengthPool = new Dictionary<int, Stack<PooledWriter>>();
        #endregion

        #region Const.
        /// <summary>
        /// Length of each bracket when using the length based writer pool.
        /// </summary>
        internal const int LENGTH_BRACKET = 1000;
        #endregion

        /// <summary>
        /// Gets a writer from the pool.
        /// </summary>
        public static PooledWriter GetWriter(NetworkManager networkManager)
        {
            PooledWriter result = (_pool.Count > 0) ? _pool.Pop() : new PooledWriter();
            result.Reset(networkManager);
            return result;
        }
        /// <summary>
        /// Gets a writer from the pool.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PooledWriter GetWriter()
        {
            return GetWriter(null);
        }

        /// <summary>
        /// Gets which index to use for length based pooled readers based on length.
        /// </summary>
        private static int GetDictionaryIndex(int length)
        {
            return (length / LENGTH_BRACKET);
        }
        /// <summary>
        /// Gets the next writer in the pool of minimum length.
        /// </summary>
        /// <param name="length">Minimum length the writer buffer must be.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PooledWriter GetWriter(int length)
        {
            return GetWriter(null, length);
        }
        /// <summary>
        /// Gets the next writer in the pool of minimum length.
        /// </summary>
        /// <param name="length">Minimum length the writer buffer must be.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static PooledWriter GetWriter(NetworkManager networkManager, int length)
        {
            //Ensure length is the minimum.
            if (length < LENGTH_BRACKET)
                length = LENGTH_BRACKET;

            /* The index returned will be for writers which have
             * length as a minimum capacity.
             * EG: if length is 1200 / 1000 (length_bracket) result
             * will be index 1. Index 0 will be up to 1000, while
             * index 1 will be up to 2000. */
            int dictIndex = GetDictionaryIndex(length);
            Stack<PooledWriter> stack;
            //There is already one pooled.
            if (_lengthPool.TryGetValue(dictIndex, out stack) && stack.Count > 0)
            {
                PooledWriter result = stack.Pop();
                result.Reset(networkManager);
                return result;
            }
            //Not pooled yet.
            else
            {
                //Get any ol' writer.
                PooledWriter writer = GetWriter(networkManager);
                /* Ensure length to fill it's bracket.
                 * Increase index by 1 since 0 index would
                 * just return 0 as the capacity. */
                int requiredCapacity = (dictIndex + 1) * LENGTH_BRACKET;
                writer.EnsureBufferCapacity(requiredCapacity);
                return writer;
            }
        }

        /// <summary>
        /// Returns a writer to the appropriate length pool.
        /// Writers must be a minimum of 1000 bytes in length to be sorted by length.
        /// Writers which do not meet the minimum will be resized to 1000 bytes.
        /// </summary>
        public static void RecycleLength(PooledWriter writer)
        {
            int capacity = writer.Capacity;
            /* If capacity is less than 1000 then the writer
             * does not meet the minimum length bracket. This should never
             * be the case unless the user perhaps manually calls this method. */
            if (capacity < LENGTH_BRACKET)
            {
                capacity = LENGTH_BRACKET;
                writer.EnsureBufferCapacity(LENGTH_BRACKET);
            }

            /* When getting the recycle index subtract one from
             * the dictionary index. This is because the writer being
             * recycled must meet the minimum for that index.
             * EG: if LENGTH_BRACKET is 1000....
             * 1200 / 1000 = 1(after flooring).
             * However, each incremeent in index should have a capacity
             * of 1000, so index 1 should have a minimum capacity of 2000,
             * which 1200 does not meet. By subtracting 1 from the index
             * 1200 will now be placed in index 0 meeting the capacity for that index. */
            int dictIndex = GetDictionaryIndex(capacity) - 1;
            Stack<PooledWriter> stack;
            if (!_lengthPool.TryGetValue(dictIndex, out stack))
            {
                stack = new Stack<PooledWriter>();
                _lengthPool[dictIndex] = stack;
            }

            stack.Push(writer);
        }

        /// <summary>
        /// Returns a writer to the pool.
        /// </summary>
        public static void Recycle(PooledWriter writer)
        {
            _pool.Push(writer);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Serializing/WriterStatics.cs ---
using FishNet.Documenting;
using System;
using System.Text;

namespace FishNet.Serializing
{

    /// <summary>
    /// Writes data to a buffer.
    /// </summary>
    [APIExclude]
    internal class WriterStatics
    {
        /* Since serializing occurs on the main thread this value may
        * be shared among all writers. //multithread
        */

        #region Private.
        /// <summary>
        /// Encoder for strings.
        /// </summary>
        private static readonly UTF8Encoding _encoding = new UTF8Encoding(false, true);
        /// <summary>
        /// StringBuffer to use with encoding.
        /// </summary>
        private static byte[] _stringBuffer = new byte[64];
        #endregion

        /// <summary>
        /// Gets the string buffer ensuring proper length, and outputs size in bytes of string.
        /// </summary>
        public static byte[] GetStringBuffer(string str, out int size)
        {
            int strLength = str.Length;
            int valueMaxBytes = _encoding.GetMaxByteCount(strLength);
            if (valueMaxBytes >= _stringBuffer.Length)
            {
                int nextSize = (_stringBuffer.Length * 2) + valueMaxBytes;
                Array.Resize(ref _stringBuffer, nextSize);
            }

            size = _encoding.GetBytes(str, 0, strLength, _stringBuffer, 0);
            return _stringBuffer;

        }
        /// <summary>
        /// Ensures the string buffer is of a minimum length and returns the buffer.
        /// </summary>
        public static byte[] GetStringBuffer(string str)
        {
            int valueMaxBytes = _encoding.GetMaxByteCount(str.Length);
            if (valueMaxBytes >= _stringBuffer.Length)
            {
                int nextSize = (_stringBuffer.Length * 2) + valueMaxBytes;
                Array.Resize(ref _stringBuffer, nextSize);
            }

            return _stringBuffer;
        }
    }
}
'''
'''--- Assets/FishNet/Runtime/Transporting/Channels.cs ---
﻿namespace FishNet.Transporting
{
    /// <summary>
    /// Channel which data is sent or received.
    /// </summary>
    public enum Channel : byte
    {
        /// <summary>
        /// Data will be sent ordered reliable.
        /// </summary>
        Reliable = 0,
        /// <summary>
        /// Data will be sent unreliable.
        /// </summary>
        Unreliable = 1
    }

}
'''
'''--- Assets/FishNet/Runtime/Transporting/ConnectionStates.cs ---
﻿namespace FishNet.Transporting
{

    /// <summary>
    /// States the local connection can be in.
    /// </summary>
    public enum LocalConnectionState : byte
    {
        /// <summary>
        /// Connection is fully stopped.
        /// </summary>
        Stopped = 0,
        /// <summary>
        /// Connection is starting but not yet established.
        /// </summary>
        Starting = 1,
        /// <summary>
        /// Connection is established.
        /// </summary>
        Started = 2,
        /// <summary>
        /// Connection is stopping.
        /// </summary>
        Stopping = 3
    }

    /// <summary>
    /// States a remote client can be in.
    /// </summary>
    public enum RemoteConnectionState : byte
    {
        /// <summary>
        /// Connection is fully stopped.
        /// </summary>
        Stopped = 0,
        /// <summary>
        /// Connection is established.
        /// </summary>
        Started = 2,
    }

}
'''
'''--- Assets/FishNet/Runtime/Transporting/EventStructures.cs ---
﻿using System;

namespace FishNet.Transporting
{
    /// <summary>
    /// Container about data received on the server.
    /// </summary>
    public struct ServerReceivedDataArgs
    {
        /// <summary>
        /// Data received.
        /// </summary>
        public ArraySegment<byte> Data;
        /// <summary>
        /// Channel data was received on.
        /// </summary>
        public Channel Channel;
        /// <summary>
        /// ConnectionId from which client sent data, if data was received on the server.
        /// </summary>
        public int ConnectionId;
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;
        /// <summary>
        /// Delegate to invoke after data is processed.
        /// </summary>
        /// <returns></returns>
        public Action FinalizeMethod;

        public ServerReceivedDataArgs(ArraySegment<byte> data, Channel channel, int connectionId, int transportIndex)
        {
            Data = data;
            Channel = channel;
            ConnectionId = connectionId;
            TransportIndex = transportIndex;
            FinalizeMethod = null;
        }
        public ServerReceivedDataArgs(ArraySegment<byte> data, Channel channel, int connectionId, int transportIndex, Action finalizeMethod)
        {
            Data = data;
            Channel = channel;
            ConnectionId = connectionId;
            TransportIndex = transportIndex;
            FinalizeMethod = finalizeMethod;
        }
    }

    /// <summary>
    /// Container about data received on the local client.
    /// </summary>
    public struct ClientReceivedDataArgs
    {
        /// <summary>
        /// Data received.
        /// </summary>
        public ArraySegment<byte> Data;
        /// <summary>
        /// Channel data was received on.
        /// </summary>
        public Channel Channel;
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;

        public ClientReceivedDataArgs(ArraySegment<byte> data, Channel channel, int transportIndex)
        {
            Data = data;
            Channel = channel;
            TransportIndex = transportIndex;
        }
    }

    /// <summary>
    /// Container about a connection state change for a client.
    /// </summary>
    public struct RemoteConnectionStateArgs
    {
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;
        /// <summary>
        /// New connection state.
        /// </summary>
        public RemoteConnectionState ConnectionState;
        /// <summary>
        /// ConnectionId for which client the state changed. Will be -1 if ConnectionState was for the local server.
        /// </summary>
        public int ConnectionId;

        public RemoteConnectionStateArgs(RemoteConnectionState connectionState, int connectionId, int transportIndex)
        {
            ConnectionState = connectionState;
            ConnectionId = connectionId;
            TransportIndex = transportIndex;
        }
    }

    /// <summary>
    /// Container about a connection state change for the server.
    /// </summary>
    public struct ServerConnectionStateArgs
    {
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;
        /// <summary>
        /// New connection state.
        /// </summary>
        public LocalConnectionState ConnectionState;

        public ServerConnectionStateArgs(LocalConnectionState connectionState, int transportIndex)
        {            
            ConnectionState = connectionState;
            TransportIndex = transportIndex;
        }
    }

    /// <summary>
    /// Container about a connection state change for the local client.
    /// </summary>
    public struct ClientConnectionStateArgs
    {
        /// <summary>
        /// New connection state.
        /// </summary>
        public LocalConnectionState ConnectionState;
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;

        public ClientConnectionStateArgs(LocalConnectionState connectionState, int transportIndex)
        {            
            ConnectionState = connectionState;
            TransportIndex = transportIndex;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/IPAddressType.cs ---
﻿namespace FishNet.Transporting
{
    /// <summary>
    /// Channel which data is sent or received.
    /// </summary>
    public enum IPAddressType : byte
    {
        /// <summary>
        /// Address is IPv4.
        /// </summary>
        IPv4 = 0,
        /// <summary>
        /// Address is IPv6.
        /// </summary>
        IPv6 = 1
    }

}
'''
'''--- Assets/FishNet/Runtime/Transporting/NetworkReaderLoop.cs ---
﻿using FishNet.Managing.Timing;
using UnityEngine;

namespace FishNet.Transporting
{
    [DisallowMultipleComponent]
    [DefaultExecutionOrder(short.MinValue)]
    internal class NetworkReaderLoop : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// TimeManager this loop is for.
        /// </summary>
        private TimeManager _timeManager;
        #endregion

        private void Awake()
        {
            _timeManager = GetComponent<TimeManager>();
        }

        private void FixedUpdate()
        {
            _timeManager.TickFixedUpdate();
        }
        private void Update()
        {
            _timeManager.TickUpdate();
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Transporting/NetworkWriterLoop.cs ---
﻿using FishNet.Managing.Timing;
using UnityEngine;

namespace FishNet.Transporting
{
    [DisallowMultipleComponent]
    [DefaultExecutionOrder(short.MaxValue)]
    internal class NetworkWriterLoop : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// TimeManager this loop is for.
        /// </summary>
        private TimeManager _timeManager;
        #endregion

        private void Awake()
        {
            _timeManager = GetComponent<TimeManager>();
        }

        private void LateUpdate()
        {
            Iterate();
        }

        /// <summary>
        /// Performs read on transport.
        /// </summary>
        private void Iterate()
        {
            _timeManager.TickLateUpdate();
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Transporting/PacketId.cs ---
﻿using FishNet.Documenting;

namespace FishNet.Transporting
{

    /// <summary>
    /// PacketIds to indicate the type of packet which is being sent or arriving.
    /// </summary>
    [APIExclude]
    public enum PacketId : ushort
    {
        Unset = 0,
        Authenticated = 1,
        Split = 2,
        ObjectSpawn = 3,
        ObjectDespawn = 4,
        Event = 5,
        SyncVar = 6,
        ServerRpc = 7,
        ObserversRpc = 8,
        TargetRpc = 10,
        OwnershipChange = 11,
        Broadcast = 12,
        SyncObject = 13,
        PingPong = 14,
        Replicate = 15,
        Reconcile = 16,
        Disconnect = 17,
        TimingUpdate = 18
    }

}
'''
'''--- Assets/FishNet/Runtime/Transporting/Transport.cs ---
﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using System;
using UnityEngine;

namespace FishNet.Transporting
{

    /// <summary>
    /// Processes connection states, and data sent to and from a socket.
    /// </summary>
    public abstract class Transport : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// NetworkManager for this transport.
        /// </summary>
        public NetworkManager NetworkManager { get; private set; }
        /// <summary>
        /// Index this transport belongs to when using multiple transports at once.
        /// </summary>
        public int Index { get; private set; }
        #endregion

        #region Initialization and unity.
        /// <summary>
        /// Initializes the transport. Use this instead of Awake.
        /// <paramref name="transportIndex"/>Index this transport belongs to when using multiple transports at once.</param>
        /// </summary>
        public virtual void Initialize(NetworkManager networkManager, int transportIndex)
        {
            NetworkManager = networkManager;
            Index = transportIndex;
        }
        #endregion

        #region ConnectionStates.
        /// <summary>
        /// Gets the address of a remote connection Id.
        /// </summary>
        /// <param name="connectionId">Connectionid to get the address for.</param>
        /// <returns></returns>
        public abstract string GetConnectionAddress(int connectionId);
        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        public abstract event Action<ClientConnectionStateArgs> OnClientConnectionState;
        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        public abstract event Action<ServerConnectionStateArgs> OnServerConnectionState;
        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        public abstract event Action<RemoteConnectionStateArgs> OnRemoteConnectionState;
        /// <summary>
        /// Handles a ConnectionStateArgs for the local client.
        /// </summary>
        /// <param name="connectionStateArgs">Data being handled.</param>
        public abstract void HandleClientConnectionState(ClientConnectionStateArgs connectionStateArgs);
        /// <summary>
        /// Handles a ConnectionStateArgs for the local server.
        /// </summary>
        /// <param name="connectionStateArgs">Data being handled.</param>
        public abstract void HandleServerConnectionState(ServerConnectionStateArgs connectionStateArgs);
        /// <summary>
        /// Handles a ConnectionStateArgs for a remote client.
        /// </summary>
        /// <param name="connectionStateArgs">Data being handled.</param>
        public abstract void HandleRemoteConnectionState(RemoteConnectionStateArgs connectionStateArgs);
        /// <summary>
        /// Gets the current local ConnectionState.
        /// </summary>
        /// <param name="server">True if getting ConnectionState for the server.</param>
        public abstract LocalConnectionState GetConnectionState(bool server);
        /// <summary>
        /// Gets the current ConnectionState of a client connected to the server. Can only be called on the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        public abstract RemoteConnectionState GetConnectionState(int connectionId);
        #endregion

        #region Sending.
        /// <summary>
        /// Sends to the server.
        /// </summary>
        /// <param name="channelId">Channel to use.</param>
        /// <param name="segment">Data to send.</param>
        public abstract void SendToServer(byte channelId, ArraySegment<byte> segment);
        /// <summary>
        /// Sends to a client.
        /// </summary>
        /// <param name="channelId">Channel to use.</param>
        /// <param name="segment">Data to send.</param>
        /// <param name="connectionId">ConnectionId to send to. When sending to clients can be used to specify which connection to send to.</param>
        public abstract void SendToClient(byte channelId, ArraySegment<byte> segment, int connectionId);
        #endregion

        #region Receiving
        /// <summary>
        /// Called when the client receives data.
        /// </summary>
        public abstract event Action<ClientReceivedDataArgs> OnClientReceivedData;
        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs">Data being handled.</param>
        public abstract void HandleClientReceivedDataArgs(ClientReceivedDataArgs receivedDataArgs);
        /// <summary>
        /// Called when the server receives data.
        /// </summary>
        public abstract event Action<ServerReceivedDataArgs> OnServerReceivedData;
        /// <summary>
        /// Handles a ServerReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs">Data being handled.</param>
        public abstract void HandleServerReceivedDataArgs(ServerReceivedDataArgs receivedDataArgs);
        #endregion

        #region Iterating.
        /// <summary>
        /// Processes data received by the socket.
        /// </summary>
        /// <param name="server">True to process data received on the server.</param>
        public abstract void IterateIncoming(bool server);
        /// <summary>
        /// Processes data to be sent by the socket.
        /// </summary>
        /// <param name="server">True to process data received on the server.</param>
        public abstract void IterateOutgoing(bool server);
        #endregion

        #region Configuration.
        /// <summary>
        /// Returns if the transport is only run locally, offline.
        /// While true several security checks are disabled.
        /// </summary>
        public virtual bool IsLocalTransport(int connectionid) => false;
        /// <summary>
        /// Gets how long in seconds until either the server or client socket must go without data before being timed out.
        /// </summary>
        /// <param name="asServer">True to get the timeout for the server socket, false for the client socket.</param>
        /// <returns></returns>
        public virtual float GetTimeout(bool asServer) => -1f;
        /// <summary>
        /// Sets how long in seconds until either the server or client socket must go without data before being timed out.
        /// </summary>
        /// <param name="asServer">True to set the timeout for the server socket, false for the client socket.</param>
        public virtual void SetTimeout(float value, bool asServer) { }
        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// </summary>
        /// <returns>Maximum clients transport allows.</returns>
        public virtual int GetMaximumClients()
        {
            bool canLog = (NetworkManager == null) ? NetworkManager.StaticCanLog(LoggingType.Warning) : NetworkManager.CanLog(LoggingType.Warning);
            if (canLog)
                Debug.LogWarning($"The current transport does not support this feature.");
            return -1;
        }
        /// <summary>
        /// Sets the maximum number of clients allowed to connect to the server. If applied at runtime and clients exceed this value existing clients will stay connected but new clients may not connect.
        /// </summary>
        /// <param name="value">Maximum clients to allow.</param>
        public virtual void SetMaximumClients(int value)
        {
            bool canLog = (NetworkManager == null) ? NetworkManager.StaticCanLog(LoggingType.Warning) : NetworkManager.CanLog(LoggingType.Warning);
            if (canLog)
                Debug.LogWarning($"The current transport does not support this feature.");
        }
        /// <summary>
        /// Sets which address the client will connect to.
        /// </summary>
        /// <param name="address">Address client will connect to.</param>
        public virtual void SetClientAddress(string address) { }
        /// <summary>
        /// Returns which address the client will connect to.
        /// </summary>
        public virtual string GetClientAddress() => string.Empty;
        /// <summary>
        /// Sets which address the server will bind to.
        /// </summary>
        /// <param name="address">Address server will bind to.</param>
        [Obsolete("Use SetServerBindAddress(string, IPAddressType)")] //Remove on 01/01/2023
        public virtual void SetServerBindAddress(string address) { }
        /// <summary>
        /// Gets which address the server will bind to.
        /// </summary>
        [Obsolete("Use GetServerBindAddress(IPAddressType)")] //Remove on 01/01/2023
        public virtual string GetServerBindAddress() => string.Empty;
        /// <summary>
        /// Sets which address the server will bind to.
        /// </summary>
        /// <param name="address">Address server will bind to.</param>
        /// <param name="addressType">Address type to set.</param>
        public virtual void SetServerBindAddress(string address, IPAddressType addressType) { }
        /// <summary>
        /// Gets which address the server will bind to.
        /// </summary>
        /// <param name="addressType">Address type to return.</param>
        public virtual string GetServerBindAddress(IPAddressType addressType) => string.Empty;
        /// <summary>
        /// Sets which port to use.
        /// </summary>
        /// <param name="port">Port to use.</param>
        public virtual void SetPort(ushort port) { }
        /// <summary>
        /// Gets which port to use.
        /// </summary>
        public virtual ushort GetPort() => 0;
        #endregion

        #region Start and stop.
        /// <summary>
        /// Starts the local server or client using configured settings.
        /// </summary>
        /// <param name="server">True to start server.</param>
        public abstract bool StartConnection(bool server);
        /// <summary>
        /// Stops the local server or client.
        /// </summary>
        /// <param name="server">True to stop server.</param>
        public abstract bool StopConnection(bool server);
        /// <summary>
        /// Stops a remote client from the server, disconnecting the client.
        /// </summary>
        /// <param name="connectionId">ConnectionId of the client to disconnect.</param>
        /// <param name="immediately">True to abrutly stop the client socket. The technique used to accomplish immediate disconnects may vary depending on the transport.
        /// When not using immediate disconnects it's recommended to perform disconnects using the ServerManager rather than accessing the transport directly.
        /// </param>
        public abstract bool StopConnection(int connectionId, bool immediately);
        /// <summary>
        /// Stops both client and server.
        /// </summary>
        public abstract void Shutdown();
        #endregion

        #region Channels.
        /// <summary>
        /// Gets the MTU for a channel.
        /// </summary>
        /// <param name="channel">Channel to get MTU for.</param>
        /// <returns>MTU of channel.</returns>
        public abstract int GetMTU(byte channel);
        #endregion

    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Multipass/CHANGELOG.txt ---
1.0.0
	- Initial release.
'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Multipass/Multipass.cs ---
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Utility.Extension;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Transporting.Multipass
{
    [AddComponentMenu("FishNet/Transport/Multipass")]
    public class Multipass : Transport
    {
        #region Types.
        public struct TransportIdData
        {
            public int TransportId;
            public int TransportIndex;

            public TransportIdData(int transportId, int transportIndex)
            {
                TransportId = transportId;
                TransportIndex = transportIndex;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// While true server actions such as starting or stopping the server will run on all transport.
        /// </summary>
        [Tooltip("While true server actions such as starting or stopping the server will run on all transport.")]
        public bool GlobalServerActions = true;
        /// <summary>
        /// 
        /// </summary>
        private Transport _clientTransport;
        /// <summary>
        /// Transport the client is using.
        /// Use SetClientTransport to assign this value.
        /// </summary>
        [HideInInspector]
        public Transport ClientTransport
        {
            get
            {
                //If not yet set.
                if (_clientTransport == null)
                {
                    //If there are transports to set from.
                    if (_transports.Count != 0)
                        _clientTransport = _transports[0];

                    /* Give feedback to developer that transport was not set
                    * before accessing this. Transport should always be set
                    * manually rather than assuming the default client
                    * transport. */
                    if (_clientTransport == null)
                        base.NetworkManager.LogError($"ClientTransport in Multipass could not be set to the first transport. This can occur if no trnasports are specified or if the first entry is null.");
                    else
                        base.NetworkManager.LogError($"ClientTransport in Multipass is being automatically set to {_clientTransport.GetType()}. For production use SetClientTransport before attempting to access the ClientTransport.");
                }

                return _clientTransport;
            }

            private set => _clientTransport = value;
        }
        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Transports to use.")]
        [SerializeField]
        private List<Transport> _transports = new List<Transport>();
        /// <summary>
        /// Transports to use.
        /// </summary>
        public IList<Transport> Transports => _transports;
        #endregion

        #region Private. 
        /// <summary>
        /// Key is the transport connectionid, Value is the TransportIdData.
        /// </summary>
        private Dictionary<int, TransportIdData> _multipassToTransport = new Dictionary<int, TransportIdData>();
        /// <summary>
        /// Key is the Multipass connectionId, Value is the transport connectionId.
        /// </summary>
        private List<Dictionary<int, int>> _transportToMultipass = new List<Dictionary<int, int>>();
        /// <summary>
        /// Ids available to new connections.
        /// </summary>
        private Queue<int> _availableIds = new Queue<int>();
        #endregion

        #region Const.
        /// <summary>
        /// Id to use for client when acting as host.
        /// </summary>
        internal const int CLIENT_HOST_ID = short.MaxValue;
        #endregion

        public override void Initialize(NetworkManager networkManager, int transportIndex)
        {
            base.Initialize(networkManager, transportIndex);

            //Remove any null transports and warn.
            for (int i = 0; i < _transports.Count; i++)
            {
                if (_transports[i] == null)
                {
                    base.NetworkManager.LogWarning($"Transports contains a null entry on index {i}.");
                    _transports.RemoveAt(i);
                    i--;
                }
            }

            //No transports to use.
            if (_transports.Count == 0)
            {
                base.NetworkManager.LogError($"No transports are set within Multipass.");
                return;
            }

            //Create transportsToMultipass.
            for (int i = 0; i < _transports.Count; i++)
            {
                Dictionary<int, int> dict = new Dictionary<int, int>();
                _transportToMultipass.Add(dict);
            }

            //Initialize each transport.
            for (int i = 0; i < _transports.Count; i++)
            {
                _transports[i].Initialize(networkManager, i);
                _transports[i].OnClientConnectionState += Multipass_OnClientConnectionState;
                _transports[i].OnServerConnectionState += Multipass_OnServerConnectionState;
                _transports[i].OnRemoteConnectionState += Multipass_OnRemoteConnectionState;
                _transports[i].OnClientReceivedData += Multipass_OnClientReceivedData;
                _transports[i].OnServerReceivedData += Multipass_OnServerReceivedData;
            }
        }

        private void OnDestroy()
        {
            //Initialize each transport.
            foreach (Transport t in _transports)
                t.Shutdown();
        }

        #region ClientIds.
        /// <summary>
        /// Clears ClientIds when appropriate.
        /// </summary>
        private void TryResetClientIds(bool force)
        {
            //Can only clear when every transport server isnt connected.
            if (!force)
            {
                foreach (Transport t in _transports)
                {
                    //Cannot clear if a server is running still.
                    if (t.GetConnectionState(true) == LocalConnectionState.Started)
                        return;
                }
            }

            _multipassToTransport.Clear();
            foreach (Dictionary<int, int> item in _transportToMultipass)
                item.Clear();
            CreateAvailableIds();
        }

        /// <summary>
        /// Gets the Multipass connectionId using a transport connectionid.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool GetMultipassId(int transportIndex, int transportId, out int multipassId)
        {
            Dictionary<int, int> dict = _transportToMultipass[transportIndex];
            if (!dict.TryGetValueIL2CPP(transportId, out multipassId))
            {
                multipassId = -1;
                base.NetworkManager.LogError($"Multipass connectionId could not be found for transportIndex {transportIndex}, transportId of {transportId}.");

                return false;
            }

            return true;
        }

        /// <summary>
        /// Gets the TransportIdData using a Multipass connectionId.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool GetTransportIdData(int multipassId, out TransportIdData data)
        {
            if (!_multipassToTransport.TryGetValueIL2CPP(multipassId, out data))
            {
                //Fall through.
                base.NetworkManager.LogError($"TransportIdData could not be found for Multipass connectionId of {multipassId}.");
                return false;
            }

            return true;
        }
        #endregion

        #region ConnectionStates.
        /// <summary>
        /// Gets the IP address of a remote connectionId.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string GetConnectionAddress(int connectionId)
        {
            TransportIdData data;
            if (!GetTransportIdData(connectionId, out data))
                return string.Empty;

            return _transports[data.TransportIndex].GetConnectionAddress(data.TransportId);
        }
        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        public override event Action<ClientConnectionStateArgs> OnClientConnectionState;
        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        public override event Action<ServerConnectionStateArgs> OnServerConnectionState;
        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        public override event Action<RemoteConnectionStateArgs> OnRemoteConnectionState;
        /// <summary>
        /// Gets the current local ConnectionState of the first transport.
        /// </summary>
        /// <param name="server">True if getting ConnectionState for the server.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override LocalConnectionState GetConnectionState(bool server)
        {
            if (server)
            {
                base.NetworkManager.LogError($"This method is not supported for server. Use GetConnectionState(server, transportIndex) instead.");
                return LocalConnectionState.Stopped;
            }

            if (IsClientTransportSetWithError("GetConnectionState"))
                return GetConnectionState(server, ClientTransport.Index);
            else
                return LocalConnectionState.Stopped;
        }
        /// <summary>
        /// Gets the current local ConnectionState of the transport on index.
        /// </summary>
        /// <param name="server">True if getting ConnectionState for the server.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LocalConnectionState GetConnectionState(bool server, int index)
        {
            if (!IndexInRange(index, true))
                return LocalConnectionState.Stopped;

            return _transports[index].GetConnectionState(server);
        }
        /// <summary>
        /// Gets the current ConnectionState of a remote client on the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override RemoteConnectionState GetConnectionState(int connectionId)
        {

            TransportIdData data;
            if (!GetTransportIdData(connectionId, out data))
                return RemoteConnectionState.Stopped;

            return _transports[data.TransportIndex].GetConnectionState(connectionId);
        }
        /// <summary>
        /// Gets the current ConnectionState of a remote client on the server of the transport on index.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RemoteConnectionState GetConnectionState(int connectionId, int index)
        {
            if (!IndexInRange(index, true))
                return RemoteConnectionState.Stopped;

            return _transports[index].GetConnectionState(connectionId);
        }

        /// <summary>
        /// Handles a ConnectionStateArgs for the local client.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        private void Multipass_OnClientConnectionState(ClientConnectionStateArgs connectionStateArgs)
        {
            OnClientConnectionState?.Invoke(connectionStateArgs);
        }
        /// <summary>
        /// Handles a ConnectionStateArgs for the local server.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        private void Multipass_OnServerConnectionState(ServerConnectionStateArgs connectionStateArgs)
        {
            OnServerConnectionState?.Invoke(connectionStateArgs);
            TryResetClientIds(false);
        }
        /// <summary>
        /// Handles a ConnectionStateArgs for a remote client.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        private void Multipass_OnRemoteConnectionState(RemoteConnectionStateArgs connectionStateArgs)
        {
            /* When starting Multipass needs to get a new
            * connectionId to be used within FN. This is the 'ClientId'
             * that is passed around for ownership, rpcs, ect.
             * 
             * The new connectionId will be linked with the connectionId
             * from the transport, named transportConnectionid. 
             * 
             * When data arrives the transportStateId is used as a key
             * in fromClientIds, where Multipass Id is returned. The argument values
             * are then overwritten with the MultipassId.
             * 
             * When data is being sent the same process is performed but reversed.
             * The connectionId is looked up in toClientIds, where the transportConnectionId
             * is output. Then as before the argument values are overwritten with the
             * transportConnectionId. */

            int transportIndex = connectionStateArgs.TransportIndex;
            int transportId = connectionStateArgs.ConnectionId;
            int multipassId;
            Dictionary<int, int> transportToMultipass = _transportToMultipass[transportIndex];

            //Started.
            if (connectionStateArgs.ConnectionState == RemoteConnectionState.Started)
            {
                multipassId = _availableIds.Dequeue();
                transportToMultipass[transportId] = multipassId;
                _multipassToTransport[multipassId] = new TransportIdData(transportId, transportIndex);
            }
            //Stopped.
            else
            {
                if (!GetMultipassId(transportIndex, transportId, out multipassId))
                    return;

                _availableIds.Enqueue(multipassId);
                transportToMultipass.Remove(transportId);
                _multipassToTransport.Remove(multipassId);
            }

            connectionStateArgs.ConnectionId = multipassId;
            OnRemoteConnectionState?.Invoke(connectionStateArgs);
        }
        #endregion

        #region Iterating.
        /// <summary>
        /// Processes data received by the socket.
        /// </summary>
        /// <param name="server">True to process data received on the server.</param>
        public override void IterateIncoming(bool server)
        {
            foreach (Transport t in _transports)
                t.IterateIncoming(server);
        }

        /// <summary>
        /// Processes data to be sent by the socket.
        /// </summary>
        /// <param name="server">True to process data received on the server.</param>
        public override void IterateOutgoing(bool server)
        {
            foreach (Transport t in _transports)
                t.IterateOutgoing(server);
        }
        #endregion

        #region ReceivedData.
        /// <summary>
        /// Called when client receives data.
        /// </summary>
        public override event Action<ClientReceivedDataArgs> OnClientReceivedData;
        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs"></param>
        private void Multipass_OnClientReceivedData(ClientReceivedDataArgs receivedDataArgs)
        {
            OnClientReceivedData?.Invoke(receivedDataArgs);
        }
        /// <summary>
        /// Called when server receives data.
        /// </summary>
        public override event Action<ServerReceivedDataArgs> OnServerReceivedData;
        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs"></param>
        private void Multipass_OnServerReceivedData(ServerReceivedDataArgs receivedDataArgs)
        {
            int multipassId;
            if (!GetMultipassId(receivedDataArgs.TransportIndex, receivedDataArgs.ConnectionId, out multipassId))
                return;

            receivedDataArgs.ConnectionId = multipassId;
            OnServerReceivedData?.Invoke(receivedDataArgs);
        }
        #endregion

        #region Sending.
        /// <summary>
        /// Sends to the server on ClientTransport.
        /// </summary>
        /// <param name="channelId">Channel to use.</param>
        /// /// <param name="segment">Data to send.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override void SendToServer(byte channelId, ArraySegment<byte> segment)
        {
            if (ClientTransport != null)
                ClientTransport.SendToServer(channelId, segment);
        }
        /// <summary>
        /// Sends data to a client.
        /// </summary>
        /// <param name="channelId"></param>
        /// <param name="segment"></param>
        /// <param name="connectionId"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override void SendToClient(byte channelId, ArraySegment<byte> segment, int connectionId)
        {
            TransportIdData data;
            if (GetTransportIdData(connectionId, out data))
                _transports[data.TransportIndex].SendToClient(channelId, segment, data.TransportId);
        }
        #endregion

        #region Configuration.
        /// <summary>
        /// Returns if GlobalServerActions is true and if not logs an error.
        /// </summary>
        /// <returns></returns>
        private bool UseGlobalServerActionsWithError(string methodText)
        {
            if (!GlobalServerActions)
            {
                base.NetworkManager.LogError($"Method {methodText} is not supported while GlobalServerActions is false.");
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Returns if ClientTransport is set and if not logs an error.
        /// </summary>
        /// <param name="methodText"></param>
        /// <returns></returns>
        private bool IsClientTransportSetWithError(string methodText)
        {
            if (ClientTransport == null)
            {
                base.NetworkManager.LogError($"ClientTransport is not set. Use SetClientTransport before calling {methodText}.");
                return false;
            }
            else
            {
                return true;
            }
        }
        /// <summary>
        /// Populates the availableIds collection.
        /// </summary>
        private void CreateAvailableIds()
        {
            _availableIds.Clear();
            for (int i = 0; i < short.MaxValue; i++)
                _availableIds.Enqueue(i);
        }

        /// <summary>
        /// Sets the client transport to the first of type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        public void SetClientTransport<T>()
        {
            int index = -1;
            for (int i = 0; i < _transports.Count; i++)
            {
                if (_transports[i].GetType() == typeof(T))
                {
                    index = i;
                    break;
                }
            }

            SetClientTransport(index);
        }

        /// <summary>
        /// Sets the client transport to the first of type T.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        public void SetClientTransport(Type type)
        {
            int index = -1;
            for (int i = 0; i < _transports.Count; i++)
            {
                if (_transports[i].GetType() == type)
                {
                    index = i;
                    break;
                }
            }

            SetClientTransport(index);
        }
        /// <summary>
        /// Sets the client transport to the matching reference of transport.
        /// </summary>
        /// <param name="transport"></param>
        public void SetClientTransport(Transport transport)
        {
            int index = -1;
            for (int i = 0; i < _transports.Count; i++)
            {
                if (_transports[i] == transport)
                {
                    index = i;
                    break;
                }
            }

            SetClientTransport(index);
        }
        /// <summary>
        /// Sets the client transport to the transport on index.
        /// </summary>
        /// <param name="index"></param>
        public void SetClientTransport(int index)
        {
            if (!IndexInRange(index, true))
                return;

            ClientTransport = _transports[index];
        }
        /// <summary>
        /// Gets the Transport on index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public Transport GetTransport(int index)
        {
            if (!IndexInRange(index, true))
                return null;

            return _transports[index];
        }
        /// <summary>
        /// Gets the Transport on of type T.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public T GetTransport<T>()
        {
            foreach (Transport t in _transports)
            {
                if (t.GetType() == typeof(T))
                    return (T)(object)t;
            }

            return default(T);
        }
        /// <summary>
        /// Returns if the transport for connectionId is a local transport.
        /// While true several security checks are disabled.
        /// </summary>
        public override bool IsLocalTransport(int connectionid)
        {
            //If able to get transport data return value from transport.
            if (GetTransportIdData(connectionid, out TransportIdData data))
                return _transports[data.TransportIndex].IsLocalTransport(data.TransportId);
            //Otherwise return false forcing checks.
            else
                return false;
        }

        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// The first transport is used.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetMaximumClients()
        {
            base.NetworkManager.LogError($"This method is not supported. Use GetMaximumClients(transportIndex) instead.");

            return -1;
        }
        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// The first transport is used.
        /// </summary>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetMaximumClients(int transportIndex)
        {
            if (!IndexInRange(transportIndex, true))
                return -1;

            return _transports[transportIndex].GetMaximumClients();
        }
        /// <summary>
        /// Sets maximum number of clients allowed to connect to the server. If applied at runtime and clients exceed this value existing clients will stay connected but new clients may not connect.
        /// This sets the value to the transport on the first index.
        /// </summary>
        /// <param name="value"></param>
        public override void SetMaximumClients(int value)
        {
            base.NetworkManager.LogError($"This method is not supported. Use SetMaximumClients(value, transportIndex) instead.");
        }
        /// <summary>
        /// Sets maximum number of clients allowed to connect to the server. If applied at runtime and clients exceed this value existing clients will stay connected but new clients may not connect.
        /// This sets the value to the transport on index.
        /// </summary>
        /// <param name="value"></param>
        public void SetMaximumClients(int value, int transportIndex)
        {
            if (!IndexInRange(transportIndex, true))
                return;

            _transports[transportIndex].SetMaximumClients(value);
        }
        /// <summary>
        /// Sets which address the client will connect to.
        /// This will set the address for every transport.
        /// </summary>
        /// <param name="address"></param>
        public override void SetClientAddress(string address)
        {
            foreach (Transport t in _transports)
                t.SetClientAddress(address);
        }
        public override void SetServerBindAddress(string address, IPAddressType addressType)
        {
            base.NetworkManager.LogError($"This method is not supported. Use SetServerBindAddress(address, transportIndex) instead.");
        }
        /// Sets which address the server will bind to.
        /// This is called on the transport of index.
        /// </summary>
        /// <param name="address"></param>
        public void SetServerBindAddress(string address, IPAddressType addressType, int index)
        {
            if (!IndexInRange(index, true))
                return;

            _transports[index].SetServerBindAddress(address, addressType);
        }
        /// <summary>
        /// Sets which port to use on the first transport.
        /// </summary>
        public override void SetPort(ushort port)
        {
            base.NetworkManager.LogError($"This method is not supported. Use SetPort(port, transportIndex) instead.");
        }
        /// <summary>
        /// Sets which port to use on transport of index.
        /// </summary>
        public void SetPort(ushort port, int index)
        {
            if (!IndexInRange(index, true))
                return;

            _transports[index].SetPort(port);
        }
        #endregion

        #region Start and stop.
        /// <summary>
        /// Starts the local server or client using configured settings on the first transport.
        /// </summary>
        /// <param name="server">True to start server.</param>
        public override bool StartConnection(bool server)
        {
            //Server.
            if (server)
            {
                if (!UseGlobalServerActionsWithError("StartConnection"))
                    return false;

                bool success = true;
                for (int i = 0; i < _transports.Count; i++)
                {
                    if (!StartConnection(true, i))
                        success = false;
                }

                return success;
            }
            //Client.
            else
            {
                if (IsClientTransportSetWithError("StartConnection"))
                    return StartConnection(false, ClientTransport.Index);
                else
                    return false;
            }
        }

        /// <summary>
        /// Starts the local server or client using configured settings on transport of index.
        /// </summary>
        /// <param name="server">True to start server.</param>
        public bool StartConnection(bool server, int index)
        {
            if (server)
            {
                return StartServer(index);
            }
            else
            {
                if (IsClientTransportSetWithError("StartConnection"))
                    return StartClient();
                else
                    return false;
            }
        }

        /// <summary>
        /// Stops the local server or client on the first transport.
        /// </summary>
        /// <param name="server">True to stop server.</param>
        public override bool StopConnection(bool server)
        {
            //Server
            if (server)
            {
                if (!UseGlobalServerActionsWithError("StopConnection"))
                    return false;

                bool success = true;
                for (int i = 0; i < _transports.Count; i++)
                {
                    if (!StopConnection(true, i))
                        success = false;
                }

                return success;
            }
            //Client.
            else
            {
                if (IsClientTransportSetWithError("StopConnection"))
                    return StopConnection(false, ClientTransport.Index);
                else
                    return false;
            }
        }
        /// <summary>
        /// Stops the local server or client on transport of index.
        /// </summary>
        /// <param name="server">True to stop server.</param>
        public bool StopConnection(bool server, int index)
        {
            if (server)
            {
                return StopServer(index);
            }
            else
            {
                if (IsClientTransportSetWithError("StopConnection"))
                    return StopClient();
                else
                    return false;
            }
        }

        /// <summary>
        /// Stops a remote client from the server, disconnecting the client.
        /// </summary>
        /// <param name="connectionId">ConnectionId of the client to disconnect.</param>
        /// <param name="immediately">True to abrutly stp the client socket without waiting socket thread.</param>
        public override bool StopConnection(int connectionId, bool immediately)
        {
            return StopClient(connectionId, immediately);
        }

        /// <summary>
        /// Stops the server connection on transportIndex.
        /// </summary>
        /// <param name="sendDisconnectMessage">True to send a disconnect message to connections before stopping them.</param>
        /// <param name="transportIndex">Index of transport to stop on.</param>
        public bool StopServerConnection(bool sendDisconnectMessage, int transportIndex)
        {
            if (sendDisconnectMessage)
            {
                //Get connectionIds as ServerManager knows them.
                int[] multipassIds = _transportToMultipass[transportIndex].Keys.ToArray();
                //Tell serve manager to write disconnect for those ids.
                base.NetworkManager.ServerManager.SendDisconnectMessages(multipassIds);
                //Iterate outgoing on transport which is being stopped.
                _transports[transportIndex].IterateOutgoing(true);
            }

            return StopConnection(true, transportIndex);
        }

        /// <summary>
        /// Stops both client and server on all transports.
        /// </summary>
        public override void Shutdown()
        {
            foreach (Transport t in _transports)
            {
                //Stops client then server connections.
                t.StopConnection(false);
                t.StopConnection(true);
            }
        }

        #region Privates.
        /// <summary>
        /// Starts server of transport on index.
        /// </summary>
        /// <returns>True if there were no blocks. A true response does not promise a socket will or has connected.</returns>
        private bool StartServer(int index)
        {
            if (!IndexInRange(index, true))
                return false;

            return _transports[index].StartConnection(true);
        }

        /// <summary>
        /// Stops server of transport on index.
        /// </summary>
        private bool StopServer(int index)
        {
            if (!IndexInRange(index, true))
                return false;

            return _transports[index].StopConnection(true);
        }

        /// <summary>
        /// Starts the client on ClientTransport.
        /// </summary>
        /// <param name="address"></param>
        /// <returns>True if there were no blocks. A true response does not promise a socket will or has connected.</returns>
        private bool StartClient()
        {
            return ClientTransport.StartConnection(false);
        }

        /// <summary>
        /// Stops the client on ClientTransport.
        /// </summary>
        private bool StopClient()
        {
            return ClientTransport.StopConnection(false);
        }

        /// <summary>
        /// Stops a remote client on the server.
        /// </summary>
        /// <param name="connectionId"></param>
        /// <param name="immediately">True to abrutly stp the client socket without waiting socket thread.</param>
        private bool StopClient(int connectionId, bool immediately)
        {
            TransportIdData data;
            if (!GetTransportIdData(connectionId, out data))
                return false;

            return _transports[data.TransportIndex].StopConnection(connectionId, immediately);
        }
        #endregion
        #endregion

        #region Channels.
        /// <summary>
        /// Gets the MTU for a channel on the first transport. This should take header size into consideration.
        /// For example, if MTU is 1200 and a packet header for this channel is 10 in size, this method should return 1190.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        public override int GetMTU(byte channel)
        {
            return GetMTU(channel, 0);
        }
        /// <summary>
        /// Gets the MTU for a channel of transport on index. This should take header size into consideration.
        /// For example, if MTU is 1200 and a packet header for this channel is 10 in size, this method should return 1190.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        public int GetMTU(byte channel, int index)
        {
            if (!IndexInRange(index, true))
                return -1;

            return _transports[index].GetMTU(channel);
        }

        #endregion

        #region Misc.
        /// <summary>
        /// Returns if an index is within range of the Transports collection.
        /// </summary>
        private bool IndexInRange(int index, bool error)
        {
            if (index >= _transports.Count || index < 0)
            {
                if (error)
                    base.NetworkManager.LogError($"Index of {index} is out of Transports range.");
                return false;
            }
            else
            {
                return true;
            }
        }

        //perf change events to direct calls in transports.
        public override void HandleServerConnectionState(ServerConnectionStateArgs connectionStateArgs) { }
        public override void HandleRemoteConnectionState(RemoteConnectionStateArgs connectionStateArgs) { }
        public override void HandleClientReceivedDataArgs(ClientReceivedDataArgs receivedDataArgs) { }
        public override void HandleServerReceivedDataArgs(ServerReceivedDataArgs receivedDataArgs) { }
        public override void HandleClientConnectionState(ClientConnectionStateArgs connectionStateArgs) { }
        #endregion

    }
}
'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Multipass/VERSION.txt ---
1.0.0
'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/Core/ClientSocket.cs ---
using FishNet.Managing.Logging;
using LiteNetLib;
using LiteNetLib.Layers;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using UnityEngine;

namespace FishNet.Transporting.Tugboat.Client
{
    public class ClientSocket : CommonSocket
    {
        ~ClientSocket()
        {
            StopConnection();
        }

        #region Private.
        #region Configuration.
        /// <summary>
        /// Address to bind server to.
        /// </summary>
        private string _address = string.Empty;
        /// <summary>
        /// Port used by server.
        /// </summary>
        private ushort _port;
        /// <summary>
        /// MTU sizes for each channel.
        /// </summary>
        private int _mtu;
        #endregion
        #region Queues.
        /// <summary>
        /// Changes to the sockets local connection state.
        /// </summary>
        private Queue<LocalConnectionState> _localConnectionStates = new Queue<LocalConnectionState>();
        /// <summary>
        /// Inbound messages which need to be handled.
        /// </summary>
        private Queue<Packet> _incoming = new Queue<Packet>();
        /// <summary>
        /// Outbound messages which need to be handled.
        /// </summary>
        private Queue<Packet> _outgoing = new Queue<Packet>();
        #endregion
        /// <summary>
        /// Client socket manager.
        /// </summary>
        private NetManager _client;
        /// <summary>
        /// How long in seconds until client times from server.
        /// </summary>
        private int _timeout;
        /// <summary>
        /// PacketLayer to use with LiteNetLib.
        /// </summary>
        private PacketLayerBase _packetLayer;
        /// <summary>
        /// Locks the NetManager to stop it.
        /// </summary>
        private readonly object _stopLock = new object();
        #endregion

        /// <summary>
        /// Initializes this for use.
        /// </summary>
        /// <param name="t"></param>
        internal void Initialize(Transport t, int unreliableMTU, PacketLayerBase packetLayer)
        {
            base.Transport = t;
            _mtu = unreliableMTU;
            _packetLayer = packetLayer;
        }

        /// <summary>
        /// Updates the Timeout value as seconds.
        /// </summary>
        internal void UpdateTimeout(int timeout)
        {
            _timeout = timeout;
            base.UpdateTimeout(_client, timeout);
        }

        /// <summary>
        /// Threaded operation to process client actions.
        /// </summary>
        private void ThreadedSocket()
        {
            EventBasedNetListener listener = new EventBasedNetListener();
            listener.NetworkReceiveEvent += Listener_NetworkReceiveEvent;
            listener.PeerConnectedEvent += Listener_PeerConnectedEvent;
            listener.PeerDisconnectedEvent += Listener_PeerDisconnectedEvent;

            _client = new NetManager(listener, _packetLayer);
            _client.MtuOverride = (_mtu + NetConstants.FragmentedHeaderTotalSize);

            UpdateTimeout(_timeout);

            _localConnectionStates.Enqueue(LocalConnectionState.Starting);
            _client.Start();
            _client.Connect(_address, _port, string.Empty);
        }

        /// <summary>
        /// Stops the socket on a new thread.
        /// </summary>
        private void StopSocketOnThread()
        {
            if (_client == null)
                return;

            Task t = Task.Run(() =>
            {
                lock (_stopLock)
                {
                    _client?.Stop();
                    _client = null;
                }

                //If not stopped yet also enqueue stop.
                if (base.GetConnectionState() != LocalConnectionState.Stopped)
                    _localConnectionStates.Enqueue(LocalConnectionState.Stopped);
            });
        }

        /// <summary>
        /// Starts the client connection.
        /// </summary>
        /// <param name="address"></param>
        /// <param name="port"></param>
        /// <param name="channelsCount"></param>
        /// <param name="pollTime"></param>
        internal bool StartConnection(string address, ushort port)
        {
            if (base.GetConnectionState() != LocalConnectionState.Stopped)
                return false;

            base.SetConnectionState(LocalConnectionState.Starting, false);

            //Assign properties.
            _port = port;
            _address = address;

            ResetQueues();
            Task t = Task.Run(() => ThreadedSocket());

            return true;
        }

        /// <summary>
        /// Stops the local socket.
        /// </summary>
        internal bool StopConnection(DisconnectInfo? info = null)
        {
            if (base.GetConnectionState() == LocalConnectionState.Stopped || base.GetConnectionState() == LocalConnectionState.Stopping)
                return false;

            if (info != null && base.Transport.NetworkManager.CanLog(LoggingType.Common))
                Debug.Log($"Local client disconnect reason: {info.Value.Reason}.");

            base.SetConnectionState(LocalConnectionState.Stopping, false);
            StopSocketOnThread();
            return true;
        }

        /// <summary>
        /// Resets queues.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ResetQueues()
        {
            _localConnectionStates.Clear();
            base.ClearPacketQueue(ref _incoming);
            base.ClearPacketQueue(ref _outgoing);
        }

        /// <summary>
        /// Called when disconnected from the server.
        /// </summary>
        private void Listener_PeerDisconnectedEvent(NetPeer peer, DisconnectInfo disconnectInfo)
        {
            StopConnection(disconnectInfo);
        }

        /// <summary>
        /// Called when connected to the server.
        /// </summary>
        private void Listener_PeerConnectedEvent(NetPeer peer)
        {
            _localConnectionStates.Enqueue(LocalConnectionState.Started);
        }

        /// <summary>
        /// Called when data is received from a peer.
        /// </summary>
        private void Listener_NetworkReceiveEvent(NetPeer fromPeer, NetPacketReader reader, byte channel, DeliveryMethod deliveryMethod)
        {
            base.Listener_NetworkReceiveEvent(_incoming, fromPeer, reader, deliveryMethod, _mtu);
        }

        /// <summary>
        /// Dequeues and processes outgoing.
        /// </summary>
        private void DequeueOutgoing()
        {
            NetPeer peer = null;
            if (_client != null)
                peer = _client.FirstPeer;
            //Server connection hasn't been made.
            if (peer == null)
            {
                /* Only dequeue outgoing because other queues might have
                * relevant information, such as the local connection queue. */
                base.ClearPacketQueue(ref _outgoing);
            }
            else
            {
                int count = _outgoing.Count;
                for (int i = 0; i < count; i++)
                {
                    Packet outgoing = _outgoing.Dequeue();

                    ArraySegment<byte> segment = outgoing.GetArraySegment();
                    DeliveryMethod dm = (outgoing.Channel == (byte)Channel.Reliable) ?
                         DeliveryMethod.ReliableOrdered : DeliveryMethod.Unreliable;

                    //If over the MTU.
                    if (outgoing.Channel == (byte)Channel.Unreliable && segment.Count > _mtu)
                    {
                        if (base.Transport.NetworkManager.CanLog(LoggingType.Warning))
                            Debug.LogWarning($"Client is sending of {segment.Count} length on the unreliable channel, while the MTU is only {_mtu}. The channel has been changed to reliable for this send.");
                        dm = DeliveryMethod.ReliableOrdered;
                    }

                    peer.Send(segment.Array, segment.Offset, segment.Count, dm);

                    outgoing.Dispose();
                }
            }
        }

        /// <summary>
        /// Allows for Outgoing queue to be iterated.
        /// </summary>
        internal void IterateOutgoing()
        {
            DequeueOutgoing();
        }

        /// <summary>
        /// Iterates the Incoming queue.
        /// </summary>
        internal void IterateIncoming()
        {
            _client?.PollEvents();

            /* Run local connection states first so we can begin
            * to read for data at the start of the frame, as that's
            * where incoming is read. */
            while (_localConnectionStates.Count > 0)
                base.SetConnectionState(_localConnectionStates.Dequeue(), false);

            //Not yet started, cannot continue.
            LocalConnectionState localState = base.GetConnectionState();
            if (localState != LocalConnectionState.Started)
            {
                ResetQueues();
                //If stopped try to kill task.
                if (localState == LocalConnectionState.Stopped)
                {
                    StopSocketOnThread();
                    return;
                }
            }

            /* Incoming. */
            while (_incoming.Count > 0)
            {
                Packet incoming = _incoming.Dequeue();
                ClientReceivedDataArgs dataArgs = new ClientReceivedDataArgs(
                    incoming.GetArraySegment(),
                    (Channel)incoming.Channel, base.Transport.Index);
                base.Transport.HandleClientReceivedDataArgs(dataArgs);
                //Dispose of packet.
                incoming.Dispose();
            }
        }

        /// <summary>
        /// Sends a packet to the server.
        /// </summary>
        internal void SendToServer(byte channelId, ArraySegment<byte> segment)
        {
            //Not started, cannot send.
            if (base.GetConnectionState() != LocalConnectionState.Started)
                return;

            base.Send(ref _outgoing, channelId, segment, -1, _mtu);
        }

    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/Core/CommonSocket.cs ---
﻿using FishNet.Utility.Performance;
using LiteNetLib;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;

namespace FishNet.Transporting.Tugboat
{

    public abstract class CommonSocket
    {

        #region Public.
        /// <summary>
        /// Current ConnectionState.
        /// </summary>
        private LocalConnectionState _connectionState = LocalConnectionState.Stopped;
        /// <summary>
        /// Returns the current ConnectionState.
        /// </summary>
        /// <returns></returns>
        internal LocalConnectionState GetConnectionState()
        {
            return _connectionState;
        }
        /// <summary>
        /// Sets a new connection state.
        /// </summary>
        /// <param name="connectionState"></param>
        protected void SetConnectionState(LocalConnectionState connectionState, bool asServer)
        {
            //If state hasn't changed.
            if (connectionState == _connectionState)
                return;

            _connectionState = connectionState;
            if (asServer)
                Transport.HandleServerConnectionState(new ServerConnectionStateArgs(connectionState, Transport.Index));
            else
                Transport.HandleClientConnectionState(new ClientConnectionStateArgs(connectionState, Transport.Index));
        }
        #endregion

        #region Protected.
        /// <summary>
        /// Transport controlling this socket.
        /// </summary>
        protected Transport Transport = null;
        #endregion

        /// <summary>
        /// Sends data to connectionId.
        /// </summary>
        internal void Send(ref Queue<Packet> queue, byte channelId, ArraySegment<byte> segment, int connectionId, int mtu)
        {
            if (GetConnectionState() != LocalConnectionState.Started)
                return;

            //ConnectionId isn't used from client to server.
            Packet outgoing = new Packet(connectionId, segment, channelId, mtu);
            queue.Enqueue(outgoing);
        }

        /// <summary>
        /// Updates the timeout for NetManager.
        /// </summary>
        protected void UpdateTimeout(NetManager netManager, int timeout)
        {
            if (netManager == null)
                return;
            
            timeout = (timeout == 0) ? int.MaxValue : Math.Min(int.MaxValue, (timeout * 1000));
            netManager.DisconnectTimeout = timeout;
        }
        /// <summary>
        /// Clears a queue using Packet type.
        /// </summary>
        /// <param name="queue"></param>
        internal void ClearPacketQueue(ref ConcurrentQueue<Packet> queue)
        {
            while (queue.TryDequeue(out Packet p))
                p.Dispose();
        }

        /// <summary>
        /// Clears a queue using Packet type.
        /// </summary>
        /// <param name="queue"></param>
        internal void ClearPacketQueue(ref Queue<Packet> queue)
        {
            int count = queue.Count;
            for (int i = 0; i < count; i++)
            {
                Packet p = queue.Dequeue();
                p.Dispose();
            }
        }

        /// <summary>
        /// Called when data is received.
        /// </summary>
        internal virtual void Listener_NetworkReceiveEvent(Queue<Packet> queue,  NetPeer fromPeer, NetPacketReader reader, DeliveryMethod deliveryMethod, int mtu)
        {
            //Set buffer.
            int dataLen = reader.AvailableBytes;
            //Prefer to max out returned array to mtu to reduce chance of resizing.
            int arraySize = Math.Max(dataLen, mtu);
            byte[] data = ByteArrayPool.Retrieve(arraySize);
            reader.GetBytes(data, dataLen);
            //Id.
            int id = fromPeer.Id;
            //Channel.
            byte channel = (deliveryMethod == DeliveryMethod.Unreliable) ?
                (byte)Channel.Unreliable : (byte)Channel.Reliable;
            //Add to packets.
            Packet packet = new Packet(id, data, dataLen, channel);
            queue.Enqueue(packet);
            //Recycle reader.
            reader.Recycle();
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/Core/ServerSocket.cs ---
using FishNet.Managing.Logging;
using LiteNetLib;
using LiteNetLib.Layers;
using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using UnityEngine;

namespace FishNet.Transporting.Tugboat.Server
{
    public class ServerSocket : CommonSocket
    {

        #region Public.
        /// <summary>
        /// Gets the current ConnectionState of a remote client on the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        internal RemoteConnectionState GetConnectionState(int connectionId)
        {
            NetPeer peer = GetNetPeer(connectionId, false);
            if (peer == null || peer.ConnectionState != ConnectionState.Connected)
                return RemoteConnectionState.Stopped;
            else
                return RemoteConnectionState.Started;
        }
        #endregion

        #region Private.
        #region Configuration.
        /// <summary>
        /// Port used by server.
        /// </summary>
        private ushort _port;
        /// <summary>
        /// Maximum number of allowed clients.
        /// </summary>
        private int _maximumClients;
        /// <summary>
        /// MTU size per packet.
        /// </summary>
        private int _mtu;
        #endregion
        #region Queues.
        /// <summary>
        /// Changes to the sockets local connection state.
        /// </summary>
        private Queue<LocalConnectionState> _localConnectionStates = new Queue<LocalConnectionState>();
        /// <summary>
        /// Inbound messages which need to be handled.
        /// </summary>
        private Queue<Packet> _incoming = new Queue<Packet>();
        /// <summary>
        /// Outbound messages which need to be handled.
        /// </summary>
        private Queue<Packet> _outgoing = new Queue<Packet>();
        /// <summary>
        /// ConnectionEvents which need to be handled.
        /// </summary>
        private Queue<RemoteConnectionEvent> _remoteConnectionEvents = new Queue<RemoteConnectionEvent>();
        #endregion
        /// <summary>
        /// Key required to connect.
        /// </summary>
        private string _key = string.Empty;
        /// <summary>
        /// How long in seconds until client times from server.
        /// </summary>
        private int _timeout;
        /// <summary>
        /// Server socket manager.
        /// </summary>
        private NetManager _server;
        /// <summary>
        /// IPv4 address to bind server to.
        /// </summary>
        private string _ipv4BindAddress;
        /// <summary>
        /// IPv6 address to bind server to.
        /// </summary>
        private string _ipv6BindAddress;
        /// <summary>
        /// PacketLayer to use with LiteNetLib.
        /// </summary>
        private PacketLayerBase _packetLayer;
        /// <summary>
        /// Locks the NetManager to stop it.
        /// </summary>
        private readonly object _stopLock = new object();
        #endregion

        ~ServerSocket()
        {
            StopConnection();
        }

        /// <summary>
        /// Initializes this for use.
        /// </summary>
        /// <param name="t"></param>
        internal void Initialize(Transport t, int unreliableMTU, PacketLayerBase packetLayer)
        {
            base.Transport = t;
            _mtu = unreliableMTU;
            _packetLayer = packetLayer;
        }

        /// <summary>
        /// Updates the Timeout value as seconds.
        /// </summary>
        internal void UpdateTimeout(int timeout)
        {
            _timeout = timeout;
            base.UpdateTimeout(_server, timeout);
        }

        /// <summary>
        /// Threaded operation to process server actions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ThreadedSocket()
        {
            EventBasedNetListener listener = new EventBasedNetListener();
            listener.ConnectionRequestEvent += Listener_ConnectionRequestEvent;
            listener.PeerConnectedEvent += Listener_PeerConnectedEvent;
            listener.NetworkReceiveEvent += Listener_NetworkReceiveEvent;
            listener.PeerDisconnectedEvent += Listener_PeerDisconnectedEvent;

            _server = new NetManager(listener, _packetLayer);
            _server.MtuOverride = (_mtu + NetConstants.FragmentedHeaderTotalSize);

            UpdateTimeout(_timeout);

            //Set bind addresses.
            IPAddress ipv4;
            IPAddress ipv6;
            //Set ipv4
            if (!string.IsNullOrEmpty(_ipv4BindAddress))
            {
                if (!IPAddress.TryParse(_ipv4BindAddress, out ipv4))
                    ipv4 = null;
            }
            else
            {
                IPAddress.TryParse("0.0.0.0", out ipv4);
            }
            //Set ipv6.
            if (!string.IsNullOrEmpty(_ipv6BindAddress))
            {
                if (!IPAddress.TryParse(_ipv6BindAddress, out ipv6))
                    ipv6 = null;
            }
            else
            {
                IPAddress.TryParse("0:0:0:0:0:0:0:0", out ipv6);
            }

            string ipv4FailText = (ipv4 == null) ? $"IPv4 address {_ipv4BindAddress} failed to parse. " : string.Empty;
            string ipv6FailText = (ipv6 == null) ? $"IPv6 address {_ipv6BindAddress} failed to parse. " : string.Empty;
            if (ipv4FailText != string.Empty || ipv6FailText != string.Empty)
            {
                if (base.Transport.NetworkManager.CanLog(LoggingType.Error))
                    Debug.Log($"{ipv4FailText}{ipv6FailText}Clear the bind address field to use any bind address.");

                StopConnection();
                return;
            }

            bool startResult = _server.Start(ipv4, ipv6, _port);
            //If started succcessfully.
            if (startResult)
            {
                _localConnectionStates.Enqueue(LocalConnectionState.Started);
            }
            //Failed to start.
            else
            {
                if (base.Transport.NetworkManager.CanLog(LoggingType.Error))
                    Debug.LogError($"Server failed to start. This usually occurs when the specified port is unavailable, be it closed or already in use.");

                StopConnection();
            }
        }

        /// <summary>
        /// Stops the socket on a new thread.
        /// </summary>
        private void StopSocketOnThread()
        {
            if (_server == null)
                return;

            Task t = Task.Run(() =>
            {
                lock (_stopLock)
                {
                    _server?.Stop();
                    _server = null;
                }

                //If not stopped yet also enqueue stop.
                if (base.GetConnectionState() != LocalConnectionState.Stopped)
                    _localConnectionStates.Enqueue(LocalConnectionState.Stopped);
            });
        }

        /// <summary>
        /// Gets the address of a remote connection Id.
        /// </summary>
        /// <param name="connectionId"></param>
        /// <returns>Returns string.empty if Id is not found.</returns>
        internal string GetConnectionAddress(int connectionId)
        {
            NetPeer peer = GetNetPeer(connectionId, false);
            return peer.EndPoint.Address.ToString();
        }

        /// <summary>
        /// Returns a NetPeer for connectionId.
        /// </summary>
        /// <param name="connectionId"></param>
        /// <returns></returns>
        private NetPeer GetNetPeer(int connectionId, bool connectedOnly)
        {
            NetPeer peer = null;
            if (_server != null)
            {
                if (connectionId >= 0 || connectionId < _server.ConnectedPeersCount)
                    peer = _server.GetPeerById(connectionId);
                if (connectedOnly && peer != null && peer.ConnectionState != ConnectionState.Connected)
                    peer = null;
            }

            return peer;
        }

        /// <summary>
        /// Starts the server.
        /// </summary>
        internal bool StartConnection(ushort port, int maximumClients, string ipv4BindAddress, string ipv6BindAddress)
        {
            if (base.GetConnectionState() != LocalConnectionState.Stopped)
                return false;

            base.SetConnectionState(LocalConnectionState.Starting, true);

            //Assign properties.
            _port = port;
            _maximumClients = maximumClients;
            _ipv4BindAddress = ipv4BindAddress;
            _ipv6BindAddress = ipv6BindAddress;
            ResetQueues();

            Task t = Task.Run(() => ThreadedSocket());

            return true;
        }

        /// <summary>
        /// Stops the local socket.
        /// </summary>
        internal bool StopConnection()
        {
            if (_server == null || base.GetConnectionState() == LocalConnectionState.Stopped || base.GetConnectionState() == LocalConnectionState.Stopping)
                return false;

            _localConnectionStates.Enqueue(LocalConnectionState.Stopping);
            StopSocketOnThread();
            return true;
        }

        /// <summary>
        /// Stops a remote client disconnecting the client from the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId of the client to disconnect.</param>
        internal bool StopConnection(int connectionId)
        {
            //Server isn't running.
            if (_server == null || base.GetConnectionState() != LocalConnectionState.Started)
                return false;

            NetPeer peer = GetNetPeer(connectionId, false);
            if (peer == null)
                return false;

            try
            {
                peer.Disconnect();
                //Let LiteNetLib get the disconnect event which will enqueue a remote connection state.
                //base.Transport.HandleRemoteConnectionState(new RemoteConnectionStateArgs(RemoteConnectionState.Stopped, connectionId, base.Transport.Index));
            }
            catch
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Resets queues.
        /// </summary>
        private void ResetQueues()
        {
            _localConnectionStates.Clear();
            base.ClearPacketQueue(ref _incoming);
            base.ClearPacketQueue(ref _outgoing);
            _remoteConnectionEvents.Clear();
        }

        /// <summary>
        /// Called when a peer disconnects or times out.
        /// </summary>
        private void Listener_PeerDisconnectedEvent(NetPeer peer, DisconnectInfo disconnectInfo)
        {
            _remoteConnectionEvents.Enqueue(new RemoteConnectionEvent(false, peer.Id));
        }

        /// <summary>
        /// Called when a peer completes connection.
        /// </summary>
        private void Listener_PeerConnectedEvent(NetPeer peer)
        {
            _remoteConnectionEvents.Enqueue(new RemoteConnectionEvent(true, peer.Id));
        }

        /// <summary>
        /// Called when data is received from a peer.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Listener_NetworkReceiveEvent(NetPeer fromPeer, NetPacketReader reader, byte channel, DeliveryMethod deliveryMethod)
        {
            //If over the MTU.
            if (reader.AvailableBytes > _mtu)
            {
                _remoteConnectionEvents.Enqueue(new RemoteConnectionEvent(false, fromPeer.Id));
                fromPeer.Disconnect();
            }
            else
            {
                base.Listener_NetworkReceiveEvent(_incoming, fromPeer, reader, deliveryMethod, _mtu);
            }
        }

        /// <summary>
        /// Called when a remote connection request is made.
        /// </summary>
        private void Listener_ConnectionRequestEvent(ConnectionRequest request)
        {
            if (_server == null)
                return;

            //At maximum peers.
            if (_server.ConnectedPeersCount >= _maximumClients)
            {
                request.Reject();
                return;
            }

            request.AcceptIfKey(_key);
        }

        /// <summary>
        /// Dequeues and processes outgoing.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void DequeueOutgoing()
        {
            if (base.GetConnectionState() != LocalConnectionState.Started || _server == null)
            {
                //Not started, clear outgoing.
                base.ClearPacketQueue(ref _outgoing);
            }
            else
            {
                int count = _outgoing.Count;
                for (int i = 0; i < count; i++)
                {
                    Packet outgoing = _outgoing.Dequeue();
                    int connectionId = outgoing.ConnectionId;

                    ArraySegment<byte> segment = outgoing.GetArraySegment();
                    DeliveryMethod dm = (outgoing.Channel == (byte)Channel.Reliable) ?
                         DeliveryMethod.ReliableOrdered : DeliveryMethod.Unreliable;

                    //If over the MTU.
                    if (outgoing.Channel == (byte)Channel.Unreliable && segment.Count > _mtu)
                    {
                        if (base.Transport.NetworkManager.CanLog(LoggingType.Warning))
                            Debug.LogWarning($"Server is sending of {segment.Count} length on the unreliable channel, while the MTU is only {_mtu}. The channel has been changed to reliable for this send.");
                        dm = DeliveryMethod.ReliableOrdered;
                    }

                    //Send to all clients.
                    if (connectionId == -1)
                    {
                        _server.SendToAll(segment.Array, segment.Offset, segment.Count, dm);
                    }
                    //Send to one client.
                    else
                    {
                        NetPeer peer = GetNetPeer(connectionId, true);
                        //If peer is found.
                        if (peer != null)
                            peer.Send(segment.Array, segment.Offset, segment.Count, dm);
                    }

                    outgoing.Dispose();
                }
            }
        }

        /// <summary>
        /// Allows for Outgoing queue to be iterated.
        /// </summary>
        internal void IterateOutgoing()
        {
            DequeueOutgoing();
        }

        /// <summary>
        /// Iterates the Incoming queue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void IterateIncoming()
        {
            _server?.PollEvents();

            /* Run local connection states first so we can begin
             * to read for data at the start of the frame, as that's
             * where incoming is read. */
            while (_localConnectionStates.Count > 0)
                base.SetConnectionState(_localConnectionStates.Dequeue(), true);

            //Not yet started.
            LocalConnectionState localState = base.GetConnectionState();
            if (localState != LocalConnectionState.Started)
            {
                ResetQueues();
                //If stopped try to kill task.
                if (localState == LocalConnectionState.Stopped)
                {
                    StopSocketOnThread();
                    return;
                }
            }

            //Handle connection and disconnection events.
            while (_remoteConnectionEvents.Count > 0)
            {
                RemoteConnectionEvent connectionEvent = _remoteConnectionEvents.Dequeue();
                RemoteConnectionState state = (connectionEvent.Connected) ? RemoteConnectionState.Started : RemoteConnectionState.Stopped;
                base.Transport.HandleRemoteConnectionState(new RemoteConnectionStateArgs(state, connectionEvent.ConnectionId, base.Transport.Index));
            }

            //Handle packets.
            while (_incoming.Count > 0)
            {
                Packet incoming = _incoming.Dequeue();
                //Make sure peer is still connected.
                NetPeer peer = GetNetPeer(incoming.ConnectionId, true);
                if (peer != null)
                {
                    ServerReceivedDataArgs dataArgs = new ServerReceivedDataArgs(
                        incoming.GetArraySegment(),
                        (Channel)incoming.Channel,
                        incoming.ConnectionId,
                        base.Transport.Index);

                    base.Transport.HandleServerReceivedDataArgs(dataArgs);
                }

                incoming.Dispose();
            }

        }

        /// <summary>
        /// Sends a packet to a single, or all clients.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void SendToClient(byte channelId, ArraySegment<byte> segment, int connectionId)
        {
            Send(ref _outgoing, channelId, segment, connectionId, _mtu);
        }

        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// </summary>
        /// <returns></returns>
        internal int GetMaximumClients()
        {
            return _maximumClients;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/Core/Supporting.cs ---
﻿using FishNet.Utility.Performance;
using System;

namespace FishNet.Transporting.Tugboat
{

    internal struct Packet
    {
        public readonly int ConnectionId;
        public readonly byte[] Data;
        public readonly int Length;
        public readonly byte Channel;

        public Packet(int connectionId, byte[] data, int length, byte channel)
        {
            ConnectionId = connectionId;
            Data = data;
            Length = length;
            Channel = channel;
        }

        public Packet(int sender, ArraySegment<byte> segment, byte channel, int mtu)
        {
            //Prefer to max out returned array to mtu to reduce chance of resizing.
            int arraySize = Math.Max(segment.Count, mtu);
            Data = ByteArrayPool.Retrieve(arraySize);
            Buffer.BlockCopy(segment.Array, segment.Offset, Data, 0, segment.Count);
            ConnectionId = sender;
            Length = segment.Count;
            Channel = channel;
        }

        public ArraySegment<byte> GetArraySegment()
        {
            return new ArraySegment<byte>(Data, 0, Length);
        }

        public void Dispose()
        {
            ByteArrayPool.Store(Data);
        }

    }

}

namespace FishNet.Transporting.Tugboat.Server
{

    internal struct RemoteConnectionEvent
    {
        public readonly bool Connected;
        public readonly int ConnectionId;
        public RemoteConnectionEvent(bool connected, int connectionId)
        {
            Connected = connected;
            ConnectionId = connectionId;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/BaseChannel.cs ---
﻿using System.Collections.Concurrent;
using System.Threading;

namespace LiteNetLib
{
    internal abstract class BaseChannel
    {
        protected readonly NetPeer Peer;
        protected readonly ConcurrentQueue<NetPacket> OutgoingQueue;
        private int _isAddedToPeerChannelSendQueue;

        public int PacketsInQueue => OutgoingQueue.Count;

        protected BaseChannel(NetPeer peer)
        {
            Peer = peer;
            OutgoingQueue = new ConcurrentQueue<NetPacket>();
        }

        public void AddToQueue(NetPacket packet)
        {
            OutgoingQueue.Enqueue(packet);
            AddToPeerChannelSendQueue();
        }

        protected void AddToPeerChannelSendQueue()
        {
            if (Interlocked.CompareExchange(ref _isAddedToPeerChannelSendQueue, 1, 0) == 0)
            {
                Peer.AddToReliableChannelSendQueue(this);
            }
        }

        public bool SendAndCheckQueue()
        {
            bool hasPacketsToSend = SendNextPackets();
            if (!hasPacketsToSend)
                Interlocked.Exchange(ref _isAddedToPeerChannelSendQueue, 0);

            return hasPacketsToSend;
        }

        protected abstract bool SendNextPackets();
        public abstract bool ProcessPacket(NetPacket packet);
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/ConnectionRequest.cs ---
﻿using System.Net;
using System.Threading;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    internal enum ConnectionRequestResult
    {
        None,
        Accept,
        Reject,
        RejectForce
    }

    public class ConnectionRequest
    {
        private readonly NetManager _listener;
        private int _used;

        public NetDataReader Data => InternalPacket.Data;

        internal ConnectionRequestResult Result { get; private set; }
        internal NetConnectRequestPacket InternalPacket;

        public readonly IPEndPoint RemoteEndPoint;

        internal void UpdateRequest(NetConnectRequestPacket connectRequest)
        {
            //old request
            if (connectRequest.ConnectionTime < InternalPacket.ConnectionTime)
                return;

            if (connectRequest.ConnectionTime == InternalPacket.ConnectionTime &&
                connectRequest.ConnectionNumber == InternalPacket.ConnectionNumber)
                return;

            InternalPacket = connectRequest;
        }

        private bool TryActivate()
        {
            return Interlocked.CompareExchange(ref _used, 1, 0) == 0;
        }

        internal ConnectionRequest(IPEndPoint remoteEndPoint, NetConnectRequestPacket requestPacket, NetManager listener)
        {
            InternalPacket = requestPacket;
            RemoteEndPoint = remoteEndPoint;
            _listener = listener;
        }

        public NetPeer AcceptIfKey(string key)
        {
            if (!TryActivate())
                return null;
            try
            {
                if (Data.GetString() == key)
                    Result = ConnectionRequestResult.Accept;
            }
            catch
            {
                NetDebug.WriteError("[AC] Invalid incoming data");
            }
            if (Result == ConnectionRequestResult.Accept)
                return _listener.OnConnectionSolved(this, null, 0, 0);

            Result = ConnectionRequestResult.Reject;
            _listener.OnConnectionSolved(this, null, 0, 0);
            return null;
        }

        /// <summary>
        /// Accept connection and get new NetPeer as result
        /// </summary>
        /// <returns>Connected NetPeer</returns>
        public NetPeer Accept()
        {
            if (!TryActivate())
                return null;
            Result = ConnectionRequestResult.Accept;
            return _listener.OnConnectionSolved(this, null, 0, 0);
        }

        public void Reject(byte[] rejectData, int start, int length, bool force)
        {
            if (!TryActivate())
                return;
            Result = force ? ConnectionRequestResult.RejectForce : ConnectionRequestResult.Reject;
            _listener.OnConnectionSolved(this, rejectData, start, length);
        }

        public void Reject(byte[] rejectData, int start, int length)
        {
            Reject(rejectData, start, length, false);
        }

        public void RejectForce(byte[] rejectData, int start, int length)
        {
            Reject(rejectData, start, length, true);
        }

        public void RejectForce()
        {
            Reject(null, 0, 0, true);
        }

        public void RejectForce(byte[] rejectData)
        {
            Reject(rejectData, 0, rejectData.Length, true);
        }

        public void RejectForce(NetDataWriter rejectData)
        {
            Reject(rejectData.Data, 0, rejectData.Length, true);
        }

        public void Reject()
        {
            Reject(null, 0, 0, false);
        }

        public void Reject(byte[] rejectData)
        {
            Reject(rejectData, 0, rejectData.Length, false);
        }

        public void Reject(NetDataWriter rejectData)
        {
            Reject(rejectData.Data, 0, rejectData.Length, false);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/INetEventListener.cs ---
﻿using System.Net;
using System.Net.Sockets;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    /// <summary>
    /// Type of message that you receive in OnNetworkReceiveUnconnected event
    /// </summary>
    public enum UnconnectedMessageType
    {
        BasicMessage,
        Broadcast
    }

    /// <summary>
    /// Disconnect reason that you receive in OnPeerDisconnected event
    /// </summary>
    public enum DisconnectReason
    {
        ConnectionFailed,
        Timeout,
        HostUnreachable,
        NetworkUnreachable,
        RemoteConnectionClose,
        DisconnectPeerCalled,
        ConnectionRejected,
        InvalidProtocol,
        UnknownHost,
        Reconnect,
        PeerToPeerConnection,
        PeerNotFound
    }

    /// <summary>
    /// Additional information about disconnection
    /// </summary>
    public struct DisconnectInfo
    {
        /// <summary>
        /// Additional info why peer disconnected
        /// </summary>
        public DisconnectReason Reason;

        /// <summary>
        /// Error code (if reason is SocketSendError or SocketReceiveError)
        /// </summary>
        public SocketError SocketErrorCode;

        /// <summary>
        /// Additional data that can be accessed (only if reason is RemoteConnectionClose)
        /// </summary>
        public NetPacketReader AdditionalData;
    }

    public interface INetEventListener
    {
        /// <summary>
        /// New remote peer connected to host, or client connected to remote host
        /// </summary>
        /// <param name="peer">Connected peer object</param>
        void OnPeerConnected(NetPeer peer);

        /// <summary>
        /// Peer disconnected
        /// </summary>
        /// <param name="peer">disconnected peer</param>
        /// <param name="disconnectInfo">additional info about reason, errorCode or data received with disconnect message</param>
        void OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo);

        /// <summary>
        /// Network error (on send or receive)
        /// </summary>
        /// <param name="endPoint">From endPoint (can be null)</param>
        /// <param name="socketError">Socket error</param>
        void OnNetworkError(IPEndPoint endPoint, SocketError socketError);

        /// <summary>
        /// Received some data
        /// </summary>
        /// <param name="peer">From peer</param>
        /// <param name="reader">DataReader containing all received data</param>
        /// <param name="channelNumber">Number of channel at which packet arrived</param>
        /// <param name="deliveryMethod">Type of received packet</param>
        void OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channelNumber, DeliveryMethod deliveryMethod);

        /// <summary>
        /// Received unconnected message
        /// </summary>
        /// <param name="remoteEndPoint">From address (IP and Port)</param>
        /// <param name="reader">Message data</param>
        /// <param name="messageType">Message type (simple, discovery request or response)</param>
        void OnNetworkReceiveUnconnected(IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType);

        /// <summary>
        /// Latency information updated
        /// </summary>
        /// <param name="peer">Peer with updated latency</param>
        /// <param name="latency">latency value in milliseconds</param>
        void OnNetworkLatencyUpdate(NetPeer peer, int latency);

        /// <summary>
        /// On peer connection requested
        /// </summary>
        /// <param name="request">Request information (EndPoint, internal id, additional data)</param>
        void OnConnectionRequest(ConnectionRequest request);
    }

    public interface IDeliveryEventListener
    {
        /// <summary>
        /// On reliable message delivered
        /// </summary>
        /// <param name="peer"></param>
        /// <param name="userData"></param>
        void OnMessageDelivered(NetPeer peer, object userData);
    }

    public interface INtpEventListener
    {
        /// <summary>
        /// Ntp response
        /// </summary>
        /// <param name="packet"></param>
        void OnNtpResponse(NtpPacket packet);
    }

    public interface IPeerAddressChangedListener
    {
        /// <summary>
        /// Called when peer address changed (when AllowPeerAddressChange is enabled)
        /// </summary>
        /// <param name="peer">Peer that changed address (with new address)</param>
        /// <param name="previousAddress">previous IP</param>
        void OnPeerAddressChanged(NetPeer peer, IPEndPoint previousAddress);
    }

    public class EventBasedNetListener : INetEventListener, IDeliveryEventListener, INtpEventListener, IPeerAddressChangedListener
    {
        public delegate void OnPeerConnected(NetPeer peer);
        public delegate void OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo);
        public delegate void OnNetworkError(IPEndPoint endPoint, SocketError socketError);
        public delegate void OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channel, DeliveryMethod deliveryMethod);
        public delegate void OnNetworkReceiveUnconnected(IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType);
        public delegate void OnNetworkLatencyUpdate(NetPeer peer, int latency);
        public delegate void OnConnectionRequest(ConnectionRequest request);
        public delegate void OnDeliveryEvent(NetPeer peer, object userData);
        public delegate void OnNtpResponseEvent(NtpPacket packet);
        public delegate void OnPeerAddressChangedEvent(NetPeer peer, IPEndPoint previousAddress);

        public event OnPeerConnected PeerConnectedEvent;
        public event OnPeerDisconnected PeerDisconnectedEvent;
        public event OnNetworkError NetworkErrorEvent;
        public event OnNetworkReceive NetworkReceiveEvent;
        public event OnNetworkReceiveUnconnected NetworkReceiveUnconnectedEvent;
        public event OnNetworkLatencyUpdate NetworkLatencyUpdateEvent;
        public event OnConnectionRequest ConnectionRequestEvent;
        public event OnDeliveryEvent DeliveryEvent;
        public event OnNtpResponseEvent NtpResponseEvent;
        public event OnPeerAddressChangedEvent PeerAddressChangedEvent;

        public void ClearPeerConnectedEvent()
        {
            PeerConnectedEvent = null;
        }

        public void ClearPeerDisconnectedEvent()
        {
            PeerDisconnectedEvent = null;
        }

        public void ClearNetworkErrorEvent()
        {
            NetworkErrorEvent = null;
        }

        public void ClearNetworkReceiveEvent()
        {
            NetworkReceiveEvent = null;
        }

        public void ClearNetworkReceiveUnconnectedEvent()
        {
            NetworkReceiveUnconnectedEvent = null;
        }

        public void ClearNetworkLatencyUpdateEvent()
        {
            NetworkLatencyUpdateEvent = null;
        }

        public void ClearConnectionRequestEvent()
        {
            ConnectionRequestEvent = null;
        }

        public void ClearDeliveryEvent()
        {
            DeliveryEvent = null;
        }

        public void ClearNtpResponseEvent()
        {
            NtpResponseEvent = null;
        }

        public void ClearPeerAddressChangedEvent()
        {
            PeerAddressChangedEvent = null;
        }

        void INetEventListener.OnPeerConnected(NetPeer peer)
        {
            if (PeerConnectedEvent != null)
                PeerConnectedEvent(peer);
        }

        void INetEventListener.OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo)
        {
            if (PeerDisconnectedEvent != null)
                PeerDisconnectedEvent(peer, disconnectInfo);
        }

        void INetEventListener.OnNetworkError(IPEndPoint endPoint, SocketError socketErrorCode)
        {
            if (NetworkErrorEvent != null)
                NetworkErrorEvent(endPoint, socketErrorCode);
        }

        void INetEventListener.OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            if (NetworkReceiveEvent != null)
                NetworkReceiveEvent(peer, reader, channelNumber, deliveryMethod);
        }

        void INetEventListener.OnNetworkReceiveUnconnected(IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType)
        {
            if (NetworkReceiveUnconnectedEvent != null)
                NetworkReceiveUnconnectedEvent(remoteEndPoint, reader, messageType);
        }

        void INetEventListener.OnNetworkLatencyUpdate(NetPeer peer, int latency)
        {
            if (NetworkLatencyUpdateEvent != null)
                NetworkLatencyUpdateEvent(peer, latency);
        }

        void INetEventListener.OnConnectionRequest(ConnectionRequest request)
        {
            if (ConnectionRequestEvent != null)
                ConnectionRequestEvent(request);
        }

        void IDeliveryEventListener.OnMessageDelivered(NetPeer peer, object userData)
        {
            if (DeliveryEvent != null)
                DeliveryEvent(peer, userData);
        }

        void INtpEventListener.OnNtpResponse(NtpPacket packet)
        {
            if (NtpResponseEvent != null)
                NtpResponseEvent(packet);
        }

        void IPeerAddressChangedListener.OnPeerAddressChanged(NetPeer peer, IPEndPoint previousAddress)
        {
            if (PeerAddressChangedEvent != null)
                PeerAddressChangedEvent(peer, previousAddress);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/InternalPackets.cs ---
using System;
using System.Net;
using LiteNetLib.Utils;

namespace LiteNetLib
{
   internal sealed class NetConnectRequestPacket
    {
        public const int HeaderSize = 18;
        public readonly long ConnectionTime;
        public byte ConnectionNumber;
        public readonly byte[] TargetAddress;
        public readonly NetDataReader Data;
        public readonly int PeerId;

        private NetConnectRequestPacket(long connectionTime, byte connectionNumber, int localId, byte[] targetAddress, NetDataReader data)
        {
            ConnectionTime = connectionTime;
            ConnectionNumber = connectionNumber;
            TargetAddress = targetAddress;
            Data = data;
            PeerId = localId;
        }

        public static int GetProtocolId(NetPacket packet)
        {
            return BitConverter.ToInt32(packet.RawData, 1);
        }

        public static NetConnectRequestPacket FromData(NetPacket packet)
        {
            if (packet.ConnectionNumber >= NetConstants.MaxConnectionNumber)
                return null;

            //Getting connection time for peer
            long connectionTime = BitConverter.ToInt64(packet.RawData, 5);

            //Get peer id
            int peerId = BitConverter.ToInt32(packet.RawData, 13);

            //Get target address
            int addrSize = packet.RawData[HeaderSize-1];
            if (addrSize != 16 && addrSize != 28)
                return null;
            byte[] addressBytes = new byte[addrSize];
            Buffer.BlockCopy(packet.RawData, HeaderSize, addressBytes, 0, addrSize);

            // Read data and create request
            var reader = new NetDataReader(null, 0, 0);
            if (packet.Size > HeaderSize+addrSize)
                reader.SetSource(packet.RawData, HeaderSize + addrSize, packet.Size);

            return new NetConnectRequestPacket(connectionTime, packet.ConnectionNumber, peerId, addressBytes, reader);
        }

        public static NetPacket Make(NetDataWriter connectData, SocketAddress addressBytes, long connectTime, int localId)
        {
            //Make initial packet
            var packet = new NetPacket(PacketProperty.ConnectRequest, connectData.Length+addressBytes.Size);

            //Add data
            FastBitConverter.GetBytes(packet.RawData, 1, NetConstants.ProtocolId);
            FastBitConverter.GetBytes(packet.RawData, 5, connectTime);
            FastBitConverter.GetBytes(packet.RawData, 13, localId);
            packet.RawData[HeaderSize-1] = (byte)addressBytes.Size;
            for (int i = 0; i < addressBytes.Size; i++)
                packet.RawData[HeaderSize + i] = addressBytes[i];
            Buffer.BlockCopy(connectData.Data, 0, packet.RawData, HeaderSize + addressBytes.Size, connectData.Length);
            return packet;
        }
    }

    internal sealed class NetConnectAcceptPacket
    {
        public const int Size = 15;
        public readonly long ConnectionTime;
        public readonly byte ConnectionNumber;
        public readonly int PeerId;
        public readonly bool PeerNetworkChanged;

        private NetConnectAcceptPacket(long connectionTime, byte connectionNumber, int peerId, bool peerNetworkChanged)
        {
            ConnectionTime = connectionTime;
            ConnectionNumber = connectionNumber;
            PeerId = peerId;
            PeerNetworkChanged = peerNetworkChanged;
        }

        public static NetConnectAcceptPacket FromData(NetPacket packet)
        {
            if (packet.Size != Size)
                return null;

            long connectionId = BitConverter.ToInt64(packet.RawData, 1);

            //check connect num
            byte connectionNumber = packet.RawData[9];
            if (connectionNumber >= NetConstants.MaxConnectionNumber)
                return null;

            //check reused flag
            byte isReused = packet.RawData[10];
            if (isReused > 1)
                return null;

            //get remote peer id
            int peerId = BitConverter.ToInt32(packet.RawData, 11);
            if (peerId < 0)
                return null;

            return new NetConnectAcceptPacket(connectionId, connectionNumber, peerId, isReused == 1);
        }

        public static NetPacket Make(long connectTime, byte connectNum, int localPeerId)
        {
            var packet = new NetPacket(PacketProperty.ConnectAccept, 0);
            FastBitConverter.GetBytes(packet.RawData, 1, connectTime);
            packet.RawData[9] = connectNum;
            FastBitConverter.GetBytes(packet.RawData, 11, localPeerId);
            return packet;
        }
        
        public static NetPacket MakeNetworkChanged(NetPeer peer)
        {
            var packet = new NetPacket(PacketProperty.PeerNotFound, Size-1);
            FastBitConverter.GetBytes(packet.RawData, 1, peer.ConnectTime);
            packet.RawData[9] = peer.ConnectionNum;
            packet.RawData[10] = 1;
            FastBitConverter.GetBytes(packet.RawData, 11, peer.RemoteId);
            return packet;
        }
    }
}
'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Layers/Crc32cLayer.cs ---
﻿using LiteNetLib.Utils;
using System;
using System.Net;

namespace LiteNetLib.Layers
{
    public sealed class Crc32cLayer : PacketLayerBase
    {
        public Crc32cLayer() : base(CRC32C.ChecksumSize)
        {

        }

        public override void ProcessInboundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length)
        {
            if (length < NetConstants.HeaderSize + CRC32C.ChecksumSize)
            {
                NetDebug.WriteError("[NM] DataReceived size: bad!");
                //Set length to 0 to have netManager drop the packet.
                length = 0;
                return;
            }

            int checksumPoint = length - CRC32C.ChecksumSize;
            if (CRC32C.Compute(data, offset, checksumPoint) != BitConverter.ToUInt32(data, checksumPoint))
            {
                NetDebug.Write("[NM] DataReceived checksum: bad!");
                //Set length to 0 to have netManager drop the packet.
                length = 0;
                return;
            }
            length -= CRC32C.ChecksumSize;
        }

        public override void ProcessOutBoundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length)
        {
            FastBitConverter.GetBytes(data, length, CRC32C.Compute(data, offset, length));
            length += CRC32C.ChecksumSize;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Layers/PacketLayerBase.cs ---
﻿using System.Net;

namespace LiteNetLib.Layers
{
    public abstract class PacketLayerBase
    {
        public readonly int ExtraPacketSizeForLayer;

        protected PacketLayerBase(int extraPacketSizeForLayer)
        {
            ExtraPacketSizeForLayer = extraPacketSizeForLayer;
        }

        public abstract void ProcessInboundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length);
        public abstract void ProcessOutBoundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length);
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Layers/XorEncryptLayer.cs ---
﻿using System;
using System.Net;
using System.Text;

namespace LiteNetLib.Layers
{
    public class XorEncryptLayer : PacketLayerBase
    {
        private byte[] _byteKey;

        public XorEncryptLayer() : base(0)
        {

        }

        public XorEncryptLayer(byte[] key) : this()
        {
            SetKey(key);
        }

        public XorEncryptLayer(string key) : this()
        {
            SetKey(key);
        }

        public void SetKey(string key)
        {
            _byteKey = Encoding.UTF8.GetBytes(key);
        }

        public void SetKey(byte[] key)
        {
            if (_byteKey == null || _byteKey.Length != key.Length)
                _byteKey = new byte[key.Length];
            Buffer.BlockCopy(key, 0, _byteKey, 0, key.Length);
        }

        public override void ProcessInboundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length)
        {
            if (_byteKey == null)
                return;
            var cur = offset;
            for (var i = 0; i < length; i++, cur++)
            {
                data[cur] = (byte)(data[cur] ^ _byteKey[i % _byteKey.Length]);
            }
        }

        public override void ProcessOutBoundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length)
        {
            if (_byteKey == null)
                return;
            var cur = offset;
            for (var i = 0; i < length; i++, cur++)
            {
                data[cur] = (byte)(data[cur] ^ _byteKey[i % _byteKey.Length]);
            }
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NatPunchModule.cs ---
﻿using System.Collections.Concurrent;
using System.Net;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    public enum NatAddressType
    {
        Internal,
        External
    }

    public interface INatPunchListener
    {
        void OnNatIntroductionRequest(IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, string token);
        void OnNatIntroductionSuccess(IPEndPoint targetEndPoint, NatAddressType type, string token);
    }

    public class EventBasedNatPunchListener : INatPunchListener
    {
        public delegate void OnNatIntroductionRequest(IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, string token);
        public delegate void OnNatIntroductionSuccess(IPEndPoint targetEndPoint, NatAddressType type, string token);

        public event OnNatIntroductionRequest NatIntroductionRequest;
        public event OnNatIntroductionSuccess NatIntroductionSuccess;

        void INatPunchListener.OnNatIntroductionRequest(IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, string token)
        {
            if(NatIntroductionRequest != null)
                NatIntroductionRequest(localEndPoint, remoteEndPoint, token);
        }

        void INatPunchListener.OnNatIntroductionSuccess(IPEndPoint targetEndPoint, NatAddressType type, string token)
        {
            if (NatIntroductionSuccess != null)
                NatIntroductionSuccess(targetEndPoint, type, token);
        }
    }

    /// <summary>
    /// Module for UDP NAT Hole punching operations. Can be accessed from NetManager
    /// </summary>
    public sealed class NatPunchModule
    {
        struct RequestEventData
        {
            public IPEndPoint LocalEndPoint;
            public IPEndPoint RemoteEndPoint;
            public string Token;
        }

        struct SuccessEventData
        {
            public IPEndPoint TargetEndPoint;
            public NatAddressType Type;
            public string Token;
        }

        class NatIntroduceRequestPacket
        {
            public IPEndPoint Internal { get; set; }
            public string Token { get; set; }
        }

        class NatIntroduceResponsePacket
        {
            public IPEndPoint Internal { get; set; }
            public IPEndPoint External { get; set; }
            public string Token { get; set; }
        }

        class NatPunchPacket
        {
            public string Token { get; set; }
            public bool IsExternal { get; set; }
        }

        private readonly NetManager _socket;
        private readonly ConcurrentQueue<RequestEventData> _requestEvents = new ConcurrentQueue<RequestEventData>();
        private readonly ConcurrentQueue<SuccessEventData> _successEvents = new ConcurrentQueue<SuccessEventData>();
        private readonly NetDataReader _cacheReader = new NetDataReader();
        private readonly NetDataWriter _cacheWriter = new NetDataWriter();
        private readonly NetPacketProcessor _netPacketProcessor = new NetPacketProcessor(MaxTokenLength);
        private INatPunchListener _natPunchListener;
        public const int MaxTokenLength = 256;

        /// <summary>
        /// Events automatically will be called without PollEvents method from another thread
        /// </summary>
        public bool UnsyncedEvents = false;

        internal NatPunchModule(NetManager socket)
        {
            _socket = socket;
            _netPacketProcessor.SubscribeReusable<NatIntroduceResponsePacket>(OnNatIntroductionResponse);
            _netPacketProcessor.SubscribeReusable<NatIntroduceRequestPacket, IPEndPoint>(OnNatIntroductionRequest);
            _netPacketProcessor.SubscribeReusable<NatPunchPacket, IPEndPoint>(OnNatPunch);
        }

        internal void ProcessMessage(IPEndPoint senderEndPoint, NetPacket packet)
        {
            lock (_cacheReader)
            {
                _cacheReader.SetSource(packet.RawData, NetConstants.HeaderSize, packet.Size);
                _netPacketProcessor.ReadAllPackets(_cacheReader, senderEndPoint);
            }
        }

        public void Init(INatPunchListener listener)
        {
            _natPunchListener = listener;
        }

        private void Send<T>(T packet, IPEndPoint target) where T : class, new()
        {
            _cacheWriter.Reset();
            _cacheWriter.Put((byte)PacketProperty.NatMessage);
            _netPacketProcessor.Write(_cacheWriter, packet);
            _socket.SendRaw(_cacheWriter.Data, 0, _cacheWriter.Length, target);
        }

        public void NatIntroduce(
            IPEndPoint hostInternal,
            IPEndPoint hostExternal,
            IPEndPoint clientInternal,
            IPEndPoint clientExternal,
            string additionalInfo)
        {
            var req = new NatIntroduceResponsePacket
            {
                Token = additionalInfo
            };

            //First packet (server) send to client
            req.Internal = hostInternal;
            req.External = hostExternal;
            Send(req, clientExternal);

            //Second packet (client) send to server
            req.Internal = clientInternal;
            req.External = clientExternal;
            Send(req, hostExternal);
        }

        public void PollEvents()
        {
            if (UnsyncedEvents)
                return;

            if (_natPunchListener == null || (_successEvents.IsEmpty && _requestEvents.IsEmpty))
                return;

            while (_successEvents.TryDequeue(out var evt))
            {
                _natPunchListener.OnNatIntroductionSuccess(
                    evt.TargetEndPoint,
                    evt.Type,
                    evt.Token);
            }

            while (_requestEvents.TryDequeue(out var evt))
            {
                _natPunchListener.OnNatIntroductionRequest(evt.LocalEndPoint, evt.RemoteEndPoint, evt.Token);
            }
        }

        public void SendNatIntroduceRequest(string host, int port, string additionalInfo)
        {
            SendNatIntroduceRequest(NetUtils.MakeEndPoint(host, port), additionalInfo);
        }

        public void SendNatIntroduceRequest(IPEndPoint masterServerEndPoint, string additionalInfo)
        {
            //prepare outgoing data
            string networkIp = NetUtils.GetLocalIp(LocalAddrType.IPv4);
            if (string.IsNullOrEmpty(networkIp))
            {
                networkIp = NetUtils.GetLocalIp(LocalAddrType.IPv6);
            }

            Send(
                new NatIntroduceRequestPacket
                {
                    Internal = NetUtils.MakeEndPoint(networkIp, _socket.LocalPort),
                    Token = additionalInfo
                },
                masterServerEndPoint);
        }

        //We got request and must introduce
        private void OnNatIntroductionRequest(NatIntroduceRequestPacket req, IPEndPoint senderEndPoint)
        {
            if (UnsyncedEvents)
            {
                _natPunchListener.OnNatIntroductionRequest(
                    req.Internal,
                    senderEndPoint,
                    req.Token);
            }
            else
            {
                _requestEvents.Enqueue(new RequestEventData
                {
                    LocalEndPoint = req.Internal,
                    RemoteEndPoint = senderEndPoint,
                    Token = req.Token
                });
            }
        }

        //We got introduce and must punch
        private void OnNatIntroductionResponse(NatIntroduceResponsePacket req)
        {
            NetDebug.Write(NetLogLevel.Trace, "[NAT] introduction received");

            // send internal punch
            var punchPacket = new NatPunchPacket {Token = req.Token};
            Send(punchPacket, req.Internal);
            NetDebug.Write(NetLogLevel.Trace, "[NAT] internal punch sent to " + req.Internal);

            // hack for some routers
            _socket.Ttl = 2;
            _socket.SendRaw(new[] { (byte)PacketProperty.Empty }, 0, 1, req.External);

            // send external punch
            _socket.Ttl = NetConstants.SocketTTL;
            punchPacket.IsExternal = true;
            Send(punchPacket, req.External);
            NetDebug.Write(NetLogLevel.Trace, "[NAT] external punch sent to " + req.External);
        }

        //We got punch and can connect
        private void OnNatPunch(NatPunchPacket req, IPEndPoint senderEndPoint)
        {
            //Read info
            NetDebug.Write(NetLogLevel.Trace, "[NAT] punch received from {0} - additional info: {1}",
                senderEndPoint, req.Token);

            //Release punch success to client; enabling him to Connect() to Sender if token is ok
            if(UnsyncedEvents)
            {
                _natPunchListener.OnNatIntroductionSuccess(
                    senderEndPoint,
                    req.IsExternal ? NatAddressType.External : NatAddressType.Internal,
                    req.Token
                    );
            }
            else
            {
                _successEvents.Enqueue(new SuccessEventData
                {
                    TargetEndPoint = senderEndPoint,
                    Type = req.IsExternal ? NatAddressType.External : NatAddressType.Internal,
                    Token = req.Token
                });
            }
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NativeSocket.cs ---
﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace LiteNetLib
{
    internal readonly struct NativeAddr : IEquatable<NativeAddr>
    {
        //common parts
        private readonly long _part1; //family, port, etc
        private readonly long _part2;
        //ipv6 parts
        private readonly long _part3;
        private readonly int _part4;

        private readonly int _hash;

        public NativeAddr(byte[] address, int len)
        {
            _part1 = BitConverter.ToInt64(address, 0);
            _part2 = BitConverter.ToInt64(address, 8);
            if (len > 16)
            {
                _part3 = BitConverter.ToInt64(address, 16);
                _part4 = BitConverter.ToInt32(address, 24);
            }
            else
            {
                _part3 = 0;
                _part4 = 0;
            }
            _hash = (int)(_part1 >> 32) ^ (int)_part1 ^
                    (int)(_part2 >> 32) ^ (int)_part2 ^
                    (int)(_part3 >> 32) ^ (int)_part3 ^
                    _part4;
        }

        public override int GetHashCode()
        {
            return _hash;
        }

        public bool Equals(NativeAddr other)
        {
            return _part1 == other._part1 &&
                   _part2 == other._part2 &&
                   _part3 == other._part3 &&
                   _part4 == other._part4;
        }

        public override bool Equals(object obj)
        {
            return obj is NativeAddr other && Equals(other);
        }

        public static bool operator ==(NativeAddr left, NativeAddr right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(NativeAddr left, NativeAddr right)
        {
            return !left.Equals(right);
        }
    }

    internal class NativeEndPoint : IPEndPoint
    {
        public readonly byte[] NativeAddress;

        public NativeEndPoint(byte[] address) : base(IPAddress.Any, 0)
        {
            NativeAddress = new byte[address.Length];
            Buffer.BlockCopy(address, 0, NativeAddress, 0, address.Length);

            short family = (short)((address[1] << 8) | address[0]);
            Port         =(ushort)((address[2] << 8) | address[3]);

            if ((NativeSocket.UnixMode && family == NativeSocket.AF_INET6) || (!NativeSocket.UnixMode && (AddressFamily)family == AddressFamily.InterNetworkV6))
            {
                uint scope = unchecked((uint)(
                    (address[27] << 24) +
                    (address[26] << 16) +
                    (address[25] << 8) +
                    (address[24])));
#if NETCOREAPP || NETSTANDARD2_1 || NETSTANDARD2_1_OR_GREATER
                Address = new IPAddress(new ReadOnlySpan<byte>(address, 8, 16), scope);
#else
                byte[] addrBuffer = new byte[16];
                Buffer.BlockCopy(address, 8, addrBuffer, 0, 16);
                Address = new IPAddress(addrBuffer, scope);
#endif
            }
            else //IPv4
            {
                long ipv4Addr = unchecked((uint)((address[4] & 0x000000FF) |
                                                 (address[5] << 8 & 0x0000FF00) |
                                                 (address[6] << 16 & 0x00FF0000) |
                                                 (address[7] << 24)));
                Address = new IPAddress(ipv4Addr);
            }
        }
    }

    internal static class NativeSocket
    {
        static
#if LITENETLIB_UNSAFE
        unsafe
#endif
        class WinSock
        {
            private const string LibName = "ws2_32.dll";

            [DllImport(LibName, SetLastError = true)]
            public static extern int recvfrom(
                IntPtr socketHandle,
                [In, Out] byte[] pinnedBuffer,
                [In] int len,
                [In] SocketFlags socketFlags,
                [Out] byte[] socketAddress,
                [In, Out] ref int socketAddressSize);

            [DllImport(LibName, SetLastError = true)]
            internal static extern int sendto(
                IntPtr socketHandle,
#if LITENETLIB_UNSAFE
                byte* pinnedBuffer,
#else
                [In] byte[] pinnedBuffer,
#endif
                [In] int len,
                [In] SocketFlags socketFlags,
                [In] byte[] socketAddress,
                [In] int socketAddressSize);
        }

        static
#if LITENETLIB_UNSAFE
        unsafe
#endif
        class UnixSock
        {
            private const string LibName = "libc";

            [DllImport(LibName, SetLastError = true)]
            public static extern int recvfrom(
                IntPtr socketHandle,
                [In, Out] byte[] pinnedBuffer,
                [In] int len,
                [In] SocketFlags socketFlags,
                [Out] byte[] socketAddress,
                [In, Out] ref int socketAddressSize);

            [DllImport(LibName, SetLastError = true)]
            internal static extern int sendto(
                IntPtr socketHandle,
#if LITENETLIB_UNSAFE
                byte* pinnedBuffer,
#else
                [In] byte[] pinnedBuffer,
#endif
                [In] int len,
                [In] SocketFlags socketFlags,
                [In] byte[] socketAddress,
                [In] int socketAddressSize);
        }

        public static readonly bool IsSupported = false;
        public static readonly bool UnixMode = false;

        public const int IPv4AddrSize = 16;
        public const int IPv6AddrSize = 28;
        public const int AF_INET = 2;
        public const int AF_INET6 = 10;

        private static readonly Dictionary<int, SocketError> NativeErrorToSocketError = new Dictionary<int, SocketError>
        {
            { 13, SocketError.AccessDenied },               //EACCES
            { 98, SocketError.AddressAlreadyInUse },        //EADDRINUSE
            { 99, SocketError.AddressNotAvailable },        //EADDRNOTAVAIL
            { 97, SocketError.AddressFamilyNotSupported },  //EAFNOSUPPORT
            { 11, SocketError.WouldBlock },                 //EAGAIN
            { 114, SocketError.AlreadyInProgress },         //EALREADY
            { 9, SocketError.OperationAborted },            //EBADF
            { 125, SocketError.OperationAborted },          //ECANCELED
            { 103, SocketError.ConnectionAborted },         //ECONNABORTED
            { 111, SocketError.ConnectionRefused },         //ECONNREFUSED
            { 104, SocketError.ConnectionReset },           //ECONNRESET
            { 89, SocketError.DestinationAddressRequired }, //EDESTADDRREQ
            { 14, SocketError.Fault },                      //EFAULT
            { 112, SocketError.HostDown },                  //EHOSTDOWN
            { 6, SocketError.HostNotFound },                //ENXIO
            { 113, SocketError.HostUnreachable },           //EHOSTUNREACH
            { 115, SocketError.InProgress },                //EINPROGRESS
            { 4, SocketError.Interrupted },                 //EINTR
            { 22, SocketError.InvalidArgument },            //EINVAL
            { 106, SocketError.IsConnected },               //EISCONN
            { 24, SocketError.TooManyOpenSockets },         //EMFILE
            { 90, SocketError.MessageSize },                //EMSGSIZE
            { 100, SocketError.NetworkDown },               //ENETDOWN
            { 102, SocketError.NetworkReset },              //ENETRESET
            { 101, SocketError.NetworkUnreachable },        //ENETUNREACH
            { 23, SocketError.TooManyOpenSockets },         //ENFILE
            { 105, SocketError.NoBufferSpaceAvailable },    //ENOBUFS
            { 61, SocketError.NoData },                     //ENODATA
            { 2, SocketError.AddressNotAvailable },         //ENOENT
            { 92, SocketError.ProtocolOption },             //ENOPROTOOPT
            { 107, SocketError.NotConnected },              //ENOTCONN
            { 88, SocketError.NotSocket },                  //ENOTSOCK
            { 3440, SocketError.OperationNotSupported },    //ENOTSUP
            { 1, SocketError.AccessDenied },                //EPERM
            { 32, SocketError.Shutdown },                   //EPIPE
            { 96, SocketError.ProtocolFamilyNotSupported }, //EPFNOSUPPORT
            { 93, SocketError.ProtocolNotSupported },       //EPROTONOSUPPORT
            { 91, SocketError.ProtocolType },               //EPROTOTYPE
            { 94, SocketError.SocketNotSupported },         //ESOCKTNOSUPPORT
            { 108, SocketError.Disconnecting },             //ESHUTDOWN
            { 110, SocketError.TimedOut },                  //ETIMEDOUT
            { 0, SocketError.Success }
        };

        static NativeSocket()
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                IsSupported = true;
                UnixMode = true;
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                IsSupported = true;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int RecvFrom(
            IntPtr socketHandle,
            byte[] pinnedBuffer,
            int len,
            byte[] socketAddress,
            ref int socketAddressSize)
        {
            return UnixMode
                ? UnixSock.recvfrom(socketHandle, pinnedBuffer, len, 0, socketAddress, ref socketAddressSize)
                : WinSock.recvfrom(socketHandle, pinnedBuffer, len, 0, socketAddress, ref socketAddressSize);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public
#if LITENETLIB_UNSAFE
            unsafe
#endif
            static int SendTo(
            IntPtr socketHandle,
#if LITENETLIB_UNSAFE
            byte* pinnedBuffer,
#else
            byte[] pinnedBuffer,
#endif
            int len,
            byte[] socketAddress,
            int socketAddressSize)
        {
            return UnixMode
                ? UnixSock.sendto(socketHandle, pinnedBuffer, len, 0, socketAddress, socketAddressSize)
                : WinSock.sendto(socketHandle, pinnedBuffer, len, 0, socketAddress, socketAddressSize);
        }

        public static SocketError GetSocketError()
        {
            int error = Marshal.GetLastWin32Error();
            if (UnixMode)
                return NativeErrorToSocketError.TryGetValue(error, out var err)
                    ? err
                    : SocketError.SocketError;
            return (SocketError)error;
        }

        public static SocketException GetSocketException()
        {
            int error = Marshal.GetLastWin32Error();
            if (UnixMode)
                return NativeErrorToSocketError.TryGetValue(error, out var err)
                    ? new SocketException((int)err)
                    : new SocketException((int)SocketError.SocketError);
            return new SocketException(error);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short GetNativeAddressFamily(IPEndPoint remoteEndPoint)
        {
            return UnixMode
                ? (short)(remoteEndPoint.AddressFamily == AddressFamily.InterNetwork ? AF_INET : AF_INET6)
                : (short)remoteEndPoint.AddressFamily;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetConstants.cs ---
﻿namespace LiteNetLib
{
    /// <summary>
    /// Sending method type
    /// </summary>
    public enum DeliveryMethod : byte
    {
        /// <summary>
        /// Unreliable. Packets can be dropped, can be duplicated, can arrive without order.
        /// </summary>
        Unreliable = 4,

        /// <summary>
        /// Reliable. Packets won't be dropped, won't be duplicated, can arrive without order.
        /// </summary>
        ReliableUnordered = 0,

        /// <summary>
        /// Unreliable. Packets can be dropped, won't be duplicated, will arrive in order.
        /// </summary>
        Sequenced = 1,

        /// <summary>
        /// Reliable and ordered. Packets won't be dropped, won't be duplicated, will arrive in order.
        /// </summary>
        ReliableOrdered = 2,

        /// <summary>
        /// Reliable only last packet. Packets can be dropped (except the last one), won't be duplicated, will arrive in order.
        /// Cannot be fragmented
        /// </summary>
        ReliableSequenced = 3
    }

    /// <summary>
    /// Network constants. Can be tuned from sources for your purposes.
    /// </summary>
    public static class NetConstants
    {
        //can be tuned
        public const int DefaultWindowSize = 64;
        public const int SocketBufferSize = 1024 * 1024; //1mb
        public const int SocketTTL = 255;

        public const int HeaderSize = 1;
        public const int ChanneledHeaderSize = 4;
        public const int FragmentHeaderSize = 6;
        public const int FragmentedHeaderTotalSize = ChanneledHeaderSize + FragmentHeaderSize;
        public const ushort MaxSequence = 32768;
        public const ushort HalfMaxSequence = MaxSequence / 2;

        //protocol
        internal const int ProtocolId = 13;
        internal const int MaxUdpHeaderSize = 68;
        internal const int ChannelTypeCount = 4;

        internal static readonly int[] PossibleMtu =
        {
            576  - MaxUdpHeaderSize, //minimal (RFC 1191)
            1024,                    //most games standard
            1232 - MaxUdpHeaderSize,
            1460 - MaxUdpHeaderSize, //google cloud
            1472 - MaxUdpHeaderSize, //VPN
            1492 - MaxUdpHeaderSize, //Ethernet with LLC and SNAP, PPPoE (RFC 1042)
            1500 - MaxUdpHeaderSize  //Ethernet II (RFC 1191)
        };

        //Max possible single packet size
        public static readonly int MaxPacketSize = PossibleMtu[PossibleMtu.Length - 1];
        public static readonly int MaxUnreliableDataSize = MaxPacketSize - HeaderSize;

        //peer specific
        public const byte MaxConnectionNumber = 4;
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetDebug.cs ---
﻿using System;
using System.Diagnostics;

namespace LiteNetLib
{
    public class InvalidPacketException : ArgumentException
    {
        public InvalidPacketException(string message) : base(message)
        {
        }
    }

    public class TooBigPacketException : InvalidPacketException
    {
        public TooBigPacketException(string message) : base(message)
        {
        }
    }

    public enum NetLogLevel
    {
        Warning,
        Error,
        Trace,
        Info
    }

    /// <summary>
    /// Interface to implement for your own logger
    /// </summary>
    public interface INetLogger
    {
        void WriteNet(NetLogLevel level, string str, params object[] args);
    }

    /// <summary>
    /// Static class for defining your own LiteNetLib logger instead of Console.WriteLine
    /// or Debug.Log if compiled with UNITY flag
    /// </summary>
    public static class NetDebug
    {
        public static INetLogger Logger = null;
        private static readonly object DebugLogLock = new object();
        private static void WriteLogic(NetLogLevel logLevel, string str, params object[] args)
        {
            lock (DebugLogLock)
            {
                if (Logger == null)
                {
#if UNITY_5_3_OR_NEWER
                    UnityEngine.Debug.Log(string.Format(str, args));
#else
                    Console.WriteLine(str, args);
#endif
                }
                else
                {
                    Logger.WriteNet(logLevel, str, args);
                }
            }
        }

        [Conditional("DEBUG_MESSAGES")]
        internal static void Write(string str, params object[] args)
        {
            WriteLogic(NetLogLevel.Trace, str, args);
        }

        [Conditional("DEBUG_MESSAGES")]
        internal static void Write(NetLogLevel level, string str, params object[] args)
        {
            WriteLogic(level, str, args);
        }

        [Conditional("DEBUG_MESSAGES"), Conditional("DEBUG")]
        internal static void WriteForce(string str, params object[] args)
        {
            WriteLogic(NetLogLevel.Trace, str, args);
        }

        [Conditional("DEBUG_MESSAGES"), Conditional("DEBUG")]
        internal static void WriteForce(NetLogLevel level, string str, params object[] args)
        {
            WriteLogic(level, str, args);
        }

        internal static void WriteError(string str, params object[] args)
        {
            WriteLogic(NetLogLevel.Error, str, args);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetManager.PacketPool.cs ---
﻿using System;
using System.Threading;

namespace LiteNetLib
{
    public partial class NetManager
    {
        private NetPacket _poolHead;
        private int _poolCount;
        private readonly object _poolLock = new object();

        /// <summary>
        /// Maximum packet pool size (increase if you have tons of packets sending)
        /// </summary>
        public int PacketPoolSize = 1000;

        public int PoolCount => _poolCount;
        
        private NetPacket PoolGetWithData(PacketProperty property, byte[] data, int start, int length)
        {
            int headerSize = NetPacket.GetHeaderSize(property);
            NetPacket packet = PoolGetPacket(length + headerSize);
            packet.Property = property;
            Buffer.BlockCopy(data, start, packet.RawData, headerSize, length);
            return packet;
        }

        //Get packet with size
        private NetPacket PoolGetWithProperty(PacketProperty property, int size)
        {
            NetPacket packet = PoolGetPacket(size + NetPacket.GetHeaderSize(property));
            packet.Property = property;
            return packet;
        }

        private NetPacket PoolGetWithProperty(PacketProperty property)
        {
            NetPacket packet = PoolGetPacket(NetPacket.GetHeaderSize(property));
            packet.Property = property;
            return packet;
        }

        internal NetPacket PoolGetPacket(int size)
        {
            NetPacket packet;
            lock (_poolLock)
            {
                packet = _poolHead;
                if (packet == null)
                    return new NetPacket(size);
                
                _poolHead = _poolHead.Next;
                _poolCount--;
            }
            
            packet.Size = size;
            if (packet.RawData.Length < size)
                packet.RawData = new byte[size];
            return packet;
        }

        internal void PoolRecycle(NetPacket packet)
        {
            if (packet.RawData.Length > NetConstants.MaxPacketSize || _poolCount >= PacketPoolSize)
            {
                //Don't pool big packets. Save memory
                return;
            }
            
            //Clean fragmented flag
            packet.RawData[0] = 0;
            lock (_poolLock)
            {
                packet.Next = _poolHead;
                _poolHead = packet;
                _poolCount++;
            }
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetManager.Socket.cs ---
#if UNITY_IOS && !UNITY_EDITOR
using UnityEngine;
#endif
using System.Runtime.InteropServices;

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using LiteNetLib.Utils;

namespace LiteNetLib
{
#if UNITY_IOS && !UNITY_EDITOR
    public class UnitySocketFix : MonoBehaviour
    {
        internal IPAddress BindAddrIPv4;
        internal IPAddress BindAddrIPv6;
        internal int Port;
        internal bool Paused;
        internal NetManager Socket;
        internal bool ManualMode;

        private void Update()
        {
            if (Socket == null)
                Destroy(gameObject);
        }

        private void OnApplicationPause(bool pause)
        {
            if (Socket == null)
                return;
            if (pause)
            {
                Paused = true;
                Socket.CloseSocket(true);
            }
            else if (Paused)
            {
                if (!Socket.Start(BindAddrIPv4, BindAddrIPv6, Port, ManualMode))
                {
                    NetDebug.WriteError("[S] Cannot restore connection \"{0}\",\"{1}\" port {2}", BindAddrIPv4, BindAddrIPv6, Port);
                    Socket.CloseSocket(false);
                }
            }
        }
    }
#endif

    public partial class NetManager
    {
        private const int ReceivePollingTime = 500000; //0.5 second

        private Socket _udpSocketv4;
        private Socket _udpSocketv6;
        private Thread _threadv4;
        private Thread _threadv6;
        private IPEndPoint _bufferEndPointv4;
        private IPEndPoint _bufferEndPointv6;

#if !LITENETLIB_UNSAFE
        [ThreadStatic] private static byte[] _sendToBuffer;
#endif
        [ThreadStatic] private static byte[] _endPointBuffer;

        private readonly Dictionary<NativeAddr, IPEndPoint> _nativeAddrMap = new Dictionary<NativeAddr, IPEndPoint>();

        private const int SioUdpConnreset = -1744830452; //SIO_UDP_CONNRESET = IOC_IN | IOC_VENDOR | 12
        private static readonly IPAddress MulticastAddressV6 = IPAddress.Parse("ff02::1");
        public static readonly bool IPv6Support;
#if UNITY_IOS && !UNITY_EDITOR
        private UnitySocketFix _unitySocketFix;
#endif

        /// <summary>
        /// Maximum packets count that will be processed in Manual PollEvents
        /// </summary>
        public int MaxPacketsReceivePerUpdate = 0;

        public short Ttl
        {
            get
            {
#if UNITY_SWITCH
                return 0;
#else
                return _udpSocketv4.Ttl;
#endif
            }
            internal set
            {
#if !UNITY_SWITCH
                _udpSocketv4.Ttl = value;
#endif
            }
        }

        static NetManager()
        {
#if DISABLE_IPV6
            IPv6Support = false;
#elif !UNITY_2019_1_OR_NEWER && !UNITY_2018_4_OR_NEWER && (!UNITY_EDITOR && ENABLE_IL2CPP)
            string version = UnityEngine.Application.unityVersion;
            IPv6Support = Socket.OSSupportsIPv6 && int.Parse(version.Remove(version.IndexOf('f')).Split('.')[2]) >= 6;
#else
            IPv6Support = Socket.OSSupportsIPv6;
#endif
        }

        private bool IsActive()
        {
#if UNITY_IOS && !UNITY_EDITOR
            var unitySocketFix = _unitySocketFix; //save for multithread
            if (unitySocketFix != null && unitySocketFix.Paused)
                return false;
#endif
            return IsRunning;
        }

        private void RegisterEndPoint(IPEndPoint ep)
        {
            if (UseNativeSockets && ep is NativeEndPoint nep)
            {
                _nativeAddrMap.Add(new NativeAddr(nep.NativeAddress, nep.NativeAddress.Length), nep);
            }
        }

        private void UnregisterEndPoint(IPEndPoint ep)
        {
            if (UseNativeSockets && ep is NativeEndPoint nep)
            {
                var nativeAddr = new NativeAddr(nep.NativeAddress, nep.NativeAddress.Length);
                _nativeAddrMap.Remove(nativeAddr);
            }
        }

        private bool ProcessError(SocketException ex)
        {
            switch (ex.SocketErrorCode)
            {
#if UNITY_IOS && !UNITY_EDITOR
                case SocketError.NotConnected:
#endif
                case SocketError.Interrupted:
                case SocketError.NotSocket:
                case SocketError.OperationAborted:
                    return true;
                case SocketError.ConnectionReset:
                case SocketError.MessageSize:
                case SocketError.TimedOut:
                case SocketError.NetworkReset:
                    //NetDebug.Write($"[R]Ignored error: {(int)ex.SocketErrorCode} - {ex}");
                    break;
                default:
                    NetDebug.WriteError($"[R]Error code: {(int)ex.SocketErrorCode} - {ex}");
                    CreateEvent(NetEvent.EType.Error, errorCode: ex.SocketErrorCode);
                    break;
            }
            return false;
        }

        private void ManualReceive(Socket socket, EndPoint bufferEndPoint)
        {
            //Reading data
            try
            {
                int packetsReceived = 0;
                while (socket.Available > 0)
                {
                    var packet = PoolGetPacket(NetConstants.MaxPacketSize);
                    packet.Size = socket.ReceiveFrom(packet.RawData, 0, NetConstants.MaxPacketSize, SocketFlags.None,
                        ref bufferEndPoint);
                    //NetDebug.Write(NetLogLevel.Trace, $"[R]Received data from {bufferEndPoint}, result: {packet.Size}");
                    OnMessageReceived(packet, (IPEndPoint) bufferEndPoint);
                    packetsReceived++;
                    if (packetsReceived == MaxPacketsReceivePerUpdate)
                        break;
                }
            }
            catch (SocketException ex)
            {
                ProcessError(ex);
            }
            catch (ObjectDisposedException)
            {

            }
            catch (Exception e)
            {
                //protects socket receive thread
                NetDebug.WriteError("[NM] SocketReceiveThread error: " + e );
            }
        }

        private void NativeReceiveLogic(object state)
        {
            Socket socket = (Socket)state;
            IntPtr socketHandle = socket.Handle;
            byte[] addrBuffer = new byte[socket.AddressFamily == AddressFamily.InterNetwork
                ? NativeSocket.IPv4AddrSize
                : NativeSocket.IPv6AddrSize];

            int addrSize = addrBuffer.Length;
            NetPacket packet = PoolGetPacket(NetConstants.MaxPacketSize);

            while (IsActive())
            {
                //Reading data
                packet.Size = NativeSocket.RecvFrom(socketHandle, packet.RawData, NetConstants.MaxPacketSize, addrBuffer, ref addrSize);
                if (packet.Size == 0)
                    return;
                if (packet.Size == -1)
                {
                    SocketError errorCode = NativeSocket.GetSocketError();
                    if (errorCode == SocketError.WouldBlock || errorCode == SocketError.TimedOut) //Linux timeout EAGAIN
                        continue;
                    if (ProcessError(new SocketException((int)errorCode)))
                        return;
                    continue;
                }

                NativeAddr nativeAddr = new NativeAddr(addrBuffer, addrSize);
                if (!_nativeAddrMap.TryGetValue(nativeAddr, out var endPoint))
                    endPoint = new NativeEndPoint(addrBuffer);

                //All ok!
                //NetDebug.WriteForce($"[R]Received data from {endPoint}, result: {packet.Size}");
                OnMessageReceived(packet, endPoint);
                packet = PoolGetPacket(NetConstants.MaxPacketSize);
            }
        }

        private void ReceiveLogic(object state)
        {
            Socket socket = (Socket)state;
            EndPoint bufferEndPoint = new IPEndPoint(socket.AddressFamily == AddressFamily.InterNetwork ? IPAddress.Any : IPAddress.IPv6Any, 0);

            while (IsActive())
            {
                //Reading data
                try
                {
                    if (socket.Available == 0 && !socket.Poll(ReceivePollingTime, SelectMode.SelectRead))
                        continue;
                    NetPacket packet = PoolGetPacket(NetConstants.MaxPacketSize);
                    packet.Size = socket.ReceiveFrom(packet.RawData, 0, NetConstants.MaxPacketSize, SocketFlags.None,
                        ref bufferEndPoint);

                    //NetDebug.Write(NetLogLevel.Trace, $"[R]Received data from {bufferEndPoint}, result: {packet.Size}");
                    OnMessageReceived(packet, (IPEndPoint)bufferEndPoint);
                }
                catch (SocketException ex)
                {
                    if (ProcessError(ex))
                        return;
                }
                catch (ObjectDisposedException)
                {
                    //socket closed
                    return;
                }
                catch (ThreadAbortException)
                {
                    //thread closed
                    return;
                }
                catch (Exception e)
                {
                    //protects socket receive thread
                    NetDebug.WriteError("[NM] SocketReceiveThread error: " + e );
                }
            }
        }

         /// <summary>
        /// Start logic thread and listening on selected port
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        /// <param name="manualMode">mode of library</param>
        public bool Start(IPAddress addressIPv4, IPAddress addressIPv6, int port, bool manualMode)
        {
            if (IsRunning && !IsActive())
                return false;
            _manualMode = manualMode;
            UseNativeSockets = UseNativeSockets && NativeSocket.IsSupported;

            //osx doesn't support dual mode
            if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX) && IPv6Mode == IPv6Mode.DualMode)
                IPv6Mode = IPv6Mode.SeparateSocket;

            bool dualMode = IPv6Mode == IPv6Mode.DualMode && IPv6Support;

            _udpSocketv4 = new Socket(
                dualMode ? AddressFamily.InterNetworkV6 : AddressFamily.InterNetwork,
                SocketType.Dgram,
                ProtocolType.Udp);

            if (!BindSocket(_udpSocketv4, new IPEndPoint(dualMode ? addressIPv6 : addressIPv4, port)))
                return false;

            LocalPort = ((IPEndPoint) _udpSocketv4.LocalEndPoint).Port;

#if UNITY_IOS && !UNITY_EDITOR
            if (_unitySocketFix == null)
            {
                var unityFixObj = new GameObject("LiteNetLib_UnitySocketFix");
                GameObject.DontDestroyOnLoad(unityFixObj);
                _unitySocketFix = unityFixObj.AddComponent<UnitySocketFix>();
                _unitySocketFix.Socket = this;
                _unitySocketFix.BindAddrIPv4 = addressIPv4;
                _unitySocketFix.BindAddrIPv6 = addressIPv6;
                _unitySocketFix.Port = LocalPort;
                _unitySocketFix.ManualMode = _manualMode;
            }
            else
            {
                _unitySocketFix.Paused = false;
            }
#endif
            if (dualMode)
                _udpSocketv6 = _udpSocketv4;

            IsRunning = true;
            if (!_manualMode)
            {
                ParameterizedThreadStart ts = ReceiveLogic;
                if (UseNativeSockets)
                    ts = NativeReceiveLogic;

                _threadv4 = new Thread(ts)
                {
                    Name = $"SocketThreadv4({LocalPort})",
                    IsBackground = true
                };
                _threadv4.Start(_udpSocketv4);

                _logicThread = new Thread(UpdateLogic) { Name = "LogicThread", IsBackground = true };
                _logicThread.Start();
            }
            else
            {
                _bufferEndPointv4 = new IPEndPoint(IPAddress.Any, 0);
            }

            //Check IPv6 support
            if (IPv6Support && IPv6Mode == IPv6Mode.SeparateSocket)
            {
                _udpSocketv6 = new Socket(AddressFamily.InterNetworkV6, SocketType.Dgram, ProtocolType.Udp);
                //Use one port for two sockets
                if (BindSocket(_udpSocketv6, new IPEndPoint(addressIPv6, LocalPort)))
                {
                    if (_manualMode)
                    {
                        _bufferEndPointv6 = new IPEndPoint(IPAddress.IPv6Any, 0);
                    }
                    else
                    {
                        ParameterizedThreadStart ts = ReceiveLogic;
                        if (UseNativeSockets)
                            ts = NativeReceiveLogic;
                        _threadv6 = new Thread(ts)
                        {
                            Name = $"SocketThreadv6({LocalPort})",
                            IsBackground = true
                        };
                        _threadv6.Start(_udpSocketv6);
                    }
                }
            }

            return true;
        }

        private bool BindSocket(Socket socket, IPEndPoint ep)
        {
            //Setup socket
            socket.ReceiveTimeout = 500;
            socket.SendTimeout = 500;
            socket.ReceiveBufferSize = NetConstants.SocketBufferSize;
            socket.SendBufferSize = NetConstants.SocketBufferSize;

            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                try
                {
                    socket.IOControl(SioUdpConnreset, new byte[] {0}, null);
                }
                catch
                {
                    //ignored
                }
            }

            try
            {
                socket.ExclusiveAddressUse = !ReuseAddress;
                socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, ReuseAddress);
            }
            catch
            {
                //Unity with IL2CPP throws an exception here, it doesn't matter in most cases so just ignore it
            }
            if (ep.AddressFamily == AddressFamily.InterNetwork || IPv6Mode == IPv6Mode.DualMode)
            {
                Ttl = NetConstants.SocketTTL;

                try { socket.EnableBroadcast = true; }
                catch (SocketException e)
                {
                    NetDebug.WriteError($"[B]Broadcast error: {e.SocketErrorCode}");
                }

                if (IPv6Mode == IPv6Mode.DualMode)
                {
                    try { socket.DualMode = true; }
                    catch(Exception e)
                    {
                        NetDebug.WriteError($"[B]Bind exception (dualmode setting): {e}");
                    }
                }
                else if (!RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                {
                    try { socket.DontFragment = true; }
                    catch (SocketException e)
                    {
                        NetDebug.WriteError($"[B]DontFragment error: {e.SocketErrorCode}");
                    }
                }
            }
            //Bind
            try
            {
                socket.Bind(ep);
                NetDebug.Write(NetLogLevel.Trace, $"[B]Successfully binded to port: {((IPEndPoint)socket.LocalEndPoint).Port}, AF: {socket.AddressFamily}");

                //join multicast
                if (ep.AddressFamily == AddressFamily.InterNetworkV6)
                {
                    try
                    {
#if !UNITY_2018_3_OR_NEWER
                        socket.SetSocketOption(
                            SocketOptionLevel.IPv6,
                            SocketOptionName.AddMembership,
                            new IPv6MulticastOption(MulticastAddressV6));
#endif
                    }
                    catch (Exception)
                    {
                        // Unity3d throws exception - ignored
                    }
                }
            }
            catch (SocketException bindException)
            {
                switch (bindException.SocketErrorCode)
                {
                    //IPv6 bind fix
                    case SocketError.AddressAlreadyInUse:
                        if (socket.AddressFamily == AddressFamily.InterNetworkV6 && IPv6Mode != IPv6Mode.DualMode)
                        {
                            try
                            {
                                //Set IPv6Only
                                socket.DualMode = false;
                                socket.Bind(ep);
                            }
                            catch (SocketException ex)
                            {
                                //because its fixed in 2018_3
                                NetDebug.WriteError($"[B]Bind exception: {ex}, errorCode: {ex.SocketErrorCode}");
                                return false;
                            }
                            return true;
                        }
                        break;
                    //hack for iOS (Unity3D)
                    case SocketError.AddressFamilyNotSupported:
                        return true;
                }
                NetDebug.WriteError($"[B]Bind exception: {bindException}, errorCode: {bindException.SocketErrorCode}");
                return false;
            }
            return true;
        }

        internal int SendRawAndRecycle(NetPacket packet, IPEndPoint remoteEndPoint)
        {
            int result = SendRaw(packet.RawData, 0, packet.Size, remoteEndPoint);
            PoolRecycle(packet);
            return result;
        }

        internal int SendRaw(NetPacket packet, IPEndPoint remoteEndPoint)
        {
            return SendRaw(packet.RawData, 0, packet.Size, remoteEndPoint);
        }

        internal int SendRaw(byte[] message, int start, int length, IPEndPoint remoteEndPoint)
        {
            if (!IsRunning)
                return 0;

            NetPacket expandedPacket = null;
            if (_extraPacketLayer != null)
            {
                expandedPacket = PoolGetPacket(length + _extraPacketLayer.ExtraPacketSizeForLayer);
                Buffer.BlockCopy(message, start, expandedPacket.RawData, 0, length);
                start = 0;
                _extraPacketLayer.ProcessOutBoundPacket(ref remoteEndPoint, ref expandedPacket.RawData, ref start, ref length);
                message = expandedPacket.RawData;
            }

            var socket = _udpSocketv4;
            if (remoteEndPoint.AddressFamily == AddressFamily.InterNetworkV6 && IPv6Support)
            {
                socket = _udpSocketv6;
                if (socket == null)
                    return 0;
            }

            int result;
            try
            {
                if (UseNativeSockets)
                {
                    byte[] socketAddress;

                    if (remoteEndPoint is NativeEndPoint nep)
                    {
                        socketAddress = nep.NativeAddress;
                    }
                    else //Convert endpoint to raw
                    {
                        if (_endPointBuffer == null)
                            _endPointBuffer = new byte[NativeSocket.IPv6AddrSize];
                        socketAddress = _endPointBuffer;

                        bool ipv4 = remoteEndPoint.AddressFamily == AddressFamily.InterNetwork;
                        short addressFamily = NativeSocket.GetNativeAddressFamily(remoteEndPoint);

                        socketAddress[0] = (byte) (addressFamily);
                        socketAddress[1] = (byte) (addressFamily >> 8);
                        socketAddress[2] = (byte) (remoteEndPoint.Port >> 8);
                        socketAddress[3] = (byte) (remoteEndPoint.Port);

                        if (ipv4)
                        {
#pragma warning disable 618
                            long addr = remoteEndPoint.Address.Address;
#pragma warning restore 618
                            socketAddress[4] = (byte) (addr);
                            socketAddress[5] = (byte) (addr >> 8);
                            socketAddress[6] = (byte) (addr >> 16);
                            socketAddress[7] = (byte) (addr >> 24);
                        }
                        else
                        {
#if NETCOREAPP || NETSTANDARD2_1 || NETSTANDARD2_1_OR_GREATER
                            remoteEndPoint.Address.TryWriteBytes(new Span<byte>(socketAddress, 8, 16), out _);
#else
                            byte[] addrBytes = remoteEndPoint.Address.GetAddressBytes();
                            Buffer.BlockCopy(addrBytes, 0, socketAddress, 8, 16);
#endif
                        }
                    }

#if LITENETLIB_UNSAFE
                    unsafe
                    {
                        fixed (byte* dataWithOffset = &message[start])
                        {
                            result =
 NativeSocket.SendTo(socket.Handle, dataWithOffset, length, socketAddress, socketAddress.Length);
                        }
                    }
#else
                    if (start > 0)
                    {
                        if (_sendToBuffer == null)
                            _sendToBuffer = new byte[NetConstants.MaxPacketSize];
                        Buffer.BlockCopy(message, start, _sendToBuffer, 0, length);
                        message = _sendToBuffer;
                    }

                    result = NativeSocket.SendTo(socket.Handle, message, length, socketAddress, socketAddress.Length);
#endif
                    if (result == -1)
                        throw NativeSocket.GetSocketException();
                }
                else
                {
                    result = socket.SendTo(message, start, length, SocketFlags.None, remoteEndPoint);
                }
                //NetDebug.WriteForce("[S]Send packet to {0}, result: {1}", remoteEndPoint, result);
            }
            catch (SocketException ex)
            {
                switch (ex.SocketErrorCode)
                {
                    case SocketError.NoBufferSpaceAvailable:
                    case SocketError.Interrupted:
                        return 0;
                    case SocketError.MessageSize:
                        NetDebug.Write(NetLogLevel.Trace, "[SRD] 10040, datalen: {0}", length);
                        return 0;

                    case SocketError.HostUnreachable:
                    case SocketError.NetworkUnreachable:
                        if (DisconnectOnUnreachable && TryGetPeer(remoteEndPoint, out var fromPeer))
                        {
                            DisconnectPeerForce(
                                fromPeer,
                                ex.SocketErrorCode == SocketError.HostUnreachable
                                    ? DisconnectReason.HostUnreachable
                                    : DisconnectReason.NetworkUnreachable,
                                ex.SocketErrorCode,
                                null);
                        }

                        CreateEvent(NetEvent.EType.Error, remoteEndPoint: remoteEndPoint, errorCode: ex.SocketErrorCode);
                        return -1;

                    default:
                        NetDebug.WriteError($"[S] {ex}");
                        return -1;
                }
            }
            catch (Exception ex)
            {
                NetDebug.WriteError($"[S] {ex}");
                return 0;
            }
            finally
            {
                if (expandedPacket != null)
                {
                    PoolRecycle(expandedPacket);
                }
            }

            if (result <= 0)
                return 0;

            if (EnableStatistics)
            {
                Statistics.IncrementPacketsSent();
                Statistics.AddBytesSent(length);
            }

            return result;
        }

        public bool SendBroadcast(NetDataWriter writer, int port)
        {
            return SendBroadcast(writer.Data, 0, writer.Length, port);
        }

        public bool SendBroadcast(byte[] data, int port)
        {
            return SendBroadcast(data, 0, data.Length, port);
        }

        public bool SendBroadcast(byte[] data, int start, int length, int port)
        {
            if (!IsActive())
                return false;

            NetPacket packet;
            if (_extraPacketLayer != null)
            {
                var headerSize = NetPacket.GetHeaderSize(PacketProperty.Broadcast);
                packet = PoolGetPacket(headerSize + length + _extraPacketLayer.ExtraPacketSizeForLayer);
                packet.Property = PacketProperty.Broadcast;
                Buffer.BlockCopy(data, start, packet.RawData, headerSize, length);
                var checksumComputeStart = 0;
                int preCrcLength = length + headerSize;
                IPEndPoint emptyEp = null;
                _extraPacketLayer.ProcessOutBoundPacket(ref emptyEp, ref packet.RawData, ref checksumComputeStart, ref preCrcLength);
            }
            else
            {
                packet = PoolGetWithData(PacketProperty.Broadcast, data, start, length);
            }

            bool broadcastSuccess = false;
            bool multicastSuccess = false;
            try
            {
                broadcastSuccess = _udpSocketv4.SendTo(
                    packet.RawData,
                    0,
                    packet.Size,
                    SocketFlags.None,
                    new IPEndPoint(IPAddress.Broadcast, port)) > 0;

                if (_udpSocketv6 != null)
                {
                    multicastSuccess = _udpSocketv6.SendTo(
                        packet.RawData,
                        0,
                        packet.Size,
                        SocketFlags.None,
                        new IPEndPoint(MulticastAddressV6, port)) > 0;
                }
            }
            catch (Exception ex)
            {
                NetDebug.WriteError($"[S][MCAST] {ex}");
                return broadcastSuccess;
            }
            finally
            {
                PoolRecycle(packet);
            }

            return broadcastSuccess || multicastSuccess;
        }

        internal void CloseSocket(bool suspend)
        {
            if (!suspend)
            {
                IsRunning = false;
#if UNITY_IOS && !UNITY_EDITOR
                _unitySocketFix.Socket = null;
                _unitySocketFix = null;
#endif
            }
            //cleanup dual mode
            if (_udpSocketv4 == _udpSocketv6)
                _udpSocketv6 = null;

            _udpSocketv4?.Close();
            _udpSocketv6?.Close();
            _udpSocketv4 = null;
            _udpSocketv6 = null;

            if (_threadv4 != null && _threadv4 != Thread.CurrentThread)
                _threadv4.Join();
            if (_threadv6 != null && _threadv6 != Thread.CurrentThread)
                _threadv6.Join();
            _threadv4 = null;
            _threadv6 = null;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetManager.cs ---
﻿using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using LiteNetLib.Layers;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    public enum IPv6Mode
    {
        Disabled,
        SeparateSocket,
        DualMode
    }

    public sealed class NetPacketReader : NetDataReader
    {
        private NetPacket _packet;
        private readonly NetManager _manager;
        private readonly NetEvent _evt;

        internal NetPacketReader(NetManager manager, NetEvent evt)
        {
            _manager = manager;
            _evt = evt;
        }

        internal void SetSource(NetPacket packet, int headerSize)
        {
            if (packet == null)
                return;
            _packet = packet;
            SetSource(packet.RawData, headerSize, packet.Size);
        }

        internal void RecycleInternal()
        {
            Clear();
            if (_packet != null)
                _manager.PoolRecycle(_packet);
            _packet = null;
            _manager.RecycleEvent(_evt);
        }

        public void Recycle()
        {
            if (_manager.AutoRecycle)
                return;
            RecycleInternal();
        }
    }

    internal sealed class NetEvent
    {
        public NetEvent Next;

        public enum EType
        {
            Connect,
            Disconnect,
            Receive,
            ReceiveUnconnected,
            Error,
            ConnectionLatencyUpdated,
            Broadcast,
            ConnectionRequest,
            MessageDelivered,
            PeerAddressChanged
        }
        public EType Type;

        public NetPeer Peer;
        public IPEndPoint RemoteEndPoint;
        public object UserData;
        public int Latency;
        public SocketError ErrorCode;
        public DisconnectReason DisconnectReason;
        public ConnectionRequest ConnectionRequest;
        public DeliveryMethod DeliveryMethod;
        public byte ChannelNumber;
        public readonly NetPacketReader DataReader;

        public NetEvent(NetManager manager)
        {
            DataReader = new NetPacketReader(manager, this);
        }
    }

    /// <summary>
    /// Main class for all network operations. Can be used as client and/or server.
    /// </summary>
    public partial class NetManager : IEnumerable<NetPeer>
    {
        private class IPEndPointComparer : IEqualityComparer<IPEndPoint>
        {
            public bool Equals(IPEndPoint x, IPEndPoint y)
            {
                return x.Address.Equals(y.Address) && x.Port == y.Port;
            }

            public int GetHashCode(IPEndPoint obj)
            {
                return obj.GetHashCode();
            }
        }

        public struct NetPeerEnumerator : IEnumerator<NetPeer>
        {
            private readonly NetPeer _initialPeer;
            private NetPeer _p;

            public NetPeerEnumerator(NetPeer p)
            {
                _initialPeer = p;
                _p = null;
            }

            public void Dispose()
            {

            }

            public bool MoveNext()
            {
                _p = _p == null ? _initialPeer : _p.NextPeer;
                return _p != null;
            }

            public void Reset()
            {
                throw new NotSupportedException();
            }

            public NetPeer Current => _p;
            object IEnumerator.Current => _p;
        }

#if DEBUG
        private struct IncomingData
        {
            public NetPacket Data;
            public IPEndPoint EndPoint;
            public DateTime TimeWhenGet;
        }
        private readonly List<IncomingData> _pingSimulationList = new List<IncomingData>();
        private readonly Random _randomGenerator = new Random();
        private const int MinLatencyThreshold = 5;
#endif

        private Thread _logicThread;
        private bool _manualMode;
        private readonly AutoResetEvent _updateTriggerEvent = new AutoResetEvent(true);

        private Queue<NetEvent> _netEventsProduceQueue = new Queue<NetEvent>();
        private Queue<NetEvent> _netEventsConsumeQueue = new Queue<NetEvent>();

        private NetEvent _netEventPoolHead;
        private readonly INetEventListener _netEventListener;
        private readonly IDeliveryEventListener _deliveryEventListener;
        private readonly INtpEventListener _ntpEventListener;
        private readonly IPeerAddressChangedListener _peerAddressChangedListener;

        private readonly Dictionary<IPEndPoint, NetPeer> _peersDict = new Dictionary<IPEndPoint, NetPeer>(new IPEndPointComparer());
        private readonly Dictionary<IPEndPoint, ConnectionRequest> _requestsDict = new Dictionary<IPEndPoint, ConnectionRequest>(new IPEndPointComparer());
        private readonly Dictionary<IPEndPoint, NtpRequest> _ntpRequests = new Dictionary<IPEndPoint, NtpRequest>(new IPEndPointComparer());
        private readonly ReaderWriterLockSlim _peersLock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
        private volatile NetPeer _headPeer;
        private int _connectedPeersCount;
        private readonly List<NetPeer> _connectedPeerListCache = new List<NetPeer>();
        private NetPeer[] _peersArray = new NetPeer[32];
        private readonly PacketLayerBase _extraPacketLayer;
        private int _lastPeerId;
        private ConcurrentQueue<int> _peerIds = new ConcurrentQueue<int>();
        private byte _channelsCount = 1;
        private readonly object _eventLock = new object();

        //config section
        /// <summary>
        /// Enable messages receiving without connection. (with SendUnconnectedMessage method)
        /// </summary>
        public bool UnconnectedMessagesEnabled = false;

        /// <summary>
        /// Enable nat punch messages
        /// </summary>
        public bool NatPunchEnabled = false;

        /// <summary>
        /// Library logic update and send period in milliseconds
        /// Lowest values in Windows doesn't change much because of Thread.Sleep precision
        /// To more frequent sends (or sends tied to your game logic) use <see cref="TriggerUpdate"/>
        /// </summary>
        public int UpdateTime = 15;

        /// <summary>
        /// Interval for latency detection and checking connection (in milliseconds)
        /// </summary>
        public int PingInterval = 1000;

        /// <summary>
        /// If NetManager doesn't receive any packet from remote peer during this time (in milliseconds) then connection will be closed
        /// (including library internal keepalive packets)
        /// </summary>
        public int DisconnectTimeout = 5000;

        /// <summary>
        /// Simulate packet loss by dropping random amount of packets. (Works only in DEBUG mode)
        /// </summary>
        public bool SimulatePacketLoss = false;

        /// <summary>
        /// Simulate latency by holding packets for random time. (Works only in DEBUG mode)
        /// </summary>
        public bool SimulateLatency = false;

        /// <summary>
        /// Chance of packet loss when simulation enabled. value in percents (1 - 100).
        /// </summary>
        public int SimulationPacketLossChance = 10;

        /// <summary>
        /// Minimum simulated latency (in milliseconds)
        /// </summary>
        public int SimulationMinLatency = 30;

        /// <summary>
        /// Maximum simulated latency (in milliseconds)
        /// </summary>
        public int SimulationMaxLatency = 100;

        /// <summary>
        /// Events automatically will be called without PollEvents method from another thread
        /// </summary>
        public bool UnsyncedEvents = false;

        /// <summary>
        /// If true - receive event will be called from "receive" thread immediately otherwise on PollEvents call
        /// </summary>
        public bool UnsyncedReceiveEvent = false;

        /// <summary>
        /// If true - delivery event will be called from "receive" thread immediately otherwise on PollEvents call
        /// </summary>
        public bool UnsyncedDeliveryEvent = false;

        /// <summary>
        /// Allows receive broadcast packets
        /// </summary>
        public bool BroadcastReceiveEnabled = false;

        /// <summary>
        /// Delay between initial connection attempts (in milliseconds)
        /// </summary>
        public int ReconnectDelay = 500;

        /// <summary>
        /// Maximum connection attempts before client stops and call disconnect event.
        /// </summary>
        public int MaxConnectAttempts = 10;

        /// <summary>
        /// Enables socket option "ReuseAddress" for specific purposes
        /// </summary>
        public bool ReuseAddress = false;

        /// <summary>
        /// Statistics of all connections
        /// </summary>
        public readonly NetStatistics Statistics = new NetStatistics();

        /// <summary>
        /// Toggles the collection of network statistics for the instance and all known peers
        /// </summary>
        public bool EnableStatistics = false;

        /// <summary>
        /// NatPunchModule for NAT hole punching operations
        /// </summary>
        public readonly NatPunchModule NatPunchModule;

        /// <summary>
        /// Returns true if socket listening and update thread is running
        /// </summary>
        public bool IsRunning { get; private set; }

        /// <summary>
        /// Local EndPoint (host and port)
        /// </summary>
        public int LocalPort { get; private set; }

        /// <summary>
        /// Automatically recycle NetPacketReader after OnReceive event
        /// </summary>
        public bool AutoRecycle;

        /// <summary>
        /// IPv6 support
        /// </summary>
        public IPv6Mode IPv6Mode = IPv6Mode.SeparateSocket;

        /// <summary>
        /// Override MTU for all new peers registered in this NetManager, will ignores MTU Discovery!
        /// </summary>
        public int MtuOverride = 0;

        /// <summary>
        /// Sets initial MTU to lowest possible value according to RFC1191 (576 bytes)
        /// </summary>
        public bool UseSafeMtu = false;

        /// <summary>
        /// First peer. Useful for Client mode
        /// </summary>
        public NetPeer FirstPeer => _headPeer;

        /// <summary>
        /// Experimental feature mostly for servers. Only for Windows/Linux
        /// use direct socket calls for send/receive to drastically increase speed and reduce GC pressure
        /// </summary>
        public bool UseNativeSockets = false;

        /// <summary>
        /// Disconnect peers if HostUnreachable or NetworkUnreachable spawned (old behaviour 0.9.x was true)
        /// </summary>
        public bool DisconnectOnUnreachable = false;

        /// <summary>
        /// Allows peer change it's ip (lte to wifi, wifi to lte, etc). Use only on server
        /// </summary>
        public bool AllowPeerAddressChange = false;

        /// <summary>
        /// QoS channel count per message type (value must be between 1 and 64 channels)
        /// </summary>
        public byte ChannelsCount
        {
            get => _channelsCount;
            set
            {
                if (value < 1 || value > 64)
                    throw new ArgumentException("Channels count must be between 1 and 64");
                _channelsCount = value;
            }
        }

        /// <summary>
        /// Returns connected peers list (with internal cached list)
        /// </summary>
        public List<NetPeer> ConnectedPeerList
        {
            get
            {
                GetPeersNonAlloc(_connectedPeerListCache, ConnectionState.Connected);
                return _connectedPeerListCache;
            }
        }

        /// <summary>
        /// Gets peer by peer id
        /// </summary>
        /// <param name="id">id of peer</param>
        /// <returns>Peer if peer with id exist, otherwise null</returns>
        public NetPeer GetPeerById(int id)
        {
            if (id >= 0 && id < _peersArray.Length)
            {
                return _peersArray[id];
            }

            return null;
        }

        /// <summary>
        /// Gets peer by peer id
        /// </summary>
        /// <param name="id">id of peer</param>
        /// <param name="peer">resulting peer</param>
        /// <returns>True if peer with id exist, otherwise false</returns>
        public bool TryGetPeerById(int id, out NetPeer peer)
        {
            peer = GetPeerById(id);

            return peer != null;
        }

        /// <summary>
        /// Returns connected peers count
        /// </summary>
        public int ConnectedPeersCount => Interlocked.CompareExchange(ref _connectedPeersCount,0,0);

        public int ExtraPacketSizeForLayer => _extraPacketLayer?.ExtraPacketSizeForLayer ?? 0;

        private bool TryGetPeer(IPEndPoint endPoint, out NetPeer peer)
        {
            _peersLock.EnterReadLock();
            bool result = _peersDict.TryGetValue(endPoint, out peer);
            _peersLock.ExitReadLock();
            return result;
        }

        private void AddPeer(NetPeer peer)
        {
            _peersLock.EnterWriteLock();
            if (_headPeer != null)
            {
                peer.NextPeer = _headPeer;
                _headPeer.PrevPeer = peer;
            }
            _headPeer = peer;
            _peersDict.Add(peer.EndPoint, peer);
            if (peer.Id >= _peersArray.Length)
            {
                int newSize = _peersArray.Length * 2;
                while (peer.Id >= newSize)
                    newSize *= 2;
                Array.Resize(ref _peersArray, newSize);
            }
            _peersArray[peer.Id] = peer;
            RegisterEndPoint(peer.EndPoint);
            _peersLock.ExitWriteLock();
        }

        private void RemovePeer(NetPeer peer)
        {
            _peersLock.EnterWriteLock();
            RemovePeerInternal(peer);
            _peersLock.ExitWriteLock();
        }

        private void RemovePeerInternal(NetPeer peer)
        {
            if (!_peersDict.Remove(peer.EndPoint))
                return;
            if (peer == _headPeer)
                _headPeer = peer.NextPeer;

            if (peer.PrevPeer != null)
                peer.PrevPeer.NextPeer = peer.NextPeer;
            if (peer.NextPeer != null)
                peer.NextPeer.PrevPeer = peer.PrevPeer;
            peer.PrevPeer = null;

            _peersArray[peer.Id] = null;
            _peerIds.Enqueue(peer.Id);
            UnregisterEndPoint(peer.EndPoint);
        }

        /// <summary>
        /// NetManager constructor
        /// </summary>
        /// <param name="listener">Network events listener (also can implement IDeliveryEventListener)</param>
        /// <param name="extraPacketLayer">Extra processing of packages, like CRC checksum or encryption. All connected NetManagers must have same layer.</param>
        public NetManager(INetEventListener listener, PacketLayerBase extraPacketLayer = null)
        {
            _netEventListener = listener;
            _deliveryEventListener = listener as IDeliveryEventListener;
            _ntpEventListener = listener as INtpEventListener;
            _peerAddressChangedListener = listener as IPeerAddressChangedListener;
            NatPunchModule = new NatPunchModule(this);
            _extraPacketLayer = extraPacketLayer;
        }

        internal void ConnectionLatencyUpdated(NetPeer fromPeer, int latency)
        {
            CreateEvent(NetEvent.EType.ConnectionLatencyUpdated, fromPeer, latency: latency);
        }

        internal void MessageDelivered(NetPeer fromPeer, object userData)
        {
            if(_deliveryEventListener != null)
                CreateEvent(NetEvent.EType.MessageDelivered, fromPeer, userData: userData);
        }

        internal void DisconnectPeerForce(NetPeer peer,
            DisconnectReason reason,
            SocketError socketErrorCode,
            NetPacket eventData)
        {
            DisconnectPeer(peer, reason, socketErrorCode, true, null, 0, 0, eventData);
        }

        private void DisconnectPeer(
            NetPeer peer,
            DisconnectReason reason,
            SocketError socketErrorCode,
            bool force,
            byte[] data,
            int start,
            int count,
            NetPacket eventData)
        {
            var shutdownResult = peer.Shutdown(data, start, count, force);
            if (shutdownResult == ShutdownResult.None)
                return;
            if(shutdownResult == ShutdownResult.WasConnected)
                Interlocked.Decrement(ref _connectedPeersCount);
            CreateEvent(
                NetEvent.EType.Disconnect,
                peer,
                errorCode: socketErrorCode,
                disconnectReason: reason,
                readerSource: eventData);
        }

        private void CreateEvent(
            NetEvent.EType type,
            NetPeer peer = null,
            IPEndPoint remoteEndPoint = null,
            SocketError errorCode = 0,
            int latency = 0,
            DisconnectReason disconnectReason = DisconnectReason.ConnectionFailed,
            ConnectionRequest connectionRequest = null,
            DeliveryMethod deliveryMethod = DeliveryMethod.Unreliable,
            byte channelNumber = 0,
            NetPacket readerSource = null,
            object userData = null)
        {
            NetEvent evt;
            bool unsyncEvent = UnsyncedEvents;

            if (type == NetEvent.EType.Connect)
                Interlocked.Increment(ref _connectedPeersCount);
            else if (type == NetEvent.EType.MessageDelivered)
                unsyncEvent = UnsyncedDeliveryEvent;

            lock(_eventLock)
            {
                evt = _netEventPoolHead;
                if (evt == null)
                    evt = new NetEvent(this);
                else
                    _netEventPoolHead = evt.Next;
            }

            evt.Type = type;
            evt.DataReader.SetSource(readerSource, readerSource?.GetHeaderSize() ?? 0);
            evt.Peer = peer;
            evt.RemoteEndPoint = remoteEndPoint;
            evt.Latency = latency;
            evt.ErrorCode = errorCode;
            evt.DisconnectReason = disconnectReason;
            evt.ConnectionRequest = connectionRequest;
            evt.DeliveryMethod = deliveryMethod;
            evt.ChannelNumber = channelNumber;
            evt.UserData = userData;

            if (unsyncEvent || _manualMode)
            {
                ProcessEvent(evt);
            }
            else
            {
                lock(_netEventsProduceQueue)
                    _netEventsProduceQueue.Enqueue(evt);
            }
        }

        private void ProcessEvent(NetEvent evt)
        {
            NetDebug.Write("[NM] Processing event: " + evt.Type);
            bool emptyData = evt.DataReader.IsNull;
            switch (evt.Type)
            {
                case NetEvent.EType.Connect:
                    _netEventListener.OnPeerConnected(evt.Peer);
                    break;
                case NetEvent.EType.Disconnect:
                    var info = new DisconnectInfo
                    {
                        Reason = evt.DisconnectReason,
                        AdditionalData = evt.DataReader,
                        SocketErrorCode = evt.ErrorCode
                    };
                    _netEventListener.OnPeerDisconnected(evt.Peer, info);
                    break;
                case NetEvent.EType.Receive:
                    _netEventListener.OnNetworkReceive(evt.Peer, evt.DataReader, evt.ChannelNumber, evt.DeliveryMethod);
                    break;
                case NetEvent.EType.ReceiveUnconnected:
                    _netEventListener.OnNetworkReceiveUnconnected(evt.RemoteEndPoint, evt.DataReader, UnconnectedMessageType.BasicMessage);
                    break;
                case NetEvent.EType.Broadcast:
                    _netEventListener.OnNetworkReceiveUnconnected(evt.RemoteEndPoint, evt.DataReader, UnconnectedMessageType.Broadcast);
                    break;
                case NetEvent.EType.Error:
                    _netEventListener.OnNetworkError(evt.RemoteEndPoint, evt.ErrorCode);
                    break;
                case NetEvent.EType.ConnectionLatencyUpdated:
                    _netEventListener.OnNetworkLatencyUpdate(evt.Peer, evt.Latency);
                    break;
                case NetEvent.EType.ConnectionRequest:
                    _netEventListener.OnConnectionRequest(evt.ConnectionRequest);
                    break;
                case NetEvent.EType.MessageDelivered:
                    _deliveryEventListener.OnMessageDelivered(evt.Peer, evt.UserData);
                    break;
                case NetEvent.EType.PeerAddressChanged:
                    _peersLock.EnterUpgradeableReadLock();
                    IPEndPoint previousAddress = null;
                    if (_peersDict.ContainsKey(evt.Peer.EndPoint))
                    {
                        _peersLock.EnterWriteLock();
                        _peersDict.Remove(evt.Peer.EndPoint);
                        previousAddress = evt.Peer.EndPoint;
                        evt.Peer.FinishEndPointChange(evt.RemoteEndPoint);
                        _peersDict.Add(evt.Peer.EndPoint, evt.Peer);
                        _peersLock.ExitWriteLock();
                    }
                    _peersLock.ExitUpgradeableReadLock();
                    if(previousAddress != null)
                        _peerAddressChangedListener.OnPeerAddressChanged(evt.Peer, previousAddress);
                    break;
            }
            //Recycle if not message
            if (emptyData)
                RecycleEvent(evt);
            else if (AutoRecycle)
                evt.DataReader.RecycleInternal();
        }

        internal void RecycleEvent(NetEvent evt)
        {
            evt.Peer = null;
            evt.ErrorCode = 0;
            evt.RemoteEndPoint = null;
            evt.ConnectionRequest = null;
            lock(_eventLock)
            {
                evt.Next = _netEventPoolHead;
                _netEventPoolHead = evt;
            }
        }

        //Update function
        private void UpdateLogic()
        {
            var peersToRemove = new List<NetPeer>();
            var stopwatch = new Stopwatch();
            stopwatch.Start();

            while (IsRunning)
            {
                try
                {
                    ProcessDelayedPackets();
                    int elapsed = (int)stopwatch.ElapsedMilliseconds;
                    elapsed = elapsed <= 0 ? 1 : elapsed;
                    stopwatch.Restart();

                    for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                    {
                        if (netPeer.ConnectionState == ConnectionState.Disconnected &&
                            netPeer.TimeSinceLastPacket > DisconnectTimeout)
                        {
                            peersToRemove.Add(netPeer);
                        }
                        else
                        {
                            netPeer.Update(elapsed);
                        }
                    }

                    if (peersToRemove.Count > 0)
                    {
                        _peersLock.EnterWriteLock();
                        for (int i = 0; i < peersToRemove.Count; i++)
                            RemovePeerInternal(peersToRemove[i]);
                        _peersLock.ExitWriteLock();
                        peersToRemove.Clear();
                    }

                    ProcessNtpRequests(elapsed);

                    int sleepTime = UpdateTime - (int)stopwatch.ElapsedMilliseconds;
                    if (sleepTime > 0)
                        _updateTriggerEvent.WaitOne(sleepTime);
                }
                catch (ThreadAbortException)
                {
                    return;
                }
                catch (Exception e)
                {
                    NetDebug.WriteError("[NM] LogicThread error: " + e);
                }
            }
            stopwatch.Stop();
        }

        [Conditional("DEBUG")]
        private void ProcessDelayedPackets()
        {
#if DEBUG
            if (!SimulateLatency)
                return;

            var time = DateTime.UtcNow;
            lock (_pingSimulationList)
            {
                for (int i = 0; i < _pingSimulationList.Count; i++)
                {
                    var incomingData = _pingSimulationList[i];
                    if (incomingData.TimeWhenGet <= time)
                    {
                        DebugMessageReceived(incomingData.Data, incomingData.EndPoint);
                        _pingSimulationList.RemoveAt(i);
                        i--;
                    }
                }
            }
#endif
        }

        private void ProcessNtpRequests(int elapsedMilliseconds)
        {
            List<IPEndPoint> requestsToRemove = null;
            foreach (var ntpRequest in _ntpRequests)
            {
                ntpRequest.Value.Send(_udpSocketv4, elapsedMilliseconds);
                if(ntpRequest.Value.NeedToKill)
                {
                    if (requestsToRemove == null)
                        requestsToRemove = new List<IPEndPoint>();
                    requestsToRemove.Add(ntpRequest.Key);
                }
            }

            if (requestsToRemove != null)
            {
                foreach (var ipEndPoint in requestsToRemove)
                {
                    _ntpRequests.Remove(ipEndPoint);
                }
            }
        }

        /// <summary>
        /// Update and send logic. Use this only when NetManager started in manual mode
        /// </summary>
        /// <param name="elapsedMilliseconds">elapsed milliseconds since last update call</param>
        public void ManualUpdate(int elapsedMilliseconds)
        {
            if (!_manualMode)
                return;

            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
            {
                if (netPeer.ConnectionState == ConnectionState.Disconnected && netPeer.TimeSinceLastPacket > DisconnectTimeout)
                {
                    RemovePeerInternal(netPeer);
                }
                else
                {
                    netPeer.Update(elapsedMilliseconds);
                }
            }
            ProcessNtpRequests(elapsedMilliseconds);
        }

        internal NetPeer OnConnectionSolved(ConnectionRequest request, byte[] rejectData, int start, int length)
        {
            NetPeer netPeer = null;

            if (request.Result == ConnectionRequestResult.RejectForce)
            {
                NetDebug.Write(NetLogLevel.Trace, "[NM] Peer connect reject force.");
                if (rejectData != null && length > 0)
                {
                    var shutdownPacket = PoolGetWithProperty(PacketProperty.Disconnect, length);
                    shutdownPacket.ConnectionNumber = request.InternalPacket.ConnectionNumber;
                    FastBitConverter.GetBytes(shutdownPacket.RawData, 1, request.InternalPacket.ConnectionTime);
                    if (shutdownPacket.Size >= NetConstants.PossibleMtu[0])
                        NetDebug.WriteError("[Peer] Disconnect additional data size more than MTU!");
                    else
                        Buffer.BlockCopy(rejectData, start, shutdownPacket.RawData, 9, length);
                    SendRawAndRecycle(shutdownPacket, request.RemoteEndPoint);
                }
            }
            else
            {
                _peersLock.EnterUpgradeableReadLock();
                if (_peersDict.TryGetValue(request.RemoteEndPoint, out netPeer))
                {
                    //already have peer
                    _peersLock.ExitUpgradeableReadLock();
                }
                else if (request.Result == ConnectionRequestResult.Reject)
                {
                    netPeer = new NetPeer(this, request.RemoteEndPoint, GetNextPeerId());
                    netPeer.Reject(request.InternalPacket, rejectData, start, length);
                    AddPeer(netPeer);
                    _peersLock.ExitUpgradeableReadLock();
                    NetDebug.Write(NetLogLevel.Trace, "[NM] Peer connect reject.");
                }
                else //Accept
                {
                    netPeer = new NetPeer(this, request, GetNextPeerId());
                    AddPeer(netPeer);
                    _peersLock.ExitUpgradeableReadLock();
                    CreateEvent(NetEvent.EType.Connect, netPeer);
                    NetDebug.Write(NetLogLevel.Trace, "[NM] Received peer connection Id: {0}, EP: {1}",
                        netPeer.ConnectTime, netPeer.EndPoint);
                }
            }

            lock(_requestsDict)
                _requestsDict.Remove(request.RemoteEndPoint);

            return netPeer;
        }

        private int GetNextPeerId()
        {
            return _peerIds.TryDequeue(out int id) ? id : _lastPeerId++;
        }

        private void ProcessConnectRequest(
            IPEndPoint remoteEndPoint,
            NetPeer netPeer,
            NetConnectRequestPacket connRequest)
        {
            //if we have peer
            if (netPeer != null)
            {
                var processResult = netPeer.ProcessConnectRequest(connRequest);
                NetDebug.Write("ConnectRequest LastId: {0}, NewId: {1}, EP: {2}, Result: {3}",
                    netPeer.ConnectTime,
                    connRequest.ConnectionTime,
                    remoteEndPoint,
                    processResult);

                switch (processResult)
                {
                    case ConnectRequestResult.Reconnection:
                        DisconnectPeerForce(netPeer, DisconnectReason.Reconnect, 0, null);
                        RemovePeer(netPeer);
                        //go to new connection
                        break;
                    case ConnectRequestResult.NewConnection:
                        RemovePeer(netPeer);
                        //go to new connection
                        break;
                    case ConnectRequestResult.P2PLose:
                        DisconnectPeerForce(netPeer, DisconnectReason.PeerToPeerConnection, 0, null);
                        RemovePeer(netPeer);
                        //go to new connection
                        break;
                    default:
                        //no operations needed
                        return;
                }
                //ConnectRequestResult.NewConnection
                //Set next connection number
                if(processResult != ConnectRequestResult.P2PLose)
                    connRequest.ConnectionNumber = (byte)((netPeer.ConnectionNum + 1) % NetConstants.MaxConnectionNumber);
                //To reconnect peer
            }
            else
            {
                NetDebug.Write("ConnectRequest Id: {0}, EP: {1}", connRequest.ConnectionTime, remoteEndPoint);
            }

            ConnectionRequest req;
            lock (_requestsDict)
            {
                if (_requestsDict.TryGetValue(remoteEndPoint, out req))
                {
                    req.UpdateRequest(connRequest);
                    return;
                }
                req = new ConnectionRequest(remoteEndPoint, connRequest, this);
                _requestsDict.Add(remoteEndPoint, req);
            }
            NetDebug.Write("[NM] Creating request event: " + connRequest.ConnectionTime);
            CreateEvent(NetEvent.EType.ConnectionRequest, connectionRequest: req);
        }

        private void OnMessageReceived(NetPacket packet, IPEndPoint remoteEndPoint)
        {
#if DEBUG
            if (SimulatePacketLoss && _randomGenerator.NextDouble() * 100 < SimulationPacketLossChance)
            {
                //drop packet
                return;
            }
            if (SimulateLatency)
            {
                int latency = _randomGenerator.Next(SimulationMinLatency, SimulationMaxLatency);
                if (latency > MinLatencyThreshold)
                {
                    lock (_pingSimulationList)
                    {
                        _pingSimulationList.Add(new IncomingData
                        {
                            Data = packet,
                            EndPoint = remoteEndPoint,
                            TimeWhenGet = DateTime.UtcNow.AddMilliseconds(latency)
                        });
                    }
                    //hold packet
                    return;
                }
            }

            //ProcessEvents
            DebugMessageReceived(packet, remoteEndPoint);
        }

        private void DebugMessageReceived(NetPacket packet, IPEndPoint remoteEndPoint)
        {
#endif
            if (EnableStatistics)
            {
                Statistics.IncrementPacketsReceived();
                Statistics.AddBytesReceived(packet.Size);
            }

            if (_ntpRequests.Count > 0)
            {
                if (_ntpRequests.TryGetValue(remoteEndPoint, out var request))
                {
                    if (packet.Size < 48)
                    {
                        NetDebug.Write(NetLogLevel.Trace, "NTP response too short: {}", packet.Size);
                        return;
                    }

                    byte[] copiedData = new byte[packet.Size];
                    Buffer.BlockCopy(packet.RawData, 0, copiedData, 0, packet.Size);
                    NtpPacket ntpPacket = NtpPacket.FromServerResponse(copiedData, DateTime.UtcNow);
                    try
                    {
                        ntpPacket.ValidateReply();
                    }
                    catch (InvalidOperationException ex)
                    {
                        NetDebug.Write(NetLogLevel.Trace, "NTP response error: {}", ex.Message);
                        ntpPacket = null;
                    }

                    if (ntpPacket != null)
                    {
                        _ntpRequests.Remove(remoteEndPoint);
                        _ntpEventListener?.OnNtpResponse(ntpPacket);
                    }
                    return;
                }
            }

            if (_extraPacketLayer != null)
            {
                int start = 0;
                _extraPacketLayer.ProcessInboundPacket(ref remoteEndPoint, ref packet.RawData, ref start, ref packet.Size);
                if (packet.Size == 0)
                    return;
            }

            if (!packet.Verify())
            {
                NetDebug.WriteError("[NM] DataReceived: bad!");
                PoolRecycle(packet);
                return;
            }

            switch (packet.Property)
            {
                //special case connect request
                case PacketProperty.ConnectRequest:
                    if (NetConnectRequestPacket.GetProtocolId(packet) != NetConstants.ProtocolId)
                    {
                        SendRawAndRecycle(PoolGetWithProperty(PacketProperty.InvalidProtocol), remoteEndPoint);
                        return;
                    }
                    break;
                //unconnected messages
                case PacketProperty.Broadcast:
                    if (!BroadcastReceiveEnabled)
                        return;
                    CreateEvent(NetEvent.EType.Broadcast, remoteEndPoint: remoteEndPoint, readerSource: packet);
                    return;
                case PacketProperty.UnconnectedMessage:
                    if (!UnconnectedMessagesEnabled)
                        return;
                    CreateEvent(NetEvent.EType.ReceiveUnconnected, remoteEndPoint: remoteEndPoint, readerSource: packet);
                    return;
                case PacketProperty.NatMessage:
                    if (NatPunchEnabled)
                        NatPunchModule.ProcessMessage(remoteEndPoint, packet);
                    return;
            }

            //Check normal packets
            _peersLock.EnterReadLock();
            bool peerFound = _peersDict.TryGetValue(remoteEndPoint, out var netPeer);
            _peersLock.ExitReadLock();

            switch (packet.Property)
            {
                case PacketProperty.ConnectRequest:
                    var connRequest = NetConnectRequestPacket.FromData(packet);
                    if (connRequest != null)
                        ProcessConnectRequest(remoteEndPoint, netPeer, connRequest);
                    break;
                case PacketProperty.PeerNotFound:
                    if (peerFound) //local
                    {
                        if (netPeer.ConnectionState != ConnectionState.Connected)
                            return;
                        if (packet.Size == 1)
                        {
                            //first reply
                            //send NetworkChanged packet
                            netPeer.ResetMtu();
                            SendRaw(NetConnectAcceptPacket.MakeNetworkChanged(netPeer), remoteEndPoint);
                            NetDebug.Write($"PeerNotFound sending connection info: {remoteEndPoint}");
                        }
                        else if (packet.Size == 2 && packet.RawData[1] == 1)
                        {
                            //second reply
                            DisconnectPeerForce(netPeer, DisconnectReason.PeerNotFound, 0, null);
                        }
                    }
                    else if (packet.Size > 1) //remote
                    {
                        //check if this is old peer
                        bool isOldPeer = false;

                        if (AllowPeerAddressChange)
                        {
                            NetDebug.Write($"[NM] Looks like address change: {packet.Size}");
                            var remoteData = NetConnectAcceptPacket.FromData(packet);
                            if (remoteData != null &&
                                remoteData.PeerNetworkChanged &&
                                remoteData.PeerId < _peersArray.Length)
                            {
                                _peersLock.EnterUpgradeableReadLock();
                                var peer = _peersArray[remoteData.PeerId];
                                if (peer != null &&
                                    peer.ConnectTime == remoteData.ConnectionTime &&
                                    peer.ConnectionNum == remoteData.ConnectionNumber)
                                {
                                    if (peer.ConnectionState == ConnectionState.Connected)
                                    {
                                        peer.InitiateEndPointChange();
                                        if (_peerAddressChangedListener != null)
                                        {
                                            CreateEvent(NetEvent.EType.PeerAddressChanged, peer, remoteEndPoint);
                                        }
                                        NetDebug.Write("[NM] PeerNotFound change address of remote peer");
                                    }
                                    isOldPeer = true;
                                }
                                _peersLock.ExitUpgradeableReadLock();
                            }
                        }

                        PoolRecycle(packet);

                        //else peer really not found
                        if (!isOldPeer)
                        {
                            var secondResponse = PoolGetWithProperty(PacketProperty.PeerNotFound, 1);
                            secondResponse.RawData[1] = 1;
                            SendRawAndRecycle(secondResponse, remoteEndPoint);
                        }
                    }
                    break;
                case PacketProperty.InvalidProtocol:
                    if (peerFound && netPeer.ConnectionState == ConnectionState.Outgoing)
                        DisconnectPeerForce(netPeer, DisconnectReason.InvalidProtocol, 0, null);
                    break;
                case PacketProperty.Disconnect:
                    if (peerFound)
                    {
                        var disconnectResult = netPeer.ProcessDisconnect(packet);
                        if (disconnectResult == DisconnectResult.None)
                        {
                            PoolRecycle(packet);
                            return;
                        }
                        DisconnectPeerForce(
                            netPeer,
                            disconnectResult == DisconnectResult.Disconnect
                            ? DisconnectReason.RemoteConnectionClose
                            : DisconnectReason.ConnectionRejected,
                            0, packet);
                    }
                    else
                    {
                        PoolRecycle(packet);
                    }
                    //Send shutdown
                    SendRawAndRecycle(PoolGetWithProperty(PacketProperty.ShutdownOk), remoteEndPoint);
                    break;
                case PacketProperty.ConnectAccept:
                    if (!peerFound)
                        return;
                    var connAccept = NetConnectAcceptPacket.FromData(packet);
                    if (connAccept != null && netPeer.ProcessConnectAccept(connAccept))
                        CreateEvent(NetEvent.EType.Connect, netPeer);
                    break;
                default:
                    if(peerFound)
                        netPeer.ProcessPacket(packet);
                    else
                        SendRawAndRecycle(PoolGetWithProperty(PacketProperty.PeerNotFound), remoteEndPoint);
                    break;
            }
        }

        internal void CreateReceiveEvent(NetPacket packet, DeliveryMethod method, byte channelNumber, int headerSize, NetPeer fromPeer)
        {
            NetEvent evt;
            lock (_eventLock)
            {
                evt = _netEventPoolHead;
                if (evt == null)
                    evt = new NetEvent(this);
                else
                    _netEventPoolHead = evt.Next;
            }
            evt.Type = NetEvent.EType.Receive;
            evt.DataReader.SetSource(packet, headerSize);
            evt.Peer = fromPeer;
            evt.DeliveryMethod = method;
            evt.ChannelNumber = channelNumber;
            if (UnsyncedEvents || UnsyncedReceiveEvent || _manualMode)
            {
                ProcessEvent(evt);
            }
            else
            {
                lock(_netEventsProduceQueue)
                    _netEventsProduceQueue.Enqueue(evt);
            }
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="writer">DataWriter with data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(NetDataWriter writer, DeliveryMethod options)
        {
            SendToAll(writer.Data, 0, writer.Length, options);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(byte[] data, DeliveryMethod options)
        {
            SendToAll(data, 0, data.Length, options);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(byte[] data, int start, int length, DeliveryMethod options)
        {
            SendToAll(data, start, length, 0, options);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="writer">DataWriter with data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(NetDataWriter writer, byte channelNumber, DeliveryMethod options)
        {
            SendToAll(writer.Data, 0, writer.Length, channelNumber, options);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(byte[] data, byte channelNumber, DeliveryMethod options)
        {
            SendToAll(data, 0, data.Length, channelNumber, options);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(byte[] data, int start, int length, byte channelNumber, DeliveryMethod options)
        {
            try
            {
                _peersLock.EnterReadLock();
                for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                    netPeer.Send(data, start, length, channelNumber, options);
            }
            finally
            {
                _peersLock.ExitReadLock();
            }
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="writer">DataWriter with data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(NetDataWriter writer, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(writer.Data, 0, writer.Length, 0, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(byte[] data, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(data, 0, data.Length, 0, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(byte[] data, int start, int length, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(data, start, length, 0, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="writer">DataWriter with data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(NetDataWriter writer, byte channelNumber, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(writer.Data, 0, writer.Length, channelNumber, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(byte[] data, byte channelNumber, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(data, 0, data.Length, channelNumber, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(byte[] data, int start, int length, byte channelNumber, DeliveryMethod options, NetPeer excludePeer)
        {
            try
            {
                _peersLock.EnterReadLock();
                for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                {
                    if (netPeer != excludePeer)
                        netPeer.Send(data, start, length, channelNumber, options);
                }
            }
            finally
            {
                _peersLock.ExitReadLock();
            }
        }

        /// <summary>
        /// Start logic thread and listening on available port
        /// </summary>
        public bool Start()
        {
            return Start(0);
        }

        /// <summary>
        /// Start logic thread and listening on selected port
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        public bool Start(IPAddress addressIPv4, IPAddress addressIPv6, int port)
        {
            return Start(addressIPv4, addressIPv6, port, false);
        }

        /// <summary>
        /// Start logic thread and listening on selected port
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        public bool Start(string addressIPv4, string addressIPv6, int port)
        {
            IPAddress ipv4 = NetUtils.ResolveAddress(addressIPv4);
            IPAddress ipv6 = NetUtils.ResolveAddress(addressIPv6);
            return Start(ipv4, ipv6, port);
        }

        /// <summary>
        /// Start logic thread and listening on selected port
        /// </summary>
        /// <param name="port">port to listen</param>
        public bool Start(int port)
        {
            return Start(IPAddress.Any, IPAddress.IPv6Any, port);
        }

        /// <summary>
        /// Start in manual mode and listening on selected port
        /// In this mode you should use ManualReceive (without PollEvents) for receive packets
        /// and ManualUpdate(...) for update and send packets
        /// This mode useful mostly for single-threaded servers
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        public bool StartInManualMode(IPAddress addressIPv4, IPAddress addressIPv6, int port)
        {
            return Start(addressIPv4, addressIPv6, port, true);
        }

        /// <summary>
        /// Start in manual mode and listening on selected port
        /// In this mode you should use ManualReceive (without PollEvents) for receive packets
        /// and ManualUpdate(...) for update and send packets
        /// This mode useful mostly for single-threaded servers
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        public bool StartInManualMode(string addressIPv4, string addressIPv6, int port)
        {
            IPAddress ipv4 = NetUtils.ResolveAddress(addressIPv4);
            IPAddress ipv6 = NetUtils.ResolveAddress(addressIPv6);
            return StartInManualMode(ipv4, ipv6, port);
        }

        /// <summary>
        /// Start in manual mode and listening on selected port
        /// In this mode you should use ManualReceive (without PollEvents) for receive packets
        /// and ManualUpdate(...) for update and send packets
        /// This mode useful mostly for single-threaded servers
        /// </summary>
        /// <param name="port">port to listen</param>
        public bool StartInManualMode(int port)
        {
            return StartInManualMode(IPAddress.Any, IPAddress.IPv6Any, port);
        }

        /// <summary>
        /// Send message without connection
        /// </summary>
        /// <param name="message">Raw data</param>
        /// <param name="remoteEndPoint">Packet destination</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(byte[] message, IPEndPoint remoteEndPoint)
        {
            return SendUnconnectedMessage(message, 0, message.Length, remoteEndPoint);
        }

        /// <summary>
        /// Send message without connection. WARNING This method allocates a new IPEndPoint object and
        /// synchronously makes a DNS request. If you're calling this method every frame it will be
        /// much faster to just cache the IPEndPoint.
        /// </summary>
        /// <param name="writer">Data serializer</param>
        /// <param name="address">Packet destination IP or hostname</param>
        /// <param name="port">Packet destination port</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(NetDataWriter writer, string address, int port)
        {
            IPEndPoint remoteEndPoint = NetUtils.MakeEndPoint(address, port);

            return SendUnconnectedMessage(writer.Data, 0, writer.Length, remoteEndPoint);
        }

        /// <summary>
        /// Send message without connection
        /// </summary>
        /// <param name="writer">Data serializer</param>
        /// <param name="remoteEndPoint">Packet destination</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(NetDataWriter writer, IPEndPoint remoteEndPoint)
        {
            return SendUnconnectedMessage(writer.Data, 0, writer.Length, remoteEndPoint);
        }

        /// <summary>
        /// Send message without connection
        /// </summary>
        /// <param name="message">Raw data</param>
        /// <param name="start">data start</param>
        /// <param name="length">data length</param>
        /// <param name="remoteEndPoint">Packet destination</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(byte[] message, int start, int length, IPEndPoint remoteEndPoint)
        {
            //No need for CRC here, SendRaw does that
            NetPacket packet = PoolGetWithData(PacketProperty.UnconnectedMessage, message, start, length);
            return SendRawAndRecycle(packet, remoteEndPoint) > 0;
        }

        /// <summary>
        /// Triggers update and send logic immediately (works asynchronously)
        /// </summary>
        public void TriggerUpdate()
        {
            _updateTriggerEvent.Set();
        }

        /// <summary>
        /// Receive all pending events. Call this in game update code
        /// In Manual mode it will call also socket Receive (which can be slow)
        /// </summary>
        public void PollEvents()
        {
            if (_manualMode)
            {
                if (_udpSocketv4 != null)
                    ManualReceive(_udpSocketv4, _bufferEndPointv4);
                if (_udpSocketv6 != null && _udpSocketv6 != _udpSocketv4)
                    ManualReceive(_udpSocketv6, _bufferEndPointv6);
                ProcessDelayedPackets();
                return;
            }
            if (UnsyncedEvents)
                return;
            lock (_netEventsProduceQueue)
            {
                (_netEventsConsumeQueue, _netEventsProduceQueue) = (_netEventsProduceQueue, _netEventsConsumeQueue);
            }

            while(_netEventsConsumeQueue.Count > 0)
                ProcessEvent(_netEventsConsumeQueue.Dequeue());
        }

        /// <summary>
        /// Connect to remote host
        /// </summary>
        /// <param name="address">Server IP or hostname</param>
        /// <param name="port">Server Port</param>
        /// <param name="key">Connection key</param>
        /// <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
        /// <exception cref="InvalidOperationException">Manager is not running. Call <see cref="Start()"/></exception>
        public NetPeer Connect(string address, int port, string key)
        {
            return Connect(address, port, NetDataWriter.FromString(key));
        }

        /// <summary>
        /// Connect to remote host
        /// </summary>
        /// <param name="address">Server IP or hostname</param>
        /// <param name="port">Server Port</param>
        /// <param name="connectionData">Additional data for remote peer</param>
        /// <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
        /// <exception cref="InvalidOperationException">Manager is not running. Call <see cref="Start()"/></exception>
        public NetPeer Connect(string address, int port, NetDataWriter connectionData)
        {
            IPEndPoint ep;
            try
            {
                ep = NetUtils.MakeEndPoint(address, port);
            }
            catch
            {
                CreateEvent(NetEvent.EType.Disconnect, disconnectReason: DisconnectReason.UnknownHost);
                return null;
            }
            return Connect(ep, connectionData);
        }

        /// <summary>
        /// Connect to remote host
        /// </summary>
        /// <param name="target">Server end point (ip and port)</param>
        /// <param name="key">Connection key</param>
        /// <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
        /// <exception cref="InvalidOperationException">Manager is not running. Call <see cref="Start()"/></exception>
        public NetPeer Connect(IPEndPoint target, string key)
        {
            return Connect(target, NetDataWriter.FromString(key));
        }

        /// <summary>
        /// Connect to remote host
        /// </summary>
        /// <param name="target">Server end point (ip and port)</param>
        /// <param name="connectionData">Additional data for remote peer</param>
        /// <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
        /// <exception cref="InvalidOperationException">Manager is not running. Call <see cref="Start()"/></exception>
        public NetPeer Connect(IPEndPoint target, NetDataWriter connectionData)
        {
            if (!IsRunning)
                throw new InvalidOperationException("Client is not running");

            lock(_requestsDict)
            {
                if (_requestsDict.ContainsKey(target))
                    return null;
            }

            byte connectionNumber = 0;
            _peersLock.EnterUpgradeableReadLock();
            if (_peersDict.TryGetValue(target, out var peer))
            {
                switch (peer.ConnectionState)
                {
                    //just return already connected peer
                    case ConnectionState.Connected:
                    case ConnectionState.Outgoing:
                        _peersLock.ExitUpgradeableReadLock();
                        return peer;
                }
                //else reconnect
                connectionNumber = (byte)((peer.ConnectionNum + 1) % NetConstants.MaxConnectionNumber);
                RemovePeer(peer);
            }

            //Create reliable connection
            //And send connection request
            peer = new NetPeer(this, target, GetNextPeerId(), connectionNumber, connectionData);
            AddPeer(peer);
            _peersLock.ExitUpgradeableReadLock();

            return peer;
        }

        /// <summary>
        /// Force closes connection and stop all threads.
        /// </summary>
        public void Stop()
        {
            Stop(true);
        }

        /// <summary>
        /// Force closes connection and stop all threads.
        /// </summary>
        /// <param name="sendDisconnectMessages">Send disconnect messages</param>
        public void Stop(bool sendDisconnectMessages)
        {
            if (!IsRunning)
                return;
            NetDebug.Write("[NM] Stop");

            //Send last disconnect
            for(var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                netPeer.Shutdown(null, 0, 0, !sendDisconnectMessages);

            //Stop
            CloseSocket(false);
            _updateTriggerEvent.Set();
            if (!_manualMode)
            {
                _logicThread.Join();
                _logicThread = null;
            }

            //clear peers
            _peersLock.EnterWriteLock();
            _headPeer = null;
            _peersDict.Clear();
            _peersArray = new NetPeer[32];
            _peersLock.ExitWriteLock();
            _peerIds = new ConcurrentQueue<int>();
            _lastPeerId = 0;
#if DEBUG
            lock (_pingSimulationList)
                _pingSimulationList.Clear();
#endif
            _connectedPeersCount = 0;
            _netEventsProduceQueue.Clear();
            _netEventsConsumeQueue.Clear();
        }

        /// <summary>
        /// Return peers count with connection state
        /// </summary>
        /// <param name="peerState">peer connection state (you can use as bit flags)</param>
        /// <returns>peers count</returns>
        public int GetPeersCount(ConnectionState peerState)
        {
            int count = 0;
            _peersLock.EnterReadLock();
            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
            {
                if ((netPeer.ConnectionState & peerState) != 0)
                    count++;
            }
            _peersLock.ExitReadLock();
            return count;
        }

        /// <summary>
        /// Get copy of peers (without allocations)
        /// </summary>
        /// <param name="peers">List that will contain result</param>
        /// <param name="peerState">State of peers</param>
        public void GetPeersNonAlloc(List<NetPeer> peers, ConnectionState peerState)
        {
            peers.Clear();
            _peersLock.EnterReadLock();
            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
            {
                if ((netPeer.ConnectionState & peerState) != 0)
                    peers.Add(netPeer);
            }
            _peersLock.ExitReadLock();
        }

        /// <summary>
        /// Disconnect all peers without any additional data
        /// </summary>
        public void DisconnectAll()
        {
            DisconnectAll(null, 0, 0);
        }

        /// <summary>
        /// Disconnect all peers with shutdown message
        /// </summary>
        /// <param name="data">Data to send (must be less or equal MTU)</param>
        /// <param name="start">Data start</param>
        /// <param name="count">Data count</param>
        public void DisconnectAll(byte[] data, int start, int count)
        {
            //Send disconnect packets
            _peersLock.EnterReadLock();
            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
            {
                DisconnectPeer(
                    netPeer,
                    DisconnectReason.DisconnectPeerCalled,
                    0,
                    false,
                    data,
                    start,
                    count,
                    null);
            }
            _peersLock.ExitReadLock();
        }

        /// <summary>
        /// Immediately disconnect peer from server without additional data
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        public void DisconnectPeerForce(NetPeer peer)
        {
            DisconnectPeerForce(peer, DisconnectReason.DisconnectPeerCalled, 0, null);
        }

        /// <summary>
        /// Disconnect peer from server
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        public void DisconnectPeer(NetPeer peer)
        {
            DisconnectPeer(peer, null, 0, 0);
        }

        /// <summary>
        /// Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        /// <param name="data">additional data</param>
        public void DisconnectPeer(NetPeer peer, byte[] data)
        {
            DisconnectPeer(peer, data, 0, data.Length);
        }

        /// <summary>
        /// Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        /// <param name="writer">additional data</param>
        public void DisconnectPeer(NetPeer peer, NetDataWriter writer)
        {
            DisconnectPeer(peer, writer.Data, 0, writer.Length);
        }

        /// <summary>
        /// Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        /// <param name="data">additional data</param>
        /// <param name="start">data start</param>
        /// <param name="count">data length</param>
        public void DisconnectPeer(NetPeer peer, byte[] data, int start, int count)
        {
            DisconnectPeer(
                peer,
                DisconnectReason.DisconnectPeerCalled,
                0,
                false,
                data,
                start,
                count,
                null);
        }

        /// <summary>
        /// Create the requests for NTP server
        /// </summary>
        /// <param name="endPoint">NTP Server address.</param>
        public void CreateNtpRequest(IPEndPoint endPoint)
        {
            _ntpRequests.Add(endPoint, new NtpRequest(endPoint));
        }

        /// <summary>
        /// Create the requests for NTP server
        /// </summary>
        /// <param name="ntpServerAddress">NTP Server address.</param>
        /// <param name="port">port</param>
        public void CreateNtpRequest(string ntpServerAddress, int port)
        {
            IPEndPoint endPoint = NetUtils.MakeEndPoint(ntpServerAddress, port);
            _ntpRequests.Add(endPoint, new NtpRequest(endPoint));
        }

        /// <summary>
        /// Create the requests for NTP server (default port)
        /// </summary>
        /// <param name="ntpServerAddress">NTP Server address.</param>
        public void CreateNtpRequest(string ntpServerAddress)
        {
            IPEndPoint endPoint = NetUtils.MakeEndPoint(ntpServerAddress, NtpRequest.DefaultPort);
            _ntpRequests.Add(endPoint, new NtpRequest(endPoint));
        }

        public NetPeerEnumerator GetEnumerator()
        {
            return new NetPeerEnumerator(_headPeer);
        }

        IEnumerator<NetPeer> IEnumerable<NetPeer>.GetEnumerator()
        {
            return new NetPeerEnumerator(_headPeer);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return new NetPeerEnumerator(_headPeer);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetPacket.cs ---
﻿using System;
using System.Net;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    internal enum PacketProperty : byte
    {
        Unreliable,
        Channeled,
        Ack,
        Ping,
        Pong,
        ConnectRequest,
        ConnectAccept,
        Disconnect,
        UnconnectedMessage,
        MtuCheck,
        MtuOk,
        Broadcast,
        Merged,
        ShutdownOk,
        PeerNotFound,
        InvalidProtocol,
        NatMessage,
        Empty
    }

    internal sealed class NetPacket
    {
        private static readonly int PropertiesCount = Enum.GetValues(typeof(PacketProperty)).Length;
        private static readonly int[] HeaderSizes;

        static NetPacket()
        {
            HeaderSizes = NetUtils.AllocatePinnedUninitializedArray<int>(PropertiesCount);
            for (int i = 0; i < HeaderSizes.Length; i++)
            {
                switch ((PacketProperty)i)
                {
                    case PacketProperty.Channeled:
                    case PacketProperty.Ack:
                        HeaderSizes[i] = NetConstants.ChanneledHeaderSize;
                        break;
                    case PacketProperty.Ping:
                        HeaderSizes[i] = NetConstants.HeaderSize + 2;
                        break;
                    case PacketProperty.ConnectRequest:
                        HeaderSizes[i] = NetConnectRequestPacket.HeaderSize;
                        break;
                    case PacketProperty.ConnectAccept:
                        HeaderSizes[i] = NetConnectAcceptPacket.Size;
                        break;
                    case PacketProperty.Disconnect:
                        HeaderSizes[i] = NetConstants.HeaderSize + 8;
                        break;
                    case PacketProperty.Pong:
                        HeaderSizes[i] = NetConstants.HeaderSize + 10;
                        break;
                    default:
                        HeaderSizes[i] = NetConstants.HeaderSize;
                        break;
                }
            }
        }

        //Header
        public PacketProperty Property
        {
            get => (PacketProperty)(RawData[0] & 0x1F);
            set => RawData[0] = (byte)((RawData[0] & 0xE0) | (byte)value);
        }

        public byte ConnectionNumber
        {
            get => (byte)((RawData[0] & 0x60) >> 5);
            set => RawData[0] = (byte) ((RawData[0] & 0x9F) | (value << 5));
        }

        public ushort Sequence
        {
            get => BitConverter.ToUInt16(RawData, 1);
            set => FastBitConverter.GetBytes(RawData, 1, value);
        }

        public bool IsFragmented => (RawData[0] & 0x80) != 0;

        public void MarkFragmented()
        {
            RawData[0] |= 0x80; //set first bit
        }

        public byte ChannelId
        {
            get => RawData[3];
            set => RawData[3] = value;
        }

        public ushort FragmentId
        {
            get => BitConverter.ToUInt16(RawData, 4);
            set => FastBitConverter.GetBytes(RawData, 4, value);
        }

        public ushort FragmentPart
        {
            get => BitConverter.ToUInt16(RawData, 6);
            set => FastBitConverter.GetBytes(RawData, 6, value);
        }

        public ushort FragmentsTotal
        {
            get => BitConverter.ToUInt16(RawData, 8);
            set => FastBitConverter.GetBytes(RawData, 8, value);
        }

        //Data
        public byte[] RawData;
        public int Size;

        //Delivery
        public object UserData;

        //Pool node
        public NetPacket Next;

        public NetPacket(int size)
        {
            RawData = new byte[size];
            Size = size;
        }

        public NetPacket(PacketProperty property, int size)
        {
            size += GetHeaderSize(property);
            RawData = new byte[size];
            Property = property;
            Size = size;
        }

        public static int GetHeaderSize(PacketProperty property)
        {
            return HeaderSizes[(int)property];
        }

        public int GetHeaderSize()
        {
            return HeaderSizes[RawData[0] & 0x1F];
        }

        public bool Verify()
        {
            byte property = (byte)(RawData[0] & 0x1F);
            if (property >= PropertiesCount)
                return false;
            int headerSize = HeaderSizes[property];
            bool fragmented = (RawData[0] & 0x80) != 0;
            return Size >= headerSize && (!fragmented || Size >= headerSize + NetConstants.FragmentHeaderSize);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetPeer.cs ---
﻿#if DEBUG
#define STATS_ENABLED
#endif
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Threading;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    /// <summary>
    /// Peer connection state
    /// </summary>
    [Flags]
    public enum ConnectionState : byte
    {
        Outgoing         = 1 << 1,
        Connected         = 1 << 2,
        ShutdownRequested = 1 << 3,
        Disconnected      = 1 << 4,
        EndPointChange    = 1 << 5,
        Any = Outgoing | Connected | ShutdownRequested | EndPointChange
    }

    internal enum ConnectRequestResult
    {
        None,
        P2PLose, //when peer connecting
        Reconnection,  //when peer was connected
        NewConnection  //when peer was disconnected
    }

    internal enum DisconnectResult
    {
        None,
        Reject,
        Disconnect
    }

    internal enum ShutdownResult
    {
        None,
        Success,
        WasConnected
    }

    /// <summary>
    /// Network peer. Main purpose is sending messages to specific peer.
    /// </summary>
    public class NetPeer
    {
        //Ping and RTT
        private int _rtt;
        private int _avgRtt;
        private int _rttCount;
        private double _resendDelay = 27.0;
        private int _pingSendTimer;
        private int _rttResetTimer;
        private readonly Stopwatch _pingTimer = new Stopwatch();
        private int _timeSinceLastPacket;
        private long _remoteDelta;

        //Common
        private readonly object _shutdownLock = new object();

        internal volatile NetPeer NextPeer;
        internal NetPeer PrevPeer;

        internal byte ConnectionNum
        {
            get => _connectNum;
            private set
            {
                _connectNum = value;
                _mergeData.ConnectionNumber = value;
                _pingPacket.ConnectionNumber = value;
                _pongPacket.ConnectionNumber = value;
            }
        }

        //Channels
        private readonly Queue<NetPacket> _unreliableChannel;
        private readonly ConcurrentQueue<BaseChannel> _channelSendQueue;
        private readonly BaseChannel[] _channels;

        //MTU
        private int _mtu;
        private int _mtuIdx;
        private bool _finishMtu;
        private int _mtuCheckTimer;
        private int _mtuCheckAttempts;
        private const int MtuCheckDelay = 1000;
        private const int MaxMtuCheckAttempts = 4;
        private readonly object _mtuMutex = new object();

        //Fragment
        private class IncomingFragments
        {
            public NetPacket[] Fragments;
            public int ReceivedCount;
            public int TotalSize;
            public byte ChannelId;
        }
        private int _fragmentId;
        private readonly Dictionary<ushort, IncomingFragments> _holdedFragments;
        private readonly Dictionary<ushort, ushort> _deliveredFragments;

        //Merging
        private readonly NetPacket _mergeData;
        private int _mergePos;
        private int _mergeCount;

        //Connection
        private IPEndPoint _remoteEndPoint;
        private int _connectAttempts;
        private int _connectTimer;
        private long _connectTime;
        private byte _connectNum;
        private ConnectionState _connectionState;
        private NetPacket _shutdownPacket;
        private const int ShutdownDelay = 300;
        private int _shutdownTimer;
        private readonly NetPacket _pingPacket;
        private readonly NetPacket _pongPacket;
        private readonly NetPacket _connectRequestPacket;
        private readonly NetPacket _connectAcceptPacket;

        /// <summary>
        /// Peer ip address and port
        /// </summary>
        public IPEndPoint EndPoint => _remoteEndPoint;

        /// <summary>
        /// Peer parent NetManager
        /// </summary>
        public readonly NetManager NetManager;

        /// <summary>
        /// Current connection state
        /// </summary>
        public ConnectionState ConnectionState => _connectionState;

        /// <summary>
        /// Connection time for internal purposes
        /// </summary>
        internal long ConnectTime => _connectTime;

        /// <summary>
        /// Peer id can be used as key in your dictionary of peers
        /// </summary>
        public readonly int Id;

        /// <summary>
        /// Id assigned from server
        /// </summary>
        public int RemoteId { get; private set; }

        /// <summary>
        /// Current one-way ping (RTT/2) in milliseconds
        /// </summary>
        public int Ping => _avgRtt/2;

        /// <summary>
        /// Round trip time in milliseconds
        /// </summary>
        public int RoundTripTime => _avgRtt;

        /// <summary>
        /// Current MTU - Maximum Transfer Unit ( maximum udp packet size without fragmentation )
        /// </summary>
        public int Mtu => _mtu;

        /// <summary>
        /// Delta with remote time in ticks (not accurate)
        /// positive - remote time > our time
        /// </summary>
        public long RemoteTimeDelta => _remoteDelta;

        /// <summary>
        /// Remote UTC time (not accurate)
        /// </summary>
        public DateTime RemoteUtcTime => new DateTime(DateTime.UtcNow.Ticks + _remoteDelta);

        /// <summary>
        /// Time since last packet received (including internal library packets)
        /// </summary>
        public int TimeSinceLastPacket => _timeSinceLastPacket;

        internal double ResendDelay => _resendDelay;

        /// <summary>
        /// Application defined object containing data about the connection
        /// </summary>
        public object Tag;

        /// <summary>
        /// Statistics of peer connection
        /// </summary>
        public readonly NetStatistics Statistics;

        //incoming connection constructor
        internal NetPeer(NetManager netManager, IPEndPoint remoteEndPoint, int id)
        {
            Id = id;
            Statistics = new NetStatistics();
            NetManager = netManager;
            ResetMtu();
            _remoteEndPoint = remoteEndPoint;
            _connectionState = ConnectionState.Connected;
            _mergeData = new NetPacket(PacketProperty.Merged, NetConstants.MaxPacketSize);
            _pongPacket = new NetPacket(PacketProperty.Pong, 0);
            _pingPacket = new NetPacket(PacketProperty.Ping, 0) {Sequence = 1};

            _unreliableChannel = new Queue<NetPacket>();
            _holdedFragments = new Dictionary<ushort, IncomingFragments>();
            _deliveredFragments = new Dictionary<ushort, ushort>();

            _channels = new BaseChannel[netManager.ChannelsCount * NetConstants.ChannelTypeCount];
            _channelSendQueue = new ConcurrentQueue<BaseChannel>();
        }

        internal void InitiateEndPointChange()
        {
            ResetMtu();
            _connectionState = ConnectionState.EndPointChange;
        }

        internal void FinishEndPointChange(IPEndPoint newEndPoint)
        {
            if (_connectionState != ConnectionState.EndPointChange)
                return;
            _connectionState = ConnectionState.Connected;
            _remoteEndPoint = newEndPoint;
        }

        internal void ResetMtu()
        {
            _finishMtu = false;
            if (NetManager.MtuOverride > 0)
                OverrideMtu(NetManager.MtuOverride);
            else if (NetManager.UseSafeMtu)
                SetMtu(0);
            else
                SetMtu(1);
        }

        private void SetMtu(int mtuIdx)
        {
            _mtuIdx = mtuIdx;
            _mtu = NetConstants.PossibleMtu[mtuIdx] - NetManager.ExtraPacketSizeForLayer;
        }

        private void OverrideMtu(int mtuValue)
        {
            _mtu = mtuValue;
            _finishMtu = true;
        }

        /// <summary>
        /// Returns packets count in queue for reliable channel
        /// </summary>
        /// <param name="channelNumber">number of channel 0-63</param>
        /// <param name="ordered">type of channel ReliableOrdered or ReliableUnordered</param>
        /// <returns>packets count in channel queue</returns>
        public int GetPacketsCountInReliableQueue(byte channelNumber, bool ordered)
        {
            int idx = channelNumber * NetConstants.ChannelTypeCount +
                       (byte) (ordered ? DeliveryMethod.ReliableOrdered : DeliveryMethod.ReliableUnordered);
            var channel = _channels[idx];
            return channel != null ? ((ReliableChannel)channel).PacketsInQueue : 0;
        }

        /// <summary>
        /// Create temporary packet (maximum size MTU - headerSize) to send later without additional copies
        /// </summary>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <returns>PooledPacket that you can use to write data starting from UserDataOffset</returns>
        public PooledPacket CreatePacketFromPool(DeliveryMethod deliveryMethod, byte channelNumber)
        {
            //multithreaded variable
            int mtu = _mtu;
            var packet = NetManager.PoolGetPacket(mtu);
            if (deliveryMethod == DeliveryMethod.Unreliable)
            {
                packet.Property = PacketProperty.Unreliable;
                return new PooledPacket(packet, mtu, 0);
            }
            else
            {
                packet.Property = PacketProperty.Channeled;
                return new PooledPacket(packet, mtu, (byte)(channelNumber * NetConstants.ChannelTypeCount + (byte)deliveryMethod));
            }
        }

        /// <summary>
        /// Sends pooled packet without data copy
        /// </summary>
        /// <param name="packet">packet to send</param>
        /// <param name="userDataSize">size of user data you want to send</param>
        public void SendPooledPacket(PooledPacket packet, int userDataSize)
        {
            if (_connectionState != ConnectionState.Connected)
                return;
            packet._packet.Size = packet.UserDataOffset + userDataSize;
            if (packet._packet.Property == PacketProperty.Channeled)
            {
                CreateChannel(packet._channelNumber).AddToQueue(packet._packet);
            }
            else
            {
                lock(_unreliableChannel)
                    _unreliableChannel.Enqueue(packet._packet);
            }
        }

        private BaseChannel CreateChannel(byte idx)
        {
            BaseChannel newChannel = _channels[idx];
            if (newChannel != null)
                return newChannel;
            switch ((DeliveryMethod)(idx % NetConstants.ChannelTypeCount))
            {
                case DeliveryMethod.ReliableUnordered:
                    newChannel = new ReliableChannel(this, false, idx);
                    break;
                case DeliveryMethod.Sequenced:
                    newChannel = new SequencedChannel(this, false, idx);
                    break;
                case DeliveryMethod.ReliableOrdered:
                    newChannel = new ReliableChannel(this, true, idx);
                    break;
                case DeliveryMethod.ReliableSequenced:
                    newChannel = new SequencedChannel(this, true, idx);
                    break;
            }
            BaseChannel prevChannel = Interlocked.CompareExchange(ref _channels[idx], newChannel, null);
            if (prevChannel != null)
                return prevChannel;

            return newChannel;
        }

        //"Connect to" constructor
        internal NetPeer(NetManager netManager, IPEndPoint remoteEndPoint, int id, byte connectNum, NetDataWriter connectData)
            : this(netManager, remoteEndPoint, id)
        {
            _connectTime = DateTime.UtcNow.Ticks;
            _connectionState = ConnectionState.Outgoing;
            ConnectionNum = connectNum;

            //Make initial packet
            _connectRequestPacket = NetConnectRequestPacket.Make(connectData, remoteEndPoint.Serialize(), _connectTime, id);
            _connectRequestPacket.ConnectionNumber = connectNum;

            //Send request
            NetManager.SendRaw(_connectRequestPacket, _remoteEndPoint);

            NetDebug.Write(NetLogLevel.Trace, $"[CC] ConnectId: {_connectTime}, ConnectNum: {connectNum}");
        }

        //"Accept" incoming constructor
        internal NetPeer(NetManager netManager, ConnectionRequest request, int id)
            : this(netManager, request.RemoteEndPoint, id)
        {
            _connectTime = request.InternalPacket.ConnectionTime;
            ConnectionNum = request.InternalPacket.ConnectionNumber;
            RemoteId = request.InternalPacket.PeerId;

            //Make initial packet
            _connectAcceptPacket = NetConnectAcceptPacket.Make(_connectTime, ConnectionNum, id);

            //Make Connected
            _connectionState = ConnectionState.Connected;

            //Send
            NetManager.SendRaw(_connectAcceptPacket, _remoteEndPoint);

            NetDebug.Write(NetLogLevel.Trace, $"[CC] ConnectId: {_connectTime}");
        }

        //Reject
        internal void Reject(NetConnectRequestPacket requestData, byte[] data, int start, int length)
        {
            _connectTime = requestData.ConnectionTime;
            _connectNum = requestData.ConnectionNumber;
            Shutdown(data, start, length, false);
        }

        internal bool ProcessConnectAccept(NetConnectAcceptPacket packet)
        {
            if (_connectionState != ConnectionState.Outgoing)
                return false;

            //check connection id
            if (packet.ConnectionTime != _connectTime)
            {
                NetDebug.Write(NetLogLevel.Trace, $"[NC] Invalid connectId: {packet.ConnectionTime} != our({_connectTime})");
                return false;
            }
            //check connect num
            ConnectionNum = packet.ConnectionNumber;
            RemoteId = packet.PeerId;

            NetDebug.Write(NetLogLevel.Trace, "[NC] Received connection accept");
            Interlocked.Exchange(ref _timeSinceLastPacket, 0);
            _connectionState = ConnectionState.Connected;
            return true;
        }

        /// <summary>
        /// Gets maximum size of packet that will be not fragmented.
        /// </summary>
        /// <param name="options">Type of packet that you want send</param>
        /// <returns>size in bytes</returns>
        public int GetMaxSinglePacketSize(DeliveryMethod options)
        {
            return _mtu - NetPacket.GetHeaderSize(options == DeliveryMethod.Unreliable ? PacketProperty.Unreliable : PacketProperty.Channeled);
        }

        /// <summary>
        /// Send data to peer with delivery event called
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="userData">User data that will be received in DeliveryEvent</param>
        /// <exception cref="ArgumentException">
        ///     If you trying to send unreliable packet type<para/>
        /// </exception>
        public void SendWithDeliveryEvent(byte[] data, byte channelNumber, DeliveryMethod deliveryMethod, object userData)
        {
            if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                throw new ArgumentException("Delivery event will work only for ReliableOrdered/Unordered packets");
            SendInternal(data, 0, data.Length, channelNumber, deliveryMethod, userData);
        }

        /// <summary>
        /// Send data to peer with delivery event called
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="userData">User data that will be received in DeliveryEvent</param>
        /// <exception cref="ArgumentException">
        ///     If you trying to send unreliable packet type<para/>
        /// </exception>
        public void SendWithDeliveryEvent(byte[] data, int start, int length, byte channelNumber, DeliveryMethod deliveryMethod, object userData)
        {
            if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                throw new ArgumentException("Delivery event will work only for ReliableOrdered/Unordered packets");
            SendInternal(data, start, length, channelNumber, deliveryMethod, userData);
        }

        /// <summary>
        /// Send data to peer with delivery event called
        /// </summary>
        /// <param name="dataWriter">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="userData">User data that will be received in DeliveryEvent</param>
        /// <exception cref="ArgumentException">
        ///     If you trying to send unreliable packet type<para/>
        /// </exception>
        public void SendWithDeliveryEvent(NetDataWriter dataWriter, byte channelNumber, DeliveryMethod deliveryMethod, object userData)
        {
            if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                throw new ArgumentException("Delivery event will work only for ReliableOrdered/Unordered packets");
            SendInternal(dataWriter.Data, 0, dataWriter.Length, channelNumber, deliveryMethod, userData);
        }

        /// <summary>
        /// Send data to peer (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(byte[] data, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, 0, data.Length, 0, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer (channel - 0)
        /// </summary>
        /// <param name="dataWriter">DataWriter with data</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(NetDataWriter dataWriter, DeliveryMethod deliveryMethod)
        {
            SendInternal(dataWriter.Data, 0, dataWriter.Length, 0, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(byte[] data, int start, int length, DeliveryMethod options)
        {
            SendInternal(data, start, length, 0, options, null);
        }

        /// <summary>
        /// Send data to peer
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(byte[] data, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, 0, data.Length, channelNumber, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer
        /// </summary>
        /// <param name="dataWriter">DataWriter with data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(NetDataWriter dataWriter, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            SendInternal(dataWriter.Data, 0, dataWriter.Length, channelNumber, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(byte[] data, int start, int length, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, start, length, channelNumber, deliveryMethod, null);
        }

        private void SendInternal(
            byte[] data,
            int start,
            int length,
            byte channelNumber,
            DeliveryMethod deliveryMethod,
            object userData)
        {
            if (_connectionState != ConnectionState.Connected || channelNumber >= _channels.Length)
                return;

            //Select channel
            PacketProperty property;
            BaseChannel channel = null;

            if (deliveryMethod == DeliveryMethod.Unreliable)
            {
                property = PacketProperty.Unreliable;
            }
            else
            {
                property = PacketProperty.Channeled;
                channel = CreateChannel((byte)(channelNumber * NetConstants.ChannelTypeCount + (byte)deliveryMethod));
            }

            //Prepare
            NetDebug.Write("[RS]Packet: " + property);

            //Check fragmentation
            int headerSize = NetPacket.GetHeaderSize(property);
            //Save mtu for multithread
            int mtu = _mtu;
            if (length + headerSize > mtu)
            {
                //if cannot be fragmented
                if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                    throw new TooBigPacketException("Unreliable or ReliableSequenced packet size exceeded maximum of " + (mtu - headerSize) + " bytes, Check allowed size by GetMaxSinglePacketSize()");

                int packetFullSize = mtu - headerSize;
                int packetDataSize = packetFullSize - NetConstants.FragmentHeaderSize;
                int totalPackets = length / packetDataSize + (length % packetDataSize == 0 ? 0 : 1);

                NetDebug.Write("FragmentSend:\n" +
                           " MTU: {0}\n" +
                           " headerSize: {1}\n" +
                           " packetFullSize: {2}\n" +
                           " packetDataSize: {3}\n" +
                           " totalPackets: {4}",
                    mtu, headerSize, packetFullSize, packetDataSize, totalPackets);

                if (totalPackets > ushort.MaxValue)
                    throw new TooBigPacketException("Data was split in " + totalPackets + " fragments, which exceeds " + ushort.MaxValue);

                ushort currentFragmentId = (ushort)Interlocked.Increment(ref _fragmentId);

                for(ushort partIdx = 0; partIdx < totalPackets; partIdx++)
                {
                    int sendLength = length > packetDataSize ? packetDataSize : length;

                    NetPacket p = NetManager.PoolGetPacket(headerSize + sendLength + NetConstants.FragmentHeaderSize);
                    p.Property = property;
                    p.UserData = userData;
                    p.FragmentId = currentFragmentId;
                    p.FragmentPart = partIdx;
                    p.FragmentsTotal = (ushort)totalPackets;
                    p.MarkFragmented();

                    Buffer.BlockCopy(data, start + partIdx * packetDataSize, p.RawData, NetConstants.FragmentedHeaderTotalSize, sendLength);
                    channel.AddToQueue(p);

                    length -= sendLength;
                }
                return;
            }

            //Else just send
            NetPacket packet = NetManager.PoolGetPacket(headerSize + length);
            packet.Property = property;
            Buffer.BlockCopy(data, start, packet.RawData, headerSize, length);
            packet.UserData = userData;

            if (channel == null) //unreliable
            {
                lock(_unreliableChannel)
                    _unreliableChannel.Enqueue(packet);
            }
            else
            {
                channel.AddToQueue(packet);
            }
        }

#if LITENETLIB_SPANS || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1 || NETCOREAPP3_1 || NET5_0 || NETSTANDARD2_1
        /// <summary>
        /// Send data to peer with delivery event called
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="userData">User data that will be received in DeliveryEvent</param>
        /// <exception cref="ArgumentException">
        ///     If you trying to send unreliable packet type<para/>
        /// </exception>
        public void SendWithDeliveryEvent(ReadOnlySpan<byte> data, byte channelNumber, DeliveryMethod deliveryMethod, object userData)
        {
            if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                throw new ArgumentException("Delivery event will work only for ReliableOrdered/Unordered packets");
            SendInternal(data, channelNumber, deliveryMethod, userData);
        }

        /// <summary>
        /// Send data to peer (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(ReadOnlySpan<byte> data, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, 0, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(ReadOnlySpan<byte> data, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, channelNumber, deliveryMethod, null);
        }

        private void SendInternal(
            ReadOnlySpan<byte> data,
            byte channelNumber,
            DeliveryMethod deliveryMethod,
            object userData)
        {
            if (_connectionState != ConnectionState.Connected || channelNumber >= _channels.Length)
                return;

            //Select channel
            PacketProperty property;
            BaseChannel channel = null;

            if (deliveryMethod == DeliveryMethod.Unreliable)
            {
                property = PacketProperty.Unreliable;
            }
            else
            {
                property = PacketProperty.Channeled;
                channel = CreateChannel((byte)(channelNumber * NetConstants.ChannelTypeCount + (byte)deliveryMethod));
            }

            //Prepare
            NetDebug.Write("[RS]Packet: " + property);

            //Check fragmentation
            int headerSize = NetPacket.GetHeaderSize(property);
            //Save mtu for multithread
            int mtu = _mtu;
            int length = data.Length;
            if (length + headerSize > mtu)
            {
                //if cannot be fragmented
                if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                    throw new TooBigPacketException("Unreliable or ReliableSequenced packet size exceeded maximum of " + (mtu - headerSize) + " bytes, Check allowed size by GetMaxSinglePacketSize()");

                int packetFullSize = mtu - headerSize;
                int packetDataSize = packetFullSize - NetConstants.FragmentHeaderSize;
                int totalPackets = length / packetDataSize + (length % packetDataSize == 0 ? 0 : 1);

                if (totalPackets > ushort.MaxValue)
                    throw new TooBigPacketException("Data was split in " + totalPackets + " fragments, which exceeds " + ushort.MaxValue);

                ushort currentFragmentId = (ushort)Interlocked.Increment(ref _fragmentId);

                for (ushort partIdx = 0; partIdx < totalPackets; partIdx++)
                {
                    int sendLength = length > packetDataSize ? packetDataSize : length;

                    NetPacket p = NetManager.PoolGetPacket(headerSize + sendLength + NetConstants.FragmentHeaderSize);
                    p.Property = property;
                    p.UserData = userData;
                    p.FragmentId = currentFragmentId;
                    p.FragmentPart = partIdx;
                    p.FragmentsTotal = (ushort)totalPackets;
                    p.MarkFragmented();

                    data.Slice(partIdx * packetDataSize, sendLength).CopyTo(new Span<byte>(p.RawData, NetConstants.FragmentedHeaderTotalSize, sendLength));
                    channel.AddToQueue(p);

                    length -= sendLength;
                }
                return;
            }

            //Else just send
            NetPacket packet = NetManager.PoolGetPacket(headerSize + length);
            packet.Property = property;
            data.CopyTo(new Span<byte>(packet.RawData, headerSize, length));
            packet.UserData = userData;

            if (channel == null) //unreliable
            {
                lock(_unreliableChannel)
                    _unreliableChannel.Enqueue(packet);
            }
            else
            {
                channel.AddToQueue(packet);
            }
        }
#endif

        public void Disconnect(byte[] data)
        {
            NetManager.DisconnectPeer(this, data);
        }

        public void Disconnect(NetDataWriter writer)
        {
            NetManager.DisconnectPeer(this, writer);
        }

        public void Disconnect(byte[] data, int start, int count)
        {
            NetManager.DisconnectPeer(this, data, start, count);
        }

        public void Disconnect()
        {
            NetManager.DisconnectPeer(this);
        }

        internal DisconnectResult ProcessDisconnect(NetPacket packet)
        {
            if ((_connectionState == ConnectionState.Connected || _connectionState == ConnectionState.Outgoing) &&
                packet.Size >= 9 &&
                BitConverter.ToInt64(packet.RawData, 1) == _connectTime &&
                packet.ConnectionNumber == _connectNum)
            {
                return _connectionState == ConnectionState.Connected
                    ? DisconnectResult.Disconnect
                    : DisconnectResult.Reject;
            }
            return DisconnectResult.None;
        }

        internal void AddToReliableChannelSendQueue(BaseChannel channel)
        {
            _channelSendQueue.Enqueue(channel);
        }

        internal ShutdownResult Shutdown(byte[] data, int start, int length, bool force)
        {
            lock (_shutdownLock)
            {
                //trying to shutdown already disconnected
                if (_connectionState == ConnectionState.Disconnected ||
                    _connectionState == ConnectionState.ShutdownRequested)
                {
                    return ShutdownResult.None;
                }

                var result = _connectionState == ConnectionState.Connected
                    ? ShutdownResult.WasConnected
                    : ShutdownResult.Success;

                //don't send anything
                if (force)
                {
                    _connectionState = ConnectionState.Disconnected;
                    return result;
                }

                //reset time for reconnect protection
                Interlocked.Exchange(ref _timeSinceLastPacket, 0);

                //send shutdown packet
                _shutdownPacket = new NetPacket(PacketProperty.Disconnect, length) {ConnectionNumber = _connectNum};
                FastBitConverter.GetBytes(_shutdownPacket.RawData, 1, _connectTime);
                if (_shutdownPacket.Size >= _mtu)
                {
                    //Drop additional data
                    NetDebug.WriteError("[Peer] Disconnect additional data size more than MTU - 8!");
                }
                else if (data != null && length > 0)
                {
                    Buffer.BlockCopy(data, start, _shutdownPacket.RawData, 9, length);
                }
                _connectionState = ConnectionState.ShutdownRequested;
                NetDebug.Write("[Peer] Send disconnect");
                NetManager.SendRaw(_shutdownPacket, _remoteEndPoint);
                return result;
            }
        }

        private void UpdateRoundTripTime(int roundTripTime)
        {
            _rtt += roundTripTime;
            _rttCount++;
            _avgRtt = _rtt/_rttCount;
            _resendDelay = 25.0 + _avgRtt * 2.1; // 25 ms + double rtt
        }

        internal void AddReliablePacket(DeliveryMethod method, NetPacket p)
        {
            if (p.IsFragmented)
            {
                NetDebug.Write("Fragment. Id: {0}, Part: {1}, Total: {2}", p.FragmentId, p.FragmentPart, p.FragmentsTotal);
                //Get needed array from dictionary
                ushort packetFragId = p.FragmentId;
                byte packetChannelId = p.ChannelId;
                if (!_holdedFragments.TryGetValue(packetFragId, out var incomingFragments))
                {
                    incomingFragments = new IncomingFragments
                    {
                        Fragments = new NetPacket[p.FragmentsTotal],
                        ChannelId = p.ChannelId
                    };
                    _holdedFragments.Add(packetFragId, incomingFragments);
                }

                //Cache
                var fragments = incomingFragments.Fragments;

                //Error check
                if (p.FragmentPart >= fragments.Length ||
                    fragments[p.FragmentPart] != null ||
                    p.ChannelId != incomingFragments.ChannelId)
                {
                    NetManager.PoolRecycle(p);
                    NetDebug.WriteError("Invalid fragment packet");
                    return;
                }
                //Fill array
                fragments[p.FragmentPart] = p;

                //Increase received fragments count
                incomingFragments.ReceivedCount++;

                //Increase total size
                incomingFragments.TotalSize += p.Size - NetConstants.FragmentedHeaderTotalSize;

                //Check for finish
                if (incomingFragments.ReceivedCount != fragments.Length)
                    return;

                //just simple packet
                NetPacket resultingPacket = NetManager.PoolGetPacket(incomingFragments.TotalSize);

                int pos = 0;
                for (int i = 0; i < incomingFragments.ReceivedCount; i++)
                {
                    var fragment = fragments[i];
                    int writtenSize = fragment.Size - NetConstants.FragmentedHeaderTotalSize;

                    if (pos+writtenSize > resultingPacket.RawData.Length)
                    {
                        _holdedFragments.Remove(packetFragId);
                        NetDebug.WriteError("Fragment error pos: {0} >= resultPacketSize: {1} , totalSize: {2}",
                            pos + writtenSize,
                            resultingPacket.RawData.Length,
                            incomingFragments.TotalSize);
                        return;
                    }
                    if (fragment.Size > fragment.RawData.Length)
                    {
                        _holdedFragments.Remove(packetFragId);
                        NetDebug.WriteError("Fragment error size: {0} > fragment.RawData.Length: {1}", fragment.Size, fragment.RawData.Length);
                        return;
                    }

                    //Create resulting big packet
                    Buffer.BlockCopy(
                        fragment.RawData,
                        NetConstants.FragmentedHeaderTotalSize,
                        resultingPacket.RawData,
                        pos,
                        writtenSize);
                    pos += writtenSize;

                    //Free memory
                    NetManager.PoolRecycle(fragment);
                    fragments[i] = null;
                }

                //Clear memory
                _holdedFragments.Remove(packetFragId);

                //Send to process
                NetManager.CreateReceiveEvent(resultingPacket, method, (byte)(packetChannelId / NetConstants.ChannelTypeCount), 0, this);
            }
            else //Just simple packet
            {
                NetManager.CreateReceiveEvent(p, method, (byte)(p.ChannelId / NetConstants.ChannelTypeCount), NetConstants.ChanneledHeaderSize, this);
            }
        }

        private void ProcessMtuPacket(NetPacket packet)
        {
            //header + int
            if (packet.Size < NetConstants.PossibleMtu[0])
                return;

            //first stage check (mtu check and mtu ok)
            int receivedMtu = BitConverter.ToInt32(packet.RawData, 1);
            int endMtuCheck = BitConverter.ToInt32(packet.RawData, packet.Size - 4);
            if (receivedMtu != packet.Size || receivedMtu != endMtuCheck || receivedMtu > NetConstants.MaxPacketSize)
            {
                NetDebug.WriteError("[MTU] Broken packet. RMTU {0}, EMTU {1}, PSIZE {2}", receivedMtu, endMtuCheck, packet.Size);
                return;
            }

            if (packet.Property == PacketProperty.MtuCheck)
            {
                _mtuCheckAttempts = 0;
                NetDebug.Write("[MTU] check. send back: " + receivedMtu);
                packet.Property = PacketProperty.MtuOk;
                NetManager.SendRawAndRecycle(packet, _remoteEndPoint);
            }
            else if(receivedMtu > _mtu && !_finishMtu) //MtuOk
            {
                //invalid packet
                if (receivedMtu != NetConstants.PossibleMtu[_mtuIdx + 1] - NetManager.ExtraPacketSizeForLayer)
                    return;

                lock (_mtuMutex)
                {
                    SetMtu(_mtuIdx+1);
                }
                //if maxed - finish.
                if (_mtuIdx == NetConstants.PossibleMtu.Length - 1)
                    _finishMtu = true;
                NetManager.PoolRecycle(packet);
                NetDebug.Write("[MTU] ok. Increase to: " + _mtu);
            }
        }

        private void UpdateMtuLogic(int deltaTime)
        {
            if (_finishMtu)
                return;

            _mtuCheckTimer += deltaTime;
            if (_mtuCheckTimer < MtuCheckDelay)
                return;

            _mtuCheckTimer = 0;
            _mtuCheckAttempts++;
            if (_mtuCheckAttempts >= MaxMtuCheckAttempts)
            {
                _finishMtu = true;
                return;
            }

            lock (_mtuMutex)
            {
                if (_mtuIdx >= NetConstants.PossibleMtu.Length - 1)
                    return;

                //Send increased packet
                int newMtu = NetConstants.PossibleMtu[_mtuIdx + 1] - NetManager.ExtraPacketSizeForLayer;
                var p = NetManager.PoolGetPacket(newMtu);
                p.Property = PacketProperty.MtuCheck;
                FastBitConverter.GetBytes(p.RawData, 1, newMtu);         //place into start
                FastBitConverter.GetBytes(p.RawData, p.Size - 4, newMtu);//and end of packet

                //Must check result for MTU fix
                if (NetManager.SendRawAndRecycle(p, _remoteEndPoint) <= 0)
                    _finishMtu = true;
            }
        }

        internal ConnectRequestResult ProcessConnectRequest(NetConnectRequestPacket connRequest)
        {
            //current or new request
            switch (_connectionState)
            {
                //P2P case
                case ConnectionState.Outgoing:
                    //fast check
                    if (connRequest.ConnectionTime < _connectTime)
                    {
                        return ConnectRequestResult.P2PLose;
                    }
                    //slow rare case check
                    if (connRequest.ConnectionTime == _connectTime)
                    {
                        var remoteBytes = _remoteEndPoint.Serialize();
                        var localBytes = connRequest.TargetAddress;
                        for (int i = remoteBytes.Size-1; i >= 0; i--)
                        {
                            byte rb = remoteBytes[i];
                            if (rb == localBytes[i])
                                continue;
                            if (rb < localBytes[i])
                                return ConnectRequestResult.P2PLose;
                        }
                    }
                    break;

                case ConnectionState.Connected:
                    //Old connect request
                    if (connRequest.ConnectionTime == _connectTime)
                    {
                        //just reply accept
                        NetManager.SendRaw(_connectAcceptPacket, _remoteEndPoint);
                    }
                    //New connect request
                    else if (connRequest.ConnectionTime > _connectTime)
                    {
                        return ConnectRequestResult.Reconnection;
                    }
                    break;

                case ConnectionState.Disconnected:
                case ConnectionState.ShutdownRequested:
                    if (connRequest.ConnectionTime >= _connectTime)
                        return ConnectRequestResult.NewConnection;
                    break;
            }
            return ConnectRequestResult.None;
        }

        //Process incoming packet
        internal void ProcessPacket(NetPacket packet)
        {
            //not initialized
            if (_connectionState == ConnectionState.Outgoing || _connectionState == ConnectionState.Disconnected)
            {
                NetManager.PoolRecycle(packet);
                return;
            }
            if (packet.Property == PacketProperty.ShutdownOk)
            {
                if (_connectionState == ConnectionState.ShutdownRequested)
                    _connectionState = ConnectionState.Disconnected;
                NetManager.PoolRecycle(packet);
                return;
            }
            if (packet.ConnectionNumber != _connectNum)
            {
                NetDebug.Write(NetLogLevel.Trace, "[RR]Old packet");
                NetManager.PoolRecycle(packet);
                return;
            }
            Interlocked.Exchange(ref _timeSinceLastPacket, 0);

            NetDebug.Write("[RR]PacketProperty: {0}", packet.Property);
            switch (packet.Property)
            {
                case PacketProperty.Merged:
                    int pos = NetConstants.HeaderSize;
                    while (pos < packet.Size)
                    {
                        ushort size = BitConverter.ToUInt16(packet.RawData, pos);
                        pos += 2;
                        if (packet.RawData.Length - pos < size)
                            break;

                        NetPacket mergedPacket = NetManager.PoolGetPacket(size);
                        Buffer.BlockCopy(packet.RawData, pos, mergedPacket.RawData, 0, size);
                        mergedPacket.Size = size;

                        if (!mergedPacket.Verify())
                            break;

                        pos += size;
                        ProcessPacket(mergedPacket);
                    }
                    NetManager.PoolRecycle(packet);
                    break;
                //If we get ping, send pong
                case PacketProperty.Ping:
                    if (NetUtils.RelativeSequenceNumber(packet.Sequence, _pongPacket.Sequence) > 0)
                    {
                        NetDebug.Write("[PP]Ping receive, send pong");
                        FastBitConverter.GetBytes(_pongPacket.RawData, 3, DateTime.UtcNow.Ticks);
                        _pongPacket.Sequence = packet.Sequence;
                        NetManager.SendRaw(_pongPacket, _remoteEndPoint);
                    }
                    NetManager.PoolRecycle(packet);
                    break;

                //If we get pong, calculate ping time and rtt
                case PacketProperty.Pong:
                    if (packet.Sequence == _pingPacket.Sequence)
                    {
                        _pingTimer.Stop();
                        int elapsedMs = (int)_pingTimer.ElapsedMilliseconds;
                        _remoteDelta = BitConverter.ToInt64(packet.RawData, 3) + (elapsedMs * TimeSpan.TicksPerMillisecond ) / 2 - DateTime.UtcNow.Ticks;
                        UpdateRoundTripTime(elapsedMs);
                        NetManager.ConnectionLatencyUpdated(this, elapsedMs / 2);
                        NetDebug.Write("[PP]Ping: {0} - {1} - {2}", packet.Sequence, elapsedMs, _remoteDelta);
                    }
                    NetManager.PoolRecycle(packet);
                    break;

                case PacketProperty.Ack:
                case PacketProperty.Channeled:
                    if (packet.ChannelId > _channels.Length)
                    {
                        NetManager.PoolRecycle(packet);
                        break;
                    }
                    var channel = _channels[packet.ChannelId] ?? (packet.Property == PacketProperty.Ack ? null : CreateChannel(packet.ChannelId));
                    if (channel != null)
                    {
                        if (!channel.ProcessPacket(packet))
                            NetManager.PoolRecycle(packet);
                    }
                    break;

                //Simple packet without acks
                case PacketProperty.Unreliable:
                    NetManager.CreateReceiveEvent(packet, DeliveryMethod.Unreliable, 0, NetConstants.HeaderSize, this);
                    return;

                case PacketProperty.MtuCheck:
                case PacketProperty.MtuOk:
                    ProcessMtuPacket(packet);
                    break;

                default:
                    NetDebug.WriteError("Error! Unexpected packet type: " + packet.Property);
                    break;
            }
        }

        private void SendMerged()
        {
            if (_mergeCount == 0)
                return;
            int bytesSent;
            if (_mergeCount > 1)
            {
                NetDebug.Write("[P]Send merged: " + _mergePos + ", count: " + _mergeCount);
                bytesSent = NetManager.SendRaw(_mergeData.RawData, 0, NetConstants.HeaderSize + _mergePos, _remoteEndPoint);
            }
            else
            {
                //Send without length information and merging
                bytesSent = NetManager.SendRaw(_mergeData.RawData, NetConstants.HeaderSize + 2, _mergePos - 2, _remoteEndPoint);
            }

            if (NetManager.EnableStatistics)
            {
                Statistics.IncrementPacketsSent();
                Statistics.AddBytesSent(bytesSent);
            }

            _mergePos = 0;
            _mergeCount = 0;
        }

        internal void SendUserData(NetPacket packet)
        {
            packet.ConnectionNumber = _connectNum;
            int mergedPacketSize = NetConstants.HeaderSize + packet.Size + 2;
            const int sizeTreshold = 20;
            if (mergedPacketSize + sizeTreshold >= _mtu)
            {
                NetDebug.Write(NetLogLevel.Trace, "[P]SendingPacket: " + packet.Property);
                int bytesSent = NetManager.SendRaw(packet, _remoteEndPoint);

                if (NetManager.EnableStatistics)
                {
                    Statistics.IncrementPacketsSent();
                    Statistics.AddBytesSent(bytesSent);
                }

                return;
            }
            if (_mergePos + mergedPacketSize > _mtu)
                SendMerged();

            FastBitConverter.GetBytes(_mergeData.RawData, _mergePos + NetConstants.HeaderSize, (ushort)packet.Size);
            Buffer.BlockCopy(packet.RawData, 0, _mergeData.RawData, _mergePos + NetConstants.HeaderSize + 2, packet.Size);
            _mergePos += packet.Size + 2;
            _mergeCount++;
            //DebugWriteForce("Merged: " + _mergePos + "/" + (_mtu - 2) + ", count: " + _mergeCount);
        }

        internal void Update(int deltaTime)
        {
            Interlocked.Add(ref _timeSinceLastPacket, deltaTime);
            switch (_connectionState)
            {
                case ConnectionState.Connected:
                    if (_timeSinceLastPacket > NetManager.DisconnectTimeout)
                    {
                        NetDebug.Write(
                            "[UPDATE] Disconnect by timeout: {0} > {1}",
                            _timeSinceLastPacket,
                            NetManager.DisconnectTimeout);
                        NetManager.DisconnectPeerForce(this, DisconnectReason.Timeout, 0, null);
                        return;
                    }
                    break;

                case ConnectionState.ShutdownRequested:
                    if (_timeSinceLastPacket > NetManager.DisconnectTimeout)
                    {
                        _connectionState = ConnectionState.Disconnected;
                    }
                    else
                    {
                        _shutdownTimer += deltaTime;
                        if (_shutdownTimer >= ShutdownDelay)
                        {
                            _shutdownTimer = 0;
                            NetManager.SendRaw(_shutdownPacket, _remoteEndPoint);
                        }
                    }
                    return;

                case ConnectionState.Outgoing:
                    _connectTimer += deltaTime;
                    if (_connectTimer > NetManager.ReconnectDelay)
                    {
                        _connectTimer = 0;
                        _connectAttempts++;
                        if (_connectAttempts > NetManager.MaxConnectAttempts)
                        {
                            NetManager.DisconnectPeerForce(this, DisconnectReason.ConnectionFailed, 0, null);
                            return;
                        }

                        //else send connect again
                        NetManager.SendRaw(_connectRequestPacket, _remoteEndPoint);
                    }
                    return;

                case ConnectionState.Disconnected:
                    return;
            }

            //Send ping
            _pingSendTimer += deltaTime;
            if (_pingSendTimer >= NetManager.PingInterval)
            {
                NetDebug.Write("[PP] Send ping...");
                //reset timer
                _pingSendTimer = 0;
                //send ping
                _pingPacket.Sequence++;
                //ping timeout
                if (_pingTimer.IsRunning)
                    UpdateRoundTripTime((int)_pingTimer.ElapsedMilliseconds);
                _pingTimer.Restart();
                NetManager.SendRaw(_pingPacket, _remoteEndPoint);
            }

            //RTT - round trip time
            _rttResetTimer += deltaTime;
            if (_rttResetTimer >= NetManager.PingInterval * 3)
            {
                _rttResetTimer = 0;
                _rtt = _avgRtt;
                _rttCount = 1;
            }

            UpdateMtuLogic(deltaTime);

            //Pending send
            int count = _channelSendQueue.Count;
            while (count-- > 0)
            {
                if (!_channelSendQueue.TryDequeue(out var channel))
                    break;
                if (channel.SendAndCheckQueue())
                {
                    // still has something to send, re-add it to the send queue
                    _channelSendQueue.Enqueue(channel);
                }
            }

            lock (_unreliableChannel)
            {
                int unreliableCount = _unreliableChannel.Count;
                for (int i = 0; i < unreliableCount; i++)
                {
                    var packet = _unreliableChannel.Dequeue();
                    SendUserData(packet);
                    NetManager.PoolRecycle(packet);
                }
            }

            SendMerged();
        }

        //For reliable channel
        internal void RecycleAndDeliver(NetPacket packet)
        {
            if (packet.UserData != null)
            {
                if (packet.IsFragmented)
                {
                    _deliveredFragments.TryGetValue(packet.FragmentId, out ushort fragCount);
                    fragCount++;
                    if (fragCount == packet.FragmentsTotal)
                    {
                        NetManager.MessageDelivered(this, packet.UserData);
                        _deliveredFragments.Remove(packet.FragmentId);
                    }
                    else
                    {
                        _deliveredFragments[packet.FragmentId] = fragCount;
                    }
                }
                else
                {
                    NetManager.MessageDelivered(this, packet.UserData);
                }
                packet.UserData = null;
            }
            NetManager.PoolRecycle(packet);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetStatistics.cs ---
﻿using System.Threading;

namespace LiteNetLib
{
    public sealed class NetStatistics
    {
        private long _packetsSent;
        private long _packetsReceived;
        private long _bytesSent;
        private long _bytesReceived;
        private long _packetLoss;

        public long PacketsSent => Interlocked.Read(ref _packetsSent);
        public long PacketsReceived => Interlocked.Read(ref _packetsReceived);
        public long BytesSent => Interlocked.Read(ref _bytesSent);
        public long BytesReceived => Interlocked.Read(ref _bytesReceived);
        public long PacketLoss => Interlocked.Read(ref _packetLoss);

        public long PacketLossPercent
        {
            get
            {
                long sent = PacketsSent, loss = PacketLoss;

                return sent == 0 ? 0 : loss * 100 / sent;
            }
        }

        public void Reset()
        {
            Interlocked.Exchange(ref _packetsSent, 0);
            Interlocked.Exchange(ref _packetsReceived, 0);
            Interlocked.Exchange(ref _bytesSent, 0);
            Interlocked.Exchange(ref _bytesReceived, 0);
            Interlocked.Exchange(ref _packetLoss, 0);
        }

        public void IncrementPacketsSent()
        {
            Interlocked.Increment(ref _packetsSent);
        }

        public void IncrementPacketsReceived()
        {
            Interlocked.Increment(ref _packetsReceived);
        }

        public void AddBytesSent(long bytesSent)
        {
            Interlocked.Add(ref _bytesSent, bytesSent);
        }

        public void AddBytesReceived(long bytesReceived)
        {
            Interlocked.Add(ref _bytesReceived, bytesReceived);
        }

        public void IncrementPacketLoss()
        {
            Interlocked.Increment(ref _packetLoss);
        }

        public void AddPacketLoss(long packetLoss)
        {
            Interlocked.Add(ref _packetLoss, packetLoss);
        }

        public override string ToString()
        {
            return
                string.Format(
                    "BytesReceived: {0}\nPacketsReceived: {1}\nBytesSent: {2}\nPacketsSent: {3}\nPacketLoss: {4}\nPacketLossPercent: {5}\n",
                    BytesReceived,
                    PacketsReceived,
                    BytesSent,
                    PacketsSent,
                    PacketLoss,
                    PacketLossPercent);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/NetUtils.cs ---
﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Net.NetworkInformation;

namespace LiteNetLib
{
    /// <summary>
    /// Address type that you want to receive from NetUtils.GetLocalIp method
    /// </summary>
    [Flags]
    public enum LocalAddrType
    {
        IPv4 = 1,
        IPv6 = 2,
        All = IPv4 | IPv6
    }

    /// <summary>
    /// Some specific network utilities
    /// </summary>
    public static class NetUtils
    {
        public static IPEndPoint MakeEndPoint(string hostStr, int port)
        {
            return new IPEndPoint(ResolveAddress(hostStr), port);
        }

        public static IPAddress ResolveAddress(string hostStr)
        {
            if(hostStr == "localhost")
                return IPAddress.Loopback;

            if (!IPAddress.TryParse(hostStr, out var ipAddress))
            {
                if (NetManager.IPv6Support)
                    ipAddress = ResolveAddress(hostStr, AddressFamily.InterNetworkV6);
                if (ipAddress == null)
                    ipAddress = ResolveAddress(hostStr, AddressFamily.InterNetwork);
            }
            if (ipAddress == null)
                throw new ArgumentException("Invalid address: " + hostStr);

            return ipAddress;
        }

        public static IPAddress ResolveAddress(string hostStr, AddressFamily addressFamily)
        {
            IPAddress[] addresses = Dns.GetHostEntry(hostStr).AddressList;
            foreach (IPAddress ip in addresses)
            {
                if (ip.AddressFamily == addressFamily)
                {
                    return ip;
                }
            }
            return null;
        }

        /// <summary>
        /// Get all local ip addresses
        /// </summary>
        /// <param name="addrType">type of address (IPv4, IPv6 or both)</param>
        /// <returns>List with all local ip addresses</returns>
        public static List<string> GetLocalIpList(LocalAddrType addrType)
        {
            List<string> targetList = new List<string>();
            GetLocalIpList(targetList, addrType);
            return targetList;
        }

        /// <summary>
        /// Get all local ip addresses (non alloc version)
        /// </summary>
        /// <param name="targetList">result list</param>
        /// <param name="addrType">type of address (IPv4, IPv6 or both)</param>
        public static void GetLocalIpList(IList<string> targetList, LocalAddrType addrType)
        {
            bool ipv4 = (addrType & LocalAddrType.IPv4) == LocalAddrType.IPv4;
            bool ipv6 = (addrType & LocalAddrType.IPv6) == LocalAddrType.IPv6;
            try
            {
                foreach (NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    //Skip loopback and disabled network interfaces
                    if (ni.NetworkInterfaceType == NetworkInterfaceType.Loopback ||
                        ni.OperationalStatus != OperationalStatus.Up)
                        continue;

                    var ipProps = ni.GetIPProperties();

                    //Skip address without gateway
                    if (ipProps.GatewayAddresses.Count == 0)
                        continue;

                    foreach (UnicastIPAddressInformation ip in ipProps.UnicastAddresses)
                    {
                        var address = ip.Address;
                        if ((ipv4 && address.AddressFamily == AddressFamily.InterNetwork) ||
                            (ipv6 && address.AddressFamily == AddressFamily.InterNetworkV6))
                            targetList.Add(address.ToString());
                    }
                }

	            //Fallback mode (unity android)
	            if (targetList.Count == 0)
	            {
	                IPAddress[] addresses = Dns.GetHostEntry(Dns.GetHostName()).AddressList;
	                foreach (IPAddress ip in addresses)
	                {
	                    if((ipv4 && ip.AddressFamily == AddressFamily.InterNetwork) ||
	                       (ipv6 && ip.AddressFamily == AddressFamily.InterNetworkV6))
	                        targetList.Add(ip.ToString());
	                }
	            }
            }
            catch
            {
                //ignored
            }
            
            if (targetList.Count == 0)
            {
                if(ipv4)
                    targetList.Add("127.0.0.1");
                if(ipv6)
                    targetList.Add("::1");
            }
        }

        private static readonly List<string> IpList = new List<string>();
        /// <summary>
        /// Get first detected local ip address
        /// </summary>
        /// <param name="addrType">type of address (IPv4, IPv6 or both)</param>
        /// <returns>IP address if available. Else - string.Empty</returns>
        public static string GetLocalIp(LocalAddrType addrType)
        {
            lock (IpList)
            {
                IpList.Clear();
                GetLocalIpList(IpList, addrType);
                return IpList.Count == 0 ? string.Empty : IpList[0];
            }
        }

        // ===========================================
        // Internal and debug log related stuff
        // ===========================================
        internal static void PrintInterfaceInfos()
        {
            NetDebug.WriteForce(NetLogLevel.Info, "IPv6Support: {0}", NetManager.IPv6Support);
            try
            {
                foreach (NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    foreach (UnicastIPAddressInformation ip in ni.GetIPProperties().UnicastAddresses)
                    {
                        if (ip.Address.AddressFamily == AddressFamily.InterNetwork ||
                            ip.Address.AddressFamily == AddressFamily.InterNetworkV6)
                        {
                            NetDebug.WriteForce(
                                NetLogLevel.Info,
                                "Interface: {0}, Type: {1}, Ip: {2}, OpStatus: {3}",
                                ni.Name,
                                ni.NetworkInterfaceType.ToString(),
                                ip.Address.ToString(),
                                ni.OperationalStatus.ToString());
                        }
                    }
                }
            }
            catch (Exception e)
            {
                NetDebug.WriteForce(NetLogLevel.Info, "Error while getting interface infos: {0}", e.ToString());
            }
        }

        internal static int RelativeSequenceNumber(int number, int expected)
        {
            return (number - expected + NetConstants.MaxSequence + NetConstants.HalfMaxSequence) % NetConstants.MaxSequence - NetConstants.HalfMaxSequence;
        }

        internal static T[] AllocatePinnedUninitializedArray<T>(int count) where T : unmanaged
        {
#if NET5_0_OR_GREATER || NET5_0
            return GC.AllocateUninitializedArray<T>(count, true);
#else
            return new T[count];
#endif
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/PooledPacket.cs ---
﻿namespace LiteNetLib
{
    public readonly ref struct PooledPacket
    {
        internal readonly NetPacket _packet;
        internal readonly byte _channelNumber;

        /// <summary>
        /// Maximum data size that you can put into such packet
        /// </summary>
        public readonly int MaxUserDataSize;

        /// <summary>
        /// Offset for user data when writing to Data array
        /// </summary>
        public readonly int UserDataOffset;

        /// <summary>
        /// Raw packet data. Do not modify header! Use UserDataOffset as start point for your data
        /// </summary>
        public byte[] Data => _packet.RawData;

        internal PooledPacket(NetPacket packet, int maxDataSize, byte channelNumber)
        {
            _packet = packet;
            UserDataOffset = _packet.GetHeaderSize();
            _packet.Size = UserDataOffset;
            MaxUserDataSize = maxDataSize - UserDataOffset;
            _channelNumber = channelNumber;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/ReliableChannel.cs ---
﻿using System;

namespace LiteNetLib
{
    internal sealed class ReliableChannel : BaseChannel
    {
        private struct PendingPacket
        {
            private NetPacket _packet;
            private long _timeStamp;
            private bool _isSent;

            public override string ToString()
            {
                return _packet == null ? "Empty" : _packet.Sequence.ToString();
            }

            public void Init(NetPacket packet)
            {
                _packet = packet;
                _isSent = false;
            }

            //Returns true if there is a pending packet inside
            public bool TrySend(long currentTime, NetPeer peer)
            {
                if (_packet == null)
                    return false;

                if (_isSent) //check send time
                {
                    double resendDelay = peer.ResendDelay * TimeSpan.TicksPerMillisecond;
                    double packetHoldTime = currentTime - _timeStamp;
                    if (packetHoldTime < resendDelay)
                        return true;
                    NetDebug.Write("[RC]Resend: {0} > {1}", (int)packetHoldTime, resendDelay);
                }
                _timeStamp = currentTime;
                _isSent = true;
                peer.SendUserData(_packet);
                return true;
            }

            public bool Clear(NetPeer peer)
            {
                if (_packet != null)
                {
                    peer.RecycleAndDeliver(_packet);
                    _packet = null;
                    return true;
                }
                return false;
            }
        }

        private readonly NetPacket _outgoingAcks;            //for send acks
        private readonly PendingPacket[] _pendingPackets;    //for unacked packets and duplicates
        private readonly NetPacket[] _receivedPackets;       //for order
        private readonly bool[] _earlyReceived;              //for unordered

        private int _localSeqence;
        private int _remoteSequence;
        private int _localWindowStart;
        private int _remoteWindowStart;

        private bool _mustSendAcks;

        private readonly DeliveryMethod _deliveryMethod;
        private readonly bool _ordered;
        private readonly int _windowSize;
        private const int BitsInByte = 8;
        private readonly byte _id;

        public ReliableChannel(NetPeer peer, bool ordered, byte id) : base(peer)
        {
            _id = id;
            _windowSize = NetConstants.DefaultWindowSize;
            _ordered = ordered;
            _pendingPackets = new PendingPacket[_windowSize];
            for (int i = 0; i < _pendingPackets.Length; i++)
                _pendingPackets[i] = new PendingPacket();

            if (_ordered)
            {
                _deliveryMethod = DeliveryMethod.ReliableOrdered;
                _receivedPackets = new NetPacket[_windowSize];
            }
            else
            {
                _deliveryMethod = DeliveryMethod.ReliableUnordered;
                _earlyReceived = new bool[_windowSize];
            }

            _localWindowStart = 0;
            _localSeqence = 0;
            _remoteSequence = 0;
            _remoteWindowStart = 0;
            _outgoingAcks = new NetPacket(PacketProperty.Ack, (_windowSize - 1) / BitsInByte + 2) {ChannelId = id};
        }

        //ProcessAck in packet
        private void ProcessAck(NetPacket packet)
        {
            if (packet.Size != _outgoingAcks.Size)
            {
                NetDebug.Write("[PA]Invalid acks packet size");
                return;
            }

            ushort ackWindowStart = packet.Sequence;
            int windowRel = NetUtils.RelativeSequenceNumber(_localWindowStart, ackWindowStart);
            if (ackWindowStart >= NetConstants.MaxSequence || windowRel < 0)
            {
                NetDebug.Write("[PA]Bad window start");
                return;
            }

            //check relevance
            if (windowRel >= _windowSize)
            {
                NetDebug.Write("[PA]Old acks");
                return;
            }

            byte[] acksData = packet.RawData;
            lock (_pendingPackets)
            {
                for (int pendingSeq = _localWindowStart;
                    pendingSeq != _localSeqence;
                    pendingSeq = (pendingSeq + 1) % NetConstants.MaxSequence)
                {
                    int rel = NetUtils.RelativeSequenceNumber(pendingSeq, ackWindowStart);
                    if (rel >= _windowSize)
                    {
                        NetDebug.Write("[PA]REL: " + rel);
                        break;
                    }

                    int pendingIdx = pendingSeq % _windowSize;
                    int currentByte = NetConstants.ChanneledHeaderSize + pendingIdx / BitsInByte;
                    int currentBit = pendingIdx % BitsInByte;
                    if ((acksData[currentByte] & (1 << currentBit)) == 0)
                    {
                        if (Peer.NetManager.EnableStatistics)
                        {
                            Peer.Statistics.IncrementPacketLoss();
                            Peer.NetManager.Statistics.IncrementPacketLoss();
                        }

                        //Skip false ack
                        NetDebug.Write("[PA]False ack: {0}", pendingSeq);
                        continue;
                    }

                    if (pendingSeq == _localWindowStart)
                    {
                        //Move window
                        _localWindowStart = (_localWindowStart + 1) % NetConstants.MaxSequence;
                    }

                    //clear packet
                    if (_pendingPackets[pendingIdx].Clear(Peer))
                        NetDebug.Write("[PA]Removing reliableInOrder ack: {0} - true", pendingSeq);
                }
            }
        }

        protected override bool SendNextPackets()
        {
            if (_mustSendAcks)
            {
                _mustSendAcks = false;
                NetDebug.Write("[RR]SendAcks");
                lock(_outgoingAcks)
                    Peer.SendUserData(_outgoingAcks);
            }

            long currentTime = DateTime.UtcNow.Ticks;
            bool hasPendingPackets = false;

            lock (_pendingPackets)
            {
                //get packets from queue
                while (!OutgoingQueue.IsEmpty)
                {
                    int relate = NetUtils.RelativeSequenceNumber(_localSeqence, _localWindowStart);
                    if (relate >= _windowSize)
                        break;

                    if (!OutgoingQueue.TryDequeue(out var netPacket))
                        break;

                    netPacket.Sequence = (ushort) _localSeqence;
                    netPacket.ChannelId = _id;
                    _pendingPackets[_localSeqence % _windowSize].Init(netPacket);
                    _localSeqence = (_localSeqence + 1) % NetConstants.MaxSequence;
                }

                //send
                for (int pendingSeq = _localWindowStart; pendingSeq != _localSeqence; pendingSeq = (pendingSeq + 1) % NetConstants.MaxSequence)
                {
                    // Please note: TrySend is invoked on a mutable struct, it's important to not extract it into a variable here
                    if (_pendingPackets[pendingSeq % _windowSize].TrySend(currentTime, Peer))
                        hasPendingPackets = true;
                }
            }

            return hasPendingPackets || _mustSendAcks || !OutgoingQueue.IsEmpty;
        }

        //Process incoming packet
        public override bool ProcessPacket(NetPacket packet)
        {
            if (packet.Property == PacketProperty.Ack)
            {
                ProcessAck(packet);
                return false;
            }
            int seq = packet.Sequence;
            if (seq >= NetConstants.MaxSequence)
            {
                NetDebug.Write("[RR]Bad sequence");
                return false;
            }

            int relate = NetUtils.RelativeSequenceNumber(seq, _remoteWindowStart);
            int relateSeq = NetUtils.RelativeSequenceNumber(seq, _remoteSequence);

            if (relateSeq > _windowSize)
            {
                NetDebug.Write("[RR]Bad sequence");
                return false;
            }

            //Drop bad packets
            if (relate < 0)
            {
                //Too old packet doesn't ack
                NetDebug.Write("[RR]ReliableInOrder too old");
                return false;
            }
            if (relate >= _windowSize * 2)
            {
                //Some very new packet
                NetDebug.Write("[RR]ReliableInOrder too new");
                return false;
            }

            //If very new - move window
            int ackIdx;
            int ackByte;
            int ackBit;
            lock (_outgoingAcks)
            {
                if (relate >= _windowSize)
                {
                    //New window position
                    int newWindowStart = (_remoteWindowStart + relate - _windowSize + 1) % NetConstants.MaxSequence;
                    _outgoingAcks.Sequence = (ushort) newWindowStart;

                    //Clean old data
                    while (_remoteWindowStart != newWindowStart)
                    {
                        ackIdx = _remoteWindowStart % _windowSize;
                        ackByte = NetConstants.ChanneledHeaderSize + ackIdx / BitsInByte;
                        ackBit = ackIdx % BitsInByte;
                        _outgoingAcks.RawData[ackByte] &= (byte) ~(1 << ackBit);
                        _remoteWindowStart = (_remoteWindowStart + 1) % NetConstants.MaxSequence;
                    }
                }

                //Final stage - process valid packet
                //trigger acks send
                _mustSendAcks = true;

                ackIdx = seq % _windowSize;
                ackByte = NetConstants.ChanneledHeaderSize + ackIdx / BitsInByte;
                ackBit = ackIdx % BitsInByte;
                if ((_outgoingAcks.RawData[ackByte] & (1 << ackBit)) != 0)
                {
                    NetDebug.Write("[RR]ReliableInOrder duplicate");
                    //because _mustSendAcks == true
                    AddToPeerChannelSendQueue();
                    return false;
                }

                //save ack
                _outgoingAcks.RawData[ackByte] |= (byte) (1 << ackBit);
            }

            AddToPeerChannelSendQueue();

            //detailed check
            if (seq == _remoteSequence)
            {
                NetDebug.Write("[RR]ReliableInOrder packet succes");
                Peer.AddReliablePacket(_deliveryMethod, packet);
                _remoteSequence = (_remoteSequence + 1) % NetConstants.MaxSequence;

                if (_ordered)
                {
                    NetPacket p;
                    while ((p = _receivedPackets[_remoteSequence % _windowSize]) != null)
                    {
                        //process holden packet
                        _receivedPackets[_remoteSequence % _windowSize] = null;
                        Peer.AddReliablePacket(_deliveryMethod, p);
                        _remoteSequence = (_remoteSequence + 1) % NetConstants.MaxSequence;
                    }
                }
                else
                {
                    while (_earlyReceived[_remoteSequence % _windowSize])
                    {
                        //process early packet
                        _earlyReceived[_remoteSequence % _windowSize] = false;
                        _remoteSequence = (_remoteSequence + 1) % NetConstants.MaxSequence;
                    }
                }
                return true;
            }

            //holden packet
            if (_ordered)
            {
                _receivedPackets[ackIdx] = packet;
            }
            else
            {
                _earlyReceived[ackIdx] = true;
                Peer.AddReliablePacket(_deliveryMethod, packet);
            }
            return true;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/SequencedChannel.cs ---
﻿using System;

namespace LiteNetLib
{
    internal sealed class SequencedChannel : BaseChannel
    {
        private int _localSequence;
        private ushort _remoteSequence;
        private readonly bool _reliable;
        private NetPacket _lastPacket;
        private readonly NetPacket _ackPacket;
        private bool _mustSendAck;
        private readonly byte _id;
        private long _lastPacketSendTime;

        public SequencedChannel(NetPeer peer, bool reliable, byte id) : base(peer)
        {
            _id = id;
            _reliable = reliable;
            if (_reliable)
                _ackPacket = new NetPacket(PacketProperty.Ack, 0) {ChannelId = id};
        }

        protected override bool SendNextPackets()
        {
            if (_reliable && OutgoingQueue.Count == 0)
            {
                long currentTime = DateTime.UtcNow.Ticks;
                long packetHoldTime = currentTime - _lastPacketSendTime;
                if (packetHoldTime >= Peer.ResendDelay * TimeSpan.TicksPerMillisecond)
                {
                    var packet = _lastPacket;
                    if (packet != null)
                    {
                        _lastPacketSendTime = currentTime;
                        Peer.SendUserData(packet);
                    }
                }
            }
            else
            {
                while (OutgoingQueue.TryDequeue(out var packet))
                {
                    _localSequence = (_localSequence + 1) % NetConstants.MaxSequence;
                    packet.Sequence = (ushort)_localSequence;
                    packet.ChannelId = _id;
                    Peer.SendUserData(packet);

                    if (_reliable && OutgoingQueue.Count == 0)
                    {
                        _lastPacketSendTime = DateTime.UtcNow.Ticks;
                        _lastPacket = packet;
                    }
                    else
                    {
                        Peer.NetManager.PoolRecycle(packet);
                    }
                }
            }

            if (_reliable && _mustSendAck)
            {
                _mustSendAck = false;
                _ackPacket.Sequence = _remoteSequence;
                Peer.SendUserData(_ackPacket);
            }

            return _lastPacket != null;
        }

        public override bool ProcessPacket(NetPacket packet)
        {
            if (packet.IsFragmented)
                return false;
            if (packet.Property == PacketProperty.Ack)
            {
                if (_reliable && _lastPacket != null && packet.Sequence == _lastPacket.Sequence)
                    _lastPacket = null;
                return false;
            }
            int relative = NetUtils.RelativeSequenceNumber(packet.Sequence, _remoteSequence);
            bool packetProcessed = false;
            if (packet.Sequence < NetConstants.MaxSequence && relative > 0)
            {
                if (Peer.NetManager.EnableStatistics)
                {
                    Peer.Statistics.AddPacketLoss(relative - 1);
                    Peer.NetManager.Statistics.AddPacketLoss(relative - 1);
                }

                _remoteSequence = packet.Sequence;
                Peer.NetManager.CreateReceiveEvent(
                    packet,
                    _reliable ? DeliveryMethod.ReliableSequenced : DeliveryMethod.Sequenced,
                    (byte)(packet.ChannelId / NetConstants.ChannelTypeCount),
                    NetConstants.ChanneledHeaderSize,
                    Peer);
                packetProcessed = true;
            }

            if (_reliable)
            {
                _mustSendAck = true;
                AddToPeerChannelSendQueue();
            }

            return packetProcessed;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/CRC32C.cs ---
﻿#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP3_1 || NET5_0
using System;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics.X86;
#endif
#if NET5_0_OR_GREATER || NET5_0
using System.Runtime.Intrinsics.Arm;
#endif

namespace LiteNetLib.Utils
{
    //Implementation from Crc32.NET
    public static class CRC32C
    {
        public const int ChecksumSize = 4;
        private const uint Poly = 0x82F63B78u;
        private static readonly uint[] Table;

        static CRC32C()
        {
#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP3_1 || NET5_0
            if (Sse42.IsSupported)
                return;
#endif
#if NET5_0_OR_GREATER || NET5_0
            if (Crc32.IsSupported)
                return;
#endif
            Table = NetUtils.AllocatePinnedUninitializedArray<uint>(16 * 256);
            for (uint i = 0; i < 256; i++)
            {
                uint res = i;
                for (int t = 0; t < 16; t++)
                {
                    for (int k = 0; k < 8; k++)
                        res = (res & 1) == 1 ? Poly ^ (res >> 1) : (res >> 1);
                    Table[t * 256 + i] = res;
                }
            }
        }

        /// <summary>
        /// Compute CRC32C for data
        /// </summary>
        /// <param name="input">input data</param>
        /// <param name="offset">offset</param>
        /// <param name="length">length</param>
        /// <returns>CRC32C checksum</returns>
        public static uint Compute(byte[] input, int offset, int length)
        {
            uint crcLocal = uint.MaxValue;
#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP3_1 || NET5_0
            if (Sse42.IsSupported)
            {
                var data = new ReadOnlySpan<byte>(input, offset, length);
                int processed = 0;
                if (Sse42.X64.IsSupported && data.Length > sizeof(ulong))
                {
                    processed = data.Length / sizeof(ulong) * sizeof(ulong);
                    var ulongs = MemoryMarshal.Cast<byte, ulong>(data.Slice(0, processed));
                    ulong crclong = crcLocal;
                    for (int i = 0; i < ulongs.Length; i++)
                    {
                        crclong = Sse42.X64.Crc32(crclong, ulongs[i]);
                    }

                    crcLocal = (uint)crclong;
                }
                else if (data.Length > sizeof(uint))
                {
                    processed = data.Length / sizeof(uint) * sizeof(uint);
                    var uints = MemoryMarshal.Cast<byte, uint>(data.Slice(0, processed));
                    for (int i = 0; i < uints.Length; i++)
                    {
                        crcLocal = Sse42.Crc32(crcLocal, uints[i]);
                    }
                }

                for (int i = processed; i < data.Length; i++)
                {
                    crcLocal = Sse42.Crc32(crcLocal, data[i]);
                }

                return crcLocal ^ uint.MaxValue;
            }
#endif
#if NET5_0_OR_GREATER || NET5_0
            if (Crc32.IsSupported)
            {
                var data = new ReadOnlySpan<byte>(input, offset, length);
                int processed = 0;
                if (Crc32.Arm64.IsSupported && data.Length > sizeof(ulong))
                {
                    processed = data.Length / sizeof(ulong) * sizeof(ulong);
                    var ulongs = MemoryMarshal.Cast<byte, ulong>(data.Slice(0, processed));
                    for (int i = 0; i < ulongs.Length; i++)
                    {
                        crcLocal = Crc32.Arm64.ComputeCrc32C(crcLocal, ulongs[i]);
                    }
                }
                else if (data.Length > sizeof(uint))
                {
                    processed = data.Length / sizeof(uint) * sizeof(uint);
                    var uints = MemoryMarshal.Cast<byte, uint>(data.Slice(0, processed));
                    for (int i = 0; i < uints.Length; i++)
                    {
                        crcLocal = Crc32.ComputeCrc32C(crcLocal, uints[i]);
                    }
                }

                for (int i = processed; i < data.Length; i++)
                {
                    crcLocal = Crc32.ComputeCrc32C(crcLocal, data[i]);
                }

                return crcLocal ^ uint.MaxValue;
            }
#endif
            while (length >= 16)
            {
                var a = Table[(3 * 256) + input[offset + 12]]
                        ^ Table[(2 * 256) + input[offset + 13]]
                        ^ Table[(1 * 256) + input[offset + 14]]
                        ^ Table[(0 * 256) + input[offset + 15]];

                var b = Table[(7 * 256) + input[offset + 8]]
                        ^ Table[(6 * 256) + input[offset + 9]]
                        ^ Table[(5 * 256) + input[offset + 10]]
                        ^ Table[(4 * 256) + input[offset + 11]];

                var c = Table[(11 * 256) + input[offset + 4]]
                        ^ Table[(10 * 256) + input[offset + 5]]
                        ^ Table[(9 * 256) + input[offset + 6]]
                        ^ Table[(8 * 256) + input[offset + 7]];

                var d = Table[(15 * 256) + ((byte)crcLocal ^ input[offset])]
                        ^ Table[(14 * 256) + ((byte)(crcLocal >> 8) ^ input[offset + 1])]
                        ^ Table[(13 * 256) + ((byte)(crcLocal >> 16) ^ input[offset + 2])]
                        ^ Table[(12 * 256) + ((crcLocal >> 24) ^ input[offset + 3])];

                crcLocal = d ^ c ^ b ^ a;
                offset += 16;
                length -= 16;
            }
            while (--length >= 0)
                crcLocal = Table[(byte)(crcLocal ^ input[offset++])] ^ crcLocal >> 8;
            return crcLocal ^ uint.MaxValue;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/FastBitConverter.cs ---
﻿using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace LiteNetLib.Utils
{
    public static class FastBitConverter
    {
#if (LITENETLIB_UNSAFE || LITENETLIB_UNSAFELIB || NETCOREAPP3_1 || NET5_0 || NETCOREAPP3_0_OR_GREATER) && !BIGENDIAN
#if LITENETLIB_UNSAFE
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static unsafe void GetBytes<T>(byte[] bytes, int startIndex, T value) where T : unmanaged
        {
            int size = sizeof(T);
            if (bytes.Length < startIndex + size)
                ThrowIndexOutOfRangeException();
#if LITENETLIB_UNSAFELIB || NETCOREAPP3_1 || NET5_0 || NETCOREAPP3_0_OR_GREATER
            Unsafe.As<byte, T>(ref bytes[startIndex]) = value;
#else
            fixed (byte* ptr = &bytes[startIndex])
            {
#if UNITY_ANDROID
                // On some android systems, assigning *(T*)ptr throws a NRE if
                // the ptr isn't aligned (i.e. if Position is 1,2,3,5, etc.).
                // Here we have to use memcpy.
                //
                // => we can't get a pointer of a struct in C# without
                //    marshalling allocations
                // => instead, we stack allocate an array of type T and use that
                // => stackalloc avoids GC and is very fast. it only works for
                //    value types, but all blittable types are anyway.
                T* valueBuffer = stackalloc T[1] { value };
                UnsafeUtility.MemCpy(ptr, valueBuffer, size);
#else
                *(T*)ptr = value;
#endif
            }
#endif
        }
#else
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes<T>(byte[] bytes, int startIndex, T value) where T : unmanaged
        {
            if (bytes.Length < startIndex + Unsafe.SizeOf<T>())
                ThrowIndexOutOfRangeException();
            Unsafe.As<byte, T>(ref bytes[startIndex]) = value;
        }
#endif

        private static void ThrowIndexOutOfRangeException() => throw new IndexOutOfRangeException();
#else
        [StructLayout(LayoutKind.Explicit)]
        private struct ConverterHelperDouble
        {
            [FieldOffset(0)]
            public ulong Along;

            [FieldOffset(0)]
            public double Adouble;
        }

        [StructLayout(LayoutKind.Explicit)]
        private struct ConverterHelperFloat
        {
            [FieldOffset(0)]
            public int Aint;

            [FieldOffset(0)]
            public float Afloat;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void WriteLittleEndian(byte[] buffer, int offset, ulong data)
        {
#if BIGENDIAN
            buffer[offset + 7] = (byte)(data);
            buffer[offset + 6] = (byte)(data >> 8);
            buffer[offset + 5] = (byte)(data >> 16);
            buffer[offset + 4] = (byte)(data >> 24);
            buffer[offset + 3] = (byte)(data >> 32);
            buffer[offset + 2] = (byte)(data >> 40);
            buffer[offset + 1] = (byte)(data >> 48);
            buffer[offset    ] = (byte)(data >> 56);
#else
            buffer[offset] = (byte)(data);
            buffer[offset + 1] = (byte)(data >> 8);
            buffer[offset + 2] = (byte)(data >> 16);
            buffer[offset + 3] = (byte)(data >> 24);
            buffer[offset + 4] = (byte)(data >> 32);
            buffer[offset + 5] = (byte)(data >> 40);
            buffer[offset + 6] = (byte)(data >> 48);
            buffer[offset + 7] = (byte)(data >> 56);
#endif
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void WriteLittleEndian(byte[] buffer, int offset, int data)
        {
#if BIGENDIAN
            buffer[offset + 3] = (byte)(data);
            buffer[offset + 2] = (byte)(data >> 8);
            buffer[offset + 1] = (byte)(data >> 16);
            buffer[offset    ] = (byte)(data >> 24);
#else
            buffer[offset] = (byte)(data);
            buffer[offset + 1] = (byte)(data >> 8);
            buffer[offset + 2] = (byte)(data >> 16);
            buffer[offset + 3] = (byte)(data >> 24);
#endif
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void WriteLittleEndian(byte[] buffer, int offset, short data)
        {
#if BIGENDIAN
            buffer[offset + 1] = (byte)(data);
            buffer[offset    ] = (byte)(data >> 8);
#else
            buffer[offset] = (byte)(data);
            buffer[offset + 1] = (byte)(data >> 8);
#endif
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes(byte[] bytes, int startIndex, double value)
        {
            ConverterHelperDouble ch = new ConverterHelperDouble { Adouble = value };
            WriteLittleEndian(bytes, startIndex, ch.Along);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes(byte[] bytes, int startIndex, float value)
        {
            ConverterHelperFloat ch = new ConverterHelperFloat { Afloat = value };
            WriteLittleEndian(bytes, startIndex, ch.Aint);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes(byte[] bytes, int startIndex, short value)
        {
            WriteLittleEndian(bytes, startIndex, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes(byte[] bytes, int startIndex, ushort value)
        {
            WriteLittleEndian(bytes, startIndex, (short)value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes(byte[] bytes, int startIndex, int value)
        {
            WriteLittleEndian(bytes, startIndex, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes(byte[] bytes, int startIndex, uint value)
        {
            WriteLittleEndian(bytes, startIndex, (int)value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes(byte[] bytes, int startIndex, long value)
        {
            WriteLittleEndian(bytes, startIndex, (ulong)value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void GetBytes(byte[] bytes, int startIndex, ulong value)
        {
            WriteLittleEndian(bytes, startIndex, value);
        }
#endif
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/INetSerializable.cs ---
﻿namespace LiteNetLib.Utils
{
    public interface INetSerializable
    {
        void Serialize(NetDataWriter writer);
        void Deserialize(NetDataReader reader);
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/NetDataReader.cs ---
﻿using System;
using System.Net;
using System.Text;

namespace LiteNetLib.Utils
{
    public class NetDataReader
    {
        protected byte[] _data;
        protected int _position;
        protected int _dataSize;
        private int _offset;

        public byte[] RawData => _data;
        public int RawDataSize => _dataSize;
        public int UserDataOffset => _offset;
        public int UserDataSize => _dataSize - _offset;
        public bool IsNull => _data == null;
        public int Position => _position;
        public bool EndOfData => _position == _dataSize;
        public int AvailableBytes => _dataSize - _position;

        // Cache encoding instead of creating it with BinaryWriter each time
        // 1000 readers before: 1MB GC, 30ms
        // 1000 readers after: .8MB GC, 18ms
        private static readonly UTF8Encoding _uTF8Encoding = new UTF8Encoding(false, true);

        public void SkipBytes(int count)
        {
            _position += count;
        }

        public void SetPosition(int position)
        {
            _position = position;
        }

        public void SetSource(NetDataWriter dataWriter)
        {
            _data = dataWriter.Data;
            _position = 0;
            _offset = 0;
            _dataSize = dataWriter.Length;
        }

        public void SetSource(byte[] source)
        {
            _data = source;
            _position = 0;
            _offset = 0;
            _dataSize = source.Length;
        }

        public void SetSource(byte[] source, int offset, int maxSize)
        {
            _data = source;
            _position = offset;
            _offset = offset;
            _dataSize = maxSize;
        }

        public NetDataReader()
        {

        }

        public NetDataReader(NetDataWriter writer)
        {
            SetSource(writer);
        }

        public NetDataReader(byte[] source)
        {
            SetSource(source);
        }

        public NetDataReader(byte[] source, int offset, int maxSize)
        {
            SetSource(source, offset, maxSize);
        }

        #region GetMethods
        public IPEndPoint GetNetEndPoint()
        {
            string host = GetString(1000);
            int port = GetInt();
            return NetUtils.MakeEndPoint(host, port);
        }

        public byte GetByte()
        {
            byte res = _data[_position];
            _position += 1;
            return res;
        }

        public sbyte GetSByte()
        {
            var b = (sbyte)_data[_position];
            _position++;
            return b;
        }

        public bool[] GetBoolArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new bool[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size);
            _position += size;
            return arr;
        }

        public ushort[] GetUShortArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new ushort[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size * 2);
            _position += size * 2;
            return arr;
        }

        public short[] GetShortArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new short[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size * 2);
            _position += size * 2;
            return arr;
        }

        public long[] GetLongArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new long[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size * 8);
            _position += size * 8;
            return arr;
        }

        public ulong[] GetULongArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new ulong[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size * 8);
            _position += size * 8;
            return arr;
        }

        public int[] GetIntArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new int[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size * 4);
            _position += size * 4;
            return arr;
        }

        public uint[] GetUIntArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new uint[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size * 4);
            _position += size * 4;
            return arr;
        }

        public float[] GetFloatArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new float[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size * 4);
            _position += size * 4;
            return arr;
        }

        public double[] GetDoubleArray()
        {
            ushort size = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            var arr = new double[size];
            Buffer.BlockCopy(_data, _position, arr, 0, size * 8);
            _position += size * 8;
            return arr;
        }

        public string[] GetStringArray()
        {
            ushort arraySize = GetUShort();
            var arr = new string[arraySize];
            for (int i = 0; i < arraySize; i++)
            {
                arr[i] = GetString();
            }
            return arr;
        }

        public string[] GetStringArray(int maxStringLength)
        {
            ushort arraySize = GetUShort();
            var arr = new string[arraySize];
            for (int i = 0; i < arraySize; i++)
            {
                arr[i] = GetString(maxStringLength);
            }
            return arr;
        }

        public bool GetBool()
        {
            bool res = _data[_position] > 0;
            _position += 1;
            return res;
        }

        public char GetChar()
        {
            return (char)GetUShort();
        }

        public ushort GetUShort()
        {
            ushort result = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            return result;
        }

        public short GetShort()
        {
            short result = BitConverter.ToInt16(_data, _position);
            _position += 2;
            return result;
        }

        public long GetLong()
        {
            long result = BitConverter.ToInt64(_data, _position);
            _position += 8;
            return result;
        }

        public ulong GetULong()
        {
            ulong result = BitConverter.ToUInt64(_data, _position);
            _position += 8;
            return result;
        }

        public int GetInt()
        {
            int result = BitConverter.ToInt32(_data, _position);
            _position += 4;
            return result;
        }

        public uint GetUInt()
        {
            uint result = BitConverter.ToUInt32(_data, _position);
            _position += 4;
            return result;
        }

        public float GetFloat()
        {
            float result = BitConverter.ToSingle(_data, _position);
            _position += 4;
            return result;
        }

        public double GetDouble()
        {
            double result = BitConverter.ToDouble(_data, _position);
            _position += 8;
            return result;
        }

        /// <summary>
        /// Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
        /// </summary>
        /// <returns>"string.Empty" if value > "maxLength"</returns>
        public string GetString(int maxLength)
        {
            ushort size = GetUShort();
            if (size == 0)
            {
                return null;
            }

            int actualSize = size - 1;
            if (actualSize >= NetDataWriter.StringBufferMaxLength)
            {
                return null;
            }

            ArraySegment<byte> data = GetBytesSegment(actualSize);

            return (maxLength > 0 && _uTF8Encoding.GetCharCount(data.Array, data.Offset, data.Count) > maxLength) ?
                string.Empty :
                _uTF8Encoding.GetString(data.Array, data.Offset, data.Count);
        }

        public string GetString()
        {
            ushort size = GetUShort();
            if (size == 0)
            {
                return null;
            }

            int actualSize = size - 1;
            if (actualSize >= NetDataWriter.StringBufferMaxLength)
            {
                return null;
            }

            ArraySegment<byte> data = GetBytesSegment(actualSize);

            return _uTF8Encoding.GetString(data.Array, data.Offset, data.Count);
        }

        public ArraySegment<byte> GetBytesSegment(int count)
        {
            ArraySegment<byte> segment = new ArraySegment<byte>(_data, _position, count);
            _position += count;
            return segment;
        }

        public ArraySegment<byte> GetRemainingBytesSegment()
        {
            ArraySegment<byte> segment = new ArraySegment<byte>(_data, _position, AvailableBytes);
            _position = _data.Length;
            return segment;
        }

        public T Get<T>() where T : INetSerializable, new()
        {
            var obj = new T();
            obj.Deserialize(this);
            return obj;
        }

        public byte[] GetRemainingBytes()
        {
            byte[] outgoingData = new byte[AvailableBytes];
            Buffer.BlockCopy(_data, _position, outgoingData, 0, AvailableBytes);
            _position = _data.Length;
            return outgoingData;
        }

        public void GetBytes(byte[] destination, int start, int count)
        {
            Buffer.BlockCopy(_data, _position, destination, start, count);
            _position += count;
        }

        public void GetBytes(byte[] destination, int count)
        {
            Buffer.BlockCopy(_data, _position, destination, 0, count);
            _position += count;
        }

        public sbyte[] GetSBytesWithLength()
        {
            int length = GetInt();
            sbyte[] outgoingData = new sbyte[length];
            Buffer.BlockCopy(_data, _position, outgoingData, 0, length);
            _position += length;
            return outgoingData;
        }

        public byte[] GetBytesWithLength()
        {
            int length = GetInt();
            byte[] outgoingData = new byte[length];
            Buffer.BlockCopy(_data, _position, outgoingData, 0, length);
            _position += length;
            return outgoingData;
        }
        #endregion

        #region PeekMethods

        public byte PeekByte()
        {
            return _data[_position];
        }

        public sbyte PeekSByte()
        {
            return (sbyte)_data[_position];
        }

        public bool PeekBool()
        {
            return _data[_position] > 0;
        }

        public char PeekChar()
        {
            return (char)PeekUShort();
        }

        public ushort PeekUShort()
        {
            return BitConverter.ToUInt16(_data, _position);
        }

        public short PeekShort()
        {
            return BitConverter.ToInt16(_data, _position);
        }

        public long PeekLong()
        {
            return BitConverter.ToInt64(_data, _position);
        }

        public ulong PeekULong()
        {
            return BitConverter.ToUInt64(_data, _position);
        }

        public int PeekInt()
        {
            return BitConverter.ToInt32(_data, _position);
        }

        public uint PeekUInt()
        {
            return BitConverter.ToUInt32(_data, _position);
        }

        public float PeekFloat()
        {
            return BitConverter.ToSingle(_data, _position);
        }

        public double PeekDouble()
        {
            return BitConverter.ToDouble(_data, _position);
        }

        public string PeekString(int maxLength)
        {
            ushort size = PeekUShort();
            if (size == 0)
            {
                return null;
            }

            int actualSize = size - 1;
            if (actualSize >= NetDataWriter.StringBufferMaxLength)
            {
                return null;
            }

            return (maxLength > 0 && _uTF8Encoding.GetCharCount(_data, _position + 2, actualSize) > maxLength) ?
                string.Empty :
                _uTF8Encoding.GetString(_data, _position + 2, actualSize);
        }

        public string PeekString()
        {
            ushort size = PeekUShort();
            if (size == 0)
            {
                return null;
            }

            int actualSize = size - 1;
            if (actualSize >= NetDataWriter.StringBufferMaxLength)
            {
                return null;
            }

            return _uTF8Encoding.GetString(_data, _position + 2, actualSize);
        }
        #endregion

        #region TryGetMethods
        public bool TryGetByte(out byte result)
        {
            if (AvailableBytes >= 1)
            {
                result = GetByte();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetSByte(out sbyte result)
        {
            if (AvailableBytes >= 1)
            {
                result = GetSByte();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetBool(out bool result)
        {
            if (AvailableBytes >= 1)
            {
                result = GetBool();
                return true;
            }
            result = false;
            return false;
        }

        public bool TryGetChar(out char result)
        {
            if (!TryGetUShort(out ushort uShortValue))
            {
                result = '\0';
                return false;
            }
            result = (char)uShortValue;
            return true;
        }

        public bool TryGetShort(out short result)
        {
            if (AvailableBytes >= 2)
            {
                result = GetShort();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetUShort(out ushort result)
        {
            if (AvailableBytes >= 2)
            {
                result = GetUShort();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetInt(out int result)
        {
            if (AvailableBytes >= 4)
            {
                result = GetInt();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetUInt(out uint result)
        {
            if (AvailableBytes >= 4)
            {
                result = GetUInt();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetLong(out long result)
        {
            if (AvailableBytes >= 8)
            {
                result = GetLong();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetULong(out ulong result)
        {
            if (AvailableBytes >= 8)
            {
                result = GetULong();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetFloat(out float result)
        {
            if (AvailableBytes >= 4)
            {
                result = GetFloat();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetDouble(out double result)
        {
            if (AvailableBytes >= 8)
            {
                result = GetDouble();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetString(out string result)
        {
            if (AvailableBytes >= 2)
            {
                ushort strSize = PeekUShort();
                if (AvailableBytes >= strSize + 1)
                {
                    result = GetString();
                    return true;
                }
            }
            result = null;
            return false;
        }

        public bool TryGetStringArray(out string[] result)
        {
            ushort strArrayLength;
            if (!TryGetUShort(out strArrayLength))
            {
                result = null;
                return false;
            }

            result = new string[strArrayLength];
            for (int i = 0; i < strArrayLength; i++)
            {
                if (!TryGetString(out result[i]))
                {
                    result = null;
                    return false;
                }
            }

            return true;
        }

        public bool TryGetBytesWithLength(out byte[] result)
        {
            if (AvailableBytes >= 4)
            {
                var length = PeekInt();
                if (length >= 0 && AvailableBytes >= length + 4)
                {
                    result = GetBytesWithLength();
                    return true;
                }
            }
            result = null;
            return false;
        }
        #endregion

        public void Clear()
        {
            _position = 0;
            _dataSize = 0;
            _data = null;
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/NetDataWriter.cs ---
﻿using System;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text;

namespace LiteNetLib.Utils
{
    public class NetDataWriter
    {
        protected byte[] _data;
        protected int _position;
        private const int InitialSize = 64;
        private readonly bool _autoResize;

        public int Capacity => _data.Length;
        public byte[] Data => _data;
        public int Length => _position;

        // Cache encoding instead of creating it with BinaryWriter each time
        // 1000 readers before: 1MB GC, 30ms
        // 1000 readers after: .8MB GC, 18ms
        private static readonly UTF8Encoding _uTF8Encoding = new UTF8Encoding(false, true);
        public const int StringBufferMaxLength = 1024 * 32; // <- short.MaxValue + 1
        private readonly byte[] _stringBuffer = new byte[StringBufferMaxLength];

        public NetDataWriter() : this(true, InitialSize)
        {
        }

        public NetDataWriter(bool autoResize) : this(autoResize, InitialSize)
        {
        }

        public NetDataWriter(bool autoResize, int initialSize)
        {
            _data = new byte[initialSize];
            _autoResize = autoResize;
        }

        /// <summary>
        /// Creates NetDataWriter from existing ByteArray
        /// </summary>
        /// <param name="bytes">Source byte array</param>
        /// <param name="copy">Copy array to new location or use existing</param>
        public static NetDataWriter FromBytes(byte[] bytes, bool copy)
        {
            if (copy)
            {
                var netDataWriter = new NetDataWriter(true, bytes.Length);
                netDataWriter.Put(bytes);
                return netDataWriter;
            }
            return new NetDataWriter(true, 0) {_data = bytes, _position = bytes.Length};
        }

        /// <summary>
        /// Creates NetDataWriter from existing ByteArray (always copied data)
        /// </summary>
        /// <param name="bytes">Source byte array</param>
        /// <param name="offset">Offset of array</param>
        /// <param name="length">Length of array</param>
        public static NetDataWriter FromBytes(byte[] bytes, int offset, int length)
        {
            var netDataWriter = new NetDataWriter(true, bytes.Length);
            netDataWriter.Put(bytes, offset, length);
            return netDataWriter;
        }

        public static NetDataWriter FromString(string value)
        {
            var netDataWriter = new NetDataWriter();
            netDataWriter.Put(value);
            return netDataWriter;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResizeIfNeed(int newSize)
        {
            if (_data.Length < newSize)
            {
                Array.Resize(ref _data, Math.Max(newSize, _data.Length * 2));
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnsureFit(int additionalSize)
        {
            if (_data.Length < _position + additionalSize)
            {
                Array.Resize(ref _data, Math.Max(_position + additionalSize, _data.Length * 2));
            }
        }

        public void Reset(int size)
        {
            ResizeIfNeed(size);
            _position = 0;
        }

        public void Reset()
        {
            _position = 0;
        }

        public byte[] CopyData()
        {
            byte[] resultData = new byte[_position];
            Buffer.BlockCopy(_data, 0, resultData, 0, _position);
            return resultData;
        }

        /// <summary>
        /// Sets position of NetDataWriter to rewrite previous values
        /// </summary>
        /// <param name="position">new byte position</param>
        /// <returns>previous position of data writer</returns>
        public int SetPosition(int position)
        {
            int prevPosition = _position;
            _position = position;
            return prevPosition;
        }

        public void Put(float value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 4);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 4;
        }

        public void Put(double value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 8);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 8;
        }

        public void Put(long value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 8);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 8;
        }

        public void Put(ulong value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 8);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 8;
        }

        public void Put(int value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 4);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 4;
        }

        public void Put(uint value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 4);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 4;
        }

        public void Put(char value)
        {
            Put((ushort)value);
        }

        public void Put(ushort value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 2);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 2;
        }

        public void Put(short value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 2);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 2;
        }

        public void Put(sbyte value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 1);
            _data[_position] = (byte)value;
            _position++;
        }

        public void Put(byte value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 1);
            _data[_position] = value;
            _position++;
        }

        public void Put(byte[] data, int offset, int length)
        {
            if (_autoResize)
                ResizeIfNeed(_position + length);
            Buffer.BlockCopy(data, offset, _data, _position, length);
            _position += length;
        }

        public void Put(byte[] data)
        {
            if (_autoResize)
                ResizeIfNeed(_position + data.Length);
            Buffer.BlockCopy(data, 0, _data, _position, data.Length);
            _position += data.Length;
        }

        public void PutSBytesWithLength(sbyte[] data, int offset, int length)
        {
            if (_autoResize)
                ResizeIfNeed(_position + length + 4);
            FastBitConverter.GetBytes(_data, _position, length);
            Buffer.BlockCopy(data, offset, _data, _position + 4, length);
            _position += length + 4;
        }

        public void PutSBytesWithLength(sbyte[] data)
        {
            if (_autoResize)
                ResizeIfNeed(_position + data.Length + 4);
            FastBitConverter.GetBytes(_data, _position, data.Length);
            Buffer.BlockCopy(data, 0, _data, _position + 4, data.Length);
            _position += data.Length + 4;
        }

        public void PutBytesWithLength(byte[] data, int offset, int length)
        {
            if (_autoResize)
                ResizeIfNeed(_position + length + 4);
            FastBitConverter.GetBytes(_data, _position, length);
            Buffer.BlockCopy(data, offset, _data, _position + 4, length);
            _position += length + 4;
        }

        public void PutBytesWithLength(byte[] data)
        {
            if (_autoResize)
                ResizeIfNeed(_position + data.Length + 4);
            FastBitConverter.GetBytes(_data, _position, data.Length);
            Buffer.BlockCopy(data, 0, _data, _position + 4, data.Length);
            _position += data.Length + 4;
        }

        public void Put(bool value)
        {
            Put((byte)(value ? 1 : 0));
        }

        private void PutArray(Array arr, int sz)
        {
            ushort length = arr == null ? (ushort) 0 : (ushort)arr.Length;
            sz *= length;
            if (_autoResize)
                ResizeIfNeed(_position + sz + 2);
            FastBitConverter.GetBytes(_data, _position, length);
            if (arr != null)
                Buffer.BlockCopy(arr, 0, _data, _position + 2, sz);
            _position += sz + 2;
        }

        public void PutArray(float[] value)
        {
            PutArray(value, 4);
        }

        public void PutArray(double[] value)
        {
            PutArray(value, 8);
        }

        public void PutArray(long[] value)
        {
            PutArray(value, 8);
        }

        public void PutArray(ulong[] value)
        {
            PutArray(value, 8);
        }

        public void PutArray(int[] value)
        {
            PutArray(value, 4);
        }

        public void PutArray(uint[] value)
        {
            PutArray(value, 4);
        }

        public void PutArray(ushort[] value)
        {
            PutArray(value, 2);
        }

        public void PutArray(short[] value)
        {
            PutArray(value, 2);
        }

        public void PutArray(bool[] value)
        {
            PutArray(value, 1);
        }

        public void PutArray(string[] value)
        {
            ushort strArrayLength = value == null ? (ushort)0 : (ushort)value.Length;
            Put(strArrayLength);
            for (int i = 0; i < strArrayLength; i++)
                Put(value[i]);
        }

        public void PutArray(string[] value, int strMaxLength)
        {
            ushort strArrayLength = value == null ? (ushort)0 : (ushort)value.Length;
            Put(strArrayLength);
            for (int i = 0; i < strArrayLength; i++)
                Put(value[i], strMaxLength);
        }

        public void Put(IPEndPoint endPoint)
        {
            Put(endPoint.Address.ToString());
            Put(endPoint.Port);
        }

        public void Put(string value)
        {
            Put(value, 0);
        }

        /// <summary>
        /// Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
        /// </summary>
        public void Put(string value, int maxLength)
        {
            if (value == null)
            {
                Put((ushort)0);
                return;
            }

            int length = maxLength > 0 && value.Length > maxLength ? maxLength : value.Length;
            int size = _uTF8Encoding.GetBytes(value, 0, length, _stringBuffer, 0);

            if (size >= StringBufferMaxLength)
            {
                Put((ushort)0);
                return;
            }

            Put(checked((ushort)(size + 1)));
            Put(_stringBuffer, 0, size);
        }

        public void Put<T>(T obj) where T : INetSerializable
        {
            obj.Serialize(this);
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/NetPacketProcessor.cs ---
﻿using System;
using System.Collections.Generic;

namespace LiteNetLib.Utils
{
    public class NetPacketProcessor
    {
        private static class HashCache<T>
        {
            public static readonly ulong Id;

            //FNV-1 64 bit hash
            static HashCache()
            {
                ulong hash = 14695981039346656037UL; //offset
                string typeName = typeof(T).ToString();
                for (var i = 0; i < typeName.Length; i++)
                {
                    hash ^= typeName[i];
                    hash *= 1099511628211UL; //prime
                }
                Id = hash;
            }
        }

        protected delegate void SubscribeDelegate(NetDataReader reader, object userData);
        private readonly NetSerializer _netSerializer;
        private readonly Dictionary<ulong, SubscribeDelegate> _callbacks = new Dictionary<ulong, SubscribeDelegate>();
        private readonly NetDataWriter _netDataWriter = new NetDataWriter();

        public NetPacketProcessor()
        {
            _netSerializer = new NetSerializer();
        }

        public NetPacketProcessor(int maxStringLength)
        {
            _netSerializer = new NetSerializer(maxStringLength);
        }

        protected virtual ulong GetHash<T>()
        {
            return HashCache<T>.Id;
        }

        protected virtual SubscribeDelegate GetCallbackFromData(NetDataReader reader)
        {
            ulong hash = reader.GetULong();
            if (!_callbacks.TryGetValue(hash, out var action))
            {
                throw new ParseException("Undefined packet in NetDataReader");
            }
            return action;
        }

        protected virtual void WriteHash<T>(NetDataWriter writer)
        {
            writer.Put(GetHash<T>());
        }

        /// <summary>
        /// Register nested property type
        /// </summary>
        /// <typeparam name="T">INetSerializable structure</typeparam>
        public void RegisterNestedType<T>() where T : struct, INetSerializable
        {
            _netSerializer.RegisterNestedType<T>();
        }

        /// <summary>
        /// Register nested property type
        /// </summary>
        /// <param name="writeDelegate"></param>
        /// <param name="readDelegate"></param>
        public void RegisterNestedType<T>(Action<NetDataWriter, T> writeDelegate, Func<NetDataReader, T> readDelegate)
        {
            _netSerializer.RegisterNestedType<T>(writeDelegate, readDelegate);
        }

        /// <summary>
        /// Register nested property type
        /// </summary>
        /// <typeparam name="T">INetSerializable class</typeparam>
        public void RegisterNestedType<T>(Func<T> constructor) where T : class, INetSerializable
        {
            _netSerializer.RegisterNestedType(constructor);
        }

        /// <summary>
        /// Reads all available data from NetDataReader and calls OnReceive delegates
        /// </summary>
        /// <param name="reader">NetDataReader with packets data</param>
        public void ReadAllPackets(NetDataReader reader)
        {
            while (reader.AvailableBytes > 0)
                ReadPacket(reader);
        }

        /// <summary>
        /// Reads all available data from NetDataReader and calls OnReceive delegates
        /// </summary>
        /// <param name="reader">NetDataReader with packets data</param>
        /// <param name="userData">Argument that passed to OnReceivedEvent</param>
        /// <exception cref="ParseException">Malformed packet</exception>
        public void ReadAllPackets(NetDataReader reader, object userData)
        {
            while (reader.AvailableBytes > 0)
                ReadPacket(reader, userData);
        }

        /// <summary>
        /// Reads one packet from NetDataReader and calls OnReceive delegate
        /// </summary>
        /// <param name="reader">NetDataReader with packet</param>
        /// <exception cref="ParseException">Malformed packet</exception>
        public void ReadPacket(NetDataReader reader)
        {
            ReadPacket(reader, null);
        }

        public void Send<T>(NetPeer peer, T packet, DeliveryMethod options) where T : class, new()
        {
            _netDataWriter.Reset();
            Write(_netDataWriter, packet);
            peer.Send(_netDataWriter, options);
        }

        public void SendNetSerializable<T>(NetPeer peer, ref T packet, DeliveryMethod options) where T : INetSerializable
        {
            _netDataWriter.Reset();
            WriteNetSerializable(_netDataWriter, ref packet);
            peer.Send(_netDataWriter, options);
        }

        public void Send<T>(NetManager manager, T packet, DeliveryMethod options) where T : class, new()
        {
            _netDataWriter.Reset();
            Write(_netDataWriter, packet);
            manager.SendToAll(_netDataWriter, options);
        }

        public void SendNetSerializable<T>(NetManager manager, ref T packet, DeliveryMethod options) where T : INetSerializable
        {
            _netDataWriter.Reset();
            WriteNetSerializable(_netDataWriter, ref packet);
            manager.SendToAll(_netDataWriter, options);
        }

        public void Write<T>(NetDataWriter writer, T packet) where T : class, new()
        {
            WriteHash<T>(writer);
            _netSerializer.Serialize(writer, packet);
        }

        public void WriteNetSerializable<T>(NetDataWriter writer, ref T packet) where T : INetSerializable
        {
            WriteHash<T>(writer);
            packet.Serialize(writer);
        }

        /// <summary>
        /// Reads one packet from NetDataReader and calls OnReceive delegate
        /// </summary>
        /// <param name="reader">NetDataReader with packet</param>
        /// <param name="userData">Argument that passed to OnReceivedEvent</param>
        /// <exception cref="ParseException">Malformed packet</exception>
        public void ReadPacket(NetDataReader reader, object userData)
        {
            GetCallbackFromData(reader)(reader, userData);
        }

        /// <summary>
        /// Register and subscribe to packet receive event
        /// </summary>
        /// <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
        /// <param name="packetConstructor">Method that constructs packet instead of slow Activator.CreateInstance</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void Subscribe<T>(Action<T> onReceive, Func<T> packetConstructor) where T : class, new()
        {
            _netSerializer.Register<T>();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                var reference = packetConstructor();
                _netSerializer.Deserialize(reader, reference);
                onReceive(reference);
            };
        }

        /// <summary>
        /// Register and subscribe to packet receive event (with userData)
        /// </summary>
        /// <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
        /// <param name="packetConstructor">Method that constructs packet instead of slow Activator.CreateInstance</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void Subscribe<T, TUserData>(Action<T, TUserData> onReceive, Func<T> packetConstructor) where T : class, new()
        {
            _netSerializer.Register<T>();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                var reference = packetConstructor();
                _netSerializer.Deserialize(reader, reference);
                onReceive(reference, (TUserData)userData);
            };
        }

        /// <summary>
        /// Register and subscribe to packet receive event
        /// This method will overwrite last received packet class on receive (less garbage)
        /// </summary>
        /// <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void SubscribeReusable<T>(Action<T> onReceive) where T : class, new()
        {
            _netSerializer.Register<T>();
            var reference = new T();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                _netSerializer.Deserialize(reader, reference);
                onReceive(reference);
            };
        }

        /// <summary>
        /// Register and subscribe to packet receive event
        /// This method will overwrite last received packet class on receive (less garbage)
        /// </summary>
        /// <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void SubscribeReusable<T, TUserData>(Action<T, TUserData> onReceive) where T : class, new()
        {
            _netSerializer.Register<T>();
            var reference = new T();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                _netSerializer.Deserialize(reader, reference);
                onReceive(reference, (TUserData)userData);
            };
        }

        public void SubscribeNetSerializable<T, TUserData>(
            Action<T, TUserData> onReceive,
            Func<T> packetConstructor) where T : INetSerializable
        {
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                var pkt = packetConstructor();
                pkt.Deserialize(reader);
                onReceive(pkt, (TUserData)userData);
            };
        }

        public void SubscribeNetSerializable<T>(
            Action<T> onReceive,
            Func<T> packetConstructor) where T : INetSerializable
        {
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                var pkt = packetConstructor();
                pkt.Deserialize(reader);
                onReceive(pkt);
            };
        }

        public void SubscribeNetSerializable<T, TUserData>(
            Action<T, TUserData> onReceive) where T : INetSerializable, new()
        {
            var reference = new T();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                reference.Deserialize(reader);
                onReceive(reference, (TUserData)userData);
            };
        }

        public void SubscribeNetSerializable<T>(
            Action<T> onReceive) where T : INetSerializable, new()
        {
            var reference = new T();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                reference.Deserialize(reader);
                onReceive(reference);
            };
        }

        /// <summary>
        /// Remove any subscriptions by type
        /// </summary>
        /// <typeparam name="T">Packet type</typeparam>
        /// <returns>true if remove is success</returns>
        public bool RemoveSubscription<T>()
        {
            return _callbacks.Remove(GetHash<T>());
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/NetSerializer.cs ---
﻿using System;
using System.Reflection;
using System.Collections.Generic;
using System.Net;
using System.Runtime.Serialization;

namespace LiteNetLib.Utils
{
    public class InvalidTypeException : ArgumentException
    {
        public InvalidTypeException(string message) : base(message) { }
    }

    public class ParseException : Exception
    {
        public ParseException(string message) : base(message) { }
    }

    public class NetSerializer
    {
        private enum CallType
        {
            Basic,
            Array,
            List
        }

        private abstract class FastCall<T>
        {
            public CallType Type;
            public virtual void Init(MethodInfo getMethod, MethodInfo setMethod, CallType type) { Type = type; }
            public abstract void Read(T inf, NetDataReader r);
            public abstract void Write(T inf, NetDataWriter w);
            public abstract void ReadArray(T inf, NetDataReader r);
            public abstract void WriteArray(T inf, NetDataWriter w);
            public abstract void ReadList(T inf, NetDataReader r);
            public abstract void WriteList(T inf, NetDataWriter w);
        }

        private abstract class FastCallSpecific<TClass, TProperty> : FastCall<TClass>
        {
            protected Func<TClass, TProperty> Getter;
            protected Action<TClass, TProperty> Setter;
            protected Func<TClass, TProperty[]> GetterArr;
            protected Action<TClass, TProperty[]> SetterArr;
            protected Func<TClass, List<TProperty>> GetterList;
            protected Action<TClass, List<TProperty>> SetterList;

            public override void ReadArray(TClass inf, NetDataReader r) { throw new InvalidTypeException("Unsupported type: " + typeof(TProperty) + "[]"); }
            public override void WriteArray(TClass inf, NetDataWriter w) { throw new InvalidTypeException("Unsupported type: " + typeof(TProperty) + "[]"); }
            public override void ReadList(TClass inf, NetDataReader r) { throw new InvalidTypeException("Unsupported type: List<" + typeof(TProperty) + ">"); }
            public override void WriteList(TClass inf, NetDataWriter w) { throw new InvalidTypeException("Unsupported type: List<" + typeof(TProperty) + ">"); }

            protected TProperty[] ReadArrayHelper(TClass inf, NetDataReader r)
            {
                ushort count = r.GetUShort();
                var arr = GetterArr(inf);
                arr = arr == null || arr.Length != count ? new TProperty[count] : arr;
                SetterArr(inf, arr);
                return arr;
            }

            protected TProperty[] WriteArrayHelper(TClass inf, NetDataWriter w)
            {
                var arr = GetterArr(inf);
                w.Put((ushort)arr.Length);
                return arr;
            }

            protected List<TProperty> ReadListHelper(TClass inf, NetDataReader r, out int len)
            {
                len = r.GetUShort();
                var list = GetterList(inf);
                if (list == null)
                {
                    list = new List<TProperty>(len);
                    SetterList(inf, list);
                }
                return list;
            }

            protected List<TProperty> WriteListHelper(TClass inf, NetDataWriter w, out int len)
            {
                var list = GetterList(inf);
                if (list == null)
                {
                    len = 0;
                    w.Put(0);
                    return null;
                }
                len = list.Count;
                w.Put((ushort)len);
                return list;
            }

            public override void Init(MethodInfo getMethod, MethodInfo setMethod, CallType type)
            {
                base.Init(getMethod, setMethod, type);
                switch (type)
                {
                    case CallType.Array:
                        GetterArr = (Func<TClass, TProperty[]>)Delegate.CreateDelegate(typeof(Func<TClass, TProperty[]>), getMethod);
                        SetterArr = (Action<TClass, TProperty[]>)Delegate.CreateDelegate(typeof(Action<TClass, TProperty[]>), setMethod);
                        break;
                    case CallType.List:
                        GetterList = (Func<TClass, List<TProperty>>)Delegate.CreateDelegate(typeof(Func<TClass, List<TProperty>>), getMethod);
                        SetterList = (Action<TClass, List<TProperty>>)Delegate.CreateDelegate(typeof(Action<TClass, List<TProperty>>), setMethod);
                        break;
                    default:
                        Getter = (Func<TClass, TProperty>)Delegate.CreateDelegate(typeof(Func<TClass, TProperty>), getMethod);
                        Setter = (Action<TClass, TProperty>)Delegate.CreateDelegate(typeof(Action<TClass, TProperty>), setMethod);
                        break;
                }
            }
        }

        private abstract class FastCallSpecificAuto<TClass, TProperty> : FastCallSpecific<TClass, TProperty>
        {
            protected abstract void ElementRead(NetDataReader r, out TProperty prop);
            protected abstract void ElementWrite(NetDataWriter w, ref TProperty prop);

            public override void Read(TClass inf, NetDataReader r)
            {
                ElementRead(r, out var elem);
                Setter(inf, elem);
            }

            public override void Write(TClass inf, NetDataWriter w)
            {
                var elem = Getter(inf);
                ElementWrite(w, ref elem);
            }

            public override void ReadArray(TClass inf, NetDataReader r)
            {
                var arr = ReadArrayHelper(inf, r);
                for (int i = 0; i < arr.Length; i++)
                    ElementRead(r, out arr[i]);
            }

            public override void WriteArray(TClass inf, NetDataWriter w)
            {
                var arr = WriteArrayHelper(inf, w);
                for (int i = 0; i < arr.Length; i++)
                    ElementWrite(w, ref arr[i]);
            }
        }

        private sealed class FastCallStatic<TClass, TProperty> : FastCallSpecific<TClass, TProperty>
        {
            private readonly Action<NetDataWriter, TProperty> _writer;
            private readonly Func<NetDataReader, TProperty> _reader;

            public FastCallStatic(Action<NetDataWriter, TProperty> write, Func<NetDataReader, TProperty> read)
            {
                _writer = write;
                _reader = read;
            }

            public override void Read(TClass inf, NetDataReader r) { Setter(inf, _reader(r)); }
            public override void Write(TClass inf, NetDataWriter w) { _writer(w, Getter(inf)); }

            public override void ReadList(TClass inf, NetDataReader r)
            {
                var list = ReadListHelper(inf, r, out int len);
                int listCount = list.Count;
                for (int i = 0; i < len; i++)
                {
                    if (i < listCount)
                        list[i] = _reader(r);
                    else
                        list.Add(_reader(r));
                }
                if (len < listCount)
                    list.RemoveRange(len, listCount - len);
            }

            public override void WriteList(TClass inf, NetDataWriter w)
            {
                var list = WriteListHelper(inf, w, out int len);
                for (int i = 0; i < len; i++)
                    _writer(w, list[i]);
            }

            public override void ReadArray(TClass inf, NetDataReader r)
            {
                var arr = ReadArrayHelper(inf, r);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    arr[i] = _reader(r);
            }

            public override void WriteArray(TClass inf, NetDataWriter w)
            {
                var arr = WriteArrayHelper(inf, w);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    _writer(w, arr[i]);
            }
        }

        private sealed class FastCallStruct<TClass, TProperty> : FastCallSpecific<TClass, TProperty> where TProperty : struct, INetSerializable
        {
            private TProperty _p;

            public override void Read(TClass inf, NetDataReader r)
            {
                _p.Deserialize(r);
                Setter(inf, _p);
            }

            public override void Write(TClass inf, NetDataWriter w)
            {
                _p = Getter(inf);
                _p.Serialize(w);
            }

            public override void ReadList(TClass inf, NetDataReader r)
            {
                var list = ReadListHelper(inf, r, out int len);
                int listCount = list.Count;
                for (int i = 0; i < len; i++)
                {
                    var itm = default(TProperty);
                    itm.Deserialize(r);
                    if(i < listCount)
                        list[i] = itm;
                    else
                        list.Add(itm);
                }
                if (len < listCount)
                    list.RemoveRange(len, listCount - len);
            }

            public override void WriteList(TClass inf, NetDataWriter w)
            {
                var list = WriteListHelper(inf, w, out int len);
                for (int i = 0; i < len; i++)
                    list[i].Serialize(w);
            }

            public override void ReadArray(TClass inf, NetDataReader r)
            {
                var arr = ReadArrayHelper(inf, r);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    arr[i].Deserialize(r);
            }

            public override void WriteArray(TClass inf, NetDataWriter w)
            {
                var arr = WriteArrayHelper(inf, w);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    arr[i].Serialize(w);
            }
        }

        private sealed class FastCallClass<TClass, TProperty> : FastCallSpecific<TClass, TProperty> where TProperty : class, INetSerializable
        {
            private readonly Func<TProperty> _constructor;
            public FastCallClass(Func<TProperty> constructor) { _constructor = constructor; }

            public override void Read(TClass inf, NetDataReader r)
            {
                var p = _constructor();
                p.Deserialize(r);
                Setter(inf, p);
            }

            public override void Write(TClass inf, NetDataWriter w)
            {
                var p = Getter(inf);
                p?.Serialize(w);
            }

            public override void ReadList(TClass inf, NetDataReader r)
            {
                var list = ReadListHelper(inf, r, out int len);
                int listCount = list.Count;
                for (int i = 0; i < len; i++)
                {
                    if (i < listCount)
                    {
                        list[i].Deserialize(r);
                    }
                    else
                    {
                        var itm = _constructor();
                        itm.Deserialize(r);
                        list.Add(itm);
                    }
                }
                if (len < listCount)
                    list.RemoveRange(len, listCount - len);
            }

            public override void WriteList(TClass inf, NetDataWriter w)
            {
                var list = WriteListHelper(inf, w, out int len);
                for (int i = 0; i < len; i++)
                    list[i].Serialize(w);
            }

            public override void ReadArray(TClass inf, NetDataReader r)
            {
                var arr = ReadArrayHelper(inf, r);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                {
                    arr[i] = _constructor();
                    arr[i].Deserialize(r);
                }
            }

            public override void WriteArray(TClass inf, NetDataWriter w)
            {
                var arr = WriteArrayHelper(inf, w);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    arr[i].Serialize(w);
            }
        }

        private class IntSerializer<T> : FastCallSpecific<T, int>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetInt()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetIntArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class UIntSerializer<T> : FastCallSpecific<T, uint>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetUInt()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetUIntArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class ShortSerializer<T> : FastCallSpecific<T, short>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetShort()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetShortArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class UShortSerializer<T> : FastCallSpecific<T, ushort>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetUShort()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetUShortArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class LongSerializer<T> : FastCallSpecific<T, long>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetLong()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetLongArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class ULongSerializer<T> : FastCallSpecific<T, ulong>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetULong()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetULongArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class ByteSerializer<T> : FastCallSpecific<T, byte>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetByte()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetBytesWithLength()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutBytesWithLength(GetterArr(inf)); }
        }

        private class SByteSerializer<T> : FastCallSpecific<T, sbyte>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetSByte()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetSBytesWithLength()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutSBytesWithLength(GetterArr(inf)); }
        }

        private class FloatSerializer<T> : FastCallSpecific<T, float>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetFloat()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetFloatArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class DoubleSerializer<T> : FastCallSpecific<T, double>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetDouble()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetDoubleArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class BoolSerializer<T> : FastCallSpecific<T, bool>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetBool()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetBoolArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class CharSerializer<T> : FastCallSpecificAuto<T, char>
        {
            protected override void ElementWrite(NetDataWriter w, ref char prop) { w.Put(prop); }
            protected override void ElementRead(NetDataReader r, out char prop) { prop = r.GetChar(); }
        }

        private class IPEndPointSerializer<T> : FastCallSpecificAuto<T, IPEndPoint>
        {
            protected override void ElementWrite(NetDataWriter w, ref IPEndPoint prop) { w.Put(prop); }
            protected override void ElementRead(NetDataReader r, out IPEndPoint prop) { prop = r.GetNetEndPoint(); }
        }

        private class StringSerializer<T> : FastCallSpecific<T, string>
        {
            private readonly int _maxLength;
            public StringSerializer(int maxLength) { _maxLength = maxLength > 0 ? maxLength : short.MaxValue; }
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetString(_maxLength)); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf), _maxLength); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetStringArray(_maxLength)); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf), _maxLength); }
        }

        private class EnumByteSerializer<T> : FastCall<T>
        {
            protected readonly PropertyInfo Property;
            protected readonly Type PropertyType;
            public EnumByteSerializer(PropertyInfo property, Type propertyType)
            {
                Property = property;
                PropertyType = propertyType;
            }
            public override void Read(T inf, NetDataReader r) { Property.SetValue(inf, Enum.ToObject(PropertyType, r.GetByte()), null); }
            public override void Write(T inf, NetDataWriter w) { w.Put((byte)Property.GetValue(inf, null)); }
            public override void ReadArray(T inf, NetDataReader r) { throw new InvalidTypeException("Unsupported type: Enum[]"); }
            public override void WriteArray(T inf, NetDataWriter w) { throw new InvalidTypeException("Unsupported type: Enum[]"); }
            public override void ReadList(T inf, NetDataReader r) { throw new InvalidTypeException("Unsupported type: List<Enum>"); }
            public override void WriteList(T inf, NetDataWriter w) { throw new InvalidTypeException("Unsupported type: List<Enum>"); }
        }

        private class EnumIntSerializer<T> : EnumByteSerializer<T>
        {
            public EnumIntSerializer(PropertyInfo property, Type propertyType) : base(property, propertyType) { }
            public override void Read(T inf, NetDataReader r) { Property.SetValue(inf, Enum.ToObject(PropertyType, r.GetInt()), null); }
            public override void Write(T inf, NetDataWriter w) { w.Put((int)Property.GetValue(inf, null)); }
        }

        private sealed class ClassInfo<T>
        {
            public static ClassInfo<T> Instance;
            private readonly FastCall<T>[] _serializers;
            private readonly int _membersCount;

            public ClassInfo(List<FastCall<T>> serializers)
            {
                _membersCount = serializers.Count;
                _serializers = serializers.ToArray();
            }

            public void Write(T obj, NetDataWriter writer)
            {
                for (int i = 0; i < _membersCount; i++)
                {
                    var s = _serializers[i];
                    if (s.Type == CallType.Basic)
                        s.Write(obj, writer);
                    else if (s.Type == CallType.Array)
                        s.WriteArray(obj, writer);
                    else
                        s.WriteList(obj, writer);
                }
            }

            public void Read(T obj, NetDataReader reader)
            {
                for (int i = 0; i < _membersCount; i++)
                {
                    var s = _serializers[i];
                    if (s.Type == CallType.Basic)
                        s.Read(obj, reader);
                    else if(s.Type == CallType.Array)
                        s.ReadArray(obj, reader);
                    else
                        s.ReadList(obj, reader);
                }
            }
        }

        private abstract class CustomType
        {
            public abstract FastCall<T> Get<T>();
        }

        private sealed class CustomTypeStruct<TProperty> : CustomType where TProperty : struct, INetSerializable
        {
            public override FastCall<T> Get<T>() { return new FastCallStruct<T, TProperty>(); }
        }

        private sealed class CustomTypeClass<TProperty> : CustomType where TProperty : class, INetSerializable
        {
            private readonly Func<TProperty> _constructor;
            public CustomTypeClass(Func<TProperty> constructor) { _constructor = constructor; }
            public override FastCall<T> Get<T>() { return new FastCallClass<T, TProperty>(_constructor); }
        }

        private sealed class CustomTypeStatic<TProperty> : CustomType
        {
            private readonly Action<NetDataWriter, TProperty> _writer;
            private readonly Func<NetDataReader, TProperty> _reader;
            public CustomTypeStatic(Action<NetDataWriter, TProperty> writer, Func<NetDataReader, TProperty> reader)
            {
                _writer = writer;
                _reader = reader;
            }
            public override FastCall<T> Get<T>() { return new FastCallStatic<T, TProperty>(_writer, _reader); }
        }

        /// <summary>
        /// Register custom property type
        /// </summary>
        /// <typeparam name="T">INetSerializable structure</typeparam>
        public void RegisterNestedType<T>() where T : struct, INetSerializable
        {
            _registeredTypes.Add(typeof(T), new CustomTypeStruct<T>());
        }

        /// <summary>
        /// Register custom property type
        /// </summary>
        /// <typeparam name="T">INetSerializable class</typeparam>
        public void RegisterNestedType<T>(Func<T> constructor) where T : class, INetSerializable
        {
            _registeredTypes.Add(typeof(T), new CustomTypeClass<T>(constructor));
        }

        /// <summary>
        /// Register custom property type
        /// </summary>
        /// <typeparam name="T">Any packet</typeparam>
        /// <param name="writer">custom type writer</param>
        /// <param name="reader">custom type reader</param>
        public void RegisterNestedType<T>(Action<NetDataWriter, T> writer, Func<NetDataReader, T> reader)
        {
            _registeredTypes.Add(typeof(T), new CustomTypeStatic<T>(writer, reader));
        }

        private NetDataWriter _writer;
        private readonly int _maxStringLength;
        private readonly Dictionary<Type, CustomType> _registeredTypes = new Dictionary<Type, CustomType>();

        public NetSerializer() : this(0)
        {
        }

        public NetSerializer(int maxStringLength)
        {
            _maxStringLength = maxStringLength;
        }

        private ClassInfo<T> RegisterInternal<T>()
        {
            if (ClassInfo<T>.Instance != null)
                return ClassInfo<T>.Instance;

            Type t = typeof(T);
            var props = t.GetProperties(
                BindingFlags.Instance |
                BindingFlags.Public |
                BindingFlags.GetProperty |
                BindingFlags.SetProperty);
            var serializers = new List<FastCall<T>>();
            for (int i = 0; i < props.Length; i++)
            {
                var property = props[i];
                var propertyType = property.PropertyType;

                var elementType = propertyType.IsArray ? propertyType.GetElementType() : propertyType;
                var callType = propertyType.IsArray ? CallType.Array : CallType.Basic;

                if (propertyType.IsGenericType && propertyType.GetGenericTypeDefinition() == typeof(List<>))
                {
                    elementType = propertyType.GetGenericArguments()[0];
                    callType = CallType.List;
                }

                if (Attribute.IsDefined(property, typeof(IgnoreDataMemberAttribute)))
                    continue;

                var getMethod = property.GetGetMethod();
                var setMethod = property.GetSetMethod();
                if (getMethod == null || setMethod == null)
                    continue;

                FastCall<T> serialzer = null;
                if (propertyType.IsEnum)
                {
                    var underlyingType = Enum.GetUnderlyingType(propertyType);
                    if (underlyingType == typeof(byte))
                        serialzer = new EnumByteSerializer<T>(property, propertyType);
                    else if (underlyingType == typeof(int))
                        serialzer = new EnumIntSerializer<T>(property, propertyType);
                    else
                        throw new InvalidTypeException("Not supported enum underlying type: " + underlyingType.Name);
                }
                else if (elementType == typeof(string))
                    serialzer = new StringSerializer<T>(_maxStringLength);
                else if (elementType == typeof(bool))
                    serialzer = new BoolSerializer<T>();
                else if (elementType == typeof(byte))
                    serialzer = new ByteSerializer<T>();
                else if (elementType == typeof(sbyte))
                    serialzer = new SByteSerializer<T>();
                else if (elementType == typeof(short))
                    serialzer = new ShortSerializer<T>();
                else if (elementType == typeof(ushort))
                    serialzer = new UShortSerializer<T>();
                else if (elementType == typeof(int))
                    serialzer = new IntSerializer<T>();
                else if (elementType == typeof(uint))
                    serialzer = new UIntSerializer<T>();
                else if (elementType == typeof(long))
                    serialzer = new LongSerializer<T>();
                else if (elementType == typeof(ulong))
                    serialzer = new ULongSerializer<T>();
                else if (elementType == typeof(float))
                    serialzer = new FloatSerializer<T>();
                else if (elementType == typeof(double))
                    serialzer = new DoubleSerializer<T>();
                else if (elementType == typeof(char))
                    serialzer = new CharSerializer<T>();
                else if (elementType == typeof(IPEndPoint))
                    serialzer = new IPEndPointSerializer<T>();
                else
                {
                    _registeredTypes.TryGetValue(elementType, out var customType);
                    if (customType != null)
                        serialzer = customType.Get<T>();
                }

                if (serialzer != null)
                {
                    serialzer.Init(getMethod, setMethod, callType);
                    serializers.Add(serialzer);
                }
                else
                {
                    throw new InvalidTypeException("Unknown property type: " + propertyType.FullName);
                }
            }
            ClassInfo<T>.Instance = new ClassInfo<T>(serializers);
            return ClassInfo<T>.Instance;
        }

        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void Register<T>()
        {
            RegisterInternal<T>();
        }

        /// <summary>
        /// Reads packet with known type
        /// </summary>
        /// <param name="reader">NetDataReader with packet</param>
        /// <returns>Returns packet if packet in reader is matched type</returns>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public T Deserialize<T>(NetDataReader reader) where T : class, new()
        {
            var info = RegisterInternal<T>();
            var result = new T();
            try
            {
                info.Read(result, reader);
            }
            catch
            {
                return null;
            }
            return result;
        }

        /// <summary>
        /// Reads packet with known type (non alloc variant)
        /// </summary>
        /// <param name="reader">NetDataReader with packet</param>
        /// <param name="target">Deserialization target</param>
        /// <returns>Returns true if packet in reader is matched type</returns>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public bool Deserialize<T>(NetDataReader reader, T target) where T : class, new()
        {
            var info = RegisterInternal<T>();
            try
            {
                info.Read(target, reader);
            }
            catch
            {
                return false;
            }
            return true;
        }

        /// <summary>
        /// Serialize object to NetDataWriter (fast)
        /// </summary>
        /// <param name="writer">Serialization target NetDataWriter</param>
        /// <param name="obj">Object to serialize</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void Serialize<T>(NetDataWriter writer, T obj) where T : class, new()
        {
            RegisterInternal<T>().Write(obj, writer);
        }

        /// <summary>
        /// Serialize object to byte array
        /// </summary>
        /// <param name="obj">Object to serialize</param>
        /// <returns>byte array with serialized data</returns>
        public byte[] Serialize<T>(T obj) where T : class, new()
        {
            if (_writer == null)
                _writer = new NetDataWriter();
            _writer.Reset();
            Serialize(_writer, obj);
            return _writer.CopyData();
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/NtpPacket.cs ---
﻿using System;

namespace LiteNetLib.Utils
{
    /// <summary>
    /// Represents RFC4330 SNTP packet used for communication to and from a network time server.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Most applications should just use the <see cref="NtpPacket.CorrectionOffset" /> property.
    /// </para>
    /// <para>
    /// The same data structure represents both request and reply packets.
    /// Request and reply differ in which properties are set and to what values.
    /// </para>
    /// <para>
    /// The only real property is <see cref="NtpPacket.Bytes" />.
    /// All other properties read from and write to the underlying byte array
    /// with the exception of <see cref="NtpPacket.DestinationTimestamp" />,
    /// which is not part of the packet on network and it is instead set locally after receiving the packet.
    /// </para>
    /// <para>
    /// Copied from <a href="https://guerrillantp.machinezoo.com/">GuerrillaNtp project</a>
    /// with permission from Robert Vazan (@robertvazan) under MIT license, see https://github.com/RevenantX/LiteNetLib/pull/236
    /// </para>
    /// </remarks>
    public class NtpPacket
    {
        private static readonly DateTime Epoch = new DateTime(1900, 1, 1);

        /// <summary>
        /// Gets RFC4330-encoded SNTP packet.
        /// </summary>
        /// <value>
        /// Byte array containing RFC4330-encoded SNTP packet. It is at least 48 bytes long.
        /// </value>
        /// <remarks>
        /// This is the only real property. All other properties except
        /// <see cref="NtpPacket.DestinationTimestamp" /> read from or write to this byte array.
        /// </remarks>
        public byte[] Bytes { get; }

        /// <summary>
        /// Gets the leap second indicator.
        /// </summary>
        /// <value>
        /// Leap second warning, if any. Special value
        /// <see cref="NtpLeapIndicator.AlarmCondition" /> indicates unsynchronized server clock.
        /// Default is <see cref="NtpLeapIndicator.NoWarning" />.
        /// </value>
        /// <remarks>
        /// Only servers fill in this property. Clients can consult this property for possible leap second warning.
        /// </remarks>
        public NtpLeapIndicator LeapIndicator => (NtpLeapIndicator)((Bytes[0] & 0xC0) >> 6);

        /// <summary>
        /// Gets or sets protocol version number.
        /// </summary>
        /// <value>
        /// SNTP protocol version. Default is 4, which is the latest version at the time of this writing.
        /// </value>
        /// <remarks>
        /// In request packets, clients should leave this property at default value 4.
        /// Servers usually reply with the same protocol version.
        /// </remarks>
        public int VersionNumber
        {
            get => (Bytes[0] & 0x38) >> 3;
            private set => Bytes[0] = (byte)((Bytes[0] & ~0x38) | value << 3);
        }

        /// <summary>
        /// Gets or sets SNTP packet mode, i.e. whether this is client or server packet.
        /// </summary>
        /// <value>
        /// SNTP packet mode. Default is <see cref="NtpMode.Client" /> in newly created packets.
        /// Server reply should have this property set to <see cref="NtpMode.Server" />.
        /// </value>
        public NtpMode Mode
        {
            get => (NtpMode)(Bytes[0] & 0x07);
            private set => Bytes[0] = (byte)((Bytes[0] & ~0x07) | (int)value);
        }

        /// <summary>
        /// Gets server's distance from the reference clock.
        /// </summary>
        /// <value>
        /// <para>
        /// Distance from the reference clock. This property is set only in server reply packets.
        /// Servers connected directly to reference clock hardware set this property to 1.
        /// Statum number is incremented by 1 on every hop down the NTP server hierarchy.
        /// </para>
        /// <para>
        /// Special value 0 indicates that this packet is a Kiss-o'-Death message
        /// with kiss code stored in <see cref="NtpPacket.ReferenceId" />.
        /// </para>
        /// </value>
        public int Stratum => Bytes[1];

        /// <summary>
        /// Gets server's preferred polling interval.
        /// </summary>
        /// <value>
        /// Polling interval in log2 seconds, e.g. 4 stands for 16s and 17 means 131,072s.
        /// </value>
        public int Poll => Bytes[2];

        /// <summary>
        /// Gets the precision of server clock.
        /// </summary>
        /// <value>
        /// Clock precision in log2 seconds, e.g. -20 for microsecond precision.
        /// </value>
        public int Precision => (sbyte)Bytes[3];

        /// <summary>
        /// Gets the total round-trip delay from the server to the reference clock.
        /// </summary>
        /// <value>
        /// Round-trip delay to the reference clock. Normally a positive value smaller than one second.
        /// </value>
        public TimeSpan RootDelay => GetTimeSpan32(4);

        /// <summary>
        /// Gets the estimated error in time reported by the server.
        /// </summary>
        /// <value>
        /// Estimated error in time reported by the server. Normally a positive value smaller than one second.
        /// </value>
        public TimeSpan RootDispersion => GetTimeSpan32(8);

        /// <summary>
        /// Gets the ID of the time source used by the server or Kiss-o'-Death code sent by the server.
        /// </summary>
        /// <value>
        /// <para>
        /// ID of server's time source or Kiss-o'-Death code.
        /// Purpose of this property depends on value of <see cref="NtpPacket.Stratum" /> property.
        /// </para>
        /// <para>
        /// Stratum 1 servers write here one of several special values that describe the kind of hardware clock they use.
        /// </para>
        /// <para>
        /// Stratum 2 and lower servers set this property to IPv4 address of their upstream server.
        /// If upstream server has IPv6 address, the address is hashed, because it doesn't fit in this property.
        /// </para>
        /// <para>
        /// When server sets <see cref="NtpPacket.Stratum" /> to special value 0,
        /// this property contains so called kiss code that instructs the client to stop querying the server.
        /// </para>
        /// </value>
        public uint ReferenceId => GetUInt32BE(12);

        /// <summary>
        /// Gets or sets the time when the server clock was last set or corrected.
        /// </summary>
        /// <value>
        /// Time when the server clock was last set or corrected or <c>null</c> when not specified.
        /// </value>
        /// <remarks>
        /// This Property is usually set only by servers. It usually lags server's current time by several minutes,
        /// so don't use this property for time synchronization.
        /// </remarks>
        public DateTime? ReferenceTimestamp => GetDateTime64(16);

        /// <summary>
        /// Gets or sets the time when the client sent its request.
        /// </summary>
        /// <value>
        /// This property is <c>null</c> in request packets.
        /// In reply packets, it is the time when the client sent its request.
        /// Servers copy this value from <see cref="NtpPacket.TransmitTimestamp" />
        /// that they find in received request packet.
        /// </value>
        /// <seealso cref="NtpPacket.CorrectionOffset" />
        /// <seealso cref="NtpPacket.RoundTripTime" />
        public DateTime? OriginTimestamp => GetDateTime64(24);

        /// <summary>
        /// Gets or sets the time when the request was received by the server.
        /// </summary>
        /// <value>
        /// This property is <c>null</c> in request packets.
        /// In reply packets, it is the time when the server received client request.
        /// </value>
        /// <seealso cref="NtpPacket.CorrectionOffset" />
        /// <seealso cref="NtpPacket.RoundTripTime" />
        public DateTime? ReceiveTimestamp => GetDateTime64(32);

        /// <summary>
        /// Gets or sets the time when the packet was sent.
        /// </summary>
        /// <value>
        /// Time when the packet was sent. It should never be <c>null</c>.
        /// Default value is <see cref="System.DateTime.UtcNow" />.
        /// </value>
        /// <remarks>
        /// This property must be set by both clients and servers.
        /// </remarks>
        /// <seealso cref="NtpPacket.CorrectionOffset" />
        /// <seealso cref="NtpPacket.RoundTripTime" />
        public DateTime? TransmitTimestamp { get { return GetDateTime64(40); } private set { SetDateTime64(40, value); } }

        /// <summary>
        /// Gets or sets the time of reception of response SNTP packet on the client.
        /// </summary>
        /// <value>
        /// Time of reception of response SNTP packet on the client. It is <c>null</c> in request packets.
        /// </value>
        /// <remarks>
        /// This property is not part of the protocol and has to be set when reply packet is received.
        /// </remarks>
        /// <seealso cref="NtpPacket.CorrectionOffset" />
        /// <seealso cref="NtpPacket.RoundTripTime" />
        public DateTime? DestinationTimestamp { get; private set; }

        /// <summary>
        /// Gets the round-trip time to the server.
        /// </summary>
        /// <value>
        /// Time the request spent traveling to the server plus the time the reply spent traveling back.
        /// This is calculated from timestamps in the packet as <c>(t1 - t0) + (t3 - t2)</c>
        /// where t0 is <see cref="NtpPacket.OriginTimestamp" />,
        /// t1 is <see cref="NtpPacket.ReceiveTimestamp" />,
        /// t2 is <see cref="NtpPacket.TransmitTimestamp" />,
        /// and t3 is <see cref="NtpPacket.DestinationTimestamp" />.
        /// This property throws an exception in request packets.
        /// </value>
        public TimeSpan RoundTripTime
        {
            get
            {
                CheckTimestamps();
                return (ReceiveTimestamp.Value - OriginTimestamp.Value) + (DestinationTimestamp.Value - TransmitTimestamp.Value);
            }
        }

        /// <summary>
        /// Gets the offset that should be added to local time to synchronize it with server time.
        /// </summary>
        /// <value>
        /// Time difference between server and client. It should be added to local time to get server time.
        /// It is calculated from timestamps in the packet as <c>0.5 * ((t1 - t0) - (t3 - t2))</c>
        /// where t0 is <see cref="NtpPacket.OriginTimestamp" />,
        /// t1 is <see cref="NtpPacket.ReceiveTimestamp" />,
        /// t2 is <see cref="NtpPacket.TransmitTimestamp" />,
        /// and t3 is <see cref="NtpPacket.DestinationTimestamp" />.
        /// This property throws an exception in request packets.
        /// </value>
        public TimeSpan CorrectionOffset
        {
            get
            {
                CheckTimestamps();
                return TimeSpan.FromTicks(((ReceiveTimestamp.Value - OriginTimestamp.Value) - (DestinationTimestamp.Value - TransmitTimestamp.Value)).Ticks / 2);
            }
        }

        /// <summary>
        /// Initializes default request packet.
        /// </summary>
        /// <remarks>
        /// Properties <see cref="NtpPacket.Mode" /> and <see cref="NtpPacket.VersionNumber" />
        /// are set appropriately for request packet. Property <see cref="NtpPacket.TransmitTimestamp" />
        /// is set to <see cref="System.DateTime.UtcNow" />.
        /// </remarks>
        public NtpPacket() : this(new byte[48])
        {
            Mode = NtpMode.Client;
            VersionNumber = 4;
            TransmitTimestamp = DateTime.UtcNow;
        }

        /// <summary>
        /// Initializes packet from received data.
        /// </summary>
        internal NtpPacket(byte[] bytes)
        {
            if (bytes.Length < 48)
                throw new ArgumentException("SNTP reply packet must be at least 48 bytes long.", "bytes");
            Bytes = bytes;
        }

        /// <summary>
        /// Initializes packet from data received from a server.
        /// </summary>
        /// <param name="bytes">Data received from the server.</param>
        /// <param name="destinationTimestamp">Utc time of reception of response SNTP packet on the client.</param>
        /// <returns></returns>
        public static NtpPacket FromServerResponse(byte[] bytes, DateTime destinationTimestamp)
        {
            return new NtpPacket(bytes) { DestinationTimestamp = destinationTimestamp };
        }

        internal void ValidateRequest()
        {
            if (Mode != NtpMode.Client)
                throw new InvalidOperationException("This is not a request SNTP packet.");
            if (VersionNumber == 0)
                throw new InvalidOperationException("Protocol version of the request is not specified.");
            if (TransmitTimestamp == null)
                throw new InvalidOperationException("TransmitTimestamp must be set in request packet.");
        }

        internal void ValidateReply()
        {
            if (Mode != NtpMode.Server)
                throw new InvalidOperationException("This is not a reply SNTP packet.");
            if (VersionNumber == 0)
                throw new InvalidOperationException("Protocol version of the reply is not specified.");
            if (Stratum == 0)
                throw new InvalidOperationException(string.Format("Received Kiss-o'-Death SNTP packet with code 0x{0:x}.", ReferenceId));
            if (LeapIndicator == NtpLeapIndicator.AlarmCondition)
                throw new InvalidOperationException("SNTP server has unsynchronized clock.");
            CheckTimestamps();
        }

        private void CheckTimestamps()
        {
            if (OriginTimestamp == null)
                throw new InvalidOperationException("Origin timestamp is missing.");
            if (ReceiveTimestamp == null)
                throw new InvalidOperationException("Receive timestamp is missing.");
            if (TransmitTimestamp == null)
                throw new InvalidOperationException("Transmit timestamp is missing.");
            if (DestinationTimestamp == null)
                throw new InvalidOperationException("Destination timestamp is missing.");
        }

        private DateTime? GetDateTime64(int offset)
        {
            var field = GetUInt64BE(offset);
            if (field == 0)
                return null;
            return new DateTime(Epoch.Ticks + Convert.ToInt64(field * (1.0 / (1L << 32) * 10000000.0)));
        }

        private void SetDateTime64(int offset, DateTime? value)
        {
            SetUInt64BE(offset, value == null ? 0 : Convert.ToUInt64((value.Value.Ticks - Epoch.Ticks) * (0.0000001 * (1L << 32))));
        }

        private TimeSpan GetTimeSpan32(int offset)
        {
            return TimeSpan.FromSeconds(GetInt32BE(offset) / (double)(1 << 16));
        }

        private ulong GetUInt64BE(int offset)
        {
            return SwapEndianness(BitConverter.ToUInt64(Bytes, offset));
        }

        private void SetUInt64BE(int offset, ulong value)
        {
            FastBitConverter.GetBytes(Bytes, offset, SwapEndianness(value));
        }

        private int GetInt32BE(int offset)
        {
            return (int)GetUInt32BE(offset);
        }

        private uint GetUInt32BE(int offset)
        {
            return SwapEndianness(BitConverter.ToUInt32(Bytes, offset));
        }

        private static uint SwapEndianness(uint x)
        {
            return ((x & 0xff) << 24) | ((x & 0xff00) << 8) | ((x & 0xff0000) >> 8) | ((x & 0xff000000) >> 24);
        }

        private static ulong SwapEndianness(ulong x)
        {
            return ((ulong)SwapEndianness((uint)x) << 32) | SwapEndianness((uint)(x >> 32));
        }
    }

    /// <summary>
    /// Represents leap second warning from the server that instructs the client to add or remove leap second.
    /// </summary>
    /// <seealso cref="NtpPacket.LeapIndicator" />
    public enum NtpLeapIndicator
    {
        /// <summary>
        /// No leap second warning. No action required.
        /// </summary>
        NoWarning,

        /// <summary>
        /// Warns the client that the last minute of the current day has 61 seconds.
        /// </summary>
        LastMinuteHas61Seconds,

        /// <summary>
        /// Warns the client that the last minute of the current day has 59 seconds.
        /// </summary>
        LastMinuteHas59Seconds,

        /// <summary>
        /// Special value indicating that the server clock is unsynchronized and the returned time is unreliable.
        /// </summary>
        AlarmCondition
    }

    /// <summary>
    /// Describes SNTP packet mode, i.e. client or server.
    /// </summary>
    /// <seealso cref="NtpPacket.Mode" />
    public enum NtpMode
    {
        /// <summary>
        /// Identifies client-to-server SNTP packet.
        /// </summary>
        Client = 3,

        /// <summary>
        /// Identifies server-to-client SNTP packet.
        /// </summary>
        Server = 4,
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/LiteNetLib/Utils/NtpRequest.cs ---
﻿using System.Net;
using System.Net.Sockets;

namespace LiteNetLib.Utils
{
    internal sealed class NtpRequest
    {
        private const int ResendTimer = 1000;
        private const int KillTimer = 10000;
        public const int DefaultPort = 123;
        private readonly IPEndPoint _ntpEndPoint;
        private int _resendTime = ResendTimer;
        private int _killTime = 0;

        public NtpRequest(IPEndPoint endPoint)
        {
            _ntpEndPoint = endPoint;
        }

        public bool NeedToKill => _killTime >= KillTimer;

        public bool Send(Socket socket, int time)
        {
            _resendTime += time;
            _killTime += time;
            if (_resendTime < ResendTimer)
            {
                return false;
            }
            var packet = new NtpPacket();
            try
            {
                int sendCount = socket.SendTo(packet.Bytes, 0, packet.Bytes.Length, SocketFlags.None, _ntpEndPoint);
                return sendCount == packet.Bytes.Length;
            }
            catch
            {
                return false;
            }
        }
    }
}

'''
'''--- Assets/FishNet/Runtime/Transporting/Transports/Tugboat/Tugboat.cs ---
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using LiteNetLib;
using LiteNetLib.Layers;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Transporting.Tugboat
{
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Transport/Tugboat")]
    public class Tugboat : Transport
    {

        #region Serialized.
        [Header("Channels")]
        /// <summary>
        /// Maximum transmission unit for the unreliable channel.
        /// </summary>
        [Tooltip("Maximum transmission unit for the unreliable channel.")]
        [Range(MINIMUM_UDP_MTU, MAXIMUM_UDP_MTU)]
        [SerializeField]
        private int _unreliableMTU = 1023;

        [Header("Server")]
        /// <summary>
        /// IPv4 address to bind server to.
        /// </summary>
        [Tooltip("IPv4 Address to bind server to.")]
        [SerializeField]
        private string _ipv4BindAddress;
        /// <summary>
        /// IPv6 address to bind server to.
        /// </summary>
        [Tooltip("IPv6 Address to bind server to.")]
        [SerializeField]
        private string _ipv6BindAddress;
        /// <summary>
        /// Port to use.
        /// </summary>
        [Tooltip("Port to use.")]
        [SerializeField]
        private ushort _port = 7770;
        /// <summary>
        /// Maximum number of players which may be connected at once.
        /// </summary>
        [Tooltip("Maximum number of players which may be connected at once.")]
        [Range(1, 9999)]
        [SerializeField]
        private int _maximumClients = 4095;

        [Header("Client")]
        /// <summary>
        /// Address to connect.
        /// </summary>
        [Tooltip("Address to connect.")]
        [SerializeField]
        private string _clientAddress = "localhost";

        [Header("Misc")]
        /// <summary>
        /// How long in seconds until either the server or client socket must go without data before being timed out. Use 0f to disable timing out.
        /// </summary>
        [Tooltip("How long in seconds until either the server or client socket must go without data before being timed out. Use 0f to disable timing out.")]
        [Range(0, MAX_TIMEOUT_SECONDS)]
        [SerializeField]
        private ushort _timeout = 15;
        #endregion

        #region Private.
        /// <summary>
        /// PacketLayer to use with LiteNetLib.
        /// </summary>
        private PacketLayerBase _packetLayer;
        /// <summary>
        /// Server socket and handler.
        /// </summary>
        private Server.ServerSocket _server = new Server.ServerSocket();
        /// <summary>
        /// Client socket and handler.
        /// </summary>
        private Client.ClientSocket _client = new Client.ClientSocket();
        #endregion

        #region Const.
        private const ushort MAX_TIMEOUT_SECONDS = 1800;
        /// <summary>
        /// Minimum UDP packet size allowed.
        /// </summary>
        private const int MINIMUM_UDP_MTU = 576;
        /// <summary>
        /// Maximum UDP packet size allowed.
        /// </summary>
        private const int MAXIMUM_UDP_MTU = 1023;
        #endregion

        #region Initialization and unity.
        public override void Initialize(NetworkManager networkManager, int transportIndex)
        {
            base.Initialize(networkManager, transportIndex);
        }

        protected void OnDestroy()
        {
            Shutdown();
        }
        #endregion

        #region ConnectionStates.
        /// <summary>
        /// Gets the address of a remote connection Id.
        /// </summary>
        /// <param name="connectionId"></param>
        /// <returns></returns>
        public override string GetConnectionAddress(int connectionId)
        {
            return _server.GetConnectionAddress(connectionId);
        }
        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        public override event Action<ClientConnectionStateArgs> OnClientConnectionState;
        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        public override event Action<ServerConnectionStateArgs> OnServerConnectionState;
        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        public override event Action<RemoteConnectionStateArgs> OnRemoteConnectionState;
        /// <summary>
        /// Gets the current local ConnectionState.
        /// </summary>
        /// <param name="server">True if getting ConnectionState for the server.</param>
        public override LocalConnectionState GetConnectionState(bool server)
        {
            if (server)
                return _server.GetConnectionState();
            else
                return _client.GetConnectionState();
        }
        /// <summary>
        /// Gets the current ConnectionState of a remote client on the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        public override RemoteConnectionState GetConnectionState(int connectionId)
        {
            return _server.GetConnectionState(connectionId);
        }
        /// <summary>
        /// Handles a ConnectionStateArgs for the local client.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        public override void HandleClientConnectionState(ClientConnectionStateArgs connectionStateArgs)
        {
            OnClientConnectionState?.Invoke(connectionStateArgs);
        }
        /// <summary>
        /// Handles a ConnectionStateArgs for the local server.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        public override void HandleServerConnectionState(ServerConnectionStateArgs connectionStateArgs)
        {
            OnServerConnectionState?.Invoke(connectionStateArgs);
            UpdateTimeout();
        }
        /// <summary>
        /// Handles a ConnectionStateArgs for a remote client.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        public override void HandleRemoteConnectionState(RemoteConnectionStateArgs connectionStateArgs)
        {
            OnRemoteConnectionState?.Invoke(connectionStateArgs);
        }
        #endregion

        #region Iterating.
        /// <summary>
        /// Processes data received by the socket.
        /// </summary>
        /// <param name="server">True to process data received on the server.</param>
        public override void IterateIncoming(bool server)
        {
            if (server)
                _server.IterateIncoming();
            else
                _client.IterateIncoming();
        }

        /// <summary>
        /// Processes data to be sent by the socket.
        /// </summary>
        /// <param name="server">True to process data received on the server.</param>
        public override void IterateOutgoing(bool server)
        {
            if (server)
                _server.IterateOutgoing();
            else
                _client.IterateOutgoing();
        }
        #endregion

        #region ReceivedData.
        /// <summary>
        /// Called when client receives data.
        /// </summary>
        public override event Action<ClientReceivedDataArgs> OnClientReceivedData;
        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs"></param>
        public override void HandleClientReceivedDataArgs(ClientReceivedDataArgs receivedDataArgs)
        {
            OnClientReceivedData?.Invoke(receivedDataArgs);
        }
        /// <summary>
        /// Called when server receives data.
        /// </summary>
        public override event Action<ServerReceivedDataArgs> OnServerReceivedData;
        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs"></param>
        public override void HandleServerReceivedDataArgs(ServerReceivedDataArgs receivedDataArgs)
        {
            OnServerReceivedData?.Invoke(receivedDataArgs);
        }
        #endregion

        #region Sending.
        /// <summary>
        /// Sends to the server or all clients.
        /// </summary>
        /// <param name="channelId">Channel to use.</param>
        /// <param name="segment">Data to send.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override void SendToServer(byte channelId, ArraySegment<byte> segment)
        {
            SanitizeChannel(ref channelId);
            _client.SendToServer(channelId, segment);
        }
        /// <summary>
        /// Sends data to a client.
        /// </summary>
        /// <param name="channelId"></param>
        /// <param name="segment"></param>
        /// <param name="connectionId"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override void SendToClient(byte channelId, ArraySegment<byte> segment, int connectionId)
        {
            SanitizeChannel(ref channelId);
            _server.SendToClient(channelId, segment, connectionId);
        }
        #endregion

        #region Configuration.
        /// <summary>
        /// Sets which PacketLayer to use with LiteNetLib.
        /// </summary>
        /// <param name="packetLayer"></param>
        public void SetPacketLayer(PacketLayerBase packetLayer)
        {
            _packetLayer = packetLayer;
            if (GetConnectionState(true) != LocalConnectionState.Stopped)
                base.NetworkManager.LogWarning("PacketLayer is set but will not be applied until the server stops.");
            if (GetConnectionState(false) != LocalConnectionState.Stopped)
                base.NetworkManager.LogWarning("PacketLayer is set but will not be applied until the client stops.");

            _server.Initialize(this, _unreliableMTU, _packetLayer);
            _client.Initialize(this, _unreliableMTU, _packetLayer);
        }
        /// <summary>
        /// How long in seconds until either the server or client socket must go without data before being timed out.
        /// </summary>
        /// <param name="asServer">True to get the timeout for the server socket, false for the client socket.</param>
        /// <returns></returns>
        public override float GetTimeout(bool asServer)
        {
            //Server and client uses the same timeout.
            return (float)_timeout;
        }
        /// <summary>
        /// Sets how long in seconds until either the server or client socket must go without data before being timed out.
        /// </summary>
        /// <param name="asServer">True to set the timeout for the server socket, false for the client socket.</param>
        public override void SetTimeout(float value, bool asServer)
        {
            _timeout = (ushort)value;
        }
        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// </summary>
        /// <returns></returns>
        public override int GetMaximumClients()
        {
            return _server.GetMaximumClients();
        }
        /// <summary>
        /// Sets maximum number of clients allowed to connect to the server. If applied at runtime and clients exceed this value existing clients will stay connected but new clients may not connect.
        /// </summary>
        /// <param name="value"></param>
        public override void SetMaximumClients(int value)
        {
            if (_server.GetConnectionState() != LocalConnectionState.Stopped)
            {
                if (base.NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Cannot set maximum clients when server is running.");
            }
            else
            {
                _maximumClients = value;
            }
        }
        /// <summary>
        /// Sets which address the client will connect to.
        /// </summary>
        /// <param name="address"></param>
        public override void SetClientAddress(string address)
        {
            _clientAddress = address;
        }
        /// <summary>
        /// Gets which address the client will connect to.
        /// </summary>
        public override string GetClientAddress()
        {
            return _clientAddress;
        }

        /// <summary>
        /// Sets which address the server will bind to.
        /// </summary>
        /// <param name="address"></param>
        public override void SetServerBindAddress(string address, IPAddressType addressType)
        {
            if (addressType == IPAddressType.IPv4)
                _ipv4BindAddress = address;
            else
                _ipv6BindAddress = address;
        }
        /// <summary>
        /// Gets which address the server will bind to.
        /// </summary>
        /// <param name="address"></param>
        public override string GetServerBindAddress(IPAddressType addressType)
        {
            if (addressType == IPAddressType.IPv4)
                return _ipv4BindAddress;
            else
                return _ipv6BindAddress;
        }
        /// <summary>
        /// Sets which port to use.
        /// </summary>
        /// <param name="port"></param>
        public override void SetPort(ushort port)
        {
            _port = port;
        }
        /// <summary>
        /// Gets which port to use.
        /// </summary>
        /// <param name="port"></param>
        public override ushort GetPort()
        {
            return _port;
        }
        #endregion

        #region Start and stop.
        /// <summary>
        /// Starts the local server or client using configured settings.
        /// </summary>
        /// <param name="server">True to start server.</param>
        public override bool StartConnection(bool server)
        {
            if (server)
                return StartServer();
            else
                return StartClient(_clientAddress);
        }

        /// <summary>
        /// Stops the local server or client.
        /// </summary>
        /// <param name="server">True to stop server.</param>
        public override bool StopConnection(bool server)
        {
            if (server)
                return StopServer();
            else
                return StopClient();
        }

        /// <summary>
        /// Stops a remote client from the server, disconnecting the client.
        /// </summary>
        /// <param name="connectionId">ConnectionId of the client to disconnect.</param>
        /// <param name="immediately">True to abrutly stop the client socket. The technique used to accomplish immediate disconnects may vary depending on the transport.
        /// When not using immediate disconnects it's recommended to perform disconnects using the ServerManager rather than accessing the transport directly.
        /// </param>
        public override bool StopConnection(int connectionId, bool immediately)
        {
            return _server.StopConnection(connectionId);
        }

        /// <summary>
        /// Stops both client and server.
        /// </summary>
        public override void Shutdown()
        {
            //Stops client then server connections.
            StopConnection(false);
            StopConnection(true);
        }

        #region Privates.
        /// <summary>
        /// Starts server.
        /// </summary>
        private bool StartServer()
        {
            _server.Initialize(this, _unreliableMTU, _packetLayer);
            UpdateTimeout();
            return _server.StartConnection(_port, _maximumClients, _ipv4BindAddress, _ipv6BindAddress);
        }

        /// <summary>
        /// Stops server.
        /// </summary>
        private bool StopServer()
        {
            return _server.StopConnection();
        }

        /// <summary>
        /// Starts the client.
        /// </summary>
        /// <param name="address"></param>
        private bool StartClient(string address)
        {
            _client.Initialize(this, _unreliableMTU, _packetLayer);
            UpdateTimeout();
            return _client.StartConnection(address, _port);
        }

        /// <summary>
        /// Updates clients timeout values.
        /// </summary>
        private void UpdateTimeout()
        {
            //If server is running set timeout to max. This is for host only.
            //int timeout = (GetConnectionState(true) != LocalConnectionState.Stopped) ? MAX_TIMEOUT_SECONDS : _timeout;
            int timeout = (Application.isEditor) ? MAX_TIMEOUT_SECONDS : _timeout;
            _client.UpdateTimeout(timeout);
            _server.UpdateTimeout(timeout);
        }
        /// <summary>
        /// Stops the client.
        /// </summary>
        private bool StopClient()
        {
            return _client.StopConnection();
        }
        #endregion
        #endregion

        #region Channels.
        /// <summary>
        /// If channelId is invalid then channelId becomes forced to reliable.
        /// </summary>
        /// <param name="channelId"></param>
        private void SanitizeChannel(ref byte channelId)
        {
            if (channelId < 0 || channelId >= TransportManager.CHANNEL_COUNT)
            {
                if (NetworkManager.CanLog(LoggingType.Warning))
                    Debug.LogWarning($"Channel of {channelId} is out of range of supported channels. Channel will be defaulted to reliable.");
                channelId = 0;
            }
        }
        /// <summary>
        /// Gets the MTU for a channel. This should take header size into consideration.
        /// For example, if MTU is 1200 and a packet header for this channel is 10 in size, this method should return 1190.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        public override int GetMTU(byte channel)
        {
            return _unreliableMTU;
        }
        #endregion

        #region Editor.
#if UNITY_EDITOR
        private void OnValidate()
        {
            if (_unreliableMTU < 0)
                _unreliableMTU = MINIMUM_UDP_MTU;
            else if (_unreliableMTU > MAXIMUM_UDP_MTU)
                _unreliableMTU = MAXIMUM_UDP_MTU;
        }
#endif
        #endregion
    }
}

'''
'''--- Assets/FishNet/Runtime/Utility/ApplicationState.cs ---
﻿using FishNet.Utility.Constant;
using System.Runtime.CompilerServices;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FishNet.Utility
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    public static class ApplicationState
    {

#if !UNITY_EDITOR
        /// <summary>
        /// True if application is quitting.
        /// </summary>
        private static bool _isQuitting;
#endif
        static ApplicationState()
        {
#if !UNITY_EDITOR
            _isQuitting = false;
#endif
            Application.quitting -= Application_quitting;
            Application.quitting += Application_quitting;
        }

        private static void Application_quitting()
        {
#if !UNITY_EDITOR
            _isQuitting = true;
#endif
        }

        public static bool IsQuitting()
        {
#if UNITY_EDITOR
            if (!EditorApplication.isPlayingOrWillChangePlaymode && EditorApplication.isPlaying)
                return true;
            else
                return false;
#else
            return _isQuitting;
#endif
        }

        public static bool IsPlaying()
        {
#if UNITY_EDITOR
            return EditorApplication.isPlaying;
#else
            return Application.isPlaying;
#endif
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Constants.cs ---
﻿namespace FishNet.Utility.Constant
{
    internal static class UtilityConstants
    {
        public const string CODEGEN_ASSEMBLY_NAME = "Unity.FishNet.CodeGen";
        public const string GENERATED_ASSEMBLY_NAME = "FishNet.Generated";
        public const string TEST_ASSEMBLY_NAME = "FishNet.Test";
        public const string RUNTIME_ASSEMBLY_NAME = "FishNet.Runtime";
    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/DDOLFinder.cs ---
﻿using UnityEngine;

namespace FishNet.Utility
{

    public class DDOLFinder : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Singleton instance of this class.
        /// </summary>
        public static DDOLFinder Instance { get; private set; }
        #endregion

        private void Awake()
        {
            FirstInitialize();
        }

        /// <summary>
        /// Initializes this script for use. Should only be completed once.
        /// </summary>
        private void FirstInitialize()
        {
            if (Instance != null && Instance != this)
            {
                Debug.LogError("Multiple DDOL scripts found. There should be only one.");
                return;
            }
            else
            {
                Instance = this;
                gameObject.name = "DDOLFinder";
                DontDestroyOnLoad(gameObject);
            }
        }

        /// <summary>
        /// Returns the current DDOL or creates one if not yet created.
        /// </summary>
        public static DDOLFinder GetDDOL()
        {
            //Not yet made.
            if (Instance == null)
            {
                GameObject obj = new GameObject();
                DDOLFinder ddol = obj.AddComponent<DDOLFinder>();
                return ddol;
            }
            //Already  made.
            else
            {
                return Instance;
            }
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Editor/MiscMenu.cs ---
﻿//remove on 2023/01/01
'''
'''--- Assets/FishNet/Runtime/Utility/Editor/SceneDrawer.cs ---
﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Utility.Editing
{
    /* Source https://forum.unity.com/threads/how-to-link-scenes-in-the-inspector.383140/ */

    [CustomPropertyDrawer(typeof(SceneAttribute))]
    public class SceneDrawer : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            if (property.propertyType == SerializedPropertyType.String)
            {
                SceneAsset sceneObject = AssetDatabase.LoadAssetAtPath<SceneAsset>(property.stringValue);

                if (sceneObject == null && !string.IsNullOrEmpty(property.stringValue))
                {
                    // try to load it from the build settings for legacy compatibility
                    sceneObject = GetBuildSettingsSceneObject(property.stringValue);
                }
                if (sceneObject == null && !string.IsNullOrEmpty(property.stringValue))
                {
                    Debug.Log($"Could not find scene {property.stringValue} in {property.propertyPath}, assign the proper scenes in your NetworkManager");
                }
                SceneAsset scene = (SceneAsset)EditorGUI.ObjectField(position, label, sceneObject, typeof(SceneAsset), true);

                property.stringValue = AssetDatabase.GetAssetPath(scene);
            }
            else
            {
                EditorGUI.LabelField(position, label.text, "Use [Scene] with strings.");
            }
        }

        protected SceneAsset GetBuildSettingsSceneObject(string sceneName)
        {
            foreach (EditorBuildSettingsScene buildScene in EditorBuildSettings.scenes)
            {
                SceneAsset sceneAsset = AssetDatabase.LoadAssetAtPath<SceneAsset>(buildScene.path);
                if (sceneAsset != null && sceneAsset.name == sceneName)
                {
                    return sceneAsset;
                }
            }
            return null;
        }
    }
}
#endif
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Collection.cs ---
﻿using System;
using System.Collections.Generic;

namespace FishNet.Utility.Extension
{
    public static class CollectionFN
    {
        /// <summary>
        /// Random for shuffling.
        /// </summary>
        private static Random _random = new Random();

        /// <summary>
        /// Shuffle based on Fisher-Yates shuffle.
        /// https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
        /// https://stackoverflow.com/questions/273313/randomize-a-listt
        /// </summary>
        public static void Shuffle<T>(this IList<T> lst)
        {
            int n = lst.Count;
            while (n > 1)
            {
                n--;
                int k = _random.Next(n + 1);
                T value = lst[k];
                lst[k] = lst[n];
                lst[n] = value;
            }
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Dictionary.cs ---
﻿using FishNet.Documenting;
using System.Collections.Generic;

namespace FishNet.Utility.Extension
{
    [APIExclude]
    public static class DictionaryFN
    {

        /// <summary>
        /// Uses a hacky way to TryGetValue on a dictionary when using IL2CPP and on mobile.
        /// This is to support older devices that don't properly handle IL2CPP builds.
        /// </summary>
        public static bool TryGetValueIL2CPP<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key, out TValue value)
        {
#if ENABLE_IL2CPP && UNITY_IOS || UNITY_ANDROID
            if (dict.ContainsKey(key))
            {
                value = dict[key];
                return true;
            }
            else
            {
                value = default;
                return false;
            }
#else
            return dict.TryGetValue(key, out value);
#endif
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Enum.cs ---
﻿using System;

namespace FishNet.Utility.Extension
{
    public static class EnumFN
    {

        /// <summary>
        /// Returns the highest numeric value for T.
        /// </summary>
        internal static int GetHighestValue<T>()
        {
            Type enumType = typeof(T);
            /* Brute force enum values. 
             * Linq Last/Max lookup throws for IL2CPP. */
            int highestValue = 0;
            Array pidValues = Enum.GetValues(enumType);
            foreach (T pid in pidValues)
            {
                object obj = Enum.Parse(enumType, pid.ToString());
                int value = Convert.ToInt32(obj);
                highestValue = Math.Max(highestValue, value);
            }

            return highestValue;
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Math.cs ---
﻿namespace FishNet.Utility.Extension
{

    public static class MathFN
    {

        /// <summary>
        /// Returns a clamped SBytte.
        /// </summary>
        public static sbyte ClampSByte(long value, sbyte min, sbyte max)
        {
            if (value < min)
                return min;
            else if (value > max)
                return max;
            else
                return (sbyte)value;
        }

        /// <summary>
        /// Returns a clamped double.
        /// </summary>
        public static double ClampDouble(double value, double min, double max)
        {
            if (value < min)
                return min;
            else if (value > max)
                return max;
            else
                return value;
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Object.cs ---
﻿using FishNet.Connection;
using FishNet.Object;
using UnityEngine;

namespace FishNet.Utility.Extension
{

    public static class ObjectFN
    {
        /// <summary>
        /// Spawns an object over the network using InstanceFinder. Only call from the server.
        /// </summary>
        public static void Spawn(this NetworkObject nob, NetworkConnection owner = null)
        {
            InstanceFinder.ServerManager.Spawn(nob, owner);
        }
        /// <summary>
        /// Spawns an object over the network using InstanceFinder. Only call from the server.
        /// </summary>
        public static void Spawn(this GameObject go, NetworkConnection owner = null)
        {
            InstanceFinder.ServerManager.Spawn(go, owner);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Quaternion.cs ---
﻿using FishNet.Documenting;
using UnityEngine;

namespace FishNet.Utility.Extension
{
    [APIExclude]
    public static class QuaterionFN
    {

        /// <summary>
        /// Returns if two quaternions match.
        /// </summary>
        /// <param name="precise">True to use a custom implementation with no error tolerance. False to use Unity's implementation which may return a match even when not true due to error tolerance.</param>
        /// <returns></returns>
        public static bool Matches(this Quaternion a, Quaternion b, bool precise = false)
        {
            if (precise)
                return (a.w == b.w && a.x == b.x && a.y == b.y && a.z == b.z);
            else
                return (a == b);
        }

        /// <summary>
        /// Returns the angle between two quaterions.
        /// </summary>
        /// <param name="precise">True to use a custom implementation with no error tolerance. False to use Unity's implementation which may return 0f due to error tolerance, even while there is a difference.</param>
        /// <returns></returns>
        public static float Angle(this Quaternion a, Quaternion b, bool precise = false)
        {
            if (precise)
            {
                //This is run Unitys implementation without the error tolerance.
                float dot = (a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
                return (Mathf.Acos(Mathf.Min(Mathf.Abs(dot), 1f)) * 2f * 57.29578f);
            }
            else
            {
                return Quaternion.Angle(a, b);
            }
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Scene.cs ---
﻿using FishNet.Object;
using FishNet.Utility.Performance;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Utility.Extension
{

    public static class SceneFN
    {
        #region Private.

        /// <summary>
        /// Used for performance gains when getting objects.
        /// </summary>
        private static List<GameObject> _gameObjectList = new List<GameObject>();
        /// <summary>
        /// List for NetworkObjects.
        /// </summary>
        private static List<NetworkObject> _networkObjectListA = new List<NetworkObject>();
        /// <summary>
        /// List for NetworkObjects.
        /// </summary>
        private static List<NetworkObject> _networkObjectListB = new List<NetworkObject>();
        #endregion

        /// <summary>
        /// Gets all NetworkObjects in a scene.
        /// </summary>
        /// <param name="s">Scene to get objects in.</param>
        /// <param name="firstOnly">True to only return the first NetworkObject within an object chain. False will return nested NetworkObjects.</param>
        /// <param name="cache">ListCache of found NetworkObjects.</param>
        /// <returns></returns>
        public static void GetSceneNetworkObjects(Scene s, bool firstOnly, out ListCache<NetworkObject> nobCache)
        {
            nobCache = ListCaches.GetNetworkObjectCache();
            //Iterate all root objects for the scene.
            s.GetRootGameObjects(_gameObjectList);
            foreach (GameObject go in _gameObjectList)
            {

                //Get NetworkObjects within children of each root.
                go.GetComponentsInChildren<NetworkObject>(true, _networkObjectListA);
                //If network objects are found.
                if (_networkObjectListA.Count > 0)
                {
                    //Add only the first networkobject 
                    if (firstOnly)
                    {
                        /* The easiest way to see if a nob is nested is to
                         * get nobs in parent and if the count is greater than 1, then
                         * it is nested. The technique used here isn't exactly fast but
                         * it will only occur during scene loads, so I'm trading off speed
                         * for effort and readability. */
                        foreach (NetworkObject nob in _networkObjectListA)
                        {
                            nob.GetComponentsInParent<NetworkObject>(true, _networkObjectListB);
                            //No extra nobs, only this one.
                            if (_networkObjectListB.Count == 1)
                                nobCache.AddValue(nob);
                        }
                    }
                    //Not first only, add them all.
                    else
                    {
                        nobCache.AddValues(_networkObjectListA);
                    }

                }
            }
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Transform.cs ---
﻿//This file is no longer needed.
//Remove on 2023/01/01.
'''
'''--- Assets/FishNet/Runtime/Utility/Extension/Transforms.cs ---
﻿using FishNet.Documenting;
using UnityEngine;

namespace FishNet.Utility.Extension
{
    [APIExclude]
    public static class TransformFN
    {

        /// <summary>
        /// Sets local position and rotation for a transform.
        /// </summary>
        public static void SetLocalPositionAndRotation(this Transform t, Vector3 pos, Quaternion rot)
        {
            t.localPosition = pos;
            t.localRotation = rot;
        }
        /// <summary>
        /// Sets local position, rotation, and scale for a transform.
        /// </summary>
        public static void SetLocalPositionRotationAndScale(this Transform t, Vector3 pos, Quaternion rot, Vector3 scale)
        {
            t.localPosition = pos;
            t.localRotation = rot;
            t.localScale = scale;
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Performance/ByteArrayPool.cs ---
﻿using System;
using System.Collections.Generic;

namespace FishNet.Utility.Performance
{

    /// <summary>
    /// Retrieves and stores byte arrays using a pooling system.
    /// </summary>
    public static class ByteArrayPool
    {
        /// <summary>
        /// Stored byte arrays.
        /// </summary>
        private static Queue<byte[]> _byteArrays = new Queue<byte[]>();

        /// <summary>
        /// Returns a byte array which will be of at lesat minimum length. The returns array must manually be stored.
        /// </summary>
        public static byte[] Retrieve(int minimumLength)
        {
            byte[] result = null;

            if (_byteArrays.Count > 0)
                result = _byteArrays.Dequeue();

            int doubleMinimumLength = (minimumLength * 2);
            if (result == null)
                result = new byte[doubleMinimumLength];
            else if (result.Length < minimumLength)
                Array.Resize(ref result, doubleMinimumLength);

            return result;
        }

        /// <summary>
        /// Stores a byte array for re-use.
        /// </summary>
        public static void Store(byte[] buffer)
        {
            /* Holy cow that's a lot of buffered
             * buffers. This wouldn't happen under normal
             * circumstances but if the user is stress
             * testing connections in one executable perhaps. */
            if (_byteArrays.Count > 300)
                return;
            _byteArrays.Enqueue(buffer);
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Performance/DefaultObjectPool.cs ---
using FishNet.Object;
using FishNet.Utility.Extension;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Utility.Performance
{

    public class DefaultObjectPool : ObjectPool
    {
        #region Serialized.
        /// <summary>
        /// True if to use object pooling.
        /// </summary>
        [Tooltip("True if to use object pooling.")]
        [SerializeField]
        private bool _enabled = true;
        #endregion

        #region Private.
        /// <summary>
        /// Pooled network objects.
        /// </summary>
        private Dictionary<int, Stack<NetworkObject>> _cached = new Dictionary<int, Stack<NetworkObject>>();
        #endregion

        /// <summary>
        /// Returns an object that has been stored. A new object will be created if no stored objects are available.
        /// </summary>
        /// <param name="prefabId">PrefabId of the object to return.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public override NetworkObject RetrieveObject(int prefabId, bool asServer)
        {
            //Quick exit/normal retrieval when not using pooling.
            if (!_enabled)
            {
                NetworkObject prefab = base.NetworkManager.SpawnablePrefabs.GetObject(asServer, prefabId);
                return Instantiate(prefab);
            }

            Stack<NetworkObject> cache;
            //No cache for prefabId yet, make one.
            if (!_cached.TryGetValueIL2CPP(prefabId, out cache))
            {
                cache = new Stack<NetworkObject>();
                _cached[prefabId] = cache;
            }

            NetworkObject nob;
            //Iterate until nob is populated just in case cache entries have been destroyed.
            do
            {
                if (cache.Count == 0)
                {
                    NetworkObject prefab = base.NetworkManager.SpawnablePrefabs.GetObject(asServer, prefabId);
                    /* A null nob should never be returned from spawnables. This means something
                     * else broke, likely unrelated to the object pool. */
                    nob = Instantiate(prefab);
                    //Can break instantly since we know nob is not null.
                    break;
                }
                else
                {
                    nob = cache.Pop();
                }

            } while (nob == null);

            nob.gameObject.SetActive(true);
            return nob;
        }

        /// <summary>
        /// Stores an object into the pool.
        /// </summary>
        /// <param name="instantiated">Object to store.</param>
        /// <param name="prefabId">PrefabId of the object.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public override void StoreObject(NetworkObject instantiated, int prefabId, bool asServer)
        {
            //Pooling is not enabled.
            if (!_enabled)
            {
                Destroy(instantiated.gameObject);
                return;
            }

            Stack<NetworkObject> cache;
            if (!_cached.TryGetValue(prefabId, out cache))
            {
                cache = new Stack<NetworkObject>();
                _cached[prefabId] = cache;
            }

            instantiated.gameObject.SetActive(false);
            instantiated.ResetForObjectPool();
            cache.Push(instantiated);
        }
    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Performance/ListCache.cs ---
﻿using FishNet.Connection;
using FishNet.Object;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Utility.Performance
{
    /// <summary>
    /// Various ListCache instances that may be used on the Unity thread.
    /// </summary>
    public static class ListCaches
    {

        /// <summary>
        /// Cache collection for NetworkObjects.
        /// </summary>
        private static Stack<ListCache<NetworkObject>> _networkObjectCaches = new Stack<ListCache<NetworkObject>>();
        /// <summary>
        /// Cache for NetworkObjects.
        /// </summary>
        [Obsolete("Use GetNetworkObjectCache instead.")] //Remove on 2023/01/01
        public static ListCache<NetworkObject> NetworkObjectCache = new ListCache<NetworkObject>();
        /// <summary>
        /// Cache collection for NetworkObjects.
        /// </summary>
        private static Stack<ListCache<NetworkBehaviour>> _networkBehaviourCaches = new Stack<ListCache<NetworkBehaviour>>();
        /// <summary>
        /// Cache for NetworkBehaviours.
        /// </summary>
        [Obsolete("Use GetNetworkBehaviourCache instead.")] //Remove on 2023/01/01
        public static ListCache<NetworkBehaviour> NetworkBehaviourCache = new ListCache<NetworkBehaviour>();
        /// <summary>
        /// Cache collection for NetworkObjects.
        /// </summary>
        private static Stack<ListCache<Transform>> _transformCaches = new Stack<ListCache<Transform>>();
        /// <summary>
        /// Cache for Transforms.
        /// </summary>
        [Obsolete("Use GetTransformCache instead.")] //Remove on 2023/01/01
        public static ListCache<Transform> TransformCache = new ListCache<Transform>();
        /// <summary>
        /// Cache collection for NetworkConnections.
        /// </summary>
        private static Stack<ListCache<NetworkConnection>> _networkConnectionCaches = new Stack<ListCache<NetworkConnection>>();
        /// <summary>
        /// Cache for NetworkConnectios.
        /// </summary>
        [Obsolete("Use GetNetworkConnectionCache instead.")] //Remove on 2023/01/01
        public static ListCache<NetworkConnection> NetworkConnectionCache = new ListCache<NetworkConnection>();
        /// <summary>
        /// Cache for ints.
        /// </summary>
        public static ListCache<int> IntCache = new ListCache<int>();

        #region GetCache.
        /// <summary>
        /// Returns a NetworkObject cache. Use StoreCache to return the cache.
        /// </summary>
        /// <returns></returns>
        public static ListCache<NetworkObject> GetNetworkObjectCache()
        {
            ListCache<NetworkObject> result;
            if (_networkObjectCaches.Count == 0)
                result = new ListCache<NetworkObject>();
            else
                result = _networkObjectCaches.Pop();

            return result;
        }
        /// <summary>
        /// Returns a NetworkConnection cache. Use StoreCache to return the cache.
        /// </summary>
        /// <returns></returns>
        public static ListCache<NetworkConnection> GetNetworkConnectionCache()
        {
            ListCache<NetworkConnection> result;
            if (_networkConnectionCaches.Count == 0)
                result = new ListCache<NetworkConnection>();
            else
                result = _networkConnectionCaches.Pop();

            return result;
        }
        /// <summary>
        /// Returns a Transform cache. Use StoreCache to return the cache.
        /// </summary>
        /// <returns></returns>
        public static ListCache<Transform> GetTransformCache()
        {
            ListCache<Transform> result;
            if (_transformCaches.Count == 0)
                result = new ListCache<Transform>();
            else
                result = _transformCaches.Pop();

            return result;
        }
        /// <summary>
        /// Returns a NetworkBehaviour cache. Use StoreCache to return the cache.
        /// </summary>
        /// <returns></returns>
        public static ListCache<NetworkBehaviour> GetNetworkBehaviourCache()
        {
            ListCache<NetworkBehaviour> result;
            if (_networkBehaviourCaches.Count == 0)
                result = new ListCache<NetworkBehaviour>();
            else
                result = _networkBehaviourCaches.Pop();

            return result;
        }
        #endregion

        #region StoreCache.
        /// <summary>
        /// Stores a NetworkObject cache.
        /// </summary>
        /// <param name="cache"></param>
        public static void StoreCache(ListCache<NetworkObject> cache)
        {
            cache.Reset();
            _networkObjectCaches.Push(cache);
        }
        /// <summary>
        /// Stores a NetworkConnection cache.
        /// </summary>
        /// <param name="cache"></param>
        public static void StoreCache(ListCache<NetworkConnection> cache)
        {
            cache.Reset();
            _networkConnectionCaches.Push(cache);
        }
        /// <summary>
        /// Stores a Transform cache.
        /// </summary>
        /// <param name="cache"></param>
        public static void StoreCache(ListCache<Transform> cache)
        {
            cache.Reset();
            _transformCaches.Push(cache);
        }
        /// <summary>
        /// Stores a NetworkBehaviour cache.
        /// </summary>
        /// <param name="cache"></param>
        public static void StoreCache(ListCache<NetworkBehaviour> cache)
        {
            cache.Reset();
            _networkBehaviourCaches.Push(cache);
        }
        #endregion

    }

    /// <summary>
    /// Creates a reusable cache of T which auto expands.
    /// </summary>
    public class ListCache<T>
    {
        #region Public.
        /// <summary>
        /// Collection cache is for.
        /// </summary>
        public List<T> Collection;
        /// <summary>
        /// Entries currently written.
        /// </summary>
        public int Written { get; private set; }
        #endregion

        public ListCache()
        {
            Collection = new List<T>();
        }
        public ListCache(int capacity)
        {
            Collection = new List<T>(capacity);
        }

        /// <summary>
        /// Adds a new value to Collection and returns it.
        /// </summary>
        /// <param name="value"></param>
        public T AddReference()
        {
            if (Collection.Count <= Written)
            {
                T next = Activator.CreateInstance<T>();
                Collection.Add(next);
                Written++;
                return next;
            }
            else
            {
                T next = Collection[Written];
                Written++;
                return next;
            }
        }

        /// <summary>
        /// Adds value to Collection.
        /// </summary>
        /// <param name="value"></param>
        public void AddValue(T value)
        {
            if (Collection.Count <= Written)
                Collection.Add(value);
            else
                Collection[Written] = value;

            Written++;
        }

        /// <summary>
        /// Adds values to Collection.
        /// </summary>
        /// <param name="values"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddValues(ListCache<T> values)
        {
            int w = values.Written;
            List<T> c = values.Collection;
            for (int i = 0; i < w; i++)
                AddValue(c[i]);
        }
        /// <summary>
        /// Adds values to Collection.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddValues(T[] values)
        {
            for (int i = 0; i < values.Length; i++)
                AddValue(values[i]);
        }
        /// <summary>
        /// Adds values to Collection.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddValues(List<T> values)
        {
            for (int i = 0; i < values.Count; i++)
                AddValue(values[i]);
        }
        /// <summary>
        /// Adds values to Collection.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddValues(HashSet<T> values)
        {
            foreach (T item in values)
                AddValue(item);
        }
        /// <summary>
        /// Adds values to Collection.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddValues(ISet<T> values)
        {
            foreach (T item in values)
                AddValue(item);
        }

        /// <summary>
        /// Adds values to Collection.
        /// </summary>
        /// <param name="value"></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddValues(IReadOnlyCollection<T> values)
        {
            foreach (T item in values)
                AddValue(item);
        }

        /// <summary>
        /// Resets cache.
        /// </summary>
        public void Reset()
        {
            Written = 0;
        }
    }

}

'''
'''--- Assets/FishNet/Runtime/Utility/Performance/ObjectPool.cs ---
﻿using FishNet.Managing;
using FishNet.Object;
using UnityEngine;

namespace FishNet.Utility.Performance
{

    public abstract class ObjectPool : MonoBehaviour
    {
        /// <summary>
        /// NetworkManager this ObjectPool belongs to.
        /// </summary>
        protected NetworkManager NetworkManager {get; private set;}

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        public virtual void InitializeOnce(NetworkManager nm)
        {
            NetworkManager = nm;
        }

        /// <summary>
        /// Returns an object that has been stored. A new object will be created if no stored objects are available.
        /// </summary>
        /// <param name="prefabId">PrefabId of the object to return.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public abstract NetworkObject RetrieveObject(int prefabId, bool asServer);
        /// <summary>
        /// Stores an object into the pool.
        /// </summary>
        /// <param name="instantiated">Object to store.</param>
        /// <param name="prefabId">PrefabId of the object.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public abstract void StoreObject(NetworkObject instantiated, int prefabId, bool asServer);
    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/Performance/Transform.cs ---
﻿//This file is no longer needed.
//Remove on 2023/01/01
'''
'''--- Assets/FishNet/Runtime/Utility/Performance/Transforms.cs ---
﻿using FishNet.Object;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Utility.Performance
{

    public static class GetNonAlloc
    {
        /// <summary>
        /// 
        /// </summary>
        private static List<Transform> _transformList = new List<Transform>();
        /// <summary>
        /// 
        /// </summary>
        private static List<NetworkBehaviour> _networkBehavioursList = new List<NetworkBehaviour>();

        /// <summary>
        /// Gets all NetworkBehaviours on a transform.
        /// </summary>
        public static List<NetworkBehaviour> GetNetworkBehaviours(this Transform t)
        {
            t.GetComponents(_networkBehavioursList);
            return _networkBehavioursList;
        }

        /// <summary>
        /// Gets all transforms on transform and it's children.
        /// </summary>
        public static List<Transform> GetTransformsInChildrenNonAlloc(this Transform t, bool includeInactive = false)
        {
            t.GetComponentsInChildren<Transform>(includeInactive, _transformList);
            return _transformList;
        }

    }

}
'''
'''--- Assets/FishNet/Runtime/Utility/SceneAttribute.cs ---
﻿using UnityEngine;

namespace FishNet.Utility
{
    /* Source https://forum.unity.com/threads/how-to-link-scenes-in-the-inspector.383140/ */

    /// <summary>
    /// Converts a string property into a Scene property in the inspector
    /// </summary>
    public class SceneAttribute : PropertyAttribute { }

}
'''
'''--- Assets/FishNet/THIRD PARTY NOTICE.md ---
This package contains third-party software components governed by the license(s) indicated below:

Component Name: LiteNetLib
License Type: MIT
Copyright (c) 2020 Ruslan Pyrch
Copyright (c) 2021, Benjamin Berwick of FirstGearGames LLC, registered 2018, North Carolina.

Paths:	FishNet\Runtime\Transporting\Transports\Tugboat\LiteNetLib

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Component Name: CodeGen Helpers(extensions).
License Type: MIT
Copyright (c) 2015, Unity Technologies
Copyright (c) 2019, vis2k, Paul and Contributors
Copyright (c) 2021, Benjamin Berwick of FirstGearGames LLC, registered 2018, North Carolina.

Paths:	FishNet/CodeGenerating/Helpers/

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Component Name: MonoCecil
License Type: MIT
Copyright (c) 2008 - 2015 Jb Evain
Copyright (c) 2008 - 2011 Novell, Inc.

Paths:	FishNet/CodeGenerating/cecil-xxxxx

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

'''
'''--- Assets/FishNet/Upgrading/MirrorUpgrade.cs ---
﻿#if UNITY_EDITOR
#if MIRROR
using UnityEditor;
using UnityEngine;
using FishNet.Object;
using FishNet.Documenting;
using System.Collections.Generic;
using FNNetworkTransform = FishNet.Component.Transforming.NetworkTransform;
using FNNetworkAnimator = FishNet.Component.Animating.NetworkAnimator;
using FNNetworkObserver = FishNet.Observing.NetworkObserver;
using FishNet.Observing;
using FishNet.Component.Observing;
using FishNet.Editing;
using System.IO;
using System.Collections;
using Mirror;
using MirrorExperimentalNetworkTransformBase = Mirror.Experimental.NetworkTransformBase;
using MirrorExperimentalNetworkTransformChild = Mirror.Experimental.NetworkTransformChild;
using MirrorNetworkTransformBase = Mirror.NetworkTransformBase;
using MirrorNetworkTransformChild = Mirror.NetworkTransformChild;
using MirrorNetworkAnimator = Mirror.NetworkAnimator;
#if !MIRROR_57_0_OR_NEWER
using MirrorNetworkProximityChecker = Mirror.NetworkProximityChecker;
using MirrorNetworkSceneChecker = Mirror.NetworkSceneChecker;
#endif

#if FGG_ASSETS
using FlexNetworkAnimator = FirstGearGames.Mirrors.Assets.FlexNetworkAnimators.FlexNetworkAnimator;
using FlexNetworkTransformBase = FirstGearGames.Mirrors.Assets.FlexNetworkTransforms.FlexNetworkTransformBase;
using FastProximityChecker = FirstGearGames.Mirrors.Assets.NetworkProximities.FastProximityChecker;
#endif

#if FGG_PROJECTS
using FlexSceneChecker = FirstGearGames.FlexSceneManager.FlexSceneChecker;
#endif

namespace FishNet.Upgrading.Mirror.Editing
{

    /* IMPORTANT IMPORTANT IMPORTANT IMPORTANT 
    * If you receive errors about missing Mirror components,
    * such as NetworkIdentity, then remove MIRROR and any other
    * MIRROR defines.
    * Project Settings -> Player -> Other -> Scripting Define Symbols.
    * 
    * If you are also using my assets add FGG_ASSETS to the defines, and
    * then remove it after running this script. */
    [APIExclude]
    [ExecuteInEditMode]
    [InitializeOnLoad]
    public class MirrorUpgrade : MonoBehaviour
    {
        /// <summary>
        /// SceneCondition within FishNet.
        /// </summary>
        private SceneCondition _sceneCondition = null;
        /// <summary>
        /// DistanceCondition created for the user.
        /// </summary>
        private DistanceCondition _distanceCondition = null;
        /// <summary>
        /// 
        /// </summary>
        private int _replacedNetworkTransforms;
        /// <summary>
        /// 
        /// </summary>
        private int _replacedNetworkAnimators;
        /// <summary>
        /// 
        /// </summary>
        private int _replacedNetworkIdentities;
        /// <summary>
        /// 
        /// </summary>
        private int _replacedSceneCheckers;
        /// <summary>
        /// 
        /// </summary>
        private int _replacedProximityCheckers;
        /// <summary>
        /// True if anything was changed.
        /// </summary>
        private bool _changed;
        /// <summary>
        /// Index in gameObjects to iterate.
        /// </summary>
        private int _goIndex = -1;
        /// <summary>
        /// Found gameObjects to iterate.
        /// </summary>
        private List<GameObject> _gameObjects = new List<GameObject>();
        /// <summary>
        /// True if initialized.
        /// </summary>
        private bool _initialized;

        private const string OBJECT_NAME_PREFIX = "MirrorUpgrade";

        private void Awake()
        {
            gameObject.name = OBJECT_NAME_PREFIX;
            Debug.Log($"{gameObject.name} is working. Please wait until this object is removed from your hierarchy.");
            EditorApplication.update += EditorUpdate;
        }

        private void OnDestroy()
        {
            EditorApplication.update -= EditorUpdate;
        }

        private void EditorUpdate()
        {
            if (!_initialized)
            {
                FindConditions(true);
                _gameObjects = Finding.GetGameObjects(true, false, true, new string[] { "/Mirror/" });
                _goIndex = 0;
                _initialized = true;
            }

            if (_goIndex == -1)
                return;
            if (_goIndex >= _gameObjects.Count)
            {
                gameObject.name = $"{OBJECT_NAME_PREFIX} - 100%";
                Debug.Log($"Switched {_replacedNetworkTransforms} NetworkTransforms.");
                Debug.Log($"Switched {_replacedNetworkAnimators} NetworkAnimators.");
                Debug.Log($"Switched {_replacedSceneCheckers} SceneCheckers.");
                Debug.Log($"Switched {_replacedProximityCheckers} ProximityCheckers.");
                Debug.Log($"Switched {_replacedNetworkIdentities} NetworkIdentities.");

                if (_changed)
                    PrintSaveWarning();

                DestroyImmediate(gameObject);
                return;
            }

            float percentFloat = ((float)_goIndex / (float)_gameObjects.Count) * 100f;
            int percentInt = Mathf.FloorToInt(percentFloat);
            gameObject.name = $"{OBJECT_NAME_PREFIX} - {percentInt}%";

            GameObject go = _gameObjects[_goIndex];
            _goIndex++;
            //Go went empty?
            if (go == null)
                return;

            /* When a component is removed
             * changed is set true and remove count is increased.
             * _goIndex is also returned before exiting the method.
             * This will cause the same gameObject to iterate
             * next update. This is important because the components
             * must be Switched in order, and I can only remove one
             * component per frame without Unity throwing a fit and
             * freezing. A while loop doesn't let Unity recognize the component
             * is gone(weird right? maybe editor thing), and a coroutine
             * doesn't show errors well, they just fail silently. */

            bool changedThisFrame = false;
            if (IterateNetworkTransform(go))
            {
                changedThisFrame = true;
                _changed = true;
                _replacedNetworkTransforms++;
            }
            if (IterateNetworkAnimator(go))
            {
                changedThisFrame = true;
                _changed = true;
                _replacedNetworkAnimators++;
            }

            if (IterateSceneChecker(go))
            {
                changedThisFrame = true;
                _changed = true;
                _replacedSceneCheckers++;
            }
            if (IterateProximityChecker(go))
            {
                changedThisFrame = true;
                _changed = true;
                _replacedProximityCheckers++;
            }
            if (changedThisFrame)
            {
                _goIndex--;
                return;
            }
            //NetworkIdentity must be done last.
            if (IterateNetworkIdentity(go))
            {
                _changed = true;
                _replacedNetworkIdentities++;
            }
        }

        /// <summary>
        /// Finds Condition scripts to be used with NetworkObserver.
        /// </summary>
        /// <param name="error"></param>
        private void FindConditions(bool error)
        {
            List<UnityEngine.Object> scriptableObjects;

            if (_sceneCondition == null)
            {
                scriptableObjects = Finding.GetScriptableObjects<SceneCondition>(true, true);
                //Use the first found scene condition, there should be only one.
                if (scriptableObjects.Count > 0)
                    _sceneCondition = (SceneCondition)scriptableObjects[0];

                if (_sceneCondition == null && error)
                    Debug.LogError("SceneCondition could not be found. Upgrading scene checker components will not function.");
            }

            if (_distanceCondition == null)
            {
                scriptableObjects = Finding.GetScriptableObjects<DistanceCondition>(false, true);
                if (scriptableObjects.Count > 0)
                {
                    _distanceCondition = (DistanceCondition)scriptableObjects[0];
                }
                else
                {
                    DistanceCondition dc = ScriptableObject.CreateInstance<DistanceCondition>();
                    string savePath = "Assets";
                    AssetDatabase.CreateAsset(dc, Path.Combine(savePath, $"CreatedDistanceCondition.asset"));
                    Debug.LogWarning($"DistanceCondition has been created at {savePath}. Place this file somewhere within your project and change settings to your liking.");
                }

                if (_distanceCondition == null && error)
                    Debug.LogError("DistanceCondition could not be found. Upgrading proximity checker components will not function.");
            }
        }

        private bool IterateNetworkTransform(GameObject go)
        {
            if (go.TryGetComponent(out MirrorNetworkTransformBase nt1))
            {
                Transform target;
                if (nt1 is MirrorNetworkTransformChild mc1)
                    target = mc1.target;
                else
                    target = go.transform;
                Replace(nt1, target);
                return true;
            }
            if (go.TryGetComponent(out MirrorExperimentalNetworkTransformBase nt2))
            {
                Transform target;
                if (nt2 is MirrorExperimentalNetworkTransformChild mc1)
                    target = mc1.target;
                else
                    target = go.transform;
                Replace(nt2, target);
                return true;
            }
#if FGG_ASSETS
            if (go.TryGetComponent(out FlexNetworkTransformBase fntb))
            {
                Replace(fntb, fntb.TargetTransform);
                return true;
            }
#endif

            void Replace(UnityEngine.Component component, Transform target)
            {
                EditorUtility.SetDirty(go);
                DestroyImmediate(component, true);

                if (target != null && !target.TryGetComponent<FNNetworkTransform>(out _))
                    target.gameObject.AddComponent<FNNetworkTransform>();
            }

            //Fall through, nothing was replaced.
            return false;
        }

        private bool IterateNetworkAnimator(GameObject go)
        {
            if (go.TryGetComponent(out MirrorNetworkAnimator mna))
            {
                Replace(mna, mna.transform);
                return true;
            }
#if FGG_ASSETS
            if (go.TryGetComponent(out FlexNetworkAnimator fna))
            {
                Replace(fna, fna.transform);
                return true;
            }
#endif

            void Replace(UnityEngine.Component component, Transform target)
            {
                EditorUtility.SetDirty(go);
                DestroyImmediate(component, true);

                if (target == null)
                    return;
                if (!target.TryGetComponent<FNNetworkAnimator>(out _))
                    target.gameObject.AddComponent<FNNetworkAnimator>();
            }

            return false;
        }

        private bool IterateSceneChecker(GameObject go)
        {
#if !MIRROR_57_0_OR_NEWER
            if (_sceneCondition == null)
                return false;

            if (go.TryGetComponent(out MirrorNetworkSceneChecker msc))
            {
                Replace(msc);
                return true;
            }
#if FGG_PROJECTS
            if (go.TryGetComponent(out FlexSceneChecker fsc))
            {
                Replace(fsc);
                return true;
            }
#endif

            void Replace(UnityEngine.Component component)
            {
                EditorUtility.SetDirty(go);
                DestroyImmediate(component, true);

                FNNetworkObserver networkObserver;
                if (!go.TryGetComponent(out networkObserver))
                    networkObserver = go.AddComponent<FNNetworkObserver>();

                bool conditionFound = false;
                foreach (ObserverCondition condition in networkObserver.ObserverConditions)
                {
                    if (condition.GetType() == typeof(SceneCondition))
                    {
                        conditionFound = true;
                        break;
                    }
                }

                //If not able to find scene condition then add one.
                if (!conditionFound)
                    networkObserver.ObserverConditionsInternal.Add(_sceneCondition);
            }

#endif
            return false;
        }

        private bool IterateProximityChecker(GameObject go)
        {
#if !MIRROR_57_0_OR_NEWER
            if (_distanceCondition == null)
                return false;

            if (go.TryGetComponent(out MirrorNetworkProximityChecker mnpc))
            {
                Replace(mnpc);
                return true;
            }
#if FGG_PROJECTS
            if (go.TryGetComponent(out FastProximityChecker fpc))
            {
                Replace(fpc);
                return true;
            }
#endif

            void Replace(UnityEngine.Component component)
            {
                EditorUtility.SetDirty(go);
                DestroyImmediate(component, true);

                FNNetworkObserver networkObserver;
                if (!go.TryGetComponent(out networkObserver))
                    networkObserver = go.AddComponent<FNNetworkObserver>();

                bool conditionFound = false;
                foreach (ObserverCondition condition in networkObserver.ObserverConditions)
                {
                    if (condition.GetType() == typeof(DistanceCondition))
                    {
                        conditionFound = true;
                        break;
                    }
                }

                //If not able to find scene condition then add one.
                if (!conditionFound)
                    networkObserver.ObserverConditionsInternal.Add(_distanceCondition);
            }
#endif

            return false;
        }

        private bool IterateNetworkIdentity(GameObject go)
        {
            if (go.TryGetComponent(out NetworkIdentity netIdentity))
            {
                EditorUtility.SetDirty(go);
                DestroyImmediate(netIdentity, true);

                //Add nob if doesn't exist.
                if (!go.TryGetComponent<NetworkObject>(out _))
                    go.AddComponent<NetworkObject>();

                return true;
            }

            return false;
        }

        private static void PrintSaveWarning()
        {
            Debug.LogWarning("You must File -> Save for changes to complete.");
        }
    }

}
#endif
#endif
'''
'''--- Assets/FishNet/Upgrading/UpgradeFromMirrorMenu.cs ---
﻿#if UNITY_EDITOR
using FishNet.Documenting;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace FishNet.Upgrading.Mirror.Editing
{

    /* IMPORTANT IMPORTANT IMPORTANT IMPORTANT 
    * If you receive errors about missing Mirror components,
    * such as NetworkIdentity, then remove MIRROR and any other
    * MIRROR defines.
    * Project Settings -> Player -> Other -> Scripting Define Symbols.
    * 
    * If you are also using my assets add FGG_ASSETS to the defines, and
    * then remove it after running this script. */
    [APIExclude]
    public class UpgradeFromMirrorMenu : MonoBehaviour
    {

        /// <summary>
        /// Replaces all components.
        /// </summary>
        [MenuItem("Fish-Networking/Upgrading/From Mirror/Replace Components", false,2)]
        private static void ReplaceComponents()
        {
#if MIRROR
            MirrorUpgrade result = GameObject.FindObjectOfType<MirrorUpgrade>();
            if (result != null)
            {
                Debug.LogError("MirrorUpgrade already exist in the scene. This suggests an operation is currently running.");
                return;
            }

            GameObject iteratorGo = new GameObject();
            iteratorGo.AddComponent<MirrorUpgrade>();
#else
            Debug.LogError("Mirror must be imported to perform this function.");
#endif
        }

        [MenuItem("Fish-Networking/Upgrading/From Mirror/Remove Defines", false, 2)]
        private static void RemoveDefines()
        {
            string currentDefines = PlayerSettings.GetScriptingDefineSymbolsForGroup(EditorUserBuildSettings.selectedBuildTargetGroup);
            /* Convert current defines into a hashset. This is so we can
             * determine if any of our defines were added. Only save playersettings
             * when a define is added. */
            HashSet<string> definesHs = new HashSet<string>();
            string[] currentArr = currentDefines.Split(';');

            bool removed = false;
            //Add any define which doesn't contain MIRROR.
            foreach (string item in currentArr)
            {
                string itemLower = item.ToLower();
                if (itemLower != "mirror" && !itemLower.StartsWith("mirror_"))
                    definesHs.Add(item);
                else
                    removed = true;
            }

            if (removed)
            {
                Debug.Log("Removed Mirror defines to player settings.");
                string changedDefines = string.Join(";", definesHs);
                PlayerSettings.SetScriptingDefineSymbolsForGroup(EditorUserBuildSettings.selectedBuildTargetGroup, changedDefines);
            }
        }

    }
}
#endif

'''
'''--- Assets/FishNet/VERSION.txt ---
2.5.4
'''
'''--- Assets/Game/Scripts/CameraFollow.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CameraFollow : MonoBehaviour
{
  public Transform target;
  void LateUpdate()
  {
    if (target != null)
    {
      transform.position = new Vector3(target.position.x, target.position.y, transform.position.z);
    }
  }
}

'''
'''--- Assets/Game/Scripts/Damager.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using FishNet.Object;

public class Damager : NetworkBehaviour
{
  void OnTriggerEnter2D(Collider2D other)
  {
    if (!base.IsOwner) return;
    if (other.tag != "Player") return;
    Health health = other.GetComponent<Health>();
    if (health != null)
    {
      ServerDamager(health);
    }
  }

  [ServerRpc]
  private void ServerDamager(Health opponentsHealth)
  {
    opponentsHealth.UpdateHealth(opponentsHealth.m_health - 10);
  }

}

'''
'''--- Assets/Game/Scripts/Health.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using FishNet.Object;

public class Health : NetworkBehaviour
{
  public int m_health;
  public int m_maxHealth = 100;

  [SerializeField] private Image m_healthBar;

  void Awake()
  {
    m_health = m_maxHealth;
  }

  public void UpdateHealth(int health)
  {
    m_health = health;
    m_healthBar.fillAmount = (float)m_health / m_maxHealth;
    ObserversUpdateHealth(m_health);
    if (m_health <= 0)
    {
      gameObject.SetActive(false);
    }
  }

  [ObserversRpc(BufferLast = true)]
  private void ObserversUpdateHealth(int health)
  {
    m_health = health;
    m_healthBar.fillAmount = (float)m_health / m_maxHealth;
    if (m_health <= 0)
    {
      gameObject.SetActive(false);
    }
  }

}

'''
'''--- Assets/Game/Scripts/Move2D.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using FishNet.Object;
using FishNet.Connection;
using FishNet.Component.Animating;

public class Move2D : NetworkBehaviour
{
  public float m_speed = 1.0f;
  private Rigidbody2D _rigidbody2D;
  private Animator _animator;
  private NetworkAnimator _networkAnimator;
  private Vector2 _userinput;
  private bool _flipped;
  [SerializeField] private Transform m_main;

  void Awake()
  {
    _rigidbody2D = GetComponent<Rigidbody2D>();
    _animator = GetComponentInChildren<Animator>();
    _networkAnimator = GetComponentInChildren<NetworkAnimator>();
  }

  public override void OnOwnershipClient(NetworkConnection prevOwner)
  {
    base.OnOwnershipClient(prevOwner);
    GetComponent<PlayerInput>().enabled = base.IsOwner;
  }

  public void Attack(InputAction.CallbackContext context)
  {
    if (!base.IsOwner) return;
    if (context.started)
    {
      _networkAnimator.SetTrigger("attack");
    }
    if (context.canceled)
    {
      _networkAnimator.ResetTrigger("attack");
    }
  }

  public void Move(InputAction.CallbackContext context)
  {
    if (!base.IsOwner) return;
    _userinput = context.ReadValue<Vector2>();
    _animator.SetFloat("speed", _userinput.magnitude);
    if (_userinput.x < 0 && !_flipped)
    {
      _flipped = true;
    }
    else if (_userinput.x > 0 && _flipped)
    {
      _flipped = false;
    }
    m_main.localScale = new Vector3(_flipped ? -1 : 1, 1, 1);
  }

  void FixedUpdate()
  {
    if (!base.IsOwner) return;
    _rigidbody2D.MovePosition(_rigidbody2D.position + _userinput * Time.fixedDeltaTime * m_speed);
  }
}

'''
'''--- Assets/Game/Scripts/NearGameController.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using RFG.NEAR;
using System.Threading.Tasks;
using FishNet.Managing;

public class NearGameController : MonoBehaviour
{
  [SerializeField] private string _contractId = "nft-unity-contract.morganpage1.testnet";
  [SerializeField] private string _network = "testnet";

  [SerializeField] private TMP_Text _textWelcome;
  [SerializeField] private TMP_Text _textTokens;
  [SerializeField] Button _buttonSignInOut;
  [SerializeField] UIToken _uiTokenPrefab;
  [SerializeField] Transform _uiTokenParent;

  private string _accountId;
  private bool _signedIn;

  [SerializeField] private NetworkManager _networkManager;
  [SerializeField] private GameObject _nearPanel;
  void OnEnable()
  {
    NearCallbacks.OnSignIn += OnSignIn;
    NearCallbacks.OnGetAccountId += OnGetAccountId;
    NearCallbacks.OnNftTokensForOwner += OnNftTokensForOwner;
  }

  void OnDisable()
  {
    NearCallbacks.OnSignIn -= OnSignIn;
    NearCallbacks.OnGetAccountId -= OnGetAccountId;
    NearCallbacks.OnNftTokensForOwner -= OnNftTokensForOwner;
  }

  void Start()
  {
    NearAPI.IsSignedIn(_network);
  }

  private void OnSignIn(bool signedIn)
  {
    _signedIn = signedIn;
    if (_signedIn)
    {
      NearAPI.GetAccountId(_network);
      _buttonSignInOut.GetComponentInChildren<TMP_Text>().text = "Sign Out";
      _textTokens.text = "Click Get Tokens to continue...";
    }
    else
    {
      _textWelcome.text = "You must sign in...";
      _textTokens.text = "You must sign in...";
      _buttonSignInOut.GetComponentInChildren<TMP_Text>().text = "Sign In";
    }
  }
  private void OnGetAccountId(string accountId)
  {
    _accountId = accountId;
    _textWelcome.text = "Welcome " + _accountId;
    NearAPI.NftTokensForOwner(_accountId, _contractId, _network);
  }
  private async void OnNftTokensForOwner(Token[] tokens)
  {
    foreach (Transform child in _uiTokenParent)
    {
      Destroy(child.gameObject);
    }

    foreach (var token in tokens)
    {
      _textTokens.text = "Select a token to continue...";

      // Get the image
      Texture texture = await RestAPI.GetImage(token.metadata.media);
      if (texture != null)
      {
        UIToken uiToken = Instantiate(_uiTokenPrefab);
        uiToken.SetImage(texture);
        uiToken.SetTitle(token.metadata.title);
        uiToken.SetTokenId(token.token_id);
        //uiToken.SetButtonListener(OnTokenButtonClicked);
        uiToken.button.onClick.AddListener(() => OnTokenButtonClicked(token));
        uiToken.transform.SetParent(_uiTokenParent);
        uiToken.transform.localScale = Vector3.one;
        uiToken.transform.localPosition = Vector3.zero;
        _uiTokenParent.localPosition = Vector3.zero;
      }
    }
  }

  void OnTokenButtonClicked(Token token)
  {
    Debug.Log("OnTokenButtonClicked: " + token.token_id);
    int charIndex = int.Parse(token.token_id) - 1;
    Player.localCharacterIndex = charIndex;
    Player.localUsername = token.metadata.title;
    _networkManager.ClientManager.StartConnection();
    _nearPanel.SetActive(false);
  }

  public void NftTokensForOwner()
  {
    if (!_signedIn)
    {
      _textTokens.text = "You must sign in to get tokens...";
      return;
    }
    NearAPI.NftTokensForOwner(_accountId, _contractId, _network);
  }
  public void SignInOut()
  {
    if (_signedIn)
    {
      NearAPI.SignOut(_network);
      NearAPI.IsSignedIn(_network);
    }
    else
    {
      NearAPI.RequestSignIn(_contractId, _network);//This will do a page refresh anyway
      NearAPI.IsSignedIn(_network);
    }
  }

}

'''
'''--- Assets/Game/Scripts/Player.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine.U2D.Animation;

public class Player : NetworkBehaviour
{
  public static string localUsername;
  public static int localCharacterIndex;
  [SyncVar(OnChange = nameof(OnUsernameChanged))]
  public string username;

  private void OnUsernameChanged(string oldValue, string newValue, bool isServer)
  {
    _usernameText.text = newValue;
  }

  [SyncVar(OnChange = nameof(OnCharacterIndexChanged))]
  public int characterIndex;
  private void OnCharacterIndexChanged(int oldValue, int newValue, bool isServer)
  {
    GetComponent<SpriteLibrary>().spriteLibraryAsset = _characterSpriteLibraries[newValue];
  }

  [SerializeField] private TMPro.TextMeshProUGUI _usernameText;
  [SerializeField] private SpriteLibraryAsset[] _characterSpriteLibraries;

  public override void OnStartClient()
  {
    base.OnStartClient();
    if (!IsOwner) return;
    ServerSetCharacterIndex(localCharacterIndex);
    ServerSetName(localUsername);
    Camera.main.GetComponent<CameraFollow>().target = transform;
    Camera.main.orthographicSize = 3.0f;
  }

  [ServerRpc]
  private void ServerSetName(string name)
  {
    username = name;
  }

  [ServerRpc]
  private void ServerSetCharacterIndex(int index)
  {
    characterIndex = index;
  }

}

'''
'''--- Assets/ParrelSync/Examples/CustomArgumentExample.cs ---
﻿// This should be editor only
#if UNITY_EDITOR
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ParrelSync.Example
{
    public class CustomArgumentExample : MonoBehaviour
    {
        // Start is called before the first frame update
        void Start()
        {
            // Is this editor instance running a clone project?
            if (ClonesManager.IsClone())
            {
                Debug.Log("This is a clone project.");

                //Argument can be set from the clones manager window.               
                string customArgument = ClonesManager.GetArgument();
                Debug.Log("The custom argument of this clone project is: " + customArgument);
                // Do what ever you need with the argument string.
            }
            else
            {
                Debug.Log("This is the original project.");
            }
        }
    }
}
#endif
'''
'''--- Assets/ParrelSync/LICENSE.md ---
MIT License

Copyright (c) 2018 Greg M  
Copyright (c) 2020 Ian and Contributors  

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'''
'''--- Assets/ParrelSync/ParrelSync/Editor/AssetModBlock/EditorQuit.cs ---
﻿using UnityEditor;
namespace ParrelSync
{
    [InitializeOnLoad]
    public class EditorQuit
    {
        /// <summary>
        /// Is editor being closed
        /// </summary>
        static public bool IsQuiting { get; private set; }
        static void Quit()
        {
            IsQuiting = true;
        }

        static EditorQuit()
        {
            IsQuiting = false;
            EditorApplication.quitting += Quit;
        }
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/Editor/AssetModBlock/ParrelSyncAssetModificationProcessor.cs ---
﻿using UnityEditor;
using UnityEngine;
namespace ParrelSync
{
    /// <summary>
    /// For preventing assets being modified from the clone instance.
    /// </summary>
    public class ParrelSyncAssetModificationProcessor : UnityEditor.AssetModificationProcessor
    {
        public static string[] OnWillSaveAssets(string[] paths)
        {
            if (ClonesManager.IsClone() && Preferences.AssetModPref.Value)
            {
                if (paths != null && paths.Length > 0 && !EditorQuit.IsQuiting)
                {
                    EditorUtility.DisplayDialog(
                        ClonesManager.ProjectName + ": Asset modifications saving detected and blocked",
                        "Asset modifications saving are blocked in the clone instance. \n\n" +
                        "This is a clone of the original project. \n" +
                        "Making changes to asset files via the clone editor is not recommended. \n" +
                        "Please use the original editor window if you want to make changes to the project files.",
                        "ok"
                    );
                    foreach (var path in paths)
                    {
                        Debug.Log("Attempting to save " + path + " are blocked.");
                    }
                }
                return new string[0] { };
            }
            return paths;
        }
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/Editor/ClonesManager.cs ---
﻿using System.Collections.Generic;
using System.Diagnostics;
using UnityEngine;
using UnityEditor;
using System.Linq;
using System.IO;
using Debug = UnityEngine.Debug;

namespace ParrelSync
{
    /// <summary>
    /// Contains all required methods for creating a linked clone of the Unity project.
    /// </summary>
    public class ClonesManager
    {
        /// <summary>
        /// Name used for an identifying file created in the clone project directory.
        /// </summary>
        /// <remarks>
        /// (!) Do not change this after the clone was created, because then connection will be lost.
        /// </remarks>
        public const string CloneFileName = ".clone";

        /// <summary>
        /// Suffix added to the end of the project clone name when it is created.
        /// </summary>
        /// <remarks>
        /// (!) Do not change this after the clone was created, because then connection will be lost.
        /// </remarks>
        public const string CloneNameSuffix = "_clone";

        public const string ProjectName = "ParrelSync";

        /// <summary>
        /// The maximum number of clones
        /// </summary>
        public const int MaxCloneProjectCount = 10;

        /// <summary>
        /// Name of the file for storing clone's argument.
        /// </summary>
        public const string ArgumentFileName = ".parrelsyncarg";

        /// <summary>
        /// Default argument of the new clone
        /// </summary>
        public const string DefaultArgument = "client";

        #region Managing clones

        /// <summary>
        /// Creates clone from the project currently open in Unity Editor.
        /// </summary>
        /// <returns></returns>
        public static Project CreateCloneFromCurrent()
        {
            if (IsClone())
            {
                Debug.LogError("This project is already a clone. Cannot clone it.");
                return null;
            }

            string currentProjectPath = ClonesManager.GetCurrentProjectPath();
            return ClonesManager.CreateCloneFromPath(currentProjectPath);
        }

        /// <summary>
        /// Creates clone of the project located at the given path.
        /// </summary>
        /// <param name="sourceProjectPath"></param>
        /// <returns></returns>
        public static Project CreateCloneFromPath(string sourceProjectPath)
        {
            Project sourceProject = new Project(sourceProjectPath);

            string cloneProjectPath = null;

            //Find available clone suffix id
            for (int i = 0; i < MaxCloneProjectCount; i++)
            {
                string originalProjectPath = ClonesManager.GetCurrentProject().projectPath;
                string possibleCloneProjectPath = originalProjectPath + ClonesManager.CloneNameSuffix + "_" + i;

                if (!Directory.Exists(possibleCloneProjectPath))
                {
                    cloneProjectPath = possibleCloneProjectPath;
                    break;
                }
            }

            if (string.IsNullOrEmpty(cloneProjectPath))
            {
                Debug.LogError("The number of cloned projects has reach its limit. Limit: " + MaxCloneProjectCount);
                return null;
            }

            Project cloneProject = new Project(cloneProjectPath);

            Debug.Log("Start cloning project, original project: " + sourceProject + ", clone project: " + cloneProject);

            ClonesManager.CreateProjectFolder(cloneProject);

            //Copy Folders           
            Debug.Log("Library copy: " + cloneProject.libraryPath);
            ClonesManager.CopyDirectoryWithProgressBar(sourceProject.libraryPath, cloneProject.libraryPath,
                "Cloning Project Library '" + sourceProject.name + "'. ");
            Debug.Log("Packages copy: " + cloneProject.libraryPath);
            ClonesManager.CopyDirectoryWithProgressBar(sourceProject.packagesPath, cloneProject.packagesPath,
              "Cloning Project Packages '" + sourceProject.name + "'. ");

            //Link Folders
            ClonesManager.LinkFolders(sourceProject.assetPath, cloneProject.assetPath);
            ClonesManager.LinkFolders(sourceProject.projectSettingsPath, cloneProject.projectSettingsPath);
            ClonesManager.LinkFolders(sourceProject.autoBuildPath, cloneProject.autoBuildPath);
            ClonesManager.LinkFolders(sourceProject.localPackages, cloneProject.localPackages);

            ClonesManager.RegisterClone(cloneProject);

            return cloneProject;
        }

        /// <summary>
        /// Registers a clone by placing an identifying ".clone" file in its root directory.
        /// </summary>
        /// <param name="cloneProject"></param>
        private static void RegisterClone(Project cloneProject)
        {
            /// Add clone identifier file.
            string identifierFile = Path.Combine(cloneProject.projectPath, ClonesManager.CloneFileName);
            File.Create(identifierFile).Dispose();

            //Add argument file with default argument
            string argumentFilePath = Path.Combine(cloneProject.projectPath, ClonesManager.ArgumentFileName);
            File.WriteAllText(argumentFilePath, DefaultArgument, System.Text.Encoding.UTF8);

            /// Add collabignore.txt to stop the clone from messing with Unity Collaborate if it's enabled. Just in case.
            string collabignoreFile = Path.Combine(cloneProject.projectPath, "collabignore.txt");
            File.WriteAllText(collabignoreFile, "*"); /// Make it ignore ALL files in the clone.
        }

        /// <summary>
        /// Opens a project located at the given path (if one exists).
        /// </summary>
        /// <param name="projectPath"></param>
        public static void OpenProject(string projectPath)
        {
            if (!Directory.Exists(projectPath))
            {
                Debug.LogError("Cannot open the project - provided folder (" + projectPath + ") does not exist.");
                return;
            }

            if (projectPath == ClonesManager.GetCurrentProjectPath())
            {
                Debug.LogError("Cannot open the project - it is already open.");
                return;
            }

            //Validate (and update if needed) the "Packages" folder before opening clone project to ensure the clone project will have the 
            //same "compiling environment" as the original project
            ValidateCopiedFoldersIntegrity.ValidateFolder(projectPath, GetOriginalProjectPath(), "Packages");

            string fileName = GetApplicationPath();
            string args = "-projectPath \"" + projectPath + "\"";
            Debug.Log("Opening project \"" + fileName + " " + args + "\"");
            ClonesManager.StartHiddenConsoleProcess(fileName, args);
        }

        private static string GetApplicationPath()
        {
            switch (Application.platform)
            {
                case RuntimePlatform.WindowsEditor:
                    return EditorApplication.applicationPath;
                case RuntimePlatform.OSXEditor:
                    return EditorApplication.applicationPath + "/Contents/MacOS/Unity";
                case RuntimePlatform.LinuxEditor:
                    return EditorApplication.applicationPath;
                default:
                    throw new System.NotImplementedException("Platform has not supported yet ;(");
            }
        }

        /// <summary>
        /// Is this project being opened by an Unity editor?
        /// </summary>
        /// <param name="projectPath"></param>
        /// <returns></returns>
        public static bool IsCloneProjectRunning(string projectPath)
        {

            //Determine whether it is opened in another instance by checking the UnityLockFile
            string UnityLockFilePath = new string[] { projectPath, "Temp", "UnityLockfile" }
                .Aggregate(Path.Combine);

            switch (Application.platform)
            {
                case (RuntimePlatform.WindowsEditor):
                    //Windows editor will lock "UnityLockfile" file when project is being opened.
                    //Sometime, for instance: windows editor crash, the "UnityLockfile" will not be deleted even the project
                    //isn't being opened, so a check to the "UnityLockfile" lock status may be necessary.
                    if (Preferences.AlsoCheckUnityLockFileStaPref.Value)
                        return File.Exists(UnityLockFilePath) && FileUtilities.IsFileLocked(UnityLockFilePath);
                    else
                        return File.Exists(UnityLockFilePath);
                case (RuntimePlatform.OSXEditor):
                    //Mac editor won't lock "UnityLockfile" file when project is being opened
                    return File.Exists(UnityLockFilePath);
                case (RuntimePlatform.LinuxEditor):
                    return File.Exists(UnityLockFilePath);
                default:
                    throw new System.NotImplementedException("IsCloneProjectRunning: Unsupport Platfrom: " + Application.platform);
            }
        }

        /// <summary>
        /// Deletes the clone of the currently open project, if such exists.
        /// </summary>
        public static void DeleteClone(string cloneProjectPath)
        {
            /// Clone won't be able to delete itself.
            if (ClonesManager.IsClone()) return;

            ///Extra precautions.
            if (cloneProjectPath == string.Empty) return;
            if (cloneProjectPath == ClonesManager.GetOriginalProjectPath()) return;

            //Check what OS is
            string identifierFile;
            string args;
            switch (Application.platform)
            {
                case (RuntimePlatform.WindowsEditor):
                    Debug.Log("Attempting to delete folder \"" + cloneProjectPath + "\"");

                    //The argument file will be deleted first at the beginning of the project deletion process 
                    //to prevent any further reading and writing to it(There's a File.Exist() check at the (file)editor windows.)
                    //If there's any file in the directory being write/read during the deletion process, the directory can't be fully removed.
                    identifierFile = Path.Combine(cloneProjectPath, ClonesManager.ArgumentFileName);
                    File.Delete(identifierFile);

                    args = "/c " + @"rmdir /s/q " + string.Format("\"{0}\"", cloneProjectPath);
                    StartHiddenConsoleProcess("cmd.exe", args);

                    break;
                case (RuntimePlatform.OSXEditor):
                    Debug.Log("Attempting to delete folder \"" + cloneProjectPath + "\"");

                    //The argument file will be deleted first at the beginning of the project deletion process 
                    //to prevent any further reading and writing to it(There's a File.Exist() check at the (file)editor windows.)
                    //If there's any file in the directory being write/read during the deletion process, the directory can't be fully removed.
                    identifierFile = Path.Combine(cloneProjectPath, ClonesManager.ArgumentFileName);
                    File.Delete(identifierFile);

                    FileUtil.DeleteFileOrDirectory(cloneProjectPath);

                    break;
                case (RuntimePlatform.LinuxEditor):
                    Debug.Log("Attempting to delete folder \"" + cloneProjectPath + "\"");
                    identifierFile = Path.Combine(cloneProjectPath, ClonesManager.ArgumentFileName);
                    File.Delete(identifierFile);

                    FileUtil.DeleteFileOrDirectory(cloneProjectPath);

                    break;
                default:
                    Debug.LogWarning("Not in a known editor. Where are you!?");
                    break;
            }
        }

        #endregion

        #region Creating project folders

        /// <summary>
        /// Creates an empty folder using data in the given Project object
        /// </summary>
        /// <param name="project"></param>
        public static void CreateProjectFolder(Project project)
        {
            string path = project.projectPath;
            Debug.Log("Creating new empty folder at: " + path);
            Directory.CreateDirectory(path);
        }

        /// <summary>
        /// Copies the full contents of the unity library. We want to do this to avoid the lengthy re-serialization of the whole project when it opens up the clone.
        /// </summary>
        /// <param name="sourceProject"></param>
        /// <param name="destinationProject"></param>
        [System.Obsolete]
        public static void CopyLibraryFolder(Project sourceProject, Project destinationProject)
        {
            if (Directory.Exists(destinationProject.libraryPath))
            {
                Debug.LogWarning("Library copy: destination path already exists! ");
                return;
            }

            Debug.Log("Library copy: " + destinationProject.libraryPath);
            ClonesManager.CopyDirectoryWithProgressBar(sourceProject.libraryPath, destinationProject.libraryPath,
                "Cloning project '" + sourceProject.name + "'. ");
        }

        #endregion

        #region Creating symlinks

        /// <summary>
        /// Creates a symlink between destinationPath and sourcePath (Mac version).
        /// </summary>
        /// <param name="sourcePath"></param>
        /// <param name="destinationPath"></param>
        private static void CreateLinkMac(string sourcePath, string destinationPath)
        {
            sourcePath = sourcePath.Replace(" ", "\\ ");
            destinationPath = destinationPath.Replace(" ", "\\ ");
            var command = string.Format("ln -s {0} {1}", sourcePath, destinationPath);

            Debug.Log("Mac hard link " + command);

            ClonesManager.ExecuteBashCommand(command);
        }

        /// <summary>
        /// Creates a symlink between destinationPath and sourcePath (Linux version).
        /// </summary>
        /// <param name="sourcePath"></param>
        /// <param name="destinationPath"></param>
        private static void CreateLinkLinux(string sourcePath, string destinationPath)
        {
            sourcePath = sourcePath.Replace(" ", "\\ ");
            destinationPath = destinationPath.Replace(" ", "\\ ");
            var command = string.Format("ln -s {0} {1}", sourcePath, destinationPath);           

            Debug.Log("Linux Symlink " + command);

            ClonesManager.ExecuteBashCommand(command);
        }

        /// <summary>
        /// Creates a symlink between destinationPath and sourcePath (Windows version).
        /// </summary>
        /// <param name="sourcePath"></param>
        /// <param name="destinationPath"></param>
        private static void CreateLinkWin(string sourcePath, string destinationPath)
        {
            string cmd = "/C mklink /J " + string.Format("\"{0}\" \"{1}\"", destinationPath, sourcePath);
            Debug.Log("Windows junction: " + cmd);
            ClonesManager.StartHiddenConsoleProcess("cmd.exe", cmd);
        }

        //TODO(?) avoid terminal calls and use proper api stuff. See below for windows! 
        ////https://docs.microsoft.com/en-us/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol
        //[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        //private static extern bool DeviceIoControl(System.IntPtr hDevice, uint dwIoControlCode,
        //	System.IntPtr InBuffer, int nInBufferSize,
        //	System.IntPtr OutBuffer, int nOutBufferSize,
        //	out int pBytesReturned, System.IntPtr lpOverlapped);

        /// <summary>
        /// Create a link / junction from the original project to it's clone.
        /// </summary>
        /// <param name="sourcePath"></param>
        /// <param name="destinationPath"></param>
        public static void LinkFolders(string sourcePath, string destinationPath)
        {
            if ((Directory.Exists(destinationPath) == false) && (Directory.Exists(sourcePath) == true))
            {
                switch (Application.platform)
                {
                    case (RuntimePlatform.WindowsEditor):
                        CreateLinkWin(sourcePath, destinationPath);
                        break;
                    case (RuntimePlatform.OSXEditor):
                        CreateLinkMac(sourcePath, destinationPath);
                        break;
                    case (RuntimePlatform.LinuxEditor):
                        CreateLinkLinux(sourcePath, destinationPath);
                        break;
                    default:
                        Debug.LogWarning("Not in a known editor. Application.platform: " + Application.platform);
                        break;
                }
            }
            else
            {
                Debug.LogWarning("Skipping Asset link, it already exists: " + destinationPath);
            }
        }

        #endregion

        #region Utility methods

        private static bool? isCloneFileExistCache = null;

        /// <summary>
        /// Returns true if the project currently open in Unity Editor is a clone.
        /// </summary>
        /// <returns></returns>
        public static bool IsClone()
        {
            if (isCloneFileExistCache == null)
            {
                /// The project is a clone if its root directory contains an empty file named ".clone".
                string cloneFilePath = Path.Combine(ClonesManager.GetCurrentProjectPath(), ClonesManager.CloneFileName);
                isCloneFileExistCache = File.Exists(cloneFilePath);
            }

            return (bool)isCloneFileExistCache;
        }

        /// <summary>
        /// Get the path to the current unityEditor project folder's info
        /// </summary>
        /// <returns></returns>
        public static string GetCurrentProjectPath()
        {
            return Application.dataPath.Replace("/Assets", "");
        }

        /// <summary>
        /// Return a project object that describes all the paths we need to clone it.
        /// </summary>
        /// <returns></returns>
        public static Project GetCurrentProject()
        {
            string pathString = ClonesManager.GetCurrentProjectPath();
            return new Project(pathString);
        }

        /// <summary>
        /// Get the argument of this clone project.
        /// If this is the original project, will return an empty string.
        /// </summary>
        /// <returns></returns>
        public static string GetArgument()
        {
            string argument = "";
            if (IsClone())
            {
                string argumentFilePath = Path.Combine(GetCurrentProjectPath(), ClonesManager.ArgumentFileName);
                if (File.Exists(argumentFilePath))
                {
                    argument = File.ReadAllText(argumentFilePath, System.Text.Encoding.UTF8);
                }
            }

            return argument;
        }

        /// <summary>
        /// Returns the path to the original project.
        /// If currently open project is the original, returns its own path.
        /// If the original project folder cannot be found, retuns an empty string.
        /// </summary>
        /// <returns></returns>
        public static string GetOriginalProjectPath()
        {
            if (IsClone())
            {
                /// If this is a clone...
                /// Original project path can be deduced by removing the suffix from the clone's path.
                string cloneProjectPath = ClonesManager.GetCurrentProject().projectPath;

                int index = cloneProjectPath.LastIndexOf(ClonesManager.CloneNameSuffix);
                if (index > 0)
                {
                    string originalProjectPath = cloneProjectPath.Substring(0, index);
                    if (Directory.Exists(originalProjectPath)) return originalProjectPath;
                }

                return string.Empty;
            }
            else
            {
                /// If this is the original, we return its own path.
                return ClonesManager.GetCurrentProjectPath();
            }
        }

        /// <summary>
        /// Returns all clone projects path.
        /// </summary>
        /// <returns></returns>
        public static List<string> GetCloneProjectsPath()
        {
            List<string> projectsPath = new List<string>();
            for (int i = 0; i < MaxCloneProjectCount; i++)
            {
                string originalProjectPath = ClonesManager.GetCurrentProject().projectPath;
                string cloneProjectPath = originalProjectPath + ClonesManager.CloneNameSuffix + "_" + i;

                if (Directory.Exists(cloneProjectPath))
                    projectsPath.Add(cloneProjectPath);
            }

            return projectsPath;
        }

        /// <summary>
        /// Copies directory located at sourcePath to destinationPath. Displays a progress bar.
        /// </summary>
        /// <param name="source">Directory to be copied.</param>
        /// <param name="destination">Destination directory (created automatically if needed).</param>
        /// <param name="progressBarPrefix">Optional string added to the beginning of the progress bar window header.</param>
        public static void CopyDirectoryWithProgressBar(string sourcePath, string destinationPath,
            string progressBarPrefix = "")
        {
            var source = new DirectoryInfo(sourcePath);
            var destination = new DirectoryInfo(destinationPath);

            long totalBytes = 0;
            long copiedBytes = 0;

            ClonesManager.CopyDirectoryWithProgressBarRecursive(source, destination, ref totalBytes, ref copiedBytes,
                progressBarPrefix);
            EditorUtility.ClearProgressBar();
        }

        /// <summary>
        /// Copies directory located at sourcePath to destinationPath. Displays a progress bar.
        /// Same as the previous method, but uses recursion to copy all nested folders as well.
        /// </summary>
        /// <param name="source">Directory to be copied.</param>
        /// <param name="destination">Destination directory (created automatically if needed).</param>
        /// <param name="totalBytes">Total bytes to be copied. Calculated automatically, initialize at 0.</param>
        /// <param name="copiedBytes">To track already copied bytes. Calculated automatically, initialize at 0.</param>
        /// <param name="progressBarPrefix">Optional string added to the beginning of the progress bar window header.</param>
        private static void CopyDirectoryWithProgressBarRecursive(DirectoryInfo source, DirectoryInfo destination,
            ref long totalBytes, ref long copiedBytes, string progressBarPrefix = "")
        {
            /// Directory cannot be copied into itself.
            if (source.FullName.ToLower() == destination.FullName.ToLower())
            {
                Debug.LogError("Cannot copy directory into itself.");
                return;
            }

            /// Calculate total bytes, if required.
            if (totalBytes == 0)
            {
                totalBytes = ClonesManager.GetDirectorySize(source, true, progressBarPrefix);
            }

            /// Create destination directory, if required.
            if (!Directory.Exists(destination.FullName))
            {
                Directory.CreateDirectory(destination.FullName);
            }

            /// Copy all files from the source.
            foreach (FileInfo file in source.GetFiles())
            {
                try
                {
                    file.CopyTo(Path.Combine(destination.ToString(), file.Name), true);
                }
                catch (IOException)
                {
                    /// Some files may throw IOException if they are currently open in Unity editor.
                    /// Just ignore them in such case.
                }

                /// Account the copied file size.
                copiedBytes += file.Length;

                /// Display the progress bar.
                float progress = (float)copiedBytes / (float)totalBytes;
                bool cancelCopy = EditorUtility.DisplayCancelableProgressBar(
                    progressBarPrefix + "Copying '" + source.FullName + "' to '" + destination.FullName + "'...",
                    "(" + (progress * 100f).ToString("F2") + "%) Copying file '" + file.Name + "'...",
                    progress);
                if (cancelCopy) return;
            }

            /// Copy all nested directories from the source.
            foreach (DirectoryInfo sourceNestedDir in source.GetDirectories())
            {
                DirectoryInfo nextDestingationNestedDir = destination.CreateSubdirectory(sourceNestedDir.Name);
                ClonesManager.CopyDirectoryWithProgressBarRecursive(sourceNestedDir, nextDestingationNestedDir,
                    ref totalBytes, ref copiedBytes, progressBarPrefix);
            }
        }

        /// <summary>
        /// Calculates the size of the given directory. Displays a progress bar.
        /// </summary>
        /// <param name="directory">Directory, which size has to be calculated.</param>
        /// <param name="includeNested">If true, size will include all nested directories.</param>
        /// <param name="progressBarPrefix">Optional string added to the beginning of the progress bar window header.</param>
        /// <returns>Size of the directory in bytes.</returns>
        private static long GetDirectorySize(DirectoryInfo directory, bool includeNested = false,
            string progressBarPrefix = "")
        {
            EditorUtility.DisplayProgressBar(progressBarPrefix + "Calculating size of directories...",
                "Scanning '" + directory.FullName + "'...", 0f);

            /// Calculate size of all files in directory.
            long filesSize = directory.GetFiles().Sum((FileInfo file) => file.Length);

            /// Calculate size of all nested directories.
            long directoriesSize = 0;
            if (includeNested)
            {
                IEnumerable<DirectoryInfo> nestedDirectories = directory.GetDirectories();
                foreach (DirectoryInfo nestedDir in nestedDirectories)
                {
                    directoriesSize += ClonesManager.GetDirectorySize(nestedDir, true, progressBarPrefix);
                }
            }

            return filesSize + directoriesSize;
        }

        /// <summary>
        /// Starts process in the system console, taking the given fileName and args.
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="args"></param>
        private static void StartHiddenConsoleProcess(string fileName, string args)
        {
            System.Diagnostics.Process.Start(fileName, args);
        }

        /// <summary>
        /// Thanks to https://github.com/karl-/unity-symlink-utility/blob/master/SymlinkUtility.cs
        /// </summary>
        /// <param name="command"></param>
        private static void ExecuteBashCommand(string command)
        {
            command = command.Replace("\"", "\"\"");

            var proc = new Process()
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "/bin/bash",
                    Arguments = "-c \"" + command + "\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                }
            };

            using (proc)
            {
                proc.Start();
                proc.WaitForExit();

                if (!proc.StandardError.EndOfStream)
                {
                    UnityEngine.Debug.LogError(proc.StandardError.ReadToEnd());
                }
            }
        }

        public static void OpenProjectInFileExplorer(string path)
        {
            System.Diagnostics.Process.Start(@path);
        }
        #endregion
    }
}

'''
'''--- Assets/ParrelSync/ParrelSync/Editor/ClonesManagerWindow.cs ---
﻿using UnityEngine;
using UnityEditor;
using System.IO;

namespace ParrelSync
{
    /// <summary>
    ///Clones manager Unity editor window
    /// </summary>
	public class ClonesManagerWindow : EditorWindow
    {
        /// <summary>
        /// Returns true if project clone exists.
        /// </summary>
        public bool isCloneCreated
        {
            get { return ClonesManager.GetCloneProjectsPath().Count >= 1; }
        }

        [MenuItem("ParrelSync/Clones Manager", priority = 0)]
        private static void InitWindow()
        {
            ClonesManagerWindow window = (ClonesManagerWindow)EditorWindow.GetWindow(typeof(ClonesManagerWindow));
            window.titleContent = new GUIContent("Clones Manager");
            window.Show();
        }

        /// <summary>
        /// For storing the scroll position of clones list
        /// </summary>
        Vector2 clonesScrollPos;

        private void OnGUI()
        {
            /// If it is a clone project...
            if (ClonesManager.IsClone())
            {
                //Find out the original project name and show the help box
                string originalProjectPath = ClonesManager.GetOriginalProjectPath();
                if (originalProjectPath == string.Empty)
                {
                    /// If original project cannot be found, display warning message.
                    EditorGUILayout.HelpBox(
                        "This project is a clone, but the link to the original seems lost.\nYou have to manually open the original and create a new clone instead of this one.\n",
                        MessageType.Warning);
                }
                else
                {
                    /// If original project is present, display some usage info.
                    EditorGUILayout.HelpBox(
                        "This project is a clone of the project '" + Path.GetFileName(originalProjectPath) + "'.\nIf you want to make changes the project files or manage clones, please open the original project through Unity Hub.",
                        MessageType.Info);
                }

                //Clone project custom argument.
                GUILayout.BeginHorizontal();
                EditorGUILayout.LabelField("Arguments", GUILayout.Width(70));
                if (GUILayout.Button("?", GUILayout.Width(20)))
                {
                    Application.OpenURL(ExternalLinks.CustomArgumentHelpLink);
                }
                GUILayout.EndHorizontal();

                string argumentFilePath = Path.Combine(ClonesManager.GetCurrentProjectPath(), ClonesManager.ArgumentFileName);
                //Need to be careful with file reading / writing since it will effect the deletion of
                //  the clone project(The directory won't be fully deleted if there's still file inside being read or write).
                //The argument file will be deleted first at the beginning of the project deletion process
                //to prevent any further being read and write.
                //Will need to take some extra cautious if want to change the design of how file editing is handled.
                if (File.Exists(argumentFilePath))
                {
                    string argument = File.ReadAllText(argumentFilePath, System.Text.Encoding.UTF8);
                    string argumentTextAreaInput = EditorGUILayout.TextArea(argument,
                        GUILayout.Height(50),
                        GUILayout.MaxWidth(300)
                    );
                    File.WriteAllText(argumentFilePath, argumentTextAreaInput, System.Text.Encoding.UTF8);
                }
                else
                {
                    EditorGUILayout.LabelField("No argument file found.");
                }
            }
            else// If it is an original project...
            {
                if (isCloneCreated)
                {
                    GUILayout.BeginVertical("HelpBox");
                    GUILayout.Label("Clones of this Project");

                    //List all clones
                    clonesScrollPos =
                         EditorGUILayout.BeginScrollView(clonesScrollPos);
                    var cloneProjectsPath = ClonesManager.GetCloneProjectsPath();
                    for (int i = 0; i < cloneProjectsPath.Count; i++)
                    {

                        GUILayout.BeginVertical("GroupBox");
                        string cloneProjectPath = cloneProjectsPath[i];

                        bool isOpenInAnotherInstance = ClonesManager.IsCloneProjectRunning(cloneProjectPath);

                        if (isOpenInAnotherInstance == true)
                            EditorGUILayout.LabelField("Clone " + i + " (Running)", EditorStyles.boldLabel);
                        else
                            EditorGUILayout.LabelField("Clone " + i);

                        GUILayout.BeginHorizontal();
                        EditorGUILayout.TextField("Clone project path", cloneProjectPath, EditorStyles.textField);
                        if (GUILayout.Button("View Folder", GUILayout.Width(80)))
                        {
                            ClonesManager.OpenProjectInFileExplorer(cloneProjectPath);
                        }
                        GUILayout.EndHorizontal();

                        GUILayout.BeginHorizontal();
                        EditorGUILayout.LabelField("Arguments", GUILayout.Width(70));
                        if (GUILayout.Button("?", GUILayout.Width(20)))
                        {
                            Application.OpenURL(ExternalLinks.CustomArgumentHelpLink);
                        }
                        GUILayout.EndHorizontal();

                        string argumentFilePath = Path.Combine(cloneProjectPath, ClonesManager.ArgumentFileName);
                        //Need to be careful with file reading/writing since it will effect the deletion of
                        //the clone project(The directory won't be fully deleted if there's still file inside being read or write).
                        //The argument file will be deleted first at the beginning of the project deletion process 
                        //to prevent any further being read and write.
                        //Will need to take some extra cautious if want to change the design of how file editing is handled.
                        if (File.Exists(argumentFilePath))
                        {
                            string argument = File.ReadAllText(argumentFilePath, System.Text.Encoding.UTF8);
                            string argumentTextAreaInput = EditorGUILayout.TextArea(argument,
                                GUILayout.Height(50),
                                GUILayout.MaxWidth(300)
                            );
                            File.WriteAllText(argumentFilePath, argumentTextAreaInput, System.Text.Encoding.UTF8);
                        }
                        else
                        {
                            EditorGUILayout.LabelField("No argument file found.");
                        }

                        EditorGUILayout.Space();
                        EditorGUILayout.Space();
                        EditorGUILayout.Space();

                        EditorGUI.BeginDisabledGroup(isOpenInAnotherInstance);

                        if (GUILayout.Button("Open in New Editor"))
                        {
                            ClonesManager.OpenProject(cloneProjectPath);
                        }

                        GUILayout.BeginHorizontal();
                        if (GUILayout.Button("Delete"))
                        {
                            bool delete = EditorUtility.DisplayDialog(
                                "Delete the clone?",
                                "Are you sure you want to delete the clone project '" + ClonesManager.GetCurrentProject().name + "_clone'?",
                                "Delete",
                                "Cancel");
                            if (delete)
                            {
                                ClonesManager.DeleteClone(cloneProjectPath);
                            }
                        }

                        GUILayout.EndHorizontal();
                        EditorGUI.EndDisabledGroup();
                        GUILayout.EndVertical();

                    }
                    EditorGUILayout.EndScrollView();

                    if (GUILayout.Button("Add new clone"))
                    {
                        ClonesManager.CreateCloneFromCurrent();
                    }

                    GUILayout.EndVertical();
                    GUILayout.FlexibleSpace();
                }
                else
                {
                    /// If no clone created yet, we must create it.
                    EditorGUILayout.HelpBox("No project clones found. Create a new one!", MessageType.Info);
                    if (GUILayout.Button("Create new clone"))
                    {
                        ClonesManager.CreateCloneFromCurrent();
                    }
                }
            }
        }
    }
}

'''
'''--- Assets/ParrelSync/ParrelSync/Editor/ExternalLinks.cs ---
﻿namespace ParrelSync
{
    public class ExternalLinks 
    {
        public const string RemoteVersionURL = "https://raw.githubusercontent.com/VeriorPies/ParrelSync/master/VERSION.txt";
        public const string Releases = "https://github.com/VeriorPies/ParrelSync/releases";
        public const string CustomArgumentHelpLink = "https://github.com/VeriorPies/ParrelSync/wiki/Argument";

        public const string GitHubHome = "https://github.com/VeriorPies/ParrelSync/";
        public const string GitHubIssue = "https://github.com/VeriorPies/ParrelSync/issues";
        public const string FAQ = "https://github.com/VeriorPies/ParrelSync/wiki/Troubleshooting-&-FAQs";
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/Editor/FileUtilities.cs ---
﻿using System.IO;
using UnityEngine;

namespace ParrelSync
{
    public class FileUtilities : MonoBehaviour
    {
        public static bool IsFileLocked(string path)
        {
            FileInfo file = new FileInfo(path);
            try
            {
                using (FileStream stream = file.Open(FileMode.Open, FileAccess.Read, FileShare.None))
                {
                    stream.Close();
                }
            }
            catch (IOException)
            {
                //the file is unavailable because it is:
                //still being written to
                //or being processed by another thread
                //or does not exist (has already been processed)
                return true;
            }

            //file is not locked
            return false;
        }
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/Editor/NonCore/AskFeedbackDialog.cs ---
﻿namespace ParrelSync.NonCore
{
    using UnityEditor;
    using UnityEngine;

    /// <summary>
    /// A simple script to display feedback/star dialog after certain time of project being opened/re-compiled.
    /// Will only pop-up once unless "Remind me next time" are chosen.
    /// Removing this file from project wont effect any other functions.
    /// </summary>
    [InitializeOnLoad]
    public class AskFeedbackDialog
    {
        const string InitializeOnLoadCountKey = "ParrelSync_InitOnLoadCount", StopShowingKey = "ParrelSync_StopShowFeedBack";
        static AskFeedbackDialog()
        {            
            if (EditorPrefs.HasKey(StopShowingKey)) { return; }

            int InitializeOnLoadCount = EditorPrefs.GetInt(InitializeOnLoadCountKey, 0);
            if (InitializeOnLoadCount > 20)
            {
                ShowDialog();
            }
            else
            {
                EditorPrefs.SetInt(InitializeOnLoadCountKey, InitializeOnLoadCount + 1);
            }
        }

        //[MenuItem("ParrelSync/(Debug)Show AskFeedbackDialog ")]
        private static void ShowDialog()
        {
            int option = EditorUtility.DisplayDialogComplex("Do you like " + ParrelSync.ClonesManager.ProjectName + "?",
                   "Do you like " + ParrelSync.ClonesManager.ProjectName + "?\n" +
                   "If so, please don't hesitate to star it on GitHub and contribute to the project!",
                   "Star on GitHub",
                   "Close",
                   "Remind me next time"
               );

            switch (option)
            {
                // First parameter.
                case 0:
                    Debug.Log("AskFeedbackDialog: Star on GitHub selected");
                    EditorPrefs.SetBool(StopShowingKey, true);
                    EditorPrefs.DeleteKey(InitializeOnLoadCountKey);
                    Application.OpenURL(ExternalLinks.GitHubHome);
                    break;
                // Second parameter.
                case 1:
                    Debug.Log("AskFeedbackDialog: Close and never show again.");
                    EditorPrefs.SetBool(StopShowingKey, true);
                    EditorPrefs.DeleteKey(InitializeOnLoadCountKey);
                    break;
                // Third parameter.
                case 2:
                    Debug.Log("AskFeedbackDialog: Remind me next time");
                    EditorPrefs.SetInt(InitializeOnLoadCountKey, 0);
                    break;
                default:
                    //Debug.Log("Close windows.");
                    break;
            }
        }

        ///// <summary>
        ///// For debug purpose
        ///// </summary>
        //[MenuItem("ParrelSync/(Debug)Delete AskFeedbackDialog keys")]
        //private static void DebugDeleteAllKeys()
        //{
        //    EditorPrefs.DeleteKey(InitializeOnLoadCountKey);
        //    EditorPrefs.DeleteKey(StopShowingKey);
        //    Debug.Log("AskFeedbackDialog keys deleted");
        //}
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/Editor/NonCore/OtherMenuItem.cs ---
﻿namespace ParrelSync.NonCore
{
    using UnityEditor;
    using UnityEngine;

    public class OtherMenuItem
    {
        [MenuItem("ParrelSync/GitHub/View this project on GitHub", priority = 10)]
        private static void OpenGitHub()
        {
            Application.OpenURL(ExternalLinks.GitHubHome);
        }

        [MenuItem("ParrelSync/GitHub/View FAQ", priority = 11)]
        private static void OpenFAQ()
        {
            Application.OpenURL(ExternalLinks.FAQ);
        }

        [MenuItem("ParrelSync/GitHub/View Issues", priority = 12)]
        private static void OpenGitHubIssues()
        {
            Application.OpenURL(ExternalLinks.GitHubIssue);
        }
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/Editor/Preferences.cs ---
﻿using UnityEngine;
using UnityEditor;

namespace ParrelSync
{
    /// <summary>
    /// To add value caching for <see cref="EditorPrefs"/> functions
    /// </summary>
    public class BoolPreference
    {
        public string key { get; private set; }
        public bool defaultValue { get; private set; }
        public BoolPreference(string key, bool defaultValue)
        {
            this.key = key;
            this.defaultValue = defaultValue;
        }

        private bool? valueCache = null;

        public bool Value
        {
            get
            {
                if (valueCache == null)
                    valueCache = EditorPrefs.GetBool(key, defaultValue);

                return (bool)valueCache;
            }
            set
            {
                if (valueCache == value)
                    return;

                EditorPrefs.SetBool(key, value);
                valueCache = value;
                Debug.Log("Editor preference updated. key: " + key + ", value: " + value);
            }
        }

        public void ClearValue()
        {
            EditorPrefs.DeleteKey(key);
            valueCache = null;
        }
    }

    public class Preferences : EditorWindow
    {
        [MenuItem("ParrelSync/Preferences", priority = 1)]
        private static void InitWindow()
        {
            Preferences window = (Preferences)EditorWindow.GetWindow(typeof(Preferences));
            window.titleContent = new GUIContent(ClonesManager.ProjectName + " Preferences");
            window.Show();
        }

        /// <summary>
        /// Disable asset saving in clone editors?
        /// </summary>
        public static BoolPreference AssetModPref = new BoolPreference("ParrelSync_DisableClonesAssetSaving", true);

        /// <summary>
        /// In addition of checking the existence of UnityLockFile, 
        /// also check is the is the UnityLockFile being opened.
        /// </summary>
        public static BoolPreference AlsoCheckUnityLockFileStaPref = new BoolPreference("ParrelSync_CheckUnityLockFileOpenStatus", true);

        private void OnGUI()
        {
            if (ClonesManager.IsClone())
            {
                EditorGUILayout.HelpBox(
                        "This is a clone project. Please use the original project editor to change preferences.",
                        MessageType.Info);
                return;
            }

            GUILayout.BeginVertical("HelpBox");
            GUILayout.Label("Preferences");
            GUILayout.BeginVertical("GroupBox");

            AssetModPref.Value = EditorGUILayout.ToggleLeft(
                new GUIContent(
                    "(recommended) Disable asset saving in clone editors- require re-open clone editors",
                    "Disable asset saving in clone editors so all assets can only be modified from the original project editor"
                ),
                AssetModPref.Value);

            if (Application.platform == RuntimePlatform.WindowsEditor)
            {
                AlsoCheckUnityLockFileStaPref.Value = EditorGUILayout.ToggleLeft(
                    new GUIContent(
                        "Also check UnityLockFile lock status while checking clone projects running status",
                        "Disable this can slightly increase Clones Manager window performance, but will lead to in-correct clone project running status" +
                        "(the Clones Manager window show the clone project is still running even it's not) if the clone editor crashed"
                    ),
                    AlsoCheckUnityLockFileStaPref.Value);
            }
            GUILayout.EndVertical();
            if (GUILayout.Button("Reset to default"))
            {
                AssetModPref.ClearValue();
                AlsoCheckUnityLockFileStaPref.ClearValue();
                Debug.Log("Editor preferences cleared");
            }
            GUILayout.EndVertical();
        }
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/Editor/Project.cs ---
﻿using System.Collections.Generic;
using System.Linq;

namespace ParrelSync
{
    public class Project : System.ICloneable
    {
        public string name;
        public string projectPath;
        string rootPath;
        public string assetPath;
        public string projectSettingsPath;
        public string libraryPath;
        public string packagesPath;
        public string autoBuildPath;
        public string localPackages;

        char[] separator = new char[1] { '/' };

        /// <summary>
        /// Default constructor
        /// </summary>
        public Project()
        {

        }

        /// <summary>
        /// Initialize the project object by parsing its full path returned by Unity into a bunch of individual folder names and paths.
        /// </summary>
        /// <param name="path"></param>
        public Project(string path)
        {
            ParsePath(path);
        }

        /// <summary>
        /// Create a new object with the same settings
        /// </summary>
        /// <returns></returns>
        public object Clone()
        {
            Project newProject = new Project();
            newProject.rootPath = rootPath;
            newProject.projectPath = projectPath;
            newProject.assetPath = assetPath;
            newProject.projectSettingsPath = projectSettingsPath;
            newProject.libraryPath = libraryPath;
            newProject.name = name;
            newProject.separator = separator;
            newProject.packagesPath = packagesPath;
            newProject.autoBuildPath = autoBuildPath;
            newProject.localPackages = localPackages;

            return newProject;
        }

        /// <summary>
        /// Update the project object by renaming and reparsing it. Pass in the new name of a project, and it'll update the other member variables to match.
        /// </summary>
        /// <param name="name"></param>
        public void updateNewName(string newName)
        {
            name = newName;
            ParsePath(rootPath + "/" + name + "/Assets");
        }

        /// <summary>
        /// Debug override so we can quickly print out the project info.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            string printString = name + "\n" +
                                 rootPath + "\n" +
                                 projectPath + "\n" +
                                 assetPath + "\n" +
                                 projectSettingsPath + "\n" +
                                 packagesPath + "\n" +
                                 autoBuildPath + "\n" +
                                 localPackages + "\n" +
                                 libraryPath;
            return (printString);
        }

        private void ParsePath(string path)
        {
            //Unity's Application functions return the Assets path in the Editor. 
            projectPath = path;

            //pop off the last part of the path for the project name, keep the rest for the root path
            List<string> pathArray = projectPath.Split(separator).ToList<string>();
            name = pathArray.Last();

            pathArray.RemoveAt(pathArray.Count() - 1);
            rootPath = string.Join(separator[0].ToString(), pathArray.ToArray());

            assetPath = projectPath + "/Assets";
            projectSettingsPath = projectPath + "/ProjectSettings";
            libraryPath = projectPath + "/Library";
            packagesPath = projectPath + "/Packages";
            autoBuildPath = projectPath + "/AutoBuild";
            localPackages = projectPath + "/LocalPackages";
        }
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/Editor/UpdateChecker.cs ---
﻿using System;
using UnityEditor;
using UnityEngine;
namespace ParrelSync.Update
{
    /// <summary>
    /// A simple update checker
    /// </summary>
    public class UpdateChecker
    {
        //const string LocalVersionFilePath = "Assets/ParrelSync/VERSION.txt";
        public const string LocalVersion = "1.5.1";
        [MenuItem("ParrelSync/Check for update", priority = 20)]
        static void CheckForUpdate()
        {
            using (System.Net.WebClient client = new System.Net.WebClient())
            {
                try
                {
                    //This won't work with UPM packages
                    //string localVersionText = AssetDatabase.LoadAssetAtPath<TextAsset>(LocalVersionFilePath).text;

                    string localVersionText = LocalVersion;
                    Debug.Log("Local version text : " + LocalVersion);

                    string latesteVersionText = client.DownloadString(ExternalLinks.RemoteVersionURL);
                    Debug.Log("latest version text got: " + latesteVersionText);
                    string messageBody = "Current Version: " + localVersionText +"\n"
                                         +"Latest Version: " + latesteVersionText + "\n";
                    var latestVersion = new Version(latesteVersionText);
                    var localVersion = new Version(localVersionText);

                    if (latestVersion > localVersion)
                    {
                        Debug.Log("There's a newer version");
                        messageBody += "There's a newer version available";
                        if(EditorUtility.DisplayDialog("Check for update.", messageBody, "Get latest release", "Close"))
                        {
                            Application.OpenURL(ExternalLinks.Releases);
                        }
                    }
                    else
                    {
                        Debug.Log("Current version is up-to-date.");
                        messageBody += "Current version is up-to-date.";
                        EditorUtility.DisplayDialog("Check for update.", messageBody,"OK");
                    }
                    
                }
                catch (Exception exp)
                {
                    Debug.LogError("Error with checking update. Exception: " + exp);
                    EditorUtility.DisplayDialog("Update Error","Error with checking update. \nSee console for more details.",
                     "OK"
                    );
                }
            }
        }
    }
}

'''
'''--- Assets/ParrelSync/ParrelSync/Editor/ValidateCopiedFoldersIntegrity.cs ---
namespace ParrelSync
{
    using UnityEditor;
    using UnityEngine;
    using System;
    using System.Text;
    using System.Security.Cryptography;
    using System.IO;
    using System.Linq;

    [InitializeOnLoad]
    public class ValidateCopiedFoldersIntegrity
    {
        const string SessionStateKey = "ValidateCopiedFoldersIntegrity_Init";
        /// <summary>
        /// Called once on editor startup.
        /// Validate copied folders integrity in clone project
        /// </summary>
        static ValidateCopiedFoldersIntegrity()
        {
            if (!SessionState.GetBool(SessionStateKey, false))
            {
                SessionState.SetBool(SessionStateKey, true);
                if (!ClonesManager.IsClone()) { return; }

                ValidateFolder(ClonesManager.GetCurrentProjectPath(), ClonesManager.GetOriginalProjectPath(), "Packages");
            }
        }

        public static void ValidateFolder(string targetRoot, string originalRoot, string folderName)
        {
            var targetFolderPath = Path.Combine(targetRoot, folderName);
            var targetFolderHash = CreateMd5ForFolder(targetFolderPath);

            var originalFolderPath = Path.Combine(originalRoot, folderName);
            var originalFolderHash = CreateMd5ForFolder(originalFolderPath);

            if (targetFolderHash != originalFolderHash)
            {
                Debug.Log("ParrelSync: Detected changes in '" + folderName + "' directory. Updating cloned project...");
                FileUtil.ReplaceDirectory(originalFolderPath, targetFolderPath);
            }
        }

        static string CreateMd5ForFolder(string path)
        {
            // assuming you want to include nested folders
            var files = Directory.GetFiles(path, "*.*", SearchOption.AllDirectories)
                                 .OrderBy(p => p).ToList();

            MD5 md5 = MD5.Create();

            for (int i = 0; i < files.Count; i++)
            {
                string file = files[i];

                // hash path
                string relativePath = file.Substring(path.Length + 1);
                byte[] pathBytes = Encoding.UTF8.GetBytes(relativePath.ToLower());
                md5.TransformBlock(pathBytes, 0, pathBytes.Length, pathBytes, 0);

                // hash contents
                byte[] contentBytes = File.ReadAllBytes(file);
                if (i == files.Count - 1)
                    md5.TransformFinalBlock(contentBytes, 0, contentBytes.Length);
                else
                    md5.TransformBlock(contentBytes, 0, contentBytes.Length, contentBytes, 0);
            }

            return BitConverter.ToString(md5.Hash).Replace("-", "").ToLower();
        }
    }
}
'''
'''--- Assets/ParrelSync/ParrelSync/package.json ---
{
    "name": "com.veriorpies.parrelsync",
    "displayName": "ParrelSync",
    "version": "1.5.1",
    "unity": "2018.4",
    "description": "ParrelSync is a Unity editor extension that allows users to test multiplayer gameplay without building the project by having another Unity editor window opened and mirror the changes from the original project.",
    "license": "MIT",
	"keywords": [ "Networking", "Utils", "Editor", "Extensions" ],
    "dependencies": {}
}
'''
'''--- Assets/ParrelSync/README.md ---
# ParrelSync 
[![Release](https://img.shields.io/github/v/release/VeriorPies/ParrelSync?include_prereleases)](https://github.com/VeriorPies/ParrelSync/releases) [![Documentation](https://img.shields.io/badge/documentation-brightgreen.svg)](https://github.com/VeriorPies/ParrelSync/wiki) [![License](https://img.shields.io/badge/license-MIT-green)](https://github.com/VeriorPies/ParrelSync/blob/master/LICENSE.md) [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-blue.svg)](https://github.com/VeriorPies/ParrelSync/pulls) [![Chats](https://img.shields.io/discord/710688100996743200)](https://discord.gg/TmQk2qG)  

ParrelSync is a Unity editor extension that allows users to test multiplayer gameplay without building the project by having another Unity editor window opened and mirror the changes from the original project.

<br>

![ShortGif](https://raw.githubusercontent.com/VeriorPies/ParrelSync/master/Images/Showcase%201.gif)
<p align="center">
<b>Test project changes on clients and server within seconds - both in editor
</b>
<br>
</p>

## Features
1. Test multiplayer gameplay without building the project
2. GUI tools for managing all project clones
3. Protected assets from being modified by other clone instances
4. Handy APIs to speed up testing workflows
## Installation

1. Backup your project folder or use a version control system such as [Git](https://git-scm.com/) or [SVN](https://subversion.apache.org/)
2. Download .unitypackage from the [latest release](https://github.com/VeriorPies/ParrelSync/releases) and import it to your project. 
3.  ParrelSync should appreared in the menu item bar after imported
![UpdateButtonInMenu](https://github.com/VeriorPies/ParrelSync/raw/master/Images/AfterImported.png)  

Check out the [Installation-and-Update](https://github.com/VeriorPies/ParrelSync/wiki/Installation-and-Update) page for more details.

### UPM Package
ParrelSync can also be installed via UPM package.  
After Unity 2019.3.4f1, Unity 2020.1a21, which support path query parameter of git package. You can install ParrelSync by adding the following to Package Manager.

```
https://github.com/VeriorPies/ParrelSync.git?path=/ParrelSync
```  

  
![UPM_Image](https://github.com/VeriorPies/ParrelSync/raw/master/Images/UPM_1.png?raw=true) ![UPM_Image2](https://github.com/VeriorPies/ParrelSync/raw/master/Images/UPM_2.png?raw=true)
  
or by adding 

```
"com.veriorpies.parrelsync": "https://github.com/VeriorPies/ParrelSync.git?path=/ParrelSync"
``` 

to the `Packages/manifest.json` file 

## Supported Platform
Currently, ParrelSync supports Windows, macOS and Linux editors.  

ParrelSync has been tested with the following Unity version. However, it should also work with other versions as well.
* *2020.3.1f1*
* *2019.3.0f6*
* *2018.4.22f1*

## APIs
There's some useful APIs for speeding up the multiplayer testing workflow.
Here's a basic example: 
```
if (ClonesManager.IsClone()) {
  // Automatically connect to local host if this is the clone editor
}else{
  // Automatically start server if this is the original editor
}
```
Check out [the doc](https://github.com/VeriorPies/ParrelSync/wiki/List-of-APIs) to view the complete API list.

## How does it work?
For each clone instance, ParrelSync will make a copy of the original project folder and reference the ```Asset```, ```Packages``` and ```ProjectSettings``` folder back to the original project with [symbolic link](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/mklink). Other folders such as ```Library```, ```Temp```, and ```obj``` will remain independent for each clone project.

All clones are placed right next to the original project with suffix *```_clone_x```*, which will be something like this in the folder hierarchy. 
```
/ProjectName
/ProjectName_clone_0
/ProjectName_clone_1
...
```
## Discord Server
We have a [Discord server](https://discord.gg/TmQk2qG).

## Need Help?
Some common questions and troubleshooting can be found under the [Troubleshooting & FAQs](https://github.com/VeriorPies/ParrelSync/wiki/Troubleshooting-&-FAQs) page.  
You can also [create a question post](https://github.com/VeriorPies/ParrelSync/issues/new/choose), or ask on [Discord](https://discord.gg/TmQk2qG) if you prefer to have a real-time conversation.

## Support this project 
A star will be appreciated :)

## Credits
This project is originated from hwaet's [UnityProjectCloner](https://github.com/hwaet/UnityProjectCloner)

'''
'''--- Assets/ParrelSync/VERSION.txt ---
1.5.1
'''
'''--- Assets/RFG/NEAR/Scripts/NearAPI.cs ---
using UnityEngine;
using System.Runtime.InteropServices;

namespace RFG.NEAR
{

  public class NearAPI
  {
    private static string _signedIn = "false";//Just to mimic the actual functionality
    private static string _dummytokens = "[{token_id:'1',metadata:{title:'Fred',media:'https://roguefoxguild.mypinata.cloud/ipfs/QmYMT3s9C4ckQxfMEm7ew4PUVPSrYLeo36uhdhGSctDJdB/Character_1.png'} },{token_id:'2',metadata:{title:'Alice',media:'https://roguefoxguild.mypinata.cloud/ipfs/QmYMT3s9C4ckQxfMEm7ew4PUVPSrYLeo36uhdhGSctDJdB/Character_2.png'}},{token_id:'3',metadata:{title:'Dan',media:'https://roguefoxguild.mypinata.cloud/ipfs/QmYMT3s9C4ckQxfMEm7ew4PUVPSrYLeo36uhdhGSctDJdB/Character_3.png'}}]";

#if !UNITY_EDITOR

    [DllImport("__Internal")]
    public static extern void RequestSignIn(string contractId, string network = "testnet");

    [DllImport("__Internal")]
    public static extern void SignOut(string network = "testnet");

    [DllImport("__Internal")]
    public static extern void IsSignedIn(string network = "testnet");

    [DllImport("__Internal")]
    public static extern void NftTokensForOwner(string accountId, string contractId,string network = "testnet");

    [DllImport("__Internal")]
    public static extern void GetAccountId(string network = "testnet");

#else

    public static void RequestSignIn(string contractId, string network = "testnet")
    {
      Debug.Log("RequestSignIn: " + contractId + " " + network);
      _signedIn = "true";
    }

    public static void SignOut(string network = "testnet")
    {
      Debug.Log("SignOut: " + network);
      _signedIn = "false";
    }

    public static void IsSignedIn(string network = "testnet")
    {
      Debug.Log("IsSignedIn: " + network);
      NearCallbacks.Instance.IsSignedIn(_signedIn);
    }

    public static void GetAccountId(string network = "testnet")
    {
      Debug.Log("GetAccountId: " + network);
      NearCallbacks.Instance.GetAccountId("testing.near");
    }

    public static void NftTokensForOwner(string accountId, string contractId, string network = "testnet")
    {
      Debug.Log("NftTokensForOwner: " + accountId + " " + contractId + " " + network);
      NearCallbacks.Instance.NftTokensForOwner(_dummytokens);
    }

#endif

  }
}
'''
'''--- Assets/RFG/NEAR/Scripts/NearCallbacks.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using Newtonsoft.Json;

namespace RFG.NEAR
{

  [System.Serializable]
  public class Token
  {
    public string token_id;
    public string owner_id;
    public MetaData metadata;
  }

  [System.Serializable]
  public class MetaData
  {
    public string title;
    public string description;
    public string media;
    public string media_hash;
    public string copies;
    public string issued_at;
    public string expires_at;
    public string starts_at;
    public string updated_at;
    public string extra;
    public string reference;
    public string reference_hash;
  }

  public class NearCallbacks : MonoBehaviour
  {
    public static event Action<bool> OnSignIn;
    public static event Action<string> OnGetAccountId;
    public static event Action<Token[]> OnNftTokensForOwner;

    public static NearCallbacks Instance;

    void Awake()
    {
      if (Instance == null)
      {
        Instance = this;
      }
      else
      {
        Destroy(gameObject);
      }
    }

    public void GetAccountId(string accountId)
    {
      Debug.Log("GetAccountId: " + accountId);
      OnGetAccountId?.Invoke(accountId);
    }

    public void IsSignedIn(string signedIn)
    {
      OnSignIn?.Invoke(signedIn == "true");
    }

    public void NftTokensForOwner(string tokens)
    {
      Token[] tokenArray = JsonConvert.DeserializeObject<Token[]>(tokens);
      OnNftTokensForOwner?.Invoke(tokenArray);
    }

  }

}
'''
'''--- Assets/RFG/NEAR/Scripts/NearController.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using RFG.NEAR;
using System.Threading.Tasks;

public class NearController : MonoBehaviour
{
  [SerializeField] private string _contractId = "nft-unity-contract.morganpage1.testnet";
  [SerializeField] private string _network = "testnet";

  [SerializeField] private TMP_Text _textWelcome;
  [SerializeField] private TMP_Text _textTokens;
  [SerializeField] Button _buttonSignInOut;
  [SerializeField] UIToken _uiTokenPrefab;
  [SerializeField] Transform _uiTokenParent;

  private string _accountId;
  private bool _signedIn;

  void OnEnable()
  {
    NearCallbacks.OnSignIn += OnSignIn;
    NearCallbacks.OnGetAccountId += OnGetAccountId;
    NearCallbacks.OnNftTokensForOwner += OnNftTokensForOwner;
  }

  void OnDisable()
  {
    NearCallbacks.OnSignIn -= OnSignIn;
    NearCallbacks.OnGetAccountId -= OnGetAccountId;
    NearCallbacks.OnNftTokensForOwner -= OnNftTokensForOwner;
  }

  void Start()
  {
    NearAPI.IsSignedIn(_network);
  }

  private void OnSignIn(bool signedIn)
  {
    _signedIn = signedIn;
    if (_signedIn)
    {
      NearAPI.GetAccountId(_network);
      _buttonSignInOut.GetComponentInChildren<TMP_Text>().text = "Sign Out";
      _textTokens.text = "Click Get Tokens to continue...";
    }
    else
    {
      _textWelcome.text = "You must sign in...";
      _textTokens.text = "You must sign in...";
      _buttonSignInOut.GetComponentInChildren<TMP_Text>().text = "Sign In";
    }
  }
  private void OnGetAccountId(string accountId)
  {
    _accountId = accountId;
    _textWelcome.text = "Welcome " + _accountId;
  }
  private async void OnNftTokensForOwner(Token[] tokens)
  {
    foreach (Transform child in _uiTokenParent)
    {
      Destroy(child.gameObject);
    }

    foreach (var token in tokens)
    {
      _textTokens.text = "Select a token to continue...";

      // Get the image
      Texture texture = await RestAPI.GetImage(token.metadata.media);
      if (texture != null)
      {
        UIToken uiToken = Instantiate(_uiTokenPrefab);
        uiToken.SetImage(texture);
        uiToken.SetTitle(token.metadata.title);
        uiToken.SetTokenId(token.token_id);
        uiToken.SetButtonListener(OnTokenButtonClicked);
        uiToken.transform.SetParent(_uiTokenParent);
        uiToken.transform.localScale = Vector3.one;
        uiToken.transform.localPosition = Vector3.zero;
        _uiTokenParent.localPosition = Vector3.zero;
      }
    }
  }

  void OnTokenButtonClicked(string tokenId)
  {
    Debug.Log("OnTokenButtonClicked: " + tokenId);
    _textTokens.text = "Token Id: " + tokenId + " was selected!";
  }

  public void NftTokensForOwner()
  {
    if (!_signedIn)
    {
      _textTokens.text = "You must sign in to get tokens...";
      return;
    }
    NearAPI.NftTokensForOwner(_accountId, _contractId, _network);
  }
  public void SignInOut()
  {
    if (_signedIn)
    {
      NearAPI.SignOut(_network);
      NearAPI.IsSignedIn(_network);
    }
    else
    {
      NearAPI.RequestSignIn(_contractId, _network);//This will do a page refresh anyway
      NearAPI.IsSignedIn(_network);
    }
  }

}

'''
'''--- Assets/RFG/NEAR/Scripts/UI/UIToken.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class UIToken : MonoBehaviour
{
  [SerializeField] private TMP_Text _textTokenId;
  [SerializeField] private Image _image;
  [SerializeField] private TMP_Text _textTitle;
  [SerializeField] private Button _button;

  public Button button { get { return _button; } }

  public void SetImage(Texture texture)
  {
    _image.sprite = Sprite.Create((Texture2D)texture, new Rect(0, 0, texture.width, texture.height), Vector2.zero);
  }

  public void SetTitle(string title)
  {
    _textTitle.text = title;
  }

  public void SetTokenId(string tokenId)
  {
    _textTokenId.text = tokenId;
  }

  public void SetButtonListener(System.Action<string> listener)
  {
    _button.onClick.AddListener(() => listener(_textTokenId.text));
  }

}

'''
'''--- Assets/RFG/NEAR/Scripts/Utils/RestAPI.cs ---
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

namespace RFG.NEAR
{

  public class RestAPI
  {
    public const string IPFSURL = "https://cloudflare-ipfs.com/ipfs/";

    async static public Task<Texture> GetImage(string imageIPFS)
    {
      Debug.Log("GetImage: " + imageIPFS);
      imageIPFS = imageIPFS.Replace("///", IPFSURL);
      using (UnityWebRequest webRequest = UnityWebRequestTexture.GetTexture(imageIPFS))
      {
        try
        {
          await webRequest.SendWebRequest();
          Texture texture = DownloadHandlerTexture.GetContent(webRequest);
          return texture;
        }
        catch (System.Exception)
        {
          Debug.Log("Error: " + imageIPFS);
          return null;
        }
      }
    }
  }

}
'''
'''--- Assets/RFG/NEAR/Scripts/Utils/UnityAsyncOperationAwaiter.cs ---
using System.Runtime.CompilerServices; using System.Threading.Tasks; using UnityEngine;

public static class ExtensionMethods
{
    public static TaskAwaiter GetAwaiter(this AsyncOperation asyncOp)
    {
        var tcs = new TaskCompletionSource<object>();
        asyncOp.completed += obj => { tcs.SetResult(null); };
        return ((Task)tcs.Task).GetAwaiter();
    }
}
'''
'''--- Assets/TextMesh Pro/Fonts/LiberationSans - OFL.txt ---
Digitized data copyright (c) 2010 Google Corporation
	with Reserved Font Arimo, Tinos and Cousine.
Copyright (c) 2012 Red Hat, Inc.
	with Reserved Font Name Liberation.

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL

-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.

The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the copyright statement(s).

"Original Version" refers to the collection of Font Software components as distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.

"Author" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.

5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.
'''
'''--- Assets/TextMesh Pro/Resources/LineBreaking Following Characters.txt ---
﻿)]｝〕〉》」』】〙〗〟’”｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、%,.:;。！？］）：；＝}¢°"†‡℃〆％，．
'''
'''--- Assets/TextMesh Pro/Resources/LineBreaking Leading Characters.txt ---
﻿([｛〔〈《「『【〘〖〝‘“｟«$—…‥〳〴〵\［（{£¥"々〇＄￥￦ #
'''
'''--- Assets/TextMesh Pro/Sprites/EmojiOne Attribution.txt ---
This sample of beautiful emojis are provided by EmojiOne https://www.emojione.com/

Please visit their website to view the complete set of their emojis and review their licensing terms.
'''
'''--- Assets/TextMesh Pro/Sprites/EmojiOne.json ---
{"frames": [

{
	"filename": "1f60a.png",
	"frame": {"x":0,"y":0,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f60b.png",
	"frame": {"x":128,"y":0,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f60d.png",
	"frame": {"x":256,"y":0,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f60e.png",
	"frame": {"x":384,"y":0,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f600.png",
	"frame": {"x":0,"y":128,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f601.png",
	"frame": {"x":128,"y":128,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f602.png",
	"frame": {"x":256,"y":128,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f603.png",
	"frame": {"x":384,"y":128,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f604.png",
	"frame": {"x":0,"y":256,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f605.png",
	"frame": {"x":128,"y":256,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f606.png",
	"frame": {"x":256,"y":256,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f609.png",
	"frame": {"x":384,"y":256,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f618.png",
	"frame": {"x":0,"y":384,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "1f923.png",
	"frame": {"x":128,"y":384,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "263a.png",
	"frame": {"x":256,"y":384,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
},
{
	"filename": "2639.png",
	"frame": {"x":384,"y":384,"w":128,"h":128},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
	"sourceSize": {"w":128,"h":128},
	"pivot": {"x":0.5,"y":0.5}
}],
"meta": {
	"app": "http://www.codeandweb.com/texturepacker",
	"version": "1.0",
	"image": "EmojiOne.png",
	"format": "RGBA8888",
	"size": {"w":512,"h":512},
	"scale": "1",
	"smartupdate": "$TexturePacker:SmartUpdate:196a26a2e149d875b91ffc8fa3581e76:fc928c7e275404b7e0649307410475cb:424723c3774975ddb2053fd5c4b85f6e$"
}
}

'''
'''--- Assets/Tutorial/Scripts/JumpBall.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class JumpBall : MonoBehaviour
{
  public Vector2 jumpForce = new Vector2(0, 300);
  private bool _jump;

  // Update is called once per frame
  void Update()
  {
    if (Input.GetKeyDown(KeyCode.Space))
    {
      _jump = true;
    }
  }
  void FixedUpdate()
  {
    if (_jump)
    {
      GetComponent<Rigidbody2D>().AddForce(jumpForce);
      _jump = false;
    }
  }
}

'''
'''--- Assets/Tutorial/Scripts/MoveBall.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

public class MoveBall : MonoBehaviour
{
  public float speed = 1.0f;
  private Rigidbody2D _rigidbody2D;
  private Vector2 _userinput;

  public void Move(InputAction.CallbackContext context)
  {
    _userinput = context.ReadValue<Vector2>();
  }

  void Awake()
  {
    _rigidbody2D = GetComponent<Rigidbody2D>();
  }

  // Start is called before the first frame update
  void Start()
  {
    Debug.Log("Calling the Start method");
  }

  // Update is called once per frame
  // void Update()
  // {
  //   _userinput = new Vector3(Input.GetAxisRaw("Horizontal"), Input.GetAxisRaw("Vertical"), 0);
  // }

  void FixedUpdate()
  {
    _rigidbody2D.MovePosition(transform.position + new Vector3(_userinput.x, _userinput.y, 0) * speed * Time.deltaTime);
  }
}

'''
'''--- Assets/WebGLTemplates/NEAR/index.html ---
<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity WebGL Player | {{{ PRODUCT_NAME }}}</title>
</head>

<body style="text-align: center">
  <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
  <script>
    window.nearApi = nearApi;
    const { connect, keyStores, WalletConnection } = window.nearApi;
    window.nearApi.getConfig = function (network) {
      switch (network) {
        case "mainnet":
          return {
            networkId: "mainnet",
            keyStore: new keyStores.BrowserLocalStorageKeyStore(),
            nodeUrl: "https://rpc.mainnet.near.org",
            walletUrl: "https://wallet.near.org",
            helperUrl: "https://helper.mainnet.near.org",
            explorerUrl: "https://explorer.mainnet.near.org",
          };
        case "testnet":
          return {
            networkId: "testnet",
            keyStore: new keyStores.BrowserLocalStorageKeyStore(),
            nodeUrl: "https://rpc.testnet.near.org",
            walletUrl: "https://wallet.testnet.near.org",
            helperUrl: "https://helper.testnet.near.org",
            explorerUrl: "https://explorer.testnet.near.org",
          };
      }
    }
  </script>
  <canvas id="unity-canvas" width={{{ WIDTH }}} height={{{ HEIGHT }}} style="width: {{{ WIDTH }}}px; height: {{{ HEIGHT }}}px; background: {{{ BACKGROUND_FILENAME ? 'url(\'Build/' + BACKGROUND_FILENAME.replace(/'/g, '%27') + '\') center / cover' : BACKGROUND_COLOR }}}"></canvas>
  <script src="Build/{{{ LOADER_FILENAME }}}"></script>
  <script>
    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
      // Mobile device style: fill the whole browser client area with the game canvas:
      var meta = document.createElement('meta');
      meta.name = 'viewport';
      meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
      document.getElementsByTagName('head')[0].appendChild(meta);
    }

    createUnityInstance(document.querySelector("#unity-canvas"), {
      dataUrl: "Build/{{{ DATA_FILENAME }}}",
      frameworkUrl: "Build/{{{ FRAMEWORK_FILENAME }}}",
      #if USE_WASM
        codeUrl: "Build/{{{ CODE_FILENAME }}}",
      #endif
#if MEMORY_FILENAME
        memoryUrl: "Build/{{{ MEMORY_FILENAME }}}",
      #endif
#if SYMBOLS_FILENAME
        symbolsUrl: "Build/{{{ SYMBOLS_FILENAME }}}",
      #endif
        streamingAssetsUrl: "StreamingAssets",
      companyName: {{{ JSON.stringify(COMPANY_NAME) }}},
      productName: {{{ JSON.stringify(PRODUCT_NAME) }}},
      productVersion: {{{ JSON.stringify(PRODUCT_VERSION) }}},
        // matchWebGLToCanvasSize: false, // Uncomment this to separately control WebGL canvas render size and DOM element size.
        // devicePixelRatio: 1, // Uncomment this to override low DPI rendering on high DPI displays.
      });
  </script>
</body>

</html>
'''
'''--- Packages/manifest.json ---
{
  "dependencies": {
    "com.unity.collab-proxy": "1.15.18",
    "com.unity.feature.2d": "1.0.0",
    "com.unity.ide.rider": "3.0.15",
    "com.unity.ide.visualstudio": "2.0.16",
    "com.unity.ide.vscode": "1.2.5",
    "com.unity.inputsystem": "1.3.0",
    "com.unity.render-pipelines.universal": "12.1.7",
    "com.unity.test-framework": "1.1.31",
    "com.unity.textmeshpro": "3.0.6",
    "com.unity.timeline": "1.6.4",
    "com.unity.ugui": "1.0.0",
    "com.unity.visualscripting": "1.7.8",
    "com.unity.modules.ai": "1.0.0",
    "com.unity.modules.androidjni": "1.0.0",
    "com.unity.modules.animation": "1.0.0",
    "com.unity.modules.assetbundle": "1.0.0",
    "com.unity.modules.audio": "1.0.0",
    "com.unity.modules.cloth": "1.0.0",
    "com.unity.modules.director": "1.0.0",
    "com.unity.modules.imageconversion": "1.0.0",
    "com.unity.modules.imgui": "1.0.0",
    "com.unity.modules.jsonserialize": "1.0.0",
    "com.unity.modules.particlesystem": "1.0.0",
    "com.unity.modules.physics": "1.0.0",
    "com.unity.modules.physics2d": "1.0.0",
    "com.unity.modules.screencapture": "1.0.0",
    "com.unity.modules.terrain": "1.0.0",
    "com.unity.modules.terrainphysics": "1.0.0",
    "com.unity.modules.tilemap": "1.0.0",
    "com.unity.modules.ui": "1.0.0",
    "com.unity.modules.uielements": "1.0.0",
    "com.unity.modules.umbra": "1.0.0",
    "com.unity.modules.unityanalytics": "1.0.0",
    "com.unity.modules.unitywebrequest": "1.0.0",
    "com.unity.modules.unitywebrequestassetbundle": "1.0.0",
    "com.unity.modules.unitywebrequestaudio": "1.0.0",
    "com.unity.modules.unitywebrequesttexture": "1.0.0",
    "com.unity.modules.unitywebrequestwww": "1.0.0",
    "com.unity.modules.vehicles": "1.0.0",
    "com.unity.modules.video": "1.0.0",
    "com.unity.modules.vr": "1.0.0",
    "com.unity.modules.wind": "1.0.0",
    "com.unity.modules.xr": "1.0.0"
  }
}

'''
'''--- Packages/packages-lock.json ---
{
  "dependencies": {
    "com.unity.2d.animation": {
      "version": "7.0.6",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.2d.common": "6.0.3",
        "com.unity.2d.sprite": "1.0.0",
        "com.unity.modules.animation": "1.0.0",
        "com.unity.modules.uielements": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.2d.common": {
      "version": "6.0.3",
      "depth": 2,
      "source": "registry",
      "dependencies": {
        "com.unity.2d.sprite": "1.0.0",
        "com.unity.mathematics": "1.1.0",
        "com.unity.modules.uielements": "1.0.0",
        "com.unity.burst": "1.5.1"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.2d.path": {
      "version": "5.0.2",
      "depth": 2,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.2d.pixel-perfect": {
      "version": "5.0.1",
      "depth": 1,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.2d.psdimporter": {
      "version": "6.0.4",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.2d.animation": "7.0.6",
        "com.unity.2d.common": "6.0.3",
        "com.unity.2d.sprite": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.2d.sprite": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.2d.spriteshape": {
      "version": "7.0.4",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.mathematics": "1.1.0",
        "com.unity.2d.common": "6.0.3",
        "com.unity.2d.path": "5.0.2",
        "com.unity.modules.physics2d": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.2d.tilemap": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.2d.tilemap.extras": {
      "version": "2.2.3",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.modules.tilemap": "1.0.0",
        "com.unity.2d.tilemap": "1.0.0",
        "com.unity.ugui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.burst": {
      "version": "1.6.6",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.mathematics": "1.2.1"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.collab-proxy": {
      "version": "1.15.18",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.services.core": "1.0.1"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ext.nunit": {
      "version": "1.0.6",
      "depth": 1,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.feature.2d": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.2d.animation": "7.0.6",
        "com.unity.2d.pixel-perfect": "5.0.1",
        "com.unity.2d.psdimporter": "6.0.4",
        "com.unity.2d.sprite": "1.0.0",
        "com.unity.2d.spriteshape": "7.0.4",
        "com.unity.2d.tilemap": "1.0.0",
        "com.unity.2d.tilemap.extras": "2.2.3"
      }
    },
    "com.unity.ide.rider": {
      "version": "3.0.15",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ext.nunit": "1.0.6"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.visualstudio": {
      "version": "2.0.16",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.test-framework": "1.1.9"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ide.vscode": {
      "version": "1.2.5",
      "depth": 0,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.inputsystem": {
      "version": "1.3.0",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.modules.uielements": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.mathematics": {
      "version": "1.2.6",
      "depth": 1,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.nuget.newtonsoft-json": {
      "version": "3.0.2",
      "depth": 2,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.render-pipelines.core": {
      "version": "12.1.7",
      "depth": 1,
      "source": "builtin",
      "dependencies": {
        "com.unity.ugui": "1.0.0",
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.render-pipelines.universal": {
      "version": "12.1.7",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.mathematics": "1.2.1",
        "com.unity.burst": "1.5.0",
        "com.unity.render-pipelines.core": "12.1.7",
        "com.unity.shadergraph": "12.1.7"
      }
    },
    "com.unity.searcher": {
      "version": "4.9.1",
      "depth": 2,
      "source": "registry",
      "dependencies": {},
      "url": "https://packages.unity.com"
    },
    "com.unity.services.core": {
      "version": "1.4.0",
      "depth": 1,
      "source": "registry",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.nuget.newtonsoft-json": "3.0.2",
        "com.unity.modules.androidjni": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.shadergraph": {
      "version": "12.1.7",
      "depth": 1,
      "source": "builtin",
      "dependencies": {
        "com.unity.render-pipelines.core": "12.1.7",
        "com.unity.searcher": "4.9.1"
      }
    },
    "com.unity.test-framework": {
      "version": "1.1.31",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ext.nunit": "1.0.6",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.textmeshpro": {
      "version": "3.0.6",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ugui": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.timeline": {
      "version": "1.6.4",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.modules.director": "1.0.0",
        "com.unity.modules.animation": "1.0.0",
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.particlesystem": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.ugui": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.imgui": "1.0.0"
      }
    },
    "com.unity.visualscripting": {
      "version": "1.7.8",
      "depth": 0,
      "source": "registry",
      "dependencies": {
        "com.unity.ugui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      },
      "url": "https://packages.unity.com"
    },
    "com.unity.modules.ai": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.androidjni": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.animation": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.assetbundle": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.audio": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.cloth": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0"
      }
    },
    "com.unity.modules.director": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.animation": "1.0.0"
      }
    },
    "com.unity.modules.imageconversion": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.imgui": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.jsonserialize": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.particlesystem": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.physics": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.physics2d": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.screencapture": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.imageconversion": "1.0.0"
      }
    },
    "com.unity.modules.subsystems": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.modules.terrain": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.terrainphysics": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.terrain": "1.0.0"
      }
    },
    "com.unity.modules.tilemap": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics2d": "1.0.0"
      }
    },
    "com.unity.modules.ui": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.uielements": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0",
        "com.unity.modules.uielementsnative": "1.0.0"
      }
    },
    "com.unity.modules.uielementsnative": {
      "version": "1.0.0",
      "depth": 1,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.imgui": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.modules.umbra": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.unityanalytics": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0"
      }
    },
    "com.unity.modules.unitywebrequest": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.unitywebrequestassetbundle": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.assetbundle": "1.0.0",
        "com.unity.modules.unitywebrequest": "1.0.0"
      }
    },
    "com.unity.modules.unitywebrequestaudio": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.modules.audio": "1.0.0"
      }
    },
    "com.unity.modules.unitywebrequesttexture": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.modules.imageconversion": "1.0.0"
      }
    },
    "com.unity.modules.unitywebrequestwww": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.unitywebrequest": "1.0.0",
        "com.unity.modules.unitywebrequestassetbundle": "1.0.0",
        "com.unity.modules.unitywebrequestaudio": "1.0.0",
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.assetbundle": "1.0.0",
        "com.unity.modules.imageconversion": "1.0.0"
      }
    },
    "com.unity.modules.vehicles": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0"
      }
    },
    "com.unity.modules.video": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.unitywebrequest": "1.0.0"
      }
    },
    "com.unity.modules.vr": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.jsonserialize": "1.0.0",
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.xr": "1.0.0"
      }
    },
    "com.unity.modules.wind": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {}
    },
    "com.unity.modules.xr": {
      "version": "1.0.0",
      "depth": 0,
      "source": "builtin",
      "dependencies": {
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.jsonserialize": "1.0.0",
        "com.unity.modules.subsystems": "1.0.0"
      }
    }
  }
}

'''
'''--- ProjectSettings/BurstAotSettings_StandaloneWindows.json ---
{
  "MonoBehaviour": {
    "Version": 4,
    "EnableBurstCompilation": true,
    "EnableOptimisations": true,
    "EnableSafetyChecks": false,
    "EnableDebugInAllBuilds": false,
    "UsePlatformSDKLinker": false,
    "CpuMinTargetX32": 0,
    "CpuMaxTargetX32": 0,
    "CpuMinTargetX64": 0,
    "CpuMaxTargetX64": 0,
    "CpuTargetsX32": 6,
    "CpuTargetsX64": 72,
    "OptimizeFor": 0
  }
}

'''
'''--- ProjectSettings/BurstAotSettings_WebGL.json ---
{
  "MonoBehaviour": {
    "Version": 4,
    "EnableBurstCompilation": true,
    "EnableOptimisations": true,
    "EnableSafetyChecks": false,
    "EnableDebugInAllBuilds": false,
    "CpuMinTargetX32": 0,
    "CpuMaxTargetX32": 0,
    "CpuMinTargetX64": 0,
    "CpuMaxTargetX64": 0,
    "OptimizeFor": 0
  }
}

'''
'''--- ProjectSettings/CommonBurstAotSettings.json ---
{
  "MonoBehaviour": {
    "Version": 4,
    "DisabledWarnings": ""
  }
}

'''
'''--- ProjectSettings/ProjectVersion.txt ---
m_EditorVersion: 2021.3.6f1
m_EditorVersionWithRevision: 2021.3.6f1 (7da38d85baf6)

'''
'''--- ProjectSettings/SceneTemplateSettings.json ---
{
    "templatePinStates": [],
    "dependencyTypeInfos": [
        {
            "userAdded": false,
            "type": "UnityEngine.AnimationClip",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.Animations.AnimatorController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.AnimatorOverrideController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.Audio.AudioMixerController",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.ComputeShader",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Cubemap",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.GameObject",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.LightingDataAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": false
        },
        {
            "userAdded": false,
            "type": "UnityEngine.LightingSettings",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Material",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.MonoScript",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.PhysicMaterial",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.PhysicsMaterial2D",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.PostProcessing.PostProcessProfile",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.PostProcessing.PostProcessResources",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Rendering.VolumeProfile",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEditor.SceneAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": false
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Shader",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.ShaderVariantCollection",
            "ignore": true,
            "defaultInstantiationMode": 1,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Texture",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Texture2D",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        },
        {
            "userAdded": false,
            "type": "UnityEngine.Timeline.TimelineAsset",
            "ignore": false,
            "defaultInstantiationMode": 0,
            "supportsModification": true
        }
    ],
    "defaultDependencyTypeInfo": {
        "userAdded": false,
        "type": "<default_scene_template_dependencies>",
        "ignore": false,
        "defaultInstantiationMode": 1,
        "supportsModification": true
    },
    "newSceneOverride": 0
}
'''