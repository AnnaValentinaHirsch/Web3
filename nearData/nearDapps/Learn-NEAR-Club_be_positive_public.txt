*GitHub Repository "Learn-NEAR-Club/be_positive_public"*

'''--- contract/.rustfmt.toml ---
tab_spaces = 2
'''
'''--- contract/Cargo.toml ---
[package]
name = "be_positive"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = { path = "src/standards", version = "3.2.0" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder â€“
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contract/src/lib.rs ---
use std::collections::HashMap;
use std::convert::TryInto;

use near_contract_standards::non_fungible_token::core::{
  NonFungibleTokenCore, NonFungibleTokenResolver,
};
use near_contract_standards::non_fungible_token::enumeration::NonFungibleTokenEnumeration;
use near_contract_standards::non_fungible_token::metadata::{
  NFTContractMetadata, TokenMetadata, TokenStatus, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{NonFungibleToken, Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, LookupSet, UnorderedSet};
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::json;
use near_sdk::{
  env, near_bindgen, setup_alloc, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault,
  Promise, PromiseOrValue,
};

setup_alloc!();

static IMAGE_ICON: &str = include_str!("../../logo.base64");

const SINGLE_CALL_GAS: Gas = 50_000_000_000_000;
const ONE_YOCTO: Balance = 1;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  tokens: NonFungibleToken,
  metadata: LazyOption<NFTContractMetadata>,
  owners: UnorderedSet<ValidAccountId>,
  moderators: UnorderedSet<ValidAccountId>,
  royalty: Royalty,
  events_transfer: LookupMap<String, EventTransfer>,
  events_lock: LookupMap<String, EventLock>,
  events_pricing: LookupMap<String, EventPricing>,
  next_event_id: u128,
  mint_locked: LookupSet<String>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum EventType {
  Transfer(EventTransfer),
  Lock(EventLock),
  Pricing(EventPricing),
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct EventTransfer {
  initiator: AccountId,
  sender: Option<AccountId>,
  receiver: Option<AccountId>,
  token_id: TokenId,
  timestamp: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLock {
  initiator: AccountId,
  status: TokenStatus,
  token_id: TokenId,
  timestamp: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct EventPricing {
  initiator: AccountId,
  price: String,
  selleble: bool,
  token_id: TokenId,
  timestamp: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ReturnEvents {
  events: Vec<EventType>,
  smth_else: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Royalty {
  mint_price: Balance,
  creator_royalty: u8,
  my_royalty: u8,
}
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ReturnRoyalty {
  mint_price: String,
  creator_royalty: u8,
  my_royalty: u8,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
  NonFungibleToken,
  Metadata,
  TokenMetadata,
  Enumeration,
  Approval,
  Moderators,
  Etransfer,
  Elock,
  Epricing,
  MintLocked,
}

#[near_bindgen]
impl Contract {
  fn is_status_ok(&mut self, status: TokenStatus) {
    assert!(
      status == TokenStatus::Ok || status == TokenStatus::SuperOk,
      "Token status is not ok"
    );
  }
  fn is_caller_owner(&mut self) {
    assert!(
      self
        .owners
        .contains(&env::predecessor_account_id().try_into().unwrap()),
      "Unauthorized"
    );
  }
  fn is_caller_moderator(&mut self) {
    let caller = env::predecessor_account_id().try_into().unwrap();
    assert!(
      self.owners.contains(&caller) || self.moderators.contains(&caller),
      "Unauthorized"
    );
  }

  fn get_metadata(&mut self, token_id: &TokenId) -> TokenMetadata {
    self
      .tokens
      .token_metadata_by_id
      .as_ref()
      .unwrap()
      .get(token_id)
      .unwrap()
  }
  fn put_metadata(&mut self, token_id: &TokenId, metadata: &TokenMetadata) {
    self
      .tokens
      .token_metadata_by_id
      .as_mut()
      .and_then(|by_id| by_id.insert(token_id, metadata));
  }

  fn get_owner(&mut self, token_id: &TokenId) -> AccountId {
    self
      .tokens
      .owner_by_id
      .get(token_id)
      .expect("Token not found")
  }

  fn add_transfer(
    &mut self,
    initiator: AccountId,
    sender: Option<AccountId>,
    receiver: Option<AccountId>,
    token_id: TokenId,
    timestamp: String,
  ) {
    self.events_transfer.insert(
      &self.next_event_id.to_string(),
      &EventTransfer {
        initiator,
        sender,
        receiver,
        token_id,
        timestamp,
      },
    );
    self.next_event_id += 1;
  }
  fn add_lock(
    &mut self,
    initiator: AccountId,
    status: TokenStatus,
    token_id: TokenId,
    timestamp: String,
  ) {
    self.events_lock.insert(
      &self.next_event_id.to_string(),
      &EventLock {
        initiator,
        status,
        token_id,
        timestamp,
      },
    );
    self.next_event_id += 1;
  }
  fn add_pricing(
    &mut self,
    initiator: AccountId,
    price: String,
    selleble: bool,
    token_id: TokenId,
    timestamp: String,
  ) {
    self.events_pricing.insert(
      &self.next_event_id.to_string(),
      &EventPricing {
        initiator,
        price,
        selleble,
        token_id,
        timestamp,
      },
    );
    self.next_event_id += 1;
  }

  #[init]
  pub fn init_meta(owner: ValidAccountId) -> Self {
    assert!(!env::state_exists(), "Already initialized");
    let mut owners = UnorderedSet::new(StorageKey::Moderators);
    owners.insert(&owner);
    Self {
      tokens: NonFungibleToken::new(
        StorageKey::NonFungibleToken,
        Some(StorageKey::TokenMetadata),
        Some(StorageKey::Enumeration),
        Some(StorageKey::Approval),
      ),
      metadata: LazyOption::new(
        StorageKey::Metadata,
        Some(&NFTContractMetadata {
          spec: NFT_METADATA_SPEC.to_string(),
          name: "Be Positive".to_string(),
          symbol: "HA-HA".to_string(),
          icon: Some(IMAGE_ICON.to_string()),
          base_uri: None,
          reference: None,
          reference_hash: None,
        }),
      ),
      owners,
      moderators: UnorderedSet::new(StorageKey::Moderators),
      royalty: Royalty {
        mint_price: 1_000_000_000_000_000_000_000_000,
        creator_royalty: 10,
        my_royalty: 10,
      },
      events_transfer: LookupMap::new(StorageKey::Etransfer),
      events_lock: LookupMap::new(StorageKey::Elock),
      events_pricing: LookupMap::new(StorageKey::Epricing),
      next_event_id: 0,
      mint_locked: LookupSet::new(StorageKey::MintLocked),
    }
  }

  pub fn view_events(self, from_index: String, limit: u64) -> ReturnEvents {
    let from = from_index
      .parse::<u128>()
      .expect("Parsing from_index failed");
    let to = from + limit as u128;
    let mut result = Vec::new();
    for i in from..to {
      let evt = self.events_transfer.get(&i.to_string());
      result.push(match evt {
        Some(e) => EventType::Transfer(e),
        None => {
          let evp = self.events_pricing.get(&i.to_string());
          match evp {
            Some(e) => EventType::Pricing(e),
            None => {
              let evl = self.events_lock.get(&i.to_string());
              match evl {
                Some(e) => EventType::Lock(e),
                None => break,
              }
            }
          }
        }
      })
    }
    ReturnEvents {
      events: result,
      smth_else: to < self.next_event_id,
    }
  }

  pub fn add_owner(&mut self, owner: ValidAccountId) {
    self.is_caller_owner();
    self.owners.insert(&owner);
  }
  pub fn delete_owner(&mut self, owner: ValidAccountId) {
    self.is_caller_owner();
    assert_ne!(
      env::predecessor_account_id(),
      owner.to_string(),
      "Don't delete yourself"
    );
    self.owners.remove(&owner);
  }
  pub fn view_owners(self) -> Vec<ValidAccountId> {
    self.owners.to_vec()
  }
  pub fn take_money(&mut self, amount: Option<String>) {
    self.is_caller_owner();
    match amount {
      None => Promise::new(env::predecessor_account_id()).transfer(
        env::account_balance() - env::storage_usage() as Balance * env::storage_byte_cost(),
      ),
      Some(money) => Promise::new(env::predecessor_account_id())
        .transfer(money.parse::<Balance>().expect("Parsing amount failed")),
    };
  }
  pub fn update_royalty(&mut self, mint_price: String, creator_royalty: u8, my_royalty: u8) {
    self.is_caller_owner();
    self.royalty = Royalty {
      mint_price: mint_price
        .parse::<Balance>()
        .expect("Parsing mint price failed"),
      creator_royalty,
      my_royalty: my_royalty,
    }
  }
  pub fn view_royalty(self) -> ReturnRoyalty {
    ReturnRoyalty {
      mint_price: self.royalty.mint_price.to_string(),
      creator_royalty: self.royalty.creator_royalty,
      my_royalty: self.royalty.my_royalty,
    }
  }

  pub fn add_moderator(&mut self, account_id: ValidAccountId) {
    self.is_caller_owner();
    self.moderators.insert(&account_id);
  }
  pub fn delete_moderator(&mut self, account_id: ValidAccountId) {
    self.is_caller_owner();
    self.moderators.remove(&account_id);
  }
  pub fn view_moderators(self) -> Vec<ValidAccountId> {
    self.moderators.to_vec()
  }
  pub fn lock_to_super_ok(&mut self, token_id: TokenId) {
    self.is_caller_moderator();
    let mut metadata = self.get_metadata(&token_id);
    metadata.status = Some(TokenStatus::SuperOk);
    self.put_metadata(&token_id, &metadata);
    self.add_lock(
      env::signer_account_id(),
      TokenStatus::SuperOk,
      token_id,
      env::block_timestamp().to_string(),
    );
  }
  pub fn lock_to_transfer(&mut self, token_id: TokenId) {
    self.is_caller_moderator();
    let mut metadata = self.get_metadata(&token_id);
    metadata.status = Some(TokenStatus::LockedToTransfer);
    self.put_metadata(&token_id, &metadata);
    self.add_lock(
      env::signer_account_id(),
      TokenStatus::LockedToTransfer,
      token_id,
      env::block_timestamp().to_string(),
    );
  }
  pub fn lock_to_listen(&mut self, token_id: TokenId) {
    self.is_caller_moderator();
    let mut metadata = self.get_metadata(&token_id);
    metadata.status = Some(TokenStatus::LockedToListen);
    self.put_metadata(&token_id, &metadata);
    let owner = self.get_owner(&token_id);
    self.add_lock(
      env::signer_account_id(),
      TokenStatus::LockedToListen,
      token_id,
      env::block_timestamp().to_string(),
    );
    self.mint_locked.insert(&owner);
  }

  #[payable]
  pub fn nft_create(
    &mut self,
    title: String,
    description: String,
    media: String,
    price: String,
    selleble: bool,
  ) -> Token {
    let attached = env::attached_deposit();

    assert!(
      self.royalty.mint_price <= attached,
      "Not enough money attached"
    );
    if self.royalty.mint_price < attached {
      Promise::new(env::predecessor_account_id()).transfer(attached - self.royalty.mint_price);
    }

    assert!(
      media.len() == 46 && &media[0..2] == "Qm",
      "Token id length should be 46 and start from 'Qm'"
    );
    assert!(
      description.len() <= 512,
      "Description length should be less than 512"
    );
    assert!(title.len() <= 64, "Title length should be less than 64");

    let caller: AccountId = env::predecessor_account_id();
    assert!(
      !self.mint_locked.contains(&caller),
      "You was banned from minting"
    );

    let contract: ValidAccountId = env::current_account_id().try_into().unwrap();
    let token_id = media.clone();
    let timestamp = env::block_timestamp().to_string();

    let mut metadata = TokenMetadata {
      title: Some(title),
      description: Some(description),
      media: Some(media),
      media_hash: None,
      copies: None,
      issued_at: Some(timestamp.clone()),
      expires_at: None,
      starts_at: None,
      updated_at: Some(timestamp.clone()),
      extra: None,
      reference: None,
      reference_hash: None,
      status: Some(TokenStatus::Ok),
      selleble: Some(false),
      price: Some(0),
      price_str: None,
      creator: Some(caller.clone()),
    };
    self
      .tokens
      .mint(token_id.clone(), contract.clone(), Some(metadata.clone()));

    self.add_transfer(
      env::signer_account_id(),
      None,
      Some(contract.to_string()),
      token_id.clone(),
      timestamp,
    );

    let promise_idx = env::promise_create(
      contract.to_string(),
      b"nft_transfer",
      json!({
        "token_id": token_id,
        "receiver_id": caller,
      })
      .to_string()
      .as_bytes(),
      ONE_YOCTO,
      SINGLE_CALL_GAS,
    );

    if selleble {
      env::promise_then(
        promise_idx,
        contract.to_string(),
        b"nft_update_price",
        json!({
          "token_id": token_id,
          "price": price,
          "selleble": selleble,
        })
        .to_string()
        .as_bytes(),
        2500000000000000000000,
        SINGLE_CALL_GAS,
      );
    }

    if selleble {
      metadata.price_str = Some(price.clone());
      metadata.price = Some(price.parse::<Balance>().expect("Parsing price failed"));
    } else {
      metadata.price_str = Some("0".to_string());
    }

    Token {
      token_id,
      owner_id: caller,
      metadata: Some(metadata),
      approved_account_ids: Some(HashMap::new()),
    }
  }

  #[payable]
  pub fn nft_update_price(&mut self, token_id: TokenId, price: String, selleble: bool) {
    let caller: AccountId = env::predecessor_account_id();
    let attached = env::attached_deposit();
    assert!(
      2500000000000000000000 <= attached,
      "Not enough money attached"
    );
    if 2500000000000000000000 < attached {
      Promise::new(caller).transfer(attached - 2500000000000000000000);
    }

    let signer: AccountId = env::signer_account_id();
    assert_eq!(self.get_owner(&token_id), signer, "Unauthorized");

    let mut metadata = self.get_metadata(&token_id);
    let status = metadata.status.clone().unwrap();

    self.is_status_ok(status);

    assert!(
      metadata.selleble.unwrap() == true || selleble == true,
      "Selleble param is false and not changed"
    );

    metadata.selleble = Some(selleble);
    metadata.price = Some(price.parse::<Balance>().expect("Parsing price failed"));
    self.put_metadata(&token_id, &metadata);

    self.add_pricing(
      signer,
      price,
      selleble,
      token_id,
      env::block_timestamp().to_string(),
    );
  }

  #[payable]
  pub fn nft_buy(&mut self, token_id: TokenId) {
    let attached = env::attached_deposit();

    let metadata = self.get_metadata(&token_id);
    let selleble = metadata.selleble.unwrap();
    let price = metadata.price.unwrap();
    let full_price =
      price * (100 + self.royalty.my_royalty + self.royalty.creator_royalty) as Balance / 100;

    assert!(full_price <= attached, "Not enough money attached");
    if full_price < attached {
      Promise::new(env::predecessor_account_id()).transfer(attached - full_price);
    }

    let status = metadata.status.unwrap();

    self.is_status_ok(status);
    assert!(selleble, "Token is not for sale");

    let caller: AccountId = env::predecessor_account_id();
    let contract = env::current_account_id();
    let creator = metadata.creator.clone().unwrap();

    let old_owner = self.get_owner(&token_id);
    self
      .tokens
      .internal_transfer_unguarded(&token_id, &old_owner, &contract);

    self.add_transfer(
      env::signer_account_id(),
      Some(old_owner.clone()),
      Some(contract.to_string()),
      token_id.clone(),
      env::block_timestamp().to_string(),
    );

    env::promise_create(
      contract,
      b"nft_transfer",
      json!({
        "token_id": token_id,
        "receiver_id": caller,
      })
      .to_string()
      .as_bytes(),
      ONE_YOCTO,
      SINGLE_CALL_GAS,
    );

    if creator.clone() == old_owner {
      Promise::new(creator).transfer(price * (100 + self.royalty.creator_royalty) as Balance / 100);
    } else {
      Promise::new(creator).transfer(price * self.royalty.creator_royalty as Balance / 100);
      Promise::new(old_owner).transfer(price);
    }
  }

  #[payable]
  pub fn nft_transfer(
    &mut self,
    receiver_id: ValidAccountId,
    token_id: TokenId,
    approval_id: Option<u64>,
    memo: Option<String>,
  ) {
    let old_owner = self.get_owner(&token_id).to_string();
    let mut metadata = self.get_metadata(&token_id);
    let status = metadata.status.clone().unwrap();

    self.is_status_ok(status);

    self
      .tokens
      .nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, memo);

    let timestamp = env::block_timestamp().to_string();
    metadata.selleble = Some(false);
    metadata.updated_at = Some(timestamp.clone());
    self.put_metadata(&token_id, &metadata);

    self.add_transfer(
      env::signer_account_id(),
      Some(old_owner),
      Some(receiver_id.to_string()),
      token_id.clone(),
      timestamp,
    );
  }

  #[payable]
  pub fn nft_transfer_call(
    &mut self,
    receiver_id: ValidAccountId,
    token_id: TokenId,
    approval_id: Option<u64>,
    memo: Option<String>,
    msg: String,
  ) -> PromiseOrValue<bool> {
    let old_owner = self.get_owner(&token_id).to_string();
    let mut metadata = self.get_metadata(&token_id);
    let status = metadata.status.clone().unwrap();

    self.is_status_ok(status);

    let res = self.tokens.nft_transfer_call(
      receiver_id.clone(),
      token_id.clone(),
      approval_id,
      memo,
      msg,
    );

    let timestamp = env::block_timestamp().to_string();
    metadata.selleble = Some(false);
    metadata.updated_at = Some(timestamp.clone());
    self.put_metadata(&token_id, &metadata);

    self.add_transfer(
      env::signer_account_id(),
      Some(old_owner),
      Some(receiver_id.to_string()),
      token_id.clone(),
      timestamp,
    );

    res
  }

  pub fn nft_token(self, token_id: TokenId) -> Option<Token> {
    self.tokens.nft_token(token_id)
  }

  #[payable]
  pub fn mint(
    &mut self,
    token_id: TokenId,
    token_owner_id: ValidAccountId,
    token_metadata: Option<TokenMetadata>,
  ) -> Token {
    let caller: AccountId = env::predecessor_account_id();
    let meta = token_metadata.unwrap();
    let media = meta.media.unwrap();

    assert_eq!(
      token_owner_id.to_string(),
      caller,
      "Unsupported to create nft for other user",
    );
    assert_eq!(token_id, media.clone(), "Wrong token id for this meta");

    self.nft_create(
      meta.title.unwrap(),
      meta.description.unwrap(),
      media,
      meta.price.unwrap().to_string(),
      meta.selleble.unwrap(),
    )
  }

  pub fn nft_burn(&mut self, token_id: TokenId) {
    let owner_id = self.get_owner(&token_id);
    let caller: AccountId = env::predecessor_account_id();
    assert_eq!(
      owner_id.clone(),
      caller,
      "You can't burn tokens, you don't own"
    );

    self.tokens.owner_by_id.remove(&token_id);
    self
      .tokens
      .token_metadata_by_id
      .as_mut()
      .and_then(|by_id| by_id.remove(&token_id));

    if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
      let mut token_ids = tokens_per_owner.get(&owner_id).unwrap();
      token_ids.remove(&token_id);
      tokens_per_owner.insert(&owner_id, &token_ids);
    }

    self.add_transfer(
      env::signer_account_id(),
      Some(owner_id),
      None,
      token_id.clone(),
      env::block_timestamp().to_string(),
    );
  }

  #[private]
  pub fn nft_resolve_transfer(
    &mut self,
    previous_owner_id: AccountId,
    receiver_id: AccountId,
    token_id: TokenId,
    approved_account_ids: Option<HashMap<AccountId, u64>>,
  ) -> bool {
    self.tokens.nft_resolve_transfer(
      previous_owner_id,
      receiver_id,
      token_id,
      approved_account_ids,
    )
  }

  pub fn nft_metadata(&self) -> NFTContractMetadata {
    self.metadata.get().unwrap()
  }

  pub fn nft_supply_for_owner(self, account_id: ValidAccountId) -> U128 {
    self.tokens.nft_supply_for_owner(account_id)
  }

  pub fn nft_tokens_for_owner(
    &self,
    account_id: ValidAccountId,
    from_index: Option<U128>,
    limit: Option<u64>,
  ) -> Vec<Token> {
    self
      .tokens
      .nft_tokens_for_owner(account_id, from_index, limit)
  }
}

use near_sdk::json_types::U128;

'''
'''--- contract/src/standards/.cargo_vcs_info.json ---
{
  "git": {
    "sha1": "fdc8c3f588b1e5170ff2e13beb669c06d5d88428"
  }
}

'''
'''--- contract/src/standards/Cargo.toml ---
# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
#
# When uploading crates to the registry Cargo will automatically
# "normalize" Cargo.toml files for maximal compatibility
# with all versions of Cargo and also rewrite `path` dependencies
# to registry (e.g., crates.io) dependencies
#
# If you believe there's an error in this file please file an
# issue against the rust-lang/cargo repository. If you're
# editing this file be aware that the upstream Cargo.toml
# will likely look very different (and much more reasonable)

[package]
edition = "2018"
name = "near-contract-standards"
version = "3.2.0"
authors = ["Near Inc <hello@near.org>"]
description = "NEAR smart contracts standard library.\n"
homepage = "https://github.com/near/near-sdk-rs/tree/master/near-contract-standards"
categories = ["wasm"]
license = "GPL-3.0"
repository = "https://github.com/near/near-sdk-rs"
[dependencies.near-sdk]
version = "=3.1.0"

'''
'''--- contract/src/standards/README.md ---
# NEAR library for Rust contract standards

This cargo provides a set of interfaces and implementations for NEAR's contract standards:
 - Upgradability
 - Fungible Token (NEP-141). See [example usage](../examples/fungible-token)

## Changelog

### `3.1.1`
- Fixed FT macro compilation for Rust `1.51.0`

'''
'''--- contract/src/standards/src/fungible_token/core.rs ---
use near_sdk::json_types::ValidAccountId;
use near_sdk::json_types::U128;
use near_sdk::PromiseOrValue;

pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128;
}

'''
'''--- contract/src/standards/src/fungible_token/core_impl.rs ---
use crate::fungible_token::core::FungibleTokenCore;
use crate::fungible_token::resolver::FungibleTokenResolver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{
    assert_one_yocto, env, ext_contract, log, AccountId, Balance, Gas, IntoStorageKey,
    PromiseOrValue, PromiseResult, StorageUsage,
};

const GAS_FOR_RESOLVE_TRANSFER: Gas = 5_000_000_000_000;
const GAS_FOR_FT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;

const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_self)]
trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

#[ext_contract(ext_fungible_token_receiver)]
pub trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_fungible_token)]
pub trait FungibleTokenContract {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

/// Implementation of a FungibleToken standard.
/// Allows to include NEP-141 compatible token to any contract.
/// There are next traits that any contract may implement:
///     - FungibleTokenCore -- interface with ft_transfer methods. FungibleToken provides methods for it.
///     - FungibleTokenMetaData -- return metadata for the token in NEP-148, up to contract to implement.
///     - StorageManager -- interface for NEP-145 for allocating storage per account. FungibleToken provides methods for it.
///     - AccountRegistrar -- interface for an account to register and unregister
///
/// For example usage, see examples/fungible-token/src/lib.rs.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct FungibleToken {
    /// AccountID -> Account balance.
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of the all token.
    pub total_supply: Balance,

    /// The storage size in bytes for one account.
    pub account_storage_usage: StorageUsage,
}

impl FungibleToken {
    pub fn new<S>(prefix: S) -> Self
    where
        S: IntoStorageKey,
    {
        let mut this =
            Self { accounts: LookupMap::new(prefix), total_supply: 0, account_storage_usage: 0 };
        this.measure_account_storage_usage();
        this
    }

    fn measure_account_storage_usage(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = "a".repeat(64);
        self.accounts.insert(&tmp_account_id, &0u128);
        self.account_storage_usage = env::storage_usage() - initial_storage_usage;
        self.accounts.remove(&tmp_account_id);
    }

    pub fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
        match self.accounts.get(&account_id) {
            Some(balance) => balance,
            None => env::panic(format!("The account {} is not registered", &account_id).as_bytes()),
        }
    }

    pub fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        let balance = self.internal_unwrap_balance_of(account_id);
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(&account_id, &new_balance);
            self.total_supply =
                self.total_supply.checked_add(amount).expect("Total supply overflow");
        } else {
            env::panic(b"Balance overflow");
        }
    }

    pub fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        let balance = self.internal_unwrap_balance_of(account_id);
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(&account_id, &new_balance);
            self.total_supply =
                self.total_supply.checked_sub(amount).expect("Total supply overflow");
        } else {
            env::panic(b"The account doesn't have enough balance");
        }
    }

    pub fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        assert_ne!(sender_id, receiver_id, "Sender and receiver should be different");
        assert!(amount > 0, "The amount should be a positive number");
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);
        log!("Transfer {} from {} to {}", amount, sender_id, receiver_id);
        if let Some(memo) = memo {
            log!("Memo: {}", memo);
        }
    }

    pub fn internal_register_account(&mut self, account_id: &AccountId) {
        if self.accounts.insert(&account_id, &0).is_some() {
            env::panic(b"The account is already registered");
        }
    }
}

impl FungibleTokenCore for FungibleToken {
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let amount: Balance = amount.into();
        self.internal_transfer(&sender_id, receiver_id.as_ref(), amount, memo);
    }

    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let amount: Balance = amount.into();
        self.internal_transfer(&sender_id, receiver_id.as_ref(), amount, memo);
        // Initiating receiver's call and the callback
        ext_fungible_token_receiver::ft_on_transfer(
            sender_id.clone(),
            amount.into(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL,
        )
        .then(ext_self::ft_resolve_transfer(
            sender_id,
            receiver_id.into(),
            amount.into(),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
        .into()
    }

    fn ft_total_supply(&self) -> U128 {
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128 {
        self.accounts.get(account_id.as_ref()).unwrap_or(0).into()
    }
}

impl FungibleToken {
    /// Internal method that returns the amount of burned tokens in a corner case when the sender
    /// has deleted (unregistered) their account while the `ft_transfer_call` was still in flight.
    /// Returns (Used token amount, Burned token amount)
    pub fn internal_ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: ValidAccountId,
        amount: U128,
    ) -> (u128, u128) {
        let receiver_id: AccountId = receiver_id.into();
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed => amount,
        };

        if unused_amount > 0 {
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);
            if receiver_balance > 0 {
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                self.accounts.insert(&receiver_id, &(receiver_balance - refund_amount));

                if let Some(sender_balance) = self.accounts.get(&sender_id) {
                    self.accounts.insert(&sender_id, &(sender_balance + refund_amount));
                    log!("Refund {} from {} to {}", refund_amount, receiver_id, sender_id);
                    return (amount - refund_amount, 0);
                } else {
                    // Sender's account was deleted, so we need to burn tokens.
                    self.total_supply -= refund_amount;
                    log!("The account of the sender was deleted");
                    return (amount, refund_amount);
                }
            }
        }
        (amount, 0)
    }
}

impl FungibleTokenResolver for FungibleToken {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: ValidAccountId,
        receiver_id: ValidAccountId,
        amount: U128,
    ) -> U128 {
        self.internal_ft_resolve_transfer(sender_id.as_ref(), receiver_id, amount).0.into()
    }
}

'''
'''--- contract/src/standards/src/fungible_token/macros.rs ---
/// The core methods for a basic fungible token. Extension standards may be
/// added in addition to this macro.
#[macro_export]
macro_rules! impl_fungible_token_core {
    ($contract: ident, $token: ident $(, $on_tokens_burned_fn:ident)?) => {
        use $crate::fungible_token::core::FungibleTokenCore;
        use $crate::fungible_token::resolver::FungibleTokenResolver;

        #[near_bindgen]
        impl FungibleTokenCore for $contract {
            #[payable]
            fn ft_transfer(
                &mut self,
                receiver_id: ValidAccountId,
                amount: U128,
                memo: Option<String>,
            ) {
                self.$token.ft_transfer(receiver_id, amount, memo)
            }

            #[payable]
            fn ft_transfer_call(
                &mut self,
                receiver_id: ValidAccountId,
                amount: U128,
                memo: Option<String>,
                msg: String,
            ) -> PromiseOrValue<U128> {
                self.$token.ft_transfer_call(receiver_id, amount, memo, msg)
            }

            fn ft_total_supply(&self) -> U128 {
                self.$token.ft_total_supply()
            }

            fn ft_balance_of(&self, account_id: ValidAccountId) -> U128 {
                self.$token.ft_balance_of(account_id)
            }
        }

        #[near_bindgen]
        impl FungibleTokenResolver for $contract {
            #[private]
            fn ft_resolve_transfer(
                &mut self,
                sender_id: ValidAccountId,
                receiver_id: ValidAccountId,
                amount: U128,
            ) -> U128 {
                let sender_id: AccountId = sender_id.into();
                let (used_amount, burned_amount) =
                    self.$token.internal_ft_resolve_transfer(&sender_id, receiver_id, amount);
                if burned_amount > 0 {
                    $(self.$on_tokens_burned_fn(sender_id, burned_amount);)?
                }
                used_amount.into()
            }
        }
    };
}

/// Ensures that when fungible token storage grows by collections adding entries,
/// the storage is be paid by the caller. This ensures that storage cannot grow to a point
/// that the FT contract runs out of â“ƒ.
/// Takes name of the Contract struct, the inner field for the token and optional method name to
/// call when the account was closed.
#[macro_export]
macro_rules! impl_fungible_token_storage {
    ($contract: ident, $token: ident $(, $on_account_closed_fn:ident)?) => {
        use $crate::storage_management::{
            StorageManagement, StorageBalance, StorageBalanceBounds
        };

        #[near_bindgen]
        impl StorageManagement for $contract {
            #[payable]
            fn storage_deposit(
                &mut self,
                account_id: Option<ValidAccountId>,
                registration_only: Option<bool>,
            ) -> StorageBalance {
                self.$token.storage_deposit(account_id, registration_only)
            }

            #[payable]
            fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
                self.$token.storage_withdraw(amount)
            }

            #[payable]
            fn storage_unregister(&mut self, force: Option<bool>) -> bool {
                #[allow(unused_variables)]
                if let Some((account_id, balance)) = self.$token.internal_storage_unregister(force) {
                    $(self.$on_account_closed_fn(account_id, balance);)?
                    true
                } else {
                    false
                }
            }

            fn storage_balance_bounds(&self) -> StorageBalanceBounds {
                self.$token.storage_balance_bounds()
            }

            fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
                self.$token.storage_balance_of(account_id)
            }
        }
    };
}

'''
'''--- contract/src/standards/src/fungible_token/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};

pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<Base64VecU8>,
    pub decimals: u8,
}

pub trait FungibleTokenMetadataProvider {
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

impl FungibleTokenMetadata {
    pub fn assert_valid(&self) {
        assert_eq!(&self.spec, FT_METADATA_SPEC);
        assert_eq!(self.reference.is_some(), self.reference_hash.is_some());
        if let Some(reference_hash) = &self.reference_hash {
            assert_eq!(reference_hash.0.len(), 32, "Hash has to be 32 bytes");
        }
    }
}

'''
'''--- contract/src/standards/src/fungible_token/mod.rs ---
pub mod core;
pub mod core_impl;
pub mod macros;
pub mod metadata;
pub mod receiver;
pub mod resolver;
pub mod storage_impl;

pub use core_impl::FungibleToken;
pub use macros::*;

'''
'''--- contract/src/standards/src/fungible_token/receiver.rs ---
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::PromiseOrValue;

pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

'''
'''--- contract/src/standards/src/fungible_token/resolver.rs ---
use near_sdk::json_types::{ValidAccountId, U128};

pub trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: ValidAccountId,
        receiver_id: ValidAccountId,
        amount: U128,
    ) -> U128;
}

'''
'''--- contract/src/standards/src/fungible_token/storage_impl.rs ---
use crate::fungible_token::FungibleToken;
use crate::storage_management::{StorageBalance, StorageBalanceBounds, StorageManagement};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{assert_one_yocto, env, log, AccountId, Balance, Promise};

impl FungibleToken {
    /// Internal method that returns the Account ID and the balance in case the account was
    /// unregistered.
    pub fn internal_storage_unregister(
        &mut self,
        force: Option<bool>,
    ) -> Option<(AccountId, Balance)> {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let force = force.unwrap_or(false);
        if let Some(balance) = self.accounts.get(&account_id) {
            if balance == 0 || force {
                self.accounts.remove(&account_id);
                self.total_supply -= balance;
                Promise::new(account_id.clone()).transfer(self.storage_balance_bounds().min.0 + 1);
                Some((account_id, balance))
            } else {
                env::panic(b"Can't unregister the account with the positive balance without force")
            }
        } else {
            log!("The account {} is not registered", &account_id);
            None
        }
    }

    fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        if self.accounts.contains_key(account_id) {
            Some(StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() })
        } else {
            None
        }
    }
}

impl StorageManagement for FungibleToken {
    // `registration_only` doesn't affect the implementation for vanilla fungible token.
    #[allow(unused_variables)]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount: Balance = env::attached_deposit();
        let account_id =
            account_id.map(|a| a.into()).unwrap_or_else(|| env::predecessor_account_id());
        if self.accounts.contains_key(&account_id) {
            log!("The account is already registered, refunding the deposit");
            if amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            }
        } else {
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic(b"The attached deposit is less than the mimimum storage balance");
            }

            self.internal_register_account(&account_id);
            let refund = amount - min_balance;
            if refund > 0 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    /// While storage_withdraw normally allows the caller to retrieve `available` balance, the basic
    /// Fungible Token implementation sets storage_balance_bounds.min == storage_balance_bounds.max,
    /// which means available balance will always be 0. So this implementation:
    /// * panics if `amount > 0`
    /// * never transfers â“ƒ to caller
    /// * returns a `storage_balance` struct if `amount` is 0
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let predecessor_account_id = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&predecessor_account_id) {
            match amount {
                Some(amount) if amount.0 > 0 => {
                    env::panic(b"The amount is greater than the available storage balance");
                }
                _ => storage_balance,
            }
        } else {
            env::panic(
                format!("The account {} is not registered", &predecessor_account_id).as_bytes(),
            );
        }
    }

    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        self.internal_storage_unregister(force).is_some()
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        let required_storage_balance =
            Balance::from(self.account_storage_usage) * env::storage_byte_cost();
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(account_id.as_ref())
    }
}

'''
'''--- contract/src/standards/src/lib.rs ---
/// Fungible tokens as described in [by the spec](https://nomicon.io/Standards/FungibleToken/README.html).
pub mod fungible_token;
/// Non-fungible tokens as described in [by the spec](https://nomicon.io/Standards/NonFungibleToken/README.html).
pub mod non_fungible_token;
/// Storage management deals with handling [state storage](https://docs.near.org/docs/concepts/storage-staking) on NEAR. This follows the [storage management standard](https://nomicon.io/Standards/StorageManagement.html).
pub mod storage_management;
/// This upgrade standard is a use case where a staging area exists for a WASM
/// blob, allowing it to be stored for a period of time before deployed.
pub mod upgrade;

'''
'''--- contract/src/standards/src/non_fungible_token/approval/approval_impl.rs ---
/// Common implementation of the [approval management standard](https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html) for NFTs.
/// on the contract/account that has just been approved. This is not required to implement.
use crate::non_fungible_token::approval::NonFungibleTokenApproval;
use crate::non_fungible_token::token::TokenId;
use crate::non_fungible_token::utils::{
    assert_at_least_one_yocto, bytes_for_approved_account_id, refund_approved_account_ids,
    refund_approved_account_ids_iter, refund_deposit,
};
use crate::non_fungible_token::NonFungibleToken;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{assert_one_yocto, env, ext_contract, AccountId, Balance, Gas, Promise};
use std::collections::HashMap;

const GAS_FOR_NFT_APPROVE: Gas = 10_000_000_000_000;
const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_approval_receiver)]
pub trait NonFungibleTokenReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

impl NonFungibleTokenApproval for NonFungibleToken {
    fn nft_approve(
        &mut self,
        token_id: TokenId,
        account_id: ValidAccountId,
        msg: Option<String>,
    ) -> Option<Promise> {
        assert_at_least_one_yocto();
        if self.approvals_by_id.is_none() {
            env::panic(b"NFT does not support Approval Management");
        }

        let owner_id = self.owner_by_id.get(&token_id).expect("Token not found");

        assert_eq!(&env::predecessor_account_id(), &owner_id, "Predecessor must be token owner.");

        // get contract-level LookupMap of token_id to approvals HashMap
        let approvals_by_id = self.approvals_by_id.as_mut().unwrap();

        // update HashMap of approvals for this token
        let approved_account_ids =
            &mut approvals_by_id.get(&token_id).unwrap_or_else(|| HashMap::new());
        let account_id: AccountId = account_id.into();
        let approval_id: u64 =
            self.next_approval_id_by_id.as_ref().unwrap().get(&token_id).unwrap_or_else(|| 1u64);
        let old_approval_id = approved_account_ids.insert(account_id.clone(), approval_id);

        // save updated approvals HashMap to contract's LookupMap
        approvals_by_id.insert(&token_id, &approved_account_ids);

        // increment next_approval_id for this token
        self.next_approval_id_by_id.as_mut().unwrap().insert(&token_id, &(approval_id + 1));

        // If this approval replaced existing for same account, no storage was used.
        // Otherwise, require that enough deposit was attached to pay for storage, and refund
        // excess.
        let storage_used =
            if old_approval_id.is_none() { bytes_for_approved_account_id(&account_id) } else { 0 };
        refund_deposit(storage_used);

        // if given `msg`, schedule call to `nft_on_approve` and return it. Else, return None.
        if let Some(msg) = msg {
            Some(ext_approval_receiver::nft_on_approve(
                token_id,
                owner_id,
                approval_id,
                msg,
                &account_id,
                NO_DEPOSIT,
                env::prepaid_gas() - GAS_FOR_NFT_APPROVE,
            ))
        } else {
            None
        }
    }

    fn nft_revoke(&mut self, token_id: TokenId, account_id: ValidAccountId) {
        assert_one_yocto();
        if self.approvals_by_id.is_none() {
            env::panic(b"NFT does not support Approval Management");
        }

        let owner_id = self.owner_by_id.get(&token_id).expect("Token not found");
        let predecessor_account_id = env::predecessor_account_id();

        assert_eq!(&predecessor_account_id, &owner_id, "Predecessor must be token owner.");

        // if token has no approvals, do nothing
        if let Some(approved_account_ids) =
            &mut self.approvals_by_id.as_mut().unwrap().get(&token_id)
        {
            // if account_id was already not approved, do nothing
            if approved_account_ids.remove(account_id.as_ref()).is_some() {
                refund_approved_account_ids_iter(
                    predecessor_account_id,
                    [account_id.into()].iter(),
                );
                // if this was the last approval, remove the whole HashMap to save space.
                if approved_account_ids.is_empty() {
                    self.approvals_by_id.as_mut().unwrap().remove(&token_id);
                } else {
                    // otherwise, update approvals_by_id with updated HashMap
                    self.approvals_by_id.as_mut().unwrap().insert(&token_id, &approved_account_ids);
                }
            }
        }
    }

    fn nft_revoke_all(&mut self, token_id: TokenId) {
        assert_one_yocto();
        if self.approvals_by_id.is_none() {
            env::panic(b"NFT does not support Approval Management");
        }

        let owner_id = self.owner_by_id.get(&token_id).expect("Token not found");
        let predecessor_account_id = env::predecessor_account_id();

        assert_eq!(&predecessor_account_id, &owner_id, "Predecessor must be token owner.");

        // if token has no approvals, do nothing
        if let Some(approved_account_ids) =
            &mut self.approvals_by_id.as_mut().unwrap().get(&token_id)
        {
            // otherwise, refund owner for storage costs of all approvals...
            refund_approved_account_ids(predecessor_account_id, &approved_account_ids);
            // ...and remove whole HashMap of approvals
            self.approvals_by_id.as_mut().unwrap().remove(&token_id);
        }
    }

    fn nft_is_approved(
        self,
        token_id: TokenId,
        approved_account_id: ValidAccountId,
        approval_id: Option<u64>,
    ) -> bool {
        self.owner_by_id.get(&token_id).expect("Token not found");

        if self.approvals_by_id.is_none() {
            // contract does not support approval management
            return false;
        }

        let approved_account_ids = self.approvals_by_id.unwrap().get(&token_id);
        if approved_account_ids.is_none() {
            // token has no approvals
            return false;
        }

        let account_id: AccountId = approved_account_id.into();
        let actual_approval_id = approved_account_ids.as_ref().unwrap().get(&account_id);
        if actual_approval_id.is_none() {
            // account not in approvals HashMap
            return false;
        }

        if let Some(given_approval_id) = approval_id {
            &given_approval_id == actual_approval_id.unwrap()
        } else {
            // account approved, no approval_id given
            true
        }
    }
}

'''
'''--- contract/src/standards/src/non_fungible_token/approval/approval_receiver.rs ---
use crate::non_fungible_token::token::TokenId;
use near_sdk::AccountId;

/// Approval receiver is the trait for the method called (or attempted to be called) when an NFT contract adds an approval for an account.
pub trait NonFungibleTokenApprovalReceiver {
    /// Respond to notification that contract has been granted approval for a token.
    ///
    /// Notes
    /// * Contract knows the token contract ID from `predecessor_account_id`
    ///
    /// Arguments:
    /// * `token_id`: the token to which this contract has been granted approval
    /// * `owner_id`: the owner of the token
    /// * `approval_id`: the approval ID stored by NFT contract for this approval.
    ///   Expected to be a number within the 2^53 limit representable by JSON.
    /// * `msg`: specifies information needed by the approved contract in order to
    ///    handle the approval. Can indicate both a function to call and the
    ///    parameters to pass to that function.
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) -> near_sdk::PromiseOrValue<String>; // TODO: how to make "any"?
}

'''
'''--- contract/src/standards/src/non_fungible_token/approval/mod.rs ---
mod approval_impl;
mod approval_receiver;

pub use approval_impl::*;
pub use approval_receiver::*;

use crate::non_fungible_token::token::TokenId;
use near_sdk::json_types::ValidAccountId;
use near_sdk::Promise;

/// Trait used when it's desired to have a non-fungible token that has a
/// traditional escrow or approval system. This allows Alice to allow Bob
/// to take only the token with the unique identifier "19" but not others.
/// It should be noted that in the [core non-fungible token standard] there
/// is a method to do "transfer and call" which may be preferred over using
/// an approval management standard in certain use cases.
///
/// [approval management standard]: https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html
/// [core non-fungible token standard]: https://nomicon.io/Standards/NonFungibleToken/Core.html
pub trait NonFungibleTokenApproval {
    /// Add an approved account for a specific token.
    ///
    /// Requirements
    /// * Caller of the method must attach a deposit of at least 1 yoctoâ“ƒ for
    ///   security purposes
    /// * Contract MAY require caller to attach larger deposit, to cover cost of
    ///   storing approver data
    /// * Contract MUST panic if called by someone other than token owner
    /// * Contract MUST panic if addition would cause `nft_revoke_all` to exceed
    ///   single-block gas limit
    /// * Contract MUST increment approval ID even if re-approving an account
    /// * If successfully approved or if had already been approved, and if `msg` is
    ///   present, contract MUST call `nft_on_approve` on `account_id`. See
    ///   `nft_on_approve` description below for details.
    ///
    /// Arguments:
    /// * `token_id`: the token for which to add an approval
    /// * `account_id`: the account to add to `approvals`
    /// * `msg`: optional string to be passed to `nft_on_approve`
    ///
    /// Returns void, if no `msg` given. Otherwise, returns promise call to
    /// `nft_on_approve`, which can resolve with whatever it wants.
    fn nft_approve(
        &mut self,
        token_id: TokenId,
        account_id: ValidAccountId,
        msg: Option<String>,
    ) -> Option<Promise>;

    /// Revoke an approved account for a specific token.
    ///
    /// Requirements
    /// * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    ///   purposes
    /// * If contract requires >1yN deposit on `nft_approve`, contract
    ///   MUST refund associated storage deposit when owner revokes approval
    /// * Contract MUST panic if called by someone other than token owner
    ///
    /// Arguments:
    /// * `token_id`: the token for which to revoke an approval
    /// * `account_id`: the account to remove from `approvals`
    fn nft_revoke(&mut self, token_id: TokenId, account_id: ValidAccountId);

    /// Revoke all approved accounts for a specific token.
    ///
    /// Requirements
    /// * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    ///   purposes
    /// * If contract requires >1yN deposit on `nft_approve`, contract
    ///   MUST refund all associated storage deposit when owner revokes approvals
    /// * Contract MUST panic if called by someone other than token owner
    ///
    /// Arguments:
    /// * `token_id`: the token with approvals to revoke
    fn nft_revoke_all(&mut self, token_id: TokenId);

    /// Check if a token is approved for transfer by a given account, optionally
    /// checking an approval_id
    ///
    /// Arguments:
    /// * `token_id`: the token for which to revoke an approval
    /// * `approved_account_id`: the account to check the existence of in `approvals`
    /// * `approval_id`: an optional approval ID to check against current approval ID for given account
    ///
    /// Returns:
    /// if `approval_id` given, `true` if `approved_account_id` is approved with given `approval_id`
    /// otherwise, `true` if `approved_account_id` is in list of approved accounts
    fn nft_is_approved(
        self,
        token_id: TokenId,
        approved_account_id: ValidAccountId,
        approval_id: Option<u64>,
    ) -> bool;
}

'''
'''--- contract/src/standards/src/non_fungible_token/core/core_impl.rs ---
use super::resolver::NonFungibleTokenResolver;
use crate::non_fungible_token::core::NonFungibleTokenCore;
use crate::non_fungible_token::metadata::TokenMetadata;
use crate::non_fungible_token::token::{Token, TokenId};
use crate::non_fungible_token::utils::{hash_account_id, refund_approved_account_ids};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, TreeMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, ValidAccountId};
use near_sdk::{
  assert_one_yocto, env, ext_contract, log, AccountId, Balance, BorshStorageKey, CryptoHash, Gas,
  IntoStorageKey, PromiseOrValue, PromiseResult, StorageUsage,
};
use std::collections::HashMap;

const GAS_FOR_RESOLVE_TRANSFER: Gas = 5_000_000_000_000;
const GAS_FOR_FT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;

const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_self)]
trait NFTResolver {
  fn nft_resolve_transfer(
    &mut self,
    previous_owner_id: AccountId,
    receiver_id: AccountId,
    token_id: TokenId,
    approved_account_ids: Option<HashMap<AccountId, u64>>,
  ) -> bool;
}

#[ext_contract(ext_receiver)]
pub trait NonFungibleTokenReceiver {
  /// Returns true if token should be returned to `sender_id`
  fn nft_on_transfer(
    &mut self,
    sender_id: AccountId,
    previous_owner_id: AccountId,
    token_id: TokenId,
    msg: String,
  ) -> PromiseOrValue<bool>;
}

/// Implementation of the non-fungible token standard.
/// Allows to include NEP-171 compatible token to any contract.
/// There are next traits that any contract may implement:
///     - NonFungibleTokenCore -- interface with nft_transfer methods. NonFungibleToken provides methods for it.
///     - NonFungibleTokenApproval -- interface with nft_approve methods. NonFungibleToken provides methods for it.
///     - NonFungibleTokenEnumeration -- interface for getting lists of tokens. NonFungibleToken provides methods for it.
///     - NonFungibleTokenMetadata -- return metadata for the token in NEP-177, up to contract to implement.
///
/// For example usage, see examples/non-fungible-token/src/lib.rs.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct NonFungibleToken {
  // The storage size in bytes for each new token
  pub extra_storage_in_bytes_per_token: StorageUsage,

  // always required
  pub owner_by_id: TreeMap<TokenId, AccountId>,

  // required by metadata extension
  pub token_metadata_by_id: Option<LookupMap<TokenId, TokenMetadata>>,

  // required by enumeration extension
  pub tokens_per_owner: Option<LookupMap<AccountId, UnorderedSet<TokenId>>>,

  // required by approval extension
  pub approvals_by_id: Option<LookupMap<TokenId, HashMap<AccountId, u64>>>,
  pub next_approval_id_by_id: Option<LookupMap<TokenId, u64>>,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
  TokensPerOwner { account_hash: Vec<u8> },
  TokenPerOwnerInner { account_id_hash: CryptoHash },
}

impl NonFungibleToken {
  pub fn new<Q, R, S, T>(
    owner_by_id_prefix: Q,
    token_metadata_prefix: Option<R>,
    enumeration_prefix: Option<S>,
    approval_prefix: Option<T>,
  ) -> Self
  where
    Q: IntoStorageKey,
    R: IntoStorageKey,
    S: IntoStorageKey,
    T: IntoStorageKey,
  {
    let (approvals_by_id, next_approval_id_by_id) = if let Some(prefix) = approval_prefix {
      let prefix: Vec<u8> = prefix.into_storage_key();
      (
        Some(LookupMap::new(prefix.clone())),
        Some(LookupMap::new([prefix, "n".into()].concat())),
      )
    } else {
      (None, None)
    };

    let mut this = Self {
      extra_storage_in_bytes_per_token: 0,
      owner_by_id: TreeMap::new(owner_by_id_prefix),
      token_metadata_by_id: token_metadata_prefix.map(LookupMap::new),
      tokens_per_owner: enumeration_prefix.map(LookupMap::new),
      approvals_by_id,
      next_approval_id_by_id,
    };
    this.measure_min_token_storage_cost();
    this
  }

  // TODO: does this seem reasonable?
  fn measure_min_token_storage_cost(&mut self) {
    let initial_storage_usage = env::storage_usage();
    let tmp_token_id = "a".repeat(64); // TODO: what's a reasonable max TokenId length?
    let tmp_owner_id = "a".repeat(64);

    // 1. set some dummy data
    self.owner_by_id.insert(&tmp_token_id, &tmp_owner_id);
    if let Some(token_metadata_by_id) = &mut self.token_metadata_by_id {
      token_metadata_by_id.insert(
        &tmp_token_id,
        &TokenMetadata {
          title: Some("a".repeat(64)),
          description: Some("a".repeat(64)),
          media: Some("a".repeat(64)),
          media_hash: Some(Base64VecU8::from("a".repeat(64).as_bytes().to_vec())),
          copies: Some(1),
          issued_at: None,
          expires_at: None,
          starts_at: None,
          updated_at: None,
          extra: None,
          reference: None,
          reference_hash: None,
          creator: None,
          price: None,
          price_str: None,
          selleble: None,
          status: None,
        },
      );
    }
    if let Some(tokens_per_owner) = &mut self.tokens_per_owner {
      let u = &mut UnorderedSet::new(StorageKey::TokensPerOwner {
        account_hash: env::sha256(tmp_owner_id.as_bytes()),
      });
      u.insert(&tmp_token_id);
      tokens_per_owner.insert(&tmp_owner_id, &u);
    }
    if let Some(approvals_by_id) = &mut self.approvals_by_id {
      let mut approvals = HashMap::new();
      approvals.insert(tmp_owner_id.clone(), 1u64);
      approvals_by_id.insert(&tmp_token_id, &approvals);
    }
    if let Some(next_approval_id_by_id) = &mut self.next_approval_id_by_id {
      next_approval_id_by_id.insert(&tmp_token_id, &1u64);
    }
    let u = UnorderedSet::new(
      StorageKey::TokenPerOwnerInner {
        account_id_hash: hash_account_id(&tmp_owner_id),
      }
      .try_to_vec()
      .unwrap(),
    );
    if let Some(tokens_per_owner) = &mut self.tokens_per_owner {
      tokens_per_owner.insert(&tmp_owner_id, &u);
    }

    // 2. see how much space it took
    self.extra_storage_in_bytes_per_token = env::storage_usage() - initial_storage_usage;

    // 3. roll it all back
    if let Some(next_approval_id_by_id) = &mut self.next_approval_id_by_id {
      next_approval_id_by_id.remove(&tmp_token_id);
    }
    if let Some(approvals_by_id) = &mut self.approvals_by_id {
      approvals_by_id.remove(&tmp_token_id);
    }
    if let Some(tokens_per_owner) = &mut self.tokens_per_owner {
      tokens_per_owner.remove(&tmp_owner_id);
    }
    if let Some(token_metadata_by_id) = &mut self.token_metadata_by_id {
      token_metadata_by_id.remove(&tmp_token_id);
    }
    if let Some(tokens_per_owner) = &mut self.tokens_per_owner {
      tokens_per_owner.remove(&tmp_owner_id);
    }
    self.owner_by_id.remove(&tmp_token_id);
  }

  /// Transfer token_id from `from` to `to`
  ///
  /// Do not perform any safety checks or do any logging
  pub fn internal_transfer_unguarded(
    &mut self,
    token_id: &TokenId,
    from: &AccountId,
    to: &AccountId,
  ) {
    // update owner
    self.owner_by_id.insert(token_id, to);

    // if using Enumeration standard, update old & new owner's token lists
    if let Some(tokens_per_owner) = &mut self.tokens_per_owner {
      // owner_tokens should always exist, so call `unwrap` without guard
      let mut owner_tokens = tokens_per_owner
        .get(from)
        .expect("Unable to access tokens per owner in unguarded call.");
      owner_tokens.remove(&token_id);
      if owner_tokens.is_empty() {
        tokens_per_owner.remove(from);
      } else {
        tokens_per_owner.insert(&from, &owner_tokens);
      }

      let mut receiver_tokens = tokens_per_owner.get(to).unwrap_or_else(|| {
        UnorderedSet::new(StorageKey::TokensPerOwner {
          account_hash: env::sha256(to.as_bytes()),
        })
      });
      receiver_tokens.insert(&token_id);
      tokens_per_owner.insert(&to, &receiver_tokens);
    }
  }

  /// Transfer from current owner to receiver_id, checking that sender is allowed to transfer.
  /// Clear approvals, if approval extension being used.
  /// Return previous owner and approvals.
  pub fn internal_transfer(
    &mut self,
    sender_id: &AccountId,
    receiver_id: &AccountId,
    token_id: &TokenId,
    approval_id: Option<u64>,
    memo: Option<String>,
  ) -> (AccountId, Option<HashMap<AccountId, u64>>) {
    let owner_id = self.owner_by_id.get(token_id).expect("Token not found");

    // clear approvals, if using Approval Management extension
    // this will be rolled back by a panic if sending fails
    let approved_account_ids = self
      .approvals_by_id
      .as_mut()
      .and_then(|by_id| by_id.remove(&token_id));

    // check if authorized
    if sender_id != &owner_id {
      // if approval extension is NOT being used, or if token has no approved accounts
      if approved_account_ids.is_none() {
        env::panic(b"Unauthorized")
      }

      // Approval extension is being used; get approval_id for sender.
      let actual_approval_id = approved_account_ids.as_ref().unwrap().get(sender_id);

      // Panic if sender not approved at all
      if actual_approval_id.is_none() {
        env::panic(b"Sender not approved");
      }

      // If approval_id included, check that it matches
      if let Some(enforced_approval_id) = approval_id {
        let actual_approval_id = actual_approval_id.unwrap();
        assert_eq!(
          actual_approval_id, &enforced_approval_id,
          "The actual approval_id {} is different from the given approval_id {}",
          actual_approval_id, enforced_approval_id,
        );
      }
    }

    assert_ne!(&owner_id, receiver_id, "Current and next owner must differ");

    self.internal_transfer_unguarded(&token_id, &owner_id, &receiver_id);

    log!(
      "Transfer {} from {} to {}",
      token_id,
      sender_id,
      receiver_id
    );
    if let Some(memo) = memo {
      log!("Memo: {}", memo);
    }

    // return previous owner & approvals
    (owner_id, approved_account_ids)
  }
}

impl NonFungibleTokenCore for NonFungibleToken {
  fn nft_transfer(
    &mut self,
    receiver_id: ValidAccountId,
    token_id: TokenId,
    approval_id: Option<u64>,
    memo: Option<String>,
  ) {
    assert_one_yocto();
    let sender_id = env::predecessor_account_id();
    self.internal_transfer(
      &sender_id,
      receiver_id.as_ref(),
      &token_id,
      approval_id,
      memo,
    );
  }

  fn nft_transfer_call(
    &mut self,
    receiver_id: ValidAccountId,
    token_id: TokenId,
    approval_id: Option<u64>,
    memo: Option<String>,
    msg: String,
  ) -> PromiseOrValue<bool> {
    assert_one_yocto();
    let sender_id = env::predecessor_account_id();
    let (old_owner, old_approvals) = self.internal_transfer(
      &sender_id,
      receiver_id.as_ref(),
      &token_id,
      approval_id,
      memo,
    );
    // Initiating receiver's call and the callback
    ext_receiver::nft_on_transfer(
      sender_id.clone(),
      old_owner.clone(),
      token_id.clone(),
      msg,
      receiver_id.as_ref(),
      NO_DEPOSIT,
      env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL,
    )
    .then(ext_self::nft_resolve_transfer(
      old_owner,
      receiver_id.into(),
      token_id,
      old_approvals,
      &env::current_account_id(),
      NO_DEPOSIT,
      GAS_FOR_RESOLVE_TRANSFER,
    ))
    .into()
  }

  fn nft_token(self, token_id: TokenId) -> Option<Token> {
    let owner_id = self.owner_by_id.get(&token_id)?;
    let mut metadata = self
      .token_metadata_by_id
      .and_then(|by_id| by_id.get(&token_id))
      .unwrap();
    metadata.price_str = Some(metadata.price.unwrap().to_string());
    let approved_account_ids = self
      .approvals_by_id
      .and_then(|by_id| by_id.get(&token_id).or_else(|| Some(HashMap::new())));
    Some(Token {
      token_id,
      owner_id,
      metadata: Some(metadata),
      approved_account_ids,
    })
  }

  fn mint(
    &mut self,
    token_id: TokenId,
    token_owner_id: ValidAccountId,
    token_metadata: Option<TokenMetadata>,
  ) -> Token {
    // let initial_storage_usage = env::storage_usage();
    if self.token_metadata_by_id.is_some() && token_metadata.is_none() {
      env::panic(b"Must provide metadata");
    }
    if self.owner_by_id.get(&token_id).is_some() {
      env::panic(b"token_id must be unique");
    }

    let owner_id: AccountId = token_owner_id.into();

    // Core behavior: every token must have an owner
    self.owner_by_id.insert(&token_id, &owner_id);

    // Metadata extension: Save metadata, keep variable around to return later.
    // Note that check above already panicked if metadata extension in use but no metadata
    // provided to call.
    self
      .token_metadata_by_id
      .as_mut()
      .and_then(|by_id| by_id.insert(&token_id, &token_metadata.as_ref().unwrap()));

    // Enumeration extension: Record tokens_per_owner for use with enumeration view methods.
    if let Some(tokens_per_owner) = &mut self.tokens_per_owner {
      let mut token_ids = tokens_per_owner.get(&owner_id).unwrap_or_else(|| {
        UnorderedSet::new(StorageKey::TokensPerOwner {
          account_hash: env::sha256(owner_id.as_bytes()),
        })
      });
      token_ids.insert(&token_id);
      tokens_per_owner.insert(&owner_id, &token_ids);
    }

    // Approval Management extension: return empty HashMap as part of Token
    let approved_account_ids = if self.approvals_by_id.is_some() {
      Some(HashMap::new())
    } else {
      None
    };

    // Return any extra attached deposit not used for storage
    // refund_deposit(env::storage_usage() - initial_storage_usage);

    Token {
      token_id,
      owner_id,
      metadata: token_metadata,
      approved_account_ids,
    }
  }
}

impl NonFungibleTokenResolver for NonFungibleToken {
  /// Returns true if token was successfully transferred to `receiver_id`.
  fn nft_resolve_transfer(
    &mut self,
    previous_owner_id: AccountId,
    receiver_id: AccountId,
    token_id: TokenId,
    approved_account_ids: Option<HashMap<AccountId, u64>>,
  ) -> bool {
    // Get whether token should be returned
    let must_revert = match env::promise_result(0) {
      PromiseResult::NotReady => unreachable!(),
      PromiseResult::Successful(value) => {
        if let Ok(yes_or_no) = near_sdk::serde_json::from_slice::<bool>(&value) {
          yes_or_no
        } else {
          true
        }
      }
      PromiseResult::Failed => true,
    };

    // if call succeeded, return early
    if !must_revert {
      return true;
    }

    // OTHERWISE, try to set owner back to previous_owner_id and restore approved_account_ids

    // Check that receiver didn't already transfer it away or burn it.
    if let Some(current_owner) = self.owner_by_id.get(&token_id) {
      if &current_owner != &receiver_id {
        // The token is not owned by the receiver anymore. Can't return it.
        return true;
      }
    } else {
      // The token was burned and doesn't exist anymore.
      // Refund storage cost for storing approvals to original owner and return early.
      if let Some(approved_account_ids) = approved_account_ids {
        refund_approved_account_ids(previous_owner_id, &approved_account_ids);
      }
      return true;
    };

    log!(
      "Return token {} from @{} to @{}",
      token_id,
      receiver_id,
      previous_owner_id
    );

    self.internal_transfer_unguarded(&token_id, &receiver_id, &previous_owner_id);

    // If using Approval Management extension,
    // 1. revert any approvals receiver already set, refunding storage costs
    // 2. reset approvals to what previous owner had set before call to nft_transfer_call
    if let Some(by_id) = &mut self.approvals_by_id {
      if let Some(receiver_approvals) = by_id.get(&token_id) {
        refund_approved_account_ids(receiver_id, &receiver_approvals);
      }
      if let Some(previous_owner_approvals) = approved_account_ids {
        by_id.insert(&token_id, &previous_owner_approvals);
      }
    }

    false
  }
}

'''
'''--- contract/src/standards/src/non_fungible_token/core/mod.rs ---
mod core_impl;

mod receiver;
mod resolver;

pub use self::core_impl::*;

pub use self::receiver::*;
pub use self::resolver::*;

use crate::non_fungible_token::metadata::TokenMetadata;
use crate::non_fungible_token::token::{Token, TokenId};
use near_sdk::json_types::ValidAccountId;
use near_sdk::PromiseOrValue;

/// Used for all non-fungible tokens. The specification for the
/// [core non-fungible token standard] lays out the reasoning for each method.
/// It's important to check out [NonFungibleTokenReceiver](crate::non_fungible_token::receiver::NonFungibleTokenReceiver)
/// and [NonFungibleTokenResolver](crate::non_fungible_token::resolver::NonFungibleTokenResolver) to
/// understand how the cross-contract call work.
///
/// [core non-fungible token standard]: https://nomicon.io/Standards/NonFungibleToken/Core.html
pub trait NonFungibleTokenCore {
    /// Simple transfer. Transfer a given `token_id` from current owner to
    /// `receiver_id`.
    ///
    /// Requirements
    /// * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes
    /// * Contract MUST panic if called by someone other than token owner or,
    ///   if using Approval Management, one of the approved accounts
    /// * `approval_id` is for use with Approval Management,
    ///   see https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html
    /// * If using Approval Management, contract MUST nullify approved accounts on
    ///   successful transfer.
    /// * TODO: needed? Both accounts must be registered with the contract for transfer to
    ///   succeed. See see https://nomicon.io/Standards/StorageManagement.html
    ///
    /// Arguments:
    /// * `receiver_id`: the valid NEAR account receiving the token
    /// * `token_id`: the token to transfer
    /// * `approval_id`: expected approval ID. A number smaller than
    ///    2^53, and therefore representable as JSON. See Approval Management
    ///    standard for full explanation.
    /// * `memo` (optional): for use cases that may benefit from indexing or
    ///    providing information for a transfer
    fn nft_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    );

    /// Transfer token and call a method on a receiver contract. A successful
    /// workflow will end in a success execution outcome to the callback on the NFT
    /// contract at the method `nft_resolve_transfer`.
    ///
    /// You can think of this as being similar to attaching native NEAR tokens to a
    /// function call. It allows you to attach any Non-Fungible Token in a call to a
    /// receiver contract.
    ///
    /// Requirements:
    /// * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security
    ///   purposes
    /// * Contract MUST panic if called by someone other than token owner or,
    ///   if using Approval Management, one of the approved accounts
    /// * The receiving contract must implement `ft_on_transfer` according to the
    ///   standard. If it does not, FT contract's `ft_resolve_transfer` MUST deal
    ///   with the resulting failed cross-contract call and roll back the transfer.
    /// * Contract MUST implement the behavior described in `ft_resolve_transfer`
    /// * `approval_id` is for use with Approval Management extension, see
    ///   that document for full explanation.
    /// * If using Approval Management, contract MUST nullify approved accounts on
    ///   successful transfer.
    ///
    /// Arguments:
    /// * `receiver_id`: the valid NEAR account receiving the token.
    /// * `token_id`: the token to send.
    /// * `approval_id`: expected approval ID. A number smaller than
    ///    2^53, and therefore representable as JSON. See Approval Management
    ///    standard for full explanation.
    /// * `memo` (optional): for use cases that may benefit from indexing or
    ///    providing information for a transfer.
    /// * `msg`: specifies information needed by the receiving contract in
    ///    order to properly handle the transfer. Can indicate both a function to
    ///    call and the parameters to pass to that function.
    fn nft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    /// Returns the token with the given `token_id` or `null` if no such token.
    fn nft_token(self, token_id: TokenId) -> Option<Token>;

    /// Mint a new token. Not part of official standard, but needed in most situations.
    /// Consuming contract expected to wrap this with an `nft_mint` function.
    ///
    /// Requirements:
    /// * Caller must be the `owner_id` set during contract initialization.
    /// * Caller of the method must attach a deposit of 1 yoctoâ“ƒ for security purposes.
    /// * If contract is using Metadata extension (by having provided `metadata_prefix` during
    ///   contract initialization), `token_metadata` must be given.
    /// * token_id must be unique
    ///
    /// Returns the newly minted token
    fn mint(
        &mut self,
        token_id: TokenId,
        token_owner_id: ValidAccountId,
        token_metadata: Option<TokenMetadata>,
    ) -> Token;
}

'''
'''--- contract/src/standards/src/non_fungible_token/core/receiver.rs ---
use crate::non_fungible_token::token::TokenId;
use near_sdk::{AccountId, PromiseOrValue};

/// Used when an NFT is transferred using `nft_transfer_call`. This trait is implemented on the receiving contract, not on the NFT contract.
pub trait NonFungibleTokenReceiver {
    /// Take some action after receiving a non-fungible token
    ///
    /// Requirements:
    /// * Contract MUST restrict calls to this function to a set of whitelisted NFT
    ///   contracts
    ///
    /// Arguments:
    /// * `sender_id`: the sender of `nft_transfer_call`
    /// * `previous_owner_id`: the account that owned the NFT prior to it being
    ///   transferred to this contract, which can differ from `sender_id` if using
    ///   Approval Management extension
    /// * `token_id`: the `token_id` argument given to `nft_transfer_call`
    /// * `msg`: information necessary for this contract to know how to process the
    ///   request. This may include method names and/or arguments.
    ///
    /// Returns true if token should be returned to `sender_id`
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool>;
}

'''
'''--- contract/src/standards/src/non_fungible_token/core/resolver.rs ---
use crate::non_fungible_token::token::TokenId;
use near_sdk::AccountId;
use std::collections::HashMap;

/// Used when an NFT is transferred using `nft_transfer_call`. This is the method that's called after `nft_on_transfer`. This trait is implemented on the NFT contract.
pub trait NonFungibleTokenResolver {
    /// Finalize an `nft_transfer_call` chain of cross-contract calls.
    ///
    /// The `nft_transfer_call` process:
    ///
    /// 1. Sender calls `nft_transfer_call` on FT contract
    /// 2. NFT contract transfers token from sender to receiver
    /// 3. NFT contract calls `nft_on_transfer` on receiver contract
    /// 4+. [receiver contract may make other cross-contract calls]
    /// N. NFT contract resolves promise chain with `nft_resolve_transfer`, and may
    ///    transfer token back to sender
    ///
    /// Requirements:
    /// * Contract MUST forbid calls to this function by any account except self
    /// * If promise chain failed, contract MUST revert token transfer
    /// * If promise chain resolves with `true`, contract MUST return token to
    ///   `sender_id`
    ///
    /// Arguments:
    /// * `previous_owner_id`: the owner prior to the call to `nft_transfer_call`
    /// * `receiver_id`: the `receiver_id` argument given to `nft_transfer_call`
    /// * `token_id`: the `token_id` argument given to `ft_transfer_call`
    /// * `approvals`: if using Approval Management, contract MUST provide
    ///   set of original approved accounts in this argument, and restore these
    ///   approved accounts in case of revert.
    ///
    /// Returns true if token was successfully transferred to `receiver_id`.
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approvals: Option<HashMap<AccountId, u64>>,
    ) -> bool;
}

'''
'''--- contract/src/standards/src/non_fungible_token/enumeration/enumeration_impl.rs ---
use super::NonFungibleTokenEnumeration;
use crate::non_fungible_token::token::Token;
use crate::non_fungible_token::NonFungibleToken;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::AccountId;

type TokenId = String;

impl NonFungibleToken {
  /// Helper function used by a enumerations methods
  /// Note: this method is not exposed publicly to end users
  fn enum_get_token(&self, owner_id: AccountId, token_id: TokenId) -> Token {
    let metadata = self.token_metadata_by_id.as_ref().unwrap().get(&token_id);
    let approved_account_ids = Some(
      self
        .approvals_by_id
        .as_ref()
        .unwrap()
        .get(&token_id)
        .unwrap_or_default(),
    );

    Token {
      token_id,
      owner_id,
      metadata,
      approved_account_ids,
    }
  }
}

impl NonFungibleTokenEnumeration for NonFungibleToken {
  fn nft_total_supply(self) -> U128 {
    // An unfortunate cast from the max of TreeMap to the spec
    (self.owner_by_id.len() as u128).into()
  }

  fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token> {
    // Get starting index, whether or not it was explicitly given.
    // Defaults to 0 based on the spec:
    // https://nomicon.io/Standards/NonFungibleToken/Enumeration.html#interface
    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    assert!(
      (self.owner_by_id.len() as u128) > start_index,
      "Out of bounds, please use a smaller from_index."
    );
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    assert_ne!(limit, 0, "Cannot provide limit of 0.");
    self
      .owner_by_id
      .iter()
      .skip(start_index as usize)
      .take(limit)
      .map(|(token_id, owner_id)| self.enum_get_token(owner_id, token_id))
      .collect()
  }

  fn nft_supply_for_owner(self, account_id: ValidAccountId) -> U128 {
    let tokens_per_owner = self
      .tokens_per_owner
      .expect("Could not find tokens_per_owner when calling a method on the enumeration standard.");
    tokens_per_owner
      .get(account_id.as_ref())
      .map(|account_tokens| U128::from(account_tokens.len() as u128))
      .unwrap_or(U128(0))
  }

  fn nft_tokens_for_owner(
    &self,
    account_id: ValidAccountId,
    from_index: Option<U128>,
    limit: Option<u64>,
  ) -> Vec<Token> {
    let tokens_per_owner = self
      .tokens_per_owner
      .as_ref()
      .expect("Could not find tokens_per_owner when calling a method on the enumeration standard.");
    let token_set = if let Some(token_set) = tokens_per_owner.get(account_id.as_ref()) {
      token_set
    } else {
      return vec![];
    };
    let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
    assert_ne!(limit, 0, "Cannot provide limit of 0.");
    let start_index: u128 = from_index.map(From::from).unwrap_or_default();
    assert!(
      token_set.len() as u128 > start_index,
      "Out of bounds, please use a smaller from_index."
    );
    token_set
      .iter()
      .skip(start_index as usize)
      .take(limit)
      .map(|token_id| self.enum_get_token(account_id.as_ref().clone(), token_id))
      .collect()
  }
}

'''
'''--- contract/src/standards/src/non_fungible_token/enumeration/mod.rs ---
mod enumeration_impl;

use crate::non_fungible_token::token::Token;
use near_sdk::json_types::{ValidAccountId, U128};

/// Offers methods helpful in determining account ownership of NFTs and provides a way to page through NFTs per owner, determine total supply, etc.
pub trait NonFungibleTokenEnumeration {
    /// Returns the total supply of non-fungible tokens as a string representing an
    /// unsigned 128-bit integer to avoid JSON number limit of 2^53.
    fn nft_total_supply(self) -> U128;

    /// Get a list of all tokens
    ///
    /// Arguments:
    /// * `from_index`: a string representing an unsigned 128-bit integer,
    ///    representing the starting index of tokens to return
    /// * `limit`: the maximum number of tokens to return
    ///
    /// Returns an array of Token objects, as described in Core standard
    fn nft_tokens(
        &self,
        from_index: Option<U128>, // default: "0"
        limit: Option<u64>,       // default: unlimited (could fail due to gas limit)
    ) -> Vec<Token>;

    /// Get number of tokens owned by a given account
    ///
    /// Arguments:
    /// * `account_id`: a valid NEAR account
    ///
    /// Returns the number of non-fungible tokens owned by given `account_id` as
    /// a string representing the value as an unsigned 128-bit integer to avoid JSON
    /// number limit of 2^53.
    fn nft_supply_for_owner(self, account_id: ValidAccountId) -> U128;

    /// Get list of all tokens owned by a given account
    ///
    /// Arguments:
    /// * `account_id`: a valid NEAR account
    /// * `from_index`: a string representing an unsigned 128-bit integer,
    ///    representing the starting index of tokens to return
    /// * `limit`: the maximum number of tokens to return
    ///
    /// Returns a paginated list of all tokens owned by this account
    fn nft_tokens_for_owner(
        &self,
        account_id: ValidAccountId,
        from_index: Option<U128>, // default: "0"
        limit: Option<u64>,       // default: unlimited (could fail due to gas limit)
    ) -> Vec<Token>;
}

'''
'''--- contract/src/standards/src/non_fungible_token/macros.rs ---
/// The core methods for a basic non-fungible token. Extension standards may be
/// added in addition to this macro.
#[macro_export]
macro_rules! impl_non_fungible_token_core {
    ($contract: ident, $token: ident) => {
        use std::collections::HashMap;
        use $crate::non_fungible_token::core::NonFungibleTokenCore;
        use $crate::non_fungible_token::core::NonFungibleTokenResolver;

        #[near_bindgen]
        impl NonFungibleTokenCore for $contract {
            #[payable]
            fn nft_transfer(
                &mut self,
                receiver_id: ValidAccountId,
                token_id: TokenId,
                approval_id: Option<u64>,
                memo: Option<String>,
            ) {
                self.$token
                    .nft_transfer(receiver_id, token_id, approval_id, memo)
            }

            #[payable]
            fn nft_transfer_call(
                &mut self,
                receiver_id: ValidAccountId,
                token_id: TokenId,
                approval_id: Option<u64>,
                memo: Option<String>,
                msg: String,
            ) -> PromiseOrValue<bool> {
                self.$token
                    .nft_transfer_call(receiver_id, token_id, approval_id, memo, msg)
            }

            fn nft_token(self, token_id: TokenId) -> Option<Token> {
                self.$token.nft_token(token_id)
            }

            fn mint(
                &mut self,
                token_id: TokenId,
                token_owner_id: ValidAccountId,
                token_metadata: Option<TokenMetadata>,
            ) -> Token {
                self.$token.mint(token_id, token_owner_id, token_metadata)
            }
        }

        #[near_bindgen]
        impl NonFungibleTokenResolver for $contract {
            #[private]
            fn nft_resolve_transfer(
                &mut self,
                previous_owner_id: AccountId,
                receiver_id: AccountId,
                token_id: TokenId,
                approved_account_ids: Option<HashMap<AccountId, u64>>,
            ) -> bool {
                self.$token.nft_resolve_transfer(
                    previous_owner_id,
                    receiver_id,
                    token_id,
                    approved_account_ids,
                )
            }
        }
    };
}

/// Non-fungible token approval management allows for an escrow system where
/// multiple approvals per token exist.
#[macro_export]
macro_rules! impl_non_fungible_token_approval {
    ($contract: ident, $token: ident) => {
        use $crate::non_fungible_token::approval::NonFungibleTokenApproval;

        #[near_bindgen]
        impl NonFungibleTokenApproval for $contract {
            #[payable]
            fn nft_approve(
                &mut self,
                token_id: TokenId,
                account_id: ValidAccountId,
                msg: Option<String>,
            ) -> Option<Promise> {
                self.$token.nft_approve(token_id, account_id, msg)
            }

            #[payable]
            fn nft_revoke(&mut self, token_id: TokenId, account_id: ValidAccountId) {
                self.$token.nft_revoke(token_id, account_id)
            }

            #[payable]
            fn nft_revoke_all(&mut self, token_id: TokenId) {
                self.$token.nft_revoke_all(token_id)
            }

            fn nft_is_approved(
                self,
                token_id: TokenId,
                approved_account_id: ValidAccountId,
                approval_id: Option<u64>,
            ) -> bool {
                self.$token
                    .nft_is_approved(token_id, approved_account_id, approval_id)
            }
        }
    };
}

/// Non-fungible enumeration adds the extension standard offering several
/// view-only methods to get token supply, tokens per owner, etc.
#[macro_export]
macro_rules! impl_non_fungible_token_enumeration {
    ($contract: ident, $token: ident) => {
        use near_sdk::json_types::U128;
        use $crate::non_fungible_token::enumeration::NonFungibleTokenEnumeration;

        #[near_bindgen]
        impl NonFungibleTokenEnumeration for $contract {
            fn nft_total_supply(self) -> U128 {
                self.$token.nft_total_supply()
            }

            fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token> {
                self.$token.nft_tokens(from_index, limit)
            }

            fn nft_supply_for_owner(self, account_id: ValidAccountId) -> U128 {
                self.$token.nft_supply_for_owner(account_id)
            }

            fn nft_tokens_for_owner(
                &self,
                account_id: ValidAccountId,
                from_index: Option<U128>,
                limit: Option<u64>,
            ) -> Vec<Token> {
                self.$token
                    .nft_tokens_for_owner(account_id, from_index, limit)
            }
        }
    };
}

'''
'''--- contract/src/standards/src/non_fungible_token/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance};

/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "nft-1.0.0";

/// Metadata for the NFT contract itself.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
  pub spec: String,              // required, essentially a version like "nft-1.0.0"
  pub name: String,              // required, ex. "Mosaics"
  pub symbol: String,            // required, ex. "MOSIAC"
  pub icon: Option<String>,      // Data URL
  pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
  pub reference: Option<String>, // URL to a JSON file with more info
  pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum TokenStatus {
  Ok,
  LockedToTransfer,
  LockedToListen,
  SuperOk,
}

/// Metadata on the individual token level.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
  pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
  pub description: Option<String>, // free-form description
  pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
  pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
  pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
  pub issued_at: Option<String>, // ISO 8601 datetime when token was issued or minted
  pub expires_at: Option<String>, // ISO 8601 datetime when token expires
  pub starts_at: Option<String>, // ISO 8601 datetime when token starts being valid
  pub updated_at: Option<String>, // ISO 8601 datetime when token was last updated
  pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
  pub reference: Option<String>, // URL to an off-chain JSON file with more info.
  pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.

  pub status: Option<TokenStatus>,
  pub selleble: Option<bool>,
  pub price: Option<Balance>,
  pub price_str: Option<String>,
  pub creator: Option<AccountId>,
}

/// Offers details on the contract-level metadata.
pub trait NonFungibleTokenMetadataProvider {
  fn nft_metadata(&self) -> NFTContractMetadata;
}

impl NFTContractMetadata {
  pub fn assert_valid(&self) {
    assert_eq!(&self.spec, NFT_METADATA_SPEC);
    assert_eq!(self.reference.is_some(), self.reference_hash.is_some());
    if let Some(reference_hash) = &self.reference_hash {
      assert_eq!(reference_hash.0.len(), 32, "Hash has to be 32 bytes");
    }
  }
}

impl TokenMetadata {
  pub fn assert_valid(&self) {
    assert_eq!(self.media.is_some(), self.media_hash.is_some());
    if let Some(media_hash) = &self.media_hash {
      assert_eq!(media_hash.0.len(), 32, "Media hash has to be 32 bytes");
    }

    assert_eq!(self.reference.is_some(), self.reference_hash.is_some());
    if let Some(reference_hash) = &self.reference_hash {
      assert_eq!(
        reference_hash.0.len(),
        32,
        "Reference hash has to be 32 bytes"
      );
    }
  }
}

'''
'''--- contract/src/standards/src/non_fungible_token/mod.rs ---
/// The [approval management standard](https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html) for NFTs.
pub mod approval;
/// The [core non-fungible token standard](https://nomicon.io/Standards/NonFungibleToken/Core.html). This can be though of as the base standard, with the others being extension standards.
pub mod core;
/// Common implementation of the [core non-fungible token standard](https://nomicon.io/Standards/NonFungibleToken/Core.html).
/// Trait for the [NFT enumeration standard](https://nomicon.io/Standards/NonFungibleToken/Enumeration.html).
/// This provides useful view-only methods returning token supply, tokens by owner, etc.
pub mod enumeration;
/// Macros typically used by a contract wanting to take advantage of the non-fungible
/// token NEAR contract standard approach.
mod macros;
/// Metadata traits and implementation according to the [NFT enumeration standard](https://nomicon.io/Standards/NonFungibleToken/Metadata.html).
/// This covers both the contract metadata and the individual token metadata.
pub mod metadata;
/// The Token struct for the non-fungible token.
mod token;
pub use self::token::{Token, TokenId};

/// NFT utility functions
mod utils;
pub use utils::*;

pub use self::core::NonFungibleToken;
pub use macros::*;

'''
'''--- contract/src/standards/src/non_fungible_token/token.rs ---
use crate::non_fungible_token::metadata::TokenMetadata;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use std::collections::HashMap;

/// Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
pub type TokenId = String;

/// In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
  pub token_id: TokenId,
  pub owner_id: AccountId,
  pub metadata: Option<TokenMetadata>,
  pub approved_account_ids: Option<HashMap<AccountId, u64>>,
}

'''
'''--- contract/src/standards/src/non_fungible_token/utils.rs ---
use near_sdk::{env, AccountId, Balance, CryptoHash, Promise};
use std::collections::HashMap;
use std::mem::size_of;

// TODO: need a way for end users to determine how much an approval will cost.
pub fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.len() as u64 + 4 + size_of::<u64>() as u64
}

pub fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I,
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    let storage_released: u64 = approved_account_ids.map(bytes_for_approved_account_id).sum();
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

pub fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

pub fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

pub fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

/// Assert that at least 1 yoctoNEAR was attached.
pub(crate) fn assert_at_least_one_yocto() {
    assert!(env::attached_deposit() >= 1, "Requires attached deposit of at least 1 yoctoNEAR")
}

'''
'''--- contract/src/standards/src/storage_management/mod.rs ---
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::Serialize;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    // if `registration_only=true` MUST refund above the minimum balance if the account didn't exist and
    //     refund full deposit if the account exists.
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Withdraw specified amount of available â“ƒ for predecessor account.
    ///
    /// This method is safe to call. It MUST NOT remove data.
    ///
    /// `amount` is sent as a string representing an unsigned 128-bit integer. If
    /// omitted, contract MUST refund full `available` balance. If `amount` exceeds
    /// predecessor account's available balance, contract MUST panic.
    ///
    /// If predecessor account not registered, contract MUST panic.
    ///
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted
    /// function-call access-key call (UX wallet security)
    ///
    /// Returns the StorageBalance structure showing updated balances.
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance;

    /// Unregisters the predecessor account and returns the storage NEAR deposit back.
    ///
    /// If the predecessor account is not registered, the function MUST return `false` without panic.
    ///
    /// If `force=true` the function SHOULD ignore account balances (burn them) and close the account.
    /// Otherwise, MUST panic if caller has a positive registered balance (eg token holdings) or
    ///     the contract doesn't support force unregistration.
    /// MUST require exactly 1 yoctoNEAR attached balance to prevent restricted function-call access-key call
    /// (UX wallet security)
    /// Returns `true` iff the account was unregistered.
    /// Returns `false` iff account was not registered before.
    fn storage_unregister(&mut self, force: Option<bool>) -> bool;

    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
}

'''
'''--- contract/src/standards/src/upgrade/mod.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::WrappedDuration;
use near_sdk::{env, AccountId, Duration, Promise, Timestamp};

pub trait Ownable {
    fn assert_owner(&self) {
        assert_eq!(env::predecessor_account_id(), self.get_owner());
    }
    fn get_owner(&self) -> AccountId;
    fn set_owner(&mut self, owner: AccountId);
}

pub trait Upgradable {
    fn get_staging_duration(&self) -> WrappedDuration;
    fn stage_code(&mut self, code: Vec<u8>, timestamp: Timestamp);
    fn deploy_code(&mut self) -> Promise;

    /// Implement migration for the next version.
    /// Should be `unimplemented` for a new contract.
    /// TODO: consider adding version of the contract stored in the storage?
    fn migrate(&mut self) {
        unimplemented!();
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Upgrade {
    pub owner: AccountId,
    pub staging_duration: Duration,
    pub staging_timestamp: Timestamp,
}

impl Upgrade {
    pub fn new(owner: AccountId, staging_duration: Duration) -> Self {
        Self { owner, staging_duration, staging_timestamp: 0 }
    }
}

impl Ownable for Upgrade {
    fn get_owner(&self) -> AccountId {
        self.owner.clone()
    }

    fn set_owner(&mut self, owner: AccountId) {
        self.assert_owner();
        self.owner = owner;
    }
}

impl Upgradable for Upgrade {
    fn get_staging_duration(&self) -> WrappedDuration {
        self.staging_duration.into()
    }

    fn stage_code(&mut self, code: Vec<u8>, timestamp: Timestamp) {
        self.assert_owner();
        assert!(
            env::block_timestamp() + self.staging_duration < timestamp,
            "Timestamp must be later than staging duration"
        );
        // Writes directly into storage to avoid serialization penalty by using default struct.
        env::storage_write(b"upgrade", &code);
        self.staging_timestamp = timestamp;
    }

    fn deploy_code(&mut self) -> Promise {
        if self.staging_timestamp < env::block_timestamp() {
            env::panic(
                &format!(
                    "Deploy code too early: staging ends on {}",
                    self.staging_timestamp + self.staging_duration
                )
                .into_bytes(),
            );
        }
        let code = env::storage_read(b"upgrade").expect("No upgrade code available");
        env::storage_remove(b"upgrade");
        Promise::new(env::current_account_id()).deploy_contract(code)
    }
}

'''
'''--- logo.svg ---
<?xml version="1.0"?>
<svg style="enable-background:new 0 0 91 91;" version="1.1" viewBox="0 0 91 91" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<g>
		<g>
			<circle xmlns="http://www.w3.org/2000/svg" cx="50%" cy="50%" r="45" fill="#ffdd9a" />
			<g transform="translate(0, 4.5)">
				<path fill="black" d="M27.3,27c2,2,4,4,5.8,6.1c2.8,3.2,7.9-1.9,4.6-4.6c-3-2.5-5.7-5.3-8.6-8c-1.4-1.4-3.6-1-4.7,0.6     c-2.3,3.6-5,6.6-8.2,9.3c-1.5,1.3,0.1,4.3,2.1,3.6C21.9,32.5,24.8,29.9,27.3,27z" />
				<path fill="black" d="M73.4,28.4c-3-2.5-5.7-5.3-8.6-8c-1.4-1.4-3.6-1-4.7,0.6c-2.3,3.6-5,6.6-8.2,9.3c-1.5,1.3,0.1,4.3,2.1,3.6     c3.6-1.4,6.5-4,9-6.9c2,2,4,4,5.8,6.1C71.5,36.3,76.6,31.1,73.4,28.4z" />
				<path fill="black" d="M63.3,51.3C52.2,49.8,40,48.1,29,51.2c-0.6,0-1.2,0.2-1.7,0.5c0,0,0,0,0,0c-0.2,0.1-0.4,0.2-0.5,0.4     c-1.3,1.1-1.8,3.1-0.3,5c2.8,3.6,5.8,6.9,9.3,9.7c2.6,2.1,6.2,5.8,9.8,4.9c3.6-0.9,7.4-4.8,10.1-7.2c3.4-3,6.3-6.4,9.1-10     C65.4,53.5,64.6,51.5,63.3,51.3z M45.4,65.5c-1.6,0.8-2.1-0.2-3.5-1.3c-1.2-1-2.4-2.1-3.5-3.2c-2.3-2.3-4.3-4.7-6.1-7.4     c4.1-0.1,8.1-0.2,12.2,0c4.7,0.2,9.3,0.7,13.9,1.3C54.6,59,50.2,63,45.4,65.5z" />
			</g>
		</g>
	</g>
</svg>

'''
'''--- package.json ---
{
  "name": "be_positive",
  "version": "0.0.1",
  "license": "UNLICENSED",
  "scripts": {
    "build": "node contract/compile.js",
    "build:debug": "node contract/compile.js --debug",
    "dev:deploy": "npm run build:debug && npx near dev-deploy && rm -rf out",
    "deploy": "npm run build && npx near deploy"
  },
  "devDependencies": {
    "near-cli": "^2.1.1",
    "shelljs": "^0.8.4"
  },
  "dependencies": {}
}

'''