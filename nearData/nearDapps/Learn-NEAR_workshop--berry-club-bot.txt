*GitHub Repository "Learn-NEAR/workshop--berry-club-bot"*

'''--- Cargo.toml ---
[package]
name = "berry-bot"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

[features]
for_real = []

'''
'''--- README.md ---
# Berry Club Bot Workshop

This is a workshop to cover basics of NEAR Protocol smart-contracts written in Rust.

## Support

* Telegram: [https://t.me/neardev](https://t.me/neardev)
* Discord [https://near.chat](https://near.chat)
* Docs: [https://docs.near.org/](https://docs.near.org/)

## Preparation

### Install required tools

NOTE: This process is for Unix-like system, e.g. Linux or Mac OS. Windows installation process is different and covered in [`README_Windows.md`](./README_Windows.md).

#### Install [Rustup](https://rustup.rs/):

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env
```

#### Add wasm target to your toolchain:

```bash
rustup target add wasm32-unknown-unknown
```

#### Install `near-cli`

See [`near-cli` installation docs](https://docs.near.org/docs/development/near-cli#installation)

#### Install `git`

See [installation guide](https://github.com/git-guides/install-git) from github.

### Prepare workshop repo and verify tools installation

#### Clone the workshop repository

```bash
git clone https://github.com/evgenykuzyakov/workshop
cd workshop
```

It should clone the repository to a local folder `workshop`.

#### Compile the contract

```bash
./build.sh
```

If you have successfully installed Rust and `wasm32` target, then `./build.sh` should compile the contract into `res/berry_bot.wasm`.
```
   Compiling autocfg v1.0.0
   Compiling proc-macro2 v1.0.9
   Compiling unicode-xid v0.2.0
   ...
   Compiling near-vm-logic v2.0.0
   Compiling near-sdk v2.0.0
   Compiling berry-bot v0.1.0 (workshop)
    Finished release [optimized] target(s) in 43.13s
```

#### You can check that the contract is present in `res/berry_bot.wasm`

```bash
test res/berry_bot.wasm && echo "OK" || echo "BAD :("
```

I hope you see `OK`

### Setup NEAR account

#### Register a new account on testnet.

You can create a new account using [NEAR Testnet Wallet](https://wallet.testnet.near.org/)
It'll create a new account for you on the NEAR Testnet. The full account ID will be something like `alice.testnet`

As a `Security Method` for this workshop I'd recommend to use either `Recovery Phrase` or `Email Recovery`.

#### Authorize your account with `near-cli`

To allow using your account with `near-cli` you need to login from the terminal.
```bash
near login
```

This should open a new browser tab in the NEAR Testnet web-wallet and ask you give `full access` to your account.
It's fine to do, since we're talking about Testnet account.
You'll need access from command line and `near-cli` for this workshop.

Once you authorized it in the browser, the command line should automatically succeed.

You should see something like this in the console:
```
Logged in as [ alice.testnet ] with public key [ ed25519:HP3oxy... ] successfully
```

#### Store your account ID into local variable

To help with this workshop let's store your account ID into `ACCOUNT_ID` variable in bash.
Replace `<YOUR_ACCOUNT_ID>` with your actual account ID that you created in the wallet, e.g. `alice.testnet`.

```bash
export ACCOUNT_ID=<YOUR_ACCOUNT_ID>
```

#### Verification

Let's verify that you've successfully created the account and added it to `near-cli`.

Run the following:
```bash
near call --accountId=$ACCOUNT_ID workshop.testnet hello
```

If it succeeded then you've successfully completed your account setup. You should see something like this:
```
Scheduling a call: workshop.testnet.hello()
Receipt: 5rKUqv4t9JVQryvyfrgrFr8R48iV4sFX7nD56KUv6Vhb
	Log [workshop.testnet]: Hello, test-12331.testnet!
Transaction Id 8D2L4AdhbZ3CqWXMpRURsyqUTNJaBJDcFQsN4W8vU4y7
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/8D2L4AdhbZ3CqWXMpRURsyqUTNJaBJDcFQsN4W8vU4y7
'Hello, test-12331.testnet!'
```

**Congrats!**

## Part 1 - Fix my code

Guess what, I made a bunch of errors in the implementation and you need to fix them.
Good thing, that I've added unit tests before I broke the code.

Run unit tests
```bash
./test.sh
```

You'll see a failed test. E.g.
```
running 1 test
test rect::tests::test_rect_complex ... FAILED

failures:

---- rect::tests::test_rect_complex stdout ----

00 ..................................................
01 ..................................................
02 ..................................................
03 .....XXXX.........................................
04 .....XXXX.........................................
05 .....XXXX.........................................
06 .....XXXX.........................................
07 ..................................................
08 ..................................................
09 ..................................................
10 ..................................................
11 ..................................................
12 ..................................................
13 ..................................................
14 ..................................................
15 ..................................................
16 ..................................................
17 ..................................................
18 ..................................................
19 ..................................................
20 ..................................................
21 ..................................................
22 ..................................................
23 ..................................................
24 ..................................................
25 ..................................................
26 ..................................................
27 ..................................................
28 ..................................................
29 ..................................................
30 ..................................................
31 ..................................................
32 ..................................................
33 ..................................................
34 ..................................................
35 ..................................................
36 ..................................................
37 ..................................................
38 ..................................................
39 ..................................................
40 ..................................................
41 ..................................................
42 ..................................................
43 ..................................................
44 ..................................................
45 ..................................................
46 ..................................................
47 ..................................................
48 ..................................................
49 ..................................................
thread 'rect::tests::test_rect_complex' panicked at 'assertion failed: `(left == right)`
  left: `".....XXXX......"`,
 right: `"..............."`: Line 3', src/rect.rs:90:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

It means the test `test_rect_complex` has failed and the assert at file `src/rect.rs` line `90` failed.
Open the file and try to figure out what went wrong. Once you figured out what is wrong, try rerunning tests.

Repeat the process of fixing the implementation (not tests) to resolve all bugs.

Once all unit tests are fixed, you're ready to move to the part 2.

## Part 2 - Let's draw

In this part you'll need to implement a new method that will draw something complex.
To do this, you can use rectangle and circle primitives and later merge them into one image.

Run
```bash
./draw_art.sh
```

You should see a preview of the art. Right now it renders a target with three circles.

```
00 ..................................................
01 ..................................................
02 ..................................................
03 ..................................................
04 ..................................................
05 .................XXXXXXX..........................
06 ..............XXX.......XXX.......................
07 ............XX.............XX.....................
08 ...........X.................X....................
09 ..........X...................X...................
10 .........X.......XXXXXXX.......X..................
11 ........X......XXX.....XXX......X.................
12 .......X......X...........X......X................
13 .......X.....X.............X.....X................
14 ......X.....X...............X.....X...............
15 ......X....X......XXXXX......X....X...............
16 ......X....X.....XX...XX.....X....X...............
17 .....X....XX....X.......X....XX....X..............
18 .....X....X....XX.......XX....X....X..............
19 .....X....X....X.........X....X....X..............
20 .....X....X....X.........X....X....X..............
21 .....X....X....X.........X....X....X..............
22 .....X....X....XX.......XX....X....X..............
23 .....X....XX....X.......X....XX....X..............
24 ......X....X.....XX...XX.....X....X...............
25 ......X....X......XXXXX......X....X...............
26 ......X.....X...............X.....X...............
27 .......X.....X.............X.....X................
28 .......X......X...........X......X................
29 ........X......XXX.....XXX......X.................
30 .........X.......XXXXXXX.......X..................
31 ..........X...................X...................
32 ...........X.................X....................
33 ............XX.............XX.....................
34 ..............XXX.......XXX.......................
35 .................XXXXXXX..........................
36 ..................................................
37 ..................................................
38 ..................................................
39 ..................................................
40 ..................................................
41 ..................................................
42 ..................................................
43 ..................................................
44 ..................................................
45 ..................................................
46 ..................................................
47 ..................................................
48 ..................................................
49 ..................................................
test art::tests::draw_art ... ok
```

Now, open file `src/art.rs` and modify the implementation of method `internal_render_art` at line `26`.

You can draw whatever you want and debug it using `./draw_art.sh`.
But note, that too many pixels might lead to performance issues.

Once you are satisfied with your art preview, it's time to try it for real.

## Part 3 - Deploy to testnet

### Recompile the contract

You've modified the code to fix tests and implemented your art, so we need to rebuild.
```bash
./build.sh
```

Every time you modify code of your contract you may want to recompile the contract.
The resulting binary is be located at `res/berry_bot.wasm`

### Deploying the contract

Accounts in NEAR Protocol can also contain one contract. The contract has full access to the account it belongs.
But a new transaction can only be initiated by signing this transaction with an access key (this stops Skynet and singularity).
A transaction may call a method on the contract by name and pass arguments.

To deploy a contract, we need to issue a transaction.
I wrote a convenient script to deploy the contract to your account stored in `$ACCOUNT_ID`.
(All it does is `near deploy $ACCOUNT_ID res/berry_bot.wasm`)
```bash
./deploy.sh
```

You should see something like this:

```
Starting deployment. Account id: test-12331.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: res/berry_bot.wasm
Transaction Id 7jxk9ANig8wJ1BqFennJN4pSuVaMn9n3HjaeKfDYfsDY
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/7jxk9ANig8wJ1BqFennJN4pSuVaMn9n3HjaeKfDYfsDY
Done deploying to test-12331.testnet
```

NOTE: You can re-deploy your contract multiple times, so long as you have access key on the account.
Every time you've modified the code and want to change the contract on-chain you need to recompile and redeploy.

### Call the contract

To call `<METHOD_NAME>` on your contract with arguments `<ARGS>` issue the following command:
```bash
near call $ACCOUNT_ID --accountId=$ACCOUNT_ID --gas=300000000000000 <METHOD_NAME> <ARGS>
```

* `<METHOD_NAME>` is a public method name that you want to call from the contract
* `<ARGS>` are JSON encoded arguments to the method, e.g. `'{"left": 10, "top": 20, "width": 10, "height": 5, "color": 16711680}'`

Since bash needs to keep JSON in one string, we recommend to wrap args with `'` when passing it, e.g. `'{}'` 

For example to draw you art, you need to call the following:
```bash
near call $ACCOUNT_ID --accountId=$ACCOUNT_ID --gas=300000000000000 render_art '{}'
```

If everything works well, then you should see your art rendered in logs, e.g.:
```
Scheduling a call: test-12331.testnet.render_art({})
Receipts: B3odJ16wnajwsrUbw2PVZyY2QDCbwFJsTAXvsWTaGGZV, 7FMyKSgszNgGhCBYv7Sg7jVS2b2LzTJ4w8e9T1fTEDWV
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: .................XXXXXXX..........................
	Log [test-12331.testnet]: ..............XXX.......XXX.......................
	Log [test-12331.testnet]: ............XX.............XX.....................
	Log [test-12331.testnet]: ...........X.................X....................
	Log [test-12331.testnet]: ..........X...................X...................
	Log [test-12331.testnet]: .........X.......XXXXXXX.......X..................
	Log [test-12331.testnet]: ........X......XXX.....XXX......X.................
	Log [test-12331.testnet]: .......X......X...........X......X................
	Log [test-12331.testnet]: .......X.....X.............X.....X................
	Log [test-12331.testnet]: ......X.....X...............X.....X...............
	Log [test-12331.testnet]: ......X....X......XXXXX......X....X...............
	Log [test-12331.testnet]: ......X....X.....XX...XX.....X....X...............
	Log [test-12331.testnet]: .....X....XX....X.......X....XX....X..............
	Log [test-12331.testnet]: .....X....X....XX.......XX....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....XX.......XX....X....X..............
	Log [test-12331.testnet]: .....X....XX....X.......X....XX....X..............
	Log [test-12331.testnet]: ......X....X.....XX...XX.....X....X...............
	Log [test-12331.testnet]: ......X....X......XXXXX......X....X...............
	Log [test-12331.testnet]: ......X.....X...............X.....X...............
	Log [test-12331.testnet]: .......X.....X.............X.....X................
	Log [test-12331.testnet]: .......X......X...........X......X................
	Log [test-12331.testnet]: ........X......XXX.....XXX......X.................
	Log [test-12331.testnet]: .........X.......XXXXXXX.......X..................
	Log [test-12331.testnet]: ..........X...................X...................
	Log [test-12331.testnet]: ...........X.................X....................
	Log [test-12331.testnet]: ............XX.............XX.....................
	Log [test-12331.testnet]: ..............XXX.......XXX.......................
	Log [test-12331.testnet]: .................XXXXXXX..........................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
Transaction Id ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3
''
```

You can also click the explorer link to see this on chain, e.g [Target](https://explorer.testnet.near.org/transactions/ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3)

There is a helper script that let you call methods on your contract easier `./call.sh`.
```bash
./call.sh <METHOD_NAME> <ARGS>
```

An example of a command to render a red rectangle
```bash
./call.sh render_rect '{"left": 10, "top": 20, "width": 10, "height": 5, "color": 16711680}'
```

Or to render your art
```bash
./call.sh render_art '{}'
```

## Part 4 - Test in Prod

If you were able to see your art in the explorer, you've already made the history on Testnet. It's now persistent on chain.
The next step is to use it with the real app.

### Build for real

Your current contract doesn't actually issue cross-contract calls to berry club, so you need to re-compile it with a compilation feature.
```bash
./build_for_real.sh
```

Now redeploy your contract
```bash
./deploy.sh
```

Game on.

### Buy some 🥑

The first thing we'll need is to buy some avocados to draw in the berry club.
Your contract has a helper method `buy_avocado` to do this.
```bash
./call.sh buy_avocado '{}'
```

You should see a log message like this:
```
	Log [test-12331.testnet]: Purchased 15001.500 Avocado tokens for 50.000 NEAR
```

`50 NEAR` is enough to get you `15000` 🥑 and this is enough to draw `15000` pixels.

### Open Berry Club on the Testnet

[test.berryclub.io](https://test.berryclub.io)

You should see a board. It might be messy, because everyone shares the same board.
You can login with your testnet account using web-wallet. This will display your name and your avocado balance.

Keep this tab open.

### Let's render your art

```bash
./call.sh render_art '{}'
```

You should see it rendered on the board in the browser.
You should also see your account ID in the list on the right.
If you hover over your account ID in the list, it will highlight your pixels.

### Iterate

Now try drawing other primitives by using `./call.sh`

Remember, if you modify the code, then you need to recompile and redeploy the contract.

Enjoy!

'''
'''--- README_RU.md ---
# Berry Club Bot Workshop

На этом семинаре вы познакомитесь с основами разработки смарт-контрактов на языке Rust для NEAR Protocol.

## Тех-поддержка

* Телеграм РУС: [https://t.me/near_protocol](https://t.me/near_protocol)
* Телеграм ENG: [https://t.me/neardev](https://t.me/neardev)
* Discord [https://near.chat](https://near.chat)
* Документация ENG: [https://docs.near.org/](https://docs.near.org/)

## Подготовка

### Установка

Описанный процесс походит для систем Unix, например Linux или Mac OS. Процесс установки для Windows описан тут [`README_Windows.md`](./README_Windows.md)
 (на английском).

#### Установить [Rustup](https://rustup.rs/):

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env
```

#### Добавить wasm target:

```bash
rustup target add wasm32-unknown-unknown
```

#### Установить `near-cli`

Документация по установке на английском: [`near-cli` installation docs](https://docs.near.org/docs/development/near-cli#installation)

Если `npm` уже установлена, то можно установить `near-cli`:
```bash
npm install -g near-cli
```

#### Установить `git`

Документация по установке на английском: [installation guide](https://github.com/git-guides/install-git) от github.

### Подготовка репозитория и проверка установки

#### Склонируйте репозиторий

```bash
git clone https://github.com/evgenykuzyakov/workshop
cd workshop
```

Это создаст локальную папку `workshop`.

#### Скомпилируйте смарт контракт

```bash
./build.sh
```

Если Rust и `wasm32` были успешно установлены, то `./build.sh` должен скомпилировать контракт в файл `res/berry_bot.wasm`.
```
   Compiling autocfg v1.0.0
   Compiling proc-macro2 v1.0.9
   Compiling unicode-xid v0.2.0
   ...
   Compiling near-vm-logic v2.0.0
   Compiling near-sdk v2.0.0
   Compiling berry-bot v0.1.0 (workshop)
    Finished release [optimized] target(s) in 43.13s
```

#### Проверим, что файл существует `res/berry_bot.wasm`

```bash
test res/berry_bot.wasm && echo "OK" || echo "BAD :("
```

Надеюсь это `OK`

### Настройка аккаунта в NEAR

#### Регистрация нового аккаунта для testnet.

Создайте новый аккаунт используя [NEAR Testnet Wallet](https://wallet.testnet.near.org/)
Web-wallet создаст новый аккаунт на тестовый сети testnet и добавит 200 тестовых NEAR токенов на этот аккаунт.
Запомните свой полный account ID, например `alice.testnet`

В качестве `метода восстановления/Security Method` для этого семинара рекомендуется использовать `Мнемоническую фразу/Recovery Phrase` или `Электронная почта/Email Recovery`.

#### Авторизуйте свой аккаунт в `near-cli`

Чтобы использовать свой аккаунт в `near-cli`, нужно добавить новый ключ в web-wallet:
```bash
near login
```

Это команда откроет новую вкладку в браузере с NEAR Testnet web-wallet и запросит `полный доступ/full access` к вашему аккаунту.
Для этого семинара вам понадобится полный доступ из `near-cli`.

Как только вы разрешите доступ в браузере, командая строка должна успешно завершиться.

Вы должны увидеть что-то подобное в терминале:
```
Logged in as [ alice.testnet ] with public key [ ed25519:HP3oxy... ] successfully
```

#### Сохраните ваше имя использователя в локальную переменную

Для упрощения, сохраните ваше имя использователя в переменную `ACCOUNT_ID` в bash.
Замените `<ИМЯ_ПОЛЬЗОВАТЕЛЯ>` на ваше настоящее имя использователя (account ID который вы создали в web-wallet), например `alice.testnet`.

```bash
export ACCOUNT_ID=<ИМЯ_ПОЛЬЗОВАТЕЛЯ>
```

#### Проверка

Проверим, что вы успешно создали аккаунт и добавили доступ в `near-cli`.

Выполните эту команду:
```bash
near call --accountId=$ACCOUNT_ID workshop.testnet hello
```

Вы должны увидеть что-то подобное:
```
Scheduling a call: workshop.testnet.hello()
Receipt: 5rKUqv4t9JVQryvyfrgrFr8R48iV4sFX7nD56KUv6Vhb
	Log [workshop.testnet]: Hello, test-12331.testnet!
Transaction Id 8D2L4AdhbZ3CqWXMpRURsyqUTNJaBJDcFQsN4W8vU4y7
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/8D2L4AdhbZ3CqWXMpRURsyqUTNJaBJDcFQsN4W8vU4y7
'Hello, test-12331.testnet!'
```

**Поздравляем!**

## Часть 1 - Баги

Какая неудача! Я сделал пару ошибок пока писал этот смарт контракт, и вам надо их исправить.
Плюс в том, что я добавил тесты, которые работают.

Запустите тесты
```bash
./test.sh
```

Вы должны увидеть нерабочий тест, например:
```
running 1 test
test rect::tests::test_rect_complex ... FAILED

failures:

---- rect::tests::test_rect_complex stdout ----

00 ..................................................
01 ..................................................
02 ..................................................
03 .....XXXX.........................................
04 .....XXXX.........................................
05 .....XXXX.........................................
06 .....XXXX.........................................
07 ..................................................
08 ..................................................
09 ..................................................
10 ..................................................
11 ..................................................
12 ..................................................
13 ..................................................
14 ..................................................
15 ..................................................
16 ..................................................
17 ..................................................
18 ..................................................
19 ..................................................
20 ..................................................
21 ..................................................
22 ..................................................
23 ..................................................
24 ..................................................
25 ..................................................
26 ..................................................
27 ..................................................
28 ..................................................
29 ..................................................
30 ..................................................
31 ..................................................
32 ..................................................
33 ..................................................
34 ..................................................
35 ..................................................
36 ..................................................
37 ..................................................
38 ..................................................
39 ..................................................
40 ..................................................
41 ..................................................
42 ..................................................
43 ..................................................
44 ..................................................
45 ..................................................
46 ..................................................
47 ..................................................
48 ..................................................
49 ..................................................
thread 'rect::tests::test_rect_complex' panicked at 'assertion failed: `(left == right)`
  left: `".....XXXX......"`,
 right: `"..............."`: Line 3', src/rect.rs:90:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Это значит `test_rect_complex` не работает. И assert в файле `src/rect.rs` строка `90` неверный.
Откройте этот файл и пропробуйте разобраться, что пошло не так.
После того как вы найдете ошибку и исправите ее, перезапустите тесты.

Повторяйте этот процесс, пока не исправите все ошибки в коде (не в тестах).

Как только все ошибки исправлены, и тесты работают, можно переходить к Часть 2.

## Часть 2 - Порисуем

В этой части вам нужно будет изменить новый метод в смарт контракте, чтобы нарисовать что-то посложнее.
Чтобы это сделать, можно использовать примитивы прямоугольника и окружности, а потом соединить их в одну картинку.

Выполните
```bash
./draw_art.sh
```

Вы должны увидеть текстовое изображение вашего рисунка. Сейчас это мишень с тремя окружностями.

```
00 ..................................................
01 ..................................................
02 ..................................................
03 ..................................................
04 ..................................................
05 .................XXXXXXX..........................
06 ..............XXX.......XXX.......................
07 ............XX.............XX.....................
08 ...........X.................X....................
09 ..........X...................X...................
10 .........X.......XXXXXXX.......X..................
11 ........X......XXX.....XXX......X.................
12 .......X......X...........X......X................
13 .......X.....X.............X.....X................
14 ......X.....X...............X.....X...............
15 ......X....X......XXXXX......X....X...............
16 ......X....X.....XX...XX.....X....X...............
17 .....X....XX....X.......X....XX....X..............
18 .....X....X....XX.......XX....X....X..............
19 .....X....X....X.........X....X....X..............
20 .....X....X....X.........X....X....X..............
21 .....X....X....X.........X....X....X..............
22 .....X....X....XX.......XX....X....X..............
23 .....X....XX....X.......X....XX....X..............
24 ......X....X.....XX...XX.....X....X...............
25 ......X....X......XXXXX......X....X...............
26 ......X.....X...............X.....X...............
27 .......X.....X.............X.....X................
28 .......X......X...........X......X................
29 ........X......XXX.....XXX......X.................
30 .........X.......XXXXXXX.......X..................
31 ..........X...................X...................
32 ...........X.................X....................
33 ............XX.............XX.....................
34 ..............XXX.......XXX.......................
35 .................XXXXXXX..........................
36 ..................................................
37 ..................................................
38 ..................................................
39 ..................................................
40 ..................................................
41 ..................................................
42 ..................................................
43 ..................................................
44 ..................................................
45 ..................................................
46 ..................................................
47 ..................................................
48 ..................................................
49 ..................................................
test art::tests::draw_art ... ok
```

Откройте файл `src/art.rs` и измените метод `internal_render_art` начиная со строки `26`.

Можете нарисовать, что хотите и тестировать это, выполняя `./draw_art.sh`.
Но если вы будете использовать слишком много точек, то это может негативно отразиться на производительности.

Когда вы закончите рисовать в текстовом режиме, то можно будет попробовать это по-настоящему.

## Часть 3 - Запускаем на testnet

### Перекомпилируйте смарт контракт

После того как вы исправили код и добавили ваш рисунок, нужно перекомпилировать смарт контракт.
```bash
./build.sh
```

Каждый раз, когда вы изменяете код контракта, вам нужно будет перекомпилировать контракт.
Результатом служит код файле `res/berry_bot.wasm`

### Добавляем контракт на аккаунт

Аккаунты в NEAR Protocol также могут содержать смарт контракт.
Смарт контракт имеет полный доступ к аккаунту, на котором он расположен.
Но новые транзакции могут быть созданы только пользователями, у которых есть ключ доступа к аккаунту (Это останавливает Skynet и сингулярность).
Транзакция может вызвать метод на смарт контракте и передать параметры.

Чтобы добавить смарт контракт к аккаунту, нужно создать транзакцию.
Я добавил скрипт, который позволяет добавить смарт контракт (или заменить текущий) на ваш аккаунт из переменной `$ACCOUNT_ID`.
(Все что он делает это `near deploy $ACCOUNT_ID res/berry_bot.wasm`)
```bash
./deploy.sh
```

Вы должны увидеть что-то подобное
```
Starting deployment. Account id: test-12331.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: res/berry_bot.wasm
Transaction Id 7jxk9ANig8wJ1BqFennJN4pSuVaMn9n3HjaeKfDYfsDY
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/7jxk9ANig8wJ1BqFennJN4pSuVaMn9n3HjaeKfDYfsDY
Done deploying to test-12331.testnet
```

Смарт контракт можно изменять много раз.
Каждый раз когда вы изменили код контракта и хотите изменить его на вашем аккаунте, то его нужно перекомпилировать и добавить к аккаунту заного (используя ./deploy.sh).

### Вызов смарт контракта

Чтобы вызвать метод `<МЕТОД>` на вашем смарт контракте с параметрами `<ПАРАМЕТРЫ>`, вызовите следующую команду:
```bash
near call $ACCOUNT_ID --accountId=$ACCOUNT_ID --gas=300000000000000 <МЕТОД> <ПАРАМЕТРЫ>
```

* `<МЕТОД>` - это публичный метод в коде контракта, объявленный с помощью `pub fn`
* `<ПАРАМЕТРЫ>` - это параметры метода, сериализованные с помощью JSON, например `'{"left": 10, "top": 20, "width": 10, "height": 5, "color": 16711680}'`

Так как bash должен получить параметры одной строкой, то рекомендуется оборачивать параметры в `'`, например `'{}'`

Например, чтобы нарисовать ваш рисунок, нужно вызвать следующее:
```bash
near call $ACCOUNT_ID --accountId=$ACCOUNT_ID --gas=300000000000000 render_art '{}'
```

Если все работает как надо, то вы увидете ваш рисунок в логах, например:
```
Scheduling a call: test-12331.testnet.render_art({})
Receipts: B3odJ16wnajwsrUbw2PVZyY2QDCbwFJsTAXvsWTaGGZV, 7FMyKSgszNgGhCBYv7Sg7jVS2b2LzTJ4w8e9T1fTEDWV
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: .................XXXXXXX..........................
	Log [test-12331.testnet]: ..............XXX.......XXX.......................
	Log [test-12331.testnet]: ............XX.............XX.....................
	Log [test-12331.testnet]: ...........X.................X....................
	Log [test-12331.testnet]: ..........X...................X...................
	Log [test-12331.testnet]: .........X.......XXXXXXX.......X..................
	Log [test-12331.testnet]: ........X......XXX.....XXX......X.................
	Log [test-12331.testnet]: .......X......X...........X......X................
	Log [test-12331.testnet]: .......X.....X.............X.....X................
	Log [test-12331.testnet]: ......X.....X...............X.....X...............
	Log [test-12331.testnet]: ......X....X......XXXXX......X....X...............
	Log [test-12331.testnet]: ......X....X.....XX...XX.....X....X...............
	Log [test-12331.testnet]: .....X....XX....X.......X....XX....X..............
	Log [test-12331.testnet]: .....X....X....XX.......XX....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....XX.......XX....X....X..............
	Log [test-12331.testnet]: .....X....XX....X.......X....XX....X..............
	Log [test-12331.testnet]: ......X....X.....XX...XX.....X....X...............
	Log [test-12331.testnet]: ......X....X......XXXXX......X....X...............
	Log [test-12331.testnet]: ......X.....X...............X.....X...............
	Log [test-12331.testnet]: .......X.....X.............X.....X................
	Log [test-12331.testnet]: .......X......X...........X......X................
	Log [test-12331.testnet]: ........X......XXX.....XXX......X.................
	Log [test-12331.testnet]: .........X.......XXXXXXX.......X..................
	Log [test-12331.testnet]: ..........X...................X...................
	Log [test-12331.testnet]: ...........X.................X....................
	Log [test-12331.testnet]: ............XX.............XX.....................
	Log [test-12331.testnet]: ..............XXX.......XXX.......................
	Log [test-12331.testnet]: .................XXXXXXX..........................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
Transaction Id ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3
''
```

Можно также посмотреть этот рисунок в block explorer, например [Мишень](https://explorer.testnet.near.org/transactions/ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3)

Чтобы легче вызвать методы я добавил вспомогательный скрипт `./call.sh`.
```bash
./call.sh <МЕТОД> <ПАРАМЕТРЫ>
```

Например, команда, чтобы нарисовать красный прямоугольник:
```bash
./call.sh render_rect '{"left": 10, "top": 20, "width": 10, "height": 5, "color": 16711680}'
```

Или команда, чтобы нарисовать ваш рисунок
```bash
./call.sh render_art '{}'
```

## Часть 4 - Тестируем в продакшене

Если вы увидели ваш рисунок в block explorer, то вы уже оставили свой отпечаток в истории сети NEAR Protocol testnet.
Эти логи теперь сохранены в блокчейне навсегда.

Следующий шаг - нарисовать его в настоящем приложении.

### Скомпилируем в продакшен

На самом деле, сейчас ваш смарт-контракт не вызвает методы в смарт-контракте berry club.
Чтобы это исправить, нужно перекомпилировать его со специальной compilation feature `for_real`:
```bash
./build_for_real.sh
```

Теперь обновите смарт-контракт на вашем аккаунте:
```bash
./deploy.sh
```

Поехали!

### Купите немного 🥑

Первое, что нужно сделать - это прикупить немного авокадо. Авакадо нужно, чтобы рисовать в контракте berry club.
Вызовите вспомогательный метод `buy_avocado` на вашем смарт-контракте:
```bash
./call.sh buy_avocado '{}'
```

Вы должны увидеть следующее:
```
	Log [test-12331.testnet]: Purchased 15001.500 Avocado tokens for 50.000 NEAR
```

`50 NEAR` достаточно чтобы купить `15000` 🥑 и этого хватит чтобы нарисовать `15000` точек.

### Откройте Berry Club на Testnet

[test.berryclub.io](https://test.berryclub.io)

Вы должны увидеть холст 50x50. Он может быть немного "грязный", потому что на нем рисуют все юзеры (одновременно и по очереди).

Оставьте открытой эту вкладку в браузере.

### Нарисуйте ваш рисунок

```bash
./call.sh render_art '{}'
```

Вы должны увидеть его на холсте в браузере, а так же в логах в терминале.
А также ваш аккаунт должен появиться в списке справа от холста.
Если вы наведете курсор на своq аккаунт в списке, то это должно подсветить и ваш рисунок, и ваши точки.

### Конец или нет?

Теперь можете попробовать нарисовать другие примитивы использую `./call.sh`

Или можете изменить ваш рисунок в коде и попробовать нарисовать его заного. 

ВАЖНО! Помните, если вы изменили код, то его нужно перекомпилировать и добавить заново на аккаунт.

Удачи!

'''
'''--- README_Windows.md ---
# Berry Club Bot Workshop

This is a workshop to cover basics of NEAR Protocol smart-contracts written in Rust.

## Preparation

**Note**: after installing each of these steps, you may need to close the Command Prompt and reopen it for changes to take effect.

### Install required tools

NOTE: This process is Windows. For other OSes please see `README.md`.

#### Install [Rust and rustup](https://forge.rust-lang.org/infra/other-installation-methods.html#other-ways-to-install-rustup):

#### Add wasm target to your toolchain:

```bash
rustup target add wasm32-unknown-unknown
```

You will also need a [Windows-specific download](https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16), then open it and install the C++ packages:

![Choose C++](./assets/vsbuild.png)

#### Install `near-cli`

Note: you'll need [to install NodeJS](https://nodejs.org/en/download).

See [`near-cli` installation docs](https://docs.near.org/docs/development/near-cli#installation)

#### Install `git`

See [installation guide](https://github.com/git-guides/install-git#install-git-on-windows) from GitHub.

### Prepare workshop repo and verify tools installation

#### Clone the workshop repository

```bash
git clone https://github.com/evgenykuzyakov/workshop
cd workshop
```

It should clone the repository to a local folder `workshop`.

#### Compile the contract

```bash
win\build.bat
```

If you have successfully installed Rust and `wasm32` target, then the `cargo build…` command should compile the contract into `res/berry_bot.wasm`.
```
   Compiling autocfg v1.0.0
   Compiling proc-macro2 v1.0.9
   Compiling unicode-xid v0.2.0
   ...
   Compiling near-vm-logic v2.0.0
   Compiling near-sdk v2.0.0
   Compiling berry-bot v0.1.0 (workshop)
    Finished release [optimized] target(s) in 43.13s
```

#### You can check that the contract is present in `res/berry_bot.wasm`

```bash
dir res
```

I hope you see:

```shell
…
05/02/2021  01:55 PM           148,112 berry_bot.wasm
…
```

### Setup NEAR account

#### Register a new account on testnet.

You can create a new account using [NEAR Testnet Wallet](https://wallet.testnet.near.org/)
It'll create a new account for you on the NEAR Testnet. The full account ID will be something like `alice.testnet`

As a `Security Method` for this workshop I'd recommend to use either `Recovery Phrase` or `Email Recovery`.

#### Authorize your account with `near-cli`

To allow using your account with `near-cli` you need to login from the terminal.
```bash
near login
```

This should open a new browser tab in the NEAR Testnet web-wallet and ask you give `full access` to your account.
It's fine to do, since we're talking about Testnet account.
You'll need access from command line and `near-cli` for this workshop.

Once you authorized it in the browser, the command line should automatically succeed.

You should see something like this in the console:
```
Logged in as [ alice.testnet ] with public key [ ed25519:HP3oxy... ] successfully
```

#### Store your account ID into local variable

To help with this workshop let's store your account ID into `ACCOUNT_ID` variable in bash.
Replace `<YOUR_ACCOUNT_ID>` with your actual account ID that you created in the wallet, e.g. `alice.testnet`.

```bash
set ACCOUNT_ID=<YOUR_ACCOUNT_ID>
```

#### Verification

Let's verify that you've successfully created the account and added it to `near-cli`.

Run the following:
```bash
near call --accountId=%ACCOUNT_ID% workshop.testnet hello
```

If it succeeded then you've successfully completed your account setup. You should see something like this:
```
Scheduling a call: workshop.testnet.hello()
Receipt: 5rKUqv4t9JVQryvyfrgrFr8R48iV4sFX7nD56KUv6Vhb
	Log [workshop.testnet]: Hello, test-12331.testnet!
Transaction Id 8D2L4AdhbZ3CqWXMpRURsyqUTNJaBJDcFQsN4W8vU4y7
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/8D2L4AdhbZ3CqWXMpRURsyqUTNJaBJDcFQsN4W8vU4y7
'Hello, test-12331.testnet!'
```

**Congrats!**

## Part 1 - Fix my code

Guess what, I made a bunch of errors in the implementation and you need to fix them.
Good thing, that I've added unit tests before I broke the code.

Run unit tests
```bash
win\test.bat
```

You'll see a failed test. E.g.
```
running 1 test
test rect::tests::test_rect_complex ... FAILED

failures:

---- rect::tests::test_rect_complex stdout ----

00 ..................................................
01 ..................................................
02 ..................................................
03 .....XXXX.........................................
04 .....XXXX.........................................
05 .....XXXX.........................................
06 .....XXXX.........................................
07 ..................................................
08 ..................................................
09 ..................................................
10 ..................................................
11 ..................................................
12 ..................................................
13 ..................................................
14 ..................................................
15 ..................................................
16 ..................................................
17 ..................................................
18 ..................................................
19 ..................................................
20 ..................................................
21 ..................................................
22 ..................................................
23 ..................................................
24 ..................................................
25 ..................................................
26 ..................................................
27 ..................................................
28 ..................................................
29 ..................................................
30 ..................................................
31 ..................................................
32 ..................................................
33 ..................................................
34 ..................................................
35 ..................................................
36 ..................................................
37 ..................................................
38 ..................................................
39 ..................................................
40 ..................................................
41 ..................................................
42 ..................................................
43 ..................................................
44 ..................................................
45 ..................................................
46 ..................................................
47 ..................................................
48 ..................................................
49 ..................................................
thread 'rect::tests::test_rect_complex' panicked at 'assertion failed: `(left == right)`
  left: `".....XXXX......"`,
 right: `"..............."`: Line 3', src/rect.rs:90:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

It means the test `test_rect_complex` has failed and the assert at file `src/rect.rs` line `90` failed.
Open the file and try to figure out what went wrong. Once you figured out what is wrong, try rerunning tests.

Repeat the process of fixing the implementation (not tests) to resolve all bugs.

Once all unit tests are fixed, you're ready to move to the part 2.

## Part 2 - Let's draw

In this part you'll need to implement a new method that will draw something complex.
To do this, you can use rectangle and circle primitives and later merge them into one image.

Run
```bash
win\draw_art.bat
```

You should see a preview of the art. Right now it renders a target with three circles.

```
00 ..................................................
01 ..................................................
02 ..................................................
03 ..................................................
04 ..................................................
05 .................XXXXXXX..........................
06 ..............XXX.......XXX.......................
07 ............XX.............XX.....................
08 ...........X.................X....................
09 ..........X...................X...................
10 .........X.......XXXXXXX.......X..................
11 ........X......XXX.....XXX......X.................
12 .......X......X...........X......X................
13 .......X.....X.............X.....X................
14 ......X.....X...............X.....X...............
15 ......X....X......XXXXX......X....X...............
16 ......X....X.....XX...XX.....X....X...............
17 .....X....XX....X.......X....XX....X..............
18 .....X....X....XX.......XX....X....X..............
19 .....X....X....X.........X....X....X..............
20 .....X....X....X.........X....X....X..............
21 .....X....X....X.........X....X....X..............
22 .....X....X....XX.......XX....X....X..............
23 .....X....XX....X.......X....XX....X..............
24 ......X....X.....XX...XX.....X....X...............
25 ......X....X......XXXXX......X....X...............
26 ......X.....X...............X.....X...............
27 .......X.....X.............X.....X................
28 .......X......X...........X......X................
29 ........X......XXX.....XXX......X.................
30 .........X.......XXXXXXX.......X..................
31 ..........X...................X...................
32 ...........X.................X....................
33 ............XX.............XX.....................
34 ..............XXX.......XXX.......................
35 .................XXXXXXX..........................
36 ..................................................
37 ..................................................
38 ..................................................
39 ..................................................
40 ..................................................
41 ..................................................
42 ..................................................
43 ..................................................
44 ..................................................
45 ..................................................
46 ..................................................
47 ..................................................
48 ..................................................
49 ..................................................
test art::tests::draw_art ... ok
```

Now, open file `src/art.rs` and modify the implementation of method `internal_render_art` at line `26`.

You can draw whatever you want and debug it by running `win\draw_art.bat`.
But note, that too many pixels might lead to performance issues.

Once you are satisfied with your art preview, it's time to try it for real.

## Part 3 - Deploy to testnet

### Recompile the contract

You've modified the code to fix tests and implemented your art, so we need to rebuild.
```bash
win\build.bat
```

Every time you modify code of your contract you may want to recompile the contract.
The resulting binary is be located at `res/berry_bot.wasm`

### Deploying the contract

Accounts in NEAR Protocol can also contain one contract. The contract has full access to the account it belongs.
But a new transaction can only be initiated by signing this transaction with an access key (this stops Skynet and singularity).
A transaction may call a method on the contract by name and pass arguments.

To deploy a contract, we need to issue a transaction.
I wrote a convenient script to deploy the contract to your account stored in `%ACCOUNT_ID%`.
(All it does is `near deploy %ACCOUNT_ID% res\berry_bot.wasm`)
```bash
win\deploy.bat
```

You should see something like this:

```
Starting deployment. Account id: test-12331.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: res/berry_bot.wasm
Transaction Id 7jxk9ANig8wJ1BqFennJN4pSuVaMn9n3HjaeKfDYfsDY
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/7jxk9ANig8wJ1BqFennJN4pSuVaMn9n3HjaeKfDYfsDY
Done deploying to test-12331.testnet
```

NOTE: You can re-deploy your contract multiple times, so long as you have access key on the account.
Every time you've modified the code and want to change the contract on-chain you need to recompile and redeploy.

### Call the contract

To call `<METHOD_NAME>` on your contract with arguments `<ARGS>` issue the following command:
```bash
near call %ACCOUNT_ID% --accountId=%ACCOUNT_ID% --gas=300000000000000 <METHOD_NAME> <ARGS>
```

* `<METHOD_NAME>` is a public method name that you want to call from the contract
* `<ARGS>` are JSON encoded arguments to the method, e.g. `"{\"left\": 10, \"top\": 20, \"width\": 10, \"height\": 5, \"color\": 16711680}"`

For example to draw you art, you need to call the following:
```bash
near call %ACCOUNT_ID% --accountId=%ACCOUNT_ID% --gas=300000000000000 render_art "{}"
```

If everything works well, then you should see your art rendered in logs, e.g.:
```
Scheduling a call: test-12331.testnet.render_art({})
Receipts: B3odJ16wnajwsrUbw2PVZyY2QDCbwFJsTAXvsWTaGGZV, 7FMyKSgszNgGhCBYv7Sg7jVS2b2LzTJ4w8e9T1fTEDWV
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: .................XXXXXXX..........................
	Log [test-12331.testnet]: ..............XXX.......XXX.......................
	Log [test-12331.testnet]: ............XX.............XX.....................
	Log [test-12331.testnet]: ...........X.................X....................
	Log [test-12331.testnet]: ..........X...................X...................
	Log [test-12331.testnet]: .........X.......XXXXXXX.......X..................
	Log [test-12331.testnet]: ........X......XXX.....XXX......X.................
	Log [test-12331.testnet]: .......X......X...........X......X................
	Log [test-12331.testnet]: .......X.....X.............X.....X................
	Log [test-12331.testnet]: ......X.....X...............X.....X...............
	Log [test-12331.testnet]: ......X....X......XXXXX......X....X...............
	Log [test-12331.testnet]: ......X....X.....XX...XX.....X....X...............
	Log [test-12331.testnet]: .....X....XX....X.......X....XX....X..............
	Log [test-12331.testnet]: .....X....X....XX.......XX....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....X.........X....X....X..............
	Log [test-12331.testnet]: .....X....X....XX.......XX....X....X..............
	Log [test-12331.testnet]: .....X....XX....X.......X....XX....X..............
	Log [test-12331.testnet]: ......X....X.....XX...XX.....X....X...............
	Log [test-12331.testnet]: ......X....X......XXXXX......X....X...............
	Log [test-12331.testnet]: ......X.....X...............X.....X...............
	Log [test-12331.testnet]: .......X.....X.............X.....X................
	Log [test-12331.testnet]: .......X......X...........X......X................
	Log [test-12331.testnet]: ........X......XXX.....XXX......X.................
	Log [test-12331.testnet]: .........X.......XXXXXXX.......X..................
	Log [test-12331.testnet]: ..........X...................X...................
	Log [test-12331.testnet]: ...........X.................X....................
	Log [test-12331.testnet]: ............XX.............XX.....................
	Log [test-12331.testnet]: ..............XXX.......XXX.......................
	Log [test-12331.testnet]: .................XXXXXXX..........................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
	Log [test-12331.testnet]: ..................................................
Transaction Id ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3
''
```

You can also click the explorer link to see this on chain, e.g [Target](https://explorer.testnet.near.org/transactions/ZWv4Ac2Qqvs8cA1CT1AHE6ovNXUGT7SCuLiDQFmSqv3)

There is a helper script that let you call methods on your contract easier `win\call.bat`.
```bash
win\call.bat <METHOD_NAME> <ARGS>
```

An example of a command to render a red rectangle
```bash
win\call.bat render_rect "{\"left\": 10, \"top\": 20, \"width\": 10, \"height\": 5, \"color\": 16711680}"
```

Or to render your art
```bash
win\call.bat render_art "{}"
```

## Part 4 - Test in Prod

If you were able to see your art in the explorer, you've already made the history on Testnet. It's now persistent on chain.
The next step is to use it with the real app.

### Build for real

Your current contract doesn't actually issue cross-contract calls to berry club, so you need to re-compile it with a compilation feature.
```bash
win\build_for_real.bat
```

Now redeploy your contract
```bash
win\deploy.bat
```

Game on.

### Buy some 🥑

The first thing we'll need is to buy some avocados to draw in the berry club.
Your contract has a helper method `buy_avocado` to do this.
```bash
win\call.bat buy_avocado "{}"
```

You should see a log message like this:
```
	Log [test-12331.testnet]: Purchased 15001.500 Avocado tokens for 50.000 NEAR
```

`50 NEAR` is enough to get you `15000` 🥑 and this is enough to draw `15000` pixels.

### Open Berry Club on the Testnet

[test.berryclub.io](https://test.berryclub.io)

You should see a board. It might be messy, because everyone shares the same board.
You can login with your testnet account using web-wallet. This will display your name and your avocado balance.

Keep this tab open.

### Let's render your art

```bash
win\call.bat render_art "{}"
```

You should see it rendered on the board in the browser.
You should also see your account ID in the list on the right.
If you hover over your account ID in the list, it will highlight your pixels.

### Iterate

Now try drawing other primitives by using `win\call.bat`

Remember, if you modify the code, then you need to recompile and redeploy the contract.

Enjoy!

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/berry_bot.wasm ./res/

'''
'''--- build_for_real.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release --features for_real
cp target/wasm32-unknown-unknown/release/berry_bot.wasm ./res/

'''
'''--- call.sh ---
#!/bin/bash
set -e

near call $ACCOUNT_ID --accountId=$ACCOUNT_ID --gas=300000000000000 "$@"

'''
'''--- deploy.sh ---
#!/bin/bash
set -e

near deploy $ACCOUNT_ID res/berry_bot.wasm

'''
'''--- draw_art.sh ---
#!/bin/bash
set -e

cargo test art::tests::draw_art -- --exact --nocapture

'''
'''--- src/art.rs ---
use crate::*;
#[allow(unused_imports)]
use circle::internal_render_circle;
#[allow(unused_imports)]
use rect::internal_render_rect;

#[near_bindgen]
impl Contract {
    /// Renders your art.
    /// To call this method you need to call `render_art`, e.g. `render_art '{}'`
    pub fn render_art(&mut self) -> Promise {
        let pixels = internal_render_art();
        // Issue a cross-contract call to the Berry Club contract to draw pixels and return the
        // promise from this method.
        draw(pixels)
    }
}

pub(crate) fn internal_render_art() -> Vec<SetPixelRequest> {
    // Creates an empty vector
    let mut pixels = vec![];

    // TODO: Implement your art by modifying code below.
    // You can also draw using implementations of rect and circle as examples.
    // E.g. the following will render 3 circles:
    pixels.extend(internal_render_circle(20, 20, 15, 0xff0000));
    pixels.extend(internal_render_circle(20, 20, 10, 0xffff00));
    pixels.extend(internal_render_circle(20, 20, 5, 0x00ff00));

    pixels
}

#[cfg(not(target = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn draw_art() {
        let pixels = internal_render_art();
        debug_print_pixels(&pixels);
    }
}

'''
'''--- src/circle.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// Renders a circle with a line.
    /// To call this method you need to call `render_circle`, e.g.
    /// `./call.sh render_circle '{"center_x": 10, "center_y": 20, "radius": 5, "color": 255}'`
    pub fn render_circle(
        &mut self,
        center_x: i32,
        center_y: i32,
        radius: u32,
        color: u32,
    ) -> Promise {
        let pixels = internal_render_circle(center_x, center_y, radius, color);
        // Issue a cross-contract call to the Berry Club contract to draw pixels and return the
        // promise from this method.
        draw(pixels)
    }
}

pub(crate) fn internal_render_circle(
    center_x: i32,
    center_y: i32,
    radius: u32,
    color: u32,
) -> Vec<SetPixelRequest> {
    // Optionally check the validity of the input.
    assert!(color <= 0xffffff, "color is out of bounds [0..0xffffff]");

    // Creates an empty vector
    let mut pixels = vec![];

    let r2 = (radius * radius) as i32;
    let max_delta = radius as i32;

    // Iterate over pixels of the rectangle.
    for i in std::cmp::max(0, center_y - radius as i32)
        ..=std::cmp::min(BOARD_HEIGHT as i32 - 1, center_y + radius as i32)
    {
        for j in std::cmp::max(0, center_x - radius as i32)
            ..=std::cmp::min(BOARD_WIDTH as i32 - 1, center_x + radius as i32)
        {
            let dx = i - center_x;
            let dy = j - center_x;
            let d2 = dx * dx + dy * dy;
            if d2 >= r2 - max_delta && d2 <= r2 + max_delta {
                pixels.push(SetPixelRequest {
                    x: j as u32,
                    y: i as u32,
                    color,
                });
            }
        }
    }

    pixels
}

#[cfg(not(target = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_circle_small() {
        let pixels = internal_render_circle(4, 5, 3, 0xffffff);
        let board = debug_print_pixels(&pixels);
        assert_eq!(&board[0][..15], "...............");
        assert_eq!(&board[1][..15], "...............");
        assert_eq!(&board[2][..15], "...XXX.........");
        assert_eq!(&board[3][..15], "..X...X........");
        assert_eq!(&board[4][..15], ".X.....X.......");
        assert_eq!(&board[5][..15], ".X.....X.......");
        assert_eq!(&board[6][..15], ".X.....X.......");
        assert_eq!(&board[7][..15], "..X...X........");
        assert_eq!(&board[8][..15], "...XXX.........");
        assert_eq!(&board[9][..15], "...............");
    }
}

'''
'''--- src/hardcore.rs ---
//! As part of the workshop you don't need to touch this contract.
//! It has some hardcode stuff that is needed for you to have fun.
//! But I'm glad you're looking for more.

use crate::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, ext_contract, Balance, Gas};

pub type AccountIndex = u32;

pub const BERRYCLUB_CONTRACT_ID: &str = "berryclub.ncd.testnet";

pub const NO_DEPOSIT: Balance = 0;

pub const BUY_TOKENS_GAS: Gas = 5_000_000_000_000;
pub const GET_LINES_GAS: Gas = 50_000_000_000_000;
pub const BASE_DRAW_GAS: Gas = 50_000_000_000_000;
pub const GAS_FOR_RENDER_WITH: Gas = GET_LINES_GAS + 20_000_000_000_000;
pub const GAS_PER_PIXEL: Gas = 50_000_000_000;

#[derive(BorshDeserialize, BorshSerialize, Copy, Clone)]
pub struct Pixel {
    pub color: u32,
    pub owner_id: AccountIndex,
}

impl Default for Pixel {
    fn default() -> Self {
        Self {
            color: 0xffffff,
            owner_id: 0,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct PixelLine(pub Vec<Pixel>);

impl Default for PixelLine {
    fn default() -> Self {
        Self(vec![Pixel::default(); BOARD_WIDTH as usize])
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SetPixelRequest {
    pub x: u32,
    pub y: u32,
    pub color: u32,
}

impl SetPixelRequest {
    pub fn is_valid(&self) -> bool {
        return self.x < BOARD_WIDTH && self.y < BOARD_HEIGHT && self.color <= 0xffffff;
    }

    pub fn assert_valid(&self) {
        assert!(self.x < BOARD_WIDTH, "X is out of bounds");
        assert!(self.y < BOARD_HEIGHT, "Y is out of bounds");
        assert!(self.color <= 0xffffff, "Color is out of bounds");
    }
}

#[ext_contract(ext_berryclub)]
trait BerryclubContract {
    fn get_lines(&self, lines: Vec<u32>) -> Vec<Base64VecU8>;

    fn buy_tokens(&mut self);

    fn draw(&mut self, pixels: Vec<SetPixelRequest>);
}

pub(crate) fn draw(pixels: Vec<SetPixelRequest>) -> Promise {
    let mut board = [[b'.'; BOARD_WIDTH as usize]; BOARD_HEIGHT as usize];
    let mut unique_pixels = vec![];
    for pixel in pixels.into_iter().rev() {
        if board[pixel.y as usize][pixel.x as usize] == b'.' {
            board[pixel.y as usize][pixel.x as usize] = b'X';
            unique_pixels.push(pixel);
        }
    }
    for line in &board {
        env::log(line);
    }

    #[cfg(feature = "for_real")]
    {
        let gas = BASE_DRAW_GAS + (unique_pixels.len() as u64) * GAS_PER_PIXEL;
        ext_berryclub::draw(
            unique_pixels,
            &BERRYCLUB_CONTRACT_ID.to_string(),
            NO_DEPOSIT,
            gas,
        )
    }
    #[cfg(not(feature = "for_real"))]
    {
        Promise::new(env::current_account_id())
    }
}

pub(crate) fn decode_board(lines: Vec<Base64VecU8>) -> Vec<Vec<u32>> {
    lines
        .into_iter()
        .map(|bytes| {
            PixelLine::try_from_slice(&bytes.0)
                .unwrap()
                .0
                .into_iter()
                .map(|p| p.color)
                .collect()
        })
        .collect()
}

#[near_bindgen]
impl Contract {
    #[cfg(feature = "for_real")]
    pub fn buy_avocado(&mut self) -> Promise {
        ext_berryclub::buy_tokens(
            &BERRYCLUB_CONTRACT_ID.to_string(),
            50 * 10u128.pow(24),
            BUY_TOKENS_GAS,
        )
    }

    pub fn render(method_name: String) -> Promise {
        ext_berryclub::get_lines(
            (0..BOARD_HEIGHT).collect(),
            &BERRYCLUB_CONTRACT_ID.to_string(),
            NO_DEPOSIT,
            GET_LINES_GAS,
        )
        .then(Promise::new(env::current_account_id()).function_call(
            method_name.into_bytes(),
            env::input().unwrap(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_RENDER_WITH,
        ))
    }
}

#[cfg(not(target = "wasm32"))]
#[cfg(test)]
pub(crate) fn debug_print_pixels(pixels: &[SetPixelRequest]) -> Vec<String> {
    let mut board = vec![vec![b'.'; BOARD_WIDTH as usize]; BOARD_HEIGHT as usize];
    for pixel in pixels {
        board[pixel.y as usize][pixel.x as usize] = b'X';
    }
    let board = board
        .into_iter()
        .map(|line| String::from_utf8(line.to_vec()).unwrap())
        .collect::<Vec<_>>();
    println!();
    for (i, line) in board.iter().enumerate() {
        println!("{:02} {}", i, line);
    }
    board
}

'''
'''--- src/invert.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// This method requires the current board colors to compute then inverse colors.
    /// To call this method you need to call `render` and pass `method_name`, e.g.
    /// `./call.sh render '{"method_name": "invert_rect", "left": 20, "top": 10, "width": 20, "height": 20}'`
    /// This is because you first need to get the lines from the berryclub contract.
    ///
    /// `[callback] lines: Vec<Base64VecU8>` is required to get the current state of the board.
    /// See `berryclub::render` for implementation details.
    pub fn invert_rect(
        &mut self,
        #[callback] lines: Vec<Base64VecU8>,
        left: u32,
        top: u32,
        width: u32,
        height: u32,
    ) -> Promise {
        // Parse current board from BerryClub
        let board = decode_board(lines);

        let pixels = internal_invert_rect(board, left, top, width, height);

        // Issue a cross-contract call to the Berry Club contract to draw pixels and return the
        // promise from this method.
        draw(pixels)
    }
}

pub fn internal_invert_rect(
    board: Vec<Vec<u32>>,
    left: u32,
    top: u32,
    width: u32,
    height: u32,
) -> Vec<SetPixelRequest> {
    // Optionally check the validity of the input.
    assert!(left < BOARD_WIDTH, "left is out of bounds [0..49]");
    assert!(top < BOARD_HEIGHT, "top is out of bounds [0..49]");
    assert!(
        width > 0 && width <= BOARD_WIDTH,
        "width is out of bounds [1..50]"
    );
    assert!(
        height > 0 && height <= BOARD_HEIGHT,
        "height is out of bounds [1..50]"
    );
    assert!(
        left + width <= BOARD_WIDTH,
        "left + top is out of bounds [0..49]"
    );
    assert!(
        top + height <= BOARD_WIDTH,
        "left + top is out of bounds [0..49]"
    );

    // Creates an empty vector
    let mut pixels = vec![];

    // Iterate over pixels of the rectangle.
    for i in top..top + height {
        let line = &board[i as usize];
        for j in left..left + width {
            let color = line[j as usize];
            let new_color = 0xfffffff - color;

            let pixel = SetPixelRequest {
                x: j,
                y: i,
                color: new_color,
            };
            pixels.push(pixel);
        }
    }

    pixels
}

#[cfg(not(target = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_invert_rect() {
        // Red map
        let input_board = vec![vec![0xff0000u32; BOARD_WIDTH as usize]; BOARD_WIDTH as usize];
        let pixels = internal_invert_rect(input_board, 4, 2, 3, 4);
        let board = debug_print_pixels(&pixels);
        assert_eq!(&board[0][..15], "...............");
        assert_eq!(&board[1][..15], "...............");
        assert_eq!(&board[2][..15], "....XXX........");
        assert_eq!(&board[3][..15], "....XXX........");
        assert_eq!(&board[4][..15], "....XXX........");
        assert_eq!(&board[5][..15], "....XXX........");
        assert_eq!(&board[6][..15], "...............");
        assert_eq!(pixels.len(), 12);
        assert!(
            pixels.iter().all(|p| p.color == 0x00ffff),
            "Colors are invalid"
        );
    }
}

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, Promise};

pub const BOARD_WIDTH: u32 = 50;
pub const BOARD_HEIGHT: u32 = 50;
pub const TOTAL_NUM_PIXELS: u32 = BOARD_WIDTH * BOARD_HEIGHT;

mod art;
mod circle;
mod hardcore;
mod invert;
mod rect;

pub use crate::hardcore::*;
use near_sdk::json_types::Base64VecU8;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc<'_> = near_sdk::wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {}

'''
'''--- src/rect.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// Renders a solid color filled rectangle.
    /// To call this method you need to call `render_rect`, e.g.
    /// `./call.sh render_rect '{"left": 10, "top": 20, "width": 10, "height": 5, "color": 16711680}'`
    pub fn render_rect(
        &mut self,
        left: u32,
        top: u32,
        width: u32,
        height: u32,
        color: u32,
    ) -> Promise {
        let pixels = internal_render_rect(left, top, width, height, color);
        // Issue a cross-contract call to the Berry Club contract to draw pixels and return the
        // promise from this method.
        draw(pixels)
    }
}

pub(crate) fn internal_render_rect(
    left: u32,
    top: u32,
    width: u32,
    height: u32,
    color: u32,
) -> Vec<SetPixelRequest> {
    // Optionally check the validity of the input.
    assert!(left < BOARD_WIDTH, "left is out of bounds [0..49]");
    assert!(top < BOARD_HEIGHT, "top is out of bounds [0..49]");
    assert!(color <= 0xffffff, "color is out of bounds [0..0xffffff]");
    assert!(
        width > 0 && width <= BOARD_WIDTH,
        "width is out of bounds [1..50]"
    );
    assert!(
        height > 0 && height <= BOARD_HEIGHT,
        "height is out of bounds [1..50]"
    );
    assert!(
        left + width <= BOARD_WIDTH,
        "left + top is out of bounds [0..49]"
    );
    assert!(
        top + height <= BOARD_HEIGHT,
        "top + height is out of bounds [0..49]"
    );

    // Creates an empty vector
    let mut pixels = vec![];

    // Iterate over pixels of the rectangle.
    for i in top..top + width {
        for j in left..left + height {
            let pixel = SetPixelRequest { x: i, y: j, color };
            // Verify that the pixel request is valid.
            // NOTE: That this check is not necessary, because we've verified the input above.
            pixel.assert_valid();

            pixels.push(pixel);
        }
    }

    pixels
}

#[cfg(not(target = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_rect_small() {
        let pixels = internal_render_rect(1, 1, 2, 1, 0xffffff);
        let board = debug_print_pixels(&pixels);
        assert_eq!(&board[0][..15], "...............", "Line 0");
        assert_eq!(&board[1][..15], ".XX............", "Line 1");
        assert_eq!(&board[2][..15], "...............", "Line 2");
    }

    #[test]
    pub fn test_rect_complex() {
        let pixels = internal_render_rect(3, 5, 4, 4, 0xffffff);
        let board = debug_print_pixels(&pixels);
        assert_eq!(&board[0][..15], "...............", "Line 0");
        assert_eq!(&board[1][..15], "...............", "Line 1");
        assert_eq!(&board[2][..15], "...............", "Line 2");
        assert_eq!(&board[3][..15], "...............", "Line 3");
        assert_eq!(&board[4][..15], "...............", "Line 4");
        assert_eq!(&board[5][..15], "...XXXX........", "Line 5");
        assert_eq!(&board[6][..15], "...XXXX........", "Line 6");
        assert_eq!(&board[7][..15], "...XXXX........", "Line 7");
        assert_eq!(&board[8][..15], "...XXXX........", "Line 8");
        assert_eq!(&board[9][..15], "...............", "Line 9");
        assert_eq!(pixels.len(), 4 * 4);
    }
}

'''
'''--- test.sh ---
#!/bin/bash
set -e

cargo test rect::tests::test_rect_small -- --exact
cargo test rect::tests::test_rect_complex -- --exact

cargo test circle::tests::test_circle_small -- --exact

cargo test invert::tests::test_invert_rect -- --exact

'''
'''--- win/build.bat ---
cargo build --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\berry_bot.wasm res
'''
'''--- win/build_for_real.bat ---
cargo build --target wasm32-unknown-unknown --release --features for_real
copy target\wasm32-unknown-unknown\release\berry_bot.wasm res
'''
'''--- win/call.bat ---
near call %ACCOUNT_ID% --accountId=%ACCOUNT_ID% --gas=300000000000000 %*
'''
'''--- win/deploy.bat ---
near deploy %ACCOUNT_ID% res\berry_bot.wasm
'''
'''--- win/draw_art.bat ---
cargo test art::tests::draw_art -- --exact --nocapture
'''
'''--- win/test.bat ---
cargo test rect::tests::test_rect_small -- --exact
cargo test rect::tests::test_rect_complex -- --exact
cargo test circle::tests::test_circle_small -- --exact
cargo test invert::tests::test_invert_rect -- --exact
'''