*GitHub Repository "InfinityHackathon/hatathon-2021-team-90"*

'''--- .cargo/audit.toml ---
[advisories]
# warn for categories of informational advisories
informational_warnings = [
    "unmaintained",
    "unsound",
]

[target]
arch = "wasm32"

'''
'''--- .cargo/config.toml ---
[net]
git-fetch-with-cli = true
[build]
rustflags = ["-C", "link-args=-s"]

'''
'''--- .github/workflows/contract.yml ---
name: contract

on:
  push:
    paths:
      - '.cargo/**'
      - 'src/contract/**'
      - 'Cargo.lock'
      - 'Cargo.toml'
    branches:
      - main
  pull_request:
    paths:
      - '.cargo/**'
      - 'src/contract/**'
      - 'Cargo.lock'
      - 'Cargo.toml'
    branches:
      - main

jobs:

  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/audit-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

  qa:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          target: wasm32-unknown-unknown
          toolchain: stable
          profile: minimal
          override: true
      - run: sudo apt-get install -y binaryen wabt
      - run: cargo install wasm-snip wasm-gc
      - run: yarn contract-build
      - run: yarn contract-qa

'''
'''--- Cargo.toml ---
[workspace]
members = [
  "src/contract/society",
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/3123272
overflow-checks = true

'''
'''--- README.md ---
# CryptoArt DAO

## Dev deploy
```shell
yarn contract-qa
yarn contract-build
yarn contract-dev-deploy && contractId=$(cat neardev/dev-account) && near --accountId $contractId call $contractId init
near delete foo.$(cat neardev/dev-account) $NEAR_DEV_ACCOUNT
near delete bar.$(cat neardev/dev-account) $NEAR_DEV_ACCOUNT
near delete $(cat neardev/dev-account) $NEAR_DEV_ACCOUNT && rm -fr neardev
yarn start
```

## Contract interact
```shell
npx near login
contractId=$(cat neardev/dev-account)
near state $contractId
near view $contractId balance
near view $contractId member_list
near view $contractId proposal_list
near view $contractId can_vote '{"proposal_id":0,"account_id": "dev-1626575883917-97357653463081"}'
near --masterAccount $contractId create-account "foo.$contractId" --initialBalance 10
near --accountId "foo.$contractId" call $contractId add_member_proposal '{"title":"foo", "description": "bar"}' --deposit 0.006
near --accountId $contractId call $contractId vote_approve '{"proposal_id":0}'
near --masterAccount $contractId create-account "bar.$contractId" --initialBalance 10
near --accountId "bar.$contractId" call $contractId add_member_proposal '{"title":"foo", "description": "bar"}' --deposit 0.006
near --accountId $contractId call $contractId vote_approve '{"proposal_id":1}'
near --accountId "foo.$contractId" call $contractId vote_approve '{"proposal_id":1}'
near --accountId $contractId call $contractId vote_reject '{"proposal_id":0}'
```

## Deploy
```shell
contractId=cryptoartdao.testnet
near state $contractId
# QA
yarn contract-qa
# Send found if need
near send $NEAR_DEV_ACCOUNT $contractId 1000
# Deploy contract
yarn contract-build && near deploy $contractId build/society-minified.wasm init '{}'
# or Migrate contract
yarn contract-build && near deploy $contractId build/society-minified.wasm migrate '{}'
# Deploy app
echo "export default "$contractId'" > src/contract-name.ts
yarn deploy:app
```

'''
'''--- angular.json ---
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "cryptoartdao": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "style": "sass"
        },
        "@schematics/angular:application": {
          "strict": true
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:browser",
          "options": {
            "outputPath": "dist/cryptoartdao",
            "index": "src/index.html",
            "main": "src/main.ts",
            "polyfills": "src/polyfills.ts",
            "tsConfig": "tsconfig.app.json",
            "inlineStyleLanguage": "sass",
            "assets": [
              "src/favicon.ico",
              "src/assets",
              "src/manifest.webmanifest"
            ],
            "styles": [
              "./node_modules/@angular/material/prebuilt-themes/indigo-pink.css",
              "src/styles.sass"
            ],
            "scripts": [],
            "serviceWorker": true,
            "ngswConfigPath": "ngsw-config.json"
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kb",
                  "maximumError": "1mb"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "2kb",
                  "maximumError": "4kb"
                }
              ],
              "fileReplacements": [
                {
                  "replace": "src/environments/environment.ts",
                  "with": "src/environments/environment.prod.ts"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "buildOptimizer": false,
              "optimization": false,
              "vendorChunk": true,
              "extractLicenses": false,
              "sourceMap": true,
              "namedChunks": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "browserTarget": "cryptoartdao:build:production"
            },
            "development": {
              "browserTarget": "cryptoartdao:build:development"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n",
          "options": {
            "browserTarget": "cryptoartdao:build"
          }
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "main": "src/test.ts",
            "polyfills": "src/polyfills.ts",
            "tsConfig": "tsconfig.spec.json",
            "karmaConfig": "karma.conf.js",
            "inlineStyleLanguage": "sass",
            "assets": [
              "src/favicon.ico",
              "src/assets",
              "src/manifest.webmanifest"
            ],
            "styles": [
              "./node_modules/@angular/material/prebuilt-themes/indigo-pink.css",
              "src/styles.sass"
            ],
            "scripts": []
          }
        },
        "deploy": {
          "builder": "angular-cli-ghpages:deploy",
          "options": {}
        }
      }
    }
  },
  "defaultProject": "cryptoartdao"
}
'''
'''--- karma.conf.js ---
// Karma configuration file, see link for more information
// https://karma-runner.github.io/1.0/config/configuration-file.html

module.exports = function (config) {
  config.set({
    basePath: '',
    frameworks: ['jasmine', '@angular-devkit/build-angular'],
    plugins: [
      require('karma-jasmine'),
      require('karma-chrome-launcher'),
      require('karma-jasmine-html-reporter'),
      require('karma-coverage'),
      require('@angular-devkit/build-angular/plugins/karma')
    ],
    client: {
      jasmine: {
        // you can add configuration options for Jasmine here
        // the possible options are listed at https://jasmine.github.io/api/edge/Configuration.html
        // for example, you can disable the random execution with `random: false`
        // or set a specific seed with `seed: 4321`
      },
      clearContext: false // leave Jasmine Spec Runner output visible in browser
    },
    jasmineHtmlReporter: {
      suppressAll: true // removes the duplicated traces
    },
    coverageReporter: {
      dir: require('path').join(__dirname, './coverage/cryptoartdao'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'text-summary' }
      ]
    },
    reporters: ['progress', 'kjhtml'],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ['Chrome'],
    singleRun: false,
    restartOnFileChange: true
  });
};

'''
'''--- ngsw-config.json ---
{
  "$schema": "./node_modules/@angular/service-worker/config/schema.json",
  "index": "/index.html",
  "assetGroups": [
    {
      "name": "app",
      "installMode": "prefetch",
      "resources": {
        "files": [
          "/favicon.ico",
          "/index.html",
          "/manifest.webmanifest",
          "/*.css",
          "/*.js"
        ]
      }
    },
    {
      "name": "assets",
      "installMode": "lazy",
      "updateMode": "prefetch",
      "resources": {
        "files": [
          "/assets/**",
          "/*.(eot|svg|cur|jpg|png|webp|gif|otf|ttf|woff|woff2|ani)"
        ]
      }
    }
  ]
}

'''
'''--- package.json ---
{
  "name": "cryptoartdao",
  "version": "1.0.0-beta.0",
  "license": "UNLICENSED",
  "description": "CryptoArt DAO on NEAR Protocol",
  "keywords": [
    "blockchain",
    "crypto",
    "dapps",
    "nearprotocol"
  ],
  "scripts": {
    "contract-deploy": "yarn contract-build && yarn contract-only-deploy",
    "contract-only-deploy": "node contract/deploy",
    "contract-qa": "yarn contract-fmt && yarn contract-lint && yarn contract-test",
    "contract-test": "cargo test",
    "contract-lint": "cargo fmt --all -- --check && cargo clippy --all-targets",
    "contract-fmt": "cargo fmt",
    "contract-dev-contract-name": "printf 'export default \"%s\"' $(cat neardev/dev-account) > src/contract-name.ts",
    "contract-dev-deploy": "yarn contract-build && near dev-deploy build/society-minified.wasm && yarn contract-dev-contract-name",
    "contract-build": "bash src/contract/build.sh",
    "deploy:app": "ng deploy --base-href=/",
    "ng": "ng",
    "start": "ng serve",
    "start:public": "ng serve --disable-host-check",
    "build": "ng build --base-href=/",
    "watch": "ng build --watch --configuration development",
    "test": "ng test"
  },
  "dependencies": {
    "@4ire-labs/near-sdk": "1.0.0-beta.8",
    "@angular/animations": "~12.1.2",
    "@angular/cdk": "^12.1.2",
    "@angular/common": "~12.1.2",
    "@angular/compiler": "~12.1.2",
    "@angular/core": "~12.1.2",
    "@angular/forms": "~12.1.2",
    "@angular/material": "^12.1.2",
    "@angular/platform-browser": "~12.1.2",
    "@angular/platform-browser-dynamic": "~12.1.2",
    "@angular/router": "~12.1.2",
    "@angular/service-worker": "~12.1.2",
    "near-api-js": "^0.42.0",
    "rxjs": "~6.6.0",
    "tslib": "^2.2.0",
    "zone.js": "~0.11.4"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "~12.1.2",
    "@angular/cli": "~12.1.2",
    "@angular/compiler-cli": "~12.1.2",
    "@types/jasmine": "~3.8.0",
    "@types/node": "^12.11.1",
    "angular-cli-ghpages": "1.0.0-rc.2",
    "dotenv": "^10.0.0",
    "jasmine-core": "~3.8.0",
    "karma": "~6.3.0",
    "karma-chrome-launcher": "~3.1.0",
    "karma-coverage": "~2.0.3",
    "karma-jasmine": "~4.0.0",
    "karma-jasmine-html-reporter": "~1.7.0",
    "typescript": "~4.3.2"
  }
}

'''
'''--- src/app/app-routing.module.ts ---
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

'''
'''--- src/app/app.component.html ---
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * * * The content below * * * * * * * * * * * -->
<!-- * * * * * * * * * * is only a placeholder * * * * * * * * * * -->
<!-- * * * * * * * * * * and can be replaced. * * * * * * * * * * * -->
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
<!-- * * * * * * * * * Delete the template below * * * * * * * * * * -->
<!-- * * * * * * * to get started with your project! * * * * * * * * -->
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->

<style>
  :host {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    font-size: 14px;
    color: #333;
    box-sizing: border-box;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    margin: 8px 0;
  }

  p {
    margin: 0;
  }

  .spacer {
    flex: 1;
  }

  .toolbar {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 60px;
    display: flex;
    align-items: center;
    background-color: #1976d2;
    color: white;
    font-weight: 600;
  }

  .toolbar img {
    margin: 0 16px;
  }

  .toolbar #twitter-logo {
    height: 40px;
    margin: 0 8px;
  }

  .toolbar #youtube-logo {
    height: 40px;
    margin: 0 16px;
  }

  .toolbar #twitter-logo:hover,
  .toolbar #youtube-logo:hover {
    opacity: 0.8;
  }

  .content {
    display: flex;
    margin: 82px auto 32px;
    padding: 0 16px;
    max-width: 960px;
    flex-direction: column;
    align-items: center;
  }

  svg.material-icons {
    height: 24px;
    width: auto;
  }

  svg.material-icons:not(:last-child) {
    margin-right: 8px;
  }

  .card svg.material-icons path {
    fill: #888;
  }

  .card-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 16px;
  }

  .card {
    all: unset;
    border-radius: 4px;
    border: 1px solid #eee;
    background-color: #fafafa;
    height: 40px;
    width: 200px;
    margin: 0 8px 16px;
    padding: 16px;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    transition: all 0.2s ease-in-out;
    line-height: 24px;
  }

  .card-container .card:not(:last-child) {
    margin-right: 0;
  }

  .card.card-small {
    height: 16px;
    width: 168px;
  }

  .card-container .card:not(.highlight-card) {
    cursor: pointer;
  }

  .card-container .card:not(.highlight-card):hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 17px rgba(0, 0, 0, 0.35);
  }

  .card-container .card:not(.highlight-card):hover .material-icons path {
    fill: rgb(105, 103, 103);
  }

  .card.highlight-card {
    background-color: #1976d2;
    color: white;
    font-weight: 600;
    border: none;
    width: auto;
    min-width: 30%;
    position: relative;
  }

  .card.card.highlight-card span {
    margin-left: 60px;
  }

  svg#rocket {
    width: 80px;
    position: absolute;
    left: -10px;
    top: -24px;
  }

  svg#rocket-smoke {
    height: calc(100vh - 95px);
    position: absolute;
    top: 10px;
    right: 180px;
    z-index: -10;
  }

  a,
  a:visited,
  a:hover {
    color: #1976d2;
    text-decoration: none;
  }

  a:hover {
    color: #125699;
  }

  .terminal {
    position: relative;
    width: 80%;
    border-radius: 6px;
    padding-top: 45px;
    margin-top: 8px;
    overflow: hidden;
    background-color: rgb(15, 15, 16);
  }

  .terminal::before {
    content: "\2022 \2022 \2022";
    position: absolute;
    top: 0;
    left: 0;
    height: 4px;
    background: rgb(58, 58, 58);
    color: #c2c3c4;
    width: 100%;
    font-size: 2rem;
    line-height: 0;
    padding: 14px 0;
    text-indent: 4px;
  }

  .terminal pre {
    font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
    color: white;
    padding: 0 1rem 1rem;
    margin: 0;
  }

  .circle-link {
    height: 40px;
    width: 40px;
    border-radius: 40px;
    margin: 8px;
    background-color: white;
    border: 1px solid #eeeeee;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
    transition: 1s ease-out;
  }

  .circle-link:hover {
    transform: translateY(-0.25rem);
    box-shadow: 0px 3px 15px rgba(0, 0, 0, 0.2);
  }

  footer {
    margin-top: 8px;
    display: flex;
    align-items: center;
    line-height: 20px;
  }

  footer a {
    display: flex;
    align-items: center;
  }

  .github-star-badge {
    color: #24292e;
    display: flex;
    align-items: center;
    font-size: 12px;
    padding: 3px 10px;
    border: 1px solid rgba(27, 31, 35, .2);
    border-radius: 3px;
    background-image: linear-gradient(-180deg, #fafbfc, #eff3f6 90%);
    margin-left: 4px;
    font-weight: 600;
  }

  .github-star-badge:hover {
    background-image: linear-gradient(-180deg, #f0f3f6, #e6ebf1 90%);
    border-color: rgba(27, 31, 35, .35);
    background-position: -.5em;
  }

  .github-star-badge .material-icons {
    height: 16px;
    width: 16px;
    margin-right: 4px;
  }

  svg#clouds {
    position: fixed;
    bottom: -160px;
    left: -230px;
    z-index: -10;
    width: 1920px;
  }

  /* Responsive Styles */
  @media screen and (max-width: 767px) {
    .card-container > *:not(.circle-link),
    .terminal {
      width: 100%;
    }

    .card:not(.highlight-card) {
      height: 16px;
      margin: 8px 0;
    }

    .card.highlight-card span {
      margin-left: 72px;
    }

    svg#rocket-smoke {
      right: 120px;
      transform: rotate(-5deg);
    }
  }

  @media screen and (max-width: 575px) {
    svg#rocket-smoke {
      display: none;
      visibility: hidden;
    }
  }

  .title__text {
    color: #fff !important;
  }

  .itemList {
    list-style: none;
  }

  .AddProposalForBecomeMember__input {
    width: 600px;
  }
</style>

<!-- Toolbar -->
<div class="toolbar" role="banner">
  <img
    width="40"
    alt="Angular Logo"
    src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg=="
  />
  <a class="title" href="https://explorer.testnet.near.org/accounts/{{wallet.contractName}}">
    <span class="title__text">{{titleFull()}}</span>
  </a>
  <div class="spacer"></div>
  <div fxLayout="row" fxShow="false" fxShow.gt-sm>
    <button mat-button *ngIf="!wallet.isAuthenticated()" (click)="wallet.signIn()">
      <mat-icon>power_settings_new</mat-icon>
      Sign In
    </button>
    <button mat-button *ngIf="wallet.isAuthenticated()">
      <mat-icon>verified_user</mat-icon>
      {{wallet.accountId}}
    </button>
    <button mat-button *ngIf="wallet.isAuthenticated()" (click)="wallet.signOut()">
      <mat-icon>exit_to_app</mat-icon>
      Sign Out
    </button>
  </div>
</div>

<div class="content" role="main">

  <!-- Highlight Card -->
  <div class="card highlight-card card-small">

    <svg id="rocket" xmlns="http://www.w3.org/2000/svg" width="101.678" height="101.678" viewBox="0 0 101.678 101.678">
      <g id="Group_83" data-name="Group 83" transform="translate(-141 -696)">
        <circle id="Ellipse_8" data-name="Ellipse 8" cx="50.839" cy="50.839" r="50.839" transform="translate(141 696)"
                fill="#dd0031"/>
        <g id="Group_47" data-name="Group 47" transform="translate(165.185 720.185)">
          <path id="Path_33" data-name="Path 33"
                d="M3.4,42.615a3.084,3.084,0,0,0,3.553,3.553,21.419,21.419,0,0,0,12.215-6.107L9.511,30.4A21.419,21.419,0,0,0,3.4,42.615Z"
                transform="translate(0.371 3.363)" fill="#fff"/>
          <path id="Path_34" data-name="Path 34"
                d="M53.3,3.221A3.09,3.09,0,0,0,50.081,0,48.227,48.227,0,0,0,18.322,13.437c-6-1.666-14.991-1.221-18.322,7.218A33.892,33.892,0,0,1,9.439,25.1l-.333.666a3.013,3.013,0,0,0,.555,3.553L23.985,43.641a2.9,2.9,0,0,0,3.553.555l.666-.333A33.892,33.892,0,0,1,32.647,53.3c8.55-3.664,8.884-12.326,7.218-18.322A48.227,48.227,0,0,0,53.3,3.221ZM34.424,9.772a6.439,6.439,0,1,1,9.106,9.106,6.368,6.368,0,0,1-9.106,0A6.467,6.467,0,0,1,34.424,9.772Z"
                transform="translate(0 0.005)" fill="#fff"/>
        </g>
      </g>
    </svg>
    <span>{{wallet.balance}} N</span>
    <svg id="rocket-smoke" xmlns="http://www.w3.org/2000/svg" width="516.119" height="1083.632"
         viewBox="0 0 516.119 1083.632">
      <path id="Path_40" data-name="Path 40"
            d="M644.6,141S143.02,215.537,147.049,870.207s342.774,201.755,342.774,201.755S404.659,847.213,388.815,762.2c-27.116-145.51-11.551-384.124,271.9-609.1C671.15,139.365,644.6,141,644.6,141Z"
            transform="translate(-147.025 -140.939)" fill="#f5f5f5"/>
    </svg>
  </div>

  <h2>Members</h2>
  <ul>
    <li class="itemList" *ngFor="let item of wallet.memberList">{{item}}</li>
  </ul>

  <h2>Proposal</h2>
  <button mat-raised-button color="primary"
          (click)="addProposalForBecomeMember()"
          *ngIf="!wallet.isMember && !hasAddProposalForBecomeMember()"
          [disabled]="catAddProposalForBecomeMember()">
    <mat-icon>group_add</mat-icon>
    I want to become an official member
  </button>
  <div class="AddProposalForBecomeMember" *ngIf="formProposalForBecomeMember">
    <p>
      <mat-form-field class="AddProposalForBecomeMember__input" appearance="fill">
        <mat-label>Title</mat-label>
        <input matInput placeholder="Briefly like on twitter" [(ngModel)]="proposalForBecomeMemberTitle" max="170">
      </mat-form-field>
    </p>
    <p>
      <mat-form-field class="AddProposalForBecomeMember__input" appearance="fill">
        <mat-label>Описание</mat-label>
        <textarea matInput
                  placeholder="Tell about yourself you have 1000 characters" maxlength="1000"
                  [(ngModel)]="proposalForBecomeMemberDescription"></textarea>
      </mat-form-field>
    </p>
    <button mat-raised-button
            (click)="sendProposalForBecomeMember()"
            color="primary">Send
    </button>
  </div>
  <ul>
    <li class="itemList"
        *ngFor="let item of wallet.proposalList">
      <b>{{item.proposal.status}}</b>
      {{item.proposal.title}} ({{item.proposal.author}})  {{item.proposal.description}}
     <div *ngIf="item.canVote && item.proposal.status === 'Vote'">
       <button mat-stroked-button
               (click)="wallet.voteApprove(item.proposal.id)"
               color="primary">accept
       </button>
       <button mat-stroked-button
               (click)="wallet.voteReject(item.proposal.id)"
               color="accent">reject
       </button>
     </div>

    </li>
  </ul>

  <!-- Next Steps -->
  <h2>DApp via near-cli</h2>
  <p>Direct interaction with the contract</p>

  <input type="hidden" #selection>

  <div class="card-container">
    <button class="card card-small" (click)="selection.value = 'member_list'" tabindex="0">
      <svg class="material-icons" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
      </svg>
      <span>Members</span>
    </button>

    <button class="card card-small" (click)="selection.value = 'proposal_list'" tabindex="0">
      <svg class="material-icons" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
      </svg>
      <span>Proposal</span>
    </button>

    <button class="card card-small" (click)="selection.value = 'add_member_proposal'" tabindex="0">
      <svg class="material-icons" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
      </svg>
      <span>Membership request</span>
    </button>

    <button class="card card-small" (click)="selection.value = 'vote'" tabindex="0">
      <svg class="material-icons" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
      </svg>
      <span>Vote</span>
    </button>
  </div>

  <!-- Terminal -->
  <div class="terminal" [ngSwitch]="selection.value">
    <pre *ngSwitchDefault>npx near view {{wallet.contractName}} member_list</pre>
    <pre *ngSwitchCase="'proposal_list'">npx near view {{wallet.contractName}} proposal_list</pre>
    <pre *ngSwitchCase="'add_member_proposal'">npx near login{{'\n'}}npx near --accountId {{wallet.isAuthenticated() ? wallet.accountId : '%accountId%'}} \
   call {{wallet.contractName}} add_member_proposal \
   '{{sampleMemberProposal()}}' --deposit 0.006</pre>
    <pre *ngSwitchCase="'vote'">npx near login{{'\n'}}npx near --accountId {{wallet.isAuthenticated() ? wallet.accountId : '%accountId%'}} \
   call {{wallet.contractName}} vote_approve \
   '{{sampleVote()}}'{{'\n'}}npx near --accountId {{wallet.isAuthenticated() ? wallet.accountId : '%accountId%'}} \
   call {{wallet.contractName}} vote_reject \
   '{{sampleVote()}}'</pre>
  </div>
  <!-- Footer -->
  <footer>
    {{titleFull()}}
  </footer>

  <svg id="clouds" xmlns="http://www.w3.org/2000/svg" width="2611.084" height="485.677" viewBox="0 0 2611.084 485.677">
    <path id="Path_39" data-name="Path 39"
          d="M2379.709,863.793c10-93-77-171-168-149-52-114-225-105-264,15-75,3-140,59-152,133-30,2.83-66.725,9.829-93.5,26.25-26.771-16.421-63.5-23.42-93.5-26.25-12-74-77-130-152-133-39-120-212-129-264-15-54.084-13.075-106.753,9.173-138.488,48.9-31.734-39.726-84.4-61.974-138.487-48.9-52-114-225-105-264,15a162.027,162.027,0,0,0-103.147,43.044c-30.633-45.365-87.1-72.091-145.206-58.044-52-114-225-105-264,15-75,3-140,59-152,133-53,5-127,23-130,83-2,42,35,72,70,86,49,20,106,18,157,5a165.625,165.625,0,0,0,120,0c47,94,178,113,251,33,61.112,8.015,113.854-5.72,150.492-29.764a165.62,165.62,0,0,0,110.861-3.236c47,94,178,113,251,33,31.385,4.116,60.563,2.495,86.487-3.311,25.924,5.806,55.1,7.427,86.488,3.311,73,80,204,61,251-33a165.625,165.625,0,0,0,120,0c51,13,108,15,157-5a147.188,147.188,0,0,0,33.5-18.694,147.217,147.217,0,0,0,33.5,18.694c49,20,106,18,157,5a165.625,165.625,0,0,0,120,0c47,94,178,113,251,33C2446.709,1093.793,2554.709,922.793,2379.709,863.793Z"
          transform="translate(142.69 -634.312)" fill="#eee"/>
  </svg>

</div>
<router-outlet></router-outlet>

'''
'''--- src/app/app.component.spec.ts ---
import { TestBed } from '@angular/core/testing';
import { RouterTestingModule } from '@angular/router/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [
        RouterTestingModule
      ],
      declarations: [
        AppComponent
      ],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have as title 'cryptoartdao'`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('CryptoArt DAO');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('.content span')?.textContent).toContain('CryptoArt DAO app is running!');
  });
});

'''
'''--- src/app/app.component.ts ---
import {
  Component,
} from '@angular/core';
import {
  WalletService,
} from "./service/wallet.service";

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.sass']
})
export class AppComponent {
  title = 'CryptoArt DAO';
  formProposalForBecomeMember = false
  proposalForBecomeMemberTitle = ''
  proposalForBecomeMemberDescription = ''

  constructor(
    public wallet: WalletService,
  ) {
  }

  sampleMemberProposal(): string {
    return JSON.stringify({
      title: 'max 170',
      description: 'max 1k'
    });
  }

  sampleVote(): string {
    return JSON.stringify({
      proposal_id: 0,
    });
  }

  catAddProposalForBecomeMember(): boolean {
    return !this.wallet.isAuthenticated() || this.hasAddProposalForBecomeMember()
  }

  addProposalForBecomeMember(): void {
    this.formProposalForBecomeMember = !this.formProposalForBecomeMember
  }

  async sendProposalForBecomeMember() {
    await this.wallet.addMemberProposal(this.proposalForBecomeMemberTitle, this.proposalForBecomeMemberDescription)
    this.formProposalForBecomeMember = false
  }

  hasAddProposalForBecomeMember(): boolean {
    return this.wallet.proposalList.filter((it) => {
      console.log(it)
      return it.proposal.author === this.wallet.accountId
    }).length > 0
  }

  titleFull(): string {
    return `${this.title} (${this.wallet.contractName})`
  }
}

'''
'''--- src/app/app.module.ts ---
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { ServiceWorkerModule } from '@angular/service-worker';
import { environment } from '../environments/environment';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import {MatButtonModule} from "@angular/material/button";
import {MatIconModule} from "@angular/material/icon";
import {MatFormFieldModule} from "@angular/material/form-field";
import {MatInputModule} from "@angular/material/input";
import {MatGridListModule} from "@angular/material/grid-list";
import {FormsModule, ReactiveFormsModule} from "@angular/forms";
import {MatBadgeModule} from "@angular/material/badge";

@NgModule({
  declarations: [
    AppComponent
  ],
    imports: [
        BrowserModule,
        AppRoutingModule,
        ServiceWorkerModule.register('ngsw-worker.js', {
            enabled: environment.production,
            // Register the ServiceWorker as soon as the app is stable
            // or after 30 seconds (whichever comes first).
            registrationStrategy: 'registerWhenStable:30000'
        }),
        BrowserAnimationsModule,
        MatButtonModule,
        MatIconModule,
        MatFormFieldModule,
        MatInputModule,
        MatGridListModule,
        ReactiveFormsModule,
        FormsModule,
        MatBadgeModule
    ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

'''
'''--- src/app/service/wallet.service.spec.ts ---
import { TestBed } from '@angular/core/testing';

import { WalletService } from './wallet.service';

describe('WalletService', () => {
  let service: WalletService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(WalletService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});

'''
'''--- src/app/service/wallet.service.ts ---
import {Injectable,} from '@angular/core';
import getConfig from '../../config'
import {connect, Contract, keyStores, WalletConnection,} from 'near-api-js'
import {formatNearAmount,} from "near-api-js/lib/utils/format";

const nearConfig = getConfig('development') // TODO use process.env.NODE_ENV || 'development'

interface ProposalVote {
  approve: number
  reject: number
}

interface Proposal {
  id: number
  title: string
  description: string
  kind: string
  status: string
  author: string
  vote: ProposalVote
}

interface ProposalOfAccount {
  proposal: Proposal
  canVote: boolean
}

interface Society extends Contract {
  balance(): Promise<string>

  member_list(): Promise<string[]>

  proposal_list(): Promise<Proposal[]>

  is_member(param: Object): Promise<boolean>

  can_vote(param: Object): Promise<boolean>

  add_member_proposal(param: Object, gas: string, amount: string): Promise<number>

  vote_reject(param: Object, gas: string, amount: string): Promise<void>

  vote_approve(param: Object, gas: string, amount: string): Promise<void>
}

@Injectable({
  providedIn: 'root'
})
export class WalletService {
  connection: WalletConnection
  contractName: string
  contract: Society
  accountId: string
  balance: number = 0
  memberList: string[] = []
  proposalList: ProposalOfAccount[] = []
  isMember: boolean = false

  // constructor(@Inject(WINDOW) private window: Window) {
  constructor() {
    this.initContract().catch(reason => {
      throw new Error(reason.message)
    })
  }

  async initContract(): Promise<void> {
    // Initialize connection to the NEAR testnet
    const near = await connect(Object.assign({deps: {keyStore: new keyStores.BrowserLocalStorageKeyStore()}}, nearConfig))

    // Initializing Wallet based Account. It can work with NEAR testnet wallet that
    // is hosted at https://wallet.testnet.near.org
    // @ts-ignore
    this.connection = new WalletConnection(near)

    // Getting the Account ID. If still unauthorized, it's just empty string
    this.accountId = this.connection.getAccountId()
    this.contractName = nearConfig.contractName

    // Initializing our contract APIs by contract name and configuration
    // @ts-ignore
    this.contract = new Contract(this.connection.account(), this.contractName, {
      viewMethods: [
        'balance',
        'member_list',
        'proposal_list',
        'is_member',
        'can_vote',
      ],
      changeMethods: [
        'add_member_proposal',
        'vote_approve',
        'vote_reject',
      ],
    })
    await this.update()
  }

  async update(): Promise<void> {
    this.isMember = await this.updateStatusMember(this.accountId)
    await this.updateBalance()
    await this.updateMemberList()
    await this.updateProposalList()
  }

  async updateBalance(): Promise<void> {
    this.balance = Math.floor(parseFloat(formatNearAmount(await this.contract.balance())) * 100) / 100
  }

  async updateMemberList(): Promise<void> {
    this.memberList = await this.contract.member_list()
  }

  async updateProposalList(): Promise<void> {
    // FIXME it need refactor
    const list = await this.contract.proposal_list()
    this.proposalList = await Promise.all(
      list.map(async (proposal) => {
        const out = <ProposalOfAccount>{
          proposal: await proposal
        }
        out.canVote = false
        if (this.accountId) {
          const catVote = await this.canVote(proposal.id, this.accountId)
          out.canVote = catVote && this.isMember
        }
        return out
      })
    )
  }

  async voteReject(proposal_id: number): Promise<void> {
    await this.contract.vote_reject(
      {
        proposal_id,
      },
      '300000000000000',
      '0',
    )
  }

  async voteApprove(proposal_id: number): Promise<void> {
    await this.contract.vote_approve(
      {
        proposal_id,
      },
      '300000000000000',
      '0',
    )
  }

  async updateStatusMember(account_id: string): Promise<boolean> {
    return await this.contract.is_member(
      {
        account_id,
      }
    )
  }

  async canVote(proposal_id: number, account_id: string): Promise<boolean> {
    return await this.contract.can_vote(
      {
        proposal_id,
        account_id,
      }
    )
  }

  addMemberProposal(title: string, description: string): Promise<number> {
    return this.contract.add_member_proposal(
      {
        title,
        description,
      },
      '5000000000000', // 5 TGas
      '14000000000000000000000', // 0.014 NEAR
    )
  }

  signIn(): void {
    // Allow the current app to make calls to the specified contract on the
    // user's behalf.
    // This works by creating a new access key for the user's account and storing
    // the private key in localStorage.
    this.connection.requestSignIn(nearConfig.contractName)
  }

  isAuthenticated(): boolean {
    return !!this.accountId
  }

  signOut(): void {
    this.connection.signOut()
  }
}

'''
'''--- src/config.ts ---
import CONTRACT_NAME from './contract-name'

interface NetworkConfig {
  networkId: string
  nodeUrl: string
  contractName: string
  walletUrl?: string
  helperUrl?: string
  explorerUrl?: string
  keyPath?: string
  masterAccount?: string
}

function getConfig(env: string): NetworkConfig {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
        explorerUrl: 'https://explorer.mainnet.near.org',
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        explorerUrl: 'https://explorer.testnet.near.org',
      }
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
        explorerUrl: 'https://explorer.betanet.near.org',
      }
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME,
      }
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near',
      }
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near',
      }
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

export default getConfig

'''
'''--- src/contract/build.sh ---
#!/usr/bin/env bash

set -o errexit

# cargo install wasm-snip wasm-gc
# apt-get install -y binaryen wabt
# https://github.com/near/near-sdk-rs/tree/master/minifier
minify() {
  filePath="${1}"
  fileName=$(basename -- "${filePath}")
  dirPath=$(dirname -- "${filePath}")
  tmpPath="${dirPath}/temp-${fileName}"
  outFileName="${fileName%.*}-minified.${fileName##*.}"
  outPath="${dirPath}/${outFileName}"
  wasm-snip \
    --snip-rust-fmt-code \
    --snip-rust-panicking-code \
    --pattern core::num::flt2dec::.* \
    --pattern core::fmt::float::.* \
    --output "${tmpPath}" \
    "${filePath}"
  wasm-gc "${tmpPath}"
  wasm-strip "${tmpPath}"
  wasm-opt -Oz "${tmpPath}" --output "${outPath}"
  rm "${tmpPath}"
  fileSize=$(stat -c "%s" "${filePath}")
  outSize=$(stat -c "%s" "${outPath}")
  echo "Minifying ${fileName} ${fileSize} bytes -> ${outSize} bytes, see ${outFileName}"
}

build() {
  package="${1}"
  cargo build --package "${package}" --target wasm32-unknown-unknown --release
  mkdir -p build
  cp target/wasm32-unknown-unknown/release/*.wasm build/
  # shellcheck disable=SC2002
  cat "src/contract/${package}/${package}.svg" | npx svgo -i - -o - | base64 -w0 | printf 'data:image/svg+xml;base64,%s' "$(cat)" >"build/${package}.icon"
  printf '<html><body><img src="%s"></body></html>' "$(cat "build/${package}.icon")" >"build/${package}.html"
  minify "build/${package}.wasm"
  echo "Build size:"
  du -b build/*"${package}"*
}

build society

'''
'''--- src/contract/society/Cargo.toml ---
[package]
name = "society"
description = "CryptoArt DAO"
homepage = "https://cryptoartdao.github.io/"
edition = "2018"
version = "1.0.0-beta.0"
license = "UNLICENSED"

[lib]
crate-type = ["cdylib", "rlib"]
path = "society.rs"
test = true
doctest = false
bench = false
doc = false

[dependencies]
serde = { version = "1.0.117", features = ["derive"] }
serde_json = "1.0.59"
near-sdk = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"

'''
'''--- src/contract/society/society.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::collections::{LookupMap, UnorderedSet};
use near_sdk::env;
use near_sdk::json_types::U128;
use near_sdk::near_bindgen;
use near_sdk::serde::Deserialize;
use near_sdk::serde::Serialize;
use near_sdk::AccountId;
use near_sdk::Balance;
use near_sdk::BorshStorageKey;
use near_sdk::CryptoHash;
use near_sdk::PanicOnDefault;
use near_sdk::Promise;

near_sdk::setup_alloc!();

const VOTE_TARGET: f64 = 0.50; // 50%
const MINT_STORAGE_COST: u128 = 14000000000000000000000; // 0.014 NEAR

fn consensus(max: u64, quorum: u64) -> bool {
    let target = (max as f64 * VOTE_TARGET).floor() as u64 + 1;
    quorum >= target
}

pub fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

pub fn hash(data: String) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(data.as_bytes()));
    hash
}

#[derive(BorshSerialize, BorshDeserialize, BorshStorageKey, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalKind {
    MemberRequest,
}

#[derive(BorshSerialize, BorshDeserialize, BorshStorageKey, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum ProposalStatus {
    Draft,
    Vote,
    Accepted,
    Rejected,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalVote {
    approve: u64,
    reject: u64,
}

impl ProposalVote {
    pub fn is_approve(&self) -> bool {
        self.approve > self.reject
    }

    pub fn is_parte(&self) -> bool {
        self.approve == self.reject
    }

    pub fn is_reject(&self) -> bool {
        self.approve < self.reject
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Proposal {
    id: u64,
    title: String,
    kind: ProposalKind,
    status: ProposalStatus,
    description: String,
    author: AccountId,
    vote: ProposalVote,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalState {
    title: String,
    kind: ProposalKind,
    status: ProposalStatus,
    description: String,
    author: AccountId,
    vote: ProposalVote,
}

impl ProposalState {
    pub fn new(
        title: String,
        description: String,
        author: AccountId,
        kind: ProposalKind,
        status: ProposalStatus,
    ) -> Self {
        Self {
            title,
            kind,
            status,
            description,
            author,
            vote: ProposalVote {
                approve: 0,
                reject: 0,
            },
        }
    }

    fn is_draft(&self) -> bool {
        self.status == ProposalStatus::Draft
    }

    fn is_accepted(&self) -> bool {
        self.status == ProposalStatus::Accepted
    }

    fn vote(&mut self, resolve: bool, max: u64) {
        if resolve {
            self.vote.approve += 1;
        } else {
            self.vote.reject += 1;
        }
        self.calc(max);
    }

    fn calc(&mut self, total: u64) {
        if !self.consensus(total) {
            return;
        }
        if self.vote.is_approve() {
            self.status = ProposalStatus::Accepted;
        } else if self.vote.is_reject() {
            self.status = ProposalStatus::Rejected;
        } else if self.quorum() == total {
            self.status = ProposalStatus::Draft;
            self.vote.reject = 0;
            self.vote.approve = 0;
        }
    }

    fn consensus(&self, max: u64) -> bool {
        consensus(max, self.quorum())
    }

    fn quorum(&self) -> u64 {
        self.vote.approve + self.vote.reject
    }
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    MemberList,
    ProposalList,
    ProposalVote { hash: CryptoHash },
    VoteList,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Society {
    member_list: UnorderedSet<AccountId>,
    proposal_list: Vector<ProposalState>,
    vote_list: LookupMap<u64, UnorderedSet<AccountId>>,
}

#[near_bindgen]
impl Society {
    #[init]
    pub fn init() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let mut contract = Self::new();
        contract.setup();
        contract
    }

    #[init(ignore_state)]
    pub fn migrate() -> Self {
        assert!(Self::is_self(), "Private function");
        assert!(env::state_exists(), "State doesn't exist");
        let mut state: Society = env::state_read().expect("State doesn't exist");
        env::log(b"clearing");
        env::log(format!("current.proposal_list.len()={}", state.proposal_list.len()).as_bytes());
        for i in 0..state.proposal_list.len() {
            env::log(format!("vote_list.remove({})", &i).as_bytes());
            state.vote_list.remove(&i);
        }
        env::log(format!("proposal_list.clear() - {}", state.proposal_list.len()).as_bytes());
        state.proposal_list.clear();
        env::log(format!("member_list.clear() - {}", state.member_list.len()).as_bytes());
        state.member_list.clear();
        let mut contract = Self::new();
        contract.setup();
        contract
    }

    fn is_self() -> bool {
        env::predecessor_account_id() == env::current_account_id()
    }

    fn setup(&mut self) {
        self.add_member(env::signer_account_id());
    }

    fn new() -> Self {
        Self {
            member_list: UnorderedSet::new(StorageKey::MemberList),
            proposal_list: Vector::new(StorageKey::ProposalList),
            vote_list: LookupMap::new(StorageKey::VoteList),
        }
    }

    fn account_locked_for_storage(self) -> u128 {
        env::storage_byte_cost() * Balance::from(env::storage_usage())
    }

    pub fn balance(self) -> U128 {
        U128(
            env::account_balance()
                - env::account_locked_balance()
                - self.account_locked_for_storage(),
        )
    }

    pub fn is_member(&self, account_id: AccountId) -> bool {
        self.member_list.contains(&account_id)
    }

    fn add_member(&mut self, account_id: AccountId) -> bool {
        self.assert_is_member(account_id.clone());
        self.member_list.insert(&account_id)
    }

    fn vote_total(&self) -> u64 {
        self.member_list.len()
    }

    pub fn can_vote(self, proposal_id: u64, account_id: AccountId) -> bool {
        match self.vote_list.get(&proposal_id) {
            Some(vote_list) => !vote_list.contains(&account_id),
            None => true,
        }
    }

    pub fn vote_approve(&mut self, proposal_id: u64) {
        self.vote(proposal_id, true)
    }

    pub fn vote_reject(&mut self, proposal_id: u64) {
        self.vote(proposal_id, false)
    }

    fn vote(&mut self, proposal_id: u64, resolve: bool) {
        let signer_account_id = env::signer_account_id();
        assert!(
            self.is_member(signer_account_id.clone()),
            "Only for members"
        );
        let mut proposal = match self.proposal_list.get(proposal_id) {
            Some(proposal) => proposal,
            None => env::panic(b"Proposal not found"),
        };
        let mut vote_list = match self.vote_list.get(&proposal_id) {
            Some(vote_list) => vote_list,
            None => UnorderedSet::new(StorageKey::ProposalVote {
                hash: hash(format!("{}{}", proposal_id, proposal.author)),
            }),
        };
        if vote_list.contains(&signer_account_id) {
            env::panic(b"You are already voted")
        }
        proposal.vote(resolve, self.vote_total());
        if proposal.is_draft() {
            vote_list = UnorderedSet::new(StorageKey::ProposalVote {
                hash: hash(format!("{}{}", proposal_id, proposal.author)),
            })
        } else {
            vote_list.insert(&signer_account_id);
        }
        self.vote_list.insert(&proposal_id, &vote_list);
        if proposal.is_accepted() {
            self.add_member(proposal.author.clone());
        }
        self.proposal_list.replace(proposal_id, &proposal);
    }

    #[payable]
    pub fn add_member_proposal(
        &mut self,
        title: Option<String>,
        description: Option<String>,
    ) -> u64 {
        if env::attached_deposit() < MINT_STORAGE_COST {
            env::panic(b"Need attach minimum 0.04 NEAR for cover storage")
        }
        let initial_storage_usage = env::storage_usage();
        let signer_account_id = env::signer_account_id();
        self.assert_is_member(signer_account_id.clone());
        let proposal_id = self.add_proposal(
            signer_account_id,
            ProposalKind::MemberRequest,
            ProposalStatus::Vote,
            title,
            description,
        );
        refund_deposit(env::storage_usage() - initial_storage_usage);
        proposal_id
    }

    fn assert_is_member(&mut self, account_id: AccountId) {
        if self.member_list.contains(&account_id) {
            env::panic(format!("Account {} already is member", account_id).as_bytes())
        }
    }

    fn add_proposal(
        &mut self,
        author: AccountId,
        kind: ProposalKind,
        status: ProposalStatus,
        title: Option<String>,
        description: Option<String>,
    ) -> u64 {
        let title = title.unwrap_or_default();
        if title.len() > 170 {
            env::panic(b"Field title mus be less 70 lenght")
        }
        let description = description.unwrap_or_default();
        if description.len() > 1000 {
            env::panic(b"Field description mus be less 1000 lenght")
        }
        self.proposal_list.push(&ProposalState::new(
            title,
            description,
            author,
            kind,
            status,
        ));
        self.proposal_list.len() - 1
    }

    pub fn member_list(self, offset: Option<u64>, limit: Option<u64>) -> Vec<AccountId> {
        let limit = limit.unwrap_or(100);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        let start_index: u64 = offset.unwrap_or(0);
        assert!(
            self.member_list.len() > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        self.member_list
            .iter()
            .skip(start_index as usize)
            .take(limit as usize)
            .collect()
    }

    pub fn proposal_list(self, offset: Option<u64>, limit: Option<u64>) -> Vec<Proposal> {
        let limit = limit.unwrap_or(100);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        let start_index: u64 = offset.unwrap_or(0);
        assert!(
            self.member_list.len() > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let mut id = start_index;
        let mut result = vec![];
        for state in self.proposal_list.iter().skip(start_index as usize) {
            result.push(Proposal {
                id,
                title: state.title,
                kind: state.kind,
                status: state.status,
                description: state.description,
                author: state.author,
                vote: state.vote,
            });
            id += 1
        }
        result
    }
}

#[cfg(test)]
mod unit {
    use super::*;
    use near_sdk::json_types::ValidAccountId;
    use near_sdk::test_utils::accounts;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;
    use near_sdk::MockedBlockchain;
    use std::convert::TryFrom;

    pub fn new_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn consensus_cases() {
        assert!(consensus(1, 1));
        assert_eq!(!consensus(2, 1), consensus(2, 2));
        assert_eq!(!consensus(3, 1), consensus(3, 2));
        assert_eq!(!consensus(4, 2), consensus(4, 3));
        assert_eq!(!consensus(5, 2), consensus(5, 3));
        assert_eq!(!consensus(6, 3), consensus(6, 4));
        assert_eq!(!consensus(7, 3), consensus(7, 4));
        assert_eq!(!consensus(8, 4), consensus(8, 5));
        assert_eq!(!consensus(9, 4), consensus(9, 5));
        assert_eq!(!consensus(10, 5), consensus(10, 6));
        assert_eq!(!consensus(11, 5), consensus(11, 6));
        assert_eq!(!consensus(12, 6), consensus(12, 7));
        assert_eq!(!consensus(13, 6), consensus(13, 7));
    }

    #[test]
    fn balance() {
        let context = new_context(accounts(1));
        testing_env!(context.build());
        let contract = Society::init();
        assert_eq!(U128(96926860000000000000000000), contract.balance());
    }

    #[test]
    fn member_list() {
        let context = new_context(accounts(1));
        testing_env!(context.build());
        let contract = Society::init();
        assert_eq!(
            vec![accounts(1).into()] as Vec<AccountId>,
            contract.member_list(None, None)
        );
    }

    #[test]
    fn is_member() {
        let context = new_context(accounts(1));
        testing_env!(context.build());
        let contract = Society::init();
        assert!(contract.is_member(accounts(1).into()));
    }

    #[test]
    fn is_not_member() {
        let context = new_context(accounts(1));
        testing_env!(context.build());
        let contract = Society::init();
        assert!(!contract.is_member(accounts(2).into()));
    }

    #[test]
    fn proposal_list_empty() {
        let context = new_context(accounts(1));
        testing_env!(context.build());
        let contract = Society::init();
        assert_eq!(0, contract.proposal_list(None, None).len());
    }

    #[test]
    #[should_panic(expected = "Account bob already is member")]
    fn add_member_proposal_for_exist() {
        let mut context = new_context(accounts(1));
        testing_env!(context.attached_deposit(MINT_STORAGE_COST).build());
        let mut contract = Society::init();
        contract.add_member_proposal(None, None);
    }

    #[test]
    fn add_member_proposal() {
        let mut context = new_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Society::init();
        testing_env!(context
            .signer_account_id(ValidAccountId::try_from("a".repeat(64)).unwrap())
            .attached_deposit(MINT_STORAGE_COST)
            .build());
        assert_eq!(
            0,
            contract.add_member_proposal(Some("a".repeat(170)), Some("a".repeat(1000)))
        );
        assert_eq!(1, contract.proposal_list(None, None).len());
    }

    #[test]
    #[should_panic(expected = "Need attach minimum 0.04 NEAR for cover storage")]
    fn add_member_proposal_without_cover_storage() {
        let context = new_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Society::init();
        contract.add_member_proposal(None, None);
    }
}
#[cfg(test)]
mod society_simulator;

'''
'''--- src/contract/society/society.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250">
  <path fill="#DD0031" d="M125 30 31.9 63.2l14.2 123.1L125 230l78.9-43.7 14.2-123.1z"/>
  <path fill="#C3002F" d="M125 30v22.2-.1V230l78.9-43.7 14.2-123.1L125 30z"/>
  <path fill="#FFF" d="M125 52.1 66.8 182.6h21.7l11.7-29.2h49.4l11.7 29.2H183L125 52.1zm17 83.3h-34l17-40.9 17 40.9z"/>
</svg>

'''
'''--- src/contract/society/society_simulator.rs ---
#[test]
fn vote() {
    let (contract, list) = create_member_proposal_for_all();
    let actual: Vec<Proposal> = contract
        .view(contract.account_id(), "proposal_list", &args(json!({})))
        .unwrap_json();
    assert_eq!(list.len(), actual.len());
    // 1st member added on deploy contract
    assert_eq!(1, member_total(&contract));

    // 1 exist members for 2nd member need 1 approve
    let proposal_id = 0;
    call_vote_approve(&contract, &contract, proposal_id);
    assert_eq!(2, member_total(&contract));

    // 2 exist members for 3rd member need 2 approve
    let proposal_id = 1;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    assert_eq!(3, member_total(&contract));

    // 3 exist members for 4th member need 2 approve
    let proposal_id = 2;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    assert_eq!(4, member_total(&contract));

    // 4 exist members for 5th member need 3 approve
    let proposal_id = 3;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    assert_eq!(5, member_total(&contract));

    // 5 exist members for 6th member need 3 approve
    let proposal_id = 4;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    assert_eq!(6, member_total(&contract));

    // 6 exist members for 7th member need 4 approve
    let proposal_id = 5;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    call_vote_approve(&contract, &list[2], proposal_id);
    assert_eq!(7, member_total(&contract));

    // 7 exist members for 8th member need 4 approve
    let proposal_id = 6;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    call_vote_approve(&contract, &list[2], proposal_id);
    assert_eq!(8, member_total(&contract));

    // 8 exist members for 9th member need 5 approve
    let proposal_id = 7;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    call_vote_approve(&contract, &list[2], proposal_id);
    call_vote_approve(&contract, &list[3], proposal_id);
    assert_eq!(9, member_total(&contract));

    // 9 exist members for 10th member need 5 approve
    let proposal_id = 8;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    call_vote_approve(&contract, &list[2], proposal_id);
    call_vote_approve(&contract, &list[3], proposal_id);
    assert_eq!(10, member_total(&contract));

    // 10 exist members for 11th member need 6 approve
    let proposal_id = 9;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    call_vote_approve(&contract, &list[2], proposal_id);
    call_vote_approve(&contract, &list[3], proposal_id);
    call_vote_approve(&contract, &list[4], proposal_id);
    assert_eq!(11, member_total(&contract));

    // 11 exist members for 12th member need 6 approve
    let proposal_id = 10;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    call_vote_approve(&contract, &list[2], proposal_id);
    call_vote_approve(&contract, &list[3], proposal_id);
    call_vote_approve(&contract, &list[4], proposal_id);
    assert_eq!(12, member_total(&contract));

    // 12 exist members for 13th member need 7 approve
    let proposal_id = 11;
    call_vote_approve(&contract, &contract, proposal_id);
    call_vote_approve(&contract, &list[0], proposal_id);
    call_vote_approve(&contract, &list[1], proposal_id);
    call_vote_approve(&contract, &list[2], proposal_id);
    call_vote_approve(&contract, &list[3], proposal_id);
    call_vote_approve(&contract, &list[4], proposal_id);
    call_vote_approve(&contract, &list[6], proposal_id);
    assert_eq!(13, member_total(&contract));
}

fn member_total(contract: &UserAccount) -> usize {
    let actual: Vec<AccountId> = contract
        .view(contract.account_id(), "member_list", &args(json!({})))
        .unwrap_json();
    actual.len()
}

fn call_vote_approve(contract: &UserAccount, signer: &UserAccount, proposal_id: u64) {
    let result = call(
        &contract,
        &signer,
        "vote_approve",
        json!({
            "proposal_id": proposal_id,
        }),
        0, // deposit
    );
    assert_eq!(
        0,
        result.promise_errors().len(),
        "got error: {:#?}",
        result.promise_errors()
    );
}

fn create_member_proposal_for_all() -> (UserAccount, Vec<UserAccount>) {
    let (contract, list) = deploy();
    for user in list.iter().as_ref() {
        let result = call(
            &contract,
            user,
            "add_member_proposal",
            json!({
                "title": "a".repeat(170),
                "description": "a".repeat(1000),
            }),
            MINT_STORAGE_COST, // deposit
        );
        assert_eq!(
            0,
            result.promise_errors().len(),
            "got error: {:#?}",
            result.promise_errors()
        );
    }
    (contract, list)
}

#[test]
fn add_member_proposal() {
    let (contract, list) = deploy();
    let actual: Vec<Proposal> = contract
        .view(contract.account_id(), "proposal_list", &args(json!({})))
        .unwrap_json();
    assert_eq!(0, actual.len());
    let result = call(
        &contract,
        &list[0],
        "add_member_proposal",
        json!({
            "title": "a".repeat(170),
            "description": "a".repeat(1000),
        }),
        MINT_STORAGE_COST, // deposit
    );
    assert_burnt_gas("add_member_proposal_1", &result, "4", None);
    let actual: Vec<Proposal> = contract
        .view(contract.account_id(), "proposal_list", &args(json!({})))
        .unwrap_json();
    assert_eq!(1, actual.len());
}

use near_sdk::serde_json::json;
use near_sdk::serde_json::Value;
use near_sdk::AccountId;
use near_sdk_sim::init_simulator;
use near_sdk_sim::lazy_static_include;
use near_sdk_sim::to_yocto;
use near_sdk_sim::ExecutionResult;
use near_sdk_sim::UserAccount;
use near_sdk_sim::DEFAULT_GAS;
use near_sdk_sim::STORAGE_AMOUNT;

pub fn account_id(name: &str) -> AccountId {
    name.to_string()
}

pub fn args(data: Value) -> Vec<u8> {
    json!(data).to_string().into_bytes()
}

use crate::{Proposal, MINT_STORAGE_COST};
use near_sdk::Balance;

pub fn call(
    contract: &UserAccount,
    signer: &UserAccount,
    method: &str,
    data: Value,
    deposit: Balance,
) -> ExecutionResult {
    signer.call(
        contract.account_id.clone(),
        method,
        &args(data),
        DEFAULT_GAS,
        deposit,
    )
}

pub fn deploy() -> (UserAccount, Vec<UserAccount>) {
    let (root, list) = init();
    lazy_static_include::lazy_static_include_bytes! {
        CONTRACT_WASM_BYTES => "../../../build/society-minified.wasm",
    }
    let contract = root.deploy(&CONTRACT_WASM_BYTES, account_id("contract"), STORAGE_AMOUNT);
    contract.call(
        contract.account_id(),
        "init",
        &json!({}).to_string().into_bytes(),
        DEFAULT_GAS,
        0,
    );
    (contract, list)
}

pub fn init() -> (UserAccount, Vec<UserAccount>) {
    let root = init_simulator(None);
    let list = vec![
        root.create_user(account_id("alice"), to_yocto("100")),
        root.create_user(account_id("bob"), to_yocto("100")),
        root.create_user(account_id("carol"), to_yocto("100")),
        root.create_user(account_id("chuck"), to_yocto("100")),
        root.create_user(account_id("craig"), to_yocto("100")),
        root.create_user(account_id("dave"), to_yocto("100")),
        root.create_user(account_id("eve"), to_yocto("100")),
        root.create_user(account_id("mallory"), to_yocto("100")),
        root.create_user(account_id("peggy"), to_yocto("100")),
        root.create_user(account_id("trent"), to_yocto("100")),
        root.create_user(account_id("walter"), to_yocto("100")),
        root.create_user(account_id("arthur"), to_yocto("100")),
        root.create_user(account_id("paul"), to_yocto("100")),
    ];
    (root, list)
}

pub fn assert_burnt_gas(
    message: &str,
    result: &ExecutionResult,
    tera_gas: &str,
    has_error: Option<usize>,
) {
    print!("{}: ", message);
    assert_eq!(
        result.promise_errors().len(),
        has_error.unwrap_or_default(),
        "got error: {:#?}",
        result.promise_errors()
    );
    assert!(
        result.gas_burnt() <= to_gas(tera_gas),
        "gas burned {} less than or equal to {} expected",
        result.gas_burnt(),
        to_gas(tera_gas)
    );
    println!(
        "burnt tokens:{:.02} TeraGas diff: {:.04}",
        (result.gas_burnt()) as f64 / 1e12,
        (to_gas(tera_gas) - result.gas_burnt()) as f64 / 1e12,
    );
}

pub fn to_gas(tera_gas: &str) -> u64 {
    let part: Vec<_> = tera_gas.split('.').collect();
    let number = part[0].parse::<u64>().unwrap() * u64::pow(10, 12);
    if part.len() > 1 {
        let power = part[1].len() as u32;
        let mantissa = part[1].parse::<u64>().unwrap() * u64::pow(10, 12 - power);
        number + mantissa
    } else {
        number
    }
}

'''
'''--- src/environments/environment.prod.ts ---
export const environment = {
  production: false
};

'''
'''--- src/environments/environment.ts ---
// This file can be replaced during build by using the `fileReplacements` array.
// `ng build` replaces `environment.ts` with `environment.prod.ts`.
// The list of file replacements can be found in `angular.json`.

export const environment = {
  production: false
};

/*
 * For easier debugging in development mode, you can import the following file
 * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
 *
 * This import should be commented out in production mode because it will have a negative impact
 * on performance if an error is thrown.
 */
// import 'zone.js/plugins/zone-error';  // Included with Angular CLI.

'''
'''--- src/index.html ---
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CryptoArt Ukraine DAO</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#1976d2">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script>
    //var global = global || window // FIXME it is hotfix Uncaught ReferenceError: global is not defined
    // console.log('global:', global)
    // console.log('Buffer:', global.Buffer)
  </script>
</head>
<body class="mat-typography">
  <app-root></app-root>
  <noscript>Please enable JavaScript to continue using this application.</noscript>
</body>
</html>

'''
'''--- src/main.ts ---
import { enableProdMode } from '@angular/core';
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';
import { environment } from './environments/environment';

if (environment.production) {
  enableProdMode();
}

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));

'''
'''--- src/polyfills.ts ---
/**
 * This file includes polyfills needed by Angular and is loaded before the app.
 * You can add your own extra polyfills to this file.
 *
 * This file is divided into 2 sections:
 *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.
 *   2. Application imports. Files imported after ZoneJS that should be loaded before your main
 *      file.
 *
 * The current setup is for so-called "evergreen" browsers; the last versions of browsers that
 * automatically update themselves. This includes Safari >= 10, Chrome >= 55 (including Opera),
 * Edge >= 13 on the desktop, and iOS 10 and Chrome on mobile.
 *
 * Learn more in https://angular.io/guide/browser-support
 */

/***************************************************************************************************
 * BROWSER POLYFILLS
 */

/**
 * IE11 requires the following for NgClass support on SVG elements
 */
// import 'classlist.js';  // Run `npm install --save classlist.js`.

/**
 * Web Animations `@angular/platform-browser/animations`
 * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.
 * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).
 */
// import 'web-animations-js';  // Run `npm install --save web-animations-js`.

/**
 * By default, zone.js will patch all possible macroTask and DomEvents
 * user can disable parts of macroTask/DomEvents patch by setting following flags
 * because those flags need to be set before `zone.js` being loaded, and webpack
 * will put import in the top of bundle, so user need to create a separate file
 * in this directory (for example: zone-flags.ts), and put the following flags
 * into that file, and then add the following code before importing zone.js.
 * import './zone-flags';
 *
 * The flags allowed in zone-flags.ts are listed here.
 *
 * The following flags will work for all browsers.
 *
 * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame
 * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick
 * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames
 *
 *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js
 *  with the following flag, it will bypass `zone.js` patch for IE/Edge
 *
 *  (window as any).__Zone_enable_cross_context_check = true;
 *
 */

/***************************************************************************************************
 * Zone JS is required by default for Angular itself.
 */
import 'zone.js';  // Included with Angular CLI.

/***************************************************************************************************
 * APPLICATION IMPORTS
 */
(window as any).global = window;
import {Buffer} from 'buffer';
global.Buffer = Buffer;

'''
'''--- src/test.ts ---
// This file is required by karma.conf.js and loads recursively all the .spec and framework files

import 'zone.js/testing';
import { getTestBed } from '@angular/core/testing';
import {
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting
} from '@angular/platform-browser-dynamic/testing';

declare const require: {
  context(path: string, deep?: boolean, filter?: RegExp): {
    keys(): string[];
    <T>(id: string): T;
  };
};

// First, initialize the Angular testing environment.
getTestBed().initTestEnvironment(
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting()
);
// Then we find all the tests.
const context = require.context('./', true, /\.spec\.ts$/);
// And load the modules.
context.keys().map(context);

'''
'''--- tsconfig.app.json ---
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": ["node"]
  },
  "files": [
    "src/main.ts",
    "src/polyfills.ts"
  ],
  "include": [
    "src/**/*.d.ts"
  ]
}

'''
'''--- tsconfig.json ---
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "baseUrl": "./",
    "outDir": "./dist/out-tsc",
    "allowSyntheticDefaultImports": true,
    "sourceMap": true,
    "declaration": false,
    "downlevelIteration": true,
    "experimentalDecorators": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "target": "es2017",
    "module": "es2020",
    "lib": [
      "es2018",
      "dom"
    ]
  }
}

'''
'''--- tsconfig.spec.json ---
/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine", "node"
    ]
  },
  "files": [
    "src/test.ts",
    "src/polyfills.ts"
  ],
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}

'''