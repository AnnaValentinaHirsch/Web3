*GitHub Repository "henchiyb/hurdle-payment-sc"*

'''--- Cargo.toml ---
[package]
name = "hurdle-payment"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[dev-dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
opt-level = 2
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- build.sh ---
#!/bin/bash
set -e

RSUTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p out
cp target/wasm32-unknown-unknown/release/*.wasm out/hurdle-payment.wasm
'''
'''--- src/account.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]

pub struct Account {
  pub locked_balance: Balance,
  pub total_revenue: Balance,
  pub transactions: UnorderedMap<u64, UnorderedMap<String, TransferTransaction>>, // date_string: { transaction_id: TransferTransaction}
  pub last_unlock_at: u64,
}

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountJson {
  pub account_id: AccountId,
  pub locked_balance: U128,
  pub total_revenue: U128,
  pub last_unlock_at: u64,
}

impl AccountJson {
  pub fn from(account_id: AccountId, account: Account) -> Self {
    AccountJson {
      account_id,
      locked_balance: U128(account.locked_balance),
      total_revenue: U128(account.total_revenue),
      last_unlock_at: account.last_unlock_at,
    }
  }
}

// code .

'''
'''--- src/internal.rs ---
use crate::*;

#[near_bindgen]
impl HurdlePayment {
  pub(crate) fn internal_register_account(&mut self, account_id: AccountId) {
    let account = Account {
      locked_balance: 0,
      total_revenue: 0,
      last_unlock_at: env::epoch_height(),
      transactions: UnorderedMap::new(StorageKey::AccountTransactionByDate {
        account_hash: env::sha256(account_id.as_bytes()),
      }),
    };
    self.accounts.insert(&account_id, &account);
  }

  pub(crate) fn internal_create_transfer_transaction(
    &mut self,
    receiver_id: AccountId,
    amount: Balance,
    cash_hold_time: i64,
    campaign_id: String,
    transaction_id: String,
  ) {
    let account = self.accounts.get(&receiver_id);
    assert!(account.is_some(), "Account not found");
    let mut account = account.unwrap();
    let trans = TransferTransaction {
      sender_id: env::predecessor_account_id(),
      receiver_id: receiver_id.clone(),
      campaign_id: campaign_id,
      locked_balance: amount,
      created_at: env::epoch_height(),
      claimable_at: env::epoch_height() + cash_hold_time as u64,
      status: "LOCK".to_string(),
    };
    let today_epoch = env::epoch_height();
    let transactions = account.transactions.get(&today_epoch);
    if transactions.is_none() {
      let mut map = UnorderedMap::new(StorageKey::AccountTransaction {
        account_hash: env::sha256(env::epoch_height().to_string().as_bytes()),
      });
      map.insert(&transaction_id, &trans);
      account.transactions.insert(&today_epoch, &map);
    } else {
      let mut transactions = transactions.unwrap();
      let check_transaction = transactions.get(&transaction_id);
      assert_eq!(
        check_transaction.is_none(),
        true,
        "Transaction ID Duplicated"
      );
      transactions.insert(&transaction_id, &trans);
      account.transactions.insert(&today_epoch, &transactions);
    }

    account.locked_balance += amount;
    account.total_revenue += amount;
    self.accounts.insert(&receiver_id, &account);
  }

  pub(crate) fn internal_unlock_locked_balance(&mut self, account_id: AccountId) {
    let account = self.accounts.get(&account_id);
    assert!(account.is_some(), "Account not found");
    let mut account = account.unwrap();
    let mut last_unlock_at = account.last_unlock_at;
    let mut transer_amount = 0;
    while last_unlock_at <= env::epoch_height() {
      let transactions = account.transactions.get(&last_unlock_at);
      if transactions.is_some() {
        let mut transactions = transactions.unwrap();
        for transaction in transactions.to_vec() {
          let (transaction_id, mut transaction) = transaction;
          if env::epoch_height() >= transaction.claimable_at
            && transaction.status == "LOCK".to_string()
          {
            transaction.status = "CLAIM".to_string();
            transactions.insert(&transaction_id, &transaction);
            account.locked_balance = account
              .locked_balance
              .checked_sub(transaction.locked_balance)
              .unwrap();
            transer_amount += transaction.locked_balance;
          }
        }
      }
      last_unlock_at += 1;
    }
    Promise::new(account_id.clone()).transfer(transer_amount);
    account.last_unlock_at = env::epoch_height();
    self.accounts.insert(&account_id, &account);
  }

  pub(crate) fn internal_refund_by_transaction_id(
    &mut self,
    sender_id: AccountId,
    receiver_id: AccountId,
    transaction_id: String,
    create_epoch: u64,
  ) {
    let account = self.accounts.get(&receiver_id);
    assert!(account.is_some(), "Account not found");
    let mut account = account.unwrap();
    let transactions = account.transactions.get(&create_epoch);
    if transactions.is_some() {
      let mut transactions = transactions.unwrap();
      let transaction = transactions.get(&transaction_id);
      if transaction.is_some() {
        let mut transaction = transaction.unwrap();
        if env::epoch_height() < transaction.claimable_at
          && transaction.status == "LOCK".to_string()
        {
          transaction.status = "REFUND".to_string();
          account.locked_balance = account
            .locked_balance
            .checked_sub(transaction.locked_balance)
            .unwrap();
          account.total_revenue = account
            .total_revenue
            .checked_sub(transaction.locked_balance)
            .unwrap();
          transactions.insert(&transaction_id, &transaction);
          Promise::new(sender_id.clone()).transfer(transaction.locked_balance);
          self.accounts.insert(&receiver_id, &account);
        }
      }
    }
  }

  pub(crate) fn internal_refund_by_epoch(
    &mut self,
    sender_id: AccountId,
    receiver_id: AccountId,
    cash_hold_time: u64,
  ) {
    let account = self.accounts.get(&receiver_id);
    assert!(account.is_some(), "Account not found");
    let mut account = account.unwrap();
    let mut start_epoch = env::epoch_height() - cash_hold_time * 2;
    let mut transer_amount = 0;
    while start_epoch <= env::epoch_height() {
      let transactions = account.transactions.get(&start_epoch);
      if transactions.is_some() {
        let mut transactions = transactions.unwrap();
        for transaction in transactions.to_vec() {
          let (transaction_id, mut transaction) = transaction;
          if env::epoch_height() < transaction.claimable_at
            && sender_id == transaction.sender_id
            && receiver_id == transaction.receiver_id
          {
            transaction.status = "REFUND".to_string();
            transactions.insert(&transaction_id, &transaction);
            account.locked_balance = account
              .locked_balance
              .checked_sub(transaction.locked_balance)
              .unwrap();
            account.total_revenue = account
              .total_revenue
              .checked_sub(transaction.locked_balance)
              .unwrap();
            transer_amount += transaction.locked_balance;
          }
        }
      }
      start_epoch += 1;
    }
    Promise::new(sender_id.clone()).transfer(transer_amount);
    self.accounts.insert(&receiver_id, &account);
  }
}

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, BlockHeight, BorshStorageKey, PanicOnDefault, Promise,
    PromiseOrValue,
};

use crate::internal::*;
mod internal;
use crate::util::*;
mod util;
use crate::account::*;
mod account;
use crate::transfer_transaction::*;
mod transfer_transaction;

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    AccountKey,
    AccountTransaction { account_hash: Vec<u8> },
    AccountTransactionByDate { account_hash: Vec<u8> },
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
#[near_bindgen]
pub struct HurdlePayment {
    pub owner_id: AccountId,
    pub accounts: LookupMap<AccountId, Account>,
}

#[near_bindgen]
impl HurdlePayment {
    #[init]
    pub fn new() -> Self {
        HurdlePayment {
            owner_id: env::current_account_id(),
            accounts: LookupMap::new(StorageKey::AccountKey),
        }
    }

    #[payable]
    pub fn register_new_account(&mut self, account_id: AccountId) {
        assert_at_least_one_yocto();
        assert!(
            env::is_valid_account_id(account_id.as_bytes()),
            "Invalid account id"
        );
        let account_stake = self.accounts.get(&account_id);

        if account_stake.is_some() {
            // refund all deposited token
            refund_deposit(0, 0);
        } else {
            // Create new account
            let before_storage_usage = env::storage_usage();
            // Refund deposited token to user's account
            self.internal_register_account(account_id.clone());
            let after_storage_usage = env::storage_usage();
            refund_deposit(0, after_storage_usage - before_storage_usage);
        }
    }

    #[payable]
    pub fn send_to_receiver(&mut self, receiver_id: AccountId, y_amount: f64) {
        let attached_amount = env::attached_deposit();
        let amount = (y_amount * 1_000_000_000_000_000_000_000_000_f64) as u128;
        if attached_amount >= amount {
            Promise::new(receiver_id).transfer(amount);
            refund_deposit(amount, 0)
        } else {
            refund_deposit(0, 0)
        }
    }

    #[payable]
    pub fn send_to_contract(
        &mut self,
        receiver_id: AccountId,
        y_amount: f64,
        cash_hold_time: i64,
        campaign_id: String,
        transaction_id: String,
    ) {
        let amount = (y_amount * 1_000_000_000_000_000_000_000_000_f64) as u128;
        let before_storage_usage = env::storage_usage();
        // Refund deposited token to user's account
        self.internal_create_transfer_transaction(
            receiver_id,
            amount,
            cash_hold_time * 2,
            campaign_id,
            transaction_id,
        );
        let after_storage_usage = env::storage_usage();
        if after_storage_usage > before_storage_usage {
            refund_deposit(
                amount,
                after_storage_usage
                    .checked_sub(before_storage_usage)
                    .unwrap(),
            );
        }
    }

    #[payable]
    pub fn claim_and_withdraw(&mut self, account_id: AccountId) {
        self.internal_unlock_locked_balance(account_id);
    }

    #[payable]
    pub fn refund_by_transaction_id(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        transaction_id: String,
        create_epoch: u64,
    ) {
        self.internal_refund_by_transaction_id(
            sender_id,
            receiver_id,
            transaction_id,
            create_epoch,
        );
    }

    #[payable]
    pub fn refund_by_epoch(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        cash_hold_time: u64,
    ) {
        self.internal_refund_by_epoch(sender_id, receiver_id, cash_hold_time);
    }

    pub fn get_account_info(&self, account_id: AccountId) -> AccountJson {
        assert!(
            env::is_valid_account_id(account_id.as_bytes()),
            "Invalid account id"
        );
        let account = self.accounts.get(&account_id).unwrap();
        AccountJson::from(account_id, account)
    }

    pub fn get_transactions_info(
        &self,
        account_id: AccountId,
        start_epoch: u64,
        end_epoch: u64,
    ) -> Vec<TransferTransactionJson> {
        let account = self.accounts.get(&account_id).unwrap();
        let mut vec = Vec::new();
        let mut start_epoch_parse = start_epoch;
        while start_epoch_parse <= end_epoch {
            let transactions = account.transactions.get(&start_epoch_parse);
            if transactions.is_some() {
                let transactions = transactions.unwrap();
                for transaction in transactions.to_vec() {
                    let (transaction_id, transaction) = transaction;
                    vec.push(TransferTransactionJson::from(transaction_id, transaction));
                }
            }
            start_epoch_parse += 1;
        }
        vec
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};

    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .attached_deposit(10 * 1_000_000_000_000_000_000_000_000)
            .current_account_id(accounts(0))
            .signer_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .is_view(is_view);
        builder
    }
    #[test]
    fn test_init_contract() {
        let context = get_context(false);

        testing_env!(context.build());

        let contract = HurdlePayment::new();
        assert_eq!(contract.owner_id, env::current_account_id());
    }

    #[test]
    fn test_register_new_account() {
        let context = get_context(false);

        testing_env!(context.build());

        let mut contract = HurdlePayment::new();
        contract.register_new_account(accounts(0).to_string());
        assert_eq!(
            contract
                .accounts
                .get(&accounts(0).to_string())
                .unwrap()
                .total_revenue,
            0
        );
    }

    #[test]
    fn test_send_to_contract() {
        let context = get_context(false);

        testing_env!(context.build());

        let mut contract = HurdlePayment::new();
        contract.register_new_account(accounts(1).to_string());
        contract.send_to_contract(
            accounts(1).to_string(),
            1.0,
            0,
            "12".to_string(),
            "test1".to_string(),
        );
        let account_info = contract.get_account_info(accounts(1).to_string());
        assert_eq!(account_info.total_revenue, U128(999999999999999983222784));
        assert_eq!(account_info.locked_balance, U128(999999999999999983222784));
        let today = env::epoch_height();
        assert_eq!(account_info.last_unlock_at, today);
        contract.send_to_contract(
            accounts(1).to_string(),
            1.0,
            0,
            "1".to_string(),
            "test2".to_string(),
        );
        let account_info = contract.get_account_info(accounts(1).to_string());
        let mut transactions = contract.get_transactions_info(
            accounts(1).to_string(),
            env::epoch_height(),
            env::epoch_height(),
        );
        assert_eq!(transactions.len(), 2);
        assert_eq!(
            account_info.total_revenue,
            U128(999999999999999983222784 * 2)
        );

        assert_eq!(
            account_info.locked_balance,
            U128(999999999999999983222784 * 2)
        );
    }

    #[test]
    fn test_unlock_balance() {
        let context = get_context(false);

        testing_env!(context.build());

        let mut contract = HurdlePayment::new();
        contract.register_new_account(accounts(1).to_string());
        contract.send_to_contract(
            accounts(1).to_string(),
            1.0,
            0,
            "1".to_string(),
            "1".to_string(),
        );

        let locked_amount = contract
            .accounts
            .get(&accounts(1).to_string())
            .unwrap()
            .locked_balance;
        contract.claim_and_withdraw(accounts(1).to_string());
        let mut transactions = contract.get_transactions_info(
            accounts(1).to_string(),
            env::epoch_height(),
            env::epoch_height(),
        );

        assert_eq!(transactions.pop().unwrap().status, "CLAIM");

        assert_eq!(
            contract
                .get_account_info(accounts(1).to_string())
                .locked_balance,
            U128(0)
        );

        assert_eq!(
            contract
                .get_account_info(accounts(1).to_string())
                .total_revenue,
            U128(locked_amount)
        );

        assert_eq!(
            contract
                .get_account_info(accounts(1).to_string())
                .total_revenue,
            U128(locked_amount)
        );
    }

    #[test]
    fn test_refund_by_transaction_id() {
        let context = get_context(false);

        testing_env!(context.build());

        let mut contract = HurdlePayment::new();
        contract.register_new_account(accounts(1).to_string());
        contract.register_new_account(accounts(2).to_string());
        contract.send_to_contract(
            accounts(1).to_string(),
            1.0,
            1,
            "1".to_string(),
            "test".to_string(),
        );

        contract.refund_by_transaction_id(
            accounts(0).to_string(),
            accounts(1).to_string(),
            "test".to_string(),
            env::epoch_height(),
        );
        let transaction = contract
            .get_transactions_info(
                accounts(1).to_string(),
                env::epoch_height(),
                env::epoch_height(),
            )
            .pop()
            .unwrap();
        assert_eq!(transaction.claimable_at, env::epoch_height() + 2);
        assert_eq!(&transaction.status, "REFUND");
        assert_eq!(
            contract
                .get_account_info(accounts(1).to_string())
                .locked_balance,
            U128(0)
        );

        assert_eq!(
            contract
                .get_account_info(accounts(1).to_string())
                .total_revenue,
            U128(0)
        );
    }

    #[test]
    fn test_refund_by_epoch() {
        let context = get_context(false);

        testing_env!(context.build());

        let mut contract = HurdlePayment::new();
        contract.register_new_account(accounts(1).to_string());
        contract.register_new_account(accounts(2).to_string());
        contract.send_to_contract(
            accounts(1).to_string(),
            1.0,
            1,
            "1".to_string(),
            "test".to_string(),
        );
        contract.send_to_contract(
            accounts(1).to_string(),
            1.0,
            1,
            "1".to_string(),
            "test1".to_string(),
        );

        contract.refund_by_epoch(accounts(0).to_string(), accounts(1).to_string(), 0);
        let transaction = contract
            .get_transactions_info(
                accounts(1).to_string(),
                env::epoch_height(),
                env::epoch_height(),
            )
            .pop()
            .unwrap();
        assert_eq!(transaction.claimable_at, env::epoch_height() + 2);
        assert_eq!(&transaction.status, "REFUND");
        assert_eq!(
            contract
                .get_account_info(accounts(1).to_string())
                .locked_balance,
            U128(0)
        );

        assert_eq!(
            contract
                .get_account_info(accounts(1).to_string())
                .total_revenue,
            U128(0)
        );
    }
}

'''
'''--- src/transfer_transaction.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TransferTransaction {
  pub sender_id: AccountId,
  pub receiver_id: AccountId,
  pub campaign_id: String,
  pub locked_balance: Balance,
  pub created_at: u64,
  pub claimable_at: u64,
  pub status: String, // LOCK UNLOCK REFUND
}

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TransferTransactionJson {
  pub transaction_id: String,
  pub sender_id: AccountId,
  pub receiver_id: AccountId,
  pub campaign_id: String,
  pub locked_balance: U128,
  pub created_at: u64,
  pub claimable_at: u64,
  pub status: String, // LOCK UNLOCK REFUND
}

impl TransferTransactionJson {
  pub fn from(transaction_id: String, transaction: TransferTransaction) -> Self {
    TransferTransactionJson {
      transaction_id: transaction_id,
      sender_id: transaction.sender_id,
      receiver_id: transaction.receiver_id,
      campaign_id: transaction.campaign_id,
      locked_balance: U128(transaction.locked_balance),
      created_at: transaction.created_at,
      claimable_at: transaction.claimable_at,
      status: transaction.status,
    }
  }
}

// code .

'''
'''--- src/util.rs ---
use crate::*;

pub(crate) fn assert_at_least_one_yocto() {
  assert!(
    env::attached_deposit() >= 1,
    "Requir attached deposit at least 1 yoctoNEAR"
  )
}

pub(crate) fn assert_one_yocto() {
  assert_eq!(env::attached_deposit(), 1, "Attached 1 yoctoNEAR");
}

pub(crate) fn refund_deposit(amount: Balance, storaged_use: u64) {
  let required_cost = env::storage_byte_cost() * Balance::from(storaged_use) + amount;
  let attached_deposit = env::attached_deposit();

  assert!(
    attached_deposit >= required_cost,
    "Must attach {} yoctoNear to cover starage",
    required_cost
  );

  let refund = attached_deposit - required_cost;
  if refund > 0 {
    Promise::new(env::predecessor_account_id()).transfer(refund);
  }
}

'''