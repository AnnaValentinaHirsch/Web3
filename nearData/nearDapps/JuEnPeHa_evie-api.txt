*GitHub Repository "JuEnPeHa/evie-api"*

'''--- README.md ---
# evie_node

'''
'''--- package.json ---
{
  "name": "evie-api",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "tsc && node ./dist/server.js",
    "dev": "ts-node-dev --respawn ./src/server.ts",
    "build": "tsc"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "express": "^4.18.0",
    "helmet": "^5.0.2",
    "mongoose": "^6.3.1",
    "morgan": "^1.10.0",
    "near-api-js": "^0.44.2",
    "near-contract-parser": "^0.1.4"
  },
  "devDependencies": {
    "@types/compression": "^1.7.2",
    "@types/cors": "^2.8.12",
    "@types/express": "^4.17.13",
    "@types/morgan": "^1.9.3",
    "@types/node": "^17.0.29",
    "nodemon": "^2.0.15",
    "ts-node-dev": "^1.1.8",
    "typescript": "^4.6.3"
  }
}

'''
'''--- src/config.ts ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'evie.jeph.testnet';
export function getConfig(env: string) {
  switch(env) {
    case 'mainnet':
    case 'production':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      };
    case 'development':
    case 'testnet':
      return {
        networkId: 'default',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.ts.`);
  }
}

//export default getConfig(process.env.NODE_ENV || 'testnet');
'''
'''--- src/models/NEARRequest.ts ---
import { Schema, model } from 'mongoose';

const NEARRequestSchema = new Schema({
    receivedAccount: String, 
    receivedContract: String,
})

export default model('NEARRequest', NEARRequestSchema);
'''
'''--- src/models/Post.ts ---
import { Schema, model } from 'mongoose';

const PostSchema = new Schema({
    title: {type: String, required: true},
    content: {type: String, required: true},
    image: {type: String, required: true},
    url: {type: String, required: true, unique: true, lowercase: true},
    createdAt: {type: Date, required: true, default: Date.now()},
    updatedAt: Date,
});

export default model('Post', PostSchema);
'''
'''--- src/models/User.ts ---
import { Schema, model } from 'mongoose';

const UserSchema = new Schema({
    name: {type: String, required: true},
    email: {type: String, required: true, unique: true, lowercase: true},
    password: {type: String, required: true},
    avatar: {type: String, required: false},
    username: {type: String, required: true, unique: true, lowercase: true},
    createdAt: {type: Date, required: true, default: Date.now()},
    updatedAt: Date,
    posts: [{ ref: 'Post', type: Schema.Types.ObjectId }],
});

export default model('User', UserSchema);
'''
'''--- src/networks/mainnet.json ---
{
    "networkId": "mainnet",
    "nodeUrl": "https://rpc.mainnet.near.org",
    "archivalUrl": "https://archival-rpc.mainnet.near.org",
    "walletUrl": "https://wallet.mainnet.near.org",
    "helperUrl": "https://helper.mainnet.near.org",
    "explorerUrl": "https://explorer.mainnet.near.org"
  }
'''
'''--- src/networks/testnet.json ---
{
    "networkId": "testnet",
    "nodeUrl": "https://rpc.testnet.near.org",
    "archivalUrl": "https://archival-rpc.testnet.near.org",
    "walletUrl": "https://wallet.testnet.near.org",
    "helperUrl": "https://helper.testnet.near.org",
    "explorerUrl": "https://explorer.testnet.near.org"
  }
'''
'''--- src/routes/NEARRoutes.ts ---
import {getConfig} from '../config';
import * as nearAPI from 'near-api-js';
import { Account, Near, keyStores } from 'near-api-js';
import { parseContract } from 'near-contract-parser';
import { Request, Response, Router } from 'express';
import NEARRequest from '../models/NEARRequest';
//import { BrowserLocalStorageKeyStore } from 'near-api-js/lib/key_stores'
const { networkId, nodeUrl, walletUrl, helperUrl } = getConfig(process.env.NODE_ENV || 'testnet');

//testNEAR2();
const near = new Near({
    networkId: 'testnet',
    keyStore: new keyStores.InMemoryKeyStore(),
    nodeUrl,
    walletUrl,
    helperUrl,
    headers: {}
})

class NEARRoutes {
    router: Router;
    constructor() {
        this.router = Router();
        this.routes();
    }

    getMarketplacesClean(listNftMarketplacesRaw: string[]) : string[] {
        let listNftMarketplaces: string[] = [];
        listNftMarketplacesRaw.forEach(
            (marketplace: string) => {
                if (marketplace.includes("mintbase") || 
                marketplace.includes("paras") || 
                marketplace.includes("neatar")) {
                    listNftMarketplaces.push(marketplace);
                }
            }
        );
        return listNftMarketplaces;
    }

    async getMarketplacesNotEmpties(account: string, listNftMarketplacesRaw: string[]) : Promise<string[]> {
        let listNftMarketplaces: string[] = [];
        listNftMarketplacesRaw.forEach(
            async (marketplace: string) => {
                const supply = await this.getNftSupplyForOwnerPrivate(account, marketplace)
                    if (supply != "0") {
                        listNftMarketplaces.push(marketplace);
                    }
                }
        );
        return listNftMarketplaces;
    }

    async getNftMetadata(req: Request, res: Response): Promise<void> {
        let receivedAccount: string = "";
        let listReceivedContract: string[] = [];
        let listReceivedContractClean: string[] = [];
        let listReceivedContractNotEmpties: string[] = [];
        let listTokens: any[] = [];
        ({ receivedAccount, listReceivedContract } = req.body);
        console.log(listReceivedContract);
        listReceivedContractClean = this.getMarketplacesClean(listReceivedContract);
        listReceivedContractNotEmpties = await this.getMarketplacesNotEmpties(receivedAccount, listReceivedContract);

        // @ts-ignore
        const metadata = contract.nft_metadata({
            
        });
        res.json(metadata);
    }

    async getNftTotalSupply(req: Request, res: Response): Promise<void> {
        console.log(req.body);
        const { receivedAccount, receivedContract } = req.body;
        //console.log( await testNEAR2(receivedAccount, receivedContract));
        //res.json(receivedContract);
         const account = await near.account(receivedAccount);
         const contract: nearAPI.Contract = new nearAPI.Contract(
             account,
             receivedContract,
             {
                 viewMethods: ['nft_total_supply'],
                 changeMethods: []
             }
         );
         // @ts-ignore
         const totalSupply = await contract.nft_total_supply({});
         res.json(totalSupply);
    }

   async getNftTokensForOwner(req: Request, res: Response): Promise<void> {
        const { receivedAccount, receivedContract } = req.body;
        const account = await near.account(receivedAccount);
        const contract: nearAPI.Contract = new nearAPI.Contract(
            account,
            receivedContract,
            {
                viewMethods: ['nft_tokens_for_owner'],
                changeMethods: []
            }
        );
        // @ts-ignore
        const tokens = await contract.nft_tokens_for_owner({
            "account_id": receivedAccount,
            "from_index": "0",
            "limit": 100
        });
        res.json(tokens);
   }

   async getNftSupplyForOwner(req: Request, res: Response): Promise<void> {
        const { receivedAccount, receivedContract } = req.body;
        const account = await near.account(receivedAccount);
        const contract: nearAPI.Contract = new nearAPI.Contract(
            account,
            receivedContract,
            {
                viewMethods: ['nft_supply_for_owner'],
                changeMethods: []
            }
        );
        // @ts-ignore
        const supply = await contract.nft_supply_for_owner({
            "account_id": receivedAccount
        });
        res.json(supply);
   }

   private async getNftSupplyForOwnerPrivate(
        receivedAccount: string,
        receivedContract: string
   ): Promise<string> {
        const account = await near.account(receivedAccount);
        const contract: nearAPI.Contract = new nearAPI.Contract(
            account,
            receivedContract,
            {
                viewMethods: ['nft_supply_for_owner'],
                changeMethods: []
            }
        );
        // @ts-ignore
        const supply = await contract.nft_supply_for_owner({
            "account_id": receivedAccount
        });
        return supply;
   }

   async getAllNftsFromUser(req: Request, res: Response): Promise<void> {
       const { receivedAccount, receivedContract } = req.body;
   }

    routes() {
        this.router.get('/getSupply', this.getNftTotalSupply);
        this.router.post('/getSupply', this.getNftTotalSupply);
        this.router.get('/getTokens', this.getNftTokensForOwner);
        this.router.post('/getTokens', this.getNftTokensForOwner);
        this.router.get('/getSupplyForOwner', this.getNftSupplyForOwner);
        this.router.post('/getSupplyForOwner', this.getNftSupplyForOwner);
        this.router.get('/getMetadata', this.getNftMetadata);
        this.router.post('/getMetadata', this.getNftMetadata);
    }
}

const nearRoutes = new NEARRoutes();
export default nearRoutes.router;
'''
'''--- src/routes/PostRoutes.ts ---
import { Request, Response, Router } from 'express';
import Post from "../models/Post";

class PostRoutes {
    router: Router;
    constructor() {
        this.router = Router();
        this.routes();
    }

    async getPost(req: Request, res: Response): Promise<void> {
        //console.log(req.params.url);
        const post = await Post.findOne({url: req.params.url});
        res.json(post);
    }

    async getPosts(req: Request, res: Response): Promise<void> {
        const posts = await Post.find();
        res.json(posts);
    }

    async createPost(req: Request, res: Response): Promise<void> {
        //console.log(req.body);
        const { title, url, content, image } = req.body;
        const newPost = new Post({ title, url, content, image })/*.save((err, post) => {})*/;
        //console.log(newPost);
        await newPost.save(/*(err: any, post: any) => {
            if (err) return res.status(400).json({
                ok: false,
                err
            });
            res.json({
                ok: true,
                post
            });
        }*/);
        res.json({data : newPost});
    }

    async updatePost(req: Request, res: Response): Promise<void> {
        const { url } = req.params;
        //console.log(req.params.url);
        //console.log(req.body);
        const post = await Post.findOneAndUpdate({url}, req.body, {new: true});
        res.json(post);
    }

    async removePost(req: Request, res: Response): Promise<void> {
        const { url } = req.params;
        const post = await Post.findOneAndDelete({url});
        res.json(post);
    }

    routes() {
        this.router.get('/', this.getPosts);
        this.router.get('/:url', this.getPost);
        this.router.post('/', this.createPost);
        this.router.put('/:url', this.updatePost);
        this.router.delete('/:url', this.removePost);
    }
}

const postRoutes = new PostRoutes();
export default postRoutes.router;
'''
'''--- src/routes/UserRoutes.ts ---
import { Request, Response, Router } from 'express';
import User from "../models/User";

class UserRoutes {
    router: Router;
    constructor() {
        this.router = Router();
        this.routes();
    }

    async getUser(req: Request, res: Response): Promise<void> {
        //console.log(req.params.url);
        const user = await User.findOne({username: req.params.username}).populate('posts');
        res.json(user);
    }

    async getUsers(req: Request, res: Response): Promise<void> {
        const users = await User.find();
        res.json(users);
    }

    async createUser(req: Request, res: Response): Promise<void> {
        const newUser = new User( req.body )/*.save((err, post) => {})*/;
        //console.log(newPost);
        await newUser.save(/*(err: any, user: any) => {
            if (err) return res.status(400).json({
                ok: false,
                err
            });
            res.json({
                ok: true,
                user
            });
        }*/);
        res.json({data : newUser});
    }

    async updateUser(req: Request, res: Response): Promise<void> {
        const { username } = req.params;
        //console.log(req.params.url);
        //console.log(req.body);
        const user = await User.findOneAndUpdate({username}, req.body, {new: true});
        res.json(user);
    }

    async removeUser(req: Request, res: Response): Promise<void> {
        const { username } = req.params;
        const user = await User.findOneAndDelete({username});
        res.json(user);
    }

    routes() {
        this.router.get('/', this.getUsers);
        this.router.get('/:username', this.getUser);
        this.router.post('/', this.createUser);
        this.router.put('/:username', this.updateUser);
        this.router.delete('/:username', this.removeUser);
    }
}

const userRoutes = new UserRoutes();
export default userRoutes.router;
'''
'''--- src/routes/indexRoutes.ts ---
import { Request, Response, Router } from 'express';

class IndexRoutes {
    router: Router;
    constructor() {
        this.router = Router();
        this.routes();
    }

    routes() {
        this.router.get('/', (req, res) => res.send('Api: /api/posts'));
    }
}

const indexRoutes = new IndexRoutes();
indexRoutes.routes();

export default indexRoutes.router;
'''
'''--- src/server.ts ---
import express from 'express';
import morgan from 'morgan';
import mongoose from 'mongoose';
import compression from 'compression';
import cors from 'cors';
import PostRoutes from './routes/PostRoutes';
import UserRoutes from './routes/UserRoutes';
import indexRoutes from './routes/indexRoutes';
import helmet from 'helmet';
import NEARRoutes from './routes/NEARRoutes';
// async function connectNEAR() {
//     const near = await nearAPI.connect({
//         networkId, nodeUrl, walletUrl,
//     });
// }

    async function testNEAR() {
//    const methodOptions = {
//      viewMethods: ['nftTotalSupply'],
//      changeMethods: []
//    };
//    const contract = new nearAPI.Contract(
//     account,
//      'paras-token-v2.testnet',
//      methodOptions
//    );
    }

    async function connectDB() {
        const MONGO_URI = '';
        const db = await mongoose.connect(MONGO_URI || process.env.MONGODB_URI).then(db => console.log('DB connected', db.connection.db.databaseName)).catch(err => console.log(err));
    }

class Server {
    app: express.Application;

    constructor() {
    this.app = express();
    this.config();
    this.routes();
    }

    config() {
        connectDB();
        this.app.set('port', process.env.PORT || 3000);
        this.app.use(express.json());
        this.app.use(express.urlencoded({extended: false}));
        this.app.use(morgan('dev'));
        this.app.use(helmet());
        this.app.use(compression());
        this.app.use(cors());
    }

    routes() {
        this.app.use(indexRoutes);
        this.app.use('/api/posts', PostRoutes);
        this.app.use('/api/users', UserRoutes);
        this.app.use('/api/near', NEARRoutes);
    }

    start() {
        this.app.listen(this.app.get('port'), () => {
            console.log('Server on port', this.app.get('port'));
        });
    }

}

const server = new Server();
server.start();

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Enable incremental compilation */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./",                          /* Specify the folder for .tsbuildinfo incremental compilation files. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es6",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.` */
    // "reactNamespace": "",                             /* Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    "rootDir": "./src",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like `./node_modules/@types`. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "resolveJsonModule": true,                        /* Enable importing .json files */
    // "noResolve": true,                                /* Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with `allowJs`. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have `@internal` in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like `__extends` in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing `const enum` declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied `any` type.. */
    // "strictNullChecks": true,                         /* When type checking, take into account `null` and `undefined`. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for `bind`, `call`, and `apply` methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when `this` is given the type `any`. */
    // "useUnknownInCatchVariables": true,               /* Type catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when a local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Include 'undefined' in index signature results */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  }
}

'''