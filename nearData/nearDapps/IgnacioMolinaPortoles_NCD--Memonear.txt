*GitHub Repository "IgnacioMolinaPortoles/NCD--Memonear"*

'''--- README.md ---
# NCD Project Memonear 

ðŸŽ¬ [Loom demo](https://www.loom.com/share/6f72b278a5fa4dbe8ba460a530bb06a7)

ðŸŽ¨ [Figma design](https://www.figma.com/file/CysKjUzYeDr2qUTBw5UohU/Memonear?node-id=0%3A1)

## Install dependencies
```
yarn
```

## Build and Deploy the contract
```
yarn build

near dev-deploy ./build/debug/singleton.wasm

# Save the contract dev name (<dev-123-456>)
```

## Guide

1. You need to create a new game with `createGame` function and send 1 near tokens
2. Player can start playing by checking different combinations, sending the position (x, y) to `checkCombination` of the 2 items to match. To add some difficulty to the game, when 2 items don't match, it won't tell you what items they are.
5. The player need to match all 6 items to win
4. The player can view the board at any moment by using `printBoard(gameId)` 
6. If some player doesn't want to play anymore, the owner can call `mockGame` and finish the game
7. When 6 items are matched, the attached deposit when the game was created will be transferred to the wallet of the winner if the player completes the game in less than 8 plays, otherwise it will receive 0.5 near tokens.

## Run the game
**Create a game**
```
# Save the game id to play

near call <dev-123-456> createGame --account_id <account-id> --amount 1
```

**View board for the first time**
```
near call <dev-123-456> printBoard '{"gameId": <game-id>}' --account_id <account-id>
```

**Start matching items**
```
near call <dev-123-456> checkCombination '{"gameId": <game-id>, "x1": <x-first-item>, "y1":<y-first-item>, "x2":<x-second-item>, "y2":<y-second-item>}' --accountId <account-id>
```

## Owner functions

**Get game info (playerId, Game state, Game deposit, Game board, Match count and User tries)**
```
near call <dev-123-456> getGameInfo '{"gameId": <game-id>}' --account_id <account-id>
```
**Hardcode game board to have only 2 items left to match**
```
near call <dev-123-456> mockGame '{"gameId": <game-id>, "userPlays": <amount-of-tries>}' --account_id <account-id>
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/singleton"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo",
    "jest": "yarn build && jest test"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/singleton/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/singleton/__tests__/index.unit.spec.ts ---
import { context, logging, u128, VMContext } from "near-sdk-as";
import { ONE_NEAR } from "../../utils";
import { Contract } from "../assembly";
import { State } from "../assembly/models";

let contract: Contract;

beforeEach(() => {
  contract = new Contract(context.sender);
});

describe("Memonear contract test", () => {
  // VIEW method tests

  it("Contract created correctly", () => {
    expect(contract).not.toBeNull();
  });

  it("Owner should the user who created the contract", () => {
    expect(contract.contractStatus()).toStrictEqual(`Owner: ${context.sender}`);
  });

  it("Mock function should be only calleable by owner", () => {
    VMContext.setAttached_deposit(ONE_NEAR);

    expect(() => {
      let gameId = contract.createGame();
      VMContext.setSigner_account_id("selvatico.testnet");
      contract.mockGame(gameId, 7);
    }).toThrow();
  });

  it("Creating a game sending 1 $NEAR", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    expect<u32>(contract.createGame()).toBeGreaterThan(0);
  });

  it("When a game is created, the state should be in progress", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    let data = contract.getGameInfo(gameId);
    expect<State>(data.gameState).toBe(State.InProgress);
  });

  it("When a game is created, it should have 0 plays", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    let data = contract.getGameInfo(gameId);
    expect<u32>(data.userPlays).toBe(0);
  });

  it("Board should have 6 unique items", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    let board = contract.showBoard(gameId);
    let items: Array<string> = [];

    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[i].length; j++) {
        if (!items.includes(board[i][j])) {
          items.push(board[i][j]);
        }
      }
    }

    expect(items).toHaveLength(6);
  });

  it("Should return its a match correctly", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    let board = contract.showBoard(gameId);
    let firstItem = board[0][0];

    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[i].length; j++) {
        if (firstItem === board[i][j]) {
          let res = contract.checkCombination(gameId, 0, 0, i, j);
          expect(res).toStrictEqual("Its a match");
        }
      }
    }
  });

  it("Play should increase the play count", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    contract.checkCombination(gameId, 0, 0, 1, 1);

    let gameInfo = contract.getGameInfo(gameId);
    expect(gameInfo.userPlays).toBe(1);
  });

  it("If its a match, match count should increase", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    let board = contract.showBoard(gameId);
    let firstItem = board[0][0];

    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[i].length; j++) {
        if (firstItem === board[i][j]) {
          contract.checkCombination(gameId, 0, 0, i, j);
          let gameInfo = contract.getGameInfo(gameId);
          expect(gameInfo.matchCount).toBe(1);
        }
      }
    }
  });

  it("When 2 items are matched, items should become winned.png", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    let board = contract.showBoard(gameId);
    let firstItem = board[0][0];

    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[i].length; j++) {
        if (firstItem === board[i][j]) {
          contract.checkCombination(gameId, 0, 0, i, j);
          let newBoard = contract.showBoard(gameId);

          expect(newBoard[0][0]).toStrictEqual("winned.png");
          expect(newBoard[i][j]).toStrictEqual("winned.png");
        }
      }
    }
  });

  it("When match all items and play count is under 8, game should be finished and player receive 1 $NEAR", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    contract.mockGame(gameId, 7);

    let res = contract.checkCombination(gameId, 0, 0, 0, 1);
    expect(res).toBe(`Player ${context.sender} won! and has received ${ONE_NEAR} tokens!`);
  });

  it("When match all items and play count is over 8, game should be finished and player receive 0.5 $NEAR", () => {
    VMContext.setAttached_deposit(ONE_NEAR);
    let gameId = contract.createGame();
    contract.mockGame(gameId, 8);

    let res = contract.checkCombination(gameId, 0, 0, 0, 1);
    const HALF_NEAR = u128.from("500000000000000000000000");
    expect(res).toBe(`Player ${context.sender} won! and has received ${HALF_NEAR} tokens!`);
  });
});

'''
'''--- src/singleton/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/singleton/assembly/index.ts ---
import { games, Memonear, State } from "./models";
import { context, ContractPromiseBatch, logging, u128 } from "near-sdk-as";
import { ONE_NEAR } from "../../utils";

@nearBindgen
export class Contract {
  private owner: string = "";

  constructor(owner: string) {
    this.owner = owner
  }

  @mutateState()
  setOwner(owner: string): string {
    assert(this.owner.length === 0, "Owner already setup")
    this.owner = owner
    return `Owner set to ${owner} succesfully!`
  }

  @mutateState()
  changeOwner(newOwner: string): string {
    assert(context.sender != this.owner, "Only owner can change owner")
    this.owner = newOwner
    return `New owner is ${newOwner}`
  }

  contractStatus(): string {
    return `Owner: ${this.owner}`;
  }

  createGame(): u32 {
    assert(
      context.attachedDeposit == ONE_NEAR,
      "You need to send only 1 near token"
    );
    const game = new Memonear();
    games.set(game.gameId, game);
    game.gameDeposit = context.attachedDeposit;

    return game.gameId;
  }

  getGameInfo(gameId: u32): Memonear {
    assert(context.sender == this.owner, "Only owner can call this function");
    let game = games.getSome(gameId);
    return game;
  }

  showBoard(gameId: u32): Array<string[]> {
    assert(context.sender == this.owner, "Only owner can call this function");
    let game = games.getSome(gameId);
    return game.gameBoard;
  }

  checkCombination(gameId: u32, x1: u32, y1: u32, x2: u32, y2: u32): string {
    let game = games.getSome(gameId);

    let firstItem: string = game.gameBoard[x1][y1];
    let secondItem: string = game.gameBoard[x2][y2];
    game.userPlays += 1;

    if (firstItem == secondItem) {
      game.matchCount += 1;
      game.gameBoard[x1][y1] = "winned.png";
      game.gameBoard[x2][y2] = "winned.png";

      if (game.matchCount == 6) {
        return this.endGame(game, game.userPlays <= 8);
      }

      games.set(gameId, game);
      return "Its a match";
    }
    games.set(gameId, game);

    return "Sorry, try again";
  }

  mockGame(gameId: u32, userPlays: u32): void {
    assert(context.sender == this.owner, "Only owner can call this function");
    let game = games.getSome(gameId);

    game.gameBoard = [
      ["slime_pink.png", "slime_pink.png", "winned.png", "winned.png"],
      ["winned.png", "winned.png", "winned.png", "winned.png"],
      ["winned.png", "winned.png", "winned.png", "winned.png"],
    ];

    game.matchCount = 5;
    game.userPlays = userPlays;

    games.set(gameId, game);
  }

  endGame(game: Memonear, returnAll: bool): string {
    game.gameState = State.Finished;
    const payablePromise = ContractPromiseBatch.create(game.player);
    let winnerTokens: u128 = game.gameDeposit;

    if (!returnAll) {
      winnerTokens = u128.div(game.gameDeposit, u128.from("2"));
    }

    payablePromise.transfer(winnerTokens);

    games.set(game.gameId, game);
    return `Player ${game.player} won! and has received ${winnerTokens} tokens!`;
  }

  printBoard(gameId: u32): string {
    let game = games.getSome(gameId);

    var parsedBoard = "";

    for (let i = 0; i < game.gameBoard.length; i++) {
      for (let j = 0; j < game.gameBoard[i].length; j++) {
        if (game.gameBoard[i][j] == "winned.png") {
          parsedBoard = parsedBoard.concat(game.gameBoard[i][j] + " | ");
        } else {
          parsedBoard = parsedBoard.concat("hidden.png | ");
        }
        
      }
      parsedBoard = parsedBoard.concat("\n");

    }

    return parsedBoard;
  }
}

'''
'''--- src/singleton/assembly/models.ts ---
import { PersistentVector, RNG, context, PersistentMap, u128 } from "near-sdk-as";

export enum State {
  InProgress,
  Finished,
}

@nearBindgen
export class Memonear {
  gameId: u32;
  player: string
  gameState: State;
  gameDeposit: u128;
  gameBoard: Array<string[]>;
  matchCount: u32
  userPlays: u32

  constructor() {
    let rng = new RNG<u32>(1, u32.MAX_VALUE);
    let roll = rng.next();
    this.gameId = roll;
    this.gameBoard = new Array<string[]>(3);

    this.gameState = State.InProgress;
    this.gameDeposit = context.attachedDeposit;
    this.player = context.sender
    this.matchCount = 0
    this.userPlays = 0

    let gamesItems: Array<string> = [
      "slime_pink.png",
      "slime_fire.png",
      "slime_cat.png",
      "slime_gold.png",
      "slime_rainbow.png",
      "slime_plant.png",
      "slime_pink.png",
      "slime_fire.png",
      "slime_cat.png",
      "slime_gold.png",
      "slime_rainbow.png",
      "slime_plant.png",
    ];

    for (let i = 0; i < 3; i++) {
      this.gameBoard[i] = new Array<string>(4);
      for (let j = 0; j < 4; j++) {
        let rng = new RNG<u32>(1, gamesItems.length);
        let index = rng.next();

        this.gameBoard[i][j] = gamesItems[index];
        gamesItems.splice(index, 1);
      }
    }
  }
}

export const games = new PersistentMap<u32, Memonear>("g");

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts", "test.js"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto â“ƒ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto â“ƒ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto â“ƒ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''