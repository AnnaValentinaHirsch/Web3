*GitHub Repository "phamthainb/spk-stream"*

'''--- README.md ---
# SPK-STREAM

# Smart Contract
## Require

➜ rustc --V  
rustc 1.65.0 (897e37553 2022-11-02) or higher

➜ cargo --version  
cargo 1.65.0 (4bc8f24d3 2022-10-20) or higher

## Build

➜ cargo build --target wasm32-unknown-unknown --release

➜ near dev-deploy ./target/wasm32-unknown-unknown/release/\*\*\*.wasm

# BackEnd
'''
'''--- docs/deploy.md ---
➜  token git:(main) near dev-deploy ./target/wasm32-unknown-unknown/release/fungible_token.wasm
Starting deployment. Account id: token.spk-stream.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: ./target/wasm32-unknown-unknown/release/fungible_token.wasm
Transaction Id 6pEHE8CzL3fVRPFgFVdLcy4AeEyqNYS5SKTJuXK3AdJz
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/6pEHE8CzL3fVRPFgFVdLcy4AeEyqNYS5SKTJuXK3AdJz
Done deploying to token.spk-stream.testnet

➜  stake git:(main) ✗ near dev-deploy ./target/wasm32-unknown-unknown/release/spk_stake.wasm 
Starting deployment. Account id: stake.spk-stream.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: ./target/wasm32-unknown-unknown/release/spk_stake.wasm
Transaction Id FG5r5i3kgACAnRtXZ1wnXUmE3AMkRFH9kbshQ92mzTcQ
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/FG5r5i3kgACAnRtXZ1wnXUmE3AMkRFH9kbshQ92mzTcQ
Done deploying to stake.spk-stream.testnet

➜  app git:(main) ✗ near dev-deploy ./target/wasm32-unknown-unknown/release/spk_app.wasm 
Starting deployment. Account id: app.spk-stream.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: ./target/wasm32-unknown-unknown/release/spk_app.wasm
Transaction Id AcZH2w9LkBELJCdeASnSUXk5v9ybMcgXzuCDsycT81s4
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/AcZH2w9LkBELJCdeASnSUXk5v9ybMcgXzuCDsycT81s4
Done deploying to app.spk-stream.testnet
'''
'''--- docs/note (3) copy.txt ---
learner: tungleanh.testnet 
advisor: dev-1669018198583-29903555965521

cargo build --target wasm32-unknown-unknown --release

near dev-deploy ./target/wasm32-unknown-unknown/release/fungible_token.wasm

token contract: token.spk-stream.testnet
near call token.spk-stream.testnet new_default_meta '{"total_supply": "100000000000000000000000000000"}' --accountId token.spk-stream.testnet

stake contract: stake.spk-stream.testnet
near call stake.spk-stream.testnet new '{"_token_address": "token.spk-stream.testnet"}' --accountId stake.spk-stream.testnet

near call token.spk-stream.testnet storage_deposit --accountId dev-1669018198583-29903555965521 --depositYocto 1000000000000000000000000

near call token.spk-stream.testnet ft_transfer '{"receiver_id": "tungleanh.testnet","amount": "100000000000000000000000", "memo": "None" }' --accountId token.spk-stream.testnet --depositYocto 1

stake
near call token.spk-stream.testnet ft_transfer_call '{"receiver_id": "stake.spk-stream.testnet", "amount": "10000000", "memo": "None", "msg": "None"}' --accountId dev-1669018198583-29903555965521 --depositYocto 1 --gas=75000000000000

near call dev-1668735602026-81766650624861 unstake_token '{"_amount": "10000000"}' --accountId tungleanh.testnet --depositYocto 1

near view stake.spk-stream.testnet get_staked_amount '{"_advisor_id": "tungleanh.testnet"}'

near view token.spk-stream.testnet ft_balance_of '{"account_id": "tungleanh.testnet"}'

Version nead signature
app contract: dev-1669022432132-58804567266197 (branch main)
near call dev-1669022432132-58804567266197 new '{"_verified_amount": "1", "_token_address": "token.spk-stream.testnet", "_staking_address": "stake.spk-stream.testnet"}' --accountId dev-1669022432132-58804567266197

Version not need signature
app contract: dev-1669349830892-52864076530996 (branch dev)
near call dev-1669349830892-52864076530996 new '{"_verified_amount": "1", "_token_address": "token.spk-stream.testnet", "_staking_address": "stake.spk-stream.testnet"}' --accountId dev-1669349830892-52864076530996

'''
'''--- docs/note (3).txt ---
learner: tungleanh.testnet 
advisor: dev-1669018198583-29903555965521

cargo build --target wasm32-unknown-unknown --release

near dev-deploy ./target/wasm32-unknown-unknown/release/fungible_token.wasm

token contract: dev-1669021473407-34726394271280
near call dev-1669021473407-34726394271280 new_default_meta '{"total_supply": "100000000000000000000000000000"}' --accountId dev-1669021473407-34726394271280

stake contract: dev-1669021948335-14262252549691
near call dev-1669021948335-14262252549691 new '{"_token_address": "dev-1669021473407-34726394271280"}' --accountId dev-1669021948335-14262252549691

near call dev-1669021473407-34726394271280 storage_deposit --accountId dev-1669018198583-29903555965521 --depositYocto 1000000000000000000000000

near call dev-1669021473407-34726394271280 ft_transfer '{"receiver_id": "tungleanh.testnet","amount": "100000000000000000000000", "memo": "None" }' --accountId dev-1669021473407-34726394271280 --depositYocto 1

stake
near call dev-1669021473407-34726394271280 ft_transfer_call '{"receiver_id": "dev-1669021948335-14262252549691", "amount": "10000000", "memo": "None", "msg": "None"}' --accountId dev-1669018198583-29903555965521 --depositYocto 1 --gas=75000000000000

near call dev-1668735602026-81766650624861 unstake_token '{"_amount": "10000000"}' --accountId tungleanh.testnet --depositYocto 1

near view dev-1669021948335-14262252549691 get_staked_amount '{"_advisor_id": "tungleanh.testnet"}'

near view dev-1669021473407-34726394271280 ft_balance_of '{"account_id": "tungleanh.testnet"}'

Version nead signature
app contract: dev-1669022432132-58804567266197 (branch main)
near call dev-1669022432132-58804567266197 new '{"_verified_amount": "1", "_token_address": "dev-1669021473407-34726394271280", "_staking_address": "dev-1669021948335-14262252549691"}' --accountId dev-1669022432132-58804567266197

Version not need signature
app contract: dev-1669349830892-52864076530996 (branch dev)
near call dev-1669349830892-52864076530996 new '{"_verified_amount": "1", "_token_address": "dev-1669021473407-34726394271280", "_staking_address": "dev-1669021948335-14262252549691"}' --accountId dev-1669349830892-52864076530996

'''
'''--- docs/note.md ---
learner: tungleanh.testnet 
advisor: dev-1669018198583-29903555965521

token.spk-stream.testnet
app.spk-stream.testnet
stake.spk-stream.testnet

cargo build --target wasm32-unknown-unknown --release

near dev-deploy ./target/wasm32-unknown-unknown/release/fungible_token.wasm

->>>>>>>> token
token contract: dev-1669021473407-34726394271280
near call dev-1669021473407-34726394271280 new_default_meta '{"total_supply": "100000000000000000000000000000"}' --accountId dev-1669021473407-34726394271280

->>>>>>>> stake
stake contract: dev-1669021948335-14262252549691
near call dev-1669021948335-14262252549691 new '{"_token_address": "dev-1669021473407-34726394271280"}' --accountId dev-1669021948335-14262252549691

near call dev-1669021473407-34726394271280 storage_deposit --accountId dev-1669018198583-29903555965521 --depositYocto 1000000000000000000000000

near call dev-1669021473407-34726394271280 ft_transfer '{"receiver_id": "tungleanh.testnet","amount": "100000000000000000000000", "memo": "None" }' --accountId dev-1669021473407-34726394271280 --depositYocto 1

near call dev-1669021473407-34726394271280 ft_transfer_call '{"receiver_id": "dev-1669021948335-14262252549691", "amount": "10000000", "memo": "None", "msg": "None"}' --accountId dev-1669018198583-29903555965521 --depositYocto 1 --gas=75000000000000

near call dev-1668735602026-81766650624861 unstake_token '{"_amount": "10000000"}' --accountId tungleanh.testnet --depositYocto 1

near view dev-1669021948335-14262252549691 get_staked_amount '{"_advisor_id": "tungleanh.testnet"}'

near view dev-1669021473407-34726394271280 ft_balance_of '{"account_id": "tungleanh.testnet"}'

>>>>>>>>> appp
Version nead signature
app contract: dev-1669022432132-58804567266197 (branch main)
near call dev-1669022432132-58804567266197 new '{"_verified_amount": "1", "_token_address": "dev-1669021473407-34726394271280", "_staking_address": "dev-1669021948335-14262252549691"}' --accountId dev-1669022432132-58804567266197

Version not need signature
app contract: dev-1669349830892-52864076530996 (branch dev)
near call dev-1669349830892-52864076530996 new '{"_verified_amount": "1", "_token_address": "dev-1669021473407-34726394271280", "_staking_address": "dev-1669021948335-14262252549691"}' --accountId dev-1669349830892-52864076530996

-- 
sc:
- token.spk-stream.testnet
- app.spk-stream.testnet
- stake.spk-stream.testnet
---

- ft token
near call token.spk-stream.testnet ft_transfer '{"receiver_id": "phamthainb.testnet","amount":"10000000000000000000000000", "memo": "None" }' --account_id token.spk-stream.testnet --depositYocto 1

- get balance via $token
near view token.spk-stream.testnet ft_balance_of '{"account_id": "phamthainb.testnet"}'

- staking
near call token.spk-stream.testnet ft_transfer_call '{"receiver_id": "stake.spk-stream.testnet", "amount": "10000000", "memo": "None", "msg": "None"}' --accountId phamthainb.testnet --depositYocto 1 --gas=75000000000000

- view amount stake
near view stake.spk-stream.testnet get_staked_amount '{"_advisor_id": "phamthainb.testnet"}'

- unstake
near call stake.spk-stream.testnet unstake_token '{"_amount": "100000"}' --accountId phamthainb.testnet --depositYocto 1

'''
'''--- smart-contract-v1/app/Cargo.toml ---
[package]
name = "spk-app"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
ed25519-dalek = "1.0.1"
near-sdk = "4.1.1"
serde_json = "1.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- smart-contract-v1/app/neardev/dev-account.env ---
CONTRACT_NAME=app.spk-stream.testnet
'''
'''--- smart-contract-v1/app/src/external.rs ---
use near_sdk::{AccountId, ext_contract};

#[ext_contract(this_contract)]
trait Callbacks {
    fn query_staked_amount_callback(&mut self) -> u128;
}

#[ext_contract(ext_stake_contract)]
trait StakeContract {
    fn get_staked_amount(&self, _advisor_id: AccountId);
    fn update_apr(&self, _advisor_id: AccountId, _learner_vote: u8);
}
'''
'''--- smart-contract-v1/app/src/lib.rs ---
use ed25519_dalek::Verifier;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, bs58, env, ext_contract, near_bindgen, require, AccountId, Balance,
    BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseError, PromiseOrValue, ONE_YOCTO,
};
use std::ops::{Mul, Sub};
use std::time::SystemTime;

pub mod external;
pub use crate::external::*;

pub const TGAS: u64 = 1_000_000_000_000;
pub const FT_TRANSFER_GAS: Gas = Gas(10_000_000_000_000);
pub const WITHDRAW_CALLBACK_GAS: Gas = Gas(10_000_000_000_000);
pub const FAUCET_CALLBACK_GAS: Gas = Gas(10_000_000_000_000);

#[ext_contract(ext_ft_contract)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct RoomCreatedLog {
    advisor: AccountId,
    learner: AccountId,
    room_id: u128,
    start_time: i64,
    amount_per_minute: Balance,
    minutes_last: i64,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct RoomExtendedLog {
    advisor: AccountId,
    learner: AccountId,
    room_id: u128,
    amount_per_minute: Balance,
    minutes_last: i64,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ClaimedTokenLog {
    amount: Balance,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PartialEq, Clone)]
pub struct Room {
    advisor: AccountId,
    learner: AccountId,
    start_time: i64,
    amount_per_minute: Balance,
    minutes_last: i64,
    pending_amount: u128,
    claimed: bool,
    reverted: bool,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner: AccountId,
    pub staking_address: AccountId,
    pub token_address: AccountId,
    pub verified_amount: Balance,
    pub room_list: LookupMap<u128, Room>,
}

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    RoomIDKey,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        _verified_amount: U128,
        _token_address: AccountId,
        _staking_address: AccountId,
    ) -> Self {
        Contract {
            owner: env::signer_account_id(),
            staking_address: _staking_address,
            token_address: _token_address,
            verified_amount: u128::from(_verified_amount),
            room_list: LookupMap::new(StorageKey::RoomIDKey),
        }
    }

    // call ft_transfer_call on token contract to do create_room/extend_meeting fn called by token contract
    pub fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
        _advisor: Option<AccountId>,
        _amount_per_minute: Option<U128>,
        _room_id: Option<U128>,
        _minutes_lasts: Option<i64>,
        _signature: Option<Vec<u8>>,
        _signer: Option<Vec<u8>>,
    ) -> PromiseOrValue<U128> {
        let _amount_per_minute = u128::from(_amount_per_minute.unwrap());
        let _room_id = u128::from(_room_id.unwrap());
        require!(
            Self::verify(
                &self,
                _signature.unwrap(),
                _signer.unwrap(),
                _advisor.clone().unwrap()
            ) == true,
            "There was an error verifying advisor's signature"
        );

        if msg == "create_room" {
            Self::query_staked_amount(&self, _advisor.clone().unwrap());

            let _pending_amount = _amount_per_minute.mul(_minutes_lasts.unwrap() as u128);

            let room = Room {
                advisor: _advisor.unwrap(),
                learner: sender_id,
                start_time: Self::now(),
                amount_per_minute: _amount_per_minute,
                minutes_last: _minutes_lasts.unwrap(),
                pending_amount: _pending_amount,
                claimed: false,
                reverted: false,
            };

            self.room_list.insert(&_room_id, &room);
        } else if msg == "extend_room" {
            let mut room = self.room_list.get(&_room_id).unwrap();
            require!(
                self.room_list.contains_key(&_room_id) == true,
                "App: Room not existed!"
            );
            require!(sender_id == room.learner, "App: Invalid learner!");
            room.minutes_last += _minutes_lasts.unwrap();
            room.pending_amount += _amount_per_minute.mul(_minutes_lasts.unwrap() as u128);

            self.room_list.insert(&_room_id, &room);
        }

        return PromiseOrValue::Value(U128(0));
    }

    // advisor sign
    #[payable]
    pub fn end_room(
        &mut self,
        _room_id: U128,
        _learner_vote: u8,
        _signature: Vec<u8>,
        _signer: Vec<u8>,
    ) {
        assert_one_yocto();
        let _room_id = u128::from(_room_id);
        require!(
            self.room_list.contains_key(&_room_id) == true,
            "App: Room not existed!"
        );
        let mut room = self.room_list.get(&_room_id).unwrap();
        require!(
            Self::verify(&self, _signature, _signer, room.advisor.clone()) == true,
            "There was an error verifying advisor's signature"
        );

        require!(room.claimed == false, "App: Already claimed!");
        require!(room.reverted == false, "App: Already reverted!");

        // let minutes_last = Utc::now().timestamp().sub(room.start_time);
        // require!(
        //     minutes_last >= room.minutes_last,
        //     "App: Too early to reveive token!"
        // );

        ext_stake_contract::ext(self.token_address.clone())
            .with_static_gas(FT_TRANSFER_GAS)
            .update_apr(env::signer_account_id(), _learner_vote);

        ext_ft_contract::ext(self.token_address.clone())
            .with_static_gas(FT_TRANSFER_GAS)
            .ft_transfer(
                room.advisor.clone(),
                U128::from(room.pending_amount * 95 / 100),
                None,
            );

        room.claimed = true;
        self.room_list.insert(&_room_id, &room);
    }

    // advisor leave meeting at least 10 minutes then leaner can revert their tokens
    // fe check time advisor leave. If time > 10 minutes, fe will allow learner do this function and create a signature for this fn
    // admin sign
    #[payable]
    pub fn revert_token(&mut self, _room_id: U128, _signature: Vec<u8>, _signer: Vec<u8>) {
        assert_one_yocto();
        let _room_id = u128::from(_room_id);
        require!(
            Self::verify(&self, _signature, _signer, self.owner.clone()) == true,
            "There was an error verifying admin's signature"
        );

        require!(
            self.room_list.contains_key(&_room_id) == true,
            "App: Room not existed!"
        );
        let mut room = self.room_list.get(&_room_id).unwrap();

        require!(
            Self::now().sub(room.start_time) < room.minutes_last,
            "App: Room already ended!"
        );

        ext_ft_contract::ext(self.token_address.clone())
            .with_static_gas(FT_TRANSFER_GAS)
            .ft_transfer(
                room.learner.clone(),
                U128::from(room.amount_per_minute.mul(room.minutes_last as u128) * 95 / 100),
                None,
            );

        room.reverted = true;
        self.room_list.insert(&_room_id, &room);
    }

    #[private]
    pub fn query_staked_amount(&self, _advisor_id: AccountId) -> Promise {
        let promise = ext_stake_contract::ext(self.token_address.clone())
            .with_static_gas(Gas(5 * TGAS))
            .get_staked_amount(_advisor_id);

        return promise.then(
            // Create a promise to callback query_staked_amount
            Self::ext(env::current_account_id())
                .with_static_gas(Gas(5 * TGAS))
                .query_staked_amount_callback(),
        );
    }

    #[private]
    pub fn query_staked_amount_callback(
        &self,
        #[callback_result] call_result: Result<u128, PromiseError>,
    ) -> u128 {
        // Check if the promise succeeded by calling the method outlined in external.rs
        if call_result.is_err() {
            require!(1 != 1, "There was an error contacting staking contract");
        }

        // Return the amount
        let amount = call_result.unwrap();
        require!(amount >= self.verified_amount, "App: Not an advisor!");
        amount
    }

    #[private]
    pub fn verify(
        &self,
        _signature: Vec<u8>,
        _signer_public_key: Vec<u8>,
        _account_id: AccountId,
    ) -> bool {
        // https://stackoverflow.com/questions/70041130/how-to-verify-secp256k1-signed-message-in-smart-contract
        // verify signature of app creator
        let signature = ed25519_dalek::Signature::try_from(_signature.as_ref())
            .expect("Signature should be a valid array of 64 bytes [13, 254, 123, ...]");
        let public_key = ed25519_dalek::PublicKey::from_bytes(
            &bs58::decode(
                // public key "H5ANpdUoXVwhYBgAgEi1ieMQZKJbwxjPJtHX4vkVcSnF",
                _signer_public_key,
            )
            .into_vec()
            .unwrap(),
        )
        .unwrap();
        if let Ok(_) = public_key.verify(_account_id.as_bytes(), &signature) {
            return true;
        } else {
            return false;
        }
    }

    #[private]
    pub fn now() -> i64 {
        return SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;
    }
}

'''
'''--- smart-contract-v1/stake/Cargo.toml ---
[package]
name = "spk-stake"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
serde_json = "1.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- smart-contract-v1/stake/neardev/dev-account.env ---
CONTRACT_NAME=stake.spk-stream.testnet
'''
'''--- smart-contract-v1/stake/src/external.rs ---
use near_sdk::json_types::U128;
use near_sdk::{ext_contract, AccountId};

#[ext_contract(ext_ft_contract)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

'''
'''--- smart-contract-v1/stake/src/lib.rs ---
use std::ops::Sub;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::{
    assert_one_yocto, env, near_bindgen, require, AccountId, BorshStorageKey, Gas, PanicOnDefault,
    ONE_NEAR, ONE_YOCTO, PromiseOrValue,
};

pub const FT_TRANSFER_GAS: Gas = Gas(10_000_000_000_000);
pub const WITHDRAW_CALLBACK_GAS: Gas = Gas(10_000_000_000_000);
pub const FAUCET_CALLBACK_GAS: Gas = Gas(10_000_000_000_000);

pub const POINT_ONE_TOKEN: u128 = 100_000_000_000_000_000_000_000; // 0.1 to 24 decimal
pub const DEFAULT_APR: u128 = 5_000_000_000_000_000_000_000_000; // 5%

pub mod external;
pub use crate::external::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakeInfo {
    time_staked: i64,
    amount_staked: u128,
    reward: u128,
    apr: u128,
    votes: u8,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub token_address: AccountId,
    pub total_stakers: u128,
    pub total_staked: u128,
    pub stake_info: LookupMap<AccountId, StakeInfo>,
}

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    StakeInfoKey,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(_token_address: AccountId) -> Self {
        Contract {
            token_address: _token_address,
            total_stakers: 0,
            total_staked: 0,
            stake_info: LookupMap::new(StorageKey::StakeInfoKey),
        }
    }

    // call ft_transfer_call on token contract to do stake_token fn called by token contract
    pub fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let _stake_amount = u128::from(amount);
        let _account_id = sender_id;
        require!(_stake_amount > 0, "Stake: Invalid amount!");

        let info = self.stake_info.get(&_account_id);
        match info {
            Some(mut unwrap_info) => {
                unwrap_info.time_staked = Self::now();
                unwrap_info.amount_staked += _stake_amount;
                unwrap_info.reward += Self::pending_reward(&self, _account_id.clone());

                self.stake_info.insert(&_account_id, &unwrap_info);
            }
            None => {
                let stake_info = StakeInfo {
                    time_staked: Self::now(),
                    amount_staked: _stake_amount,
                    reward: 0,
                    apr: DEFAULT_APR,
                    votes: 0,
                };
                self.stake_info.insert(&_account_id, &stake_info);
                self.total_stakers += 1;
            }
        }
        self.total_staked += _stake_amount;

        return PromiseOrValue::Value(near_sdk::json_types::U128(0));
    }

    #[payable]
    pub fn unstake_token(&mut self, _amount: U128) {
        assert_one_yocto();
        let _amount = u128::from(_amount);
        let _account_id = env::signer_account_id();
        require!(
            self.stake_info.contains_key(&_account_id) == true,
            "Stake: You didn't stake any tokens!"
        );
        let mut stake_info = self.stake_info.get(&_account_id).unwrap();
        require!(
            stake_info.amount_staked > 0,
            "Stake: You staked less token than amount"
        );
        require!(_amount > 0, "Stake: Invalid amount");

        ext_ft_contract::ext(self.token_address.clone())
            .with_static_gas(FT_TRANSFER_GAS)
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer(env::signer_account_id(), U128::from(_amount), None);

        stake_info.amount_staked -= _amount;
        stake_info.time_staked = Self::now();
        stake_info.reward += Self::pending_reward(&self, _account_id.clone());

        self.total_staked -= _amount;

        self.stake_info.insert(&_account_id, &stake_info);
    }

    #[payable]
    pub fn claim_reward(&mut self) {
        assert_one_yocto();
        let _account_id = env::signer_account_id();
        require!(
            self.stake_info.contains_key(&_account_id) == true,
            "Stake: You didn't stake any tokens!"
        );
        let mut stake_info = self.stake_info.get(&_account_id).unwrap();

        let reward = Self::pending_reward(&self, _account_id.clone());
        require!(reward > 0, "Stake: You have no reward yet!");

        ext_ft_contract::ext(self.token_address.clone())
            .with_static_gas(FT_TRANSFER_GAS)
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer(env::signer_account_id(), U128::from(reward), None);

        stake_info.time_staked = Self::now();
        stake_info.reward = 0;

        self.stake_info.insert(&_account_id, &stake_info);
    }

    pub fn pending_reward(&self, _account_id: AccountId) -> u128 {
        require!(
            self.stake_info.contains_key(&_account_id) == true,
            "Stake: You didn't stake any tokens!"
        );
        let stake_info = self.stake_info.get(&_account_id).unwrap();

        let time_last = Self::now().sub(stake_info.time_staked);
        let pending_reward = (stake_info.amount_staked * (time_last as u128) / (31536000 * 100))
            * stake_info.apr
            / ONE_NEAR;
        return pending_reward + stake_info.reward;
    }

    pub fn get_staked_amount(&self, _advisor_id: AccountId) -> u128 {
        require!(
            self.stake_info.contains_key(&_advisor_id) == true,
            "Stake: Advisor not stake any tokens!"
        );
        return self.stake_info.get(&_advisor_id).unwrap().amount_staked;
    }

    pub fn update_apr(&mut self, _advisor_id: AccountId, _learner_vote: u8) {
        require!(
            self.stake_info.contains_key(&_advisor_id) == true,
            "Stake: Advisor not stake any tokens!"
        );
        let mut stake_info = self.stake_info.get(&_advisor_id).unwrap();
        stake_info.reward = Self::pending_reward(&self, _advisor_id.clone());
        stake_info.time_staked = Self::now();
        match _learner_vote {
            1_u8 => {
                stake_info.apr -= POINT_ONE_TOKEN * 2;
                stake_info.votes -= 2;
            }
            2_u8 => {
                stake_info.apr -= POINT_ONE_TOKEN;
                stake_info.votes -= 1;
            }
            3_u8 => {
                // do nothing
            }
            4_u8 => {
                stake_info.apr += POINT_ONE_TOKEN;
                stake_info.votes += 1;
            }
            5_u8 => {
                stake_info.apr += POINT_ONE_TOKEN * 2;
                stake_info.votes += 2;
            }
            _ => {
                require!(1 != 1, "Stake: Invalid vote!");
            }
        }
        self.stake_info.insert(&_advisor_id, &stake_info);
    }

    #[private]
    pub fn now() -> i64 {
        return env::block_timestamp() as i64;
    }
}

'''
'''--- smart-contract-v1/token/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
'''
'''--- smart-contract-v1/token/neardev/dev-account.env ---
CONTRACT_NAME=token.spk-stream.testnet
'''
'''--- smart-contract-v1/token/src/events.rs ---
//! Standard for nep141 (Fungible Token) events.
//!
//! These events will be picked up by the NEAR indexer.
//!
//! <https://github.com/near/NEPs/blob/master/specs/Standards/FungibleToken/Event.md>
//!
//! This is an extension of the events format (nep-297):
//! <https://github.com/near/NEPs/blob/master/specs/Standards/EventsFormat.md>
//!
//! The three events in this standard are [`FtMint`], [`FtTransfer`], and [`FtBurn`].
//!
//! These events can be logged by calling `.emit()` on them if a single event, or calling
//! [`FtMint::emit_many`], [`FtTransfer::emit_many`],
//! or [`FtBurn::emit_many`] respectively.

use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk::serde::Serialize;

use near_sdk::env;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    Nep141(Nep141Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

/// Data to log for an FT mint event. To log this event, call [`.emit()`](FtMint::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtMint<'a> {
    pub owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtMint<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT mint event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtMint`] represents the data of each mint.
    pub fn emit_many(data: &[FtMint<'_>]) {
        new_141_v1(Nep141EventKind::FtMint(data)).emit()
    }
}

/// Data to log for an FT transfer event. To log this event,
/// call [`.emit()`](FtTransfer::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtTransfer<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT transfer event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtTransfer`] represents the data of each transfer.
    pub fn emit_many(data: &[FtTransfer<'_>]) {
        new_141_v1(Nep141EventKind::FtTransfer(data)).emit()
    }
}

#[derive(Serialize, Debug)]
pub(crate) struct Nep141Event<'a> {
    version: &'static str,
    #[serde(flatten)]
    event_kind: Nep141EventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep141EventKind<'a> {
    FtMint(&'a [FtMint<'a>]),
    FtTransfer(&'a [FtTransfer<'a>]),
}

fn new_141<'a>(version: &'static str, event_kind: Nep141EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep141(Nep141Event { version, event_kind })
}

fn new_141_v1(event_kind: Nep141EventKind) -> NearEvent {
    new_141("1.0.0", event_kind)
}
'''
'''--- smart-contract-v1/token/src/ft_core.rs ---
use near_sdk::{assert_one_yocto, ext_contract, require, Gas, PromiseOrValue, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
        _advisor: Option<AccountId>,
        _amount_per_minute: Option<U128>,
        _room_id: Option<U128>,
        _minutes_lasts: Option<i64>,
        _signature: Option<Vec<u8>>,
        _signer: Option<Vec<u8>>,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        // Assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be required to sign with a FAK.
        assert_one_yocto();
        // The sender is the user who called the method
        let sender_id = env::predecessor_account_id();
        // How many tokens the user wants to withdraw
        let amount: Balance = amount.into();
        // Transfer the tokens
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
        _advisor: Option<AccountId>,
        _amount_per_minute: Option<U128>,
        _room_id: Option<U128>,
        _minutes_lasts: Option<i64>,
        _signature: Option<Vec<u8>>,
        _signer: Option<Vec<u8>>,
    ) -> PromiseOrValue<U128> {
        // Assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be required to sign with a FAK.
        assert_one_yocto();
        // The sender is the user who called the method
        let sender_id = env::predecessor_account_id();
        // How many tokens the sender wants to transfer
        let amount: Balance = amount.into();
        // Transfer the tokens

        if _room_id != None {
            self.internal_transfer(&sender_id, &receiver_id, u128::from(_amount_per_minute.unwrap()) * _minutes_lasts.unwrap() as u128, memo);
            if msg == "create_room" {
                // create_room in spk-app contract
                ext_ft_receiver::ext(receiver_id.clone())
                    .with_static_gas(GAS_FOR_FT_TRANSFER_CALL)
                    .ft_on_transfer(
                        sender_id.clone(),
                        amount.into(),
                        msg,
                        _advisor,
                        _amount_per_minute,
                        _room_id,
                        _minutes_lasts,
                        _signature,
                        _signer,
                    )
                    // We then resolve the promise and call ft_resolve_transfer on our own contract
                    // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                            .ft_resolve_transfer(&sender_id, receiver_id, amount.into()),
                    )
                    .into()
            } else if msg == "extend_room" {
                
                // extend_room in spk-app contract
                ext_ft_receiver::ext(receiver_id.clone())
                    .with_static_gas(GAS_FOR_FT_TRANSFER_CALL)
                    .ft_on_transfer(
                        sender_id.clone(),
                        amount.into(),
                        msg,
                        None,
                        _amount_per_minute,
                        _room_id,
                        _minutes_lasts,
                        _signature,
                        _signer,
                    )
                    // We then resolve the promise and call ft_resolve_transfer on our own contract
                    // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                            .ft_resolve_transfer(&sender_id, receiver_id, amount.into()),
                    )
                    .into()
            } else {
                require!(1 != 1, "Invalid message!");
                return PromiseOrValue::Value(U128::from(0));
            }
        } else {
            self.internal_transfer(&sender_id, &receiver_id, amount, memo);
            // Initiating receiver's call and the callback
            // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for ft transfer call.
            ext_ft_receiver::ext(receiver_id.clone())
                .with_static_gas(GAS_FOR_FT_TRANSFER_CALL)
                .ft_on_transfer(
                    sender_id.clone(),
                    amount.into(),
                    msg,
                    None,
                    None,
                    None,
                    None,
                    None,
                    None,
                )
                // We then resolve the promise and call ft_resolve_transfer on our own contract
                // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                        .ft_resolve_transfer(&sender_id, receiver_id, amount.into()),
                )
                .into()
        }
    }

    fn ft_total_supply(&self) -> U128 {
        // Return the total supply casted to a U128
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        // Return the balance of the account casted to a U128
        self.accounts.get(&account_id).unwrap_or(0).into()
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
        _advisor: Option<AccountId>,
        _amount_per_minute: Option<U128>,
        _room_id: Option<U128>,
        _minutes_lasts: Option<i64>,
        _signature: Option<Vec<u8>>,
        _signer: Option<Vec<u8>>,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    // Finalize an `ft_transfer_call` chain of cross-contract calls.
    //
    // The `ft_transfer_call` process:
    //
    // 1. Sender calls `ft_transfer_call` on FT contract
    // 2. FT contract transfers `amount` tokens from sender to receiver
    // 3. FT contract calls `ft_on_transfer` on receiver contract
    // 4+. [receiver contract may make other cross-contract calls]
    // N. FT contract resolves promise chain with `ft_resolve_transfer`, and may
    //    refund sender some or all of original `amount`
    //
    // Requirements:
    // * Contract MUST forbid calls to this function by any account except self
    // * If promise chain failed, contract MUST revert token transfer
    // * If promise chain resolves with a non-zero amount given as a string,
    //   contract MUST return this amount of tokens to `sender_id`
    //
    // Arguments:
    // * `sender_id`: the sender of `ft_transfer_call`
    // * `receiver_id`: the `receiver_id` argument given to `ft_transfer_call`
    // * `amount`: the `amount` argument given to `ft_transfer_call`
    //
    // Returns a string representing a string version of an unsigned 128-bit
    // integer of how many total tokens were spent by sender_id. Example: if sender
    // calls `ft_transfer_call({ "amount": "100" })`, but `receiver_id` only uses
    // 80, `ft_on_transfer` will resolve with `"20"`, and `ft_resolve_transfer`
    // will return `"80"`.
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            // If the promise was successful, get the return value and cast it to a U128.
            PromiseResult::Successful(value) => {
                // If we can properly parse the value, the unused amount is equal to whatever is smaller - the unused amount or the original amount (to prevent malicious contracts)
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                // If we can't properly parse the value, the original amount is returned.
                } else {
                    amount
                }
            }
            // If the promise wasn't successful, return the original amount.
            PromiseResult::Failed => amount,
        };

        // If there is some unused amount, we should refund the sender
        if unused_amount > 0 {
            // Get the receiver's balance. We can only refund the sender if the receiver has enough balance.
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);
            if receiver_balance > 0 {
                // The amount to refund is the smaller of the unused amount and the receiver's balance as we can only refund up to what the receiver currently has.
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);

                // Refund the sender for the unused amount.
                self.internal_transfer(
                    &receiver_id,
                    &sender_id,
                    refund_amount,
                    Some("Refund".to_string()),
                );

                // Return what was actually used (the amount sent - refund)
                let used_amount = amount
                    .checked_sub(refund_amount)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow"));
                return used_amount.into();
            }
        }

        // If the unused amount is 0, return the original amount.
        amount.into()
    }
}

'''
'''--- smart-contract-v1/token/src/internal.rs ---
use near_sdk::{require};

use crate::*;

impl Contract {
    /// Internal method for force getting the balance of an account. If the account doesn't have a balance, panic with a custom message.
    pub(crate) fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
        match self.accounts.get(account_id) {
            Some(balance) => balance,
            None => {
                env::panic_str(format!("The account {} is not registered", &account_id).as_str())
            }
        }
    }

    /// Internal method for depositing some amount of FTs into an account. 
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Add the amount to the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("Balance overflow");
        }
    }

    /// Internal method for withdrawing some amount of FTs from an account. 
    pub(crate) fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Decrease the amount from the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("The account doesn't have enough balance");
        }
    }

    /// Internal method for performing a transfer of FTs from one account to another.
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        // Ensure the sender can't transfer to themselves
        require!(sender_id != receiver_id, "Sender and receiver should be different");
        // Ensure the sender can't transfer 0 tokens
        require!(amount > 0, "The amount should be a positive number");
        
        // Withdraw from the sender and deposit into the receiver
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);
        
        // Emit a Transfer event
        FtTransfer {
            old_owner_id: sender_id,
            new_owner_id: receiver_id,
            amount: &U128(amount),
            memo: memo.as_deref(),
        }
        .emit();
    }

    /// Internal method for registering an account with the contract.
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
        if self.accounts.insert(account_id, &0).is_some() {
            env::panic_str("The account is already registered");
        }
    }

    /// Internal method for measuring how many bytes it takes to insert the longest possible account ID into our map
    /// This will insert the account, measure the storage, and remove the account. It is called in the initialization function.
    pub(crate) fn measure_bytes_for_longest_account_id(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = AccountId::new_unchecked("a".repeat(64));
        self.accounts.insert(&tmp_account_id, &0u128);
        self.bytes_for_longest_account_id = env::storage_usage() - initial_storage_usage;
        self.accounts.remove(&tmp_account_id);
    }
}
'''
'''--- smart-contract-v1/token/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod ft_core;
pub mod events;
pub mod metadata;
pub mod storage;
pub mod internal;

use crate::metadata::*;
use crate::events::*;

/// The image URL for the default icon
const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/jpeg;base64,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";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Keep track of each account's balances
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of all tokens.
    pub total_supply: Balance,

    /// The bytes for the largest possible account ID that can be registered on the contract 
    pub bytes_for_longest_account_id: StorageUsage,

    /// Metadata for the contract itself
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(total_supply: U128) -> Self {
        // Calls the other function "new: with some default metadata and the owner_id & total supply passed in 
        Self::new(
            env::signer_account_id(),
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "SPK".to_string(),
                symbol: "SPK".to_string(),
                icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        // Create a variable of type Self with all the fields initialized. 
        let mut this = Self {
            // Set the total supply
            total_supply: total_supply.0,
            // Set the bytes for the longest account ID to 0 temporarily until it's calculated later
            bytes_for_longest_account_id: 0,
            // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            accounts: LookupMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
            metadata: LazyOption::new(
                StorageKey::Metadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        // Measure the bytes for the longest account ID and store it in the contract.
        this.measure_bytes_for_longest_account_id();

        // Register the owner's account and set their balance to the total supply.
        this.internal_register_account(&owner_id);
        this.internal_deposit(&owner_id, total_supply.into());
        
        // Emit an event showing that the FTs were minted
        FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial token supply is minted"),
        }
        .emit();

        // Return the Contract object
        this
    }
}
'''
'''--- smart-contract-v1/token/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String, // Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract.
    pub name: String, // The human-readable name of the token.
    pub symbol: String, // The abbreviation, like wETH or AMPL.
    pub icon: Option<String>, // Icon of the fungible token.
    pub reference: Option<String>, // A link to a valid JSON file containing various keys offering supplementary details on the token 
    pub reference_hash: Option<Base64VecU8>, // The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering.
    pub decimals: u8, // used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post. https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}
'''
'''--- smart-contract-v1/token/src/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, log, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`
// The `total` and `available` values are string representations of unsigned
// 128-bit integers showing the balance of a specific account in yoctoⓃ.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// The below structure will be returned for the method `storage_balance_bounds`.
// Both `min` and `max` are string representations of unsigned 128-bit integers.
//
// `min` is the amount of tokens required to start using this contract at all
// (eg to register with the contract). If a new contract user attaches `min`
// NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of`
// for this user must show their `total` equal to `min` and `available=0` .
//
// A contract may implement `max` equal to `min` if it only charges for initial
// registration, and does not adjust per-user storage over time. A contract
// which implements `max` must refund deposits that would increase a user's
// storage balance beyond this amount.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    /************************************/
    /* CHANGE METHODS on fungible token */
    /************************************/
    // Payable method that receives an attached deposit of Ⓝ for a given account.
    //
    // If `account_id` is omitted, the deposit MUST go toward predecessor account.
    // If provided, deposit MUST go toward this account. If invalid, contract MUST
    // panic.
    //
    // If `registration_only=true`, contract MUST refund above the minimum balance
    // if the account wasn't registered and refund full deposit if already
    // registered.
    //
    // The `storage_balance_of.total` + `attached_deposit` in excess of
    // `storage_balance_bounds.max` must be refunded to predecessor account.
    //
    // Returns the StorageBalance structure showing updated balances.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /****************/
    /* VIEW METHODS */
    /****************/
    // Returns minimum and maximum allowed balance amounts to interact with this
    // contract. See StorageBalanceBounds.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns the StorageBalance structure of the valid `account_id`
    // provided. Must panic if `account_id` is invalid.
    //
    // If `account_id` is not registered, must return `null`.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        // Get the amount of $NEAR to deposit
        let amount: Balance = env::attached_deposit();
        // If an account was specified, use that. Otherwise, use the predecessor account.
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        
        // If the account is already registered, refund the deposit.
        if self.accounts.contains_key(&account_id) {
            log!("The account is already registered, refunding the deposit");
            if amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } 
        // Register the account and refund any excess $NEAR
        } else {
            // Get the minimum required storage and ensure the deposit is at least that amount
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the minimum storage balance");
            }

            // Register the account
            self.internal_register_account(&account_id);
            // Perform a refund
            let refund = amount - min_balance;
            if refund > 0 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }

        // Return the storage balance of the account
        StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        // Calculate the required storage balance by taking the bytes for the longest account ID and multiplying by the current byte cost
        let required_storage_balance =
            Balance::from(self.bytes_for_longest_account_id) * env::storage_byte_cost();
        
        // Storage balance bounds will have min == max == required_storage_balance
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        // Get the storage balance of the account. Available will always be 0 since you can't overpay for storage.
        if self.accounts.contains_key(&account_id) {
            Some(StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() })
        } else {
            None
        }
    }
}
'''