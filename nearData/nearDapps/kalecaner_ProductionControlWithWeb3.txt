*GitHub Repository "kalecaner/ProductionControlWithWeb3"*

'''--- README.md ---
# Web3 Based Production Control Application

## Summary
The products produced in this project are listed according to the product code and can be separated according to their shifts. All productions are followed by all shifts. This is the first phase of my project. I will continue to develop and add more features to make this project more efficient in the future.

## Requirements
```
- npm Node.js package manager
- git bash (terminal)
- yarn(npm install -g yarn)
- near-cli
```

## Installation
1- Clone repository to your computer
```
https://github.com/kalecaner/ProductionControlWithWeb3.git
```
2- Go to file
```
cd ProductionControlWithWeb3
```
3- Run this in your terminal
```
yarn
```
4- Login your account
```
near login
```
5- Build contract
```
yarn build:release
```
6- deploy contract
```
near dev-deploy ./build/release/simple.wasm
```
7- Export the development account to the $CONTRACT
```
export CONTRACT=<YOUR_DEV_ACCOUNT_HERE>
```
## Scripts 
```
./scripts/1.dev-deploy.sh
```
It creates a new testnet account and deply the contract into it automatically.
```
./scripts/2.use-createproduct.sh
```
1. Initiates the contract
2. Creates product

## Usage
*Initialize contract by shift
```
near call $CONTRACT Saveshift '{}' --accountId $CONTRACT
```
This function can only be called once,Sets the function caller as shift and Does not take any parameters

* Create a new Product or ProductCode
```
near call $CONTRACT createProduct '{"productCode":"<Product Code>","productType":"<Product Type>","productLine":"<Line Name>","density":"<Density Value>","width":"<Width Value>","lenght":"<Lenght Value>","thickness":"<Thickness Value>","amountofUnits":"<Amount of Units>","produtionDate":"<dd.mm.yyyy>"}' --accountId YOUR-ACCOUNT.testnet
```
* Read all product by between a certain index
```
near view $CONTRACT getProducts '{"offset":"<WHERE TO START>","limit":"<LIMIT OF GET PRODUCT"}' --accountId canerkale.testnet
```
* Read all Product by index
```
near view $CONTRACT getProductById '{"id":"<Product-ID>"}' --accountId YOUR-ACCOUNT.testnet
```
* Update Product Data
```
near call $CONTRACT updateProduct '{"id":"<Product-ID>","updates":{"productCode":"<Product Code>","productType":"<Product Type>","productLine":"<Line Name>","density":"<Density Value>","width":"<Width Value>","lenght":"<Lenght Value>","thickness":"<Thickness Value>","produceUnit":"<produce Unit Value>","amountofUnits":"<Amount of Units>","produtionDate":"<dd.mm.yyyy>"}}' --accountId YOUR-ACCOUNT.testnet
```
* Delete Product by ID
```
near call $CONTRACT DelProduct '{"id":"<Product-ID>"}' --accountId YOUR-ACCOUNT.testnet
```
* Save Product to Chain
```
near call $CONTRACT SaveProduct '{"productCode":"<Product Code>","productType":"<Product Type>","productLine":"<Line Name>","density":"<Density Value>","width":"<Width Value>","lenght":"<Lenght Value>","thickness":"<Thickness Value>","amountofUnits":"<Amount of Units>","produtionDate":"<dd.mm.yyyy>"}' --accountId YOUR-ACCOUNT.testnet
```
* Read Product from Chain
```
nnear call $CONTRACT getFromChainData --accountId YOUR-ACCOUNT.testnet
```

## Patika
https://www.patika.dev/tr

## Loom video

https://www.loom.com/share/6ec61f62613a437e9f7e28ec011ee903

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/simple",
    "src/singleton"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build:release

echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo ---------------------------------------------------------
echo

near dev-deploy ./build/release/simple.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
echo
echo
echo "Don't forget to initialize the contract"
echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo
echo
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.use-createproduct.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo ---------------------------------------------------------
echo "Step 1: Initialize the contract"
echo ---------------------------------------------------------
echo

near call $CONTRACT Saveshift '{}' --accountId $CONTRACT

echo
echo ---------------------------------------------------------
echo "Step 2: Create product"
echo ---------------------------------------------------------
echo

near call $CONTRACT createProduct '{"productCode":"<Product Code>","productType":"<Product Type>","productLine":"<Line Name>","density":"<Density Value>","width":"<Width Value>","lenght":"<Lenght Value>","thickness":"<Thickness Value>","amountofUnits":"<Amount of Units>","produtionDate":"<dd.mm.yyyy>"}' --accountId $CONTRACT

echo
echo
exit 0

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/simple/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/simple/__tests__/index.unit.spec.ts ---
import * as contract from "../assembly";

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("ðŸš« Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("âœ… Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/simple/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/simple/assembly/index.ts ---
import { Product, PartialProduct,productListStorage } from "./model";
import { storage, Context, context, ContractPromiseBatch, u128 } from "near-sdk-as"

export function createProduct(
  productCode: string, productType: string,productLine: string,density:u64,width: u64,lenght: u64,thickness:u64,produceUnit:u64,amountofUnits:u64,produtionDate:string
): Product {
  assert_IsShift()
  let id = storage.getSome<u32>("currentID")
  storage.set("currentID", id + 1)
  return Product.addProduct(productCode, productType,productLine,density ,width,lenght,thickness,produceUnit,amountofUnits,produtionDate);
}

export function getProductById(id: u32): Product {
  return Product.FindProductById(id);
}

export function getProducts(offset: u32, limit: u32 = 10): Product[] {
  return Product.GetAllProducts(offset, limit);
}

export function updateProduct(id: u32, updates: PartialProduct): Product {
  return Product.UpdateProductById(id, updates);
}

export function DelProduct(id: u32): void {
  Product.DeleteProductById(id);
}
export function SaveProduct(productCode: string, productType: string,productLine: string,density:u64,width: u64,lenght: u64,thickness:u64,produceUnit:u64,amountofUnits:u64,produtionDate:string):string
{
  const product= new Product(productCode, productType,productLine,density ,width,lenght,thickness,produceUnit,amountofUnits,produtionDate);
  productListStorage.push(product);  
    return "added product to chain"
}
const limitProducts= 10;
export function getFromChainData():Product[]{
  const numProducts=min(limitProducts,productListStorage.length);
  const startIndex=productListStorage.length-numProducts;
  const list= new Array<Product>(numProducts);
  for (let i=0;i<numProducts;i++)
  {
    list[i]=productListStorage[i+startIndex];
  }
  return list;
}
export function Saveshift(): void {
  assert_shift()
  storage.setString("shift", context.sender)
  storage.set("currentID", 0)
}

function assert_shift(): void {
  assert(!storage.hasKey("shift"), "Shift initialized before!")
}
function assert_IsShift(): void {
  assert(context.predecessor == storage.getString("shift"), "Only shift may call this function!")
}
'''
'''--- src/simple/assembly/model.ts ---
import {
    PersistentUnorderedMap,
    math,
    Context,
    PersistentVector    
  } from "near-sdk-as";
  type AccountId = string;
  @nearBindgen
  export class Product {
    id: u32;
    shift: AccountId = Context.sender;
    productCode: string;
    productType: string;
    productLine: string;
    density:u64; // unit kg/m3
    width: u64; //unit  millimeter
    lenght: u64; //unit  millimeter
    thickness: u64;//unit  millimeter
    amountofUnits:u64; //unit number
    produceUnit:u64; //unit palette
    productionTonnage:u64; //unit kg
    produtionDate:string;//dd-mm-yyyy

  
    constructor(productCode: string, productType: string,productLine: string,density:u64,width: u64,lenght: u64,thickness: u64, produceUnit:u64,amountofUnits:u64,produtionDate:string) {
      this.id = math.hash32<string>(productCode);
      this.productCode = productCode;
      this.productType = productType;
      this.productLine = productLine;
      this.density = density;
      this.width = width;
      this.lenght = lenght;
      this.thickness = thickness;
      this.produceUnit = produceUnit;
      this.produtionDate = produtionDate;
      this.amountofUnits = amountofUnits;
      this.productionTonnage =(density*width*lenght*thickness*produceUnit*amountofUnits)/1000000000;     

    }
    static addProduct(productCode: string, productType: string,productLine: string,density:u64,width:u64,lenght:u64,thickness:u64,produceUnit:u64,amountofUnits:u64,produtionDate:string): Product {
        const product = new Product(productCode, productType,productLine,density,width,lenght,thickness,produceUnit,amountofUnits,produtionDate);
        products.set(product.id, product);
    
        return product;

      }
      static FindProductById(id: u32): Product {
        return products.getSome(id);
      }
    
      static GetAllProducts(offset: u32, limit: u32): Product[] {
        return products.values(offset, offset + limit);
      }
    
      static UpdateProductById(id: u32, partial: PartialProduct): Product {
        const product = this.FindProductById(id);
    
        product.productCode = partial.productCode;
        product.productType = partial.productType;
        product.productLine = partial.productLine;
        product.density = partial.density;
        product.width = partial.width;
        product.lenght = partial.lenght;
        product.thickness = partial.thickness;
        product.amountofUnits = partial.amountofUnits;
        product.produceUnit = partial.produceUnit;
        product.produtionDate = partial.produtionDate;
        
    
        products.set(id, product);
    
        return product;
      }
    
      static DeleteProductById(id: u32): void {
          products.delete(id);
      }
}
  export const products = new PersistentUnorderedMap<u32, Product>("p");
  export const productListStorage = new PersistentVector<Product>("pl");
  @nearBindgen
  export class PartialProduct {
    productCode: string;
    productType: string;
    productLine: string;
    density:u64; 
    width: u64; 
    lenght: u64; 
    thickness: u64;
    amountofUnits:u64; 
    produceUnit:u64; 
    produtionDate:string;

    
  }
   
   
  
 
'''
'''--- src/singleton/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/singleton/__tests__/index.unit.spec.ts ---

'''
'''--- src/singleton/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/singleton/assembly/index.ts ---

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto â“ƒ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto â“ƒ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto â“ƒ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''