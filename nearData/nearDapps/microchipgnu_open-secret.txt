*GitHub Repository "microchipgnu/open-secret"*

'''--- README.md ---
# Open Secret

<img width="946" alt="image" src="https://github.com/microchipgnu/open-secret/assets/12901349/0d5c50d6-0269-49f2-b793-405c66c06ced">

[YouTube Demo](https://www.youtube.com/watch?v=VawBqiXaiAg)

Open Secret allows you to chat with NEAR Social accounts. We allow users to mint dynamic NFTs that control that reference on-chain private metadata. By owning an NFT, you are able to attach encrypted pieces of data and then give access to other accounts to decrypt this data.

## NEAR Protocol: Handling Private Data 

### Storing Private Data in Tokens

To mint a token that contains encrypted private data, the following steps are proposed:

1. **Encryption**: Used a library such as [NEAR JavaScript Encryption Box](https://github.com/NEARFoundation/near-js-encryption-box/tree/main) to encrypt the data before minting the token.

2. **Key Management**: Implemented smart contract functionality to manage encryption keys.

   - The contract allows adding or removing keys associated with the current owner of the token, enabling them to encrypt and decrypt the data.

As a bonus we thought of adding ability for tokens to carry proof elements (using ZK), such as links to data stored on Arweave, to ensure data integrity and authenticity.

## Giving access to Private Data

### Minting and Storing Private Data Process

The following process allows for the secure minting and transferring of private data through NFTs:

1. **Minter's Actions**:

   - The **Minter** (M) encrypts the data using their keypair (KP1) and includes a reference to this encrypted data (ED1) within the NFT, possibly pointing to an Arweave storage location.
   - When giving access to specific private data bits, they owner needs to decrypt and encrypt again with the viewer's public key.
   - Optionally, the minter may include Zero-Knowledge proofs (e.g., ZK-SNARKs) to validate certain claims about the data, like confirming it matches an Arweave hash pattern through regex verification or that the content was not changed (sha-256).

## To Do

- [] Indexer (subgraph?)
- [] Dashboard 
- [] Marketplace
- [] Cont
- Use-cases
   - [] Chat

'''
'''--- open-secret-chat/.eslintrc.json ---
{
  "extends": "next/core-web-vitals"
}

'''
'''--- open-secret-chat/README.md ---
# Open Secret

Mintbase template with to generate Stability.ai images and mint them to Near instantly.

<img width="900" alt="image" src="https://github.com/Markeljan/open-secret/assets/12901349/eb061e45-04b6-4cd6-bb1e-7f5c1f7f39ac">

## Getting Started

First, add necessary environment variables.

Next, create a contract on testnet.mintbase.xyz

Deploy a proxy minter contract using this repo:
[mintbase/minsta-contract](https://github.com/Mintbase/minsta-contract)

Finally, add the proxy contract as a minter on your Mintbase dashboard.

**Note  if deploying to prod this requires pro or higher on vercel to support serverless functions > 15 seconds 

Run the development server:

```bash
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

- make sure to add your environment variables

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

.
'''
'''--- open-secret-chat/app/api/chat/route.ts ---
import { ChatCompletionRequestMessage, Configuration, OpenAIApi } from "openai-edge";
import { OpenAIStream, StreamingTextResponse } from "ai";
import { callViewMethod } from "@/lib/data/near-rpc-functions";
import { constants } from "@/lib/constants";
import { open } from "@nearfoundation/near-js-encryption-box";

export const maxDuration = 40;

const getPrivateData = async (accountId: string) => {
  let privateData = "";

  const data = await callViewMethod({
    contractId: constants.tokenContractAddress,
    method: "get_private_metadata_by_key_paginated",
    args: {
      token_id: accountId,
      public_key: process.env.NEXT_PUBLIC_BOT_PUBLIC_KEY,
      from_index: 0,
      limit: 1000,
    },
  });

  const decryptData = async (uri: string, signerPublicKey: string) => {
    const result = await fetch(uri);
    if (!result.ok) {
      throw new Error(result.statusText);
    }

    const data = await result.text();

    const decryptedData = open(
      data,
      signerPublicKey,
      process.env.BOT_PRIVATE_KEY!,
      "86NFZFaUh1A8v8O11oMH3/Xwo4Fmi25g"
    );

    return decryptedData;
  };

  for (const item of data) {
    privateData += await decryptData(item?.metadata?.uri, item?.signer_public_key);
    privateData += "\n";
  }

  return privateData;
};

export async function POST(req: Request) {
  const json = await req.json();
  const { messages, accountId } = json;

  const configuration = new Configuration({
    apiKey: process.env.OPENAI_API_KEY,
  });

  const openai = new OpenAIApi(configuration);

  const openSecretDataContent = await getPrivateData(accountId);

  const openSecretSystemMessage: ChatCompletionRequestMessage = {
    role: "system",
    content: `Here is the OpenSecret data for ${accountId}: ${openSecretDataContent}`,
  };

  const messagesWithOpenSecretData = [...messages, openSecretSystemMessage];

  const res = await openai.createChatCompletion({
    model: "gpt-4-1106-preview",
    stream: true,
    temperature: 0.7,
    messages: messagesWithOpenSecretData,
  });

  const stream = OpenAIStream(res)

  return new StreamingTextResponse(stream);
}

'''
'''--- open-secret-chat/app/api/text-to-speech/route.ts ---
import OpenAI from "openai";

const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});

export const runtime = 'edge'

export async function POST(req: Request) {

    const json = await req.json();
    const { text, voiceId } = json;

    const audioResponse = await openai.audio.speech.create({
        model: "tts-1",
        voice: voiceId,
        input: text,
    });

    // Error handling
    if (!audioResponse.ok || !audioResponse.body) {
        return new Response('Failed to get voice response', { status: audioResponse.status });
    }

    const buffer = Buffer.from(await audioResponse.arrayBuffer());

    return new Response(buffer);
}
'''
'''--- open-secret-chat/app/globals.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {

    --gradient: linear-gradient(to top left, #56ab2f, #a8e063);

    --background: 107 37.05% 3.44%;
    --foreground: 107 5.699999999999999% 97.15%;

    --muted: 107 28.499999999999996% 12.9%;
    --muted-foreground: 107 5.699999999999999% 54.3%;

    --popover: 107 53.6% 5.59%;
    --popover-foreground: 107 5.699999999999999% 97.15%;

    --card: 107 53.6% 5.59%;
    --card-foreground: 107 5.699999999999999% 97.15%;

    --border: 107 28.499999999999996% 12.9%;
    --input: 107 28.499999999999996% 12.9%;

    --primary: 107 57% 43%;
    --primary-foreground: 107 5.699999999999999% 97.15%;

    --secondary: 107 28.499999999999996% 12.9%;
    --secondary-foreground: 107 5.699999999999999% 97.15%;

    --accent: 107 28.499999999999996% 12.9%;
    --accent-foreground: 107 5.699999999999999% 97.15%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 107 5.699999999999999% 97.15%;

    --ring: 107 57% 43%;

    --radius: 0.3rem;
  }

  .dark {
    --gradient: linear-gradient(to top left, #434343, #000000);

    --background: 0 0% 2.08%;
    --foreground: 0 0% 96.3%;

    --muted: 0 0% 7.800000000000001%;
    --muted-foreground: 0 0% 52.6%;

    --popover: 0 65% 3.38%;
    --popover-foreground: 0 0% 96.3%;

    --card: 0 65% 3.38%;
    --card-foreground: 0 0% 96.3%;

    --border: 0 0% 7.800000000000001%;
    --input: 0 0% 7.800000000000001%;

    --primary: 0 0% 26%;
    --primary-foreground: 0 0% 96.3%;

    --secondary: 0 0% 7.800000000000001%;
    --secondary-foreground: 0 0% 96.3%;

    --accent: 0 0% 7.800000000000001%;
    --accent-foreground: 0 0% 96.3%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 96.3%;

    --ring: 0 0% 26%;

    --radius: 0.3rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }
}
'''
'''--- open-secret-chat/components.json ---
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
'''
'''--- open-secret-chat/lib/constants.ts ---
const appName: string = process.env.NEXT_PUBLIC_APP_TITLE || "MINTBASE";
const callbackUrl: string = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
const network = process.env.NEXT_PUBLIC_NETWORK || "mainnet";

const tokenContractAddress =
    process.env.NEXT_PUBLIC_NFT_CONTRACT_ADDRESS || "open-secret.mintspace2.testnet";

const mintbaseBaseUrl =
    process.env.NEXT_PUBLIC_BASE_URL || "https://mintbase.xyz";

const mintbaseWalletUrl =
    process.env.NEXT_PUBLIC_MINTBASE_WALLET_URL ||
    "https://wallet.mintbase.xyz";

const twitterText =
    process.env.NEXT_PUBLIC_TWITTER ||
    "Instantly%20mint%20your%20AI%20%%20creations%20%at%20%%Open%20%Secret%20%40Mintbase%20%40NEARProtocol%20%23BOS%20%23NEAR%0aMint%20yours%20here%3A%20https%3A%2F%2Fminsta.mintbase.xyz";

export const constants = {
    appName,
    callbackUrl,
    tokenContractAddress,
    network,
    mintbaseBaseUrl,
    mintbaseWalletUrl,
    twitterText,
    isClosed: process.env.NEXT_PUBLIC_MINTING_CLOSED === "true" || false,
    showRewards: process.env.NEXT_PUBLIC_SHOW_REWARDS === "true" || false,
};

'''
'''--- open-secret-chat/lib/data/fetch.ts ---

export const REQUEST_HEADERS = {
    "Cache-Control": "public, max-age=31536000, immutable",
    "mb-api-key": "omni-site",
};

export enum REQUEST_METHODS {
    get = "GET",
    post = "POST",
}

export const REQUEST_OPTIONS = (method: REQUEST_METHODS) => {
    return { method: method, headers: REQUEST_HEADERS };
};

export const fetchApi = async <T>(
    url: string,
    method: REQUEST_METHODS
): Promise<T | any> => {
    try {
        const result = await fetch(url, REQUEST_OPTIONS(method));

        if (result) {
            return await result.json();
        }
    } catch (error) {
        console.error(error);
    }
};
'''
'''--- open-secret-chat/lib/data/get-blocked-nfts.ts ---
import { REQUEST_METHODS, fetchApi } from "@/lib/data/fetch";

export const getBlockedNfts = async (): Promise<any> => {
    const fetchUrl = `https://surface-api-z3w7d7dnea-ew.a.run.app/blocked-nfts`;

    return fetchApi(fetchUrl, REQUEST_METHODS.get);
};

'''
'''--- open-secret-chat/lib/data/graphql-service.ts ---
import { nearEndpoints } from '@/lib/data/network'
import { constants } from "@/lib/constants";
import request from "graphql-request";

export type GqlFetchResult<T> = {
    data?: T;
    error?: string;
};

export const graphqlQLServiceNew = async ({
    query,
    variables,
    network,
    customUrl,
}: {
    query: any;
    variables?: Record<string, unknown>;
    network?: "testnet" | "mainnet";
    customUrl?: string;
}) => {
    const net = network ?? constants.network;
    const isTestnet = net === "testnet";

    const baseUrl = customUrl ? customUrl : isTestnet
        ? nearEndpoints.testnet.graph
        : nearEndpoints.mainnet.graph;

    const headers = {
        "content-type": "application/json",
        "mb-api-key": "anon",
        "Access-Control-Allow-Origin": "*",
        ...(customUrl && { "X-Hasura-Role": "dataplatform_near" }),

    };

    const queryLoad = () => request(baseUrl, query, variables, headers);

    return await queryLoad();
};

export const graphQLService = async ({
    query,
    variables,
    network,
    customUrl,
}: {
    query: any;
    variables?: Record<string, unknown>;
    network?: "testnet" | "mainnet";
    customUrl?: string;
}) => {
    try {
        const data = await graphQlFetch(query, variables, network, customUrl).then(
            async (data: Response) => {
                const res = await data.json();
                return res.data;
            }
        );

        return { data };
    } catch (error) {
        console.log(error, "error");
        return { error: `Query Error: ${error}` };
    }
};

export const graphQlFetch = async (
    query: string,
    variables: any,
    network?: "testnet" | "mainnet",
    customUrl?: string
): Promise<Response> => {
    const net = network ?? constants.network;
    const isTestnet = net === "testnet";

    const baseUrl = customUrl ? customUrl : isTestnet
        ? nearEndpoints.testnet.graph
        : nearEndpoints.mainnet.graph;

    const res = fetch(baseUrl, {
        method: "POST",
        body: JSON.stringify({
            query: query,
            variables: variables,
        }),
        headers: {
            "content-type": "application/json",
            "mb-api-key": "omni-site",
            ...(customUrl && { "X-Hasura-Role": "dataplatform_near" }),
        },
    });

    return await res;
};

'''
'''--- open-secret-chat/lib/data/near-rpc-functions.ts ---

import { RPC_ENDPOINTS } from "@mintbase-js/sdk";
import { constants } from "@/lib/constants";

export const requestFromNearRpc = async (
    body: Record<string, any>
): Promise<Record<string, any> | undefined> => {
    const fetchUrl = RPC_ENDPOINTS[constants.network as "testnet" | "mainnet"];

    const res = await fetch(fetchUrl, {
        method: "POST",
        body: JSON.stringify(body),
        headers: { "Content-type": "application/json" },
    });

    return res.json();
};

export const callViewMethod = async ({
    contractId,
    method,
    args,
}: {
    contractId: string;
    method: string;
    args?: Record<string, any>;
}): Promise<any> => {
    const args_base64 = args
        ? Buffer.from(JSON.stringify(args), "utf-8").toString("base64")
        : "";

    const res = await requestFromNearRpc({
        jsonrpc: "2.0",
        id: "dontcare",
        method: "query",
        params: {
            request_type: "call_function",
            finality: "final",
            account_id: contractId,
            method_name: method,
            args_base64,
        },
    });

    if (res?.error) {
        throw res.error;
    }

    const parsed = JSON.parse(Buffer.from(res?.result?.result).toString());
    return parsed;
};

'''
'''--- open-secret-chat/lib/data/network.ts ---
export const nearEndpoints = {
    testnet: {
        graph: "https://graph.mintbase.xyz/testnet",
    },
    mainnet: {
        graph: "https://graph.mintbase.xyz/",
    },
};

'''
'''--- open-secret-chat/lib/data/posts-graphql.ts ---
import { gql } from 'graphql-request';

export const getPostsQuery = gql`
  query MyQuery($accountId: String!) {
    dataplatform_near_social_feed_posts(
      where: { account_id: { _eq: $accountId } }
      limit: 10
    ) {
      id
      content
    }
  }
`;
'''
'''--- open-secret-chat/lib/data/use-graphql-query.ts ---

import { useQuery, type QueryObserverResult } from '@tanstack/react-query'
import { graphqlQLServiceNew } from '@/lib/data/graphql-service'

interface UseGraphQlQueryResult {
    data: any
    error: any
    isLoading: boolean
    refetch: () => Promise<QueryObserverResult<unknown, unknown>>
    isFetching: boolean
    status: 'error' | 'success' | 'loading'
}

export interface GQLQueryOptions {
    queryName: string
    query: string
    variables: Record<string, any>
    queryOpts?: any
    queryParams?: any[]
    customUrl?: string
}

export const useGraphQlQuery = ({
    queryName,
    query,
    variables,
    queryOpts = {},
    queryParams = [],
    customUrl,
}: GQLQueryOptions): UseGraphQlQueryResult => {
    const queryObj =
        queryParams.length > 0 ? [queryName, ...queryParams] : [queryName]

    const { data, error, isLoading, refetch, isFetching, status } = useQuery(
        queryObj,
        () => graphqlQLServiceNew({ query, variables, customUrl }),
        queryOpts
    )

    return { data, error, isLoading, refetch, isFetching, status }
}

'''
'''--- open-secret-chat/lib/fonts.ts ---
import { JetBrains_Mono as FontMono, Inter as FontSans } from 'next/font/google'

export const fontSans = FontSans({
    subsets: ['latin'],
    variable: '--font-sans'
})

export const fontMono = FontMono({
    subsets: ['latin'],
    variable: '--font-mono'
})
'''
'''--- open-secret-chat/lib/functions/schemas.ts ---
import { ChatRequestOptions } from 'ai'

export const functionSchemas: ChatRequestOptions['functions'] = [
  {
    name: 'text_to_image',
    description: `This function generates an image from text.  Return the value as an image in markdown.`,
    parameters: {
      type: 'object',
      properties: {
        text: {
          type: 'string',
          description: 'Text to generate an image from text.'
        }
      },
      required: ['text']
    }
  }
]

'''
'''--- open-secret-chat/lib/hooks/use-blocked-nfts.ts ---
import { getBlockedNfts } from "@/lib/data/get-blocked-nfts";
import { useQuery } from "@tanstack/react-query";

export const useBlockedNfts = () => {
    const { data: blockedNfts } = useQuery(
        ["q_getBlockedNfts"],
        () => getBlockedNfts(),
        {
            initialData: null, // Set initial data as null
            refetchInterval: 30000, // Automatically refetch every 120000 (2mins)
        }
    );

    return { blockedNfts };
};
'''
'''--- open-secret-chat/lib/hooks/use-is-client-mounted.ts ---
'use client'

import { useEffect, useState } from "react";

export default function useIsClientMounted() {
    const [isClientMounted, setIsClientMounted] = useState(false);
    useEffect(() => {
        setIsClientMounted(true);
    }, []);

    return isClientMounted;
};

'''
'''--- open-secret-chat/lib/hooks/use-profile.ts ---
import { useState, useEffect } from 'react';
import { ProfileData } from '@/lib/types';

export function useProfile(accountId?: string) {
    const [profileData, setProfileData] = useState<ProfileData | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    useEffect(() => {
        async function fetchData() {
            setIsLoading(true);
            const requestOptions: RequestInit = {
                method: 'POST',
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    "keys": [`${accountId}/profile/**`],
                }),
            };

            try {
                const response = await fetch("https://api.near.social/get", requestOptions);
                if (!response.ok) {
                    throw new Error(`HTTP error: ${response.status}`);
                }
                const data = await response.json();
                const formattedData = accountId ? data[accountId].profile : data

                // append accountId to the profile data
                formattedData["accountId"] = accountId;

                setProfileData(formattedData);
            } catch (error: any) {
                console.error(error);
            } finally {
                setIsLoading(false);
            }
        }

        fetchData();
    }, [accountId]);

    return { profileData, isLoading };
}

'''
'''--- open-secret-chat/lib/types.ts ---
export type ProfileData = {
    accountId: string;
    name: string;
    description: string;
    linktree: {
        twitter: string;
        github: string;
        telegram: string;
        website: string;
    };
    image: {
        ipfs_cid?: string;
        nft?: {
            contractId: string;
            tokenId: string;
        };
    };
    backgroundImage: {
        ipfs_cid: string;
    };
    tags: {
        [key: string]: string;
    };
}
'''
'''--- open-secret-chat/lib/utils.ts ---
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export const generateRandomId = (length: number) => {
  let result = "";
  const characters =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
};

export const toGatewayUrl = (ipfsCid: string) => {
  return `https://ipfs.near.social/ipfs/${ipfsCid}`
  // return `https://ipfs.io/ipfs/${ipfsCid}`
  // return `https:${ipfsCid}.ipfs.nftstorage.link`;
  // return `https:cloudflare-ipfs.com/ipfs/${ipfsCid}`;
}

// if given a string ensure it ends in .near if not add it
export const toNearAccount = (accountId: string) => {
  if (accountId.endsWith(".near")) {
    return accountId
  } else {
    return `${accountId}.near`
  }
}

'''
'''--- open-secret-chat/next.config.js ---
const { hostname } = require('os');

/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        hostname: "**.nftstorage.link"
      },
      {
        hostname: "ipfs.io"
      },
      {
        hostname: "cloudflare-ipfs.com"
      },
      {
        protocol: "https",
        hostname: "ipfs.near.social"
      }
    ]
  },
  webpack(config) {
    // eslint-disable-next-line no-param-reassign
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false, // https://stackoverflow.com/a/67478653/470749
    };

    return config;
  },

  experimental: {
    webpackBuildWorker: true
  },
};

module.exports = nextConfig;
'''
'''--- open-secret-chat/package.json ---
{
  "name": "open-secret",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@mintbase-js/data": "0.5.0-beta.2",
    "@mintbase-js/react": "0.5.0-beta.2",
    "@mintbase-js/sdk": "0.5.0-beta.2",
    "@mintbase-js/storage": "0.5.0-beta.2",
    "@mintbase-js/rpc": "0.5.0-beta.2",
    "@near-wallet-selector/modal-ui": "^8.7.1",
    "@nearfoundation/near-js-encryption-box": "^0.1.2",
    "@radix-ui/react-separator": "^1.0.3",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@tanstack/react-query": "^4.36.1",
    "ai": "^2.2.13",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "graphql-request": "^6.1.0",
    "lucide-react": "^0.279.0",
    "near-api-js": "^2.1.4",
    "next": "^14.0.1",
    "next-themes": "^0.2.1",
    "openai": "^4.16.1",
    "openai-edge": "^1.2.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hot-toast": "^2.4.1",
    "react-intersection-observer": "^9.5.2",
    "react-markdown": "^8.0.7",
    "react-syntax-highlighter": "^15.5.0",
    "react-textarea-autosize": "^8.5.2",
    "remark-gfm": "^3.0.1",
    "remark-math": "^5.1.1",
    "shadcn-ui": "^0.4.0"
  },
  "devDependencies": {
    "@types/node": "^20.7.2",
    "@types/react": "^18.2.23",
    "@types/react-dom": "^18.2.8",
    "@types/react-syntax-highlighter": "^15.5.7",
    "autoprefixer": "^10.4.16",
    "encoding": "^0.1.13",
    "eslint": "^8.50.0",
    "eslint-config-next": "^14.0.1",
    "isomorphic-unfetch": "3.0.0",
    "postcss": "^8.4.31",
    "tailwind-merge": "^1.14.0",
    "tailwindcss": "^3.3.3",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.2.2",
    "usehooks-ts": "^2.9.1"
  }
}
'''
'''--- open-secret-chat/postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

'''
'''--- open-secret-chat/public/next.svg ---
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
'''
'''--- open-secret-chat/public/vercel.svg ---
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
'''
'''--- open-secret-chat/tailwind.config.ts ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
	],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
'''
'''--- open-secret-chat/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "forceConsistentCasingInFileNames": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

'''
'''--- open-secret-contract/Cargo.toml ---
[package]
name = "minsta_proxy_minter"
version = "0.0.1"
authors = ["microchipgnu"]
edition = "2018"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
near-sdk = "4.1.1"
near-contract-standards = "4.1.1"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- open-secret-contract/README.md ---
# Minsta Proxy Minter NEAR Contract

This smart contract on the NEAR network is designed to handle minting functionality through proxy minters. It provides a way to mint Non-Fungible Tokens (NFTs) through specified minters while keeping track of the latest minter for each NFT contract.

## Contract Structure

### MinstaProxyMinter

- `latest_minters`: Lookup map that keeps track of the latest minter for each NFT contract ID.
- `mint`: A method that takes metadata and NFT contract ID to mint NFTs, payable and callable.
- `cb_mint`: A private callback method for handling successful minting.
- `get_latest_minter`: A view method to get the latest minter for a given NFT contract ID.

# Quickstart

1. Make sure you Rust installed.
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<br />

## 1. Build and Deploy the Contract
Compile and deploy the contract in the NEAR testnet by running:

```bash
sh ./scripts/build

# cargo build --target wasm32-unknown-unknown --release
```

Check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

<br />

## 2. Minting an NFT
To mint an NFT, you will need to call the `mint` method. Make sure to specify the metadata and NFT contract ID:

```bash
# Use near-cli to mint an NFT
near call <dev-account> mint '{"metadata":"<metadata>","nft_contract_id":"<nft_contract_id>"}' --accountId <dev-account> --amount <amount>
```

<br />

## 3. Retrieve the Latest Minter
You can get the latest minter for a given NFT contract ID:

```bash
# Use near-cli to get the latest minter
near view <dev-account> get_latest_minter '{"nft_contract_id":"<nft_contract_id>"}'
```

<br />

## Note
Please replace `<dev-account>`, `<metadata>`, `<nft_contract_id>`, and `<amount>` with appropriate values as needed.

Ensure that the account calling the `mint` method has the necessary funds to cover the associated costs, as this is a payable function.

---
'''
'''--- open-secret-contract/neardev/dev-account.env ---
CONTRACT_NAME=dev-1700440135493-87881503455960
'''
'''--- open-secret-contract/scripts/calls/add-metadata.sh ---

#!/bin/bash

# Path to the file containing the contract name
CONTRACT_NAME_FILE="./neardev/dev-account"
# Check if the contract name file exists
if [ -f "$CONTRACT_NAME_FILE" ]; then
    # Read the contract name from the file
    CONTRACT_NAME=$(cat "$CONTRACT_NAME_FILE")
    echo "Contract Name: $CONTRACT_NAME"

    # Now you can use the CONTRACT_NAME variable to run your near view command
    near call $CONTRACT_NAME add_metadata '{
        "token_id": "1",
        "metadata": {
            "public_key": "ed25519:8LXEySyBYewiTTL2jfGTSYcZsDjpRJ4hRm1fS3WJ4MdH",
            "metadata": {
                "uri": "asdasd",
                "sha256": "test"
            }
        }
    }' --accountId yoooooooooooooooooooo.testnet
else
    echo "Error: Contract name file does not exist."
    exit 1
fi
'''
'''--- open-secret-contract/scripts/calls/build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release
'''
'''--- open-secret-contract/scripts/calls/deploy.sh ---
#!/usr/bin/env bash

near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/minsta_proxy_minter.wasm
'''
'''--- open-secret-contract/scripts/calls/init.sh ---
#!/bin/bash

# Path to the file containing the contract name
CONTRACT_NAME_FILE="./neardev/dev-account"

# Check if the contract name file exists
if [ -f "$CONTRACT_NAME_FILE" ]; then
    # Read the contract name from the file
    CONTRACT_NAME=$(cat "$CONTRACT_NAME_FILE")
    echo "Contract Name: $CONTRACT_NAME"

    # Now you can use the CONTRACT_NAME variable to run your near view command
    near call $CONTRACT_NAME new '{
        "owner_id": "yoooooooooooooooooooo.testnet",
        "metadata": {
            "spec": "nft-1.0.0",
            "name": "Open Secret",
            "symbol": "OS",
            "icon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEXUlEQVRYR8VXW4hVVRj+vrX3OYbFNBl2eSsoa8pkxMJmzpGGoIwMY0wwImuCXmKKkiikKayHQIpAwbdAswskBYqJSlANek7TUOPURGKCWdmFkJnsoZnhzNn/F2vcZ9gez2UfEVoP+2Gv///Xt771X4mUq6enpz2Kogck3S2pk+R1ki736iT/kfQzyW/N7PNsNrtvcHDwTBrTbCbU1dV1cxiGGyWtA3BJM/l4f1rSLjPbPDQ0dKyRTl0AS5YsubStre11AP0AwiYHi+SJmJGFCdmypG3T09MDIyMjk7Vs1ASQy+VuIrkbQEezG3vqJfXGTzHhnFtlZttIuoTuUQC9hULheLW98wDkcrnbARwkeWWzw+P9ewCsB/AYgBkz6yW5lmRfUl/SOMmVhUJhJPn/HAD+5gCKLRzubS0AMO59MTa828z2Oud2VF8gBtGdZGIOQPzmX6ehPWk4iqKOIAg+BnCr/y/pJUmnnHPv1WHw6NTU1B0Vn5gDkM/ntwB4NiXtc2KS9kdR1B+G4aMA/pD0kaQHGwDwILcUi8UNs37jPz7UgiD4PoW318Qn6QSA/STbJc2T9EkjAAB8dCwuFos/zgLI5/M7YydqlYBa8vvMbFcTAJ6FncVisY/5fP4KT10LSaYZyFQAAEyHYXitB+BD6N1mVlvYTwsAZraeuVxuR3XMNjpM0mFJW0n+VUfub0mnSS6S5JxznQBeBpDMkBXV7R7AKEkv1HRJGiLpvX0rgHYzGyB5S5yuZ/VJHioUCv25XO4Vn/0AHDCzD51z35DMViWnUf8EEwC8H6RZj5O8Py5M3pF+D4JghZn9lFDeB+AtAF9U/vmw9CBJ3lt1yIQHYIks1gzEapJPSlodJ53xcrncmclkTiUOOwRgM8n9iX8Pk/S+tqqKAWsZgJmddM6971kzs+f9W5P0VbOyZmZmZjyo5yStcc4djKJoE8kxkvNrAWjlCVZLugHAYefcpJmtIzkAIKii7ldJL5jZkTAMF0t6A8CNNeidaMkJAXjqNwLobvZWafYljbYahhcVAIDtrSaiiwpgNhGlSMVjAI5J8m3Xm3FILapD8UKSd9XwiVriZ1Ox36lXjCRtMLPPwjC8s1QqHRgeHv6tu7v7IefcNYkQG8tkMqPlcnmNrylm9q9z7lMAlzXyg7li5IXqlOOvADwN4EsAPoOdLpVKHdlsdm/SCUku8/UdwIo4NzxF8noALzYAcG45jlmobkjelnTc014xRPI+Sa8BWJ4w7lsyH8qVtUfSHpLv1ANwXkPiBWu0ZEeiKOoLgsAzMd+nXTNb7pz7geTsQBLfuIvkqwBWnu3I9ASAZSSfqQOgdkvmhaubUpKboij6IAiCpSSH/aAB4JEqw9+VSqXeTCZzm6Q/nXNXA/A94rxqAA2b0opwjbb8JADfzy8FcFWdW01K8kwtqFdZU7XlCRCpB5M0GQ9A+sGkYrDF0awejgsbzZLW/rfhtPpKTcbzM5J+uZDx/D8+0FUx/4DhyAAAAABJRU5ErkJggg==",
            "base_uri": null,
            "reference": null,
            "reference_hash": null
        }
    }' --accountId yoooooooooooooooooooo.testnet
else
    echo "Error: Contract name file does not exist."
    exit 1
fi
'''
'''--- open-secret-contract/scripts/calls/mint.sh ---
#!/bin/bash

# Path to the file containing the contract name
CONTRACT_NAME_FILE="./neardev/dev-account"

# Check if the contract name file exists
if [ -f "$CONTRACT_NAME_FILE" ]; then
    # Read the contract name from the file
    CONTRACT_NAME=$(cat "$CONTRACT_NAME_FILE")
    echo "Contract Name: $CONTRACT_NAME"

    # Now you can use the CONTRACT_NAME variable to run your near view command
    near call $CONTRACT_NAME nft_mint '{
        "token_id": "1",
        "receiver_id": "yoooooooooooooooooooo.testnet",
        "token_metadata": {
            "title": "hey"
        }
    }' --accountId yoooooooooooooooooooo.testnet --depositYocto 5760000000000000000000
else
    echo "Error: Contract name file does not exist."
    exit 1
fi
'''
'''--- open-secret-contract/scripts/views/get-metadata.sh ---
#!/bin/bash

# Path to the file containing the contract name
CONTRACT_NAME_FILE="./neardev/dev-account"

# Check if the contract name file exists
if [ -f "$CONTRACT_NAME_FILE" ]; then
    # Read the contract name from the file
    CONTRACT_NAME=$(cat "$CONTRACT_NAME_FILE")
    echo "Contract Name: $CONTRACT_NAME"

    # Now you can use the CONTRACT_NAME variable to run your near view command
    near view $CONTRACT_NAME get_private_metadata_by_key_paginated '{
        "token_id": "fixed-bytebender.mintbase.testnet",
        "public_key": "ed25519:9rRQXn3dXqNf5ZffyCkToNAVimGeH47jfZ4HoxXTbCkc",
        "from_index": 0,
        "limit": 10
    }' --accountId yoooooooooooooooooooo.testnet
else
    echo "Error: Contract name file does not exist."
    exit 1
fi

'''
'''--- open-secret-contract/scripts/views/get-public-keys.sh ---
#!/bin/bash

# Path to the file containing the contract name
CONTRACT_NAME_FILE="./neardev/dev-account"

# Check if the contract name file exists
if [ -f "$CONTRACT_NAME_FILE" ]; then
    # Read the contract name from the file
    CONTRACT_NAME=$(cat "$CONTRACT_NAME_FILE")
    echo "Contract Name: $CONTRACT_NAME"

    # Now you can use the CONTRACT_NAME variable to run your near view command
    near view $CONTRACT_NAME get_public_keys '{
        "token_id": "1",
        "from_index": 0,
        "limit": 10
    }' --accountId yoooooooooooooooooooo.testnet
else
    echo "Error: Contract name file does not exist."
    exit 1
fi
'''
'''--- open-secret-contract/scripts/views/get-tokens-by-public-key.sh ---

#!/bin/bash

# Path to the file containing the contract name
CONTRACT_NAME_FILE="./neardev/dev-account"

# Check if the contract name file exists
if [ -f "$CONTRACT_NAME_FILE" ]; then
    # Read the contract name from the file
    CONTRACT_NAME=$(cat "$CONTRACT_NAME_FILE")
    echo "Contract Name: $CONTRACT_NAME"

    # Now you can use the CONTRACT_NAME variable to run your near view command
    near view $CONTRACT_NAME get_tokens_by_public_key '{
        "public_key": "ed25519:8LXEySyBYewiTTL2jfGTSYcZsDjpRJ4hRm1fS3WJ4MdH",
        "from_index": 0,
        "limit": 10
    }' --accountId yoooooooooooooooooooo.testnet
else
    echo "Error: Contract name file does not exist."
    exit 1
fi
'''
'''--- open-secret-contract/src/lib.rs ---
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata,
    NonFungibleTokenMetadataProvider,
    NFT_METADATA_SPEC,
    TokenMetadata,
};
use std::convert::TryInto;
use near_sdk::PublicKey;
use near_sdk::collections::Vector;
use near_sdk::serde::{ Deserialize, Serialize };
use near_sdk::collections::LookupMap;
use near_contract_standards::non_fungible_token::{ Token, TokenId };
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize };
use near_sdk::collections::LazyOption;
use near_sdk::{
    env,
    near_bindgen,
    AccountId,
    BorshStorageKey,
    PanicOnDefault,
    Promise,
    PromiseOrValue,
};

#[derive(
    Debug,
    Clone,
    Serialize,
    Deserialize,
    PartialEq,
    Eq,
    BorshDeserialize,
    BorshSerialize,
    Default
)]
pub struct OpenSecretMetadata {
    uri: String,
    sha256: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, BorshDeserialize, BorshSerialize)]
pub struct EncryptedMetadata {
    public_key: PublicKey,
    signer_public_key: PublicKey,
    metadata: OpenSecretMetadata,
    nonce: String,
    sha256: String,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    private_metadata: LookupMap<TokenId, Vector<EncryptedMetadata>>,
    tokens_by_public_key: LookupMap<PublicKey, Vector<TokenId>>,
    used_nonce_hash_pairs: LookupMap<String, bool>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str =
    "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    PrivateMetadata,
    TokensByPublicKeyIndex,
    UsedNonceHashPairs,
    PrivateMetadataByTokenId(TokenId),
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(owner_id, NFTContractMetadata {
            spec: NFT_METADATA_SPEC.to_string(),
            name: "Open Secret".to_string(),
            symbol: "OS".to_string(),
            icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
            base_uri: None,
            reference: None,
            reference_hash: None,
        })
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval)
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            private_metadata: LookupMap::new(StorageKey::PrivateMetadata),
            tokens_by_public_key: LookupMap::new(StorageKey::TokensByPublicKeyIndex),
            used_nonce_hash_pairs: LookupMap::new(StorageKey::UsedNonceHashPairs),
        }
    }

    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata
    ) -> Token {
        self.tokens.internal_mint(token_id, receiver_id, Some(token_metadata))
    }

    pub fn add_metadata(&mut self, token_id: TokenId, metadata: EncryptedMetadata) {
        // Get the Token data which includes the owner's account ID
        let token = self.tokens.nft_token(token_id.clone()).expect("Token not found");

        let nonce_hash_key = format!("{}-{}", metadata.nonce, metadata.sha256);

        assert!(
            !self.used_nonce_hash_pairs.contains_key(&nonce_hash_key),
            "Nonce and hash pair already used"
        );

        // Ensure that the sender of the transaction is the owner of the token
        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Only the owner of the token can add metadata"
        );

        let mut token_ids = self.tokens_by_public_key
            .get(&metadata.public_key)
            .unwrap_or_else(|| Vector::new(StorageKey::TokensByPublicKeyIndex));

        token_ids.push(&token_id);
        self.tokens_by_public_key.insert(&metadata.public_key, &token_ids);

        let mut metadata_vector = self.private_metadata
            .get(&token_id)
            .unwrap_or_else(|| Vector::new(StorageKey::PrivateMetadataByTokenId(token_id.clone())));
        metadata_vector.push(&metadata);

        self.private_metadata.insert(&token_id, &metadata_vector);
        self.used_nonce_hash_pairs.insert(&nonce_hash_key, &true);
    }

    pub fn remove_metadata(&mut self, token_id: TokenId, public_key: PublicKey) {
        // Get the Token data to check the owner
        let token = self.tokens.nft_token(token_id.clone()).expect("Token not found");

        // Ensure that the sender of the transaction is the owner of the token
        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Only the owner of the token can remove metadata"
        );

        // Retrieve the metadata vector, if it exists
        if let Some(metadatas) = self.private_metadata.get(&token_id) {
            let initial_len = metadatas.len(); // `len()` returns `u64` already, no need to cast.

            // Filter out metadata that matches the public key
            let mut new_metadatas = Vector::new(b"m".to_vec());
            for index in 0..initial_len {
                let metadata = metadatas.get(index).unwrap(); // Directly using `u64` index
                if metadata.public_key != public_key {
                    new_metadatas.push(&metadata);
                }
            }

            // If any metadata was removed (i.e., new vector is smaller), save the changes
            if (new_metadatas.len() as u64) != initial_len {
                // Compare both as u64
                self.private_metadata.insert(&token_id, &new_metadatas);
            }
        }

        // Similarly, update the tokens_by_public_key map
        if let Some(token_ids) = self.tokens_by_public_key.get(&public_key) {
            let initial_len = token_ids.len() as u64; // Convert usize to u64 if needed

            let mut new_token_ids = Vector::new(b"t".to_vec());
            for index in 0..initial_len {
                let id = token_ids.get((index as usize).try_into().unwrap()).unwrap();
                if id != token_id {
                    new_token_ids.push(&id);
                }
            }

            // If any token ids were removed (i.e., new vector is smaller), save the changes
            if (new_token_ids.len() as u64) != initial_len {
                // Compare both as u64
                if new_token_ids.is_empty() {
                    self.tokens_by_public_key.remove(&public_key);
                } else {
                    self.tokens_by_public_key.insert(&public_key, &new_token_ids);
                }
            }
        }
    }

    pub fn remove_all_metadata(&mut self, token_id: TokenId) {
        let token = self.tokens.nft_token(token_id.clone()).expect("Token not found");

        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Only the owner of the token can remove all metadata"
        );

        let metadata_removed = self.private_metadata.remove(&token_id);

        assert!(metadata_removed.is_some(), "No metadata found to remove");
    }

    pub fn get_tokens_by_public_key(
        &self,
        public_key: PublicKey,
        from_index: Option<u64>,
        limit: Option<u64>
    ) -> Vec<TokenId> {
        let tokens_vector = self.tokens_by_public_key.get(&public_key).unwrap_or_else(|| {
            Vector::new(b"t".to_vec()) // You can use a unique prefix for the new Vector
        });

        let start_index = from_index.unwrap_or(0);

        // Set the limit for how many items we will return at most.
        // The limit is the minimum of the requested limit and a pre-defined maximum limit.
        let limit = limit.unwrap_or(50).min(50); // for example, enforce a max limit of 50

        // Collect the token IDs within the specified range
        (start_index..start_index + limit).filter_map(|index| tokens_vector.get(index)).collect()
    }

    // Retrieves a list of encrypted metadata entries for a given token ID
    // and public key starting from the specified index cursor and limited by the limit.
    pub fn get_private_metadata_by_key_paginated(
        &self,
        token_id: TokenId,
        public_key: PublicKey,
        from_index: Option<u64>, // Cursor: Start from this index (inclusive)
        limit: u64 // How many items to return
    ) -> Vec<EncryptedMetadata> {
        let metadata_vector = self.private_metadata.get(&token_id);
        if let Some(metadata_vector) = metadata_vector {
            let start_index = from_index.unwrap_or(0);
            metadata_vector
                .iter()
                .skip(start_index as usize)
                .take(limit as usize)
                .filter(|metadata| metadata.public_key == public_key)
                .collect()
        } else {
            vec![]
        }
    }

    pub fn get_private_metadata_paginated(
        &self,
        token_id: TokenId,
        from_index: Option<u64>,
        limit: Option<u64> // How many items to return
    ) -> Vec<EncryptedMetadata> {
        let metadata_vector = self.private_metadata
            .get(&token_id)
            .unwrap_or_else(|| {
                Vector::new(StorageKey::PrivateMetadataByTokenId(token_id.clone()))
            });

        // Determine the starting index
        let start_index = from_index.unwrap_or(0);

        // Determine the limit for how many items to return at most
        let limit = limit.unwrap_or(50).min(50); // Enforce a max limit of 50

        // Collect the metadata entries within the specified range
        metadata_vector
            .iter()
            .skip(start_index as usize)
            .take(limit as usize)
            .collect()
    }

    pub fn get_public_keys(
        &self,
        token_id: TokenId,
        from_index: u64,
        limit: u64
    ) -> Vec<PublicKey> {
        // Assume `metadatas` is a `Vector<EncryptedMetadata>`
        let metadatas: Vector<EncryptedMetadata> = self.private_metadata
            .get(&token_id)
            .unwrap_or_else(|| Vector::new(StorageKey::PrivateMetadataByTokenId(token_id.clone())));

        // Calculate end index respecting the length of the vector and the given limit
        let end_index = std::cmp::min(from_index + limit, metadatas.len());

        // Collect the range of public keys
        (from_index..end_index)
            .filter_map(|index| { metadatas.get(index).map(|metadata| metadata.public_key) })
            .collect()
    }

    pub fn has_public_key_access(&self, token_id: TokenId, public_key: PublicKey) -> bool {
        // Assume `metadatas` is a `Vector<EncryptedMetadata>`
        let metadatas: Vector<EncryptedMetadata> = self.private_metadata
            .get(&token_id)
            .unwrap_or_else(|| Vector::new(StorageKey::PrivateMetadataByTokenId(token_id.clone())));

        // Iterate over the vector and check if any metadata matches the public key
        (0..metadatas.len()).any(|index| {
            if let Some(metadata) = metadatas.get(index) {
                metadata.public_key == public_key
            } else {
                false
            }
        })
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{ accounts, VMContextBuilder };
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(MINT_STORAGE_COST)
                .predecessor_account_id(accounts(0))
                .build()
        );

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(MINT_STORAGE_COST)
                .predecessor_account_id(accounts(0))
                .build()
        );
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(1)
                .predecessor_account_id(accounts(0))
                .build()
        );
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .account_balance(env::account_balance())
                .is_view(true)
                .attached_deposit(0)
                .build()
        );
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(MINT_STORAGE_COST)
                .predecessor_account_id(accounts(0))
                .build()
        );
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(150000000000000000000)
                .predecessor_account_id(accounts(0))
                .build()
        );
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .account_balance(env::account_balance())
                .is_view(true)
                .attached_deposit(0)
                .build()
        );
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(MINT_STORAGE_COST)
                .predecessor_account_id(accounts(0))
                .build()
        );
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(150000000000000000000)
                .predecessor_account_id(accounts(0))
                .build()
        );
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(1)
                .predecessor_account_id(accounts(0))
                .build()
        );
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .account_balance(env::account_balance())
                .is_view(true)
                .attached_deposit(0)
                .build()
        );
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(MINT_STORAGE_COST)
                .predecessor_account_id(accounts(0))
                .build()
        );
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(150000000000000000000)
                .predecessor_account_id(accounts(0))
                .build()
        );
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .attached_deposit(1)
                .predecessor_account_id(accounts(0))
                .build()
        );
        contract.nft_revoke_all(token_id.clone());
        testing_env!(
            context
                .storage_usage(env::storage_usage())
                .account_balance(env::account_balance())
                .is_view(true)
                .attached_deposit(0)
                .build()
        );
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''
'''--- open-secret-dashboard/.eslintrc.json ---
{
  "extends": "next/core-web-vitals"
}

'''
'''--- open-secret-dashboard/README.md ---
# Open Secret

Mintbase template with to generate Stability.ai images and mint them to Near instantly.

<img width="900" alt="image" src="https://github.com/Markeljan/open-secret/assets/12901349/eb061e45-04b6-4cd6-bb1e-7f5c1f7f39ac">

## Getting Started

First, add necessary environment variables.

Next, create a contract on testnet.mintbase.xyz

Deploy a proxy minter contract using this repo:
[mintbase/minsta-contract](https://github.com/Mintbase/minsta-contract)

Finally, add the proxy contract as a minter on your Mintbase dashboard.

**Note  if deploying to prod this requires pro or higher on vercel to support serverless functions > 15 seconds 

Run the development server:

```bash
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

- make sure to add your environment variables

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

.
'''
'''--- open-secret-dashboard/app/globals.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {

    --gradient: linear-gradient(to top left, #56ab2f, #a8e063);

    --background: 107 37.05% 3.44%;
    --foreground: 107 5.699999999999999% 97.15%;

    --muted: 107 28.499999999999996% 12.9%;
    --muted-foreground: 107 5.699999999999999% 54.3%;

    --popover: 107 53.6% 5.59%;
    --popover-foreground: 107 5.699999999999999% 97.15%;

    --card: 107 53.6% 5.59%;
    --card-foreground: 107 5.699999999999999% 97.15%;

    --border: 107 28.499999999999996% 12.9%;
    --input: 107 28.499999999999996% 12.9%;

    --primary: 107 57% 43%;
    --primary-foreground: 107 5.699999999999999% 97.15%;

    --secondary: 107 28.499999999999996% 12.9%;
    --secondary-foreground: 107 5.699999999999999% 97.15%;

    --accent: 107 28.499999999999996% 12.9%;
    --accent-foreground: 107 5.699999999999999% 97.15%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 107 5.699999999999999% 97.15%;

    --ring: 107 57% 43%;

    --radius: 0.3rem;
  }

  .dark {
    --gradient: linear-gradient(to top left, #434343, #000000);

    --background: 0 0% 2.08%;
    --foreground: 0 0% 96.3%;

    --muted: 0 0% 7.800000000000001%;
    --muted-foreground: 0 0% 52.6%;

    --popover: 0 65% 3.38%;
    --popover-foreground: 0 0% 96.3%;

    --card: 0 65% 3.38%;
    --card-foreground: 0 0% 96.3%;

    --border: 0 0% 7.800000000000001%;
    --input: 0 0% 7.800000000000001%;

    --primary: 0 0% 26%;
    --primary-foreground: 0 0% 96.3%;

    --secondary: 0 0% 7.800000000000001%;
    --secondary-foreground: 0 0% 96.3%;

    --accent: 0 0% 7.800000000000001%;
    --accent-foreground: 0 0% 96.3%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 96.3%;

    --ring: 0 0% 26%;

    --radius: 0.3rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }
}
'''
'''--- open-secret-dashboard/components.json ---
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
'''
'''--- open-secret-dashboard/lib/constants.ts ---
const appName: string = process.env.NEXT_PUBLIC_APP_TITLE || "MINTBASE";
const callbackUrl: string = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
const network = process.env.NEXT_PUBLIC_NETWORK || "mainnet";

const tokenContractAddress =
    process.env.NEXT_PUBLIC_NFT_CONTRACT_ADDRESS || "open-secret.mintspace2.testnet";

const mintbaseBaseUrl =
    process.env.NEXT_PUBLIC_BASE_URL || "https://mintbase.xyz";

const mintbaseWalletUrl =
    process.env.NEXT_PUBLIC_MINTBASE_WALLET_URL ||
    "https://wallet.mintbase.xyz";

const twitterText =
    process.env.NEXT_PUBLIC_TWITTER ||
    "Instantly%20mint%20your%20AI%20%%20creations%20%at%20%%Open%20%Secret%20%40Mintbase%20%40NEARProtocol%20%23BOS%20%23NEAR%0aMint%20yours%20here%3A%20https%3A%2F%2Fminsta.mintbase.xyz";

export const constants = {
    appName,
    callbackUrl,
    tokenContractAddress,
    network,
    mintbaseBaseUrl,
    mintbaseWalletUrl,
    twitterText,
    isClosed: process.env.NEXT_PUBLIC_MINTING_CLOSED === "true" || false,
    showRewards: process.env.NEXT_PUBLIC_SHOW_REWARDS === "true" || false,
};

'''
'''--- open-secret-dashboard/lib/data/fetch.ts ---

export const REQUEST_HEADERS = {
    "Cache-Control": "public, max-age=31536000, immutable",
    "mb-api-key": "omni-site",
};

export enum REQUEST_METHODS {
    get = "GET",
    post = "POST",
}

export const REQUEST_OPTIONS = (method: REQUEST_METHODS) => {
    return { method: method, headers: REQUEST_HEADERS };
};

export const fetchApi = async <T>(
    url: string,
    method: REQUEST_METHODS
): Promise<T | any> => {
    try {
        const result = await fetch(url, REQUEST_OPTIONS(method));

        if (result) {
            return await result.json();
        }
    } catch (error) {
        console.error(error);
    }
};
'''
'''--- open-secret-dashboard/lib/data/get-blocked-nfts.ts ---
import { REQUEST_METHODS, fetchApi } from "@/lib/data/fetch";

export const getBlockedNfts = async (): Promise<any> => {
    const fetchUrl = `https://surface-api-z3w7d7dnea-ew.a.run.app/blocked-nfts`;

    return fetchApi(fetchUrl, REQUEST_METHODS.get);
};

'''
'''--- open-secret-dashboard/lib/data/graphql-service.ts ---
import { nearEndpoints } from '@/lib/data/network'
import { constants } from "@/lib/constants";
import request from "graphql-request";

export type GqlFetchResult<T> = {
    data?: T;
    error?: string;
};

export const graphqlQLServiceNew = async ({
    query,
    variables,
    network,
    customUrl,
}: {
    query: any;
    variables?: Record<string, unknown>;
    network?: "testnet" | "mainnet";
    customUrl?: string;
}) => {
    const net = network ?? constants.network;
    const isTestnet = net === "testnet";

    const baseUrl = customUrl ? customUrl : isTestnet
        ? nearEndpoints.testnet.graph
        : nearEndpoints.mainnet.graph;

    const headers = {
        "content-type": "application/json",
        "mb-api-key": "anon",
        "Access-Control-Allow-Origin": "*",
        ...(customUrl && { "X-Hasura-Role": "dataplatform_near" }),

    };

    const queryLoad = () => request(baseUrl, query, variables, headers);

    return await queryLoad();
};

export const graphQLService = async ({
    query,
    variables,
    network,
    customUrl,
}: {
    query: any;
    variables?: Record<string, unknown>;
    network?: "testnet" | "mainnet";
    customUrl?: string;
}) => {
    try {
        const data = await graphQlFetch(query, variables, network, customUrl).then(
            async (data: Response) => {
                const res = await data.json();
                return res.data;
            }
        );

        return { data };
    } catch (error) {
        console.log(error, "error");
        return { error: `Query Error: ${error}` };
    }
};

export const graphQlFetch = async (
    query: string,
    variables: any,
    network?: "testnet" | "mainnet",
    customUrl?: string
): Promise<Response> => {
    const net = network ?? constants.network;
    const isTestnet = net === "testnet";

    const baseUrl = customUrl ? customUrl : isTestnet
        ? nearEndpoints.testnet.graph
        : nearEndpoints.mainnet.graph;

    const res = fetch(baseUrl, {
        method: "POST",
        body: JSON.stringify({
            query: query,
            variables: variables,
        }),
        headers: {
            "content-type": "application/json",
            "mb-api-key": "omni-site",
            ...(customUrl && { "X-Hasura-Role": "dataplatform_near" }),
        },
    });

    return await res;
};

'''
'''--- open-secret-dashboard/lib/data/hash.ts ---
export const sha256 = async (message: string) => {
  // Encode the string into a Uint8Array, which is like a buffer
  const msgBuffer = new TextEncoder().encode(message);

  // Hash the message
  const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);

  // Convert the ArrayBuffer to hex string
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
  return hashHex;
};

'''
'''--- open-secret-dashboard/lib/data/near-rpc-functions.ts ---

import { RPC_ENDPOINTS } from "@mintbase-js/sdk";
import { constants } from "@/lib/constants";

export const requestFromNearRpc = async (
    body: Record<string, any>
): Promise<Record<string, any> | undefined> => {
    const fetchUrl = RPC_ENDPOINTS[constants.network as "testnet" | "mainnet"];

    const res = await fetch(fetchUrl, {
        method: "POST",
        body: JSON.stringify(body),
        headers: { "Content-type": "application/json" },
    });

    return res.json();
};

export const callViewMethod = async ({
    contractId,
    method,
    args,
}: {
    contractId: string;
    method: string;
    args?: Record<string, any>;
}): Promise<any> => {
    const args_base64 = args
        ? Buffer.from(JSON.stringify(args), "utf-8").toString("base64")
        : "";

    const res = await requestFromNearRpc({
        jsonrpc: "2.0",
        id: "dontcare",
        method: "query",
        params: {
            request_type: "call_function",
            finality: "final",
            account_id: contractId,
            method_name: method,
            args_base64,
        },
    });

    if (res?.error) {
        throw res.error;
    }

    const parsed = JSON.parse(Buffer.from(res?.result?.result).toString());
    return parsed;
};

'''
'''--- open-secret-dashboard/lib/data/network.ts ---
export const nearEndpoints = {
    testnet: {
        graph: "https://graph.mintbase.xyz/testnet",
    },
    mainnet: {
        graph: "https://graph.mintbase.xyz/",
    },
};

'''
'''--- open-secret-dashboard/lib/data/posts-graphql.ts ---
import { gql } from 'graphql-request';

export const getPostsQuery = gql`
  query MyQuery($accountId: String!) {
    dataplatform_near_social_feed_posts(
      where: { account_id: { _eq: $accountId } }
      limit: 10
    ) {
      id
      content
    }
  }
`;
'''
'''--- open-secret-dashboard/lib/data/use-graphql-query.ts ---

import { useQuery, type QueryObserverResult } from '@tanstack/react-query'
import { graphqlQLServiceNew } from '@/lib/data/graphql-service'

interface UseGraphQlQueryResult {
    data: any
    error: any
    isLoading: boolean
    refetch: () => Promise<QueryObserverResult<unknown, unknown>>
    isFetching: boolean
    status: 'error' | 'success' | 'loading'
}

export interface GQLQueryOptions {
    queryName: string
    query: string
    variables: Record<string, any>
    queryOpts?: any
    queryParams?: any[]
    customUrl?: string
}

export const useGraphQlQuery = ({
    queryName,
    query,
    variables,
    queryOpts = {},
    queryParams = [],
    customUrl,
}: GQLQueryOptions): UseGraphQlQueryResult => {
    const queryObj =
        queryParams.length > 0 ? [queryName, ...queryParams] : [queryName]

    const { data, error, isLoading, refetch, isFetching, status } = useQuery(
        queryObj,
        () => graphqlQLServiceNew({ query, variables, customUrl }),
        queryOpts
    )

    return { data, error, isLoading, refetch, isFetching, status }
}

'''
'''--- open-secret-dashboard/lib/fonts.ts ---
import { JetBrains_Mono as FontMono, Inter as FontSans } from 'next/font/google'

export const fontSans = FontSans({
    subsets: ['latin'],
    variable: '--font-sans'
})

export const fontMono = FontMono({
    subsets: ['latin'],
    variable: '--font-mono'
})
'''
'''--- open-secret-dashboard/lib/functions/schemas.ts ---
import { ChatRequestOptions } from 'ai'

export const functionSchemas: ChatRequestOptions['functions'] = [
  {
    name: 'text_to_image',
    description: `This function generates an image from text.  Return the value as an image in markdown.`,
    parameters: {
      type: 'object',
      properties: {
        text: {
          type: 'string',
          description: 'Text to generate an image from text.'
        }
      },
      required: ['text']
    }
  }
]

'''
'''--- open-secret-dashboard/lib/hooks/use-blocked-nfts.ts ---
import { getBlockedNfts } from "@/lib/data/get-blocked-nfts";
import { useQuery } from "@tanstack/react-query";

export const useBlockedNfts = () => {
    const { data: blockedNfts } = useQuery(
        ["q_getBlockedNfts"],
        () => getBlockedNfts(),
        {
            initialData: null, // Set initial data as null
            refetchInterval: 30000, // Automatically refetch every 120000 (2mins)
        }
    );

    return { blockedNfts };
};
'''
'''--- open-secret-dashboard/lib/hooks/use-is-client-mounted.ts ---
'use client'

import { useEffect, useState } from "react";

export default function useIsClientMounted() {
    const [isClientMounted, setIsClientMounted] = useState(false);
    useEffect(() => {
        setIsClientMounted(true);
    }, []);

    return isClientMounted;
};

'''
'''--- open-secret-dashboard/lib/hooks/use-profile.ts ---
import { useState, useEffect } from 'react';
import { ProfileData } from '@/lib/types';

export function useProfile(accountId?: string) {
    const [profileData, setProfileData] = useState<ProfileData | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    useEffect(() => {
        async function fetchData() {
            setIsLoading(true);
            const requestOptions: RequestInit = {
                method: 'POST',
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    "keys": [`${accountId}/profile/**`],
                }),
            };

            try {
                const response = await fetch("https://api.near.social/get", requestOptions);
                if (!response.ok) {
                    throw new Error(`HTTP error: ${response.status}`);
                }
                const data = await response.json();
                const formattedData = accountId ? data[accountId].profile : data

                // append accountId to the profile data
                formattedData["accountId"] = accountId;

                setProfileData(formattedData);
            } catch (error: any) {
                console.error(error);
            } finally {
                setIsLoading(false);
            }
        }

        fetchData();
    }, [accountId]);

    return { profileData, isLoading };
}

'''
'''--- open-secret-dashboard/lib/types.ts ---
export type ProfileData = {
    accountId: string;
    name: string;
    description: string;
    linktree: {
        twitter: string;
        github: string;
        telegram: string;
        website: string;
    };
    image: {
        ipfs_cid?: string;
        nft?: {
            contractId: string;
            tokenId: string;
        };
    };
    backgroundImage: {
        ipfs_cid: string;
    };
    tags: {
        [key: string]: string;
    };
}
'''
'''--- open-secret-dashboard/lib/utils.ts ---
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export const generateRandomId = (length: number) => {
  let result = "";
  const characters =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
};

export const toGatewayUrl = (ipfsCid: string) => {
  return `https://ipfs.near.social/ipfs/${ipfsCid}`
  // return `https://ipfs.io/ipfs/${ipfsCid}`
  // return `https:${ipfsCid}.ipfs.nftstorage.link`;
  // return `https:cloudflare-ipfs.com/ipfs/${ipfsCid}`;
}

// if given a string ensure it ends in .near if not add it
export const toNearAccount = (accountId: string) => {
  if (accountId.endsWith(".near")) {
    return accountId
  } else {
    return `${accountId}.near`
  }
}

'''
'''--- open-secret-dashboard/next.config.js ---
const { hostname } = require('os');

/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        hostname: "**.nftstorage.link"
      },
      {
        hostname: "ipfs.io"
      },
      {
        hostname: "cloudflare-ipfs.com"
      },
      {
        protocol: "https",
        hostname: "ipfs.near.social"
      }
    ]
  },
  webpack(config) {
    // eslint-disable-next-line no-param-reassign
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false, // https://stackoverflow.com/a/67478653/470749
    };

    return config;
  },

  experimental: {
    webpackBuildWorker: true
  },
};

module.exports = nextConfig;
'''
'''--- open-secret-dashboard/package.json ---
{
  "name": "open-secret",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@mintbase-js/data": "0.5.0-beta.2",
    "@mintbase-js/react": "0.5.0-beta.2",
    "@mintbase-js/rpc": "0.5.0-beta.2",
    "@mintbase-js/sdk": "0.5.0-beta.2",
    "@mintbase-js/storage": "0.5.0-beta.2",
    "@near-js/biometric-ed25519": "^0.3.0",
    "@near-wallet-selector/modal-ui": "^8.7.1",
    "@nearfoundation/near-js-encryption-box": "^0.1.2",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-checkbox": "^1.0.4",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-icons": "^1.3.0",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-separator": "^1.0.3",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@tanstack/react-query": "^4.36.1",
    "@tanstack/react-table": "^8.10.7",
    "ai": "^2.2.13",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "graphql-request": "^6.1.0",
    "lucide-react": "^0.279.0",
    "nanoid": "^5.0.3",
    "near-api-js": "^2.1.4",
    "next": "^14.0.1",
    "next-themes": "^0.2.1",
    "openai": "^4.16.1",
    "openai-edge": "^1.2.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hot-toast": "^2.4.1",
    "react-intersection-observer": "^9.5.2",
    "react-markdown": "^8.0.7",
    "react-syntax-highlighter": "^15.5.0",
    "react-textarea-autosize": "^8.5.2",
    "remark-gfm": "^3.0.1",
    "remark-math": "^5.1.1",
    "shadcn-ui": "^0.4.0"
  },
  "devDependencies": {
    "@types/node": "^20.7.2",
    "@types/react": "^18.2.23",
    "@types/react-dom": "^18.2.8",
    "@types/react-syntax-highlighter": "^15.5.7",
    "autoprefixer": "^10.4.16",
    "encoding": "^0.1.13",
    "eslint": "^8.50.0",
    "eslint-config-next": "^14.0.1",
    "isomorphic-unfetch": "3.0.0",
    "postcss": "^8.4.31",
    "tailwind-merge": "^1.14.0",
    "tailwindcss": "^3.3.3",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.2.2",
    "usehooks-ts": "^2.9.1"
  }
}
'''
'''--- open-secret-dashboard/postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

'''
'''--- open-secret-dashboard/public/next.svg ---
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
'''
'''--- open-secret-dashboard/public/vercel.svg ---
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
'''
'''--- open-secret-dashboard/tailwind.config.ts ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
	],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
'''
'''--- open-secret-dashboard/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "forceConsistentCasingInFileNames": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

'''