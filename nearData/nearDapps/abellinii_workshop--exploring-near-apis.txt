*GitHub Repository "abellinii/workshop--exploring-near-apis"*

'''--- challenges/apps/playground/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting to the NEAR platform</title>
    <!-- to connect to the NEAR platform, include a reference to near-api-js -->
    <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.23.2/dist/near-api-js.min.js"></script>
    <script>
      // configure network settings and key storage
      const config = {
        networkId: "default", // this can be any label to namespace user accounts
        nodeUrl: "https://rpc.testnet.near.org", // this endpoint must point to the network you want to reach
        walletUrl: "http://wallet.testnet.near.org", // this endpoint must exist for the wallet to work
        deps: {
          keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(), // keys are stored as plaintext in LocalStorage
        },
      };

      // open a connection to the NEAR platform
      (async function () {
        window.near = await nearApi.connect(config); // connect to the NEAR platform
        window.wallet = new nearApi.WalletAccount(window.near); // instantiate a new wallet

        // ---------------------------------------------------------------------------
        // here you have access to `near-api-js` and a valid connection object `near`
        //
        // we've added them to the window object to make working in the console convenient
        // ---------------------------------------------------------------------------
      })(window);
    </script>
  </head>
  <body>
    <h2><code>near-api-js</code> client-side challenge</h2>

    To run through this demo you will need to open your
    <a href="https://javascript.info/devtools">JavaScript Developer Console</a
    ><br />
    <strong>(Press Cmd+Opt+J or, if youâ€™re on Windows, then F12)</strong>

    <blockquote>
      <em>
        "There are two ways to write error-free programs; only the third one
        works."<br />
        (Alan J. Perlis)
      </em>
    </blockquote>
  </body>
</html>

'''
'''--- contracts/01.greeting/__tests__/greeting.simulate.spec.js ---
const { Runtime } = require("near-sdk-as/runtime");
const path = require("path");

const WASM_FILE = path.join(__dirname, "/../../../out/greeting.wasm");

describe("Greeting ", () => {
  const users = ["alice", "bob", "carol"];
  const messages = ["awesomesauce!", "yashilsin!", "beleza!"];

  let runtime;
  let greeting;

  beforeAll(() => {
    runtime = new Runtime();
    greeting = runtime.newAccount("greeting", WASM_FILE);

    accounts = users
      .map((name) => runtime.newAccount(name))
      .reduce((acc, user) => {
        acc[user.account_id] = user;
        return acc;
      }, {});
  });

  afterEach(() => {
    greeting.state = {};
  });

  describe("View methods", () => {
    it("responds to showYouKnow()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "view",
          name: "showYouKnow",
        },
      };

      const { result } = simulate(transaction);

      expectToFind("showYouKnow() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to sayHello()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "view",
          name: "sayHello",
        },
      };

      const { result, data } = simulate(transaction);

      expect(data).toEqual("Hello!");
      expectToFind("sayHello() was called", {
        inArray: result.outcome.logs,
      });
    });

    describe("responds to getAllMessages()", () => {
      it("works with 0 messages", () => {
        const transaction = {
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        const { result, data } = simulate(transaction);

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });

      it("works with 1 message", () => {
        sendMessage(accounts.alice, { message: messages[0] });

        const transaction = {
          signer: accounts.alice,
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        // useful for visualizing contract state
        // console.log(greeting.state);

        const { result, data } = simulate(transaction);

        expectToFind("alice says awesomesauce!", {
          inArray: data,
        });

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });

      it("works with many messages", () => {
        let expectedMessages = [];

        Object.keys(accounts).map((user, idx) => {
          let signer = accounts[user];
          let message = messages[idx];

          sendMessage(signer, { message });
          expectedMessages.push(`${signer.account_id} says ${message}`);
        });

        const transaction = {
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        // useful for visualizing contract state
        // console.log(greeting.state);

        const { result, data } = simulate(transaction);

        expectedMessages.map((message) => {
          expectToFind(message, {
            inArray: data,
          });
        });

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });
    });
  });

  describe("Call methods", () => {
    it("responds to sayMyName()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "sayMyName",
        },
      };

      const { data, result } = simulate(transaction);

      expect(data).toEqual(`Hello, ${accounts.alice.account_id}!`);
      expectToFind("sayMyName() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to saveMyName()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "saveMyName",
        },
      };

      const { result } = simulate(transaction);

      // "c2VuZGVy" is " in base64
      // "YWxpY2U=" is "alice" in base64
      expect(result.state).toHaveProperty("sender", "alice");

      expectToFind("saveMyName() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to saveMyMessage()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "saveMyMessage",
          params: { message: "awesomesauce" },
        },
      };

      const { data, result } = simulate(transaction);

      expect(data).toBeTruthy();

      // "bWVzc2FnZXM6Oi0x" is  in base64
      // "YWxpY2Ugc2F5cyBhd2Vzb21lc2F1Y2Uh" is "alice says awesomesauce" in base64
      expect(result.state).toHaveProperty(
        "messages::-1",
        "alice says awesomesauce"
      );

      expectToFind("saveMyMessage() was called", {
        inArray: result.outcome.logs,
      });
    });
  });

  // ---------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------

  function sendMessage(signer, params) {
    const transaction = {
      signer,
      contract: greeting,
      method: {
        type: "view",
        name: "saveMyMessage",
        params,
      },
    };

    const { data } = simulate(transaction);

    expect(data).toBeTruthy();
  }

  function expectToFind(target, { inArray }) {
    if (inArray) {
      expect(inArray).toEqual(expect.arrayContaining([target]));
    }
  }

  function simulate({ signer, contract, method }, printResponse = false) {
    let response;

    if (signer) {
      response = signer.call_other(
        contract.account_id,
        method.name,
        method.params
      );
    } else {
      response = contract[method.type](method.name, method.params);
    }

    if (printResponse) {
      console.log("\n\n------ Near VM Response ------");
      console.log(JSON.stringify(response, null, 2));
    }

    return {
      data: response.return_data,
      error: response.err,
      result: response.result,
      results: response.results,
      calls: response.calls,
    };
  }

  function getContext() {
    return {
      input: "{}",
      output_data_receivers: [],
      prepaid_gas: 10 ** 15,
      attached_deposit: "0",
      is_view: false,
      block_index: 1,
      block_timestamp: 1585778575325000000,
      epoch_height: 1,
      storage_usage: 100,
      random_seed: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
      current_account_id: "alice",
      signer_account_id: "alice",
      predecessor_account_id: "bob",
      account_balance: "1000",
      signer_account_pk: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
      account_locked_balance: "10",
    };
  }
});

'''
'''--- contracts/04.cross-contract-calls/__tests__/cross-contract-calls.simulate.spec.js ---
const { Runtime, encodeBs64 } = require("near-sdk-as/runtime");
const path = require("path");

const sentencesWasm = path.join(__dirname, "/../../../out/sentences.wasm");
const wordsWasm = path.join(__dirname, "/../../../out/words.wasm");

let runtime, alice, sentences, words;

describe("cross contract calls", () => {
  beforeEach(() => {
    runtime = new Runtime();
    alice = runtime.newAccount("alice");
    sentences = runtime.newAccount("sentences", sentencesWasm);
    words = runtime.newAccount("words.examples", wordsWasm);
  });

  function addWord(text) {
    return alice.call_other("sentences", "SetWord", {
      word: { text },
    });
  }

  test("single promise", () => {
    let res = alice.call_other("sentences", "reverseWordOne");
    expect(res.return_data.text).toBe("elpmas");
  });

  test("promise + then with no arguments", () => {
    let res = alice.call_other("sentences", "reverseWordTwo");
    expect(res.return_data).toBe(true);
  });
  test("promise + then with arguments", () => {
    let res = alice.call_other("sentences", "reverseWordThree");
    expect(res.return_data).toBe(true);
  });

  test("add to storage", () => {
    addWord("hello");
    expect(sentences.storage_usage).toBeGreaterThan(0);
  });

  test("read from storage with default", () => {
    const word = sentences.view("GetWord").return_data;
    expect(word.text).toBe("DEFAULT");
    expect(sentences.state["word"]).toBe(undefined);
  });
  test("read from storage", () => {
    addWord("hello");
    const word = sentences.view("GetWord").return_data;
    expect(word.text).toBe("hello");
    expect(sentences.state["word"]).toStrictEqual(word);
  });

  test("setting state", () => {
    let state = { word: { lang: "en-us", text: "hello" } };
    sentences.state = state;
    sentences.reset();
    let { result } = addWord("hello");
    expect(result.state).toStrictEqual(state);
  });
});

'''
'''--- contracts/as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- contracts/compile.js ---
const compile = require("near-sdk-as/compiler").compile;
const fs = require("fs");
const path = require("path");

scanProjects().map(compileContract);

// ----------------------------------------------------------------------------
// Helper functions for the code above
// ----------------------------------------------------------------------------

function compileContract(fqPath) {
  const folder = fqPath.replace(`${__dirname}/`, "");
  const name = folder
    .replace(/(a-z)*\/main\.ts/, "")
    .split(/[\.\/]/)
    .pop();

  const output = `out/${name}.wasm`;

  console.log(`\ncompiling contract [ ${folder} ] to [ ${output} ]`);

  compile(
    fqPath, // input file
    output, // output file
    [
      "-O3z",
      "--debug", // Shows debug output
      "--measure", // shows compiler run time
      "--runPasses",
      "inlining-optimizing,dce", // inlines to optimize and removes deadcode
    ],
    {
      verbose: false, // Output the cli args passed to asc
    }
  );

  reportFilesize(output);
}

function scanProjects() {
  let filter = "main.ts";

  const target = process.argv.pop();
  if (target !== __filename) {
    filter = target;
  }

  return readDirR(path.resolve(__dirname)) // only AssemblyScript files
    .filter((fqPath) => fqPath.includes(filter)) // ignore cross contract calls
    .filter((fqPath) => fqPath.includes("main.ts")); // just the contract entry points
}

function reportFilesize(fqPath) {
  const stats = fs.statSync(fqPath);
  console.log(`Filesize   :    ${stats.size / 1000.0} kb`);
}

/**
 * List all files in a directory recursively in a synchronous fashion
 * adapted from https://gist.github.com/kethinov/6658166#gistcomment-2109513
 * @param {string} dir top level to begin recursive descent through gstall subfolders
 */
function readDirR(dir) {
  return fs.statSync(dir).isDirectory()
    ? [].concat(...fs.readdirSync(dir).map((f) => readDirR(path.join(dir, f))))
    : dir;
}

'''