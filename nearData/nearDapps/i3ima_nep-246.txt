*GitHub Repository "i3ima/nep-246"*

'''--- Cargo.toml ---
[package]
name = "nep-246"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0-pre.7"
serde = "1"
serde_json = "1"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.7"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- README.md ---
# WIP Implementation of [NEP-246](https://github.com/near/NEPs/issues/246) for NEAR Protocol

## What's done

* Approvals, Metadata, Enumeration extenstions
* Transfers
* Resolvers & receivers

## What's not

* Tests
* Burn
'''
'''--- examples/approval-receiver/Cargo.toml ---
[package]
name = "nep-246-ccc"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
nep-246 = { path = "../../" }
near-sdk = "4.0.0-pre.6"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- examples/approval-receiver/scripts/build.sh ---
#!/bin/bash
set -e

OUT_DIR=out

if [ ! -d $OUT_DIR ]; then
    echo "Creating '${OUT_DIR}' directory"
    mkdir $OUT_DIR;
fi

# Because we include bytes from FT contract we need to build it before factory

cargo build --release
cp target/wasm32-unknown-unknown/release/nep_246_ccc.wasm $OUT_DIR
'''
'''--- examples/approval-receiver/src/lib.rs ---
use near_sdk::{near_bindgen, borsh::{self, BorshDeserialize, BorshSerialize}, PanicOnDefault, AccountId, env, PromiseOrValue};
use nep_246::multi_token::{approval::MultiTokenApprovalReceiver, token::TokenId};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default data and the owner ID
        that's passed in
    */
    #[init]
    pub fn new() -> Self {
        Self {
            
        }
    }
}

#[near_bindgen]
impl MultiTokenApprovalReceiver for Contract {
    fn on_approve(
        &mut self,
        tokens: Vec<TokenId>,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) -> PromiseOrValue<String> {

        env::log_str(format!("Tokens: {:?} Owner: {}, approval_id: {}", tokens, owner_id, approval_id).as_str());
        env::log_str(&msg);

        PromiseOrValue::Value("yeeeeeeeeeeeeeeee".to_string())
    }
}
'''
'''--- examples/multi-token/Cargo.toml ---
[package]
name = "nep-246-test"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
nep-246 = { path = "../../" }
near-sdk = "4.0.0-pre.6"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- examples/multi-token/rustfmt.toml ---
use_small_heuristics = "Max"
'''
'''--- examples/multi-token/scripts/build.sh ---
#!/bin/bash
set -e

OUT_DIR=out

if [ ! -d $OUT_DIR ]; then
    echo "Creating '${OUT_DIR}' directory"
    mkdir $OUT_DIR;
fi

# Because we include bytes from FT contract we need to build it before factory

cargo build --release
cp target/wasm32-unknown-unknown/release/nep_246_test.wasm $OUT_DIR
'''
'''--- examples/multi-token/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::Promise;
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, BorshStorageKey, PanicOnDefault, PromiseOrValue,
};
use nep_246::multi_token::metadata::MT_METADATA_SPEC;
use nep_246::multi_token::token::{Token, TokenId};
use nep_246::multi_token::{
    core::MultiToken,
    metadata::{MtContractMetadata, TokenMetadata},
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: MultiToken,
    metadata: LazyOption<MtContractMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    MultiToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        let metadata = MtContractMetadata {
            spec: MT_METADATA_SPEC.to_string(),
            name: "Test".to_string(),
            symbol: "OMG".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        };

        Self::new(owner_id, metadata)
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: MtContractMetadata) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();

        Self {
            tokens: MultiToken::new(
                StorageKey::MultiToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    #[payable]
    pub fn mt_mint(
        &mut self,
        token_owner_id: AccountId,
        token_metadata: TokenMetadata,
        amount: Balance,
    ) -> Token {
        assert_eq!(env::predecessor_account_id(), self.tokens.owner_id, "Unauthorized");
        self.tokens.internal_mint(token_owner_id, Some(amount), Some(token_metadata), None)
    }

    pub fn register(&mut self, token_id: TokenId, account_id: AccountId) {
        self.tokens.internal_register_account(&token_id, &account_id)
    }
}

nep_246::impl_multi_token_core!(Contract, tokens);
nep_246::impl_multi_token_approval!(Contract, tokens);
nep_246::impl_multi_token_enumeration!(Contract, tokens);
'''
'''--- src/event.rs ---
use near_sdk::env;
use serde::Serialize;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    Nep246(crate::multi_token::events::Nep246Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

'''
'''--- src/lib.rs ---
#![allow(clippy::too_many_arguments)]
#![allow(clippy::ptr_arg)]
#![allow(unused_variables)]

//! NEP-246 Implementation
//!
//! NOTES:
//! * All amounts, balances and allowance are limited by U128 (max value 2**128 - 1).
//! * Token standard uses JSON for serialization of arguments and results.
//! * Amounts in arguments and results are serialized as Base-10 strings, e.g. "100". This is done to avoid JSON limitation of max integer value of 2**53.
//! * The contract must track the change in storage when adding to and removing from collections. This is not included in this core multi token standard but instead in the Storage Standard.
//! * To prevent the deployed contract from being modified or deleted, it should not have any access keys on its account.
pub mod multi_token;
pub mod event;
'''
'''--- src/multi_token/approval/approval_impl.rs ---
use std::collections::HashMap;
use near_sdk::{assert_one_yocto, env, ext_contract, AccountId, Balance, Promise, require};
use near_sdk::json_types::U128;

use crate::multi_token::{
    core::{MultiToken, GAS_FOR_MT_TRANSFER_CALL},
    token::{Approval, TokenId},
    utils::{bytes_for_approved_account_id, expect_extension, refund_deposit, Entity, unauthorized_assert},
};
use crate::multi_token::approval::{MAX_APPROVALS_PER_TOKEN, TokenApproval};

use super::MultiTokenApproval;

const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_approval_receiver)]
pub trait MultiTokenReceiver {
    fn mt_on_approve(&mut self,
                     token_ids: Vec<TokenId>,
                     amounts: Vec<U128>,
                     owner_id: AccountId,
                     approval_ids: Vec<u64>,
                     msg: String);
}

impl MultiToken {
    fn internal_approve(&mut self, account_id: &AccountId, token_id: TokenId, amount: &Balance) -> Approval {
        // Unwrap to check if approval supported
        let approvals_by_id = expect_extension(self.approvals_by_id.as_mut(), Entity::Token);
        let approvals_number_by_id = self.approvals_number_by_id.as_mut().unwrap();

        let approvals_number = approvals_number_by_id.get(&token_id).unwrap_or_default();

        // Check for approvals limit
        assert!(approvals_number + 1 < MAX_APPROVALS_PER_TOKEN, "Token reached approvals limit");

        // Get owner & caller
        let owner_id = self.owner_by_id.get(&token_id).expect("This token does not exist");

        // Check if caller is authorized
        unauthorized_assert(&owner_id);

        // Get the balance to check if user have enough tokens
        let balance = self.balances_per_token.get(&token_id).unwrap().get(&owner_id).unwrap_or(0);

        require!(&balance >= amount, "Not enough balance to approve");

        // Get some IDs and check if approval management supported both for contract & token
        let next_id = expect_extension(self.next_approval_id_by_id.as_mut(), Entity::Token);
        let mut current_next_id =
            expect_extension(next_id.get(&token_id), Entity::Token);

        let new_approval = Approval { amount: amount.to_owned(), approval_id: current_next_id };
        env::log_str(format!("New approval: {:?}", new_approval).as_str());

        // Get approvals for this token
        let approvals = &mut approvals_by_id.get(&token_id).unwrap_or_default();
        let old_approval_id = approvals.insert(account_id.clone(), new_approval.clone());

        // Update count
        let old_approvals_number = approvals_number_by_id.get(&token_id).unwrap();
        approvals_number_by_id.insert(&token_id, &(old_approvals_number + 1));

        approvals_by_id.insert(&token_id, approvals);

        env::log_str(format!("Updated approvals by id: {:?}", old_approval_id).as_str());

        let used_storage =
            if old_approval_id.is_none() { bytes_for_approved_account_id(account_id) } else { 0 };

        refund_deposit(used_storage);

        current_next_id += 1;

        new_approval
    }

    fn internal_revoke(&mut self, token_id: TokenId, account_id: &AccountId) {
        // It's impossible that token does not have owner, so i'll just unwrap the value
        let owner = self.owner_by_id.get(&token_id).unwrap();

        unauthorized_assert(&owner);

        // Get all approvals for token, will panic if approval extension is not used for contract or token
        let approvals = expect_extension(self.approvals_by_id.as_mut(), Entity::Contract);
        let mut approvals_by_token = expect_extension(approvals.get(&token_id), Entity::Token);

        let approvals_number = self.approvals_number_by_id.as_mut().unwrap();
        let old_number = approvals_number.get(&token_id).unwrap_or_default();

        // Remove approval for user & also clean map to save space it it's empty
        approvals_by_token.remove(account_id);
        approvals_number.insert(&token_id, &(old_number - 1));

        if approvals_by_token.is_empty() {
            approvals.remove(&token_id);
        }
    }
}

impl MultiTokenApproval for MultiToken {
    fn mt_approve(
        &mut self,
        account_id: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        msg: Option<String>,
    ) -> Option<Promise> {
        assert_one_yocto();

        let amounts_to: Vec<Balance> = amounts.iter().map(|a| a.0).collect();

        let approval_ids: Vec<u64> = token_ids.clone().into_iter().enumerate().map(|(id, token_id)|
            self.internal_approve(&account_id, token_id, &amounts_to[id]).approval_id
        ).collect();

        // Check if msg present and then call `mt_on_approve`
        msg.map(|msg| ext_approval_receiver::mt_on_approve(
                token_ids,
                amounts,
                account_id.clone(),
                approval_ids,
                msg,
                account_id,
                NO_DEPOSIT,
                env::prepaid_gas() - GAS_FOR_MT_TRANSFER_CALL,
            ))
    }

    fn mt_revoke(&mut self, token_ids: Vec<TokenId>, account_id: AccountId) {
        assert_one_yocto();

        token_ids.into_iter()
            .for_each(|token_id| self.internal_revoke(token_id, &account_id));
    }

    fn mt_revoke_all(&mut self, token: Vec<String>) {
        todo!()
    }

    fn mt_is_approved(
        &self,
        token_ids: Vec<String>,
        approved_account_id: AccountId,
        amounts: Vec<U128>,
        approval_ids: Option<Vec<u64>>,
    ) -> bool {
        let approvals = expect_extension(self.approvals_by_id.as_ref(), Entity::Contract);

        let amounts_to: Vec<u128> = amounts.iter().map(|a| a.0).collect();

        let results: Vec<bool> = token_ids.into_iter().enumerate().map(|(idx, token_id)| {
            let by_token = approvals.get(&token_id).unwrap_or_default();

            match by_token.get(&approved_account_id) {
                Some(approve) => {
                    let approval_id = approval_ids.as_ref().unwrap().get(idx);

                    if approve.amount.eq(&amounts_to[idx]) {
                        match approval_id {
                            Some(approval) => approve.approval_id.eq(approval),
                            None => true,
                        }
                    } else {
                        false
                    }
                }
                None => false
            }
        }).collect();

        results.contains(&false)

    }

    fn mt_token_approval(&self, token_id: TokenId, account_id: AccountId) -> TokenApproval {
        let approvals = expect_extension(self.approvals_by_id.as_ref(), Entity::Contract);
        let by_token = expect_extension(approvals.get(&token_id), Entity::Token);
        let by_account: (AccountId, Approval) = by_token.into_iter().find(|(account, _)| account == &account_id)
            .expect("This account does not have approvals in this token");
        let owner = self.owner_by_id.get(&token_id).unwrap();

        TokenApproval {
            approval_owner_id: owner,
            approved_account_ids: HashMap::from([by_account])
        }
    }

    fn mt_token_approvals(&self, token_id: TokenId, from_index: U128, limit: u128) -> Vec<TokenApproval> {
        let approvals = expect_extension(self.approvals_by_id.as_ref(), Entity::Contract);
        let owner = self.owner_by_id.get(&token_id).unwrap();
        approvals.get(&token_id).unwrap().into_iter().skip(from_index.0 as usize).take(limit as usize)
            .map(|approval| {
                TokenApproval {
                    approval_owner_id: owner.clone(),
                    approved_account_ids: HashMap::from([approval]),
                }
            }).collect()
    }
}

'''
'''--- src/multi_token/approval/mod.rs ---
mod approval_impl;
mod receiver;

use std::collections::HashMap;
pub use approval_impl::*;
pub use receiver::*;

use crate::multi_token::token::{Approval, TokenId};
use near_sdk::{AccountId, Promise};
use near_sdk::json_types::U128;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

/// Limit for amount of approvals
/// See - https://github.com/shipsgold/NEPs/blob/master/specs/Standards/MultiToken/ApprovalManagement.md#why-must-mt_approve-panic-if-mt_revoke_all-would-fail-later
pub const MAX_APPROVALS_PER_TOKEN: usize = 99;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenApproval {
    approval_owner_id: AccountId,
    approved_account_ids: HashMap<AccountId, Approval>,
}

/// Trait used in approval management
/// Specs - https://github.com/shipsgold/NEPs/blob/master/specs/Standards/MultiToken/ApprovalManagement.md
pub trait MultiTokenApproval {
    /// Add an approved account for a specific set of tokens.
    ///
    /// Requirements
    /// * Caller of the method must attach a deposit of at least 1 yoctoⓃ for
    ///   security purposes
    /// * Contract MAY require caller to attach larger deposit, to cover cost of
    ///   storing approver data
    /// * Contract MUST panic if called by someone other than token owner
    /// * Contract MUST panic if addition would cause `mt_revoke_all` to exceed
    ///   single-block gas limit. See below for more info.
    /// * Contract MUST increment approval ID even if re-approving an account
    /// * If successfully approved or if had already been approved, and if `msg` is
    ///   present, contract MUST call `mt_on_approve` on `account_id`. See
    ///   `mt_on_approve` description below for details.
    ///
    /// # Arguments:
    /// * `token_ids`: the token ids for which to add an approval
    /// * `account_id`: the account to add to `approved_account_ids`
    /// * `amounts`: the number of tokens to approve for transfer, wrapped in quotes and treated
    ///    like an array of string, although the numbers will be stored as an array of
    ///    unsigned integer with 128 bits.
    ///
    /// * `msg`: optional string to be passed to `mt_on_approve`
    ///
    /// # Returns
    /// void, if no `msg` given. Otherwise, returns promise call to
    /// `mt_on_approve`, which can resolve with whatever it wants.
    fn mt_approve(
        &mut self,
        account_id: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        msg: Option<String>,
    ) -> Option<Promise>;

    /// Revoke an approved account for a specific token.
    ///
    /// # Requirements:
    /// * Caller of the method must attach a deposit of 1 yoctoⓃ for security
    ///   purposes
    /// * If contract requires >1yN deposit on `mt_approve`, contract
    ///   MUST refund associated storage deposit when owner revokes approval
    /// * Contract MUST panic if called by someone other than token owner
    ///
    /// # Arguments:
    /// * `token_ids`: the token for which to revoke approved_account_ids
    /// * `account_id`: the account to remove from `approvals`
    fn mt_revoke(&mut self, token_ids: Vec<TokenId>, account_id: AccountId);

    /// Revoke all approved accounts for a specific token.
    ///
    /// # Requirements:
    /// * Caller of the method must attach a deposit of 1 yoctoⓃ for security
    ///   purposes
    /// * If contract requires >1yN deposit on `mt_approve`, contract
    ///   MUST refund all associated storage deposit when owner revokes approved_account_ids
    /// * Contract MUST panic if called by someone other than token owner
    ///
    /// # Arguments:
    /// * `token_ids`: the token ids with approved_account_ids to revoke
    fn mt_revoke_all(&mut self, token_ids: Vec<TokenId>);

    /// Check if tokens are approved for transfer by a given account, optionally
    /// checking an approval_id
    ///
    /// # Requirements:
    /// * Contract MUST panic if `approval_ids` is not null and the length of
    ///   `approval_ids` is not equal to `token_ids`
    ///
    /// # Arguments:
    /// * `token_ids`: the tokens for which to check an approval
    /// * `approved_account_id`: the account to check the existence of in `approved_account_ids`
    /// * `amounts`: specify the positionally corresponding amount for the `token_id`
    ///    that at least must be approved. The number of tokens to approve for transfer,
    ///    wrapped in quotes and treated like an array of string, although the numbers will be
    ///    stored as an array of unsigned integer with 128 bits.
    /// * `approval_ids`: an optional array of approval IDs to check against
    ///    current approval IDs for given account and `token_ids`.
    ///
    /// # Returns:
    /// if `approval_ids` is given, `true` if `approved_account_id` is approved with given `approval_id`
    /// and has at least the amount specified approved  otherwise, `true` if `approved_account_id`
    /// is in list of approved accounts and has at least the amount specified approved
    /// finally it returns false for all other states
    fn mt_is_approved(
        &self,
        token_ids: Vec<TokenId>,
        approved_account_id: AccountId,
        amounts: Vec<U128>,
        approval_ids: Option<Vec<u64>>,
    ) -> bool;

    /// Get a the list of approvals for a given token_id and account_id
    ///
    /// # Arguments:
    /// * `token_id`: the token for which to check an approval
    /// * `account_id`: the account to retrieve approvals for
    ///
    /// # Returns:
    /// A TokenApproval object, as described in Approval Management standard
    fn mt_token_approval(&self, token_id: TokenId, account_id: AccountId) -> TokenApproval;

    /// Get a list of all approvals for a given token_id
    ///
    /// # Arguments:
    /// * `from_index`: a string representing an unsigned 128-bit integer,
    ///    representing the starting index of tokens to return
    /// * `limit`: the maximum number of tokens to return
    ///
    /// # Returns:
    /// An array of TokenApproval objects, as described in Approval Management standard, and an empty array if there are no approvals
    fn mt_token_approvals(&self, token_id: TokenId, from_index: U128, limit: u128) -> Vec<TokenApproval>;
}

'''
'''--- src/multi_token/approval/receiver.rs ---
use crate::multi_token::token::TokenId;
use near_sdk::AccountId;
use near_sdk::json_types::U128;

/// Approval receiver is the trait for the method called (or attempted to be called) when an MT contract adds an approval for an account.
pub trait MultiTokenApprovalReceiver {
    /// Respond to notification that contract has been granted approval for a token.
    ///
    /// # Notes:
    /// * Contract knows the token contract ID from `predecessor_account_id`
    ///
    /// # Arguments:
    /// * `token_ids`: the token_ids to which this contract has been granted approval
    /// * `amounts`: the ositionally corresponding amount for the token_id
    ///    that at must be approved. The number of tokens to approve for transfer,
    ///    wrapped in quotes and treated like an array of string, although the numbers will be
    ///    stored as an array of unsigned integer with 128 bits.
    /// * `owner_id`: the owner of the token
    /// * `approval_ids`: the approval ID stored by NFT contract for this approval.
    ///    Expected to be a number within the 2^53 limit representable by JSON.
    /// * `msg`: specifies information needed by the approved contract in order to
    ///    handle the approval. Can indicate both a function to call and the
    ///    parameters to pass to that function.
    fn mt_on_approve(
        &mut self,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        owner_id: AccountId,
        approval_ids: Vec<u64>,
        msg: String,
    ) -> near_sdk::PromiseOrValue<String>;
}

'''
'''--- src/multi_token/core/core_impl.rs ---
use crate::multi_token::core::{ApprovalId, MultiTokenCore, MultiTokenResolver};
use crate::multi_token::events::{MtBurn, MtMint, MtTransfer};
use crate::multi_token::metadata::TokenMetadata;
use crate::multi_token::token::{Approval, Token, TokenId};
use crate::multi_token::utils::refund_deposit_to_account;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, TreeMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::{
    assert_one_yocto, env, ext_contract, log, require, AccountId, Balance, BorshStorageKey,
    CryptoHash, Gas, IntoStorageKey, PromiseOrValue, PromiseResult, StorageUsage,
};
use std::collections::HashMap;

pub const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
pub const GAS_FOR_MT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_self)]
trait MtResolver {
    fn mt_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        approvals: Option<Vec<(AccountId, ApprovalId, U128)>>,
    ) -> Vector<Balance>;
}

#[ext_contract(ext_receiver)]
pub trait MultiTokenReceiver {
    fn mt_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: Vec<AccountId>,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        msg: String,
    ) -> PromiseOrValue<Balance>;
}

/// Implementation of the multi-token standard
/// Allows to include NEP-246 compatible tokens to any contract.
/// There are next traits that any contract may implement:
///     - MultiTokenCore -- interface with transfer methods. MultiToken provides methods for it.
///     - MultiTokenApproval -- interface with approve methods. MultiToken provides methods for it.
///     - MultiTokenEnumeration -- interface for getting lists of tokens. MultiToken provides methods for it.
///     - MultiTokenMetadata -- return metadata for the token in NEP-246, up to contract to implement.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MultiToken {
    /// Owner of contract
    pub owner_id: AccountId,

    /// How much storage takes every token
    pub extra_storage_in_bytes_per_emission: StorageUsage,

    /// Owner of each token
    pub owner_by_id: TreeMap<TokenId, AccountId>,

    /// Total supply for each token
    pub total_supply: LookupMap<TokenId, Balance>,

    /// Metadata for each token
    pub token_metadata_by_id: Option<LookupMap<TokenId, TokenMetadata>>,

    /// All tokens owned by user
    pub tokens_per_owner: Option<LookupMap<AccountId, UnorderedSet<TokenId>>>,

    /// Balance of user for given token
    pub balances_per_token: UnorderedMap<TokenId, LookupMap<AccountId, u128>>,

    /// All approvals of user
    pub approvals_by_id: Option<LookupMap<TokenId, HashMap<AccountId, Approval>>>,

    /// Number of approvals for [Token]. Used for limiting maximum number of approvals
    pub approvals_number_by_id: Option<LookupMap<TokenId, usize>>,

    /// Next id of approval
    pub next_approval_id_by_id: Option<LookupMap<TokenId, u64>>,

    /// Next id for token
    pub next_token_id: u64,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    PerOwner,
    TokensPerOwner { account_hash: Vec<u8> },
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    OwnerById,
    OwnerByIdInner { account_id_hash: CryptoHash },
    TokenMetadata,
    Approvals,
    ApprovalById,
    ApprovalsInner { account_id_hash: CryptoHash },
    TotalSupply { supply: u128 },
    Balances,
    BalancesInner { token_id: Vec<u8> },
}

impl MultiToken {
    pub fn new<Q, R, S, T>(
        owner_by_id_prefix: Q,
        owner_id: AccountId,
        token_metadata_prefix: Option<R>,
        enumeration_prefix: Option<S>,
        approval_prefix: Option<T>,
    ) -> Self
        where
            Q: IntoStorageKey,
            R: IntoStorageKey,
            S: IntoStorageKey,
            T: IntoStorageKey,
    {
        let (approvals_by_id, next_approval_id_by_id, approvals_number_by_id) = if let Some(prefix) = approval_prefix {
            let prefix: Vec<u8> = prefix.into_storage_key();
            (
                Some(LookupMap::new(prefix.clone())),
                Some(LookupMap::new([prefix.clone(), "n".into()].concat())),
                Some(LookupMap::new(prefix))
            )
        } else {
            (None, None, None)
        };

        Self {
            owner_id,
            extra_storage_in_bytes_per_emission: 0,
            owner_by_id: TreeMap::new(StorageKey::OwnerById),
            total_supply: LookupMap::new(StorageKey::TotalSupply { supply: u128::MAX }),
            token_metadata_by_id: token_metadata_prefix.map(LookupMap::new),
            tokens_per_owner: enumeration_prefix.map(LookupMap::new),
            balances_per_token: UnorderedMap::new(StorageKey::Balances),
            approvals_by_id,
            approvals_number_by_id,
            next_approval_id_by_id,
            next_token_id: 0,
        }
    }

    /// Used to get balance of specified account in specified token
    pub fn internal_unwrap_balance_of(
        &self,
        token_id: &TokenId,
        account_id: &AccountId,
    ) -> Balance {
        match self
            .balances_per_token
            .get(token_id)
            .expect("This token does not exist")
            .get(account_id)
        {
            Some(balance) => balance,
            None => {
                env::panic_str(format!("The account {} is not registered", account_id).as_str())
            }
        }
    }

    /// Add to balance of user specified amount
    pub fn internal_deposit(
        &mut self,
        token_id: &TokenId,
        account_id: &AccountId,
        amount: Balance,
    ) {
        let balance = self.internal_unwrap_balance_of(token_id, account_id);
        if let Some(new) = balance.checked_add(amount) {
            let mut balances = self.balances_per_token.get(token_id).unwrap();
            balances.insert(account_id, &new);
            self.total_supply.insert(
                token_id,
                &self
                    .total_supply
                    .get(token_id)
                    .unwrap()
                    .checked_add(amount)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow")),
            );
        } else {
            env::panic_str("Balance overflow");
        }
    }

    /// Subtract specified amount from user account in given token
    pub fn internal_withdraw(
        &mut self,
        token_id: &TokenId,
        account_id: &AccountId,
        amount: Balance,
    ) {
        let balance = self.internal_unwrap_balance_of(token_id, account_id);
        if let Some(new) = balance.checked_sub(amount) {
            let mut balances = self.balances_per_token.get(token_id).unwrap();
            balances.insert(account_id, &new);
            self.total_supply.insert(
                token_id,
                &self
                    .total_supply
                    .get(token_id)
                    .unwrap()
                    .checked_sub(amount)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow")),
            );
        } else {
            env::panic_str("The account doesn't have enough balance");
        }
    }

    pub fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        approval_id: Option<u64>,
        amount: Balance,
    ) -> (AccountId, Option<HashMap<AccountId, Approval>>) {
        // Safety checks
        require!(sender_id != receiver_id);
        require!(amount > 0);

        let owner_of_token = self.owner_by_id.get(token_id).expect("Token not found");

        let approvals = self
            .approvals_by_id
            .as_mut()
            .and_then(|by_id| by_id.remove(token_id));

        let owner_id = if sender_id != &owner_of_token {
            let approved_accounts = approvals.as_ref().expect("Unauthorized");

            let approval = approved_accounts.get(sender_id);

            if approval.is_none() {
                env::panic_str("Sender not approved");
            }

            require!(
                approval_id.is_none() || approval.unwrap().approval_id == approval_id.unwrap(),
                "The actual approval_id is different from given"
            );
            Some(sender_id)
        } else {
            Some(sender_id)
        };

        require!(
            owner_id.unwrap() != receiver_id,
            "Sender and receiver must differ"
        );

        let owner_id = owner_id.unwrap();

        self.internal_withdraw(token_id, owner_id, amount);
        self.internal_deposit(token_id, receiver_id, amount);

        MultiToken::emit_transfer(
            owner_id,
            receiver_id,
            token_id,
            amount,
            Some(sender_id),
            None,
        );

        (owner_id.to_owned(), approvals)
    }

    pub fn internal_batch_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_ids: &Vec<TokenId>,
        approval_ids: Vec<Option<u64>>,
        amounts: Vec<Balance>,
    ) -> Vec<(AccountId, Option<HashMap<AccountId, Approval>>)> {
        token_ids.iter().enumerate().map(|(idx, token)| {
            let amount: Balance = amounts[idx];
            let approval = approval_ids[idx];
            self.internal_transfer(sender_id, receiver_id, token, approval, amount)
        }).collect()
    }

    pub fn internal_register_account(&mut self, token_id: &TokenId, account_id: &AccountId) {
        if self
            .balances_per_token
            .get(token_id)
            .unwrap()
            .insert(account_id, &0)
            .is_some()
        {
            env::panic_str("The account is already registered");
        }
    }

    pub fn internal_mint(
        &mut self,
        owner_id: AccountId,
        owner_amount: Option<Balance>,
        metadata: Option<TokenMetadata>,
        refund_id: Option<AccountId>,
    ) -> Token {
        let token =
            self.internal_mint_with_refund(owner_id.clone(), owner_amount, metadata, refund_id);
        MultiToken::emit_mint(&owner_id, &token.token_id, &token.supply, None);

        token
    }

    /// Mint a new token without checking:
    /// * Whether the caller id is equal to the `owner_id`
    /// * `refund_id` will transfer the leftover balance after storage costs are calculated to the provided account.
    ///   Typically, the account will be the owner. If `None`, will not refund. This is useful for delaying refunding
    ///   until multiple tokens have been minted.
    ///
    /// Returns the newly minted token and does not emit the mint event. This allows minting multiple before emitting.
    pub fn internal_mint_with_refund(
        &mut self,
        token_owner_id: AccountId,
        owner_amount: Option<Balance>,
        token_metadata: Option<TokenMetadata>,
        refund_id: Option<AccountId>,
    ) -> Token {
        // Remember current storage usage if refund_id is Some
        let initial_storage_usage = refund_id.map(|account_id| (account_id, env::storage_usage()));

        // Panic if contract is using metadata extension and caller must provide it
        if self.token_metadata_by_id.is_some() && token_metadata.is_none() {
            env::panic_str("MUST provide metadata");
        }

        // Increment next id of the token. Panic if it's overflowing u64::MAX
        self.next_token_id
            .checked_add(1)
            .expect("u64 overflow, cannot mint any more tokens");

        let token_id: TokenId = self.next_token_id.to_string();

        // If contract uses approval management create new LookupMap for approvals
        self.next_approval_id_by_id
            .as_mut()
            .and_then(|internal| internal.insert(&token_id, &0));

        // Alias
        let owner_id: AccountId = token_owner_id;

        // Insert new owner
        self.owner_by_id.insert(&token_id, &owner_id);

        // Insert new metadata
        self.token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &token_metadata.clone().unwrap()));

        // Insert new supply
        self.total_supply.insert(&token_id, &u128::MAX);

        // Insert new balance
        let mut new_set: LookupMap<AccountId, u128> = LookupMap::new(StorageKey::BalancesInner {
            token_id: env::sha256(token_id.as_bytes()),
        });
        new_set.insert(&owner_id, &owner_amount.unwrap_or(0));
        self.balances_per_token.insert(&token_id, &new_set);

        // Updates enumeration if extension is used
        if let Some(per_owner) = &mut self.tokens_per_owner {
            let mut token_ids = per_owner.get(&owner_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(owner_id.as_bytes()),
                })
            });
            token_ids.insert(&token_id);
            per_owner.insert(&owner_id, &token_ids);
        }

        // Stuff for Approval Management extension, also check for presence of it first
        let approved_account_ids = if self.approvals_by_id.is_some() {
            Some(HashMap::new())
        } else {
            None
        };

        if let Some((id, usage)) = initial_storage_usage {
            refund_deposit_to_account(env::storage_usage() - usage, id);
        }

        Token {
            token_id,
            owner_id,
            supply: u128::MAX,
            balances: HashMap::new(),
            metadata: token_metadata,
            approvals: approved_account_ids,
            next_approval_id: Some(0),
        }
    }

    fn emit_transfer(
        owner_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &str,
        amount: Balance,
        sender_id: Option<&AccountId>,
        memo: Option<String>,
    ) {
        MtTransfer {
            old_owner_id: owner_id,
            new_owner_id: receiver_id,
            token_ids: &[token_id],
            amounts: &[&amount.to_string()],
            authorized_id: sender_id.filter(|sender_id| *sender_id == owner_id),
            memo: memo.as_deref(),
        }
            .emit();
    }

    fn emit_mint(owner_id: &AccountId, token_id: &TokenId, amount: &Balance, memo: Option<String>) {
        MtMint {
            owner_id,
            token_ids: &[token_id],
            amounts: &[&amount.to_string()],
            memo: memo.as_deref(),
        }
            .emit()
    }

    // TODO: Use this for `mt_burn()`
    fn emit_burn(owner_id: &AccountId, token_id: &TokenId, amount: &Balance, memo: Option<String>) {
        MtBurn {
            owner_id,
            authorized_id: Some(owner_id),
            token_ids: &[token_id],
            amounts: &[&amount.to_string()],
            memo: memo.as_deref(),
        }
            .emit()
    }
}

impl MultiTokenCore for MultiToken {
    fn mt_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        amount: Balance,
        approval: Option<u64>,
    ) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        env::log_str(format!("Predecessor {}", sender_id).as_str());
        self.internal_transfer(&sender_id, &receiver_id, &token_id, approval, amount);
    }

    fn mt_batch_transfer(&mut self, receiver_id: AccountId, token_ids: Vec<TokenId>, amounts: Vec<Balance>, approvals: Vec<Option<u64>>) {
        assert_one_yocto();
        let sender = env::predecessor_account_id();
        env::log_str(format!("Predecessor {}", sender).as_str());

        self.internal_batch_transfer(&sender, &receiver_id, &token_ids, approvals, amounts);
    }

    fn mt_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        amount: Balance,
        approval_id: Option<u64>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        assert_one_yocto();

        require!(
            env::prepaid_gas() > GAS_FOR_MT_TRANSFER_CALL + GAS_FOR_RESOLVE_TRANSFER,
            "Not enough prepaid gas"
        );
        let sender_id = env::predecessor_account_id();

        let (old_owner, old_approvals) =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, approval_id, amount);

        // TODO: Add approvals list creation

        ext_receiver::mt_on_transfer(
            sender_id,
            vec![old_owner.clone()],
            vec![token_id.clone()],
            vec![amount.into()],
            msg,
            receiver_id.clone(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_MT_TRANSFER_CALL,
        )
            .then(ext_self::mt_resolve_transfer(
                old_owner,
                receiver_id,
                vec![token_id],
                vec![amount.into()],
                None,
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_RESOLVE_TRANSFER,
            ))
            .into()
    }

    fn mt_batch_transfer_call(&mut self, receiver_id: AccountId, token_ids: Vec<TokenId>, amounts: Vec<U128>, approval_ids: Vec<Option<u64>>, msg: String) -> PromiseOrValue<bool> {
        assert_one_yocto();

        require!(
            env::prepaid_gas() > GAS_FOR_MT_TRANSFER_CALL + GAS_FOR_RESOLVE_TRANSFER,
            "Not enough prepaid gas"
        );
        let sender_id = env::predecessor_account_id();

        let amounts_to = amounts.iter().map(|a| a.0).collect();

        let tuples =
            self.internal_batch_transfer(&sender_id, &receiver_id, &token_ids, approval_ids, amounts_to);

        let mut owners = vec![];

        let approvals: Vec<(AccountId, ApprovalId, U128)> = tuples.into_iter()
            .map(|(owner, approvals)| {
                owners.push(owner.clone());
                let approval = approvals.as_ref().and_then(|approvals| approvals.get(&owner)).unwrap();
                (owner, approval.approval_id, U128::from(approval.amount))
            }).collect();

        ext_receiver::mt_on_transfer(
            sender_id.clone(),
            owners,
            token_ids.clone(),
            amounts.clone(),
            msg,
            receiver_id.clone(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_MT_TRANSFER_CALL,
        )
            .then(ext_self::mt_resolve_transfer(
                sender_id,
                receiver_id,
                token_ids,
                amounts,
                Some(approvals),
                env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_RESOLVE_TRANSFER,
            ))
            .into()
    }

    fn mt_approval_for_all(&mut self, owner: AccountId, approved: bool) {
        todo!()
    }

    fn mt_balance_of(&self, owner: AccountId, id: Vec<TokenId>) -> Vec<u128> {
        self.balances_per_token
            .iter()
            .filter(|(token_id, _)| id.contains(token_id))
            .map(|(_, balances)| {
                balances
                    .get(&owner)
                    .expect("User does not have account in of the tokens")
            })
            .collect()
    }

    fn mt_token(&self, token_id: TokenId) -> Option<Token> {
        let metadata = if let Some(metadata_by_id) = &self.token_metadata_by_id {
            metadata_by_id.get(&token_id)
        } else {
            None
        };
        let next_approval_id = self.next_approval_id_by_id.as_ref().unwrap().get(&token_id);
        let supply = self.total_supply.get(&token_id)?;
        let owner_id = self.owner_by_id.get(&token_id)?;
        let approved_accounts = self
            .approvals_by_id
            .as_ref()
            .and_then(|by_id| by_id.get(&token_id).or_else(|| Some(HashMap::new())));
        let balances = self.balances_per_token.get(&token_id)?;

        Some(Token {
            token_id,
            owner_id,
            supply,
            balances: HashMap::new(),
            metadata,
            approvals: approved_accounts,
            next_approval_id,
        })
    }
}

impl MultiToken {
    pub fn internal_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver: AccountId,
        token_id: TokenId,
        amount: U128,
    ) -> (Balance, Balance) {
        let amount: Balance = amount.into();

        let unused = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            PromiseResult::Successful(value) => {
                if let Ok(unused) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed => 0,
        };

        // All this `.get()` will not fail since it would fail before it gets to this call
        if unused > 0 {
            let mut balances = self.balances_per_token.get(&token_id).unwrap();
            let receiver_balance = balances.get(&receiver).unwrap_or(0);

            if receiver_balance > 0 {
                let refund = std::cmp::min(receiver_balance, unused);
                balances.insert(&receiver, &(receiver_balance - refund));

                return if let Some(sender_balance) = balances.get(sender_id) {
                    balances.insert(sender_id, &(sender_balance + refund));
                    log!("Refund {} from {} to {}", refund, receiver, sender_id);
                    (amount - refund, 0)
                } else {
                    *self.total_supply.get(&token_id).as_mut().unwrap() -= refund;
                    log!("The account of the sender was deleted");
                    (amount, refund)
                };
            }
        }
        (amount, 0)
    }
}

impl MultiTokenResolver for MultiToken {
    fn mt_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        approvals: Option<Vec<(AccountId, ApprovalId, U128)>>,
    ) -> Vec<U128> {
        token_ids.into_iter()
            .enumerate()
            .map(|(idx, token_id)|
                self.internal_resolve_transfer(&sender_id, receiver.clone(), token_id, amounts[idx]).0.into()
            )
            .collect()
    }
}

'''
'''--- src/multi_token/core/mod.rs ---
/*! Multi-Token Implementation (ERC-1155)

 */

mod core_impl;
mod receiver;
mod resolver;

pub use self::core_impl::*;
pub use self::receiver::*;
pub use self::resolver::*;

pub type ApprovalId = u64;

use crate::multi_token::token::TokenId;
use near_sdk::{AccountId, Balance, PromiseOrValue};
use near_sdk::json_types::U128;

use super::token::Token;

/// Describes functionality according to this - https://eips.ethereum.org/EIPS/eip-1155
/// And this - <https://github.com/shipsgold/NEPs/blob/master/specs/Standards/MultiToken/Core.md>
pub trait MultiTokenCore {
    /// Make a single transfer
    ///
    /// # Arguments
    ///
    /// * `receiver_id`: Receiver of tokens
    /// * `token_id`: ID of token to send from
    /// * `amount`: How much to send
    ///
    /// returns: ()
    ///
    fn mt_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        amount: Balance,
        approval: Option<u64>,
    );

    /// Simple batch transfer. Transfer a given `token_ids` from current owner to
    /// `receiver_id`
    /// # Arguments
    ///
    /// * `receiver_id`: the valid NEAR account receiving the token
    /// * `token_ids`: the tokens to transfer
    /// * `amounts`: the number of tokens to transfer, wrapped in quotes and treated
    ///    like an array of strings, although the numbers will be stored as an array of unsigned integer
    ///    with 128 bits.
    /// * `approval`: expected approval IDs per `token_ids`. If a `token_id` does
    ///    not have a corresponding approval id then the entry in the array must be marked null.
    ///    The `approval_ids` are numbers smaller than 2^5
    ///
    /// returns: ()
    ///
    fn mt_batch_transfer(
        &mut self,
        receiver_id: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<Balance>,
        approvals: Vec<Option<u64>>);

    /// Transfer MT and call a method on receiver contract. A successful
    /// workflow will end in a success execution outcome to the callback on the MT
    /// contract at the method `resolve_transfer`.
    ///
    /// # Arguments
    ///
    /// * `receiver_id`: NEAR account receiving MT
    /// * `token_id`: Token to send
    /// * `amount`: How much to send
    /// * `approval_id`: ID of approval for signer
    /// * `memo`: Used as context
    /// * `msg`: Additional msg that will be passed to receiving contract
    ///
    /// returns: PromiseOrValue<bool>
    ///
    fn mt_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        amount: Balance,
        approval_id: Option<u64>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    /// Transfer tokens and call a method on a receiver contract. A successful
    /// workflow will end in a success execution outcome to the callback on the MT
    /// contract at the method `mt_resolve_transfer`.
    ///
    /// You can think of this as being similar to attaching native NEAR tokens to a
    /// function call. It allows you to attach any Multi Token, token in a call to a
    /// receiver contract.
    ///
    /// # Arguments
    ///
    /// * `receiver_id`: NEAR account receiving MT
    /// * `token_ids`: Tokens to transfer
    /// * `amounts`: the number of tokens to transfer, wrapped in quotes and treated
    ///    like an array of string, although the numbers will be stored as an array of
    ///    unsigned integer with 128 bits.
    /// * `approval_ids`: expected approval IDs per `token_ids`. If a `token_id` does
    ///    not have a corresponding approval id then the entry in the array must be marked null.
    ///    The `approval_ids` are numbers smaller than 2^53, and therefore representable as JSON.
    ///    ApprovalId See Approval Management standard for full explanation.
    /// * `memo`: Used as context
    /// * `msg`: Additional msg that will be passed to receiving contract
    ///
    /// returns: PromiseOrValue<bool>
    ///
    fn mt_batch_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        approval_ids: Vec<Option<u64>>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    fn mt_approval_for_all(&mut self, owner: AccountId, approved: bool);

    /// Get balance of user in specified tokens
    ///
    /// # Arguments
    ///
    /// * `owner`: Account to check
    /// # `id`: Vector of token IDs
    fn mt_balance_of(&self, owner: AccountId, id: Vec<TokenId>) -> Vec<u128>;

    /// Get all info about token
    fn mt_token(&self, token_id: TokenId) -> Option<Token>;
}

'''
'''--- src/multi_token/core/receiver.rs ---
use crate::multi_token::token::TokenId;
use near_sdk::json_types::U128;
use near_sdk::{AccountId, PromiseOrValue};

/// Used when an MT is transferred using `transfer_call`. This trait should be implemented on receiving contract
pub trait MultiTokenReceiver {
    /// Take some action after receiving a multi-token's
    ///
    /// ## Requirements:
    /// * Contract MUST restrict calls to this function to a set of whitelisted MT
    ///   contracts
    /// * Contract MUST panic if `token_ids` length does not equal `amounts`
    ///   length
    /// * Contract MUST panic if `previous_owner_ids` length does not equal `token_ids`
    ///   length
    ///
    /// ## Arguments:
    /// * `sender_id`: the sender of `transfer_call`
    /// * `previous_owner_id`: the account that owned the NFT prior to it being
    ///   transferred to this contract, which can differ from `sender_id` if using
    ///   Approval Management extension
    /// * `token_ids`: the `token_id` argument given to `transfer_call`
    /// * `amounts`: the `token_ids` argument given to `transfer_call`
    /// * `msg`: information necessary for this contract to know how to process the
    ///   request. This may include method names and/or arguments.
    ///
    /// Returns the number of unused tokens in integer form. For instance, if `amounts`
    /// is `[10]` but only 9 are needed, it will return `[1]`.
    fn mt_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: Vec<AccountId>,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        msg: String,
    ) -> PromiseOrValue<Vec<U128>>;
}

'''
'''--- src/multi_token/core/resolver.rs ---
use crate::multi_token::token::TokenId;
use near_sdk::json_types::U128;
use near_sdk::AccountId;
use crate::multi_token::core::ApprovalId;

//// `resolve_transfer` will be called after `on_transfer`
pub trait MultiTokenResolver {
    /// Finalize an `mt_transfer_call` or `mt_batch_transfer_call` chain of cross-contract calls. Generically
    /// referred to as `mt_transfer_call` as it applies to `mt_batch_transfer_call` as well.
    ///
    /// The `mt_transfer_call` process:
    ///
    /// 1. Sender calls `mt_transfer_call` on MT contract
    /// 2. MT contract transfers token from sender to receiver
    /// 3. MT contract calls `mt_on_transfer` on receiver contract
    /// 4+. [receiver contract may make other cross-contract calls]
    /// N. MT contract resolves promise chain with `mt_resolve_transfer`, and may
    ///    transfer token back to sender
    ///
    /// Requirements:
    /// * Contract MUST forbid calls to this function by any account except self
    /// * If promise chain failed, contract MUST revert token transfer
    /// * If promise chain resolves with `true`, contract MUST return token to
    ///   `sender_id`
    ///
    /// Arguments:
    /// * `sender_id`: the sender of `mt_transfer_call`
    /// * `receiver_id`: the `receiver_id` argument given to `mt_transfer_call`
    /// * `token_ids`: the `token_ids` argument given to `mt_transfer_call`
    /// * `amounts`: the `token_ids` argument given to `mt_transfer_call`
    /// * `approvals (optional)`: if using Approval Management, contract MUST provide
    ///   set of original approvals in this argument, and restore the
    ///   approved accounts in case of revert.
    ///   `approvals` is an array of expected `approval_list` per `token_ids`.
    ///   If a `token_id` does not have a corresponding `approvals_list` then the entry in the
    ///   array must be marked null.
    ///   `approvals_list` is an array of triplets of [`owner_id`,`approval_id`,`amount`].
    ///   `owner_id` is the valid Near account that owns the tokens.
    ///   `approval_id` is the expected approval ID. A number smaller than
    ///    2^53, and therefore representable as JSON. See Approval Management
    ///    standard for full explanation.
    ///   `amount`: the number of tokens to transfer, wrapped in quotes and treated
    ///    like a string, although the number will be stored as an unsigned integer
    ///    with 128 bits.
    ///
    ///
    ///
    /// Returns total amount spent by the `receiver_id`, corresponding to the `token_id`.
    /// The amounts returned, though wrapped in quotes and treated like strings,
    /// the numbers will be stored as an unsigned integer with 128 bits.
    /// Example: if sender_id calls `mt_transfer_call({ "amounts": ["100"], token_ids: ["55"], receiver_id: "games" })`,
    /// but `receiver_id` only uses 80, `mt_on_transfer` will resolve with `["20"]`, and `mt_resolve_transfer`
    /// will return `["80"]`.

    fn mt_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver: AccountId,
        token_ids: Vec<TokenId>,
        amounts: Vec<U128>,
        approvals: Option<Vec<(AccountId, ApprovalId, U128)>>,
    ) -> Vec<U128>;
}

'''
'''--- src/multi_token/enumeration/enumeration_impl.rs ---
use std::collections::HashMap;

use near_sdk::{AccountId, require};

use crate::multi_token::{core::MultiToken, token::{Token, TokenId}};

use super::MultiTokenEnumeration;

impl MultiToken {
    fn enum_get_token(&self, owner_id: AccountId, token_id: TokenId) -> Token {
        let metadata = self.token_metadata_by_id.as_ref().unwrap().get(&token_id);
        let approved_account_ids =
            Some(self.approvals_by_id.as_ref().unwrap().get(&token_id).unwrap_or_default());
        let supply = self.total_supply.get(&token_id).unwrap();
        let approvals = self.approvals_by_id.as_ref().unwrap().get(&token_id);
        let next_approval_id = self.next_approval_id_by_id.as_ref().unwrap().get(&token_id);

        Token { token_id, owner_id, metadata, approvals, supply, balances: HashMap::new(), next_approval_id }
    }
}

impl MultiTokenEnumeration for MultiToken {
    fn mt_tokens(&self, from_index: Option<u64>, limit: u64) -> Vec<Token> {
        let from_index = from_index.unwrap_or(0);

        require!(self.owner_by_id.len() > from_index, "Out of bounds");

        require!(limit !=0, "Limit cannot be 0");

        self.owner_by_id
        .iter()
        .skip(from_index as usize)
        .take(limit as usize)
        .map(|(token_id, owner_id)| self.enum_get_token(owner_id, token_id))
        .collect()
    }

    fn mt_tokens_for_owner(&self, account_id: AccountId, from_index: Option<u64>, limit: u64) -> Vec<Token> {
        let tokens_per_owner = self.tokens_per_owner.as_ref().expect("Could not find field");

        let token_set = if let Some(set) = tokens_per_owner.get(&account_id) {
            set
        } else {
            return vec![];
        };

        require!(limit != 0, "Limit cannot be 0");
        let from_index = from_index.unwrap_or(0);

        require!(token_set.len() > from_index, "Out of bounds");

        token_set
        .iter()
        .skip(from_index as usize)
        .take(limit as usize)
        .map(|token_id| self.enum_get_token(account_id.clone(), token_id))
        .collect()
    }
}
'''
'''--- src/multi_token/enumeration/mod.rs ---
use near_sdk::AccountId;

pub mod enumeration_impl;

use super::{metadata::MtContractMetadata, token::Token};

/// Enumeration extension for NEP-246
/// See specs here -> <https://github.com/shipsgold/NEPs/blob/master/specs/Standards/MultiToken/Enumeration.md>
pub trait MultiTokenEnumeration {
    /// Get a list of all tokens (with pagination)
    ///
    /// # Arguments:
    /// * `from_index` - Index to start from, defaults to 0 if not provided
    /// * `limit` - The maximum number of tokens to return
    ///
    /// returns: List of [Token]s.
    ///
    fn mt_tokens(&self, from_index: Option<u64>, limit: u64) -> Vec<Token>;

    /// Get list of all tokens by a given account
    ///
    /// # Arguments:
    /// * `account_id`: a valid NEAR account
    /// * `from_index` - Index to start from, defaults to 0 if not provided
    /// * `limit` - The maximum number of tokens to return
    ///
    /// returns: List of [Token]s owner by user
    ///
    fn mt_tokens_for_owner(&self, account_id: AccountId, from_index: Option<u64>, limit: u64) -> Vec<Token>;
}

/// The contract must implement the following view methods if using metadata extension
pub trait MultiTokenEnumerationMetadata {
    /// Get list of all base metadata for the contract
    ///
    /// Arguments:
    /// * `from_index`: a string representing an unsigned 128-bit integer,
    ///    representing the starting index of tokens to return
    /// * `limit`: the maximum number of tokens to return
    ///
    /// Returns an array of `MTBaseTokenMetadata` objects, as described in the Metadata standard, and an empty array if there are no tokens
    fn mt_tokens_base_metadata_all(&self, from_index: Option<u64>, limit: u64) -> Vec<MtContractMetadata>;
}

'''
'''--- src/multi_token/events.rs ---
use near_sdk::AccountId;
use serde::Serialize;

use crate::event::NearEvent;

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct MtMint<'a> {
    pub owner_id: &'a AccountId,
    pub token_ids: &'a [&'a str],
    pub amounts: &'a [&'a str],
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>
}

impl MtMint<'_> {
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    pub fn emit_many(data: &[MtMint<'_>]) {
        new_246_v1(Nep246EventKind::MtMint(data)).emit()
    }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct MtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub token_ids: &'a [&'a str],
    pub amounts: &'a [&'a str],
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<&'a AccountId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>
}

impl MtTransfer<'_> {
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    pub fn emit_many(data: &[MtTransfer<'_>]) {
        new_246_v1(Nep246EventKind::MtTransfer(data)).emit()
    }
}

#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct MtBurn<'a> {
    pub owner_id: &'a AccountId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<&'a AccountId>,
    pub token_ids: &'a [&'a str],
    pub amounts: &'a [&'a str],
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>
}

impl MtBurn<'_> {
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    pub fn emit_many(data: &[MtBurn<'_>]) {
        new_246_v1(Nep246EventKind::MtBurn(data)).emit()
    }
}

#[derive(Serialize, Debug)]
pub(crate) struct Nep246Event<'a> {
    version:  &'static str,
    #[serde(flatten)]
    event_kind: Nep246EventKind<'a>
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep246EventKind<'a> {
    MtMint(&'a [MtMint<'a>]),
    MtTransfer(&'a [MtTransfer<'a>]),
    MtBurn(&'a [MtBurn<'a>]),
}

fn new_246<'a>(version: &'static str, event_kind: Nep246EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep246(Nep246Event { version, event_kind })
}

fn new_246_v1(event_kind: Nep246EventKind) -> NearEvent {
    new_246("1.0.0", event_kind)
}

'''
'''--- src/multi_token/macros.rs ---
/// The core methods for a basic multi token. Extension standards may be
/// added in addition to this macro.
#[macro_export]
macro_rules! impl_multi_token_core {
    ($contract: ident, $token: ident) => {
        use $crate::multi_token::core::ApprovalId;
        use $crate::multi_token::core::MultiTokenCore;
        use $crate::multi_token::core::MultiTokenResolver;

        #[near_bindgen]
        impl MultiTokenCore for $contract {
            #[payable]
            fn mt_transfer(
                &mut self,
                receiver_id: AccountId,
                token_id: TokenId,
                amount: Balance,
                approval: Option<u64>,
            ) {
                self.$token
                    .mt_transfer(receiver_id, token_id, amount, approval)
            }

            #[payable]
            fn mt_batch_transfer(
                &mut self,
                receiver_id: AccountId,
                token_ids: Vec<TokenId>,
                amounts: Vec<Balance>,
                approval: Vec<Option<u64>>,
            ) {
                self.$token
                    .mt_batch_transfer(receiver_id, token_ids, amounts, approval)
            }

            #[payable]
            fn mt_batch_transfer_call(
                &mut self,
                receiver_id: AccountId,
                token_ids: Vec<TokenId>,
                amounts: Vec<U128>,
                approval_ids: Vec<Option<u64>>,
                msg: String,
            ) -> PromiseOrValue<bool> {
                self.$token.mt_batch_transfer_call(
                    receiver_id,
                    token_ids,
                    amounts,
                    approval_ids,
                    msg,
                )
            }

            #[payable]
            fn mt_transfer_call(
                &mut self,
                receiver_id: AccountId,
                token_id: TokenId,
                amount: Balance,
                approval_id: Option<u64>,
                msg: String,
            ) -> PromiseOrValue<bool> {
                self.$token
                    .mt_transfer_call(receiver_id, token_id, amount, approval_id, msg)
            }

            fn mt_approval_for_all(&mut self, owner_id: AccountId, approved: bool) {
                todo!()
            }

            fn mt_balance_of(&self, owner: AccountId, id: Vec<TokenId>) -> Vec<u128> {
                self.$token.mt_balance_of(owner, id)
            }

            fn mt_token(&self, token_id: TokenId) -> Option<Token> {
                self.$token.mt_token(token_id)
            }
        }

        #[near_bindgen]
        impl MultiTokenResolver for $contract {
            #[private]
            fn mt_resolve_transfer(
                &mut self,
                sender_id: AccountId,
                receiver_id: AccountId,
                token_ids: Vec<TokenId>,
                amounts: Vec<U128>,
                approvals: Option<Vec<(AccountId, ApprovalId, U128)>>,
            ) -> Vec<U128> {
                self.$token
                    .mt_resolve_transfer(sender_id, receiver_id, token_ids, amounts, approvals)
            }
        }
    };
}

/// Multi token approval management allows for an escrow system where
/// multiple approvals per token exist.
#[macro_export]
macro_rules! impl_multi_token_approval {
    ($contract: ident, $token: ident) => {
        use $crate::multi_token::approval::MultiTokenApproval;
        use $crate::multi_token::approval::TokenApproval;

        #[near_bindgen]
        impl MultiTokenApproval for $contract {
            #[payable]
            fn mt_approve(
                &mut self,
                account_id: AccountId,
                token_ids: Vec<TokenId>,
                amounts: Vec<U128>,
                msg: Option<String>,
            ) -> Option<Promise> {
                self.$token.mt_approve(account_id, token_ids, amounts, msg)
            }

            #[payable]
            fn mt_revoke(&mut self, token_ids: Vec<TokenId>, account_id: AccountId) {
                self.$token.mt_revoke(token_ids, account_id)
            }

            #[payable]
            fn mt_revoke_all(&mut self, token_ids: Vec<TokenId>) {
                self.$token.mt_revoke_all(token_ids)
            }

            fn mt_is_approved(
                &self,
                token_ids: Vec<TokenId>,
                approved_account_id: AccountId,
                amounts: Vec<U128>,
                approval_ids: Option<Vec<u64>>,
            ) -> bool {
                self.$token
                    .mt_is_approved(token_ids, approved_account_id, amounts, approval_ids)
            }

            fn mt_token_approval(&self, token_id: TokenId, account_id: AccountId) -> TokenApproval {
                self.$token
                    .mt_token_approval(token_id, account_id)
            }

            fn mt_token_approvals(
                &self,
                token_id: TokenId,
                from_index: U128,
                limit: u128,
            ) -> Vec<TokenApproval> {
                self.$token
                    .mt_token_approvals(token_id, from_index, limit)
            }
        }
    };
}

/// Multi-token enumeration adds the extension standard offering several
/// view-only methods to get token supply, tokens per owner, etc.
#[macro_export]
macro_rules! impl_multi_token_enumeration {
    ($contract: ident, $token: ident) => {
        use $crate::multi_token::enumeration::MultiTokenEnumeration;

        #[near_bindgen]
        impl MultiTokenEnumeration for $contract {
            fn mt_tokens(&self, from_index: Option<u64>, limit: u64) -> Vec<Token> {
                self.$token.mt_tokens(from_index, limit)
            }

            fn mt_tokens_for_owner(
                &self,
                account_id: AccountId,
                from_index: Option<u64>,
                limit: u64,
            ) -> Vec<Token> {
                self.$token
                    .mt_tokens_for_owner(account_id, from_index, limit)
            }
        }
    };
}

'''
'''--- src/multi_token/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::require;
use near_sdk::serde::{Deserialize, Serialize};

/// Version of standard
pub const MT_METADATA_SPEC: &str = "mt-0.0.1";

/// Metadata that will be permanently set at the contract init
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct MtContractMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub base_uri: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
}

/// Metadata for each token
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>,
    /// Free-form description
    pub description: Option<String>,
    /// URL to associated media, preferably to decentralized, content-addressed storage
    pub media: Option<String>,
    /// Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub media_hash: Option<String>,
    /// When token was issued or minted, Unix epoch in milliseconds
    pub issued_at: Option<String>,
    /// When token expires, Unix epoch in milliseconds
    pub expires_at: Option<String>,
    /// When token starts being valid, Unix epoch in milliseconds
    pub starts_at: Option<String>,
    /// When token was last updated, Unix epoch in milliseconds
    pub updated_at: Option<String>,
    /// Anything extra the MT wants to store on-chain. Can be stringified JSON.
    pub extra: Option<String>,
    /// URL to an off-chain JSON file with more info.
    pub reference: Option<String>,
    /// Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    pub reference_hash: Option<String>,
}

/// Offers details on the contract-level metadata.
pub trait MultiTokenMetadataProvider {
    fn mt_metadata(&self) -> MtContractMetadata;
}

impl MtContractMetadata {
    pub fn assert_valid(&self) {
        require!(self.spec == MT_METADATA_SPEC, "Spec is not NFT metadata");
        require!(
            self.reference.is_some() == self.reference_hash.is_some(),
            "Reference and reference hash must be present"
        );
        if let Some(reference_hash) = &self.reference_hash {
            require!(reference_hash.len() == 32, "Hash has to be 32 bytes");
        }
    }
}

impl TokenMetadata {
    pub fn assert_valid(&self) {
        require!(self.media.is_some() == self.media_hash.is_some());
        if let Some(media_hash) = &self.media_hash {
            require!(media_hash.len() == 32, "Media hash has to be 32 bytes");
        }

        require!(self.reference.is_some() == self.reference_hash.is_some());
        if let Some(reference_hash) = &self.reference_hash {
            require!(reference_hash.len() == 32, "Reference hash has to be 32 bytes");
        }
    }
}
'''
'''--- src/multi_token/mod.rs ---
pub mod core;

pub mod token;

pub mod approval;

pub mod metadata;

pub mod enumeration;

pub mod utils;

pub mod events;

pub mod macros;

pub use macros::*;
'''
'''--- src/multi_token/token.rs ---
use crate::multi_token::metadata::TokenMetadata;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
pub use near_sdk::{AccountId, Balance};
use std::collections::HashMap;
use crate::multi_token::core::ApprovalId;

/// Type alias for convenience
pub type TokenId = String;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Approval {
    pub amount: u128,
    pub approval_id: ApprovalId,
}

/// Info on individual token
#[derive(Debug, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
pub struct Token {
    pub token_id: String,
    pub owner_id: AccountId,
    /// Total amount generated
    pub supply: u128,
    pub balances: HashMap<AccountId, Balance>,
    pub metadata: Option<TokenMetadata>,
    pub approvals: Option<HashMap<AccountId, Approval>>,
    pub next_approval_id: Option<u64>,
}

'''
'''--- src/multi_token/utils.rs ---
use std::{
    fmt::Display,
    mem::size_of,
};

use near_sdk::{env, require, AccountId, Balance, CryptoHash, Promise};

pub fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

pub fn refund_deposit_to_account(storage_used: u64, account_id: AccountId) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    require!(
        required_cost <= attached_deposit,
        format!("Must attach {} yoctoNEAR to cover storage", required_cost)
    );

    let refund = attached_deposit - required_cost;
    if refund > 1 {
        Promise::new(account_id).transfer(refund);
    }
}

/// Assumes that the precedecessor will be refunded
pub fn refund_deposit(storage_used: u64) {
    refund_deposit_to_account(storage_used, env::predecessor_account_id())
}

// TODO: need a way for end users to determine how much an approval will cost.
pub fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

pub enum Entity {
    Contract,
    Token,
}

impl Display for Entity {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let as_string = match self {
            Entity::Contract => "contract",
            Entity::Token => "token",
        };
        write!(f, "{}", as_string)
    }
}

pub fn expect_extension<T>(o: Option<T>, entity: Entity) -> T {
    o.unwrap_or_else(|| panic!("Approval Management is not supported by {}", entity))
}

pub fn unauthorized_assert(account_id: &AccountId) {
    require!(account_id == &env::predecessor_account_id())
}
'''