*GitHub Repository "hskang9/aurora-silo-tests"*

'''--- .idea/discord.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DiscordProjectSettings">
    <option name="show" value="ASK" />
    <option name="description" value="" />
  </component>
</project>
'''
'''--- .idea/modules.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/near-counter.iml" filepath="$PROJECT_DIR$/.idea/near-counter.iml" />
    </modules>
  </component>
</project>
'''
'''--- .idea/vcs.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$" vcs="Git" />
  </component>
</project>
'''
'''--- Cargo.toml ---
[package]
name = "aurora-workspace-demo"
version = "0.1.0"
edition = "2021"
authors = ["Joshua J. Bouw <hi@jjb.rs>"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
aurora-workspace = { git = "https://github.com/aurora-is-near/aurora-workspace.git", rev = "e192c4b152826263499380ba2917cb4ee5946c91" }
aurora-workspace-types = { git = "https://github.com/aurora-is-near/aurora-workspace.git", rev="e192c4b152826263499380ba2917cb4ee5946c91" }
aurora-engine = { git = "https://github.com/aurora-is-near/aurora-engine.git", tag = "2.8.1", features = ["std"] }
aurora-engine-precompiles = { git = "https://github.com/aurora-is-near/aurora-engine.git", tag = "2.8.1", features = ["std"] }
aurora-engine-sdk = { git = "https://github.com/aurora-is-near/aurora-engine.git", tag = "2.8.1", features = ["std"] }
aurora-engine-transactions = { git = "https://github.com/aurora-is-near/aurora-engine.git", tag = "2.8.1", features = ["std"] }
aurora-engine-types = { git = "https://github.com/aurora-is-near/aurora-engine.git", tag = "2.8.1", features = ["std", "serde"] }
workspaces = { git = "https://github.com/near/workspaces-rs.git", rev = "34bb786470700c7f95b0c88201a58b8792b6dba1" }
ethabi = "18.0.0"
hex = "0.4.3"
ethereum-types = "0.13.1"
ethereum-tx-sign = "6.0.1"
anyhow = "1"
tokio = "1.21.2"
serde_json = "1.0.64"
near-units = "0.2.0"
base64 = "0.13.0"
borsh = "0.9.1"
serde = { version = "1", features = ["derive"] }
near-sdk = "4.0"
'''
'''--- README.md ---
# aurora-silo-tests
tests for aurora dao deployment

# How to run
```
cargo test
```

'''
'''--- src/common.rs ---
use aurora_workspace::contract::EthProverConfig;
use aurora_workspace::{types::AccountId, EvmContract, InitConfig};
use aurora_engine::parameters::NewCallArgs;
use std::str::FromStr;
use workspaces::network::Sandbox;
use workspaces::types::{KeyType, SecretKey};
use workspaces::{Worker, Account};

pub const EVM_ACCOUNT_ID: &str = "aurora.test.near";
const AURORA_LOCAL_CHAIN_ID: u64 = 1313161556;
pub const OWNER_ACCOUNT_ID: &str = "owner.test.near";
const PROVER_ACCOUNT_ID: &str = "prover.test.near";

pub async fn create_account(worker: &Worker<Sandbox>, id: &str, sk: Option<SecretKey>) -> anyhow::Result<Account> {
    let secret = sk.unwrap_or_else(|| SecretKey::from_random(KeyType::ED25519));
    let account = worker
        .create_tla(AccountId::from_str(id)?, secret)
        .await?
        .into_result()?;
    Ok(account) 
}

pub async fn init_and_deploy_contract_with_path(worker: &Worker<Sandbox>, path: &str) -> anyhow::Result<(EvmContract, SecretKey)> {
    let sk = SecretKey::from_random(KeyType::ED25519);
    let evm_account = worker
        .create_tla(AccountId::from_str(EVM_ACCOUNT_ID)?, sk.clone())
        .await?
        .into_result()?;
    let eth_prover_config = EthProverConfig::default();
    let init_config = InitConfig {
        owner_id: AccountId::from_str(OWNER_ACCOUNT_ID)?,
        prover_id: AccountId::from_str(PROVER_ACCOUNT_ID)?,
        eth_prover_config: Some(eth_prover_config),
        chain_id: AURORA_LOCAL_CHAIN_ID.into(),
    };
    let wasm = std::fs::read(path)?;
    // create contract
    let contract = EvmContract::deploy_and_init(evm_account.clone(), init_config, wasm).await?;

    Ok((contract, sk))
}

pub async fn init_and_deploy_contract_with_path_on_admin_change(worker: &Worker<Sandbox>, path: &str) -> anyhow::Result<(EvmContract, SecretKey, Account)> {
    let sk = SecretKey::from_random(KeyType::ED25519);
    let evm_account = worker
        .create_tla(AccountId::from_str(OWNER_ACCOUNT_ID)?, sk.clone())
        .await?
        .into_result()?;
    let eth_prover_config = EthProverConfig::default();
    let init_config = InitConfig {
        owner_id: AccountId::from_str(OWNER_ACCOUNT_ID)?,
        prover_id: AccountId::from_str(PROVER_ACCOUNT_ID)?,
        eth_prover_config: Some(eth_prover_config),
        chain_id: AURORA_LOCAL_CHAIN_ID.into(),
    };
    let wasm = std::fs::read(path)?;
    // create contract
    let contract = EvmContract::deploy_and_init(evm_account.clone(), init_config, wasm).await?;

    Ok((contract, sk, evm_account))
}

pub async fn init_and_deploy_contract(worker: &Worker<Sandbox>) -> anyhow::Result<EvmContract> {
    let sk = SecretKey::from_random(KeyType::ED25519);
    let evm_account = worker
        .create_tla(AccountId::from_str(EVM_ACCOUNT_ID)?, sk)
        .await?
        .into_result()?;
    let eth_prover_config = EthProverConfig::default();
    let init_config = InitConfig {
        owner_id: AccountId::from_str(OWNER_ACCOUNT_ID)?,
        prover_id: AccountId::from_str(PROVER_ACCOUNT_ID)?,
        eth_prover_config: Some(eth_prover_config),
        chain_id: AURORA_LOCAL_CHAIN_ID.into(),
    };
    let wasm = std::fs::read("./res/aurora-testnet.wasm")?;
    // create contract
    let contract = EvmContract::deploy_and_init(evm_account, init_config, wasm).await?;

    Ok(contract)
}

pub async fn init_and_deploy_sputnik(worker: &Worker<Sandbox>) -> anyhow::Result<EvmContract> {
    let sk = SecretKey::from_random(KeyType::ED25519);
    let evm_account = worker
        .create_tla(AccountId::from_str(EVM_ACCOUNT_ID)?, sk)
        .await?
        .into_result()?;
    let eth_prover_config = EthProverConfig::default();
    let init_config = InitConfig {
        owner_id: AccountId::from_str(OWNER_ACCOUNT_ID)?,
        prover_id: AccountId::from_str(PROVER_ACCOUNT_ID)?,
        eth_prover_config: Some(eth_prover_config),
        chain_id: AURORA_LOCAL_CHAIN_ID.into(),
    };
    let wasm = std::fs::read("./res/aurora-testnet.wasm")?;
    // create contract
    let contract = EvmContract::deploy_and_init(evm_account, init_config, wasm).await?;

    Ok(contract)
}

'''
'''--- src/lib.rs ---
pub mod common;

'''
'''--- src/main.rs ---
use aurora_workspace::{
    types::{ KeyType, SecretKey}, EvmContract,
};
use aurora_workspace_demo::common;
use serde_json::json;
use std::{str::FromStr};
use workspaces::AccountId;

use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use std::io::{self, Write};

#[cfg(test)]
mod test;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // TODO: add deployment code here
    Ok(())
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct NewOwnerArgs {
    pub new_owner: AccountId,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Raw(pub Vec<u8>);

impl BorshSerialize for Raw {
    fn serialize<W: Write>(&self, writer: &mut W) -> io::Result<()> {
        writer.write_all(&self.0)
    }
}

impl BorshDeserialize for Raw {
    fn deserialize(bytes: &mut &[u8]) -> io::Result<Self> {
        let res = bytes.to_vec();
        *bytes = &[];
        Ok(Self(res))
    }
}

'''
'''--- src/test.rs ---
use aurora_engine::{
    fungible_token::FungibleTokenMetadata,
    parameters::{InitCallArgs, PauseEthConnectorCallArgs, SetContractDataCallArgs}, xcc::AddressVersionUpdateArgs,
};
use aurora_engine_types::{self, types::Address};
use aurora_workspace::{
    contract::{EthProverConfig}, types::{SecretKey, KeyType}
};
use aurora_workspace_demo::common;
use aurora_workspace_types::AccountId;
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Serialize, Deserialize};
use std::str::FromStr;

pub const OWNER_ACCOUNT_ID: &str = "owner.test.near";
const PROVER_ACCOUNT_ID: &str = "prover.test.near";

#[tokio::test]
async fn test_new_eth_connector() {
    // 1. Create a sandbox environment.
    let worker = workspaces::sandbox().await.unwrap();

    worker.fast_forward(1).await.unwrap();

    // 2. deploy the Aurora EVM in sandbox with initial call to setup admin account from sender
    let (evm, _sk) = common::init_and_deploy_contract_with_path(
        &worker,
        "./res/aurora-testnet-feat-change-admin.wasm",
    )
    .await
    .unwrap();

    let sk2 = SecretKey::from_random(KeyType::ED25519);
    let owner = worker
    .create_tla(AccountId::from_str(OWNER_ACCOUNT_ID).unwrap(), sk2.clone())
    .await.unwrap()
    .into_result().unwrap();

    worker.fast_forward(1).await.unwrap();

    let eth_prover_config = EthProverConfig::default();

    let args = InitCallArgs {
        prover_account: aurora_engine_types::account_id::AccountId::from_str(
            eth_prover_config.account_id.as_str(),
        )
        .unwrap(),
        eth_custodian_address: eth_prover_config.evm_custodian_address,
        metadata: FungibleTokenMetadata::default(),
    };

    let result = owner
        .call(evm.as_account().id(), "new_eth_connector")
        .args_borsh(args)
        .transact()
        .await
        .unwrap();
    println!("result: {:?}", result);
    // new eth connector should fail as it can only be called once and it is already called in init method.
    // set_eth_connector_contract_data should be called instead.
    assert!(result.is_failure());
}

#[tokio::test]
async fn test_set_eth_connector_contract_data() {
    // 1. Create a sandbox environment.
    let worker = workspaces::sandbox().await.unwrap();

    worker.fast_forward(1).await.unwrap();

    // 2. deploy the Aurora EVM in sandbox.
    let (evm, _sk) = common::init_and_deploy_contract_with_path(
        &worker,
        "./res/aurora-testnet-feat-change-admin.wasm",
    )
    .await
    .unwrap();

    let sk2 = SecretKey::from_random(KeyType::ED25519);
    let owner = worker
    .create_tla(AccountId::from_str(OWNER_ACCOUNT_ID).unwrap(), sk2.clone())
    .await.unwrap()
    .into_result().unwrap();

    worker.fast_forward(1).await.unwrap();
    let aur_prover_account: aurora_engine_types::account_id::AccountId =
        aurora_engine_types::account_id::AccountId::from_str(PROVER_ACCOUNT_ID).unwrap();

    let args = SetContractDataCallArgs {
        eth_custodian_address: "0000000000000000000000000000000000000000".to_string(),
        prover_account: aur_prover_account,
        metadata: FungibleTokenMetadata {
            spec: "ft-1.0.0".to_string(),
            name: "Aurora Testnet NEAR".to_string(),
            symbol: "aurora.test.near".to_string(),
            icon: None,
            reference: None,
            reference_hash: None,
            decimals: 24,
        },
    };

    let result = owner
        .call(evm.as_account().id(), "set_eth_connector_contract_data")
        .args_borsh(args)
        .transact()
        .await
        .unwrap();
    println!("result: {:?}", result);
    assert!(result.is_success());
}

#[tokio::test]
async fn test_set_paused_flags() {
    // 1. Create a sandbox environment.
    let worker = workspaces::sandbox().await.unwrap();

    worker.fast_forward(1).await.unwrap();

    // 2. deploy the Aurora EVM in sandbox.
    let (evm, _sk) = common::init_and_deploy_contract_with_path(
        &worker,
        "./res/aurora-testnet-feat-change-admin.wasm",
    )
    .await
    .unwrap();

    

    worker.fast_forward(1).await.unwrap();

    let args = PauseEthConnectorCallArgs { paused_mask: 0 };
     
    let sk2 = SecretKey::from_random(KeyType::ED25519);
    let owner = worker
    .create_tla(AccountId::from_str(OWNER_ACCOUNT_ID).unwrap(), sk2.clone())
    .await.unwrap()
    .into_result().unwrap();

    let result = owner
        .call(evm.as_account().id(), "set_paused_flags")
        .args_borsh(args)
        .transact()
        .await
        .unwrap();
    println!("result: {:?}", result);
    assert!(result.is_success());
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub struct SetOwnerArgs {
    pub new_owner: AccountId,
}

#[tokio::test]
async fn test_set_owner() {
    // 1. Create a sandbox environment.
    let worker = workspaces::sandbox().await.unwrap();

    worker.fast_forward(1).await.unwrap();

    // 2. deploy the Aurora EVM in sandbox.
    let (evm, _sk, owner) = common::init_and_deploy_contract_with_path_on_admin_change(
        &worker,
        "./res/aurora-testnet-set-owner.wasm",
    )
    .await
    .unwrap();

    worker.fast_forward(1).await.unwrap();

    let args = SetOwnerArgs { new_owner: AccountId::from_str("newowner.test.near").unwrap() };

    let result = owner
        .call(evm.as_account().id(), "set_owner")
        .args_borsh(args)
        .transact()
        .await
        .unwrap();
    println!("Set Owner result: {:?}", result);
    assert!(result.is_success());

    // get owner account id
    let result = owner
        .view(evm.as_account().id(), "get_owner")
        .args_borsh(())
        .await
        .unwrap();

    println!("View result: {:?}", result);
}
'''