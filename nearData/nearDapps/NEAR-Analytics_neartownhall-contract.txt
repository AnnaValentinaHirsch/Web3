*GitHub Repository "NEAR-Analytics/neartownhall-contract"*

'''--- .github/workflows/release.yml ---
name: Release
on:
  push:
    branches: [main, ci/deploy-to-mainnet]

jobs:
  deploy-widgets:
    runs-on: ubuntu-latest
    name: Deploy contract to mainnet
    env:
      NEAR_NETWORK_CONNECTION: mainnet
      NEAR_GIGSBOARD_ACCOUNT_ID: ${{ vars.NEAR_GIGSBOARD_ACCOUNT_ID }}
      NEAR_GIGSBOARD_ACCOUNT_PUBLIC_KEY: ${{ vars.NEAR_GIGSBOARD_ACCOUNT_PUBLIC_KEY }}
      NEAR_GIGSBOARD_ACCOUNT_PRIVATE_KEY: ${{ secrets.NEAR_GIGSBOARD_ACCOUNT_PRIVATE_KEY }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: 1.68.2
    - uses: Swatinem/rust-cache@v1
    - run: rustup target add wasm32-unknown-unknown
    - name: Build contract
      run: ./build.sh
    - name: Install near CLI
      run: |
        curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/near-cli-rs/releases/download/v0.3.1/near-cli-rs-v0.3.1-installer.sh | sh
    - name: Deploy contract
      run: |
        output=$(near contract call-function as-transaction "$NEAR_GIGSBOARD_ACCOUNT_ID" unsafe_self_upgrade file-args ./res/near_analytics.wasm prepaid-gas '100 TeraGas' attached-deposit '0 NEAR' sign-as "$NEAR_GIGSBOARD_ACCOUNT_ID" network-config "$NEAR_NETWORK_CONNECTION" sign-with-plaintext-private-key --signer-public-key "$NEAR_GIGSBOARD_ACCOUNT_PUBLIC_KEY" --signer-private-key "$NEAR_GIGSBOARD_ACCOUNT_PRIVATE_KEY" send)
        while [[ ! "$output" == *"Migration done."* ]]; do
          echo "$output"
          sleep 5
          output=$(near contract call-function as-transaction "$NEAR_GIGSBOARD_ACCOUNT_ID" unsafe_migrate json-args '{}' prepaid-gas '100 TeraGas' attached-deposit '0 NEAR' sign-as "$NEAR_GIGSBOARD_ACCOUNT_ID" network-config "$NEAR_NETWORK_CONNECTION" sign-with-plaintext-private-key --signer-public-key "$NEAR_GIGSBOARD_ACCOUNT_PUBLIC_KEY" --signer-private-key "$NEAR_GIGSBOARD_ACCOUNT_PRIVATE_KEY" send)
        done
        echo "$output"
'''
'''--- Cargo.toml ---
[package]
name = "near-analytics"
version = "0.1.0"
authors = ["Maksym Zavershynskyi"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/near_analytics.wasm ./res/

'''
'''--- rustfmt.toml ---
use_small_heuristics = "Max"
reorder_imports = true
edition = "2021"

'''
'''--- src/access_control/members.rs ---
use crate::access_control::rules::Rule;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use std::collections::hash_map::Entry;
use std::collections::{HashMap, HashSet};

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    Clone,
    Debug,
    PartialOrd,
    PartialEq,
    Ord,
    Eq,
    Hash,
)]
#[serde(crate = "near_sdk::serde")]
#[serde(from = "String")]
#[serde(into = "String")]
pub enum Member {
    /// NEAR account names do not allow `:` character so this structure cannot be abused.
    Account(String),
    Team(String),
}

/// JSON string representation prefix of `Member::Team` variant.
const TEAM: &str = "team:";

impl From<String> for Member {
    fn from(full_str: String) -> Self {
        if let Some(s) = full_str.strip_prefix(TEAM) {
            Member::Team(s.to_string())
        } else {
            Member::Account(full_str)
        }
    }
}

impl Into<String> for Member {
    fn into(self) -> String {
        match self {
            Member::Account(s) => s.to_string(),
            Member::Team(s) => format!("{}{}", TEAM, s).to_string(),
        }
    }
}

#[derive(
    BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Default, Debug, Eq, PartialEq,
)]
#[serde(crate = "near_sdk::serde")]
pub struct MemberMetadata {
    description: String,
    permissions: HashMap<Rule, HashSet<ActionType>>,
    children: HashSet<Member>,
    parents: HashSet<Member>,
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    Clone,
    PartialOrd,
    PartialEq,
    Ord,
    Eq,
    Hash,
    Debug,
)]
#[serde(crate = "near_sdk::serde")]
#[serde(rename_all = "kebab-case")]
pub enum ActionType {
    /// Can edit posts that have these labels.
    EditPost,
    /// Can add/remove labels that fall under these rules.
    UseLabels,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug, Eq, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "member_metadata_version")]
pub enum VersionedMemberMetadata {
    V0(MemberMetadata),
}

impl VersionedMemberMetadata {
    pub fn last_version(&self) -> MemberMetadata {
        match self {
            VersionedMemberMetadata::V0(v0) => v0.clone(),
        }
    }
}

impl From<MemberMetadata> for VersionedMemberMetadata {
    fn from(m: MemberMetadata) -> Self {
        VersionedMemberMetadata::V0(m)
    }
}

#[derive(
    BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug, Eq, PartialEq, Default,
)]
#[serde(crate = "near_sdk::serde")]
pub struct MembersList {
    #[serde(flatten)]
    pub members: HashMap<Member, VersionedMemberMetadata>,
}

impl MembersList {
    /// Get members that do not belong to any team.
    pub fn get_root_members(&self) -> HashMap<Member, VersionedMemberMetadata> {
        self.members
            .iter()
            .filter(|(_, v)| v.last_version().parents.is_empty())
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect()
    }

    /// Whether given account has special permissions for a post with the given labels.
    /// Labels are restricted labels.
    pub fn check_permissions(&self, account: String, labels: Vec<String>) -> HashSet<ActionType> {
        if !self.members.contains_key(&Member::Account(account.clone())) {
            return HashSet::new();
        }

        let mut stack = HashSet::new();
        stack.insert(Member::Account(account));

        let mut res = HashSet::new();
        while let Some(member) = stack.iter().next().cloned() {
            stack.remove(&member);

            let metadata = self
                .members
                .get(&member)
                .unwrap_or_else(|| panic!("Metadata not found for {:#?}", member))
                .last_version();

            for (rule, permissions) in metadata.permissions.iter() {
                if match rule {
                    Rule::ExactMatch(rule) => {
                        // `.find` requires mutable argument.
                        labels.iter().filter(|label| rule == *label).next().is_some()
                    }
                    Rule::StartsWith(rule) => {
                        // `.find` requires mutable argument.
                        labels.iter().filter(|label| label.starts_with(rule)).next().is_some()
                    }
                } {
                    for p in permissions {
                        res.insert(p.clone());
                    }
                }
            }

            for add_member in metadata.parents.iter() {
                stack.insert(add_member.clone());
            }
        }
        res
    }

    pub fn add_member(&mut self, member: Member, metadata: VersionedMemberMetadata) {
        assert!(
            self.members.insert(member.clone(), metadata.clone()).is_none(),
            "Member already exists"
        );

        // Update child members that this member is a parent of.
        for child in &metadata.last_version().children {
            match self.members.entry(child.clone()) {
                Entry::Occupied(mut occ) => {
                    let MemberMetadata { description, children, mut parents, permissions } =
                        occ.get().last_version();
                    assert!(parents.insert(member.clone()), "Child already had this parent");
                    let new_child = MemberMetadata { description, children, parents, permissions };
                    occ.insert(new_child.into());
                }
                Entry::Vacant(_) => {
                    panic!("Member declares a child {:#?} that does not exist", child)
                }
            }
        }

        // Update parent members that this member is now a child of.
        for parent in &metadata.last_version().parents {
            match self.members.entry(parent.clone()) {
                Entry::Occupied(mut occ) => {
                    let MemberMetadata { description, mut children, parents, permissions } =
                        occ.get().last_version();
                    assert!(children.insert(member.clone()), "Parent already had this child");
                    let new_parent = MemberMetadata { description, children, parents, permissions };
                    occ.insert(new_parent.into());
                }
                Entry::Vacant(_) => {
                    panic!("Member declares a parent {:#?} that does not exist", parent)
                }
            }
        }
    }

    pub fn remove_member(&mut self, member: &Member) {
        let metadata = self.members.remove(member).expect("Member does not exist");

        // Update child members that this member is not a parent of anymore.
        for child in &metadata.last_version().children {
            match self.members.entry(child.clone()) {
                Entry::Occupied(mut occ) => {
                    let MemberMetadata { description, children, mut parents, permissions } =
                        occ.get().last_version();
                    assert!(parents.remove(member), "Child did not have this parent.");
                    let new_child = MemberMetadata { description, children, parents, permissions };
                    occ.insert(new_child.into());
                }
                Entry::Vacant(_) => {
                    panic!("Member declares a child {:#?} that does not exist", child)
                }
            }
        }

        // Update parent members that this member is not a child of anymore.
        for parent in &metadata.last_version().parents {
            match self.members.entry(parent.clone()) {
                Entry::Occupied(mut occ) => {
                    let MemberMetadata { description, mut children, parents, permissions } =
                        occ.get().last_version();
                    assert!(children.remove(member), "Parent did not have this child.");
                    let new_parent = MemberMetadata { description, children, parents, permissions };
                    occ.insert(new_parent.into());
                }
                Entry::Vacant(_) => {
                    panic!("Member declares a parent {:#?} that does not exist", parent)
                }
            }
        }
    }

    pub fn edit_member(&mut self, member: Member, metadata: VersionedMemberMetadata) {
        self.remove_member(&member);
        self.add_member(member, metadata);
    }

    pub fn get_moderators(&self) -> HashSet<Member> {
        self.members
            .get(&Member::Team("moderators".to_string()))
            .map(|team| team.last_version().children)
            .unwrap_or(HashSet::new())
    }
}

#[cfg(test)]
mod tests {
    use crate::access_control::members::{
        ActionType, Member, MemberMetadata, MembersList, VersionedMemberMetadata,
    };
    use crate::access_control::rules::Rule;
    use near_sdk::serde_json;
    use std::collections::{HashMap, HashSet};

    #[test]
    fn member_serialization() {
        let member = Member::Account("alice.near".to_string());
        assert_eq!(serde_json::to_value(&member).unwrap(), serde_json::json!("alice.near"));

        let member = Member::Team("funding".to_string());
        assert_eq!(serde_json::to_value(&member).unwrap(), serde_json::json!("team:funding"));
    }

    #[test]
    fn member_deserialization() {
        let member: Member = serde_json::from_str(r#""alice.near""#).unwrap();
        assert_eq!(member, Member::Account("alice.near".to_string()));

        let member: Member = serde_json::from_str(r#""team:funding""#).unwrap();
        assert_eq!(member, Member::Team("funding".to_string()));
    }

    fn root_member() -> (Member, VersionedMemberMetadata) {
        (
            Member::Account("near-analytics.near".to_string()),
            MemberMetadata {
                description: "Main account can do anything".to_string(),
                permissions: HashMap::from([
                    (
                        Rule::StartsWith("wg-".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                    (
                        Rule::StartsWith("funding".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                    (
                        Rule::StartsWith("mnw".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                ]),
                ..Default::default()
            }
            .into(),
        )
    }

    fn moderator_member(name: &str) -> (Member, VersionedMemberMetadata) {
        (
            Member::Account(name.to_string()),
            MemberMetadata {
                description: format!("{} inherits everything from moderator group.", name)
                    .to_string(),
                parents: HashSet::from([Member::Team("moderators".to_string())]),
                ..Default::default()
            }
            .into(),
        )
    }

    fn moderators() -> (Member, VersionedMemberMetadata) {
        (
            Member::Team("moderators".to_string()),
            MemberMetadata {
                description: "Moderators can do anything except funding posts.".to_string(),
                permissions: HashMap::from([
                    (
                        Rule::StartsWith("wg-".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                    (
                        Rule::StartsWith("mnw".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                ]),
                children: HashSet::from([
                    Member::Account("ori.near".to_string()),
                    Member::Account("max.near".to_string()),
                    Member::Account("vlad.near".to_string()),
                ]),
                ..Default::default()
            }
            .into(),
        )
    }

    fn create_list() -> MembersList {
        MembersList {
            members: HashMap::from([
                moderators(),
                root_member(),
                moderator_member("ori.near"),
                moderator_member("max.near"),
                moderator_member("vlad.near"),
            ]),
        }
    }

    #[test]
    fn get_root_members() {
        let list = create_list();
        let root_members: HashSet<_> = list.get_root_members().keys().cloned().collect();
        assert_eq!(
            root_members,
            HashSet::from([
                Member::Team("moderators".to_string()),
                Member::Account("near-analytics.near".to_string())
            ])
        );
    }

    #[test]
    fn check_permissions() {
        let list = create_list();
        let actual = list.check_permissions(
            "max.near".to_string(),
            vec!["wg-protocol".to_string(), "funding-requested".to_string()],
        );
        assert_eq!(
            actual,
            serde_json::from_value::<HashSet<ActionType>>(serde_json::json!([
                "edit-post",
                "use-labels"
            ]))
            .unwrap()
        );

        let actual =
            list.check_permissions("max.near".to_string(), vec!["funding-requested".to_string()]);
        assert!(actual.is_empty());
    }

    #[test]
    fn check_permissions_of_not_member() {
        let list = create_list();
        let actual = list.check_permissions(
            "random.near".to_string(),
            vec!["wg-protocol".to_string(), "funding-requested".to_string()],
        );
        assert!(actual.is_empty());
    }

    #[test]
    fn add_remove_member() {
        let mut list = create_list();
        list.add_member(
            Member::Account("bob.near".to_string()),
            MemberMetadata {
                parents: HashSet::from([Member::Team("moderators".to_string())]),
                ..Default::default()
            }
            .into(),
        );
        list.remove_member(&Member::Account("bob.near".to_string()));
        assert_eq!(list, create_list());
    }
}

'''
'''--- src/access_control/mod.rs ---
use crate::access_control::members::{Member, MembersList, VersionedMemberMetadata};
use crate::access_control::rules::{Rule, RulesList};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

pub mod members;
pub mod rules;

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone, Default)]
#[serde(crate = "near_sdk::serde")]
pub struct AccessControl {
    pub rules_list: RulesList,
    pub members_list: MembersList,
}

use crate::*;
use near_sdk::near_bindgen;

#[near_bindgen]
impl Contract {
    pub fn get_access_control_info(&self) -> &AccessControl {
        &self.access_control
    }

    pub fn is_restricted_label(&self, label: &String) -> bool {
        self.access_control.rules_list.is_restricted(label)
    }

    pub fn find_restricted_labels(&self, labels: Vec<String>) -> HashSet<String> {
        self.access_control.rules_list.find_restricted(labels)
    }

    pub fn set_restricted_rules(&mut self, rules: RulesList) {
        near_sdk::assert_self();
        self.access_control.rules_list.set_restricted(rules)
    }

    pub fn unset_restricted_rules(&mut self, rules: Vec<Rule>) {
        near_sdk::assert_self();
        self.access_control.rules_list.unset_restricted(rules)
    }

    pub fn get_root_members(&self) -> HashMap<Member, VersionedMemberMetadata> {
        self.access_control.members_list.get_root_members()
    }

    pub fn add_member(&mut self, member: Member, metadata: VersionedMemberMetadata) {
        near_sdk::assert_self();
        self.access_control.members_list.add_member(member, metadata)
    }

    pub fn remove_member(&mut self, member: &Member) {
        near_sdk::assert_self();
        self.access_control.members_list.remove_member(member)
    }

    pub fn edit_member(&mut self, member: Member, metadata: VersionedMemberMetadata) {
        near_sdk::assert_self();
        self.access_control.members_list.edit_member(member, metadata)
    }
}

'''
'''--- src/access_control/rules.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

#[derive(
    BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug, Eq, PartialEq, Default,
)]
#[serde(crate = "near_sdk::serde")]
pub struct RulesList {
    #[serde(flatten)]
    pub rules: HashMap<Rule, VersionedRuleMetadata>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug, Eq, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct RuleMetadata {
    pub description: String,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug, Eq, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "rule_metadata_version")]
pub enum VersionedRuleMetadata {
    V0(RuleMetadata),
}

impl From<RuleMetadata> for VersionedRuleMetadata {
    fn from(rm: RuleMetadata) -> Self {
        VersionedRuleMetadata::V0(rm)
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    Clone,
    PartialOrd,
    PartialEq,
    Ord,
    Eq,
    Hash,
    Debug,
)]
#[serde(crate = "near_sdk::serde")]
#[serde(from = "String")]
#[serde(into = "String")]
pub enum Rule {
    /// Labels can be any string, but rules are created by the NEAR account owner of this contract,
    /// or small circle of moderators. So this code cannot be abused. Likely creating a label that
    /// mimics a rule makes this label only more restrictive, so there might be nothing to exploit.
    /// TODO: Add extra logic to prevent malicious rules creation by creating labels that mimic rules.
    ExactMatch(String),
    StartsWith(String),
}

/// JSON string representation prefix of Rule::StartsWith variant.
const STARTS_WITH: &str = "starts-with:";

impl From<String> for Rule {
    fn from(full_str: String) -> Self {
        if let Some(s) = full_str.strip_prefix(STARTS_WITH) {
            Rule::StartsWith(s.to_string())
        } else {
            Rule::ExactMatch(full_str)
        }
    }
}

impl Into<String> for Rule {
    fn into(self) -> String {
        match self {
            Rule::ExactMatch(s) => s.to_string(),
            Rule::StartsWith(s) => format!("{}{}", STARTS_WITH, s).to_string(),
        }
    }
}

impl Rule {
    /// Check if this rule applies to a label.
    pub fn applies(&self, label: &String) -> bool {
        match self {
            Rule::ExactMatch(rule) => rule == label,
            Rule::StartsWith(rule) => label.starts_with(rule),
        }
    }
}

impl RulesList {
    /// Is this a restricted label.
    pub fn is_restricted(&self, label: &String) -> bool {
        self.rules.keys().find(|key| key.applies(label)).is_some()
    }

    /// Get restricted labels out of this list.
    pub fn find_restricted(&self, ref labels: Vec<String>) -> HashSet<String> {
        self.rules
            .keys()
            .map(|key| match key {
                Rule::ExactMatch(rule) => {
                    labels.into_iter().filter(|label| rule == *label).collect::<Vec<_>>()
                }
                Rule::StartsWith(rule) => {
                    labels.into_iter().filter(|label| label.starts_with(rule)).collect::<Vec<_>>()
                }
            })
            .flatten()
            .cloned()
            .collect()
    }

    /// Set rules as restricted. Can be also used to override metadata on existing rules.
    pub fn set_restricted(&mut self, rules: Self) {
        for (rule, metadata) in rules.rules {
            self.rules.insert(rule, metadata);
        }
    }

    /// Unset rules as restricted.
    pub fn unset_restricted(&mut self, rules: Vec<Rule>) {
        for rule in rules {
            self.rules.remove(&rule);
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::access_control::rules::{Rule, RuleMetadata, RulesList};
    use near_sdk::serde_json;
    use std::collections::{HashMap, HashSet};

    #[test]
    fn rule_serialization() {
        let rule = Rule::ExactMatch("wg-protocol".to_string());
        assert_eq!(serde_json::to_value(&rule).unwrap(), serde_json::json!("wg-protocol"));

        let rule = Rule::StartsWith("funding".to_string());
        assert_eq!(serde_json::to_value(&rule).unwrap(), serde_json::json!("starts-with:funding"));
    }

    #[test]
    fn rule_deserialization() {
        let rule: Rule = serde_json::from_str(r#""wg-protocol""#).unwrap();
        assert_eq!(rule, Rule::ExactMatch("wg-protocol".to_string()));

        let rule: Rule = serde_json::from_str(r#""starts-with:funding""#).unwrap();
        assert_eq!(rule, Rule::StartsWith("funding".to_string()));
    }

    fn create_list() -> RulesList {
        RulesList {
            rules: HashMap::from([
                (
                    Rule::ExactMatch("wg-protocol".to_string()),
                    RuleMetadata { description: "For Protocol WG only".to_string() }.into(),
                ),
                (
                    Rule::ExactMatch("wg-tools".to_string()),
                    RuleMetadata { description: "For Tools WG only".to_string() }.into(),
                ),
                (
                    Rule::StartsWith("funding".to_string()),
                    RuleMetadata { description: "For funding team only".to_string() }.into(),
                ),
                (
                    Rule::StartsWith("mnw".to_string()),
                    RuleMetadata { description: "For Wallet WG only".to_string() }.into(),
                ),
            ]),
        }
    }

    #[test]
    fn rule_list_serialization_deserialization() {
        let list = create_list();

        let list_json = serde_json::json!(
            {
                "wg-protocol": { "description": "For Protocol WG only", "rule_metadata_version": "V0"},
                "wg-tools": {"description": "For Tools WG only", "rule_metadata_version": "V0" },
                "starts-with:funding": {"description": "For funding team only", "rule_metadata_version": "V0" },
                "starts-with:mnw": {"description": "For Wallet WG only", "rule_metadata_version": "V0" }
            }
        );
        assert_eq!(serde_json::to_value(list.clone()).unwrap(), list_json);
        assert_eq!(serde_json::from_value::<RulesList>(list_json).unwrap(), list);
    }

    #[test]
    fn is_restricted() {
        let list = create_list();
        assert!(list.is_restricted(&"wg-protocol".to_string()));
        assert!(list.is_restricted(&"wg-tools".to_string()));
        assert!(!list.is_restricted(&"wg-wallet".to_string()));
        assert!(list.is_restricted(&"funding".to_string()));
        assert!(list.is_restricted(&"fundingfoobar".to_string()));
        assert!(list.is_restricted(&"funding-requested".to_string()));
        assert!(!list.is_restricted(&"nofunding".to_string()));
        assert!(list.is_restricted(&"mnw".to_string()));
        assert!(list.is_restricted(&"mnw-approved".to_string()));
        assert!(!list.is_restricted(&"nomnw".to_string()));
    }

    #[test]
    fn find_restricted() {
        let list = create_list();
        let actual = list.find_restricted(vec![
            "wg-protocol".to_string(),
            "wg-tools".to_string(),
            "wg-wallet".to_string(),
            "funding".to_string(),
            "funding".to_string(),
            "fundingfoobar".to_string(),
            "fundingfoobar".to_string(),
            "funding-requested".to_string(),
            "nofunding".to_string(),
            "nofunding".to_string(),
            "mnw".to_string(),
            "mnw-approved".to_string(),
            "nomnw".to_string(),
        ]);
        let expected = HashSet::from([
            "wg-protocol".to_string(),
            "wg-tools".to_string(),
            "funding".to_string(),
            "fundingfoobar".to_string(),
            "funding-requested".to_string(),
            "mnw".to_string(),
            "mnw-approved".to_string(),
        ]);
        assert_eq!(actual, expected);
    }
}

'''
'''--- src/community.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId};

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Community {
    pub name: String,
    pub description: String,
    pub image_url: String,
    pub thumbnail_url: String,
    pub overview_page_markdown: String,
    pub events_page_markdown: String,
    pub admins: Vec<AccountId>,
    pub labels: Vec<String>,
    pub telegram_handles: Vec<String>,
    /// JSON string of github board configuration
    pub github: Option<String>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CommunityCard {
    pub slug: String,
    pub name: String,
    pub description: String,
    pub image_url: String,
}

impl Community {
    pub fn validate(&self) {
        if self.name.len() > 30 {
            panic!("Community name is limit to 30 characters");
        }
        if self.description.len() > 60 {
            panic!("Community description is limit to 60 characters");
        }
        if self.labels.len() == 0 {
            panic!("At least one primary label is required");
        }
    }

    pub fn set_default_admin(&mut self) {
        if self.admins.is_empty() {
            self.admins = vec![env::predecessor_account_id()];
        }
    }
}

'''
'''--- src/debug.rs ---
use crate::*;
use near_sdk::near_bindgen;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats {
    pub num_posts: u64,
}

#[near_bindgen]
impl Contract {
    pub fn get_post_to_parent(&self) -> Vec<(PostId, PostId)> {
        let mut res = vec![];
        for child_id in 0..self.posts.len() {
            if let Some(parent_id) = self.post_to_parent.get(&child_id) {
                res.push((child_id, parent_id));
            }
        }
        res
    }

    pub fn get_parent_to_children(&self) -> Vec<(PostId, Vec<PostId>)> {
        let mut res = vec![];
        for parent_id in 0..self.posts.len() {
            if let Some(children_ids) = self.post_to_children.get(&parent_id) {
                res.push((parent_id, children_ids));
            }
        }
        res
    }
}

'''
'''--- src/lib.rs ---
pub mod access_control;
pub mod community;
pub mod debug;
pub mod migrations;
mod notify;
pub mod post;
mod repost;
mod social_db;
pub mod stats;
pub mod str_serializers;

use crate::access_control::members::ActionType;
use crate::access_control::members::Member;
use crate::access_control::AccessControl;
use community::{Community, CommunityCard};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, Vector};
use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault};
use post::*;
use std::collections::HashSet;

near_sdk::setup_alloc!();

type PostId = u64;
type IdeaId = u64;
type AttestationId = u64;
type SubmissionId = u64;
type SponsorshipId = u64;
type CommentId = u64;

/// An imaginary top post representing the landing page.
const ROOT_POST_ID: u64 = u64::MAX;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub communities: UnorderedMap<String, Community>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        migrations::state_version_write(&migrations::StateVersion::V4);
        let mut contract = Self {
            posts: Vector::new(StorageKey::Posts),
            post_to_parent: LookupMap::new(StorageKey::PostToParent),
            post_to_children: LookupMap::new(StorageKey::PostToChildren),
            label_to_posts: UnorderedMap::new(StorageKey::LabelToPostsV2),
            access_control: AccessControl::default(),
            authors: UnorderedMap::new(StorageKey::AuthorToAuthorPosts),
            communities: UnorderedMap::new(StorageKey::Communities),
        };
        contract.post_to_children.insert(&ROOT_POST_ID, &Vec::new());
        contract
    }

    /// If `parent_id` is not provided get all landing page posts. Otherwise, get all posts under
    /// `parent_id` post.
    pub fn get_posts(&self, parent_id: Option<PostId>) -> Vec<VersionedPost> {
        near_sdk::log!("get_posts");
        let parent_id = parent_id.unwrap_or(ROOT_POST_ID);
        let children_ids = self
            .post_to_children
            .get(&parent_id)
            .unwrap_or_else(|| panic!("Parent id {} not found", parent_id));
        children_ids
            .into_iter()
            .map(|id| {
                self.posts
                    .get(id)
                    .unwrap_or_else(|| panic!("Post id {} not found. Broken state invariant", id))
            })
            .collect()
    }

    pub fn get_post(&self, post_id: PostId) -> VersionedPost {
        near_sdk::log!("get_post");
        self.posts.get(post_id).unwrap_or_else(|| panic!("Post id {} not found", post_id))
    }

    pub fn get_all_post_ids(&self) -> Vec<PostId> {
        (0..self.posts.len()).into_iter().collect()
    }

    pub fn get_children_ids(&self, post_id: Option<PostId>) -> Vec<PostId> {
        near_sdk::log!("get_children_ids");
        let post_id = post_id.unwrap_or(ROOT_POST_ID);
        self.post_to_children
            .get(&post_id)
            .unwrap_or_else(|| panic!("Parent id {} not found", post_id))
    }

    pub fn get_parent_id(&self, post_id: PostId) -> Option<PostId> {
        near_sdk::log!("get_parent_id");
        let res = self
            .post_to_parent
            .get(&post_id)
            .unwrap_or_else(|| panic!("Parent id {} not found", post_id));
        if res == ROOT_POST_ID {
            Option::None
        } else {
            Option::Some(res)
        }
    }

    #[payable]
    pub fn add_like(&mut self, post_id: PostId) {
        near_sdk::log!("add_like");
        let mut post: Post = self
            .posts
            .get(post_id)
            .unwrap_or_else(|| panic!("Post id {} not found", post_id))
            .into();
        let post_author = post.author_id.clone();
        let like =
            Like { author_id: env::predecessor_account_id(), timestamp: env::block_timestamp() };
        post.likes.insert(like);
        self.posts.replace(post_id, &post.into());
        notify::notify_like(post_id, post_author);
    }

    #[payable]
    pub fn add_post(&mut self, parent_id: Option<PostId>, body: PostBody, labels: HashSet<String>) {
        near_sdk::log!("add_post");
        let parent_id = parent_id.unwrap_or(ROOT_POST_ID);
        let id = self.posts.len();
        let author_id = env::predecessor_account_id();
        let editor_id = author_id.clone();
        assert!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels.iter().cloned().collect()
            ),
            "Cannot use these labels"
        );

        for label in &labels {
            let mut other_posts = self.label_to_posts.get(label).unwrap_or_default();
            other_posts.insert(id);
            self.label_to_posts.insert(label, &other_posts);
        }
        let post = Post {
            id,
            author_id: author_id.clone(),
            likes: Default::default(),
            snapshot: PostSnapshot { editor_id, timestamp: env::block_timestamp(), labels, body },
            snapshot_history: vec![],
        };
        self.posts.push(&post.clone().into());
        self.post_to_parent.insert(&id, &parent_id);

        let mut siblings = self
            .post_to_children
            .get(&parent_id)
            .unwrap_or_else(|| panic!("Parent id {} not found", parent_id));
        siblings.push(id);
        self.post_to_children.insert(&parent_id, &siblings);

        // Don't forget to add an empty list of your own children.
        self.post_to_children.insert(&id, &vec![]);

        let mut author_posts = self.authors.get(&author_id).unwrap_or_else(|| HashSet::new());
        author_posts.insert(post.id);
        self.authors.insert(&post.author_id, &author_posts);

        if parent_id != ROOT_POST_ID {
            let parent_post: Post = self
                .posts
                .get(parent_id)
                .unwrap_or_else(|| panic!("Parent post with id {} not found", parent_id))
                .into();
            let parent_author = parent_post.author_id;
            notify::notify_reply(parent_id, parent_author);
        } else {
            repost::repost(post);
        }
    }

    pub fn get_posts_by_author(&self, author: AccountId) -> Vec<PostId> {
        self.authors.get(&author).map(|posts| posts.into_iter().collect()).unwrap_or(Vec::new())
    }

    pub fn get_posts_by_label(&self, label: String) -> Vec<PostId> {
        near_sdk::log!("get_posts_by_label");
        let mut res: Vec<_> =
            self.label_to_posts.get(&label).unwrap_or_default().into_iter().collect();
        res.sort();
        res
    }

    pub fn get_all_labels(&self) -> Vec<String> {
        near_sdk::log!("get_all_labels");
        let mut res: Vec<_> = self.label_to_posts.keys().collect();
        res.sort();
        res
    }

    pub fn get_all_authors(&self) -> Vec<String> {
        near_sdk::log!("get_all_authors");
        let mut res: Vec<_> = self.authors.keys().collect();
        res.sort();
        res
    }

    pub fn is_allowed_to_edit(&self, post_id: PostId, editor: Option<AccountId>) -> bool {
        near_sdk::log!("is_allowed_to_edit");
        let post: Post = self
            .posts
            .get(post_id)
            .unwrap_or_else(|| panic!("Post id {} not found", post_id))
            .into();
        let editor = match editor {
            None => env::predecessor_account_id(),
            Some(e) => e,
        };
        // First check for simple cases.
        if editor == env::current_account_id() || editor == post.author_id {
            return true;
        }

        // Then check for complex case.
        self.access_control
            .members_list
            .check_permissions(editor, post.snapshot.labels.iter().cloned().collect())
            .contains(&ActionType::EditPost)
    }

    pub fn is_allowed_to_use_labels(&self, editor: Option<AccountId>, labels: Vec<String>) -> bool {
        let editor = match editor {
            None => env::predecessor_account_id(),
            Some(e) => e,
        };
        // First check for simple cases.
        if editor == env::current_account_id() {
            return true;
        }
        let restricted_labels = self.access_control.rules_list.find_restricted(labels.clone());
        if restricted_labels.is_empty() {
            return true;
        }
        self.access_control
            .members_list
            .check_permissions(editor, labels)
            .contains(&ActionType::UseLabels)
    }

    pub fn get_all_allowed_labels(&self, editor: AccountId) -> Vec<String> {
        near_sdk::log!("get_all_allowed_labels");
        let mut res: Vec<_> = self
            .label_to_posts
            .keys()
            .filter(|label| {
                self.is_allowed_to_use_labels(Some(editor.clone()), vec![label.clone()])
            })
            .collect();
        res.sort();
        res
    }

    #[payable]
    pub fn edit_post(&mut self, id: PostId, body: PostBody, labels: HashSet<String>) {
        near_sdk::log!("edit_post");
        assert!(
            self.is_allowed_to_edit(id, Option::None),
            "The account is not allowed to edit this post"
        );
        let editor_id = env::predecessor_account_id();
        let mut post: Post =
            self.posts.get(id).unwrap_or_else(|| panic!("Post id {} not found", id)).into();

        let old_snapshot = post.snapshot.clone();
        let old_labels_set = old_snapshot.labels.clone();
        let new_labels = labels;
        let new_snapshot = PostSnapshot {
            editor_id: editor_id.clone(),
            timestamp: env::block_timestamp(),
            labels: new_labels.clone(),
            body,
        };
        post.snapshot = new_snapshot;
        post.snapshot_history.push(old_snapshot);
        let post_author = post.author_id.clone();
        self.posts.replace(id, &post.into());

        // Update labels index.

        let new_labels_set = new_labels;
        let labels_to_remove = &old_labels_set - &new_labels_set;
        let labels_to_add = &new_labels_set - &old_labels_set;
        assert!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels_to_remove.iter().cloned().collect()
            ),
            "Not allowed to remove these labels"
        );
        assert!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels_to_add.iter().cloned().collect()
            ),
            "Not allowed to add these labels"
        );

        for label_to_remove in labels_to_remove {
            let mut posts = self.label_to_posts.get(&label_to_remove).unwrap();
            posts.remove(&id);
            self.label_to_posts.insert(&label_to_remove, &posts);
        }

        for label_to_add in labels_to_add {
            let mut posts = self.label_to_posts.get(&label_to_add).unwrap_or_default();
            posts.insert(id);
            self.label_to_posts.insert(&label_to_add, &posts);
        }

        notify::notify_edit(id, post_author);
    }

    pub fn add_community(&mut self, slug: String, mut community: Community) {
        if self.communities.get(&slug).is_some() {
            panic!("Community already exists");
        }
        community.validate();
        community.set_default_admin();
        self.communities.insert(&slug, &community);
    }

    pub fn edit_community(&mut self, slug: String, mut community: Community) {
        let community_old = self.communities.get(&slug).expect("Community does not exist");
        let moderators = self.access_control.members_list.get_moderators();
        let editor = env::predecessor_account_id();
        if !community_old.admins.contains(&editor)
            && !moderators.contains(&Member::Account(editor.clone()))
        {
            panic!("Only community admins or moderators can edit community");
        }

        community.validate();
        community.set_default_admin();
        self.communities.insert(&slug, &community);
    }

    pub fn get_all_communities(&self) -> Vec<CommunityCard> {
        near_sdk::log!("get_all_communities");
        self.communities
            .iter()
            .map(|(slug, community)| CommunityCard {
                slug,
                name: community.name,
                description: community.description,
                image_url: community.image_url,
            })
            .collect()
    }

    pub fn get_community(&self, slug: String) -> Option<Community> {
        self.communities.get(&slug)
    }
}

'''
'''--- src/migrations.rs ---
//! Public methods of data model/state migrations between the versions.
//! Should be invocable only by the owner and in most cases should be called only once though the
//! latter is not asserted.

use crate::*;
use near_sdk::{env, near_bindgen, Promise};
use std::cmp::min;
use std::collections::HashSet;

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct OldContractV1 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
}

// From OldContractV1 to OldContractV2
#[near_bindgen]
impl Contract {
    fn unsafe_add_acl() {
        let OldContractV1 { posts, post_to_parent, post_to_children, label_to_posts } =
            env::state_read().unwrap();
        env::state_write(&OldContractV2 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control: Default::default(),
        });
    }
}

// // Fake vector purely for the sake of overriding initialization.
// #[derive(BorshSerialize, BorshDeserialize)]
// pub struct FakeVector {
//     len: u64,
//     prefix: Vec<u8>,
// }
//
// impl FakeVector {
//     pub fn new<S>(len: u64, prefix: S) -> Self
//     where
//         S: IntoStorageKey,
//     {
//         Self { len, prefix: prefix.into_storage_key() }
//     }
// }

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct OldContractV2 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
}

// From OldContractV2 to OldContractV3
#[near_bindgen]
impl Contract {
    fn unsafe_add_post_authors() {
        let OldContractV2 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
        } = env::state_read().unwrap();
        let authors = UnorderedMap::new(StorageKey::AuthorToAuthorPosts);

        env::state_write(&OldContractV3 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
        });
    }

    fn unsafe_insert_old_post_authors(start: u64, end: u64) -> StateVersion {
        let mut contract: OldContractV3 = env::state_read().unwrap();
        let total = contract.posts.len();
        let end = min(total, end);
        for i in start..end {
            let versioned_post = contract.posts.get(i);
            if let Some(versioned_post) = versioned_post {
                let post: Post = versioned_post.into();
                let mut author_posts =
                    contract.authors.get(&post.author_id).unwrap_or_else(|| HashSet::new());
                author_posts.insert(post.id);
                contract.authors.insert(&post.author_id, &author_posts);
            }
        }
        env::state_write(&contract);
        StateVersion::V3 { done: end == total, migrated_count: end }
    }
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct OldContractV3 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
}

// From OldContractV3 to Contract
#[near_bindgen]
impl Contract {
    fn unsafe_add_communities() {
        let OldContractV3 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
        } = env::state_read().unwrap();
        env::state_write(&Contract {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities: UnorderedMap::new(StorageKey::Communities),
        });
    }
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub(crate) enum StateVersion {
    V1,
    V2,
    V3 { done: bool, migrated_count: u64 },
    V4,
}

const VERSION_KEY: &[u8] = b"VERSION";

fn state_version_read() -> StateVersion {
    env::storage_read(VERSION_KEY)
        .map(|data| {
            StateVersion::try_from_slice(&data).expect("Cannot deserialize the contract state.")
        })
        .unwrap_or(StateVersion::V2) // StateVersion is introduced in production contract with V2 State.
}

pub(crate) fn state_version_write(version: &StateVersion) {
    let data = version.try_to_vec().expect("Cannot serialize the contract state.");
    env::storage_write(VERSION_KEY, &data);
    near_sdk::log!("Migrated to version: {:?}", version);
}

#[near_bindgen]
impl Contract {
    pub fn unsafe_self_upgrade() {
        near_sdk::assert_self();

        let contract = env::input().expect("No contract code is attached in input");
        Promise::new(env::current_account_id())
            .deploy_contract(contract)
            .then(Promise::new(env::current_account_id()).function_call(
                b"unsafe_migrate".to_vec(),
                Vec::new(),
                0u128,
                env::prepaid_gas() - 60_000_000_000_000u64,
            ))
            .as_return();
    }

    fn migration_done() {
        near_sdk::log!("Migration done.");
        env::value_return(&b"\"done\"".to_vec());
    }

    fn needs_migration() {
        env::value_return(&b"\"needs-migration\"".to_vec());
    }

    pub fn unsafe_migrate() {
        near_sdk::assert_self();
        let current_version = state_version_read();
        near_sdk::log!("Migrating from version: {:?}", current_version);
        match current_version {
            StateVersion::V1 => {
                Contract::unsafe_add_acl();
                state_version_write(&StateVersion::V2);
            }
            StateVersion::V2 => {
                Contract::unsafe_add_post_authors();
                state_version_write(&StateVersion::V3 { done: false, migrated_count: 0 })
            }
            StateVersion::V3 { done: false, migrated_count } => {
                let new_version =
                    Contract::unsafe_insert_old_post_authors(migrated_count, migrated_count + 100);
                state_version_write(&new_version);
            }
            StateVersion::V3 { done: true, migrated_count: _ } => {
                Contract::unsafe_add_communities();
                state_version_write(&StateVersion::V4);
                return Contract::migration_done();
            }
            _ => {
                return Contract::migration_done();
            }
        }
        Contract::needs_migration();
    }
}

'''
'''--- src/notify.rs ---
use crate::social_db::{ext_social_db, SOCIAL_DB};
use crate::PostId;
use near_sdk::serde_json::json;
use near_sdk::{env, AccountId, Promise};

pub fn notify_like(post_id: PostId, post_author: AccountId) -> Promise {
    notify(post_id, post_author, "like")
}

pub fn notify_reply(post_id: PostId, post_author: AccountId) -> Promise {
    notify(post_id, post_author, "reply")
}

pub fn notify_edit(post_id: PostId, post_author: AccountId) -> Promise {
    notify(post_id, post_author, "edit")
}

fn notify(post_id: PostId, post_author: AccountId, action: &str) -> Promise {
    ext_social_db::set(
        json!({
            env::predecessor_account_id() : {
                "index": {
                    "notify": json!({
                        "key": post_author,
                        "value": {
                            "type": format!("near-analytics/{}", action),
                            "post": post_id,
                        },
                    }).to_string()
                }
            }
        }),
        &SOCIAL_DB,
        env::attached_deposit(),
        env::prepaid_gas() / 2,
    )
}

'''
'''--- src/post/attestation.rs ---
use super::{Like, PostStatus};
use crate::str_serializers::*;
use crate::{AttestationId, CommentId, SubmissionId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Timestamp};
use std::collections::HashSet;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Attestation {
    // Common fields
    pub id: AttestationId,
    pub name: String,
    pub description: String,
    pub author_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub status: PostStatus,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,

    //Specific fields
    #[serde(with = "u64_dec_format")]
    pub submission_id: SubmissionId,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct AttestationV1 {
    pub name: String,
    pub description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "attestation_version")]
pub enum VersionedAttestation {
    V0(Attestation),
    V1(AttestationV1),
}

impl VersionedAttestation {
    pub fn latest_version(self) -> AttestationV1 {
        self.into()
    }
}

impl From<VersionedAttestation> for Attestation {
    fn from(va: VersionedAttestation) -> Self {
        match va {
            VersionedAttestation::V0(v0) => v0,
            VersionedAttestation::V1(_) => unimplemented!(),
        }
    }
}

impl From<VersionedAttestation> for AttestationV1 {
    fn from(va: VersionedAttestation) -> Self {
        match va {
            VersionedAttestation::V0(_) => unimplemented!(),
            VersionedAttestation::V1(v1) => v1,
        }
    }
}

impl From<Attestation> for VersionedAttestation {
    fn from(a: Attestation) -> Self {
        VersionedAttestation::V0(a)
    }
}

'''
'''--- src/post/comment.rs ---
use super::Like;
use crate::str_serializers::*;
use crate::CommentId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Timestamp};
use std::collections::HashSet;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CommentV0 {
    pub author_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub description: String,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Comment {
    pub id: CommentId,
    pub author_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub description: String,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CommentV2 {
    pub description: String,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "comment_version")]
pub enum VersionedComment {
    V0(CommentV0),
    V1(Comment),
    V2(CommentV2),
}

impl VersionedComment {
    pub fn latest_version(self) -> CommentV2 {
        self.into()
    }
}

impl From<VersionedComment> for Comment {
    fn from(vc: VersionedComment) -> Self {
        match vc {
            VersionedComment::V0(v0) => Comment {
                id: 0,
                author_id: v0.author_id,
                timestamp: v0.timestamp,
                description: v0.description,
                likes: v0.likes,
                comments: v0.comments,
            },
            VersionedComment::V1(v1) => v1,
            VersionedComment::V2(_) => unimplemented!(),
        }
    }
}

impl From<VersionedComment> for CommentV2 {
    fn from(vc: VersionedComment) -> Self {
        match vc {
            VersionedComment::V2(v2) => v2,
            _ => unimplemented!(),
        }
    }
}

impl From<Comment> for VersionedComment {
    fn from(c: Comment) -> Self {
        VersionedComment::V1(c)
    }
}

'''
'''--- src/post/github.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct GithubV0 {
    pub github_link: String,
    pub name: String,
    pub description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "github_version")]
pub enum VersionedGithub {
    V0(GithubV0),
}

impl From<GithubV0> for VersionedGithub {
    fn from(v0: GithubV0) -> Self {
        VersionedGithub::V0(v0)
    }
}

impl From<VersionedGithub> for GithubV0 {
    fn from(vg: VersionedGithub) -> Self {
        match vg {
            VersionedGithub::V0(v0) => v0,
        }
    }
}

'''
'''--- src/post/idea.rs ---
use super::{Like, PostStatus};
use crate::{CommentId, IdeaId, SubmissionId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Timestamp};
use std::collections::HashSet;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Idea {
    // Common Fields
    pub id: IdeaId,
    pub name: String,
    pub description: String,
    pub author_id: AccountId,
    pub timestamp: Timestamp,
    pub status: PostStatus,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,

    // Specific fields
    pub submissions: Vec<SubmissionId>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct IdeaV1 {
    pub name: String,
    pub description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "idea_version")]
pub enum VersionedIdea {
    V0(Idea),
    V1(IdeaV1),
}

impl VersionedIdea {
    pub fn latest_version(self) -> IdeaV1 {
        self.into()
    }
}

impl From<VersionedIdea> for Idea {
    fn from(vi: VersionedIdea) -> Self {
        match vi {
            VersionedIdea::V0(v0) => v0,
            VersionedIdea::V1(_) => unimplemented!(),
        }
    }
}

impl From<VersionedIdea> for IdeaV1 {
    fn from(vi: VersionedIdea) -> Self {
        match vi {
            VersionedIdea::V1(v1) => v1,
            _ => unimplemented!(),
        }
    }
}

impl From<Idea> for VersionedIdea {
    fn from(idea: Idea) -> Self {
        VersionedIdea::V0(idea)
    }
}

'''
'''--- src/post/like.rs ---
use crate::str_serializers::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Timestamp};
use std::cmp::Ordering;
use std::hash::{Hash, Hasher};

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Like {
    pub author_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
}

impl Hash for Like {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.author_id.hash(state)
    }
}

impl PartialEq for Like {
    fn eq(&self, other: &Self) -> bool {
        self.author_id.eq(&other.author_id)
    }
}

impl PartialOrd for Like {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.author_id.partial_cmp(&other.author_id)
    }
}

impl Eq for Like {}

'''
'''--- src/post/mod.rs ---
mod attestation;
mod comment;
mod github;
mod idea;
mod like;
mod sponsorship;
mod submission;

use crate::str_serializers::*;
pub use attestation::*;
pub use comment::*;
pub use idea::*;
pub use like::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, BorshStorageKey, CryptoHash, Timestamp};
pub use sponsorship::*;
use std::collections::HashSet;
pub use submission::*;

pub type PostId = u64;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum PostType {
    Comment,
    Idea,
    Submission,
    Attestation,
    Sponsorship,
    Github,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum PostStatus {
    Open,
    Closed { reason: String },
}

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Ideas,
    Submissions,
    Attestations,
    Sponsorships,
    Comments,
    Posts,
    PostToParent,
    PostToChildren,
    LabelToPosts, // This collection got corrupted by accident.
    LabelToPostsV2,
    AuthorToAuthorPosts,
    AuthorPosts(CryptoHash),
    Communities,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "post_version")]
pub enum VersionedPost {
    V0(Post),
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Post {
    pub id: PostId,
    pub author_id: AccountId,
    pub likes: HashSet<Like>,
    pub snapshot: PostSnapshot,
    // Excludes the current snapshot itself.
    pub snapshot_history: Vec<PostSnapshot>,
}

impl From<VersionedPost> for Post {
    fn from(vp: VersionedPost) -> Self {
        match vp {
            VersionedPost::V0(v0) => v0,
        }
    }
}

impl From<Post> for VersionedPost {
    fn from(p: Post) -> Self {
        VersionedPost::V0(p)
    }
}

type Label = String;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PostSnapshot {
    pub editor_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub labels: HashSet<Label>,
    #[serde(flatten)]
    pub body: PostBody,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "post_type")]
pub enum PostBody {
    Comment(VersionedComment),
    Idea(VersionedIdea),
    Submission(VersionedSubmission),
    Attestation(VersionedAttestation),
    Sponsorship(VersionedSponsorship),
}

'''
'''--- src/post/sponsorship.rs ---
use super::{Like, PostStatus};
use crate::str_serializers::*;
use crate::{CommentId, IdeaId, SponsorshipId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, Timestamp};
use std::collections::HashSet;
use std::str::FromStr;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum SponsorshipToken {
    Near,
    NEP141 { address: AccountId },
    USD,
}

impl FromStr for SponsorshipToken {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "near" => Ok(Self::Near),
            _ => Ok(Self::NEP141 { address: s.to_string() }),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Sponsorship {
    // Common fields
    pub id: SponsorshipId,
    pub name: String,
    pub description: String,
    pub author_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub status: PostStatus,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,

    // Specific fields
    #[serde(with = "u64_dec_format")]
    pub submission_id: IdeaId,
    pub sponsorship_token: SponsorshipToken,
    #[serde(with = "u128_dec_format")]
    pub amount: Balance,
    pub supervisor: AccountId,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SponsorshipV1 {
    pub name: String,
    pub description: String,
    pub sponsorship_token: SponsorshipToken,
    #[serde(with = "u128_dec_format")]
    pub amount: Balance,
    pub supervisor: AccountId,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "sponsorship_version")]
pub enum VersionedSponsorship {
    V0(Sponsorship),
    V1(SponsorshipV1),
}

impl VersionedSponsorship {
    pub fn latest_version(self) -> SponsorshipV1 {
        self.into()
    }
}

impl From<VersionedSponsorship> for Sponsorship {
    fn from(vs: VersionedSponsorship) -> Self {
        match vs {
            VersionedSponsorship::V0(v0) => v0,
            VersionedSponsorship::V1(_) => unimplemented!(),
        }
    }
}

impl From<VersionedSponsorship> for SponsorshipV1 {
    fn from(vs: VersionedSponsorship) -> Self {
        match vs {
            VersionedSponsorship::V1(v1) => v1,
            _ => unimplemented!(),
        }
    }
}

impl From<Sponsorship> for VersionedSponsorship {
    fn from(s: Sponsorship) -> Self {
        VersionedSponsorship::V0(s)
    }
}

'''
'''--- src/post/submission.rs ---
use super::{Like, PostStatus};
use crate::str_serializers::*;
use crate::{AttestationId, CommentId, SponsorshipId, SubmissionId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Timestamp};
use std::collections::HashSet;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Submission {
    // Common fields
    pub id: SubmissionId,
    pub name: String,
    pub description: String,
    pub author_id: AccountId,
    #[serde(with = "u64_dec_format")]
    pub timestamp: Timestamp,
    pub status: PostStatus,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,

    // Specific fields
    #[serde(with = "u64_dec_format")]
    pub idea_id: u64,
    pub attestations: Vec<AttestationId>,
    pub sponsorships: Vec<SponsorshipId>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SubmissionV1 {
    pub name: String,
    pub description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "submission_version")]
pub enum VersionedSubmission {
    V0(Submission),
    V1(SubmissionV1),
}

impl VersionedSubmission {
    pub fn latest_version(self) -> SubmissionV1 {
        self.into()
    }
}

impl From<VersionedSubmission> for Submission {
    fn from(vs: VersionedSubmission) -> Self {
        match vs {
            VersionedSubmission::V0(v0) => v0,
            VersionedSubmission::V1(_) => unimplemented!(),
        }
    }
}

impl From<VersionedSubmission> for SubmissionV1 {
    fn from(vs: VersionedSubmission) -> Self {
        match vs {
            VersionedSubmission::V1(v1) => v1,
            _ => unimplemented!(),
        }
    }
}

impl From<Submission> for VersionedSubmission {
    fn from(s: Submission) -> Self {
        VersionedSubmission::V0(s)
    }
}

'''
'''--- src/repost.rs ---
use crate::post::{Post, PostBody};
use crate::social_db::{ext_social_db, SOCIAL_DB};
use near_sdk::serde_json::json;
use near_sdk::{env, AccountId, Promise};

fn repost_internal(post: Post, contract_address: AccountId) -> near_sdk::serde_json::Value {
    let post_link = format!("https://near.social/#/near-analytics.near/widget/Post?id={}", post.id);
    let title = match post.snapshot.body.clone() {
        PostBody::Idea(idea) => format!("## Idea: {}\n", idea.latest_version().name),
        PostBody::Submission(submission) => {
            format!("## Solution: {}\n", submission.latest_version().name)
        }
        PostBody::Attestation(attestation) => {
            format!("## Attestation: {}\n", attestation.latest_version().name)
        }
        PostBody::Sponsorship(sponsorship) => {
            format!("## Sponsorship: {}\n", sponsorship.latest_version().name)
        }
        _ => Default::default(),
    };

    let desc = match post.snapshot.body.clone() {
        PostBody::Comment(comment) => comment.latest_version().description,
        PostBody::Idea(idea) => idea.latest_version().description,
        PostBody::Submission(submission) => submission.latest_version().description,
        PostBody::Attestation(attestation) => attestation.latest_version().description,
        PostBody::Sponsorship(sponsorship) => sponsorship.latest_version().description,
    };

    let text = format!(
        "@{author} [Posted on TownHall Board]({post_link})\n{title}{desc}",
        author = post.author_id,
        post_link = post_link,
        title = title,
        desc = desc
    );

    let main_value = json!({
        "type": "md",
        "text": text
    })
    .to_string();

    json!({
        contract_address: {
            "post": {
                "main": main_value,
            },
            "index": {
                "post": "{\"key\":\"main\",\"value\":{\"type\":\"md\"}}",
            }
        }
    })
}

pub fn repost(post: Post) -> Promise {
    ext_social_db::set(
        repost_internal(post, env::current_account_id()),
        &SOCIAL_DB,
        env::attached_deposit(),
        env::prepaid_gas() / 2,
    )
}

#[cfg(test)]
mod tests {
    use crate::post::{IdeaV1, Post, PostBody, PostSnapshot, VersionedIdea};
    use crate::repost::repost_internal;
    use near_sdk::serde_json::json;

    #[test]
    pub fn check_formatting() {
        let post = Post {
            id: 0,
            author_id: "neardevgov.near".to_string(),
            likes: Default::default(),
            snapshot: PostSnapshot {
                editor_id: "neardevgov.near".to_string(),
                timestamp: 0,
                labels: Default::default(),
                body: PostBody::Idea(VersionedIdea::V1(IdeaV1 { name: "A call for Zero Knowledge Work Group members!".to_string(), description: "We are excited to create a more formal Zero Knowledge Work Group (WG) to oversee official decisions on Zero Knowledge proposals. We’re looking for 3-7 experts to participate. Reply to the post if you’re interested in becoming a work group member.".to_string() })),
            },
            snapshot_history: vec![],
        };

        let call_args = repost_internal(post, "near-analytics.near".to_string());
        let expected = json!({
            "near-analytics.near": {
                "post": {
                  "main": "{\"type\":\"md\",\"text\":\"@neardevgov.near [Posted on TownHall Board](https://near.social/#/near-analytics.near/widget/Post?id=0)\\n## Idea: A call for Zero Knowledge Work Group members!\\nWe are excited to create a more formal Zero Knowledge Work Group (WG) to oversee official decisions on Zero Knowledge proposals. We’re looking for 3-7 experts to participate. Reply to the post if you’re interested in becoming a work group member.\"}"
                },
                "index": {
                  "post": "{\"key\":\"main\",\"value\":{\"type\":\"md\"}}"
                }
              }
        });
        assert_eq!(call_args, expected);
    }
}

'''
'''--- src/social_db.rs ---
use near_sdk::ext_contract;
use near_sdk::serde_json::Value;

pub const SOCIAL_DB: &str = "social.near";

#[ext_contract(ext_social_db)]
pub trait SocialDB {
    fn set(&mut self, data: Value);
}

'''
'''--- src/stats.rs ---
use crate::*;
use near_sdk::near_bindgen;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats {
    pub num_posts: u64,
}

#[near_bindgen]
impl Contract {
    pub fn get_stats(&self) -> Stats {
        Stats { num_posts: self.posts.len() }
    }
}

'''
'''--- src/str_serializers.rs ---
pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?.parse().map_err(de::Error::custom)
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?.parse().map_err(de::Error::custom)
    }
}

'''
'''--- test.sh ---
#!/bin/bash

contract=i.near-analytics.testnet

near create-account $contract --masterAccount near-analytics.testnet --initialBalance 10
near deploy $contract res/near_analytics.wasm --initFunction new --initArgs '{}'

for i in $(seq 1 2)
do
near call $contract add_post --accountId near-analytics.testnet --deposit 0.01 --args '{"parent_id":null,"body":{"post_type": "Idea","idea_version":"V1","name":"a'$i'","description":"aaa"},"labels":[]}'
near call $contract add_post --accountId near-analytics.testnet --deposit 0.01 --args '{"parent_id":null,"body":{"post_type": "Idea","idea_version":"V1","name":"b'$i'","description":"bbb"},"labels":[]}'
near call $contract add_post --accountId a.near-analytics.testnet --deposit 0.01 --args '{"parent_id":null,"body":{"post_type": "Idea","idea_version":"V1","name":"c'$i'","description":"ccc"},"labels":[]}'
near call $contract add_post --accountId near-analytics.testnet --deposit 0.01 --args '{"parent_id":null,"body":{"post_type": "Idea","idea_version":"V1","name":"d'$i'","description":"ddd"},"labels":[]}'
done

near deploy $contract res/near_analytics.wasm

near call $contract unsafe_self_upgrade --accountId $contract --args $(base64 < res/near_analytics.wasm ) --base64 --gas 300000000000000

near call $contract unsafe_migrate --accountId $contract --gas 300000000000000
'''