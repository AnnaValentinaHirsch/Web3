*GitHub Repository "near/near-abi-client-rs"*

'''--- .github/workflows/release-plz.yml ---
name: Release-plz

permissions:
  pull-requests: write
  contents: write

on:
  push:
    branches:
      - main

jobs:
  release-plz:
    name: Release-plz
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_PLZ_GITHUB_TOKEN }}
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://marcoieni.github.io/release-plz/github-action.html#triggering-further-workflow-runs
          GITHUB_TOKEN: ${{ secrets.RELEASE_PLZ_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- .github/workflows/test.yml ---
name: test

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  msrv-check:
    runs-on: ${{ matrix.platform }}
    strategy:
      fail-fast: false
      matrix:
        platform: [ubuntu-latest, macos-latest]

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v2

      - name: Get MSRV
        run: |
          RUST_MSRV="$(cat near-abi-client/Cargo.toml | sed -n 's/rust-version *= *"\(.*\)"/\1/p')"
          echo "RUST_MSRV=$RUST_MSRV" >> $GITHUB_ENV

      - name: "Install ${{ env.RUST_MSRV }} toolchain (MSRV)"
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: ${{ env.RUST_MSRV }}

      - name: Cargo check
        run: cargo check -p near-abi-client

  tests:
    runs-on: ${{ matrix.platform }}
    strategy:
      fail-fast: false
      matrix:
        platform: [ubuntu-latest, macos-latest]

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v2

      - name: Install `wasm32-unknown-unknown`
        run: rustup target add wasm32-unknown-unknown

      - name: Run tests
        run: cargo test --workspace --verbose

  lint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v2

      - name: Check Formatting
        run: cargo fmt -p near-abi-client -p near-abi-client-macros -p near-abi-client-impl -- --check

      - name: Check Clippy
        run: cargo clippy -p near-abi-client -p near-abi-client-macros -p near-abi-client-impl --tests -- -Dclippy::all

  audit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Sources
        uses: actions/checkout@v2

      - name: Install Audit Tool
        run: cargo install cargo-audit

      - name: Run Audit Tool
        run: cargo audit --ignore RUSTSEC-2021-0145 --ignore RUSTSEC-2023-0033

'''
'''--- CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.1.0] - 2023-01-04

> Release Page: <https://github.com/near/near-abi-client-rs/releases/tag/v0.1.0>

[unreleased]: https://github.com/near/near-abi-client-rs/releases/tag/v0.1.0...HEAD
[0.1.0]: https://github.com/near/near-abi-client-rs/releases/tag/v0.1.0
'''
'''--- Cargo.toml ---
[workspace]
resolver = "2"
members = [
    "near-abi-client",
    "near-abi-client-impl",
    "near-abi-client-macros",
    "examples/*",
]

'''
'''--- README.md ---
<!-- markdownlint-disable MD014 -->

<div align="center">

  <h1><code>near-abi-client-rs</code></h1>

  <p>
    <strong>Library to generate Rust client code with <a href="https://github.com/near/workspaces-rs">workspaces-rs</a> from <a href="https://github.com/near/abi">ABI schemas</a> on NEAR</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-abi-client-rs/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-abi-client-rs/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-abi-client"><img src="https://img.shields.io/crates/v/near-abi-client.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-abi-client"><img src="https://img.shields.io/crates/d/near-abi-client.svg?style=flat-square" alt="Downloads" /></a>
  </p>

</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Usage

This crate supports two sets of APIs for users with different needs:
* **Macro-driven**. Gives you a client in a single macro invocation.
* **Generation-based**. Gives you more control and is transparent about what code you end up using, but requires more setup.

### Macro API

Checkout the [`delegator-macro`](https://github.com/near/near-abi-client-rs/tree/main/examples/delegator-macro) example for a standalone project using macro API to get a client and use it.

To generate a struct named `ClientName` based on ABI located at `path/to/abi.json` (relative to the current file's directory):

```rust
mod mymod {
    near_abi_client::generate!(ClientName for "path/to/abi.json");
}
```

Placing the macro invocation inside a `mod` section is optional, but helps reducing unexpected behaviors such as name clashes.

Now, assuming you have a `contract: near_workspaces::Contract` deployed, you can make a call like this:

```rust
let contract = mymod::ClientName { contract };
let res = contract
    .my_method_name(arg1, arg2)
    .await?;
```

### Generation API

Checkout the [`delegator-generation`](https://github.com/near/near-abi-client-rs/tree/main/examples/delegator-generation) example for a standalone project using generation API to generate a client and use it.

First, we need our package to have a `build.rs` file that runs the generation step. The following snippet will generate the client in `abi.rs` under `path/to/out/dir`:

```rust
fn main() -> anyhow::Result<()> {
    near_abi_client::Generator::new("path/to/out/dir".into())
        .file("path/to/abi.json")
        .generate()?;
    Ok(())
}
```

The resulting file, however, is not included in your source set by itself. You have to include it manually; the recommended way is to create a mod with a custom path:

```
#[path = "path/to/out/dir/abi.rs"]
mod mymod;
```

Now, assuming you have a `contract: near_workspaces::Contract` deployed, you can make a call like this:

```rust
let contract = mymod::AbiClient { contract };
let res = contract
    .my_method_name(arg1, arg2)
    .await?;
```

Feel free to explore what other methods `Generator` has to customize the resulting code (e.g. client struct name).

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- examples/delegator-generation/Cargo.toml ---
[package]
publish = false
name = "delegator-generation"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0"
near-workspaces = "0.10.0"

[dev-dependencies]
tokio = { version = "1.14", features = ["full"] }

[build-dependencies]
anyhow = "1.0"
near-abi-client = { path = "../../near-abi-client", version = "0.1.1" }

'''
'''--- examples/delegator-generation/build.rs ---
use near_abi_client::Generator;

fn main() -> anyhow::Result<()> {
    Generator::new("gen".into())
        .file("src/adder.json")
        .generate()?;
    Ok(())
}

'''
'''--- examples/delegator-generation/src/adder.json ---
{
  "schema_version": "0.4.0",
  "metadata": {
    "name": "abi",
    "version": "0.1.0",
    "authors": [
      "Near Inc <hello@nearprotocol.com>"
    ]
  },
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}

'''
'''--- examples/delegator-generation/src/lib.rs ---
#[path = "../gen/adder.rs"]
mod adder;

pub async fn run(a: u32, b: u32, c: u32, d: u32) -> anyhow::Result<(u32, u32)> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker
        .dev_deploy(include_bytes!("../res/adder.wasm"))
        .await?;

    let contract = adder::AbiClient { contract };
    let res = contract
        .add(vec![a.into(), b.into()], vec![c.into(), d.into()])
        .await?;

    Ok((res[0].try_into().unwrap(), res[1].try_into().unwrap()))
}

'''
'''--- examples/delegator-generation/tests/mod.rs ---
use delegator_generation::run;

#[tokio::test]
async fn test_client() -> anyhow::Result<()> {
    assert_eq!(run(1, 2, 3, 4).await?, (4, 6));

    Ok(())
}

'''
'''--- examples/delegator-macro/Cargo.toml ---
[package]
publish = false
name = "delegator-macro"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0"
near-workspaces = "0.10.0"
near-abi-client = { path = "../../near-abi-client", version = "0.1.1" }

[dev-dependencies]
tokio = { version = "1.14", features = ["full"] }

'''
'''--- examples/delegator-macro/src/adder.json ---
{
  "schema_version": "0.4.0",
  "metadata": {
    "name": "abi",
    "version": "0.1.0",
    "authors": [
      "Near Inc <hello@nearprotocol.com>"
    ]
  },
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}

'''
'''--- examples/delegator-macro/src/lib.rs ---
mod adder {
    near_abi_client::generate!(Client for "src/adder.json");
}

pub async fn run(a: u32, b: u32, c: u32, d: u32) -> anyhow::Result<(u32, u32)> {
    let worker = near_workspaces::sandbox().await?;
    let contract = worker
        .dev_deploy(include_bytes!("../res/adder.wasm"))
        .await?;

    let contract = adder::Client { contract };
    let res = contract
        .add(vec![a.into(), b.into()], vec![c.into(), d.into()])
        .await?;

    Ok((res[0].try_into().unwrap(), res[1].try_into().unwrap()))
}

'''
'''--- examples/delegator-macro/tests/mod.rs ---
use delegator_macro::run;

#[tokio::test]
async fn test_client() -> anyhow::Result<()> {
    assert_eq!(run(1, 2, 3, 4).await?, (4, 6));

    Ok(())
}

'''
'''--- near-abi-client-impl/CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.1.1](https://github.com/near/near-abi-client-rs/compare/near-abi-client-impl-v0.1.0...near-abi-client-impl-v0.1.1) - 2024-01-25

### Fixed
- bump dependency versions ([#14](https://github.com/near/near-abi-client-rs/pull/14))

'''
'''--- near-abi-client-impl/Cargo.toml ---
[package]
name = "near-abi-client-impl"
version = "0.1.1"
edition = "2021"
license = "MIT OR Apache-2.0"
readme = "README.md"
repository = "https://github.com/near/near-abi-client-rs"
description = """
Library to generate Rust clients for NEAR smart contracts.
"""

[dependencies]
quote = "1.0"
anyhow = "1.0"
schemars = "0.8"
serde_json = "1.0"
proc-macro2 = "1.0"
near_schemafy_lib = "0.7"

near-abi = "0.4.0"

'''
'''--- near-abi-client-impl/README.md ---
<!-- markdownlint-disable MD014 -->

<div align="center">

  <h1><code>near-abi-client-rs</code></h1>

  <p>
    <strong>Library to generate Rust client code with <a href="https://github.com/near/workspaces-rs">workspaces-rs</a> from <a href="https://github.com/near/abi">ABI schemas</a> on NEAR</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-abi-client-rs/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-abi-client-rs/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-abi-client"><img src="https://img.shields.io/crates/v/near-abi-client.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-abi-client"><img src="https://img.shields.io/crates/d/near-abi-client.svg?style=flat-square" alt="Downloads" /></a>
  </p>

</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Usage

This crate supports two sets of APIs for users with different needs:
* **Macro-driven**. Gives you a client in a single macro invocation.
* **Generation-based**. Gives you more control and is transparent about what code you end up using, but requires more setup.

### Macro API

Checkout the [`delegator-macro`](https://github.com/near/near-abi-client-rs/tree/main/examples/delegator-macro) example for a standalone project using macro API to get a client and use it.

To generate a struct named `ClientName` based on ABI located at `path/to/abi.json` (relative to the current file's directory):

```rust
mod mymod {
    near_abi_client::generate!(ClientName for "path/to/abi.json");
}
```

Placing the macro invocation inside a `mod` section is optional, but helps reducing unexpected behaviors such as name clashes.

Now, assuming you have a `contract: near_workspaces::Contract` deployed, you can make a call like this:

```rust
let contract = mymod::ClientName { contract };
let res = contract
    .my_method_name(arg1, arg2)
    .await?;
```

### Generation API

Checkout the [`delegator-generation`](https://github.com/near/near-abi-client-rs/tree/main/examples/delegator-generation) example for a standalone project using generation API to generate a client and use it.

First, we need our package to have a `build.rs` file that runs the generation step. The following snippet will generate the client in `abi.rs` under `path/to/out/dir`:

```rust
fn main() -> anyhow::Result<()> {
    near_abi_client::Generator::new("path/to/out/dir".into())
        .file("path/to/abi.json")
        .generate()?;
    Ok(())
}
```

The resulting file, however, is not included in your source set by itself. You have to include it manually; the recommended way is to create a mod with a custom path:

```
#[path = "path/to/out/dir/abi.rs"]
mod mymod;
```

Now, assuming you have a `contract: near_workspaces::Contract` deployed, you can make a call like this:

```rust
let contract = mymod::AbiClient { contract };
let res = contract
    .my_method_name(arg1, arg2)
    .await?;
```

Feel free to explore what other methods `Generator` has to customize the resulting code (e.g. client struct name).

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- near-abi-client-impl/src/lib.rs ---
use near_abi::{AbiFunctionKind, AbiParameters, AbiRoot, AbiType};
use near_schemafy_lib::{Expander, Generator, Schema};
use quote::{format_ident, quote};
use std::path::{Path, PathBuf};

pub fn generate_abi_client(
    near_abi: AbiRoot,
    contract_name: proc_macro2::Ident,
) -> proc_macro2::TokenStream {
    let schema_json = serde_json::to_string(&near_abi.body.root_schema).unwrap();

    let generator = Generator::builder().with_input_json(&schema_json).build();
    let (mut token_stream, schema) = generator.generate_with_schema();
    let mut expander = Expander::new(None, "", &schema);

    token_stream.extend(quote! {
        pub struct #contract_name {
            pub contract: near_workspaces::Contract,
        }
    });

    let mut methods_stream = proc_macro2::TokenStream::new();
    for function in near_abi.body.functions {
        let name = format_ident!("{}", function.name);

        let mut param_names = vec![];
        let params = match &function.params {
            AbiParameters::Borsh { .. } => panic!("Borsh is currently unsupported"),
            AbiParameters::Json { args } => args
                .iter()
                .map(|arg| {
                    param_names.push(format_ident!("{}", arg.name));
                    let arg_name = param_names.last().unwrap();
                    let arg_type = expand_subschema(&mut expander, &arg.type_schema);
                    quote! { #arg_name: #arg_type }
                })
                .collect::<Vec<_>>(),
        };

        let return_type = function
            .result
            .map(|r_type| match r_type {
                AbiType::Json { type_schema } => expand_subschema(&mut expander, &type_schema),
                AbiType::Borsh { type_schema: _ } => panic!("Borsh is currently unsupported"),
            })
            .unwrap_or_else(|| format_ident!("{}", "()"));
        let name_str = name.to_string();
        let args = if param_names.is_empty() {
            // Special case for parameter-less functions because otherwise the type for
            // `[]` is not inferrable.
            quote! { () }
        } else {
            quote! { [#(#param_names),*] }
        };
        if function.kind == AbiFunctionKind::View {
            methods_stream.extend(quote! {
                pub async fn #name(
                    &self,
                    #(#params),*
                ) -> anyhow::Result<#return_type> {
                    let result = self.contract
                        .call(#name_str)
                        .args_json(#args)
                        .view()
                        .await?;
                    Ok(result.json::<#return_type>()?)
                }
            });
        } else {
            methods_stream.extend(quote! {
                pub async fn #name(
                    &self,
                    gas: near_workspaces::types::Gas,
                    deposit: near_workspaces::types::Balance,
                    #(#params),*
                ) -> anyhow::Result<#return_type> {
                    let result = self.contract
                        .call(#name_str)
                        .args_json(#args)
                        .gas(gas)
                        .deposit(deposit)
                        .transact()
                        .await?;
                    Ok(result.json::<#return_type>()?)
                }
            });
        }
    }

    token_stream.extend(quote! {
        impl #contract_name {
            #methods_stream
        }
    });

    token_stream
}

pub fn read_abi(abi_path: impl AsRef<Path>) -> AbiRoot {
    let abi_path = if abi_path.as_ref().is_relative() {
        let crate_root = get_crate_root().unwrap();
        crate_root.join(&abi_path)
    } else {
        PathBuf::from(abi_path.as_ref())
    };

    let abi_json = std::fs::read_to_string(&abi_path)
        .unwrap_or_else(|err| panic!("Unable to read `{}`: {}", abi_path.to_string_lossy(), err));

    serde_json::from_str::<AbiRoot>(&abi_json).unwrap_or_else(|err| {
        panic!(
            "Cannot parse `{}` as ABI: {}",
            abi_path.to_string_lossy(),
            err
        )
    })
}

fn get_crate_root() -> std::io::Result<PathBuf> {
    if let Ok(path) = std::env::var("CARGO_MANIFEST_DIR") {
        return Ok(PathBuf::from(path));
    }

    let current_dir = std::env::current_dir()?;

    for p in current_dir.ancestors() {
        if std::fs::read_dir(p)?
            .filter_map(Result::ok)
            .any(|p| p.file_name().eq("Cargo.toml"))
        {
            return Ok(PathBuf::from(p));
        }
    }

    Ok(current_dir)
}

fn schemars_schema_to_schemafy(schema: &schemars::schema::Schema) -> Schema {
    let schema_json = serde_json::to_string(&schema).unwrap();
    serde_json::from_str(&schema_json).unwrap_or_else(|err| {
        panic!(
            "Could not convert schemars schema to schemafy model: {}",
            err
        )
    })
}

fn expand_subschema(
    expander: &mut Expander,
    schema: &schemars::schema::Schema,
) -> proc_macro2::Ident {
    let schemafy_schema = schemars_schema_to_schemafy(schema);
    format_ident!("{}", expander.expand_type_from_schema(&schemafy_schema).typ)
}

'''
'''--- near-abi-client-macros/CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.1.1](https://github.com/near/near-abi-client-rs/compare/near-abi-client-macros-v0.1.0...near-abi-client-macros-v0.1.1) - 2024-01-25

### Other
- updated the following local packages: near-abi-client-impl

'''
'''--- near-abi-client-macros/Cargo.toml ---
[package]
name = "near-abi-client-macros"
version = "0.1.1"
edition = "2021"
license = "MIT OR Apache-2.0"
readme = "README.md"
repository = "https://github.com/near/near-abi-client-rs"
description = """
Library to generate Rust clients for NEAR smart contracts.
"""

[lib]
proc-macro = true

[dependencies]
syn = "1.0"

near-abi-client-impl = { path = "../near-abi-client-impl", version = "0.1.1" }

'''
'''--- near-abi-client-macros/README.md ---
<!-- markdownlint-disable MD014 -->

<div align="center">

  <h1><code>near-abi-client-rs</code></h1>

  <p>
    <strong>Library to generate Rust client code with <a href="https://github.com/near/workspaces-rs">workspaces-rs</a> from <a href="https://github.com/near/abi">ABI schemas</a> on NEAR</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-abi-client-rs/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-abi-client-rs/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-abi-client"><img src="https://img.shields.io/crates/v/near-abi-client.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-abi-client"><img src="https://img.shields.io/crates/d/near-abi-client.svg?style=flat-square" alt="Downloads" /></a>
  </p>

</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Usage

This crate supports two sets of APIs for users with different needs:
* **Macro-driven**. Gives you a client in a single macro invocation.
* **Generation-based**. Gives you more control and is transparent about what code you end up using, but requires more setup.

### Macro API

Checkout the [`delegator-macro`](https://github.com/near/near-abi-client-rs/tree/main/examples/delegator-macro) example for a standalone project using macro API to get a client and use it.

To generate a struct named `ClientName` based on ABI located at `path/to/abi.json` (relative to the current file's directory):

```rust
mod mymod {
    near_abi_client::generate!(ClientName for "path/to/abi.json");
}
```

Placing the macro invocation inside a `mod` section is optional, but helps reducing unexpected behaviors such as name clashes.

Now, assuming you have a `contract: near_workspaces::Contract` deployed, you can make a call like this:

```rust
let contract = mymod::ClientName { contract };
let res = contract
    .my_method_name(arg1, arg2)
    .await?;
```

### Generation API

Checkout the [`delegator-generation`](https://github.com/near/near-abi-client-rs/tree/main/examples/delegator-generation) example for a standalone project using generation API to generate a client and use it.

First, we need our package to have a `build.rs` file that runs the generation step. The following snippet will generate the client in `abi.rs` under `path/to/out/dir`:

```rust
fn main() -> anyhow::Result<()> {
    near_abi_client::Generator::new("path/to/out/dir".into())
        .file("path/to/abi.json")
        .generate()?;
    Ok(())
}
```

The resulting file, however, is not included in your source set by itself. You have to include it manually; the recommended way is to create a mod with a custom path:

```
#[path = "path/to/out/dir/abi.rs"]
mod mymod;
```

Now, assuming you have a `contract: near_workspaces::Contract` deployed, you can make a call like this:

```rust
let contract = mymod::AbiClient { contract };
let res = contract
    .my_method_name(arg1, arg2)
    .await?;
```

Feel free to explore what other methods `Generator` has to customize the resulting code (e.g. client struct name).

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- near-abi-client-macros/src/lib.rs ---
use std::path::PathBuf;

use near_abi_client_impl::{generate_abi_client, read_abi};

#[proc_macro]
pub fn generate(tokens: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let abi_def = syn::parse_macro_input!(tokens as AbiDef);
    let near_abi = read_abi(PathBuf::from(&abi_def.path.value()));

    generate_abi_client(near_abi, abi_def.name).into()
}

struct AbiDef {
    /// Resulting client struct name.
    name: syn::Ident,
    /// Path to the ABI file.
    path: syn::LitStr,
}

impl syn::parse::Parse for AbiDef {
    fn parse(input: syn::parse::ParseStream<'_>) -> syn::Result<Self> {
        let name = input.parse::<syn::Ident>()?;
        input.parse::<syn::Token![for]>()?;
        let path = input.parse()?;
        Ok(AbiDef { name, path })
    }
}

'''
'''--- near-abi-client/CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.1.1](https://github.com/near/near-abi-client-rs/compare/near-abi-client-v0.1.0...near-abi-client-v0.1.1) - 2024-01-25

### Fixed
- bump dependency versions ([#14](https://github.com/near/near-abi-client-rs/pull/14))

'''
'''--- near-abi-client/Cargo.toml ---
[package]
name = "near-abi-client"
version = "0.1.1"
edition = "2021"
rust-version = "1.56.0"
license = "MIT OR Apache-2.0"
readme = "README.md"
repository = "https://github.com/near/near-abi-client-rs"
description = """
Library to generate Rust clients for NEAR smart contracts.
"""

[dependencies]
syn = "1.0"
quote = "1.0"
anyhow = "1.0"
convert_case = "0.5"
prettyplease = "0.1"

near-abi-client-impl = { path = "../near-abi-client-impl", version = "0.1.1" }
near-abi-client-macros = { path = "../near-abi-client-macros", version = "0.1.1" }

[dev-dependencies]
tempfile = "3"

'''
'''--- near-abi-client/README.md ---
<!-- markdownlint-disable MD014 -->

<div align="center">

  <h1><code>near-abi-client-rs</code></h1>

  <p>
    <strong>Library to generate Rust client code with <a href="https://github.com/near/workspaces-rs">workspaces-rs</a> from <a href="https://github.com/near/abi">ABI schemas</a> on NEAR</strong>
  </p>

  <p>
    <a href="https://github.com/near/near-abi-client-rs/actions/workflows/test.yml?query=branch%3Amain"><img src="https://github.com/near/near-abi-client-rs/actions/workflows/test.yml/badge.svg" alt="Github CI Build" /></a>
    <a href="https://crates.io/crates/near-abi-client"><img src="https://img.shields.io/crates/v/near-abi-client.svg?style=flat-square" alt="Crates.io version" /></a>
    <a href="https://crates.io/crates/near-abi-client"><img src="https://img.shields.io/crates/d/near-abi-client.svg?style=flat-square" alt="Downloads" /></a>
  </p>

</div>

## Release notes

**Release notes and unreleased changes can be found in the [CHANGELOG](CHANGELOG.md)**

## Usage

This crate supports two sets of APIs for users with different needs:
* **Macro-driven**. Gives you a client in a single macro invocation.
* **Generation-based**. Gives you more control and is transparent about what code you end up using, but requires more setup.

### Macro API

Checkout the [`delegator-macro`](https://github.com/near/near-abi-client-rs/tree/main/examples/delegator-macro) example for a standalone project using macro API to get a client and use it.

To generate a struct named `ClientName` based on ABI located at `path/to/abi.json` (relative to the current file's directory):

```rust
mod mymod {
    near_abi_client::generate!(ClientName for "path/to/abi.json");
}
```

Placing the macro invocation inside a `mod` section is optional, but helps reducing unexpected behaviors such as name clashes.

Now, assuming you have a `contract: near_workspaces::Contract` deployed, you can make a call like this:

```rust
let contract = mymod::ClientName { contract };
let res = contract
    .my_method_name(arg1, arg2)
    .await?;
```

### Generation API

Checkout the [`delegator-generation`](https://github.com/near/near-abi-client-rs/tree/main/examples/delegator-generation) example for a standalone project using generation API to generate a client and use it.

First, we need our package to have a `build.rs` file that runs the generation step. The following snippet will generate the client in `abi.rs` under `path/to/out/dir`:

```rust
fn main() -> anyhow::Result<()> {
    near_abi_client::Generator::new("path/to/out/dir".into())
        .file("path/to/abi.json")
        .generate()?;
    Ok(())
}
```

The resulting file, however, is not included in your source set by itself. You have to include it manually; the recommended way is to create a mod with a custom path:

```
#[path = "path/to/out/dir/abi.rs"]
mod mymod;
```

Now, assuming you have a `contract: near_workspaces::Contract` deployed, you can make a call like this:

```rust
let contract = mymod::AbiClient { contract };
let res = contract
    .my_method_name(arg1, arg2)
    .await?;
```

Feel free to explore what other methods `Generator` has to customize the resulting code (e.g. client struct name).

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as below, without any additional terms or conditions.

## License

Licensed under either of

* Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
* MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

'''
'''--- near-abi-client/src/lib.rs ---
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::{env, fs};

use anyhow::{anyhow, Result};
use convert_case::{Case, Casing};
use quote::format_ident;

use near_abi_client_impl::{generate_abi_client, read_abi};
pub use near_abi_client_macros::generate;

/// Configuration options for ABI code generation.
#[derive(Default)]
pub struct Generator {
    pub out_dir: Option<PathBuf>,
    abis: Vec<(PathBuf, Option<String>)>,
}

impl Generator {
    pub fn new(out_dir: PathBuf) -> Self {
        Generator {
            out_dir: Some(out_dir),
            abis: vec![],
        }
    }

    pub fn file(mut self, path: impl Into<PathBuf>) -> Self {
        self.abis.push((path.into(), None));
        self
    }

    pub fn file_with_name(mut self, path: impl Into<PathBuf>, name: String) -> Self {
        self.abis.push((path.into(), Some(name)));
        self
    }

    pub fn generate(self) -> Result<()> {
        let target: PathBuf = self.out_dir.clone().map(Ok).unwrap_or_else(|| {
            env::var_os("OUT_DIR")
                .ok_or_else(|| anyhow!("OUT_DIR environment variable is not set"))
                .map(Into::into)
        })?;
        fs::create_dir_all(&target)?;

        for (abi_path, name) in self.abis {
            let abi_path_no_ext = abi_path.with_extension("");
            let abi_filename = abi_path_no_ext
                .file_name()
                .ok_or_else(|| anyhow!("{:?} is not a valid ABI path", &abi_path))?;
            let rust_path = target.join(abi_filename).with_extension("rs");
            let near_abi = read_abi(&abi_path);

            let contract_name = name
                .as_ref()
                .map(|n| format_ident!("{}", n))
                .or_else(|| {
                    near_abi
                        .metadata
                        .name
                        .clone()
                        .map(|n| format_ident!("{}Client", n.to_case(Case::UpperCamel)))
                })
                .ok_or_else(|| {
                    anyhow!(
                        "ABI file '{}' does not contain a contract name. Please supply the name via `file_with_name`.",
                        abi_path.display()
                    )
                })?;

            let token_stream = generate_abi_client(near_abi, contract_name);
            let syntax_tree = syn::parse_file(&token_stream.to_string()).unwrap();
            let formatted = prettyplease::unparse(&syntax_tree);

            let mut rust_file = File::create(rust_path)?;
            write!(rust_file, "{}", formatted)?;
        }

        Ok(())
    }
}

'''
'''--- near-abi-client/tests/adder.json ---
{
  "schema_version": "0.4.0",
  "metadata": {
    "name": "abi",
    "version": "0.1.0",
    "authors": [
      "Near Inc <hello@nearprotocol.com>"
    ]
  },
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}

'''
'''--- near-abi-client/tests/mod.rs ---
use std::fs;

use quote::quote;

use near_abi_client::Generator;

#[test]
fn test_generate_abi() -> anyhow::Result<()> {
    let tmp_dir = tempfile::tempdir()?;
    let tmp_dir_path = tmp_dir.into_path();
    Generator::new(tmp_dir_path.clone())
        .file("tests/adder.json")
        .generate()?;

    let generated_code = fs::read_to_string(tmp_dir_path.join("adder.rs"))?;
    let expected = quote! {
        pub type Pair = Vec<i64>;
        pub struct AbiClient {
            pub contract: near_workspaces::Contract,
        }
        impl AbiClient {
            pub async fn add(
                &self,
                a: Pair,
                b: Pair
            ) -> anyhow::Result<Pair> {
                let result = self
                    .contract
                    .call("add")
                    .args_json([a, b])
                    .view()
                    .await?;
                Ok(result.json::<Pair>()?)
            }
        }
    };
    let syntax_tree = syn::parse_file(&expected.to_string()).unwrap();
    let expected = prettyplease::unparse(&syntax_tree);
    assert_eq!(expected, generated_code);

    Ok(())
}

'''
'''--- res/adder.json ---
{
  "schema_version": "0.4.0",
  "metadata": {
    "name": "abi",
    "version": "0.1.0",
    "authors": [
      "Near Inc <hello@nearprotocol.com>"
    ]
  },
  "body": {
    "functions": [
      {
        "name": "add",
        "doc": " Adds two pairs point-wise.",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "a",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            },
            {
              "name": "b",
              "type_schema": {
                "$ref": "#/definitions/Pair"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pair"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "Pair": {
          "type": "array",
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      }
    }
  }
}

'''