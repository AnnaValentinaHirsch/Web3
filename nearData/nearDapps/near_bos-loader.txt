*GitHub Repository "near/bos-loader"*

'''--- .devcontainer/devcontainer.json ---
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/rust
{
	"name": "Rust",
	// Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
	"image": "mcr.microsoft.com/devcontainers/rust:0-1-bullseye",
	"features": {
		"ghcr.io/devcontainers/features/common-utils:2": {}
	}

	// Use 'mounts' to make the cargo cache persistent in a Docker Volume.
	// "mounts": [
	// 	{
	// 		"source": "devcontainer-cargo-cache-${devcontainerId}",
	// 		"target": "/usr/local/cargo",
	// 		"type": "volume"
	// 	}
	// ]

	// Features to add to the dev container. More info: https://containers.dev/features.
	// "features": {},

	// Use 'forwardPorts' to make a list of ports inside the container available locally.
	// "forwardPorts": [],

	// Use 'postCreateCommand' to run commands after the container is created.
	// "postCreateCommand": "rustc --version",

	// Configure tool-specific properties.
	// "customizations": {},

	// Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
	// "remoteUser": "root"
}

'''
'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/workflows/release.yml ---
# CI that:
#
# * checks for a Git Tag that looks like a release
# * creates a Github Release™ and fills in its text
# * builds artifacts with cargo-dist (executable-zips, installers)
# * uploads those artifacts to the Github Release™
#
# Note that the Github Release™ will be created before the artifacts,
# so there will be a few minutes where the release has no artifacts
# and then they will slowly trickle in, possibly failing. To make
# this more pleasant we mark the release as a "draft" until all
# artifacts have been successfully uploaded. This allows you to
# choose what to do with partial successes and avoids spamming
# anyone with notifications before the release is actually ready.
name: Release

permissions:
  contents: write

# This task will run whenever you push a git tag that looks like a version
# like "v1", "v1.2.0", "v0.1.0-prerelease01", "my-app-v1.0.0", etc.
# The version will be roughly parsed as ({PACKAGE_NAME}-)?v{VERSION}, where
# PACKAGE_NAME must be the name of a Cargo package in your workspace, and VERSION
# must be a Cargo-style SemVer Version.
#
# If PACKAGE_NAME is specified, then we will create a Github Release™ for that
# package (erroring out if it doesn't have the given version or isn't cargo-dist-able).
#
# If PACKAGE_NAME isn't specified, then we will create a Github Release™ for all
# (cargo-dist-able) packages in the workspace with that version (this is mode is
# intended for workspaces with only one dist-able package, or with all dist-able
# packages versioned/released in lockstep).
#
# If you push multiple tags at once, separate instances of this workflow will
# spin up, creating an independent Github Release™ for each one.
#
# If there's a prerelease-style suffix to the version then the Github Release™
# will be marked as a prerelease.
on:
  push:
    tags:
      - '*-?v[0-9]+*'

jobs:
  # Create the Github Release™ so the packages have something to be uploaded to
  create-release:
    runs-on: ubuntu-latest
    outputs:
      has-releases: ${{ steps.create-release.outputs.has-releases }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v3
      - name: Install Rust
        run: rustup update 1.67.1 --no-self-update && rustup default 1.67.1
      - name: Install cargo-dist
        run: curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.sh | sh
      - id: create-release
        run: |
          cargo dist manifest --tag=${{ github.ref_name }} --artifacts=all --no-local-paths --output-format=json > dist-manifest.json
          echo "dist manifest ran successfully"
          cat dist-manifest.json
        
          # Create the Github Release™ based on what cargo-dist thinks it should be
          ANNOUNCEMENT_TITLE=$(cat dist-manifest.json | jq --raw-output ".announcement_title")
          IS_PRERELEASE=$(cat dist-manifest.json | jq --raw-output ".announcement_is_prerelease")
          cat dist-manifest.json | jq --raw-output ".announcement_github_body" > new_dist_announcement.md
          gh release create ${{ github.ref_name }} --draft --prerelease="$IS_PRERELEASE" --title="$ANNOUNCEMENT_TITLE" --notes-file=new_dist_announcement.md
          echo "created announcement!"

          # Upload the manifest to the Github Release™
          gh release upload ${{ github.ref_name }} dist-manifest.json
          echo "uploaded manifest!"

          # Disable all the upload-artifacts tasks if we have no actual releases
          HAS_RELEASES=$(cat dist-manifest.json | jq --raw-output ".releases != null")
          echo "has-releases=$HAS_RELEASES" >> "$GITHUB_OUTPUT"

  # Build and packages all the things
  upload-artifacts:
    # Let the initial task tell us to not run (currently very blunt)
    needs: create-release
    if: ${{ needs.create-release.outputs.has-releases == 'true' }}
    strategy:
      matrix:
        # For these target platforms
        include:
        - os: ubuntu-20.04
          dist-args: --artifacts=global
          install-dist: curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.sh | sh
        - os: macos-11
          dist-args: --artifacts=local --target=aarch64-apple-darwin --target=x86_64-apple-darwin
          install-dist: curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.sh | sh
        - os: ubuntu-20.04
          dist-args: --artifacts=local --target=x86_64-unknown-linux-gnu
          install-dist: curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.sh | sh
        - os: windows-2019
          dist-args: --artifacts=local --target=x86_64-pc-windows-msvc
          install-dist: irm  https://github.com/axodotdev/cargo-dist/releases/download/v0.0.5/cargo-dist-v0.0.5-installer.ps1 | iex

    runs-on: ${{ matrix.os }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v3
      - name: Install Rust
        run: rustup update 1.67.1 --no-self-update && rustup default 1.67.1
      - name: Install cargo-dist
        run: ${{ matrix.install-dist }}
      - name: Run cargo-dist
        # This logic is a bit janky because it's trying to be a polyglot between
        # powershell and bash since this will run on windows, macos, and linux!
        # The two platforms don't agree on how to talk about env vars but they
        # do agree on 'cat' and '$()' so we use that to marshal values between commands.
        run: |
          # Actually do builds and make zips and whatnot
          cargo dist build --tag=${{ github.ref_name }} --output-format=json ${{ matrix.dist-args }} > dist-manifest.json
          echo "dist ran successfully"
          cat dist-manifest.json

          # Parse out what we just built and upload it to the Github Release™
          cat dist-manifest.json | jq --raw-output ".artifacts[]?.path | select( . != null )" > uploads.txt
          echo "uploading..."
          cat uploads.txt
          gh release upload ${{ github.ref_name }} $(cat uploads.txt)
          echo "uploaded!"

  # Mark the Github Release™ as a non-draft now that everything has succeeded!
  publish-release:
    # Only run after all the other tasks, but it's ok if upload-artifacts was skipped
    needs: [create-release, upload-artifacts]
    if: ${{ always() && needs.create-release.result == 'success' && (needs.upload-artifacts.result == 'skipped' || needs.upload-artifacts.result == 'success') }}
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v3
      - name: mark release as non-draft
        run: |
          gh release edit ${{ github.ref_name }} --draft=false
'''
'''--- .vscode/launch.json ---
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug executable 'bos-loader'",
      "cargo": {
        "args": ["build", "--bin=bos-loader", "--package=bos-loader"],
        "filter": {
          "name": "bos-loader",
          "kind": "bin"
        }
      },
      "args": ["near", "--path=./examples/components"],
      "cwd": "${workspaceFolder}"
    },
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug unit tests in executable 'bos-loader'",
      "cargo": {
        "args": [
          "test",
          "--no-run",
          "--bin=bos-loader",
          "--package=bos-loader"
        ],
        "filter": {
          "name": "bos-loader",
          "kind": "bin"
        }
      },
      "args": [],
      "cwd": "${workspaceFolder}"
    }
  ]
}

'''
'''--- CHANGELOG.md ---
# Changelog

## 0.12.0
Add support for serving CSS modules when operating in BOS Web Engine mode

## 0.11.0
Refactor and improved error handling by @robertlopezdev

## 0.10.0

Add argument for specifying port to serve on

## 0.6.0

Improved documentation of command and arguments

## 0.5.0

Add support for organizing `.` delimited component names into directories to be more compatible
with the `near-social` CLI. e.g. `DIG.Button.jsx` → `DIG/Button.jsx`

## 0.2.0

Take optional path parameter, defaulting to the current directory (previously `./src`)

## 0.1.0

Initial release. Takes a single argument of the account ID used when serving components

'''
'''--- Cargo.toml ---
[package]
name = "bos-loader"
version = "0.12.0"
edition = "2021"
repository = "https://github.com/mpeterdev/bos-loader"
description = "Serves BOS component files (.jsx) for preview on a BOS gateway"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
tokio = { version = "1", features = ["full"] }
warp = "0.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
clap = { version = "4.2.1", features = ["derive"] }
config = { version = "0.13.3", features = ["toml"] }
async-recursion = "1.0.5"
anyhow = "1.0.79"

# The profile that 'cargo dist' will build with
[profile.dist]
inherits = "release"
lto = "thin"

# Config for 'cargo dist'
[workspace.metadata.dist]
# The preferred cargo-dist version to use in CI (Cargo.toml SemVer syntax)
cargo-dist-version = "0.0.5"
# The preferred Rust toolchain to use in CI (rustup toolchain syntax)
rust-toolchain-version = "1.67.1"
# CI backends to support (see 'cargo dist generate-ci')
ci = ["github"]
# Target platforms to build apps for (Rust target-triple syntax)
targets = [
  "x86_64-unknown-linux-gnu",
  "x86_64-apple-darwin",
  "x86_64-pc-windows-msvc",
  "aarch64-apple-darwin",
]
installers = ["shell", "powershell"]

[workspace.metadata.release]
publish = false

'''
'''--- README.md ---
# BOS Component Loader

Serves a local directory of component files as a JSON payload properly formatted to be plugged into a BOS `redirectMap`. When paired with a viewer configured to call out to this loader, it enables local component development—especially when working on multiple components in parallel.

Works best when paired with [FroVolod/bos-cli-rs](https://github.com/FroVolod/bos-cli-rs) for component syncing and CI/CD

## Installation

see GitHub Releases

## Compatibility
Should work without issue when accessing gateway through Chrome, Arc and Firefox.

Brave requires turning shields off for gateway site.

Safari requires serving over HTTPS, which can be accomplished with ngrok. See [this issue](https://github.com/near/bos-loader/issues/9)

## Usage

1. Run this tool with desired options

```sh
Serves the contents of BOS component files (.jsx) in a specified directory as a JSON object properly formatted for preview on a BOS gateway

Usage: bos-loader [OPTIONS] [ACCOUNT_ID]

Arguments:
  [ACCOUNT_ID]
          NEAR account to use as component author in preview

Options:
  -p, --path <PATH>
          Path to directory containing component files
          
          [default: .]

  -c
          Use config file in current dir (./.bos-loader.toml) to set account_id and path, causes other args to be ignored

  -w
          Run in BOS Web Engine mode

      --port <PORT>
          Port to serve on
          
          [default: 3030]

  -r, --replacements <REPLACEMENTS>
          Path to file with replacements map

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
```

The only required argument is the account which you want to serve the components from

e.g. running from a directory with `HelloWorld.jsx` in the following way

```bash
bos-loader michaelpeter.near
```

results in

```json
{
  "components": {
    "michaelpeter.near/widget/HelloWorld": {
      "code": "return <>Hello World</>;"
    }
  }
}
```

2. Go to https://near.org/flags and set the BOS Loader URL to access your bos-loader instance. The default would be `http://127.0.0.1:3030`
3. Load the component you would like to preview as `https://near.org/<account id>/widget/<component name>`
   - e.g. from the previous example: `https://near.org/michaelpeter.near/widget/HelloWorld`

## Replacements

The replacements file is an optional file where placeholders and values they should resolve to are specified. Think of replacements as environment variables for your components which are injected before writing the component code on chain

The file should have the following format:

```json
{
  "REPL_PLACEHOLDER1": "value1",
  "REPL_PLACEHOLDER2": "value2"
}
```

The placeholders in widgets are replaced with specified values. For example the code for the following widget:

```javascript
return <>
    <div> This is ${REPL_PLACEHOLDER1} </div>
    <Widget src="${REPL_ACCOUNT}/widget/SomeWidget">
    <div>${REPL_PLACEHOLDER2}</div>
</>;
```

will be resolved to:

```javascript
return <>
    <div> This is value1 </div>
    <Widget src="accountId/widget/SomeWidget">
    <div>value2</div>
</>;
```

where accountId is the account passed as an argument.

The file should **not** contain `REPL_ACCOUNT` placeholder. This placeholder is automatically resolved to `accountId` value.

## Configuration file

Some advanced options can be configured via a `.bos-loader.toml` file in the directory where you run the loader. The following options are available

### paths

specify multiple accounts and paths to serve components from. You can even serve components from the same directory as multiple accounts

```toml
paths = [
  { account = "near", path = "./components" },
  { account = "michaelpeter.near", path = "./src" },
]
```

## Multi-device Testing

Run both your loader behind [ngrok](https://ngrok.com/) to test on multiple devices or share your working copy with others!

Example ngrok config:

```yml
authtoken: <automatically populated during setup>
tunnels:
  api:
    proto: http
    addr: 127.0.0.1:3030
    subdomain: my-loader # change this and use as your loader url e.g. https://my-loader.ngrok.io
version: "2"
region: us
```

Then start with `ngrok start --all`

## Contributing

### Cutting a new release

Once all changes are merged into `main`, use `cargo release` to cut a new release. This will automatically update the version in `Cargo.toml`, create a new git tag, and push the tag to GitHub.

Given the next release version will be `0.9.0`

```bash
# dry run to make sure everything looks normal
cargo release 0.9.0

# execute the release
cargo release 0.9.0 --execute
```

## Troubleshooting

### Mac OS

If you've installed a new version of `bos-loader` on Mac OS, it's possible you could see the following `killed` response when running any command:

```
$ bos-loader --version
[1]    32008 killed     bos-loader --version
```

To fix this, you'll need to follow these steps in order:

1. Remove the executable: `rm ~/.cargo/bin/bos-loader`
2. Restart your computer
3. Re-install `bos-loader` using the command provided by the latest release notes.

After following these steps, `bos-loader` should be able to execute without issue. This process resets the kernel cache for the executable.

'''
'''--- src/main.rs ---
use anyhow::anyhow;
use async_recursion::async_recursion;
use clap::Parser;
use config::Config;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::{collections::HashMap, path::PathBuf, sync::Arc};
use tokio::{fs, io::AsyncReadExt, sync::Mutex};
use warp::{http::Method, Filter};

#[derive(Parser, Debug)]
#[command(
    author,
    version,
    about,
    long_about = "Serves the contents of BOS component files (.jsx) in a specified directory as a JSON object properly formatted for preview on a BOS gateway"
)]
struct Args {
    /// Path to directory containing component files
    #[clap(short, long, default_value = ".", value_hint = clap::ValueHint::DirPath)]
    path: PathBuf,
    /// Port to serve on
    #[arg(long, default_value = "3030")]
    port: u16,
    /// NEAR account to use as component author in preview
    account: Option<String>,
    /// Use config file in current dir (./.bos-loader.toml) to set account and path, causes other args to be ignored
    #[arg(short = 'c')]
    use_config: bool,
    /// Run in BOS Web Engine mode
    #[arg(short = 'w')]
    web_engine: bool,
    /// Path to file with replacements map
    #[clap(short, long, value_hint = clap::ValueHint::DirPath)]
    replacements: Option<PathBuf>,
}

#[derive(Serialize, Deserialize)]
struct FileList {
    components: HashMap<String, ComponentCode>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
struct ComponentCode {
    code: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    css: Option<String>,
}

#[derive(Serialize, Deserialize, Clone)]
struct AccountPath {
    path: PathBuf,
    account: String,
}

struct HandleRequestOptions {
    path: PathBuf,
    account: String,
    web_engine: bool,
    replacements_map: Arc<HashMap<String, String>>,
}

async fn handle_request(
    HandleRequestOptions {
        path,
        account,
        web_engine,
        replacements_map,
    }: HandleRequestOptions,
) -> Result<Arc<Mutex<HashMap<String, ComponentCode>>>, anyhow::Error> {
    let components = Arc::new(Mutex::new(HashMap::new()));

    load_components(LoadComponentsOptions {
        path,
        account,
        prefix: "".to_string(),
        web_engine,
        components: components.clone(),
        replacements_map,
    })
    .await?;

    Ok(components)
}

fn replace_placeholders(
    code: &str,
    account: &str,
    replacements_map: &HashMap<String, String>,
) -> String {
    let mut modified_string = code.to_string();
    let mut replacements = replacements_map.clone();
    replacements.insert("${REPL_ACCOUNT}".to_owned(), account.to_owned());

    for (substring, value) in replacements.iter() {
        modified_string = modified_string.replace(substring, value);
    }

    modified_string
}

async fn read_replacements(path: PathBuf) -> Result<Arc<HashMap<String, String>>, anyhow::Error> {
    let contents = fs::read_to_string(&path)
        .await
        .map_err(|err| anyhow!("Failed to read path {:?} \n Error: {:?}", path, err))?;

    let map = serde_json::from_str::<HashMap<String, String>>(&contents)
        .map_err(|_| anyhow!("Invalid JSON format"))?
        .iter()
        .map(|(key, value)| (format!("{}{}{}", "${", key, "}"), value.to_owned()))
        .collect::<HashMap<String, String>>();

    if map.contains_key("${REPL_ACCOUNT}") {
        panic!("The replacements file can't contain the REPL_ACCOUNT key. This key is reserved.");
    }

    Ok(Arc::new(map))
}

struct LoadComponentsOptions {
    path: PathBuf,
    prefix: String,
    account: String,
    web_engine: bool,
    components: Arc<Mutex<HashMap<String, ComponentCode>>>,
    replacements_map: Arc<HashMap<String, String>>,
}

#[async_recursion]
async fn load_components(
    LoadComponentsOptions {
        path,
        prefix,
        account,
        web_engine,
        components,
        replacements_map,
    }: LoadComponentsOptions,
) -> Result<(), anyhow::Error> {
    let mut paths = fs::read_dir(path.clone())
        .await
        .map_err(|err| anyhow!("Could not read directory {:?} \n Error: {:?}", path, err))?;

    while let Some(directory_entry) = paths.next_entry().await.map_err(|err| {
        anyhow!(
            "Could not read directory entries for path {:?} \n Error: {:?}",
            path,
            err
        )
    })? {
        let file_path = directory_entry.path();
        let file_name = file_path
            .file_name()
            .ok_or(anyhow!("Could not get file name from path {:?}", file_path))?
            .to_string_lossy()
            .to_string();

        if directory_entry
            .file_type()
            .await
            .map_err(|err| {
                anyhow!(
                    "Could not get file type from path {:?} \n Error: {:?}",
                    file_path,
                    err
                )
            })?
            .is_dir()
        {
            load_components(LoadComponentsOptions {
                path: file_path,
                account: account.clone(),
                prefix: format!("{prefix}{file_name}."),
                web_engine,
                components: components.clone(),
                replacements_map: replacements_map.clone(),
            })
            .await?;

            continue;
        }

        let mut file_name_parts: Vec<&str> = file_name.split('.').collect();

        if let Some(extension) = file_name_parts.pop() {
            if extension != "jsx" && extension != "tsx" {
                continue;
            }
        }

        let file_key = file_name_parts.join(".");
        let join_string = if web_engine { "/" } else { "/widget/" };
        let key = format!("{account}{join_string}{prefix}{file_key}");

        // read code
        let mut code = String::new();
        let mut file = fs::File::open(&file_path)
            .await
            .map_err(|err| anyhow!("Failed to open file {:?} \n Error: {:?}", file_path, err))?;

        file.read_to_string(&mut code)
            .await
            .map_err(|err| anyhow!("Failed to read file {:?} \n Error: {:?}", file_path, err))?;

        code = replace_placeholders(&code, &account, &replacements_map.clone());

        // read css
        let css: Option<String> = if web_engine {
            let css_path = file_path.with_extension("module.css");
            if css_path.exists() {
                let mut css_file = fs::File::open(&css_path).await.map_err(|err| {
                    anyhow!("Failed to open file {:?} \n Error: {:?}", css_path, err)
                })?;

                let mut read_css = String::new();
                css_file
                    .read_to_string(&mut read_css)
                    .await
                    .map_err(|err| {
                        anyhow!("Failed to read file {:?} \n Error: {:?}", css_path, err)
                    })?;

                Some(read_css)
            } else {
                Some(String::from(""))
            }
        } else {
            None
        };

        components.lock().await.insert(
            key,
            ComponentCode {
                code,
                css: if web_engine { css } else { None },
            },
        );
    }

    Ok(())
}

#[tokio::main]
async fn main() {
    let Args {
        path,
        port,
        account,
        use_config,
        web_engine,
        replacements,
    } = Args::parse();

    let account_paths = if use_config {
        let settings = Config::builder()
            .add_source(config::File::with_name("./.bos-loader.toml"))
            .build()
            .expect("Failed to load config file");

        settings
            .get::<Vec<AccountPath>>("paths")
            .expect("A valid path configuration was not found in config file")
    } else {
        vec![AccountPath {
            path,
            account: account
                .expect("Account ID must be provided when not using configuration file"),
        }]
    };

    let replacements_map = if let Some(replacements_path) = replacements {
        read_replacements(replacements_path)
            .await
            .map_err(|err| {
                format!(
                    "Something went wrong while parsing the replacement file: {}",
                    err
                )
            })
            .unwrap()
    } else {
        Arc::new(HashMap::new())
    };

    let display_paths_str = account_paths
        .iter()
        .map(|AccountPath { path, account }| format!("{:?} as account {}", path, account))
        .collect::<Vec<String>>()
        .join("\n");

    let cors = warp::cors()
        .allow_any_origin()
        .allow_methods(&[Method::GET]);

    let api = warp::get()
        .and_then(move || {
            let account_paths = account_paths.clone();
            let replacements_map = replacements_map.clone();

            async move {
                let mut all_components = HashMap::new();

                for AccountPath { path, account } in account_paths {
                    match handle_request(HandleRequestOptions {
                        path: path.clone(),
                        web_engine,
                        account: account.clone(),
                        replacements_map: replacements_map.clone(),
                    })
                    .await
                    {
                        Ok(components) => {
                            let components_lock = components.lock().await;

                            all_components.extend(components_lock.clone());
                        }
                        Err(err) => {
                            let error = format!(
                                "Error handling request for account {}, path {:?} \n Error: {:?}",
                                account, path, err
                            );

                            println!("{error}");

                            return Ok::<_, warp::Rejection>(warp::reply::json(&json!({
                                "error": error,
                            })));
                        }
                    }
                }

                Ok(warp::reply::json(&FileList {
                    components: all_components,
                }))
            }
        })
        .with(cors);

    println!(
        "\nServing .jsx/.tsx files on http://127.0.0.1:{}\n\n{}",
        port, display_paths_str
    );

    warp::serve(api).run(([127, 0, 0, 1], port)).await;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_replace_placeholders() {
        let input_string = String::from("<div> This is ${REPL_PLACEHOLDER1} </div> <Widget src=\"${REPL_ACCOUNT}/widget/SomeWidget\"> <div>${REPL_PLACEHOLDER2}</div>");
        let expected_output = String::from("<div> This is value1 </div> <Widget src=\"MY_ACCOUNT/widget/SomeWidget\"> <div>value2</div>");

        let replacements: HashMap<String, String> = vec![
            ("${REPL_PLACEHOLDER1}".to_owned(), "value1".to_owned()),
            ("${REPL_PLACEHOLDER2}".to_owned(), "value2".to_owned()),
        ]
        .into_iter()
        .collect();

        let modified_string = replace_placeholders(&input_string, "MY_ACCOUNT", &replacements);

        assert_eq!(modified_string, expected_output);
    }

    #[test]
    fn test_replace_placeholders_empty_map() {
        let input_string = String::from("<div> This is ${REPL_PLACEHOLDER1} </div> <Widget src=\"${REPL_ACCOUNT}/widget/SomeWidget\"> <div>${REPL_PLACEHOLDER2}</div>");
        let expected_output = String::from("<div> This is ${REPL_PLACEHOLDER1} </div> <Widget src=\"MY_ACCOUNT/widget/SomeWidget\"> <div>${REPL_PLACEHOLDER2}</div>");

        let modified_string = replace_placeholders(&input_string, "MY_ACCOUNT", &HashMap::new());

        assert_eq!(modified_string, expected_output);
    }

    #[test]
    fn test_replace_placeholders_wrong_notation() {
        let input_string =
            String::from("${REPL_ACCOUNT REPL_ACCOUNT $REPL_ACCOUNT ${WRONG_PLACEHOLDER}");
        let expected_output = String::from(input_string.clone());

        let replacements: HashMap<String, String> = vec![
            ("${REPL_PLACEHOLDER1}".to_owned(), "value1".to_owned()),
            ("${REPL_PLACEHOLDER2}".to_owned(), "value2".to_owned()),
        ]
        .into_iter()
        .collect();

        let modified_string = replace_placeholders(&input_string, "MY_ACCOUNT", &replacements);

        assert_eq!(modified_string, expected_output);
    }

    #[tokio::test]
    async fn test_read_replacements() {
        let path: PathBuf = "./test/replacements.json".into();

        let expected_output: HashMap<String, String> = vec![
            ("${REPL_PLACEHOLDER1}".to_owned(), "value1".to_owned()),
            ("${REPL_PLACEHOLDER2}".to_owned(), "value2".to_owned()),
        ]
        .into_iter()
        .collect();

        let map = read_replacements(path).await.unwrap();

        assert_eq!(map, expected_output.into());
    }

    #[tokio::test]
    #[should_panic(
        expected = "The replacements file can't contain the REPL_ACCOUNT key. This key is reserved."
    )]
    async fn test_read_replacements_repl_account() {
        let path: PathBuf = "./test/replacements.wrong.json".into();

        read_replacements(path).await.unwrap();
    }

    #[tokio::test]
    async fn test_basic_web_engine_components() {
        let path: PathBuf = "./test/webengine".into();
        let account = "test.near".to_string();
        let web_engine = true;
        let replacements_map = Arc::new(HashMap::new());

        let components = handle_request(HandleRequestOptions {
            path,
            account,
            web_engine,
            replacements_map,
        })
        .await
        .unwrap();

        let components_lock = components.lock().await;

        assert_eq!(
            components_lock.get("test.near/WithStyle"),
            Some(&ComponentCode {
                code: String::from(
                    "import s from \"./WithStyle.module.css\";\n\ntype Props = {\n  message?: string;\n};\n\nfunction WithStyle({ message = \"Hello!\" }: Props) {\n  return (\n    <div className={s.wrapper}>\n      <p>{message}</p>\n    </div>\n  );\n}\n\nexport default WithStyle as BWEComponent<Props>;\n"
                ),
                css: Some(String::from(".wrapper {\n  color: rebeccapurple;\n}"))
            })
        );
        assert_eq!(
            components_lock.get("test.near/NoStyle"),
            Some(&ComponentCode {
                code: String::from(
                    "type Props = {\n  message?: string;\n};\n\nfunction NoStyle({ message = \"Hello!\" }: Props) {\n  return (\n    <div>\n      <p>{message}</p>\n    </div>\n  );\n}\n\nexport default NoStyle as BWEComponent<Props>;\n"
                ),
                css: Some(String::from(""))
            })
        );
    }

    // TODO: add tests for config file multi-account setup
}

'''
'''--- test/.bos-loader.toml ---
paths = [
  { account = "near", path = "./components" },
  { account = "michaelpeter.near", path = "./components" },
]

'''
'''--- test/replacements.json ---
{
    "REPL_PLACEHOLDER1": "value1",
    "REPL_PLACEHOLDER2": "value2"
}
'''
'''--- test/replacements.wrong.json ---
{
    "REPL_ACCOUNT": "This is reserved placeholder",
    "REPL_PLACEHOLDER2": "value2"
}
'''
'''--- test/webengine/WithStyle.module.css ---
.wrapper {
  color: rebeccapurple;
}
'''