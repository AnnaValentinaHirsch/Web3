*GitHub Repository "onchezz/tendersDapp"*

'''--- Cargo.toml ---
[package]
name = "near-smart-contract-rust-template"
version = "0.1.0"
edition = "2021"
authors = ["Jacob Lindahl <jacob@near.foundation>"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# NEAR Smart Contract Rust Template

Project structure for writing smart contracts in Rust for NEAR Protocol

# Required Software

- Rust 1.58 + cargo
- Node.js
- NEAR CLI 3.1

# Authors

- Jacob Lindahl <jacob@near.foundation> [@sudo_build](https://twitter.com/sudo_build)

'''
'''--- build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release

'''
'''--- deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

console.log(JSON.stringify({}));

'''
'''--- rustfmt.toml ---
tab_spaces = 2

'''
'''--- src/contract.rs ---
use crate::*;

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    ITEM,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {}
    }
}

'''
'''--- src/lib.rs ---
use near_sdk::{
    borsh::{self, *},
    collections::*,
    json_types::*,
    serde::{self, *},
    *,
};

mod utils;

mod contract;
pub use contract::*;

#[cfg(test)]
mod tests {
    use crate::*;
    use near_sdk::{test_utils::*, testing_env};

    const ONE_NEAR: u128 = u128::pow(10, 24);

    fn contract_account() -> AccountId {
        "contract".parse::<AccountId>().unwrap()
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(contract_account())
            .account_balance(15 * ONE_NEAR)
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test() {}
}

'''
'''--- src/utils.rs ---
use near_sdk::{env, log, require, Balance, Promise, StorageUsage};

pub(crate) fn prefix_key(prefix: &Vec<u8>, key: &[u8]) -> Vec<u8> {
  [prefix as &[u8], key].concat()
}

pub(crate) fn storage_refund(storage_usage_start: StorageUsage, other_fees: Balance) {
  let storage_usage_end = env::storage_usage();

  let storage_fee =
    Balance::from(storage_usage_end.saturating_sub(storage_usage_start)) * env::storage_byte_cost();

  let total_required_deposit = storage_fee + other_fees;

  let attached_deposit = env::attached_deposit();

  require!(
    attached_deposit >= total_required_deposit,
    format!(
      "Insufficient deposit: required: {} yoctoNEAR; received: {} yoctoNEAR",
      &total_required_deposit, &attached_deposit
    )
  );

  let refund = attached_deposit - total_required_deposit;

  log!("storage fee: {} yoctoNEAR", &storage_fee);
  log!("refund: {} yoctoNEAR", &refund);

  if refund > 0 {
    Promise::new(env::predecessor_account_id()).transfer(refund);
  }
}

'''