*GitHub Repository "longvuit18/pnc-contract"*

'''--- Cargo.toml ---
[package]
name = "NEAR-Private-Cash"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = { version = "1.0.127", default-features = false, features = ["derive"] }
thiserror = { version = "1.0.26" }
hex = "0.4"
ark-ff = { version = "^0.3.0", default-features = false }
ark-std = { version = "^0.3.0", default-features = false }
ark-bn254 = { version = "^0.3.0", default-features = false, features = [ "curve" ] }
ark-crypto-primitives = { version = "^0.3.0", features = ["r1cs"], default-features = false }

arkworks-gadgets = { version = "0.4.19", default-features = false }
arkworks-utils = { version = "0.4.19", default-features = false, features = [
    "poseidon_bn254_x5_3",
    "poseidon_bn254_x5_4",
    "poseidon_bn254_x5_5",
]}

ark-ec = { version = "^0.3.0", default-features = false }
ark-groth16 = { version = "^0.3.0", default-features = false }
ark-serialize = { version = "^0.3.0", default-features = false }
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p out
cp target/wasm32-unknown-unknown/release/*.wasm out/

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1655091761102-40027653995849
'''
'''--- note.sh ---

./build.sh
near delete privatecash.longvuit18.testnet longvuit18.testnet
near create-account privatecash.longvuit18.testnet --masterAccount longvuit18.testnet --initialBalance 20
near deploy --accountId privatecash.longvuit18.testnet --wasmFile out/NEAR_Private_Cash.wasm --initFunction new --initArgs '{"denomination": 1000000000000000000000000, "tree_levels": 30}'

'''
'''--- protocol-substrate-fixtures/README.md ---
# protocol-substrate-fixtures

'''
'''--- protocol-substrate-fixtures/builder/Cargo.toml ---
[package]
name = "builder"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
arkworks-circuits = { version = "0.4.19" }
arkworks-utils = { version = "0.4.19" }
ark-std = { version = "^0.3.0", default-features = false }
ark-groth16 = { version = "^0.3.0", default-features = false }
ark-ec = { version = "^0.3.0", default-features = false }
ark-serialize = {version = "^0.3.0", default-features = false }
ark-bn254 = { version = "^0.3.0", default-features = false, features = [ "curve" ] }
ark-bls12-381 = { version = "^0.3.0", default-features = false, features = [ "curve" ] }
'''
'''--- protocol-substrate-fixtures/builder/src/main.rs ---
use ark_ec::PairingEngine;
use arkworks_circuits::setup::anchor::AnchorProverSetup;
use arkworks_circuits::setup::mixer::MixerProverSetup;
use arkworks_circuits::setup::vanchor::VAnchorProverSetup;
use arkworks_utils::utils::common::{setup_params_x5_2, setup_params_x5_3, setup_params_x5_5, setup_params_x5_4, Curve};
use arkworks_circuits::prelude::ark_crypto_primitives::SNARK;
use ark_serialize::CanonicalSerialize;
use ark_groth16::{Groth16, ProvingKey, VerifyingKey};
use ark_std::test_rng;
use ark_bn254::Bn254;
use std::fs::write;
use std::env::current_dir;

pub const N: usize = 30;
pub const M: usize = 2;
type AnchorProverSetupBn254_30<F> = AnchorProverSetup<F, M, N>;
type MixerProverSetupBn254_30<F> = MixerProverSetup<F, N>;
type VAnchorProverSetupBn254_30_2x2<F> = VAnchorProverSetup<F, N, M, 2, 2>;

fn save_keys<E: PairingEngine>(proving_key: ProvingKey<E>, verifying_key: VerifyingKey<E>, path: &str) {
	let mut pk = Vec::new();
	let mut vk = Vec::new();
	proving_key.serialize(&mut pk).unwrap();
	verifying_key.serialize(&mut vk).unwrap();

	let mut pk_uncompressed = Vec::new();
	let mut vk_uncompressed = Vec::new();
	proving_key.serialize_uncompressed(&mut pk_uncompressed).unwrap();
	verifying_key.serialize_uncompressed(&mut vk_uncompressed).unwrap();

	let current_path = current_dir().unwrap();
	write(format!("{}/{}/proving_key.bin", current_path.display(), path), pk).unwrap();
	write(format!("{}/{}/verifying_key.bin", current_path.display(), path), vk).unwrap();
	write(format!("{}/{}/proving_key_uncompressed.bin", current_path.display(), path), pk_uncompressed).unwrap();
	write(format!("{}/{}/verifying_key_uncompressed.bin", current_path.display(), path), vk_uncompressed).unwrap();
}

fn generate_mixer_keys<E: PairingEngine>(curve: Curve) {
	let mut rng = test_rng();
	let params3 = setup_params_x5_3::<E::Fr>(curve);
	let params5 = setup_params_x5_5::<E::Fr>(curve);

	let prover = MixerProverSetupBn254_30::new(params3, params5);
	let (circuit, ..) = prover.setup_random_circuit(&mut rng).unwrap();

	let (proving_key, verifying_key) = Groth16::<E>::circuit_specific_setup(circuit, &mut rng).unwrap();

	save_keys(proving_key, verifying_key, "../mixer/bn254/x5");
}

fn generate_anchor_keys<E: PairingEngine>(curve: Curve) {
	let mut rng = test_rng();
	let params3 = setup_params_x5_3::<E::Fr>(curve);
	let params4 = setup_params_x5_4::<E::Fr>(curve);

	let prover = AnchorProverSetupBn254_30::new(params3, params4);
	let (circuit, ..) = prover.setup_random_circuit(&mut rng).unwrap();

	let (proving_key, verifying_key) = Groth16::<E>::circuit_specific_setup(circuit, &mut rng).unwrap();

	save_keys(proving_key, verifying_key, "../fixed-anchor/bn254/x5");
}

fn generate_vanchor_keys<E: PairingEngine>(curve: Curve) {
	let mut rng = test_rng();
	let params2 = setup_params_x5_2::<E::Fr>(curve);
	let params3 = setup_params_x5_3::<E::Fr>(curve);
	let params4 = setup_params_x5_4::<E::Fr>(curve);
	let params5 = setup_params_x5_5::<E::Fr>(curve);

	let prover = VAnchorProverSetupBn254_30_2x2::new(params2, params3, params4, params5);
	let circuit = prover.setup_random_circuit(&mut rng).unwrap();

	let (proving_key, verifying_key) = Groth16::<E>::circuit_specific_setup(circuit, &mut rng).unwrap();

	save_keys(proving_key, verifying_key, "../vanchor/bn254/x5");
}

fn main() {
	generate_mixer_keys::<Bn254>(Curve::Bn254);
	generate_anchor_keys::<Bn254>(Curve::Bn254);
	generate_vanchor_keys::<Bn254>(Curve::Bn254);
}

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, PanicOnDefault, Promise
};
use near_sdk::log;
use near_sdk::collections::LookupMap;

use crate::util::*;
use crate::poseidon::*;
mod util;
mod merkle;
mod poseidon;

pub const ROOT_HISTORY_SIZE: u32 = 100;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct AnonymousContract {
    owner: AccountId,
    denomination: Balance,
    nullifier_hash: LookupMap<Vec<u8>, bool>,
    commitments: LookupMap< [u8; 32], bool>,
    levels: u32,
    next_index: u32,
    current_root_index: u32,
    sub_trees: LookupMap<String, [u8; 32]>,
    merkle_root: LookupMap<String, [u8; 32]>,
    verifier: MixerVerifier,
}

#[near_bindgen]
impl AnonymousContract {
    #[init]
    pub fn new(denomination: Balance, tree_levels: u32) -> Self {

        Self {
            owner: env::predecessor_account_id(),
            denomination: denomination,
            nullifier_hash: LookupMap::new(vec![0u8]),
            commitments: LookupMap::new(vec![0u8]),
            levels: tree_levels,
            next_index: 0,
            current_root_index: 0,
            sub_trees: LookupMap::new(b"s"),
            merkle_root: LookupMap::new(b"m"),
            verifier: MixerVerifier::new(),
        }
    }

    #[payable]
    pub fn deposit(&mut self, commitment: [u8; 32]) {
        assert!(self.commitments.get(&&commitment).unwrap_or(false) == false, "The commitment has been submitted");

        let poseidon =  Poseidon::new();

        self.insert(poseidon, commitment);

        assert_denomination(self.denomination);
        
    }

    #[payable]
    pub fn withdraw(&mut self, proof_bytes: Vec<u8>, root: [u8; 32], nullifier_hash: [u8; 32], recipient: AccountId, relayer: AccountId, fee: u128, refund:u8){
        
        assert!(fee < self.denomination, "Fee is greater than denomination");
        assert!(self.nullifier_hash.get(&nullifier_hash.to_vec()).unwrap_or(false) == false, "The note has been already spent");

        assert!(self.is_known_root(root) == true, "Cannot find your merkle root");
        let element_encoder = |v: &[u8]| {
            let mut output = [0u8; 32];
            output.iter_mut().zip(v).for_each(|(b1, b2)| *b1 = *b2);
            output
        };
        

        let mut recipient_bytes = recipient.to_string().into_bytes();
        let mut relayer_bytes = relayer.to_string().into_bytes();

        recipient_bytes = truncate_and_pad(&recipient_bytes);
        relayer_bytes = truncate_and_pad(&relayer_bytes);
        
        let fee_bytes = element_encoder(&fee.to_be_bytes());
        let refund_bytes = element_encoder(&refund.to_be_bytes());
        
        

        let mut bytes = Vec::new();
        bytes.extend_from_slice(&nullifier_hash);
        bytes.extend_from_slice(&root);
        bytes.extend_from_slice(&recipient_bytes);
        bytes.extend_from_slice(&relayer_bytes);
        bytes.extend_from_slice(&fee_bytes);
        bytes.extend_from_slice(&refund_bytes);

        
        let ver = MixerVerifier::new();
        let result = ver
            .verify(bytes, proof_bytes);

        assert!(result.unwrap_or(false) == true, "verify failed");
        self.nullifier_hash.insert(&nullifier_hash.to_vec(), &true);
        Promise::new(recipient).transfer(self.denomination - fee);

    }

    pub fn insert(&mut self, hasher: Poseidon, leaf: [u8; 32]) {
        let next_index = self.next_index;
        
        assert!(
            next_index != (2 as u32).pow(self.levels),
            "Merkle tree is full"
        );

        let mut current_index = next_index;
        let mut current_level_hash = leaf;
        let mut left: [u8; 32];
        let mut right: [u8; 32];

        for i in 0..self.levels {
            if current_index % 2 == 0 {
                left = current_level_hash;
                right = zeroes(i);
                self.sub_trees.insert(&i.to_string(), &current_level_hash);

            } else {
                left = self.sub_trees.get(&i.to_string()).unwrap_or([0u8; 32]);
                right = current_level_hash;
            }

            let inputs = vec![left, right];
            current_level_hash = hasher.hash(inputs).unwrap();
            current_index /= 2;
        }

        let new_root_index = (self.current_root_index + 1) % ROOT_HISTORY_SIZE;
        self.current_root_index = new_root_index;
        self.merkle_root.insert(&new_root_index.to_string(), &current_level_hash);
        self.next_index = next_index + 1;

    }

    pub fn is_known_root(&self, root: [u8; 32]) -> bool {
        assert!(root != [0u8; 32], "Root is zeros");
        
        let mut i = self.current_root_index;

        for _i in 0..ROOT_HISTORY_SIZE {
            let r = self.merkle_root.get(&i.to_string()).unwrap_or([0u8; 32]);
            if r == root {
                return true;
            }

            if i == 0 {
                i = ROOT_HISTORY_SIZE - 1;
            } else {
                i -=1;
            }
        }

        false
    }

    
    
}

fn truncate_and_pad(t: &[u8]) -> Vec<u8> {
    let mut truncated_bytes = t[..20].to_vec();
    truncated_bytes.extend_from_slice(&[0u8; 12]);
    truncated_bytes
}

'''
'''--- src/lib2.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault, Promise,
    PromiseOrValue,
};

use std::collections::HashMap;
use near_sdk::collections::LookupMap;
use lib2::merkle::*;
use lib2::util::*;
use lib2::poseidon::*;
mod util;
mod merkle;
mod poseidon;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct AnonymousContract {
    owner: AccountId,
    denomination: Balance,
    fee: Balance,
    nullifier_hash: LookupMap<Vec<u8>, bool>,
    
    
}

#[near_bindgen]
impl AnonymousContract {
    #[init]
    pub fn new(_denomination: Balance, _fee: Balance, _levels: u32) -> Self {

        let merkle_tree = merkle::MerkleTree {
            levels: _levels,
            next_index: 0,
            current_root_index: 0,
            sub_trees: LookupMap::new(b"s"),
            merkle_root: LookupMap::new(b"m"),
        };

        Self {
            owner: env::predecessor_account_id(),
            denomination: _denomination,
            fee: _fee,
            merkle_tree: merkle_tree,
            nullifier_hash: LookupMap::new(vec![0u8]),
        }
    }

    #[payable]
    pub fn deposit(&mut self, _commitment: [u8; 32]) {

        let mut merkle_tree = self.merkle_tree;
        let poseidon =  Poseidon::new();

        let res = merkle_tree.insert(poseidon, _commitment);

        self.merkle_tree = merkle_tree;

        // Require xem _commitment da ton tai chua

        // Them vao tree

        // thay doi trang thai commitment

        // nhan tien
        assert_denomination(self.denomination);
        
    }

    #[payable]
    pub fn withdraw(&mut self, proof_bytes: Vec<u8>, root: [u8; 32], nullifier_hash: [u8; 32], recipient: AccountId, fee: Balance){

        let merkle_tree =  self.merkle_tree;

        if !merkle_tree.is_known_root(root) {
            // Return Falied;
            println!("Falied by not root");
        }

        if self.nullifier_hash.get(&nullifier_hash.to_vec()).unwrap() {
            println!{"Failed by nullifier"};
        }

        

    }

} 

// fn is_known_nullifier(nullifier: [u8; 32]) -> bool {

// }

'''
'''--- src/merkle.rs ---
// use serde::{Deserialize, Serialize};
// use near_sdk::{
//     env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault, Promise,
//     PromiseOrValue,
// };

// use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

// use near_sdk::collections::LookupMap;

// use crate::poseidon::Poseidon;
// use std::result::Result;
// use crate::util::*;

// pub const ROOT_HISTORY_SIZE: u32 = 100;

// #[derive(Debug, BorshDeserialize, BorshSerialize)]
// pub struct MerkleTree {
//     pub levels: u32,
//     pub next_index: u32,
//     pub current_root_index: u32,
//     pub sub_trees: LookupMap<String, [u8; 32]>,
//     pub merkle_root: LookupMap<String, [u8; 32]>,
// }

// impl MerkleTree {
//     // fn hash_left_right(&mut self, hasher: Poseidon, left: [u8; 32], right: [u8; 32]) -> [u8; 32] {
//     //     let inputs = vec![left, right];
//     //     hasher.hash(inputs)
//     // }

//     pub fn insert(&mut self, hasher: Poseidon, leaf: [u8; 32]) {
//         let next_index = self.next_index;

//         assert!(
//             next_index != 2u32.pow(self.levels),
//             "Merkle tree is full"
//         );

//         let mut current_index = next_index;
//         let mut current_level_hash = leaf;
//         let mut left: [u8; 32];
//         let mut right: [u8; 32];

//         for i in 0..self.levels {
//             if current_index %2 == 0 {
//                 left = current_level_hash;
//                 //right = zeroes::zeroes(i);
//                 // TODO Fix zeroes
//                 right = zeroes(i);

                
//                 // self.sub_trees.insert(&i.to_string(), &current_level_hash);
//             } else {

//                 // left = self.sub_trees.get(&i.to_string()).unwrap_or([0u8; 32]);
//                 right = current_level_hash;
//             }

//             // current_level_hash = self.hash_left_right(hasher.clone(), left, right);
//             let inputs = vec![left, right];
//             current_level_hash = hasher.hash(inputs).unwrap();
//             current_index /=2;
//         }

//         let new_root_index  = (self.current_root_index + 1) % ROOT_HISTORY_SIZE;
//         self.current_root_index = new_root_index;

    

//         // self.merkle_root.insert(&new_root_index.to_string(), &current_level_hash);

//         self.next_index =  next_index + 1;

//     }

//     pub fn is_known_root(&self, root: [u8; 32]) -> bool {
//         if root == [0u8; 32] {
//             return false
//         }

//         let mut i = self.current_root_index;

//         // for _i in 0..ROOT_HISTORY_SIZE {
//         //     let r = self.merkle_root.get(&i.to_string()).unwrap_or([0u8; 32]);
//         //     if r == root {
//         //         return true;
//         //     }

//         //     if i == 0 {
//         //         i = ROOT_HISTORY_SIZE - 1;
//         //     } else {
//         //         i -=1;
//         //     }
//         // }

//         false
//     }
// }
'''
'''--- src/mixer_verifier.rs ---
// pub use self::mixer_verifier::MixerVerifier;

// mod verifier {
//     use ark_crypto_primitives::{Error, SNARK};
//     use ark_ec::PairingEngine;
//     use ark_groth16::{Groth16, Proof, VerifyingKey};
//     use ark_serialize::CanonicalDeserialize;
//     use ark_std::marker::PhantomData;
//     use arkworks_utils::utils::to_field_elements;
//     pub struct ArkworksVerifierGroth16<E: PairingEngine>(PhantomData<E>);

//     pub fn verify_groth16<E: PairingEngine>(
//         vk: &VerifyingKey<E>,
//         public_inputs: &[E::Fr],
//         proof: &Proof<E>,
//     ) -> Result<bool, Error> {
//         let res = Groth16::<E>::verify(vk, public_inputs, proof)?;
//         Ok(res)
//     }

//     impl<E: PairingEngine> ArkworksVerifierGroth16<E> {
//         pub fn verify(
//             public_inp_bytes: &[u8],
//             proof_bytes: &[u8],
//             vk_bytes: &[u8],
//         ) -> Result<bool, Error> {
//             let public_input_field_elts = to_field_elements::<E::Fr>(public_inp_bytes)?;
//             let vk = VerifyingKey::<E>::deserialize(vk_bytes)?;
//             let proof = Proof::<E>::deserialize(proof_bytes)?;
//             let res = verify_groth16::<E>(&vk, &public_input_field_elts, &proof)?;
//             Ok(res)
//         }
//     }

//     use ark_bn254::Bn254;
//     pub type ArkworksVerifierBn254 = ArkworksVerifierGroth16<Bn254>;
// }

// pub mod mixer_verifier {
//     use serde::{Deserialize, Serialize};

//     use crate::mixer_verifier::verifier::ArkworksVerifierBn254;

//     #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
//     pub struct MixerVerifier {
//         vk_bytes: Vec<u8>,
//     }

//     #[derive(Debug)]
//     pub enum Error {
//         /// Returned if error verifying
//         VerifierError,
//     }

//     /// The verifier result type.
//     pub type Result<T> = core::result::Result<T, Error>;

//     impl MixerVerifier {
//         /// Constructor that initializes the `bool` value to the given `init_value`.
//         pub fn new() -> Self {
//             let vk_bytes =
//                 include_bytes!("../protocol-substrate-fixtures/mixer/bn254/x5/verifying_key.bin");
//             Self {
//                 vk_bytes: vk_bytes.to_vec(),
//             }
//         }

//         /// A message that can be called on instantiated contracts.
//         /// This one flips the value of the stored `bool` from `true`
//         /// to `false` and vice versa.
//         pub fn verify(&self, public_inp_bytes: Vec<u8>, proof_bytes: Vec<u8>) -> Result<bool> {
//             ArkworksVerifierBn254::verify(&public_inp_bytes, &proof_bytes, &self.vk_bytes)
//                 .map_err(|_| Error::VerifierError)
//         }
//     }

//     impl Default for MixerVerifier {
//         fn default() -> Self {
//             Self::new()
//         }
//     }
// }
'''
'''--- src/poseidon.rs ---
pub use self::poseidon::Poseidon;

mod hasher {
    use ark_crypto_primitives::{Error, CRH as CRHTrait};
    use ark_ff::{BigInteger, PrimeField};
    use ark_std::{marker::PhantomData, vec::Vec};
    use arkworks_gadgets::poseidon::CRH;
    use arkworks_utils::poseidon::PoseidonParameters;
    pub struct ArkworksPoseidonHasher<F: PrimeField>(PhantomData<F>);

    impl<F: PrimeField> ArkworksPoseidonHasher<F> {
        pub fn hash(input: &[u8], param_bytes: &[u8]) -> Result<Vec<u8>, Error> {
            let params = PoseidonParameters::<F>::from_bytes(param_bytes)?;
            let output: F = <CRH<F> as CRHTrait>::evaluate(&params, input)?;
            let value = output.into_repr().to_bytes_le();
            Ok(value)
        }
    }

    use ark_bn254::Fr as Bn254;
    pub type ArkworksPoseidonHasherBn254 = ArkworksPoseidonHasher<Bn254>;
}

pub mod poseidon {
    use serde::{Deserialize, Serialize};

    use crate::poseidon::hasher::ArkworksPoseidonHasherBn254;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Poseidon {
        hasher_params_width_3_bytes: Vec<u8>,
        hasher_params_width_4_bytes: Vec<u8>,
        hasher_params_width_5_bytes: Vec<u8>,
    }

    /// The hash error types.
    #[derive(Debug)]
    pub enum Error {
        /// Returned if there is an error hashing
        HashError,
        /// Invalid hash width
        InvalidHashInputWidth,
    }

    /// The Hash result type.
    pub type Result<T> = core::result::Result<T, Error>;

    impl Poseidon {
        pub fn new() -> Self {
            Self {
                hasher_params_width_3_bytes:
                    arkworks_utils::utils::bn254_x5_3::get_poseidon_bn254_x5_3::<ark_bn254::Fr>()
                        .to_bytes(),
                hasher_params_width_4_bytes:
                    arkworks_utils::utils::bn254_x5_4::get_poseidon_bn254_x5_4::<ark_bn254::Fr>()
                        .to_bytes(),
                hasher_params_width_5_bytes:
                    arkworks_utils::utils::bn254_x5_5::get_poseidon_bn254_x5_5::<ark_bn254::Fr>()
                        .to_bytes(),
            }
        }

        pub fn hash(&self, inputs: Vec<[u8; 32]>) -> Result<[u8; 32]> {
            let num_inputs = inputs.len();
            let mut packed_inputs = Vec::new();
            for inp in inputs {
                packed_inputs.extend_from_slice(&inp);
            }

            let hash_result = match num_inputs {
                2 => ArkworksPoseidonHasherBn254::hash(
                    &packed_inputs,
                    &self.hasher_params_width_3_bytes,
                ),
                3 => ArkworksPoseidonHasherBn254::hash(
                    &packed_inputs,
                    &self.hasher_params_width_4_bytes,
                ),
                4 => ArkworksPoseidonHasherBn254::hash(
                    &packed_inputs,
                    &self.hasher_params_width_5_bytes,
                ),
                _ => return Err(Error::InvalidHashInputWidth),
            };

            hash_result
                .map(|h| {
                    let mut hash_result = [0u8; 32];
                    hash_result.copy_from_slice(&h);
                    hash_result
                })
                .map_err(|_| Error::HashError)
        }
    }

    impl Default for Poseidon {
        fn default() -> Self {
            Self::new()
        }
    }
}

'''
'''--- src/util.rs ---
use crate::*;

pub(crate) fn assert_denomination(denomination: Balance) {
    assert!(
        env::attached_deposit() >= denomination,
        "Require attached deposit of exactly denomination"
    )
}

pub(crate) fn zeroes(index: u32) -> [u8; 32] {
    match index {
        0 => [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ],
        1 => [
            100, 72, 182, 70, 132, 238, 57, 168, 35, 213, 254, 95, 213, 36, 49, 220, 129, 228, 129,
            123, 242, 195, 234, 60, 171, 158, 35, 158, 251, 245, 152, 32,
        ],
        2 => [
            225, 241, 177, 96, 68, 119, 164, 103, 240, 141, 198, 157, 203, 68, 26, 38, 236, 167,
            132, 245, 111, 26, 48, 223, 99, 34, 177, 205, 61, 103, 105, 16,
        ],
        3 => [
            56, 210, 86, 184, 178, 126, 213, 40, 213, 29, 55, 80, 234, 110, 124, 70, 6, 33, 247,
            80, 141, 117, 61, 46, 175, 226, 126, 83, 49, 51, 244, 24,
        ],
        4 => [
            42, 149, 188, 157, 85, 151, 172, 202, 101, 130, 86, 26, 87, 40, 183, 241, 69, 35, 165,
            59, 233, 255, 32, 99, 211, 176, 23, 203, 55, 216, 249, 7,
        ],
        5 => [
            85, 63, 24, 57, 22, 236, 92, 123, 77, 173, 178, 148, 140, 197, 153, 166, 7, 41, 243,
            93, 76, 31, 99, 201, 245, 179, 70, 135, 94, 207, 148, 43,
        ],
        6 => [
            120, 157, 160, 46, 163, 221, 17, 29, 97, 83, 185, 81, 105, 30, 215, 254, 188, 225, 169,
            204, 34, 125, 234, 70, 150, 69, 102, 166, 197, 147, 238, 45,
        ],
        7 => [
            157, 52, 135, 60, 190, 170, 164, 168, 127, 172, 181, 140, 168, 21, 5, 139, 123, 89, 57,
            182, 30, 96, 207, 130, 233, 132, 43, 162, 229, 149, 130, 7,
        ],
        8 => [
            97, 204, 243, 153, 58, 190, 76, 68, 26, 33, 65, 74, 39, 46, 107, 97, 42, 71, 100, 69,
            134, 236, 27, 80, 166, 39, 96, 143, 241, 229, 165, 47,
        ],
        9 => [
            71, 215, 252, 20, 166, 86, 33, 62, 171, 40, 226, 227, 204, 122, 94, 228, 102, 31, 148,
            158, 56, 128, 183, 236, 33, 253, 216, 208, 118, 67, 136, 14,
        ],
        10 => [
            242, 10, 25, 218, 229, 117, 97, 222, 51, 53, 113, 87, 249, 146, 88, 249, 105, 180, 46,
            165, 209, 122, 113, 40, 30, 79, 73, 114, 218, 1, 114, 27,
        ],
        11 => [
            54, 118, 125, 206, 250, 107, 188, 190, 181, 8, 8, 101, 228, 225, 230, 166, 25, 152, 36,
            1, 178, 192, 0, 82, 56, 54, 94, 114, 34, 136, 141, 31,
        ],
        12 => [
            90, 248, 181, 113, 4, 154, 135, 208, 168, 136, 207, 42, 161, 176, 98, 97, 251, 252,
            140, 186, 137, 21, 112, 185, 175, 75, 145, 108, 246, 130, 93, 44,
        ],
        13 => [
            208, 191, 191, 224, 112, 242, 88, 100, 100, 244, 19, 161, 170, 196, 245, 78, 19, 161,
            63, 223, 90, 127, 149, 32, 184, 11, 148, 160, 72, 65, 197, 20,
        ],
        14 => [
            12, 232, 235, 244, 75, 142, 17, 22, 212, 137, 173, 140, 88, 37, 190, 17, 175, 185, 216,
            68, 238, 192, 16, 30, 150, 111, 152, 47, 177, 51, 13, 25,
        ],
        15 => [
            146, 108, 224, 37, 147, 100, 179, 165, 10, 81, 175, 150, 101, 174, 103, 17, 237, 115,
            173, 20, 73, 53, 23, 172, 82, 65, 112, 206, 169, 138, 249, 34,
        ],
        16 => [
            35, 115, 186, 139, 211, 83, 183, 248, 238, 204, 110, 198, 41, 111, 82, 90, 87, 106,
            191, 114, 141, 34, 111, 159, 11, 136, 229, 108, 155, 124, 124, 42,
        ],
        17 => [
            146, 185, 54, 63, 100, 221, 117, 77, 149, 139, 152, 194, 201, 67, 0, 71, 252, 63, 70,
            77, 193, 249, 122, 198, 193, 142, 105, 88, 229, 134, 129, 46,
        ],
        18 => [
            15, 241, 31, 28, 157, 36, 70, 53, 39, 146, 115, 100, 173, 110, 239, 138, 148, 174, 13,
            5, 207, 200, 226, 73, 171, 78, 154, 30, 87, 197, 87, 15,
        ],
        19 => [
            202, 44, 247, 52, 97, 227, 156, 60, 228, 70, 125, 105, 16, 227, 120, 254, 28, 14, 128,
            136, 67, 61, 246, 213, 74, 85, 251, 181, 103, 238, 48, 24,
        ],
        20 => [
            62, 31, 25, 34, 223, 182, 113, 211, 249, 18, 247, 234, 70, 30, 10, 136, 238, 132, 143,
            221, 225, 43, 108, 24, 171, 26, 210, 197, 106, 231, 52, 33,
        ],
        21 => [
            177, 165, 145, 219, 243, 141, 143, 143, 168, 58, 238, 88, 201, 216, 81, 192, 176, 89,
            56, 243, 102, 216, 235, 254, 79, 188, 78, 132, 236, 144, 223, 25,
        ],
        22 => [
            43, 229, 239, 34, 247, 5, 140, 100, 180, 18, 73, 239, 147, 14, 175, 116, 45, 133, 132,
            253, 174, 105, 30, 152, 135, 7, 92, 107, 166, 162, 204, 24,
        ],
        23 => [
            141, 83, 210, 73, 69, 100, 5, 223, 250, 131, 173, 239, 242, 56, 131, 98, 58, 71, 79,
            213, 210, 4, 19, 77, 27, 13, 35, 21, 148, 144, 136, 35,
        ],
        24 => [
            64, 213, 158, 82, 228, 115, 230, 150, 29, 11, 141, 156, 44, 175, 162, 102, 232, 77, 41,
            181, 67, 245, 232, 233, 192, 108, 123, 169, 180, 31, 23, 39,
        ],
        25 => [
            33, 174, 230, 221, 150, 150, 213, 248, 229, 131, 37, 57, 185, 48, 178, 220, 40, 13,
            252, 116, 188, 160, 17, 87, 253, 41, 246, 64, 5, 101, 246, 47,
        ],
        26 => [
            24, 21, 97, 206, 48, 38, 147, 105, 86, 215, 173, 246, 104, 81, 173, 224, 162, 120, 119,
            39, 245, 247, 2, 89, 233, 145, 212, 67, 241, 88, 12, 18,
        ],
        27 => [
            149, 55, 72, 121, 210, 101, 214, 162, 29, 162, 101, 165, 160, 149, 196, 30, 7, 3, 219,
            229, 213, 83, 248, 123, 176, 33, 63, 13, 183, 254, 33, 31,
        ],
        28 => [
            210, 114, 138, 225, 221, 161, 177, 139, 150, 158, 138, 6, 104, 231, 38, 168, 35, 134,
            106, 246, 192, 140, 99, 76, 225, 53, 19, 167, 95, 144, 190, 36,
        ],
        29 => [
            109, 194, 218, 83, 229, 116, 76, 116, 40, 195, 101, 29, 130, 243, 126, 89, 205, 212,
            87, 173, 222, 234, 12, 197, 145, 116, 209, 46, 182, 102, 134, 15,
        ],
        30 => [
            239, 89, 25, 14, 35, 42, 26, 61, 180, 140, 224, 106, 63, 122, 122, 78, 89, 65, 28, 26,
            74, 63, 65, 52, 176, 152, 45, 245, 107, 212, 24, 9,
        ],
        // Reuse index 0 for wildcard
        _ => [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ],
    }
}

pub use self::mixer_verifier::MixerVerifier;

mod verifier {
    use ark_crypto_primitives::{Error, SNARK};
    use ark_ec::PairingEngine;
    use ark_groth16::{Groth16, Proof, VerifyingKey};
    use ark_serialize::CanonicalDeserialize;
    use ark_std::marker::PhantomData;
    use arkworks_utils::utils::to_field_elements;
    pub struct ArkworksVerifierGroth16<E: PairingEngine>(PhantomData<E>);
    use near_sdk::log;

    pub fn verify_groth16<E: PairingEngine>(
        vk: &VerifyingKey<E>,
        public_inputs: &[E::Fr],
        proof: &Proof<E>,
    ) -> Result<bool, Error> {
        let res = Groth16::<E>::verify(vk, public_inputs, proof)?;
        Ok(res)
    }

    impl<E: PairingEngine> ArkworksVerifierGroth16<E> {
        pub fn verify(
            public_inp_bytes: &[u8],
            proof_bytes: &[u8],
            vk_bytes: &[u8],
        ) -> Result<bool, Error> {
            let public_input_field_elts = to_field_elements::<E::Fr>(public_inp_bytes)?;
            let vk = VerifyingKey::<E>::deserialize(vk_bytes)?;
            let proof = Proof::<E>::deserialize(proof_bytes)?;
            let res = verify_groth16::<E>(&vk, &public_input_field_elts, &proof)?;
            Ok(res)
        }
    }

    use ark_bn254::Bn254;
    pub type ArkworksVerifierBn254 = ArkworksVerifierGroth16<Bn254>;
}

pub mod mixer_verifier {
    use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
    use serde::{Deserialize, Serialize};

    use crate::util::verifier::ArkworksVerifierBn254;
    use near_sdk::log;

    #[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct MixerVerifier {
        vk_bytes: Vec<u8>,
    }

    #[derive(Debug)]
    pub enum Error {
        /// Returned if error verifying
        VerifierError,
    }

    /// The verifier result type.
    pub type Result<T> = core::result::Result<T, Error>;

    impl MixerVerifier {
        /// Constructor that initializes the `bool` value to the given `init_value`.
        pub fn new() -> Self {
            let vk_bytes =
                include_bytes!("../protocol-substrate-fixtures/mixer/bn254/x5/verifying_key.bin");
            Self {
                vk_bytes: vk_bytes.to_vec(),
            }
        }

        /// A message that can be called on instantiated contracts.
        /// This one flips the value of the stored `bool` from `true`
        /// to `false` and vice versa.
        pub fn verify(&self, public_inp_bytes: Vec<u8>, proof_bytes: Vec<u8>) -> Result<bool> {
            ArkworksVerifierBn254::verify(&public_inp_bytes, &proof_bytes, &self.vk_bytes)
                .map_err(|_| Error::VerifierError)
        }
    }

    impl Default for MixerVerifier {
        fn default() -> Self {
            Self::new()
        }
    }
}

'''
'''--- src/zero.rs ---
use crate::*;

pub(crate) fn zeroes(index: u32) -> [u8; 32] {
    match index {
        0 => [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ],
        1 => [
            100, 72, 182, 70, 132, 238, 57, 168, 35, 213, 254, 95, 213, 36, 49, 220, 129, 228, 129,
            123, 242, 195, 234, 60, 171, 158, 35, 158, 251, 245, 152, 32,
        ],
        2 => [
            225, 241, 177, 96, 68, 119, 164, 103, 240, 141, 198, 157, 203, 68, 26, 38, 236, 167,
            132, 245, 111, 26, 48, 223, 99, 34, 177, 205, 61, 103, 105, 16,
        ],
        3 => [
            56, 210, 86, 184, 178, 126, 213, 40, 213, 29, 55, 80, 234, 110, 124, 70, 6, 33, 247,
            80, 141, 117, 61, 46, 175, 226, 126, 83, 49, 51, 244, 24,
        ],
        4 => [
            42, 149, 188, 157, 85, 151, 172, 202, 101, 130, 86, 26, 87, 40, 183, 241, 69, 35, 165,
            59, 233, 255, 32, 99, 211, 176, 23, 203, 55, 216, 249, 7,
        ],
        5 => [
            85, 63, 24, 57, 22, 236, 92, 123, 77, 173, 178, 148, 140, 197, 153, 166, 7, 41, 243,
            93, 76, 31, 99, 201, 245, 179, 70, 135, 94, 207, 148, 43,
        ],
        6 => [
            120, 157, 160, 46, 163, 221, 17, 29, 97, 83, 185, 81, 105, 30, 215, 254, 188, 225, 169,
            204, 34, 125, 234, 70, 150, 69, 102, 166, 197, 147, 238, 45,
        ],
        7 => [
            157, 52, 135, 60, 190, 170, 164, 168, 127, 172, 181, 140, 168, 21, 5, 139, 123, 89, 57,
            182, 30, 96, 207, 130, 233, 132, 43, 162, 229, 149, 130, 7,
        ],
        8 => [
            97, 204, 243, 153, 58, 190, 76, 68, 26, 33, 65, 74, 39, 46, 107, 97, 42, 71, 100, 69,
            134, 236, 27, 80, 166, 39, 96, 143, 241, 229, 165, 47,
        ],
        9 => [
            71, 215, 252, 20, 166, 86, 33, 62, 171, 40, 226, 227, 204, 122, 94, 228, 102, 31, 148,
            158, 56, 128, 183, 236, 33, 253, 216, 208, 118, 67, 136, 14,
        ],
        10 => [
            242, 10, 25, 218, 229, 117, 97, 222, 51, 53, 113, 87, 249, 146, 88, 249, 105, 180, 46,
            165, 209, 122, 113, 40, 30, 79, 73, 114, 218, 1, 114, 27,
        ],
        11 => [
            54, 118, 125, 206, 250, 107, 188, 190, 181, 8, 8, 101, 228, 225, 230, 166, 25, 152, 36,
            1, 178, 192, 0, 82, 56, 54, 94, 114, 34, 136, 141, 31,
        ],
        12 => [
            90, 248, 181, 113, 4, 154, 135, 208, 168, 136, 207, 42, 161, 176, 98, 97, 251, 252,
            140, 186, 137, 21, 112, 185, 175, 75, 145, 108, 246, 130, 93, 44,
        ],
        13 => [
            208, 191, 191, 224, 112, 242, 88, 100, 100, 244, 19, 161, 170, 196, 245, 78, 19, 161,
            63, 223, 90, 127, 149, 32, 184, 11, 148, 160, 72, 65, 197, 20,
        ],
        14 => [
            12, 232, 235, 244, 75, 142, 17, 22, 212, 137, 173, 140, 88, 37, 190, 17, 175, 185, 216,
            68, 238, 192, 16, 30, 150, 111, 152, 47, 177, 51, 13, 25,
        ],
        15 => [
            146, 108, 224, 37, 147, 100, 179, 165, 10, 81, 175, 150, 101, 174, 103, 17, 237, 115,
            173, 20, 73, 53, 23, 172, 82, 65, 112, 206, 169, 138, 249, 34,
        ],
        16 => [
            35, 115, 186, 139, 211, 83, 183, 248, 238, 204, 110, 198, 41, 111, 82, 90, 87, 106,
            191, 114, 141, 34, 111, 159, 11, 136, 229, 108, 155, 124, 124, 42,
        ],
        17 => [
            146, 185, 54, 63, 100, 221, 117, 77, 149, 139, 152, 194, 201, 67, 0, 71, 252, 63, 70,
            77, 193, 249, 122, 198, 193, 142, 105, 88, 229, 134, 129, 46,
        ],
        18 => [
            15, 241, 31, 28, 157, 36, 70, 53, 39, 146, 115, 100, 173, 110, 239, 138, 148, 174, 13,
            5, 207, 200, 226, 73, 171, 78, 154, 30, 87, 197, 87, 15,
        ],
        19 => [
            202, 44, 247, 52, 97, 227, 156, 60, 228, 70, 125, 105, 16, 227, 120, 254, 28, 14, 128,
            136, 67, 61, 246, 213, 74, 85, 251, 181, 103, 238, 48, 24,
        ],
        20 => [
            62, 31, 25, 34, 223, 182, 113, 211, 249, 18, 247, 234, 70, 30, 10, 136, 238, 132, 143,
            221, 225, 43, 108, 24, 171, 26, 210, 197, 106, 231, 52, 33,
        ],
        21 => [
            177, 165, 145, 219, 243, 141, 143, 143, 168, 58, 238, 88, 201, 216, 81, 192, 176, 89,
            56, 243, 102, 216, 235, 254, 79, 188, 78, 132, 236, 144, 223, 25,
        ],
        22 => [
            43, 229, 239, 34, 247, 5, 140, 100, 180, 18, 73, 239, 147, 14, 175, 116, 45, 133, 132,
            253, 174, 105, 30, 152, 135, 7, 92, 107, 166, 162, 204, 24,
        ],
        23 => [
            141, 83, 210, 73, 69, 100, 5, 223, 250, 131, 173, 239, 242, 56, 131, 98, 58, 71, 79,
            213, 210, 4, 19, 77, 27, 13, 35, 21, 148, 144, 136, 35,
        ],
        24 => [
            64, 213, 158, 82, 228, 115, 230, 150, 29, 11, 141, 156, 44, 175, 162, 102, 232, 77, 41,
            181, 67, 245, 232, 233, 192, 108, 123, 169, 180, 31, 23, 39,
        ],
        25 => [
            33, 174, 230, 221, 150, 150, 213, 248, 229, 131, 37, 57, 185, 48, 178, 220, 40, 13,
            252, 116, 188, 160, 17, 87, 253, 41, 246, 64, 5, 101, 246, 47,
        ],
        26 => [
            24, 21, 97, 206, 48, 38, 147, 105, 86, 215, 173, 246, 104, 81, 173, 224, 162, 120, 119,
            39, 245, 247, 2, 89, 233, 145, 212, 67, 241, 88, 12, 18,
        ],
        27 => [
            149, 55, 72, 121, 210, 101, 214, 162, 29, 162, 101, 165, 160, 149, 196, 30, 7, 3, 219,
            229, 213, 83, 248, 123, 176, 33, 63, 13, 183, 254, 33, 31,
        ],
        28 => [
            210, 114, 138, 225, 221, 161, 177, 139, 150, 158, 138, 6, 104, 231, 38, 168, 35, 134,
            106, 246, 192, 140, 99, 76, 225, 53, 19, 167, 95, 144, 190, 36,
        ],
        29 => [
            109, 194, 218, 83, 229, 116, 76, 116, 40, 195, 101, 29, 130, 243, 126, 89, 205, 212,
            87, 173, 222, 234, 12, 197, 145, 116, 209, 46, 182, 102, 134, 15,
        ],
        30 => [
            239, 89, 25, 14, 35, 42, 26, 61, 180, 140, 224, 106, 63, 122, 122, 78, 89, 65, 28, 26,
            74, 63, 65, 52, 176, 152, 45, 245, 107, 212, 24, 9,
        ],
        // Reuse index 0 for wildcard
        _ => [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ],
    }
}
'''
'''--- vcc.py ---
cos_inputs =  [21, 154, 41, 203, 105, 7, 200, 121, 211, 223, 35, 54, 81, 59, 49, 57, 72, 63, 141, 192, 158, 2, 24, 238, 184, 79, 27, 77, 104, 118, 219, 33, 247, 98, 18, 78, 4, 162, 174, 24, 10, 228, 247, 212, 1, 166, 98, 244, 200, 90, 77, 57, 236, 174, 223, 179, 235, 0, 205, 55, 132, 144, 70, 26, 99, 97, 108, 108, 109, 101, 116, 117, 97, 110, 97, 110, 104, 46, 116, 101, 115, 116, 110, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 97, 108, 108, 109, 101, 116, 117, 97, 110, 97, 110, 104, 46, 116, 101, 115, 116, 110, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

near_inputs = [21, 154, 41, 203, 105, 7, 200, 121, 211, 223, 35, 54, 81, 59, 49, 57, 72, 63, 141, 192, 158, 2, 24, 238, 184, 79, 27, 77, 104, 118, 219, 33, 247, 98, 18, 78, 4, 162, 174, 24, 10, 228, 247, 212, 1, 166, 98, 244, 200, 90, 77, 57, 236, 174, 223, 179, 235, 0, 205, 55, 132, 144, 70, 26, 99, 97, 108, 108, 109, 101, 116, 117, 97, 110, 97, 110, 104, 46, 116, 101, 115, 116, 110, 101, 116, 99, 97, 108, 108, 109, 101, 116, 117, 97, 110, 97, 110, 104, 46, 116, 101, 115, 116, 110, 101, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
near_proof =  [93, 174, 94, 89, 135, 58, 124, 66, 112, 174, 19, 199, 89, 8, 62, 63, 241, 96, 115, 18, 137, 128, 159, 149, 192, 222, 42, 195, 19, 242, 51, 46, 4, 191, 168, 0, 151, 60, 150, 45, 165, 33, 128, 40, 4, 104, 243, 199, 167, 151, 116, 46, 123, 51, 11, 65, 49, 60, 156, 143, 134, 167, 100, 25, 167, 2, 237, 223, 209, 202, 56, 16, 248, 150, 211, 48, 226, 126, 202, 150, 242, 64, 193, 141, 126, 253, 207, 107, 67, 86, 110, 214, 225, 207, 165, 143, 182, 184, 222, 36, 168, 48, 33, 54, 205, 19, 241, 22, 163, 255, 98, 144, 243, 188, 15, 76, 204, 142, 69, 248, 167, 62, 13, 181, 188, 70, 36, 20]
near_key = [149, 229, 101, 88, 100, 4, 250, 96, 247, 71, 232, 13, 37, 96, 25, 0, 58, 59, 170, 192, 153, 186, 201, 53, 52, 68, 134, 78, 216, 35, 197, 133, 51, 149, 196, 231, 25, 186, 151, 253, 9, 153, 116, 162, 73, 52, 228, 245, 181, 64, 90, 183, 2, 84, 109, 174, 68, 148, 3, 146, 249, 112, 249, 34, 29, 149, 51, 170, 157, 9, 62, 225, 20, 28, 134, 177, 247, 178, 245, 104, 43, 44, 177, 89, 167, 231, 183, 14, 21, 169, 179, 87, 1, 255, 63, 142, 57, 146, 21, 163, 120, 223, 167, 249, 0, 105, 63, 18, 204, 58, 237, 109, 67, 102, 105, 102, 235, 19, 205, 179, 178, 146, 35, 239, 156, 232, 55, 14, 229, 217, 74, 39, 17, 110, 192, 137, 75, 61, 159, 182, 249, 237, 135, 107, 124, 199, 128, 20, 174, 96, 237, 164, 104, 248, 43, 67, 159, 124, 246, 28, 111, 160, 204, 128, 219, 117, 243, 122, 1, 177, 55, 171, 50, 74, 244, 108, 124, 11, 154, 255, 77, 58, 171, 123, 21, 186, 226, 119, 76, 244, 149, 21, 254, 213, 233, 157, 62, 58, 130, 65, 212, 236, 44, 0, 127, 92, 213, 50, 14, 78, 80, 78, 223, 114, 211, 214, 59, 85, 19, 203, 10, 165, 115, 174, 7, 0, 0, 0, 0, 0, 0, 0, 189, 115, 140, 254, 246, 241, 56, 164, 153, 131, 0, 157, 196, 69, 233, 245, 187, 215, 48, 113, 146, 18, 137, 55, 228, 134, 82, 236, 155, 193, 22, 18, 110, 146, 86, 167, 202, 211, 174, 113, 97, 214, 82, 164, 235, 12, 145, 99, 43, 193, 164, 196, 140, 5, 2, 243, 238, 126, 154, 87, 249, 187, 229, 162, 117, 18, 255, 192, 165, 58, 91, 163, 129, 20, 9, 219, 244, 188, 225, 123, 193, 119, 2, 27, 182, 162, 144, 140, 98, 90, 51, 2, 53, 35, 94, 165, 84, 42, 135, 78, 99, 107, 45, 48, 118, 108, 100, 75, 161, 27, 216, 5, 126, 49, 225, 149, 105, 71, 71, 13, 36, 120, 170, 38, 75, 76, 190, 21, 109, 95, 39, 83, 146, 120, 226, 215, 1, 77, 8, 38, 230, 252, 76, 234, 128, 63, 21, 150, 249, 42, 234, 75, 136, 163, 54, 135, 53, 60, 83, 12, 103, 91, 134, 233, 39, 37, 156, 65, 237, 116, 240, 194, 64, 248, 250, 128, 243, 112, 60, 164, 67, 153, 225, 58, 70, 112, 202, 102, 104, 88, 40, 7, 140, 248, 33, 221, 197, 68, 134, 214, 15, 210, 122, 80, 174, 65, 33, 37, 191, 6, 1, 29, 92, 10, 177, 86, 202, 16, 112, 253, 201, 158, 14, 162]

cos_inputs = [21, 154, 41, 203, 105, 7, 200, 121, 211, 223, 35, 54, 81, 59, 49, 57, 72, 63, 141, 192, 158, 2, 24, 238, 184, 79, 27, 77, 104, 118, 219, 33, 247, 98, 18, 78, 4, 162, 174, 24, 10, 228, 247, 212, 1, 166, 98, 244, 200, 90, 77, 57, 236, 174, 223, 179, 235, 0, 205, 55, 132, 144, 70, 26, 99, 97, 108, 108, 109, 101, 116, 117, 97, 110, 97, 110, 104, 46, 116, 101, 115, 116, 110, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 97, 108, 108, 109, 101, 116, 117, 97, 110, 97, 110, 104, 46, 116, 101, 115, 116, 110, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
cos_proof = [93, 174, 94, 89, 135, 58, 124, 66, 112, 174, 19, 199, 89, 8, 62, 63, 241, 96, 115, 18, 137, 128, 159, 149, 192, 222, 42, 195, 19, 242, 51, 46, 4, 191, 168, 0, 151, 60, 150, 45, 165, 33, 128, 40, 4, 104, 243, 199, 167, 151, 116, 46, 123, 51, 11, 65, 49, 60, 156, 143, 134, 167, 100, 25, 167, 2, 237, 223, 209, 202, 56, 16, 248, 150, 211, 48, 226, 126, 202, 150, 242, 64, 193, 141, 126, 253, 207, 107, 67, 86, 110, 214, 225, 207, 165, 143, 182, 184, 222, 36, 168, 48, 33, 54, 205, 19, 241, 22, 163, 255, 98, 144, 243, 188, 15, 76, 204, 142, 69, 248, 167, 62, 13, 181, 188, 70, 36, 20]
cos_key = [149, 229, 101, 88, 100, 4, 250, 96, 247, 71, 232, 13, 37, 96, 25, 0, 58, 59, 170, 192, 153, 186, 201, 53, 52, 68, 134, 78, 216, 35, 197, 133, 51, 149, 196, 231, 25, 186, 151, 253, 9, 153, 116, 162, 73, 52, 228, 245, 181, 64, 90, 183, 2, 84, 109, 174, 68, 148, 3, 146, 249, 112, 249, 34, 29, 149, 51, 170, 157, 9, 62, 225, 20, 28, 134, 177, 247, 178, 245, 104, 43, 44, 177, 89, 167, 231, 183, 14, 21, 169, 179, 87, 1, 255, 63, 142, 57, 146, 21, 163, 120, 223, 167, 249, 0, 105, 63, 18, 204, 58, 237, 109, 67, 102, 105, 102, 235, 19, 205, 179, 178, 146, 35, 239, 156, 232, 55, 14, 229, 217, 74, 39, 17, 110, 192, 137, 75, 61, 159, 182, 249, 237, 135, 107, 124, 199, 128, 20, 174, 96, 237, 164, 104, 248, 43, 67, 159, 124, 246, 28, 111, 160, 204, 128, 219, 117, 243, 122, 1, 177, 55, 171, 50, 74, 244, 108, 124, 11, 154, 255, 77, 58, 171, 123, 21, 186, 226, 119, 76, 244, 149, 21, 254, 213, 233, 157, 62, 58, 130, 65, 212, 236, 44, 0, 127, 92, 213, 50, 14, 78, 80, 78, 223, 114, 211, 214, 59, 85, 19, 203, 10, 165, 115, 174, 7, 0, 0, 0, 0, 0, 0, 0, 189, 115, 140, 254, 246, 241, 56, 164, 153, 131, 0, 157, 196, 69, 233, 245, 187, 215, 48, 113, 146, 18, 137, 55, 228, 134, 82, 236, 155, 193, 22, 18, 110, 146, 86, 167, 202, 211, 174, 113, 97, 214, 82, 164, 235, 12, 145, 99, 43, 193, 164, 196, 140, 5, 2, 243, 238, 126, 154, 87, 249, 187, 229, 162, 117, 18, 255, 192, 165, 58, 91, 163, 129, 20, 9, 219, 244, 188, 225, 123, 193, 119, 2, 27, 182, 162, 144, 140, 98, 90, 51, 2, 53, 35, 94, 165, 84, 42, 135, 78, 99, 107, 45, 48, 118, 108, 100, 75, 161, 27, 216, 5, 126, 49, 225, 149, 105, 71, 71, 13, 36, 120, 170, 38, 75, 76, 190, 21, 109, 95, 39, 83, 146, 120, 226, 215, 1, 77, 8, 38, 230, 252, 76, 234, 128, 63, 21, 150, 249, 42, 234, 75, 136, 163, 54, 135, 53, 60, 83, 12, 103, 91, 134, 233, 39, 37, 156, 65, 237, 116, 240, 194, 64, 248, 250, 128, 243, 112, 60, 164, 67, 153, 225, 58, 70, 112, 202, 102, 104, 88, 40, 7, 140, 248, 33, 221, 197, 68, 134, 214, 15, 210, 122, 80, 174, 65, 33, 37, 191, 6, 1, 29, 92, 10, 177, 86, 202, 16, 112, 253, 201, 158, 14, 162]

print(near_inputs == cos_inputs)

'''