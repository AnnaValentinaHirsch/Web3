*GitHub Repository "pztask/mintbase-pzt-session-nft-lib"*

'''--- README.md ---
# Mintbase Puzzletask Session-NFT Lib

## Core Features

The core `mintbase-pzt-session-nft-lib` is a set of convenience helpers to be used together with [mintbase JS](https://github.com/Mintbase/mintbase-js) to call the Mintbase Puzzletask Session-NFT smart contract methods.

It relies on the low-level isomorphic `execute` method that can be passed raw `NearContractCall` information.

## Install lib

```bash
yarn add https://github.com/pztask/mintbase-pzt-session-nft-lib/
```

## How to import the helpers

```typescript
import {
  mintUserBoundNFT,
  transferUserBoundNFT,
  burnUserBoundNFT,
  permitRequest,
  getUserNFTs,
  getUserPermit,
} from "mintbase-pzt-session-nft-lib/puzzletaskHelpers";
```

## Using the helpers

The easiest way to call mintbase token and market contracts are with the helpers.

Details such as the method name, arguments, gas supplied, deposits and some other less than convenient aspects of blockchain development **will be abstracted away for you**, or at least well documented in each example.

Mint user bound NFT example using the `mintUserBoundNFT` helper:

```typescript
const mintNFT = useCallback(async () => {
  const wallet = await selector.wallet();
  const mintCall = mintUserBoundNFT({
    contractAddress: CONTRACT_ADRESS,
    receiverId: activeAccountId ?? "",
    userId: (session as any)?.user?.id,
    metadata: {
      title: "PZT Token " + new Date().toLocaleString("en-US"),
      description: "I'm a PZT User Bound Token.",
    },
  });
  await execute({ wallet }, mintCall).catch((e) => {
    alert(e);
  });
}, [selector, activeAccountId, session]);
```

The same applies for `transferUserBoundNFT`, `burnUserBoundNFT`, `permitRequest`.

## Using the views helpers

Since we rely on the mintbase JS `execute` method for our contract calls, and they will always be signed, we can't sent view calls to the contract with the `execute` method. As a workaround we relied on the [near-api-js](https://github.com/near/near-api-js) `Contract` to make this calls.

Example on how to get user NFTs using the `getUserNFTs` helper:

```typescript
const callGetUserNFTs = useCallback(async () => {
  return await getUserNFTs({
    nearContract: nearContract,
    userId: (session as any)?.user?.id,
  });
}, [nearContract, session]);
```

The same applies for `getUserPermit`.

## Note

This lib is meant to be used within the [Mintbase Puzzletask Session-NFT](https://github.com/pztask/mintbase-pzt-session-nft-demo) use case, and depends on having a compatible smart-contract deployed and having some sort of API to handle the user/session and wallet. For more information on the specific use case please refer to the demo [documentation](https://github.com/pztask/mintbase-pzt-session-nft-demo).

'''
'''--- constants.ts ---
import { utils } from "near-api-js";

export const GAS = "200000000000000";
export const ONE_YOCTO = "1";
export const DEPOSIT_FOR_BURN = ONE_YOCTO;
export const DEPOSIT_FOR_TRANSFER = ONE_YOCTO;
export const DEPOSIT_FOR_PERMIT_REQUEST = utils.format.parseNearAmount("0.1");

export const CONTRACT_METHOD_NAMES = {
  MINT: "nft_mint",
  TRANSFER: "nft_transfer",
  BURN: "nft_burn",
  PERMIT_REQUEST: "permit_request",
};

export const STORAGE_BYTES = {
  COMMON: 80, // one royalty owner, one split owner, or one approval
  TOKEN_BASE: 440,
  MINTING_BASE: 92,
  MINTING_FEE: 100, // minting fee of 1 milliNEAR expressed as bytes
};

// currently 19, meaning that 1 bytes costs 1e19 yoctoNEAR
export const STORAGE_PRICE_PER_BYTE_EXPONENT = 19;

'''
'''--- near.ts ---
import { connect, Contract, keyStores } from "near-api-js";
import { Network } from "mintbase";

const NEAR_RPC_URL = process.env.NEAR_RPC_URL ?? "";
const NEAR_CONTRACT_ID = process.env.NEAR_CONTRACT_ID ?? "";

export async function NearContract(
  accountId: string | null
): Promise<Contract> {
  accountId = accountId ? accountId : "";
  const keyStore = new keyStores.BrowserLocalStorageKeyStore();
  const connection = await connect({
    networkId: Network.testnet,
    keyStore: keyStore,
    masterAccount: accountId,
    nodeUrl: NEAR_RPC_URL,
    headers: {},
  });

  const nearAccount = await connection.account(accountId);

  const contract = new Contract(nearAccount, NEAR_CONTRACT_ID, {
    changeMethods: [],
    viewMethods: ["nft_tokens_for_user", "permit_for_user"],
  });
  return contract;
}

'''
'''--- package.json ---
{
  "name": "mintbase-pzt-session-nft-lib",
  "version": "0.1.0",
  "private": false,
  "license": "MIT",
  "dependencies": {
    "near-api-js": "^2.0.4",
    "mintbase": "^0.8.5-rc.2",
    "@mintbase-js/sdk": "^0.2.0-beta.0",
    "uuid": "^9.0.0"
  }
}

'''
'''--- puzzletaskHelpers.ts ---
import {
  DEPOSIT_FOR_BURN,
  DEPOSIT_FOR_PERMIT_REQUEST,
  DEPOSIT_FOR_TRANSFER,
  GAS,
  STORAGE_BYTES,
  STORAGE_PRICE_PER_BYTE_EXPONENT,
  CONTRACT_METHOD_NAMES,
} from "./constants";
import { Contract } from "near-api-js";
import type { NearContractCall, TokenMetadata } from "@mintbase-js/sdk";
import { v4 as uuid } from "uuid";

type mintUserBoundNFTArgs = {
  contractAddress: string;
  receiverId: string;
  metadata: TokenMetadata;
  userId: string;
};

type mintUserBoundNFTArgsResponse = {
  receiver_id: string;
  token_id: string;
  metadata: TokenMetadata;
};

type transferUserBoundNFTArgs = {
  contractAddress: string;
  receiverId: string;
  tokenId: string;
};

type transferUserBoundNFTArgsResponse = {
  receiver_id: string;
  token_id: string;
};

type burnUserBoundNFTArgs = {
  contractAddress: string;
  tokenId: string;
};

type burnUserBoundNFTArgsResponse = {
  token_id: string;
};

type permitRequestArgs = {
  contractAddress: string;
  userId: string;
};

type permitRequestArgsResponse = {
  user_id: string;
};

type getUserNFTsArgs = {
  nearContract: Contract | any;
  userId: string;
};

type getUserPermitArgs = {
  nearContract: Contract | any;
  userId: string;
};

function mintingDeposit({ metadata }: { metadata: TokenMetadata }): string {
  const bytesPerToken = STORAGE_BYTES.TOKEN_BASE * STORAGE_BYTES.COMMON;
  const metadataBytesEstimate = JSON.stringify(metadata).length;

  const totalBytes =
    STORAGE_BYTES.MINTING_BASE +
    STORAGE_BYTES.MINTING_FEE +
    metadataBytesEstimate +
    bytesPerToken +
    STORAGE_BYTES.COMMON;

  return `${Math.ceil(totalBytes)}${"0".repeat(
    STORAGE_PRICE_PER_BYTE_EXPONENT
  )}`;
}

export const mintUserBoundNFT = function (
  args: mintUserBoundNFTArgs
): NearContractCall<mintUserBoundNFTArgsResponse> {
  const { contractAddress, receiverId, metadata, userId } = args;
  metadata["extra"] = JSON.stringify({
    user_id: userId,
  });
  return {
    contractAddress: contractAddress,
    args: {
      receiver_id: receiverId,
      token_id: uuid(),
      metadata: metadata,
    },
    methodName: CONTRACT_METHOD_NAMES.MINT,
    gas: GAS,
    deposit: mintingDeposit({ metadata }),
  };
};

export const transferUserBoundNFT = function (
  args: transferUserBoundNFTArgs
): NearContractCall<transferUserBoundNFTArgsResponse> {
  const { contractAddress, receiverId, tokenId } = args;
  return {
    contractAddress: contractAddress,
    args: {
      receiver_id: receiverId,
      token_id: tokenId,
    },
    methodName: CONTRACT_METHOD_NAMES.TRANSFER,
    gas: GAS,
    deposit: DEPOSIT_FOR_TRANSFER,
  };
};

export const burnUserBoundNFT = function (
  args: burnUserBoundNFTArgs
): NearContractCall<burnUserBoundNFTArgsResponse> {
  const { contractAddress, tokenId } = args;
  return {
    contractAddress: contractAddress,
    args: {
      token_id: tokenId,
    },
    methodName: CONTRACT_METHOD_NAMES.BURN,
    gas: GAS,
    deposit: DEPOSIT_FOR_BURN,
  };
};

export const permitRequest = function (
  args: permitRequestArgs
): NearContractCall<permitRequestArgsResponse> {
  const { contractAddress, userId } = args;
  return {
    contractAddress: contractAddress,
    args: {
      user_id: userId,
    },
    methodName: CONTRACT_METHOD_NAMES.PERMIT_REQUEST,
    gas: GAS,
    deposit: DEPOSIT_FOR_PERMIT_REQUEST,
  };
};

export const getUserNFTs = async function (
  args: getUserNFTsArgs
): Promise<Array<any>> {
  /*
  We used the near-api-js for this call because
  we couldn't find a way to make call without
  signing them through @mintbase-js/sdk
  */
  const response = await args.nearContract
    .nft_tokens_for_user({
      user_id: args.userId,
    })
    .catch((e: any) => {
      alert(e);
    });
  return response;
};

export const getUserPermit = async function (
  args: getUserPermitArgs
): Promise<Array<any>> {
  /*
  We used the near-api-js for this call because
  we couldn't find a way to make call without
  signing them through @mintbase-js/sdk
  */
  const response = await args.nearContract
    .permit_for_user({
      user_id: args.userId,
    })
    .catch((e: any) => {
      alert(e);
    });
  return response;
};

'''