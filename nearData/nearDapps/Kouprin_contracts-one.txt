*GitHub Repository "Kouprin/contracts-one"*

'''--- README.md ---
# TBD

'''
'''--- cli/index.js ---
#!/usr/bin/env node
const { program } = require('commander')
const bs58 = require('bs58')
const crypto = require('crypto')
const fs = require('fs')
const path = require('path')
const tar = require('tar')
const realZlibConstants = require('zlib').constants

const { nearContractView } = require('./near')

program.version(require('./package.json').version)

program
  .command('pack <path-to-project> <filename>')
  .description('pack the contract source code to the proper bs58-encoded .tar.gz archive')
  .action((sourceCodePath, filename) => {
    tar.c(
      {
        gzip: { level: realZlibConstants.Z_BEST_COMPRESSION, strategy: realZlibConstants.Z_DEFAULT_STRATEGY },
        file: path.resolve(filename + '.tar.gz'),
        C: path.normalize(sourceCodePath),
        filter: function (name) {
          const pathResolved = path.resolve(sourceCodePath, name)
          const isDir = fs.lstatSync(pathResolved).isDirectory()
          const base = path.basename(pathResolved)
          const ext = path.extname(pathResolved)
          const process = (isDir && base !== 'target' && base !== 'res') || base === 'Cargo.lock' || base === 'Cargo.toml' || ext === '.rs'
          if (process) {
            console.log(base, 'processing...')
          }
          return process
        }
      },
      // TODO replace with actual files to remove './' prefixes from tar
      ['.']
    ).then(_ => {
      const bytes = fs.readFileSync(path.resolve(filename + '.tar.gz'))
      // TODO use base64 encoding
      console.log('bs58 encoding...')
      const bs58encoded = bs58.encode(bytes)
      fs.writeFileSync(filename, bs58encoded)
      fs.unlinkSync(path.resolve(filename + '.tar.gz'))
      console.log('done')
    })
  })

program
  .command('unpack <filename>')
  .description('unpack the contract source code from the bs58-encoded .tar.gz archive')
  .action((filename) => {
    const bytes = fs.readFileSync(filename)
    console.log('bs58 decoding...')
    const bs58decoded = bs58.decode(bytes.toString())
    fs.writeFileSync(path.resolve(filename + '.tar.gz'), bs58decoded)
    console.log('files extracting...')
    tar.x(
      {
        file: path.resolve(filename + '.tar.gz')
      }
    ).then(_ => {
      fs.unlinkSync(path.resolve(filename + '.tar.gz'))
      console.log('done')
    })
  })

program
  .command('hash <wasm-file>')
  .description('get code_hash from the compiled wasm file')
  .action((wasmFile) => {
    const bytes = fs.readFileSync(wasmFile)
    const hash = crypto.createHash('sha256').update(bytes).digest('hex')
    const bs58encoded = bs58.encode(Buffer.from(hash, 'hex'))
    console.log(bs58encoded)
  })

const nearCommand = program
  .command('near [options]')
  .description('operations with NEAR blockchain')

nearCommand
  .command('source <code-hash> <filename>')
  .description('download source code of the contract by given hash as the file')
  .action(async (codeHash, filename) => {
    // TODO use env variable
    const env = 'testnet'
    const contract = await nearContractView(env)
    console.log(contract)
    const response = await contract.get_contract_source_code({ contract_hash: codeHash })
    fs.writeFileSync(filename, response)
    console.log('done')
  })

;(async () => {
  await program.parseAsync(process.argv)
})()

'''
'''--- cli/near.js ---
const nearAPI = require('near-api-js')

function getConfig (env) {
  switch (env) {
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        // TODO
        contractName: '',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      }
    case '':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: 'dev-1618917933127-5935675',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        keyStore: []
      }
  }
}

async function nearContractView (env) {
  const config = getConfig(env)
  const near = await nearAPI.connect(config)
  const account = await near.account(config.contractName)
  return new nearAPI.Contract(
    account,
    config.contractName, {
      viewMethods: ['get_contract_source_code'],
      changeMethods: []
    })
}

module.exports = {
  getConfig,
  nearContractView,
  nearAPI
}

'''
'''--- cli/package.json ---
{
  "name": "contracts-one-cli",
  "version": "1.0.0",
  "author": "Alex Kouprin <kpr@near.org>",
  "description": "CLI for developers and auditors",
  "main": "index.js",
  "bin": {
    "contracts-one": "./index.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kouprin/contracts-one.git"
  },
  "license": "MIT",
  "keywords": [
    "nearprotocol",
    "decentralized",
    "blockchain"
  ],
  "dependencies": {
    "bs58": "^4.0.1",
    "commander": "^5.1.0",
    "near-api-js": "^0.39.0",
    "tar": "^6.1.0"
  }
}

'''
'''--- contract/Cargo.toml ---
[package]
name = "contracts-one"
version = "0.1.0"
authors = ["Alex Kouprin <kpr@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
# TODO use released sdk
#near-sdk = { path = "../../near-sdk-rs/near-sdk", version = "=3.0.0-pre.3" }
near-sdk = "=3.1.0"
regex = "1"

[dev-dependencies]
# TODO use released sdk-sim when available
#near-sdk-sim = { path = "../../near-sdk-rs/near-sdk-sim", version = "=3.0.0-pre.3" }
near-sdk-sim = "=3.1.0"
#near-sdk-sim = { git = "https://github.com/near/near-sdk-rs.git", tag="3.1.0" }

[features]
expensive_tests = []

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
RUSTFLAGS='-C link-arg=-s' cargo +nightly build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/contracts_one.wasm ./res/

'''
'''--- contract/compile_and_test.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
RUSTFLAGS='-C link-arg=-s' cargo +nightly build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/contracts_one.wasm ./res/
RUSTFLAGS='-C link-arg=-s' cargo +nightly test --all -- --nocapture

'''
'''--- contract/expensive.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
RUSTFLAGS='-C link-arg=-s' cargo +nightly build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/contracts_one.wasm ./res/
RUSTFLAGS='-C link-arg=-s' cargo +nightly test --all --features=expensive_tests -- --nocapture

'''
'''--- contract/src/audit.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Audit {
    pub publisher: UserId,

    pub auditor_url: Url,
    pub report_url: Url,
    pub summary: String,
    pub date: Timestamp,
}

impl Audit {
    pub(crate) fn id(&self) -> AuditId {
        env::sha256(self.report_url.as_bytes()).try_into().unwrap()
    }
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AuditView {
    pub audit_id: Base58CryptoHash,

    pub publisher: AccountId,

    pub auditor_url: String,
    pub report_url: String,
    pub summary: String,
    pub date: WrappedTimestamp,
}

impl From<&Audit> for AuditView {
    fn from(a: &Audit) -> Self {
        Self {
            audit_id: a.id().into(),
            publisher: a.publisher.clone(),
            auditor_url: a.auditor_url.clone(),
            report_url: a.report_url.clone(),
            summary: a.summary.clone(),
            date: a.date.into(),
        }
    }
}

#[near_bindgen]
impl Main {
    pub fn get_audit(&self, audit_id: AuditId) -> Option<AuditView> {
        Self::audits().get(&audit_id).map(|a| (&a).into())
    }

    #[payable]
    pub fn submit_audit(
        &mut self,
        contract_hash: Base58CryptoHash,
        auditor_url: String,
        report_url: String,
        summary: String,
        date: WrappedTimestamp,
    ) -> bool {
        Self::assert_deposit(SUBMIT_AUDIT_DEPOSIT);
        Self::assert_text_len(&auditor_url);
        Self::assert_text_len(&report_url);
        Self::assert_text_len(&summary);
        let mut audits = Self::audits();
        let audit = Audit {
            publisher: env::predecessor_account_id(),
            auditor_url,
            report_url,
            summary,
            date: date.into(),
        };
        assert!(audits.insert(&audit.id(), &audit).is_none());

        let mut contract = self.contracts.get(&contract_hash.into()).unwrap();
        self.assert_council_or_project_owner(&contract.project_name);
        assert!(contract.audits.insert(&audit.id()));

        true
    }
}

'''
'''--- contract/src/certificate.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Certificate {
    pub issuer: UserId,
    pub issue_time: Timestamp,

    pub is_hash_valid: Option<bool>,
    pub is_audit_accepted: Option<bool>,
    pub is_code_approved: Option<bool>,
    pub is_standards_confirmed: Option<bool>,

    pub details: String,
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct CertificateView {
    pub issuer: AccountId,
    pub issue_time: WrappedTimestamp,

    pub is_hash_valid: Option<bool>,
    pub is_audit_accepted: Option<bool>,
    pub is_code_approved: Option<bool>,
    pub is_standards_confirmed: Option<bool>,

    pub details: String,
}

impl From<&Certificate> for CertificateView {
    fn from(c: &Certificate) -> Self {
        Self {
            issuer: c.issuer.clone(),
            issue_time: c.issue_time.into(),
            is_hash_valid: c.is_hash_valid,
            is_audit_accepted: c.is_audit_accepted,
            is_code_approved: c.is_code_approved,
            is_standards_confirmed: c.is_standards_confirmed,
            details: c.details.clone(),
        }
    }
}

#[near_bindgen]
impl Main {
    #[payable]
    pub fn certify_contract(
        &mut self,
        contract_hash: Base58CryptoHash,
        is_hash_valid: Option<bool>,
        is_audit_accepted: Option<bool>,
        is_code_approved: Option<bool>,
        is_standards_confirmed: Option<bool>,
        details: String,
    ) -> bool {
        Self::assert_one_yocto();
        Self::assert_council();
        Self::assert_text_len(&details);
        if is_hash_valid.is_none()
            && is_audit_accepted.is_none()
            && is_code_approved.is_none()
            && is_standards_confirmed.is_none()
            && details.len() == 0
        {
            // Empty certificate
            assert!(false, "{}", ERR_EMPTY_CERTIFICATE);
        }

        let mut contract = self.contracts.get(&contract_hash.into()).unwrap();
        contract.certificates.insert(&Certificate {
            issuer: env::predecessor_account_id(),
            issue_time: env::block_timestamp(),
            is_hash_valid,
            is_audit_accepted,
            is_code_approved,
            is_standards_confirmed,
            details,
        });
        self.contracts.insert(&contract_hash.into(), &contract);

        true
    }
}

'''
'''--- contract/src/contract.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pub hash: ContractHash,

    pub project_name: String,
    pub contract_name: String,

    pub version: Version,
    pub published_time: Timestamp,

    // Cargo.toml + Cargo.lock + src folder?
    // Full marketplace contract + tests took 30k, 0.3 NEAR
    pub source_code_archived: Option<String>,
    pub commit_hash: String,

    pub publisher: UserId,

    pub standards_declared: UnorderedSet<Standard>,

    pub audits: UnorderedSet<AuditId>,

    pub certificates: UnorderedSet<Certificate>,
}

impl Contract {
    pub(crate) fn get_safety_report(&self) -> SafetyReport {
        if self.source_code_archived.is_none() {
            return SafetyReport::new (0, vec![SAFETY_REPORT_NO_SOURCE_CODE]);
        }
        let mut safety_level = 3;
        let mut issues = vec![];
        if self.audits.is_empty() {
            safety_level = min(safety_level, 2);
            issues.push(SAFETY_REPORT_NO_AUDITS);
        }

        if self.certificates.is_empty() {
            safety_level = min(safety_level, 1);
            issues.push(SAFETY_REPORT_NO_CERTIFICATES);
        } else {
            // TODO implement certificates analyses
        }

        return SafetyReport::new (safety_level , issues );
    }
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractView {
    pub hash: Base58CryptoHash,

    pub project_name: String,
    pub contract_name: String,

    pub version: String,
    pub published_time: WrappedTimestamp,

    pub source_code_size: u64,
    pub commit_hash: String,

    pub publisher: UserId,

    pub standards_declared: Vec<Standard>,

    pub audits: Vec<AuditId>,

    pub certificates: Vec<CertificateView>,

    pub safety_report: SafetyReport,
}

impl From<&Contract> for ContractView {
    fn from(c: &Contract) -> Self {
        Self {
            hash: c.hash.into(),
            project_name: c.project_name.clone(),
            contract_name: c.contract_name.clone(),
            version: (&c.version).into(),
            published_time: c.published_time.into(),
            source_code_size: c
                .source_code_archived
                .as_ref()
                .map(|s| s.len() as u64)
                .unwrap_or(0),
            commit_hash: c.commit_hash.clone(),
            publisher: c.publisher.clone(),
            standards_declared: c.standards_declared.to_vec(),
            audits: c.audits.to_vec(),
            certificates: c.certificates.iter().map(|c| (&c).into()).collect(),
            safety_report: c.get_safety_report()
        }
    }
}

#[near_bindgen]
impl Main {
    pub fn get_contract(&self, contract_hash: Base58CryptoHash) -> Option<ContractView> {
        self.contracts
            .get(&contract_hash.into())
            .map(|c| (&c).into())
    }

    pub fn get_contract_source_code(&self, contract_hash: Base58CryptoHash) -> Option<String> {
        self.contracts
            .get(&contract_hash.into())
            .map(|c| c.source_code_archived)
            .unwrap_or(None)
    }

    #[payable]
    pub fn register_contract(
        &mut self,
        project_name: String,
        contract_name: String,
        contract_hash: Base58CryptoHash,
        version: String,
        commit_hash: String,
        standards_declared: Vec<Standard>,
    ) -> bool {
        Self::assert_deposit(REGISTER_CONTRACT_DEPOSIT);
        Self::assert_text_len(&project_name);
        Self::assert_text_len(&contract_name);
        Self::assert_text_len(&commit_hash);
        Self::assert_vec_len(&standards_declared);

        let version: Version = (&version).into(); // asserts if version is valid
        let mut project = self.extract_project_by_name_or_panic(&project_name);
        assert!(project.owners.contains(&env::predecessor_account_id()));

        let mut prefix = Vec::with_capacity(33);
        prefix.push(b'k');
        prefix.extend(&ContractHash::from(contract_hash));
        let mut standards_declared_set = UnorderedSet::new(prefix);
        standards_declared_set.extend(standards_declared.into_iter());

        let mut prefix2 = Vec::with_capacity(33);
        prefix2.push(b'l');
        prefix2.extend(&ContractHash::from(contract_hash));

        let mut prefix3 = Vec::with_capacity(33);
        prefix3.push(b'm');
        prefix3.extend(&ContractHash::from(contract_hash));

        let contract = Contract {
            hash: contract_hash.into(),
            project_name: project_name.clone(),
            contract_name,
            version: version.clone(),
            published_time: env::block_timestamp(),
            source_code_archived: None,
            commit_hash,
            publisher: env::predecessor_account_id(),
            standards_declared: standards_declared_set,
            audits: UnorderedSet::new(prefix2),
            certificates: UnorderedSet::new(prefix3),
        };

        assert!(self
            .contracts
            .insert(&contract_hash.into(), &contract)
            .is_none());
        assert!(project
            .contracts
            .insert(&version, &contract_hash.into())
            .is_none());
        self.save_project_by_name_or_panic(&project_name, &project);

        true
    }

    #[payable]
    pub fn upload_source_code(
        &mut self,
        contract_hash: Base58CryptoHash,
        source_code_archived: String,
    ) -> bool {
        let mut contract = self.contracts.get(&contract_hash.into()).unwrap();
        if contract.source_code_archived.is_some() {
            Self::assert_council();
            Self::assert_one_yocto();
        } else {
            self.assert_council_or_project_owner(&contract.project_name);
            Self::assert_deposit(source_code_archived.len() as Balance * PRICE_PER_BYTE);
        }
        contract.source_code_archived = Some(source_code_archived);
        self.contracts.insert(&contract_hash.into(), &contract);

        true
    }
}
'''
'''--- contract/src/lib.rs ---
use regex::Regex;
use std::cmp::min;
use std::convert::TryInto;

mod audit;
mod certificate;
mod contract;
mod primitives;
mod project;
mod user;
mod version;

pub use crate::audit::*;
pub use crate::certificate::*;
pub use crate::contract::*;
pub use crate::primitives::*;
pub use crate::project::*;
pub use crate::user::*;
pub use crate::version::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, LookupSet, TreeMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base58CryptoHash, ValidAccountId, WrappedTimestamp};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, CryptoHash, PanicOnDefault, Timestamp};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Main {
    pub projects: UnorderedMap<ProjectId, Project>,
    pub contracts: TreeMap<ContractHash, Contract>,
    // users: LookupMap<UserId, User>,
    // audits: LookupMap<AuditId, Audit>,
    // council: LookupSet<UserId>,
}

#[near_bindgen]
impl Main {
    #[init]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let mut main = Self {
            projects: UnorderedMap::new(b"a".to_vec()),
            contracts: TreeMap::new(b"b".to_vec()),
        };

        let mut user = main.extract_user_or_create(&env::signer_account_id());
        user.is_council = true;
        main.save_user_or_panic(&env::signer_account_id(), &user);
        assert!(Self::council().insert(&env::signer_account_id()));

        main
    }
}

impl Main {
    pub(crate) fn users() -> LookupMap<UserId, User> {
        LookupMap::new(b"c".to_vec())
    }

    pub(crate) fn audits() -> LookupMap<AuditId, Audit> {
        LookupMap::new(b"d".to_vec())
    }

    pub(crate) fn council() -> LookupSet<UserId> {
        LookupSet::new(b"e".to_vec())
    }

    pub(crate) fn is_council() -> bool {
        Self::council().contains(&env::predecessor_account_id())
    }

    pub(crate) fn assert_deposit(required_deposit: Balance) {
        assert!(
            env::attached_deposit() >= required_deposit,
            "{}: required {}, received {}",
            ERR_DEPOSIT_NOT_ENOUGH,
            required_deposit,
            env::attached_deposit()
        )
    }

    pub(crate) fn assert_one_yocto() {
        assert_eq!(env::attached_deposit(), 1, "Must be 1 yocto")
    }

    pub(crate) fn assert_council() {
        assert!(
            Self::is_council(),
            "{}: account {}",
            ERR_COUNCIL,
            env::predecessor_account_id()
        )
    }

    pub(crate) fn assert_text_len(text: &String) {
        assert!(
            text.len() < MAX_TEXT_LENGTH,
            "{}: length of {} is {}, max allowed length is {}",
            ERR_TEXT_TOO_LONG,
            text,
            text.len(),
            MAX_TEXT_LENGTH,
        )
    }

    pub(crate) fn assert_vec_len<T>(vec: &Vec<T>) {
        assert!(
            vec.len() < MAX_VEC_LENGTH,
            "{}: length of vector is {}, max allowed length is {}",
            ERR_VEC_TOO_LONG,
            vec.len(),
            MAX_VEC_LENGTH,
        )
    }

    pub(crate) fn assert_council_or_project_owner(&self, project_name: &String) {
        assert!(
            Self::is_council()
                || self
                    .projects
                    .get(&Project::get_id(project_name))
                    .unwrap()
                    .owners
                    .contains(&env::predecessor_account_id()),
            "{}: account {}",
            ERR_COUNCIL_OR_PROJECT_OWNER,
            env::predecessor_account_id()
        )
    }
}

'''
'''--- contract/src/primitives.rs ---
use crate::*;

pub const ERR_DEPOSIT_NOT_ENOUGH: &str = "Attached deposit is not enough";
pub const ERR_COUNCIL: &str = "Only council can do this operation";
pub const ERR_COUNCIL_OR_PROJECT_OWNER: &str =
    "Only project owner or council can do this operation";
pub const ERR_PROJECT_NAME_INVALID: &str = "Project name is invalid";
pub const ERR_INVALID_REPORT_URL: &str = "Report cannot be used more than once";
pub const ERR_ALREADY_EXISTS: &str = "Already exists";
pub const ERR_ACCESS_DENIED: &str = "Caller is not allowed to do this operation";
pub const ERR_EMPTY_CERTIFICATE: &str = "Nothing to certify";
pub const ERR_PROJECT_CREATOR_IS_NOT_OWNER: &str =
    "Project creator is not in list of project owners";
pub const ERR_TEXT_TOO_LONG: &str = "Text is too long";
pub const ERR_VEC_TOO_LONG: &str = "Vector is too long";
pub const ERR_INVALID_SCORE: &str = "The score is invalid";

pub const REGISTER_PROJECT_DEPOSIT: Balance = 1_000_000_000_000_000_000_000_000; // 1 NEAR
pub const REGISTER_CONTRACT_DEPOSIT: Balance = 100_000_000_000_000_000_000_000; // 0.1 NEAR
pub const CREATE_USER_DEPOSIT: Balance = 10_000_000_000_000_000_000_000; // 0.01 NEAR
pub const SUBMIT_AUDIT_DEPOSIT: Balance = 100_000_000_000_000_000_000_000; // 0.1 NEAR
pub const MAX_TEXT_LENGTH: usize = 1000;
pub const MAX_VEC_LENGTH: usize = 16;
pub const PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;

pub type AuditId = CryptoHash;
// pub type ContractId = (ProjectId, Version); - unused
pub type ContractHash = CryptoHash;
pub type ProjectId = CryptoHash;
pub type Standard = String;
pub type Url = String;
pub type UserId = AccountId;

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct SafetyReport {
    pub safety_level: String,
    pub safety_issues: Vec<String>,
}

pub const SAFETY_LEVEL_CRITICAL: &str = "Dangerous";
pub const SAFETY_LEVEL_LOW: &str = "Low";
pub const SAFETY_LEVEL_MODERATE: &str = "Moderate";
pub const SAFETY_LEVEL_HIGH: &str = "High";

pub const SAFETY_REPORT_NO_SOURCE_CODE: &str = "No source code uploaded. Don't trust.";
pub const SAFETY_REPORT_NO_AUDITS: &str = "The contract hasn't been audited.";
pub const SAFETY_REPORT_NO_CERTIFICATES: &str = "The contract hasn't been certified by NEAR council.";

impl SafetyReport {
    pub fn new(safety_level_num: u64, safety_issues: Vec<&str>) -> Self {
        let safety_level = match safety_level_num {
            1 => SAFETY_LEVEL_LOW,
            2 => SAFETY_LEVEL_MODERATE,
            3 => SAFETY_LEVEL_HIGH,
            _ => SAFETY_LEVEL_CRITICAL,
        }.to_string();
        Self {
            safety_level,
            safety_issues: safety_issues.iter().map(|&s| s.into()).collect(),
        }
    }
}

'''
'''--- contract/src/project.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Project {
    pub project_name: String,
    pub description: String,
    pub url: String,

    pub owners: UnorderedSet<AccountId>,

    pub contracts: TreeMap<Version, ContractHash>,
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ProjectView {
    pub project_id: Base58CryptoHash,

    pub project_name: String,
    pub description: String,
    pub url: String,

    pub owners: Vec<AccountId>,

    pub contracts: Vec<ContractView>,

    pub last_version: Option<String>,
}

impl From<(&Project, &Main)> for ProjectView {
    fn from(p: (&Project, &Main)) -> Self {
        Self {
            project_id: Project::get_id(&p.0.project_name).into(),
            project_name: p.0.project_name.clone(),
            description: p.0.description.clone(),
            url: p.0.url.clone(),
            owners: p.0.owners.to_vec(),
            contracts: p
                .0
                .contracts
                .iter()
                .map(|(_, c)| (&p.1.contracts.get(&c).unwrap()).into())
                .collect(),
            last_version: p
                .1
                .view_last_contract(p.0)
                .map_or(None, |c| Some((&c.version).into())),
        }
    }
}

impl Project {
    pub(crate) fn get_id(project_name: &String) -> ProjectId {
        env::sha256(project_name.as_bytes())
            .as_slice()
            .try_into()
            .unwrap()
    }
}

#[near_bindgen]
impl Main {
    pub fn get_project(&self, project_name: String) -> Option<ProjectView> {
        self.projects
            .get(&Project::get_id(&project_name))
            .map(|p| (&p, self).into())
    }

    pub fn get_all_projects(&self, from: u64, to: u64) -> Vec<ProjectView> {
        let from = min(from, self.projects.len());
        let to = min(to, self.projects.len());
        let mut res = vec![];
        for i in from..to {
            // values_as_vector() should work for O(1)
            res.push((&self.projects.values_as_vector().get(i).unwrap(), self).into())
        }
        res
    }

    pub fn get_project_last_contract(&self, project_name: String) -> Option<ContractView> {
        self.view_last_contract(&self.projects.get(&Project::get_id(&project_name)).unwrap())
            .map(|c| (&c).into())
    }

    #[payable]
    pub fn register_project(
        &mut self,
        project_name: String,
        description: String,
        url: String,
        owners: Vec<ValidAccountId>,
    ) -> bool {
        Self::assert_deposit(REGISTER_PROJECT_DEPOSIT);
        assert!(
            project_name.len() > 0 && project_name.len() <= 64,
            "{}",
            ERR_PROJECT_NAME_INVALID
        );
        let re = Regex::new(r"^(([A-Z|a-z|0-9]+[\-_\.])*[A-Z|a-z|0-9]+)$").unwrap();
        assert!(re.is_match(&project_name), "{}", ERR_PROJECT_NAME_INVALID);
        Self::assert_text_len(&description);
        Self::assert_text_len(&url);
        Self::assert_vec_len(&owners);

        let project_id = Project::get_id(&project_name);
        let mut is_predecessor_found = false;
        for user_id in owners.iter() {
            if user_id.as_ref() == &env::predecessor_account_id() {
                is_predecessor_found = true;
            }
            let mut user = self.extract_user_or_create(user_id.as_ref());
            user.projects_owned.insert(&project_id);
            self.save_user_or_panic(user_id.as_ref(), &user);
        }
        assert!(is_predecessor_found, "{}", ERR_PROJECT_CREATOR_IS_NOT_OWNER);

        let mut prefix = Vec::with_capacity(33);
        prefix.push(b'x');
        prefix.extend(&project_id);
        let mut owners_set = UnorderedSet::new(prefix);
        owners_set.extend(owners.into_iter().map(|o| o.into()));

        let mut prefix2 = Vec::with_capacity(33);
        prefix2.push(b'y');
        prefix2.extend(&project_id);

        assert!(
            self.projects
                .insert(
                    &project_id,
                    &Project {
                        project_name,
                        description,
                        url,
                        owners: owners_set,
                        contracts: TreeMap::new(prefix2),
                    }
                )
                .is_none(),
            "{}",
            ERR_ALREADY_EXISTS
        );

        true
    }
}

impl Main {
    pub(crate) fn view_last_contract(&self, project: &Project) -> Option<Contract> {
        if project.contracts.len() == 0 {
            return None;
        }
        self.contracts
            .get(&project.contracts.iter_rev().next().map(|(_, c)| c).unwrap())
    }

    pub(crate) fn extract_project_or_panic(&mut self, project_id: &ProjectId) -> Project {
        self.projects.remove(project_id).unwrap()
    }

    pub(crate) fn extract_project_by_name_or_panic(&mut self, project_name: &String) -> Project {
        self.extract_project_or_panic(&Project::get_id(project_name))
    }

    pub(crate) fn save_project_or_panic(&mut self, project_id: &ProjectId, project: &Project) {
        assert!(self.projects.insert(project_id, project).is_none())
    }

    pub(crate) fn save_project_by_name_or_panic(
        &mut self,
        project_name: &String,
        project: &Project,
    ) {
        self.save_project_or_panic(&Project::get_id(project_name), project)
    }
}

'''
'''--- contract/src/user.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct User {
    pub projects_owned: UnorderedSet<ProjectId>,

    pub is_council: bool,
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct UserView {
    pub projects_owned: Vec<Base58CryptoHash>,

    pub is_council: bool,
}

impl From<&User> for UserView {
    fn from(u: &User) -> Self {
        Self {
            projects_owned: u.projects_owned.iter().map(|id| id.into()).collect(),
            is_council: u.is_council,
        }
    }
}

#[near_bindgen]
impl Main {
    pub fn get_user(&self, user_id: ValidAccountId) -> Option<UserView> {
        Self::users().get(user_id.as_ref()).map(|u| (&u).into())
    }

    #[payable]
    pub fn create_user(&mut self, user_id: ValidAccountId) -> bool {
        Self::assert_deposit(CREATE_USER_DEPOSIT);
        assert!(
            Self::users().get(user_id.as_ref()).is_none(),
            "{}",
            ERR_ALREADY_EXISTS
        );
        let user = self.extract_user_or_create(user_id.as_ref());
        self.save_user_or_panic(user_id.as_ref(), &user);

        true
    }

    #[payable]
    pub fn register_council(&mut self, user_id: ValidAccountId) -> bool {
        Self::assert_council();
        Self::assert_one_yocto();
        let mut user = self.extract_user_or_create(user_id.as_ref());
        user.is_council = true;
        self.save_user_or_panic(user_id.as_ref(), &user);
        assert!(Self::council().insert(user_id.as_ref()));

        true
    }
}

impl Main {
    pub(crate) fn extract_user_or_create(&mut self, user_id: &UserId) -> User {
        Self::users().remove(&user_id).unwrap_or_else(|| {
            let mut prefix = Vec::with_capacity(33);
            prefix.push(b'u');
            prefix.extend(env::sha256(&user_id.as_bytes()));

            User {
                projects_owned: UnorderedSet::new(prefix),
                is_council: false,
            }
        })
    }

    pub(crate) fn save_user_or_panic(&mut self, user_id: &UserId, user: &User) {
        assert!(Self::users().insert(user_id, user).is_none());
    }
}

'''
'''--- contract/src/version.rs ---
use regex::Regex;
use std::cmp::Ordering;

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub struct Version {
    pub major: u64,
    pub minor: u64,
    pub patch: u64,
}

impl From<&Version> for String {
    fn from(v: &Version) -> Self {
        format!("{}.{}.{}", v.major, v.minor, v.patch)
    }
}

impl From<&String> for Version {
    fn from(s: &String) -> Self {
        let re = Regex::new(r"^([1-9]+[0-9]*{1,6}|0).([1-9]+[0-9]*{1,6}|0).([1-9]+[0-9]*{1,8}|0)$")
            .unwrap();
        let captures = re.captures(&s).unwrap();
        assert_eq!(captures.len(), 4);
        Version {
            major: captures[1].parse::<u64>().unwrap(),
            minor: captures[2].parse::<u64>().unwrap(),
            patch: captures[3].parse::<u64>().unwrap(),
        }
    }
}

impl Ord for Version {
    fn cmp(&self, other: &Self) -> Ordering {
        (self.major, self.minor, self.patch).cmp(&(other.major, other.minor, other.patch))
    }
}

impl PartialOrd for Version {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for Version {
    fn eq(&self, other: &Self) -> bool {
        (self.major, self.minor, self.patch) == (other.major, other.minor, other.patch)
    }
}

impl Eq for Version {}

'''
'''--- contract/tests/general.rs ---
use std::collections::HashMap;
use std::convert::TryInto;

/// Import the generated proxy contract
use contracts_one::MainContract;
use contracts_one::{
    ContractView, ProjectView, UserView, CREATE_USER_DEPOSIT, ERR_PROJECT_NAME_INVALID,
    REGISTER_CONTRACT_DEPOSIT, REGISTER_PROJECT_DEPOSIT, SUBMIT_AUDIT_DEPOSIT,
};

use near_sdk::json_types::Base58CryptoHash;
use near_sdk::Timestamp;
use near_sdk_sim::{call, deploy, init_simulator, to_yocto, view, ContractAccount, UserAccount};

// Load in contract bytes at runtime
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
  CONTRACT_WASM_BYTES => "res/contracts_one.wasm",
}

const CONTRACT_ID: &str = "contracts_one";

const ERR_ASSERT: Option<&str> = Some("assertion failed");
const ERR_UNWRAP: Option<&str> = Some("called `Option::unwrap()`");

const DEFAULT_PROJECT_ID: &str = "Test_Project_111";
const DEFAULT_CONTRACT_HASH: &str = "FtPgYqXzhGhcsB4rMt8ji5krAQuoDWamLgtUqYMLKnP3";
const DEFAULT_URL: &str = "near.org";
const DEFAULT_VERSION: &str = "1.2.3";
const DEFAULT_STANDARDS_DECLARED: Vec<String> = vec![];
const ALICE: &str = "alice";
const BOB: &str = "bob";
#[allow(dead_code)]
const CAROL: &str = "carol";
const DEFAULT_PROJECT_OWNERS: &[&'static str; 3] = &["root", ALICE, BOB];

struct State {
    pub root: UserAccount,
    pub contract: ContractAccount<MainContract>,
    pub accounts: HashMap<String, UserAccount>,
}

impl State {
    pub fn new() -> Self {
        let root = init_simulator(None);

        let deployed_contract = deploy!(
            contract: MainContract,
            contract_id: CONTRACT_ID,
            bytes: &CONTRACT_WASM_BYTES,
            signer_account: root,
            deposit: to_yocto("1000000000"),
            init_method: new()
        );
        let state = State {
            root,
            contract: deployed_contract,
            accounts: HashMap::default(),
        };
        // Already added in new()
        // state.do_create_user(&state.root.account_id(), None);
        state
    }

    pub fn create_alice(&mut self) {
        let alice = self.root.create_user(ALICE.into(), to_yocto("1000000000"));
        self.accounts.insert(ALICE.into(), alice);
    }

    pub fn create_bob(&mut self) {
        let bob = self.root.create_user(BOB.into(), to_yocto("1000000000"));
        self.accounts.insert(BOB.into(), bob);
    }

    pub fn get_all_projects(&self) -> Vec<ProjectView> {
        let contract = &self.contract;
        let res = view!(contract.get_all_projects(0, 1000)).unwrap_json();
        res
    }

    pub fn get_contract(&self, contract_hash: &str) -> ContractView {
        let contract = &self.contract;
        let res = view!(contract.get_contract(contract_hash.try_into().unwrap())).unwrap_json();
        res
    }

    pub fn get_project(&self, project_name: &str) -> ProjectView {
        let contract = &self.contract;
        let res = view!(contract.get_project(project_name.into())).unwrap_json();
        res
    }

    pub fn get_user(&self, user_name: &str) -> Option<UserView> {
        let contract = &self.contract;
        let res = view!(contract.get_user(user_name.try_into().unwrap())).unwrap_json();
        res
    }

    pub fn do_register_project(&self, name: &str, owners: &[&str], err: Option<&str>) {
        let contract = &self.contract;

        let outcome = call!(
            self.root,
            contract.register_project(
                name.to_string(),
                "bla".to_string(),
                DEFAULT_URL.to_string(),
                owners
                    .iter()
                    .map(|o| o.to_string().try_into().unwrap())
                    .collect()
            ),
            deposit = REGISTER_PROJECT_DEPOSIT
        );
        if let Some(msg) = err {
            assert!(
                format!("{:?}", outcome.status()).contains(msg),
                "received {:?}",
                outcome.status()
            );
            assert!(!outcome.is_ok(), "Should panic");
        } else {
            outcome.assert_success();
        }
    }

    pub fn do_register_contract(
        &self,
        account_name: &str,
        project: &str,
        hash: &str,
        version: &str,
        err: Option<&str>,
    ) {
        let contract = &self.contract;
        let account = self.accounts.get(account_name).unwrap();
        let outcome = call!(
            account,
            contract.register_contract(
                project.to_string(),
                "default contract name".to_string(),
                hash.try_into().unwrap(),
                version.to_string(),
                "default sha-1".to_string(),
                DEFAULT_STANDARDS_DECLARED
            ),
            deposit = REGISTER_CONTRACT_DEPOSIT
        );
        if let Some(msg) = err {
            assert!(
                format!("{:?}", outcome.status()).contains(msg),
                "received {:?}",
                outcome.status()
            );
            assert!(!outcome.is_ok(), "Should panic");
        } else {
            outcome.assert_success();
        }
    }

    fn do_create_user(&self, account_name: &str, err: Option<&str>) {
        let contract = &self.contract;
        let outcome = call!(
            self.root,
            contract.create_user(account_name.try_into().unwrap()),
            deposit = CREATE_USER_DEPOSIT
        );
        if let Some(msg) = err {
            assert!(
                format!("{:?}", outcome.status()).contains(msg),
                "received {:?}",
                outcome.status()
            );
            assert!(!outcome.is_ok(), "Should panic");
        } else {
            outcome.assert_success();
        }
    }

    fn do_submit_audit(
        &self,
        account_name: &str,
        contract_hash: &str,
        auditor_url: &str,
        report_url: &str,
        summary: &str,
        date: Timestamp,
        err: Option<&str>,
    ) {
        let contract = &self.contract;
        let account = self.accounts.get(account_name).unwrap();
        let outcome = call!(
            account,
            contract.submit_audit(
                contract_hash.try_into().unwrap(),
                auditor_url.to_string(),
                report_url.to_string(),
                summary.to_string(),
                date.into()
            ),
            deposit = SUBMIT_AUDIT_DEPOSIT
        );
        if let Some(msg) = err {
            assert!(
                format!("{:?}", outcome.status()).contains(msg),
                "received {:?}",
                outcome.status()
            );
            assert!(!outcome.is_ok(), "Should panic");
        } else {
            outcome.assert_success();
        }
    }

    pub fn validate(&self) {
        let projects = self.get_all_projects();
        let a = self.get_user(ALICE);
        // println!("A = {:?}", a);
        //assert_eq!(project_names.len(), 5);

        //assert!(false);
    }
}

#[test]
fn init_sanity() {
    let mut state = State::new();
    state.create_alice();

    state.validate();
}

#[test]
fn project_names() {
    let state = State::new();

    state.do_register_project("test", DEFAULT_PROJECT_OWNERS, None);
    state.do_register_project("Test_Project.123", DEFAULT_PROJECT_OWNERS, None);
    state.do_register_project(
        "Test_Project.123 ",
        DEFAULT_PROJECT_OWNERS,
        Some(ERR_PROJECT_NAME_INVALID),
    );
    state.do_register_project("", DEFAULT_PROJECT_OWNERS, Some(ERR_PROJECT_NAME_INVALID));
    state.do_register_project("0", DEFAULT_PROJECT_OWNERS, None);
    state.do_register_project("a", DEFAULT_PROJECT_OWNERS, None);
    state.do_register_project("#", DEFAULT_PROJECT_OWNERS, Some(ERR_PROJECT_NAME_INVALID));
    state.do_register_project("_", DEFAULT_PROJECT_OWNERS, Some(ERR_PROJECT_NAME_INVALID));
    state.do_register_project(&"1".repeat(64), DEFAULT_PROJECT_OWNERS, None);
    state.do_register_project(
        &"1".repeat(65),
        DEFAULT_PROJECT_OWNERS,
        Some(ERR_PROJECT_NAME_INVALID),
    );

    state.validate();
}

#[test]
fn register_project_by_not_a_user() {
    let mut state = State::new();
    state.create_alice();

    let contract = &state.contract;
    let alice = state.accounts.get(ALICE).unwrap();
    let outcome = call!(
        alice,
        contract.register_project(
            DEFAULT_PROJECT_ID.to_string(),
            "bla".to_string(),
            DEFAULT_URL.to_string(),
            DEFAULT_PROJECT_OWNERS
                .iter()
                .map(|o| o.to_string().try_into().unwrap())
                .collect()
        ),
        deposit = REGISTER_PROJECT_DEPOSIT
    );
    outcome.assert_success();
}

#[test]
fn version_sanity() {
    let mut state = State::new();
    state.create_alice();

    state.do_register_project(DEFAULT_PROJECT_ID, DEFAULT_PROJECT_OWNERS, None);
    state.do_register_contract(
        ALICE,
        DEFAULT_PROJECT_ID,
        DEFAULT_CONTRACT_HASH,
        "0.0.0",
        None,
    );
    state.do_register_contract(ALICE, DEFAULT_PROJECT_ID, &"1".repeat(32), "0.0.1", None);
    // TODO random hashes
}

#[test]
fn reproduce_1() {
    let mut state = State::new();
    state.create_alice();
    state.create_bob();

    state.do_register_project("contract.one_test", DEFAULT_PROJECT_OWNERS, None);
    state.do_register_contract(
        ALICE,
        "contract.one_test",
        "5suuACmAzbTj8oyv4bQUjuJZbRinGMAKMLorDDEFzu4a",
        "1.2.3",
        None,
    );
    let ver = &state.get_project("contract.one_test").contracts[0].version;

    state.do_register_project("contract.two_test", DEFAULT_PROJECT_OWNERS, None);
    state.do_register_project("contract.three_test", DEFAULT_PROJECT_OWNERS, None);
    state.do_register_contract(
        ALICE,
        "contract.three_test",
        "5suuACmAzbTj8oyv4bQUjuJZbRinGMAKMLorDDEFzu4b",
        "0.0.0",
        None,
    );

    assert_eq!(
        ver,
        &state.get_project("contract.one_test").contracts[0].version
    );
}

'''
'''--- frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "homepage": "https://contracts.one",
  "private": true,
  "dependencies": {
    "bootstrap": "^5.0.0-beta2",
    "collections": "^5.1.12",
    "error-polyfill": "^0.1.2",
    "moment": "^2.29.1",
    "near-api-js": "^0.37.0",
    "node-sass": "^4.0.0",
    "react": "^16.13.1",
    "react-dom": "^16.13.1",
    "react-moment": "^1.1.1",
    "react-router": "^5.2.0",
    "react-router-dom": "^5.2.0",
    "react-scripts": "^4.0.3",
    "swr": "^0.5.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "deploy": "yarn build && gh-pages -d build"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "gh-pages": "^2.2.0"
  }
}

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Contracts One"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:image" content="https://contracts.one/logo.png"/>
    <meta property="og:url" content="https://contracts.one/" />
    <meta property="og:title" content="[BETA] Contracts One" />
    <meta property="og:description" content="Contracts One" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/favicon.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>[BETA] Contracts One</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- frontend/public/manifest.json ---
{
  "short_name": "Contracts One",
  "name": "[BETA] Contracts One",
  "icons": [
    {
      "src": "favicon.png",
      "sizes": "256x256",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/App.js ---
import React from 'react'
import { HashRouter as Router, Link, Route, Switch } from 'react-router-dom'
import 'error-polyfill'
import 'bootstrap/dist/js/bootstrap.bundle'
import 'bootstrap/dist/css/bootstrap.min.css'
import './App.scss'

import * as nearAPI from 'near-api-js'

import LandingPage from './pages/Landing'
import CertificatesPage from './pages/Certificates'
import CLIPage from './pages/CLI'
import ContractPage from './pages/Contract'
import ProjectsPage from './pages/Projects'
import ProjectInfoPage from './pages/ProjectInfo'
import { ProfileStatsPage, ProfileProjectsPage, ProfileAuditsPage } from './pages/Profile'
import Logo from './images/logo.png'
import Profile from './images/profile.png'

const IsMainnet = false // TODO window.location.hostname === 'contracts.one'
const TestNearConfig = {
  accountSuffix: 'testnet',
  networkId: 'testnet',
  nodeUrl: 'https://rpc.testnet.near.org',
  contractName: 'dev-1620999790595-5106147',
  walletUrl: 'https://wallet.testnet.near.org'
}
const MainNearConfig = {
  accountSuffix: 'near',
  networkId: 'mainnet',
  nodeUrl: 'https://rpc.mainnet.near.org',
  contractName: 'c.nearbet.near',
  walletUrl: 'https://wallet.near.org'
}

const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig

class App extends React.Component {
  constructor (props) {
    super(props)

    this._near = {}

    this._near.lsKey = NearConfig.contractName + ':v01:'

    this._near.config = NearConfig

    this.state = {
      connected: false,
      account: null
    }

    this._initNear().then(() => {
      this.setState({
        signedIn: !!this._near.accountId,
        signedAccountId: this._near.accountId,
        connected: true
      })
    })
  }

  async _initNear () {
    const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore()
    const near = await nearAPI.connect(Object.assign({ deps: { keyStore } }, NearConfig))
    this._near.keyStore = keyStore
    this._near.near = near

    this._near.walletConnection = new nearAPI.WalletConnection(near, NearConfig.contractName)
    this._near.accountId = this._near.walletConnection.getAccountId()

    this._near.account = this._near.walletConnection.account()
    this._near.contract = new nearAPI.Contract(this._near.account, NearConfig.contractName, {
      viewMethods: [
        'get_user',
        'get_project',
        'get_all_projects',
        'get_project_last_contract',
        'get_contract',
        'get_contract_source_code',
        'get_audit'
      ],
      changeMethods: [
        'create_user',
        'register_project',
        'register_contract',
        'register_council',
        'submit_audit',
        'certify_contract'
      ]
    })

    this._near.logOut = () => {
      this._near.walletConnection.signOut()
      this._near.accountId = null
      this.setState({
        signedIn: !!this._accountId,
        signedAccountId: this._accountId
      })
    }

    this._near.refreshAllowance = async () => {
      alert("You're out of access key allowance. Need sign in again to refresh it")
      await this.logOut()
      await this.requestSignIn()
    }
  }

  async requestSignIn (e) {
    e && e.preventDefault()
    const appTitle = 'Contracts One'
    await this._near.walletConnection.requestSignIn(
      NearConfig.contractName,
      appTitle
    )
    return false
  }

  render () {
    const passProps = {
      _near: this._near,
      refreshAllowance: () => this._near.refreshAllowance(),
      ...this.state
    }
    const header = !this.state.connected ? (
      <div>Connecting... <span className='spinner-grow spinner-grow-sm' role='status' aria-hidden='true' /></div>
    ) : (this.state.signedIn ? (
      <div>
        <Link className='navbar-brand' to={`/profileProjects/${this.state.signedAccountId}`}>
          {this.state.signedAccountId}
          <img src={Profile} alt='Profile' className='px-2 d-inline-block align-middle' style={{ opacity: 0.85 }} />
        </Link>
      </div>
    ) : (
      <div>
        <button
          className='btn btn-primary'
          onClick={(e) => this.requestSignIn(e)}
        >Sign in with NEAR Wallet
        </button>
      </div>
    ))

    return (
      <div className='App text-white' style={{ backgroundColor: '#000000' }}>
        <Router basename={process.env.PUBLIC_URL}>
          <nav className='navbar navbar-expand-lg navbar-dark mb-3' style={{ backgroundColor: '#2F2F2F' }}>
            <div className='container-fluid'>
              <div style={{ marginLeft: '3%' }} />
              <Link className='navbar-brand' to='/' title='contracts.one'>
                <img src={Logo} alt='[BETA] Contracts One' className='d-inline-block align-middle' style={{ opacity: 1 }} />
              </Link>
              <div style={{ marginLeft: '1%' }} />
              <button
                className='navbar-toggler' type='button' data-bs-toggle='collapse'
                data-bs-target='#navbarSupportedContent' aria-controls='navbarSupportedContent'
                aria-expanded='false' aria-label='Toggle navigation'
              >
                <span className='navbar-toggler-icon' />
              </button>
              <div className='collapse navbar-collapse' id='navbarSupportedContent'>
                <ul className='navbar-nav me-auto mb-2 mb-lg-0'>
                  <li className='nav-item'>
                    <Link className='nav-link' aria-current='page' to='/'>Search</Link>
                  </li>
                  <li className='nav-item'>
                    <Link className='nav-link' aria-current='page' to='/projects'>Projects</Link>
                  </li>
                  <li className='nav-item'>
                    <Link className='nav-link' aria-current='page' to='/cli'>CLI</Link>
                  </li>
                  <li className='nav-item'>
                    <Link className='nav-link' aria-current='page' to='/cli'>New project</Link>
                  </li>
                </ul>
                <form className='d-flex'>
                  {header}
                </form>
                <div style={{ marginRight: '3%' }} />
              </div>
            </div>
          </nav>

          <Switch>
            <Route exact path='/'>
              <LandingPage {...passProps} />
            </Route>
            <Route exact path='/projects'>
              <ProjectsPage {...passProps} />
            </Route>
            <Route exact path='/projects/:page'>
              <ProjectsPage {...passProps} />
            </Route>
            <Route exact path='/cli'>
              <CLIPage {...passProps} />
            </Route>
            <Route exact path='/projectInfo/:projectName'>
              <ProjectInfoPage {...passProps} />
            </Route>
            <Route exact path='/contract/:contractHash'>
              <ContractPage {...passProps} />
            </Route>
            <Route exact path='/profileStats/:profileId'>
              <ProfileStatsPage {...passProps} />
            </Route>
            <Route exact path='/profileProjects/:profileId'>
              <ProfileProjectsPage {...passProps} />
            </Route>
            <Route exact path='/profileAudits/:profileId'>
              <ProfileAuditsPage {...passProps} />
            </Route>
          </Switch>
        </Router>
      </div>
    )
  }
}

export default App

'''
'''--- frontend/src/components/CertificateCard.js ---
import React from 'react'

import { ProfileLink, ProjectLink } from '../components/Links'
import { mapCertificateView } from '../components/Helpers'

function CertificateCard (props) {
  const data = props.data
  const certificate = mapCertificateView(data)
  const standards = certificate.standardsConfirmed.map((data, index) => {
    return (
      <div key={index} className='badge bg-success mx-1'>
        {data}
      </div>
    )
  })
  return (
    <div className='card mb-3 bg-gray' style={{ width: '100%' }}>
      <div className='card-body'>
        <div className='d-flex flex-row'>
          <h5 className='card-title pe-3'>Certificated <ProjectLink projectName={certificate.projectName} /></h5>
          <div className='card-title gray pe-3'>version {certificate.version}</div>
          <div className='card-title gray pe-3'>by <ProfileLink userName={certificate.author} /></div>
          <div className='me-auto card-title'>{standards}</div>
          <big className='pe-3 card-title'><small className='gray'>score:</small> {certificate.score}</big>
          <big className='pe-3 card-title'><small className='gray'>basic validity:</small> {certificate.basicValidityPassed ? 'passed' : 'failed'}</big>
          <big className='card-title'><small className='gray'>audit verdict:</small> {certificate.contractApproved ? 'approved' : 'refused'}</big>
        </div>
        <div className='d-flex flex-row card-text'>
          <div className='w-75'>
            <div className='card-text gray'>{certificate.summary}</div>
          </div>
          <div className='ms-auto'>
            <a href={'//' + certificate.reportUrl} className='btn btn-secondary'>Go to report</a>
          </div>
        </div>
      </div>
    </div>
  )
}

export { CertificateCard }

'''
'''--- frontend/src/components/Helpers.js ---
import React from 'react'

const NEAR = '\u24C3\u202F'

const fromNear = (s) => parseFloat(s) / 1e24 || 0

function loader () {
  return (
  // key='1' is needed by InfiniteScroll
    <div className='d-flex justify-content-center' key='1'>
      <div className='spinner-grow' role='status'>
        <span className='visually-hidden'>Loading...</span>
      </div>
    </div>
  )
}

const mapProjectView = (c) => {
  return c ? {
    id: c.project_id,
    name: c.project_name,
    description: c.description,
    url: c.url,
    owners: c.owners,
    contracts: c.contracts,
    lastVersion: c.last_version
  } : null
}

const mapCertificateView = (c) => {
  return c ? {
    projectName: c.project_name,
    version: c.version,
    author: c.author,
    reportUrl: c.report_url,
    summary: c.summary,
    standardsConfirmed: c.standards_confirmed,
    basicValidityPassed: c.basic_validity_passed,
    contractApproved: c.contract_approved,
    score: c.score
  } : null
}

const mapContract = (c) => {
  return c ? {
    audits: c.audits,
    certificates: c.certificates,
    commitHash: c.commit_hash,
    contractName: c.contract_name,
    hash: c.hash,
    projectName: c.project_name,
    publishedTime: c.published_time,
    publisher: c.publisher,
    safetyLevel: c.safety_report.safety_level,
    safetyIssues: c.safety_report.safety_issues,
    sourceCodeSize: c.source_code_size,
    standardsDeclared: c.standards_declared,
    version: c.version
  } : null
}

const mapProject = (c) => {
  return c ? {
    id: c.project_id,
    name: c.project_name,
    url: c.url,
    contracts: c.contracts,
    description: c.description,
    lastVersion: c.last_version,
    owners: c.owners
  } : null
}

export { NEAR, fromNear, loader, mapContract, mapProject, mapProjectView, mapCertificateView }

'''
'''--- frontend/src/components/Links.js ---
import React from 'react'
import { Link } from 'react-router-dom'

function ContractLink (props) {
  const contractHash = props.contractHash
  const version = props.version
  return <Link className='navigate' to={'/contract/' + contractHash}>{version}</Link>
}

function ProjectLink (props) {
  const projectName = props.projectName
  return <Link className='navigate' to={'/projectInfo/' + projectName}>{projectName}</Link>
}

function ProfileLink (props) {
  const userName = props.userName
  return <Link className='navigate' to={'/profileStats/' + userName}>{userName}</Link>
}

export { ContractLink, ProjectLink, ProfileLink }

'''
'''--- frontend/src/components/ProjectCard.js ---
import React from 'react'
import { Link } from 'react-router-dom'

import { ContractLink, ProfileLink, ProjectLink } from './Links'
import { mapProjectView } from './Helpers'

function ProjectCard (props) {
  const data = props.data
  const project = mapProjectView(data)
  let lastContract = null
  if (project.contracts) {
    project.contracts.forEach(element => {
      if (element.version === project.lastVersion) {
        lastContract = element
      }
    })
  }
  return (
    <div className='card mb-3 bg-gray' style={{ width: '100%' }}>
      <div className='card-body'>
        <div className='card-title d-flex flex-row'>
          <h5 className='pe-3'>Project <ProjectLink projectName={project.name} /></h5>
          {lastContract &&
            <div className='gray pe-3'><big>{project.contracts.length}</big> contract(s)</div>}
          {lastContract &&
            <div className='gray pe-3'>last version <ContractLink contractHash={lastContract.hash} version={project.lastVersion} /></div>}
          {lastContract &&
            <div className='gray'>by <ProfileLink userName={lastContract.publisher} /></div>}
          {/* lastContract &&
            <div className='ms-auto badge bg-success mt-1 mb-2'>test</div> */}
        </div>
        <div className='d-flex flex-row card-text'>
          <div className='flex-grow-1 d-flex flex-row'>
            <div className='card-text gray'>{project.description}</div>
          </div>
          {lastContract &&
            <div className='ms-3 align-bottom '>
              <Link to={'/contract/' + lastContract.hash} className='btn btn-primary'>Last deployed contract</Link>
            </div>}
          <div className='ms-3 align-bottom '>
            <Link to={'/projectInfo/' + project.name} className='btn btn-secondary'>Project details</Link>
          </div>
        </div>
      </div>
    </div>
  )
}

export { ProjectCard }

'''
'''--- frontend/src/index.css ---

'''
'''--- frontend/src/index.js ---
import React from 'react'
import ReactDOM from 'react-dom'
import './index.css'
import App from './App'

ReactDOM.render(<App />, document.getElementById('root'))

'''
'''--- frontend/src/pages/CLI.js ---
import React from 'react'
import { useParams } from 'react-router'
import { Link } from 'react-router-dom'
import useSWR from 'swr'
import Moment from 'react-moment'

import { loader, getBgByStatus } from '../components/Helpers'

function CLIPage (props) {
  return props.connected ? (
    <div className='pb-3'>
      <div className='container g-0 px-5 pt-3'>
        <div className='col-8'>
          <h4>Contracts.one CLI Developer and Auditor tools</h4>
          <div className='gray'>Contracts.one CLI is developed to improve and simplify experience of using the service. The tools are mostly about receiving source code of the contract and uploading it in a proper way.</div>
          <a href='https://github.com/Kouprin/contracts-one/tree/master/cli' className='mt-3 btn btn-outline-secondary'>CLI tools at GitHub</a>
        </div>
        <hr style={{ marginTop: '2%', marginBottom: '2%' }} />
        <div className='col-8'>
          <h5>Getting started</h5>
          <div className='gray pb-1'>Use yarn and node.js to build and execute.</div>
          <div className='gray'>At BETA stage, the CLI is not available at npmjs, so you have to build it locally.</div>
          <div className='small px-2 py-1 my-1 bg-gray'>
            <div>
              <samp className='mt-5'>yarn</samp>
            </div>
            <div>
              <samp className='mt-5'>./index.js</samp>
            </div>
          </div>
        </div>
        <hr style={{ marginTop: '2%', marginBottom: '2%' }} />
        <div className='col-8'>
          <h5>Getting packed source code of the contract</h5>
          <div className='gray'>Run</div>
          <div className='small px-2 py-1 my-1 bg-gray'>
            <div>
              <samp className='mt-5'>./index.js near source &lt;code-hash&gt; &lt;filename&gt;</samp>
            </div>
          </div>
          <div className='gray'>For example,</div>
          <div className='small px-2 py-1 my-1 bg-gray'>
            <div>
              <samp className='mt-5'>./index.js near source 8RcunxYGCt2RhNBnLeAJg1h7aYKbqi9MNHncZdJn8HqS test.bs58</samp>
            </div>
          </div>
          <div className='gray'>will create the file <samp className='small'>test.bs58</samp> with the proper data.</div>
        </div>
        <hr style={{ marginTop: '2%', marginBottom: '2%' }} />
        <div className='col-8'>
          <h5>Check the contract hash validity</h5>
        </div>
        <hr style={{ marginTop: '2%', marginBottom: '2%' }} />
        <div className='col-8'>
          <h5>Unpack the contract code</h5>
          <div className='gray'>Run</div>
          <div className='small px-2 py-1 my-1 bg-gray'>
            <div>
              <samp className='mt-5'>./index.js near unpack &lt;filename&gt;</samp>
            </div>
          </div>
          <div className='gray'>For example,</div>
          <div className='small px-2 py-1 my-1 bg-gray'>
            <div>
              <samp className='mt-5'>./index.js near test.bs58</samp>
            </div>
          </div>
          <div className='gray'>will extract the data from <samp className='small'>test.bs58</samp>.</div>
        </div>
        <hr style={{ marginTop: '2%', marginBottom: '2%' }} />
        <div className='col-8'>
          <h5>Publish the contract</h5>
        </div>
        <hr style={{ marginTop: '2%', marginBottom: '2%' }} />
        <div className='col-8'>
          <h5>Pack the source code of the contract</h5>
        </div>
      </div>
    </div>
  ) : loader()
}

export default CLIPage

'''
'''--- frontend/src/pages/Certificates.js ---
import React from 'react'
import { useParams } from 'react-router'
import { Link } from 'react-router-dom'
import useSWR from 'swr'

import { CertificateCard } from '../components/CertificateCard'
import { loader } from '../components/Helpers'

const FetchLimit = 25

function CertificatesPage (props) {
  let { page } = useParams()
  if (page === undefined) {
    page = 0
  }
  const from = Math.max(0, page - 1) * FetchLimit

  const fetchCertificates = async (...args) => {
    return await props._near.contract.get_all_certificates({ from: args[1], to: args[1] + FetchLimit })
  }

  const { data: certificates } = useSWR(['all_certificates', from], fetchCertificates, { errorRetryInterval: 500 })

  const certificatesList = certificates && certificates.map((data, index) => {
    return <CertificateCard {...props} key={index} data={data} />
  })

  return certificates ? (
    <div className='pb-3'>
      <div className='container g-0 px-5'>
        <div className='d-flex flex-row bd-highlight mb-3'>
          <h4 className='py-2 bd-highlight'>
            All Certificates
          </h4>
          <div className='ms-auto bd-highlight' />
          <Link className={'btn btn-outline-secondary ' + (!props.signedIn ? 'disabled' : '')} to={'/profileAudits/' + props.signedAccountId}>Submit new audit</Link>
          <div className='px-2 bd-highlight' />
          <Link className={'btn btn-outline-secondary ' + (!props.signedIn ? 'disabled' : '')} to={'/profileAudits/' + props.signedAccountId}>My audits</Link>
          <div className='px-2 bd-highlight' />
          <Link className={'btn btn-outline-primary disabled ' + (!props.signedIn ? 'disabled' : '')} to={'/profileAudits/' + props.signedAccountId}>Request an audit</Link>
        </div>
      </div>
      <div className='container g-0 px-5'>
        <div className='mb-3 py-2'>
          {certificatesList}
        </div>
      </div>
    </div>
  ) : loader()
}

export default CertificatesPage

'''
'''--- frontend/src/pages/Contract.js ---
import React from 'react'
import { useParams } from 'react-router'
import { Link } from 'react-router-dom'
import useSWR from 'swr'
import Moment from 'react-moment'

import { loader, mapContract, mapProject } from '../components/Helpers'

function ContractPage (props) {
  const { contractHash } = useParams()

  const fetchProject = async (...args) => {
    return mapProject(await props._near.contract.get_project({ project_name: args[1] }))
  }

  const fetchContract = async (...args) => {
    return args[1] === '' ? mapContract(null) : mapContract(await props._near.contract.get_contract({ contract_hash: args[1] }))
  }

  const { data: contract } = useSWR(contractHash ? ['contract', contractHash] : null, fetchContract, { errorRetryInterval: 500 })
  const { data: project } = useSWR(contract ? ['project', contract.projectName] : null, fetchProject, { errorRetryInterval: 500 })

  const certificates = contract && contract.certificates.length ? contract.certificates.map((data, index) => {
    const approvedMsg = data.approved ? 'approved' : 'refused'
    return (
      <div key={index} className='container g-0'>
        <div>
          {approvedMsg} by <Link to={`/profileAudits/${data.author}`}>{data.author}</Link>
        </div>
      </div>
    )
  }) : <div>No certificates found</div>

  const standards = contract && contract.standardsDeclared.length ? contract.standardsDeclared.map((data, index) => {
    return (
      <div key={index} className='badge bg-primary me-2'>
        <small>{data}</small>
      </div>
    )
  }) : <div>No standards declared</div>

  const safety = contract && (contract.safetyLevel === 'High' ? 'bg-success' : (contract.safetyLevel === 'Moderate' ? 'bg-warning' : 'bg-danger'))

  const audits = contract && contract.audits.length ? contract.audits.map((data, index) => {
    return (
      <div key={index} className='badge bg-secondary me-2'>
        <small>{data}</small>
      </div>
    )
  }) : <div>No audits</div>

  const issues = contract && contract.safetyIssues.length ? contract.safetyIssues.map((data, index) => {
    return (
      <div key={index} className='container g-0'>
        <small>
          {data}
        </small>
      </div>
    )
  }) : <div>No issues found</div>

  return props.connected && contract && project ? (
    <div className='pb-3'>
      <div className='container g-0 px-5'>
        <div className='d-flex flex-row bd-highlight mb-3'>
          <div className='py-2 bd-highlight'>
            <h5>Contract</h5>
          </div>
          <div className='p-2 bd-highlight' />
          <div className='p-2 bd-highlight'>
            <h5 className='gray'>{contract.hash}</h5>
          </div>
        </div>
        <div className='mb-3 py-2'>
          <h4>Project</h4>
          <Link to={`/projectInfo/${contract.projectName}`}>{contract.projectName}</Link>
        </div>
        <div className='mb-3 py-2'>
          <h4>Description</h4>
          <div>{project.description}</div>
        </div>
        <hr />
        <div className='mb-3 py-2'>
          <h4>Contract details</h4>
          <div className='row'>
            <div className='col-2' style={{ minWidth: '200px' }}>
            Contract name:
            </div>
            <div className='col-4' style={{ minWidth: '200px' }}>
              {contract.contractName}
            </div>
          </div>
          <div className='row'>
            <div className='col-2' style={{ minWidth: '200px' }}>
            Version:
            </div>
            <div className='col-4' style={{ minWidth: '200px' }}>
              {contract.version}
            </div>
          </div>
          <div className='row'>
            <div className='col-2' style={{ minWidth: '200px' }}>
            Publisher:
            </div>
            <div className='col-4' style={{ minWidth: '200px' }}>
              <Link to={`/profileProjects/${contract.publisher}`}>{contract.publisher}</Link>
            </div>
          </div>
          <div className='row'>
            <div className='col-2' style={{ minWidth: '200px' }}>
            Published time:
            </div>
            <div className='col-4' style={{ minWidth: '200px' }}>
              <Moment unix fromNow>{contract.publishedTime / 1000000000}</Moment>
            </div>
          </div>
          <div className='row'>
            <div className='col-2' style={{ minWidth: '200px' }}>
            Hash:
            </div>
            <div className='col-4' style={{ minWidth: '200px' }}>
              <samp className='small'>{contract.hash}</samp>
            </div>
          </div>
          <div className='row'>
            <div className='col-2' style={{ minWidth: '200px' }}>
            Audits:
            </div>
            <div className='col-4' style={{ minWidth: '200px' }}>
              {audits}
            </div>
          </div>
          <div className='row'>
            <div className='col-2' style={{ minWidth: '200px' }}>
            Source code:
            </div>
            <div className='col-4' style={{ minWidth: '200px' }}>
              {contract.sourceCodeSize} bytes <Link to='/cli'>(download)</Link>
            </div>
          </div>
          <div className='row'>
            <div className='col-2' style={{ minWidth: '200px' }}>
            Safety report:
            </div>
            <div className='col-4' style={{ minWidth: '200px' }}>
              <div className={'badge ' + safety}>{contract.safetyLevel}</div>
              {issues}
            </div>
          </div>
        </div>
        <hr />
        <div className='mb-3 py-2'>
          <h4>Standards</h4>
          {standards}
        </div>
        <div className='mb-3 py-2'>
          <h4>Certificates</h4>
          {certificates}
        </div>
      </div>
    </div>
  ) : loader()
}

export default ContractPage

'''
'''--- frontend/src/pages/Landing.js ---
import React, { useState } from 'react'
import { mapContract } from '../components/Helpers'
import useSWR from 'swr'

function LandingPage (props) {
  const [query, setQuery] = useState('')

  async function go (e) {
    e.preventDefault()
    window.location.href = '#/contract/' + query
  }

  const fetchContract = async (...args) => {
    return mapContract(await props._near.contract.get_contract({ contract_hash: args[1] }))
  }

  const { data: contract } = useSWR(query ? ['contract', query] : null, fetchContract, { errorRetryInterval: 500 })

  return (
    <div
      className='container my-auto'
    >
      <div style={{ margin: '5%' }} />
      <h4 className='mb-5 text-center'>Welcome to contracts.one!</h4>
      <h5 className='text-center'>The decentralized source of truth for NEAR contracts</h5>
      <div style={{ margin: '10%' }} />
      <form onSubmit={(e) => go(e)}>
        <div className='d-flex align-items-center justify-content-center'>
          <div className='form-group' style={{ width: '600px', margin: '25px' }}>
            <label className='mt-3'>Put here contract hash or certificate id</label>
            <input
              type='text' className='form-control mt-2'
              placeholder='Example: 55E7imniT2uuYrECn17qJAk9fLcwQW4ftNSwmCJL5Di' onChange={(e) => setQuery(e.target.value)}
            />
            <small className='gray'>try <samp className='small'>5suuACmAzbTj8oyv4bQUjuJZbRinGMAKMLorDDEFzu4a</samp></small>
            <div style={{ margin: '10%' }} />
            <div className='d-flex justify-content-center'>
              <button className={'btn-lg btn btn-outline-primary ' + (contract ? '' : 'disabled')}>Go!</button>
            </div>
          </div>
        </div>
      </form>
    </div>
  )
}

export default LandingPage

'''
'''--- frontend/src/pages/Profile.js ---
import React, { useState } from 'react'
import { useParams } from 'react-router'
import { Link } from 'react-router-dom'
import useSWR from 'swr'

import { CertificateCard } from '../components/CertificateCard'
import { ProjectCard } from '../components/ProjectCard'
import { mapContract, loader } from '../components/Helpers'

const tabs = {
  STATS: 'stats',
  PROJECTS: 'projects',
  AUDITS: 'audits'
}

function ProfilePageCommon (props, tab) {
  const { profileId } = useParams()
  const [showSubmitButton, setShowSubmitButton] = useState(true)
  const [newProjectName, setNewProjectName] = useState('')
  const [newProjectDesc, setNewProjectDesc] = useState('')
  const [formURL, setFormURL] = useState('')
  const [formSummary, setFormSummary] = useState('')
  const [formCommaSeparated, setFormCommaSeparated] = useState('')
  const [auditHash, setAuditHash] = useState('')
  const [auditRadioBasicValidity, setAuditRadioBasicValidity] = useState(undefined)
  const [auditRadioApprove, setAuditRadioApprove] = useState(undefined)
  const [auditRating, setAuditRating] = useState(undefined)

  async function submitNewProject (e) {
    e.preventDefault()
    setShowSubmitButton(false)
    try {
      await props._near.contract.register_project(
        {
          project_name: newProjectName,
          description: newProjectDesc,
          url: formURL,
          owners: formCommaSeparated.split(/[ ,]+/)
        }, '200000000000000', '1')
      // TODO
      window.location.href = '#/projectInfo/' + newProjectName
    } catch (e) {
      console.log('result', e)
      setShowSubmitButton(true)
    }
  }

  async function registerAsAuditor (e) {
    e.preventDefault()
    setShowSubmitButton(false)
    try {
      await props._near.contract.register_auditor(
        {
          user_id: profileId
        }, '200000000000000', '0')
    } catch (e) {
      console.log('result', e)
      setShowSubmitButton(true)
    }
  }

  async function submitNewAudit (e) {
    e.preventDefault()
    console.log(formCommaSeparated)
    console.log(formCommaSeparated.split(/[ ,]+/))
    console.log(auditRating)
    console.log(contract)
    setShowSubmitButton(false)
    try {
      await props._near.contract.sign_audit(
        {
          project_name: contract.project_name,
          version: contract.version,
          report_url: formURL,
          summary: formSummary,
          standards_confirmed: formCommaSeparated.split(/[ ,]+/),
          basic_validity_passed: auditRadioBasicValidity,
          contract_approved: auditRadioApprove,
          score: parseInt(auditRating)
        }, '200000000000000', '1')
      // TODO
      window.location.href = '#/contract/' + auditHash
    } catch (e) {
      console.log('result', e)
      setShowSubmitButton(true)
    }
  }

  const fetchUser = async (...args) => {
    return await props._near.contract.get_user({ user_id: args[1] })
  }

  const fetchCertificates = async (...args) => {
    return await props._near.contract.get_auditor_certificates({ user_id: args[1] })
  }

  const fetchContract = async (...args) => {
    return mapContract(await props._near.contract.get_contract({ contract_hash: args[1] }))
  }

  const { data: user } = useSWR(['user_id', profileId], fetchUser, { errorRetryInterval: 500 })
  const { data: certificates } = useSWR(user && user.auditor !== null ? ['user_audits', profileId] : null, fetchCertificates, { errorRetryInterval: 500 })
  const { data: contract } = useSWR(auditHash ? ['contract', auditHash] : null, fetchContract, { errorRetryInterval: 500 })

  const userProjects = user && user.projects_owned.map((data, index) => {
    return <ProjectCard {...props} key={index} data={data} />
  })

  const userCertificates = certificates && certificates.length > 0 ? certificates.map((data, index) => {
    return <CertificateCard {...props} key={index} data={data} />
  }) : <div>No certificates found</div>

  const isMe = profileId === props.signedAccountId

  return props.connected ? (
    <div className='pb-3'>
      <div className='container g-0 px-5'>
        <div className='d-flex flex-row bd-highlight mb-3'>
          <div className='py-2 bd-highlight'>
            <h5>Profile</h5>
          </div>
          <div className='p-2 bd-highlight' />
          <div className='p-2 bd-highlight'>
            <h5 className='gray'>{profileId}</h5>
          </div>

          <div className='ms-auto bd-highlight' />
          {isMe
            ? <button className='btn btn-outline-secondary' onClick={() => props._near.logOut()}>Sign out</button>
            : <div />}
        </div>
        <hr />
      </div>
      <div className='container g-0 px-5'>
        <div className='d-flex flex-row bd-highlight mb-3'>
          <div className='py-2 bd-highlight'>
            {tab === tabs.PROJECTS
              ? <h5 className='nonavigate'>Projects</h5>
              : <h5><Link className='navigate' to={`/profileProjects/${profileId}`}>Projects</Link></h5>}
          </div>
          <div className='p-2 bd-highlight' />
          <div className='py-2 bd-highlight'>
            {tab === tabs.AUDITS
              ? <h5 className='nonavigate'>Audits</h5>
              : <h5><Link className='navigate' to={`/profileAudits/${profileId}`}>Audits</Link></h5>}
          </div>
          <div className='p-2 bd-highlight' />
          <div className='py-2 bd-highlight'>
            {tab === tabs.STATS
              ? <h5 className='nonavigate'>Stats</h5>
              : <h5><Link className='navigate' to={`/profileStats/${profileId}`}>Stats</Link></h5>}
          </div>
        </div>
      </div>
      <div className='container g-0 px-5'>
        {tab === tabs.PROJECTS &&
          <div>
            <div className='pb-3'>
              {userProjects}
            </div>
            <hr />
            {isMe &&
              <div className='mb-3 py-2'>
                <h4>Create a new project</h4>
                <form onSubmit={(e) => submitNewProject(e)}>
                  <div className='d-flex align-items-center justify-content-center'>
                    <div className='form-group' style={{ width: '600px', margin: '25px' }}>
                      <label className='mt-3'>Project name</label>
                      <input
                        type='text' className='form-control mt-2'
                        placeholder='Example: My-awesome-project-3000' onChange={(e) => setNewProjectName(e.target.value)}
                      />
                      <label className='mt-3'>Project description (max 255 symbols)</label>
                      <input
                        type='text' className='form-control mt-2'
                        placeholder='Example: Developer platform to create apps that put users back in control of their data and assets'
                        onChange={(e) => setNewProjectDesc(e.target.value)}
                      />
                      <label className='mt-3'>Project URL</label>
                      <input
                        type='text' className='form-control mt-2'
                        placeholder='Example: github.com/near' onChange={(e) => setFormURL(e.target.value)}
                      />
                      <label className='mt-3'>Owners, comma-separated</label>
                      <input
                        type='text' className='form-control mt-2'
                        placeholder='Example: root.near, alex.near' onChange={(e) => setFormCommaSeparated(e.target.value)}
                      />
                      {showSubmitButton ? <button className='btn btn-outline-primary mt-5' disabled={!newProjectName || !newProjectDesc || !formURL || !formCommaSeparated}>Create a new project</button> : loader()}
                    </div>
                  </div>
                </form>
              </div>}
          </div>}
        {tab === tabs.AUDITS &&
          <div>
            <div className='pb-3'>
              {user && !user.auditor
                ? (
                  <div>
                    <h5>Not an auditor. Contact to devs to register as auditor</h5>
                    {/*
                    TODO
                    <h4>Not an auditor. Register?</h4>
                    <div className='p-2 bd-highlight' />
                    {showSubmitButton ? <button className='btn btn-primary' onClick={(e) => registerAsAuditor(e)}>Register as auditor</button> : loader()}
                    */}
                  </div>)
                : userCertificates}
            </div>
            {isMe && user && user.auditor &&
              <div className='mb-3 py-2'>
                <hr />
                <h4>Submit an audit</h4>
                <form onSubmit={(e) => submitNewAudit(e)}>
                  <small>// 5suuACmAzbTj8oyv4bQUjuJZbRinGMAKMLorDDEFzu4a - quick example</small>
                  <div className='d-flex align-items-center justify-content-center'>
                    <div className='form-group' style={{ width: '600px', margin: '25px' }}>
                      <label className='mt-3'>Contract hash</label>
                      <input
                        type='text' className='form-control mt-2'
                        placeholder='Example: 55E7imniT2uuYrECn17qJAk9fLcwQW4ftNSwmCJL5Di' onChange={(e) => setAuditHash(e.target.value)}
                      />
                      <div className='mt-3' />
                      <div className='d-flex align-items-center justify-content-center'>
                        {!contract
                          ? <small className='me-auto'>Nothing found</small> : <small className='me-auto'>Found</small>}
                        {contract &&
                          <small className='gray me-3'>Project: {contract.project_name}</small>}
                        {contract &&
                          <small className='gray'>Version: {contract.version}</small>}
                      </div>

                      <div />

                      <div className='mt-3' />
                      <label>Report URL</label>
                      <input
                        type='text' className='form-control mt-2'
                        placeholder='Example: github.com/near' onChange={(e) => setFormURL(e.target.value)}
                      />
                      <div className='mt-3' />
                      <label>Summary, 255 symbols max</label>
                      <textarea
                        rows='4' className='form-control mt-2'
                        placeholder='Example: Fifteen critical and eight high severity issues were found, along with recommendations on how to fix them. Additionally, some medium and lower severity issues were found and explained. Some changes were proposed to follow best practices and reduce the potential attack surface.' onChange={(e) => setFormSummary(e.target.value)}
                      />
                      <div className='mt-3' />
                      <label>Standards, comma-separated, optional</label>
                      <input
                        type='text' className='form-control mt-2'
                        placeholder='Example: FOO-16, BAR-141' onChange={(e) => setFormCommaSeparated(e.target.value)}
                      />
                      <small className='gray'>Leave blank if no standards are confirmed</small>
                      <div className='mt-3' />
                      <label>Basic contract validity verdict</label>
                      <div className='mt-1' />
                      <div className='form-check'>
                        <input className='form-check-input' type='radio' name='flexRadioDefault1' onChange={(e) => setAuditRadioBasicValidity(true)} />
                        <label className='form-check-label small'>I confirm the source code of the contract has been downloaded from the Blockchain and it has been compiled into <samp className='small'>{auditHash}</samp></label>
                      </div>
                      <div className='form-check'>
                        <input className='form-check-input' type='radio' name='flexRadioDefault1' onChange={(e) => setAuditRadioBasicValidity(false)} />
                        <label className='form-check-label small'>The condition above is false</label>
                      </div>
                      <small className='gray'>This mark corresponds to basic contract validity knowledge at <u>contracts.one</u>. If you have audited NOT an open source code, please mark the condition above as false and go to the next question.</small>
                      <div className='mt-3' />
                      <label>General contract audit verdict</label>
                      <div className='mt-1' />
                      <div className='form-check'>
                        <input className='form-check-input' type='radio' name='flexRadioDefault2' onChange={(e) => setAuditRadioApprove(true)} />
                        <label className='form-check-label small'>I confirm the source code of the contract is considered safe and can be used by anyone in any way without risks of potential funding losses</label>
                      </div>
                      <div className='form-check'>
                        <input className='form-check-input' type='radio' name='flexRadioDefault2' onChange={(e) => setAuditRadioApprove(false)} />
                        <label className='form-check-label small'>The condition above is false</label>
                      </div>
                      <small className='gray'>If the contract has dangerous flaws, please mark the condition above as false. Then the contract must be updated by the developer and uploaded under a new version. Please make sure that your report is reachable by URL and explains clearly the flaws.</small>
                      <div className='mt-3' />
                      <label>Overall contract quality rating, integer in range [1..10]</label>
                      <input
                        type='text' className='form-control mt-2'
                        placeholder='Example: 7' onChange={(e) => setAuditRating(e.target.value)}
                      />
                      <small className='gray'>Even in case of having dangerous flaws, the overall code quality may be very good. This score is mostly about your subjective understanding of how good the code is organized and structured, how easy to get into details, etc.</small>
                      <div className='mt-3' />
                      {showSubmitButton ? <button className='btn btn-outline-primary' disabled={!contract || !formURL || auditRadioBasicValidity === undefined || auditRadioApprove === undefined || !auditRating}>Submit an audit</button> : loader()}
                    </div>
                  </div>
                </form>
              </div>}
          </div>}
      </div>
    </div>
  ) : loader()
}

function ProfileStatsPage (props) {
  return ProfilePageCommon(props, tabs.STATS)
}

function ProfileProjectsPage (props) {
  return ProfilePageCommon(props, tabs.PROJECTS)
}

function ProfileAuditsPage (props) {
  return ProfilePageCommon(props, tabs.AUDITS)
}

export { ProfileStatsPage, ProfileProjectsPage, ProfileAuditsPage }

'''
'''--- frontend/src/pages/ProjectInfo.js ---
import React from 'react'
import { useParams } from 'react-router'
import { Link } from 'react-router-dom'
import useSWR from 'swr'
import Moment from 'react-moment'

import { mapProject, loader } from '../components/Helpers'

function ProjectInfoPage (props) {
  const { projectName } = useParams()

  const fetchProject = async (...args) => {
    return mapProject(await props._near.contract.get_project({ project_name: args[1] }))
  }

  const { data: project } = useSWR(['project', projectName], fetchProject, { errorRetryInterval: 500 })

  const owners = project && project.owners.map((data, index) => {
    return (
      <div key={index} className='container g-0'>
        <div>
          <Link to={`/profileProjects/${data}`}>{data}</Link>
        </div>
      </div>
    )
  })

  const versions = project && project.contracts.map((data, index) => {
    return (
      <div key={index} className='container g-0'>
        <div key={index} className='row'>
          <div className='col-1'>
            <Link to={`/contract/${data.hash}`}>{data.version}</Link>
          </div>
          <div className='col-4'>
            <samp className='small'><Link to={`/contract/${data.hash}`}>{data.hash}</Link></samp>
          </div>
          <div className='col-7'>
            Published <Moment unix fromNow>{data.published_time / 1000000000}</Moment> by <Link to={`/profileProjects/${data.publisher}`}>{data.publisher}</Link>
          </div>
        </div>
      </div>
    )
  })

  return props.connected && project ? (
    <div className='pb-3'>
      <div className='container g-0 px-5'>
        <div className='d-flex flex-row bd-highlight mb-3'>
          <div className='py-2 bd-highlight'>
            <h5>Project</h5>
          </div>
          <div className='p-2 bd-highlight' />
          <div className='p-2 bd-highlight'>
            <h5 className='gray'>{project.name}</h5>
          </div>
        </div>
        <div className='mb-3 py-2'>
          <h4>Description</h4>
          <div>{project.description}</div>
        </div>
        <hr />
        <div className='mb-3 py-2'>
          <h4>Known versions</h4>
          <div>{versions}</div>
        </div>
        <hr />
        <div className='mb-3 py-2'>
          <h4>Owners</h4>
          <div>{owners}</div>
        </div>
      </div>
    </div>
  ) : loader()
}

export default ProjectInfoPage

'''
'''--- frontend/src/pages/Projects.js ---
import React from 'react'
import { useParams } from 'react-router'
import { Link } from 'react-router-dom'
import useSWR from 'swr'

import { ProjectCard } from '../components/ProjectCard'
import { loader } from '../components/Helpers'

const FetchLimit = 25

function ProjectsPage (props) {
  let { page } = useParams()
  if (page === undefined) {
    page = 0
  }
  const from = Math.max(0, page - 1) * FetchLimit

  const fetchProjects = async (...args) => {
    return await props._near.contract.get_all_projects({ from: args[1], to: args[1] + FetchLimit })
  }

  const { data: projects } = useSWR(['all_projects', from], fetchProjects, { errorRetryInterval: 500 })

  const projectList = projects && projects.map((data, index) => {
    return <ProjectCard {...props} key={index} data={data} />
  })

  return projects ? (
    <div className='pb-3'>
      <div className='container g-0 px-5'>
        <div className='d-flex flex-row bd-highlight mb-3'>
          <h4 className='py-2 bd-highlight'>
            All Projects
          </h4>
          <div className='ms-auto bd-highlight' />
          <Link className={'btn btn-outline-secondary ' + (!props.signedIn ? 'disabled' : '')} to={'/profileProjects/' + props.signedAccountId}>Create new project</Link>
          <div className='px-2 bd-highlight' />
          <Link className={'btn btn-outline-secondary ' + (!props.signedIn ? 'disabled' : '')} to={'/profileProjects/' + props.signedAccountId}>My projects</Link>
        </div>
      </div>
      <div className='container g-0 px-5'>
        <div className='mb-3 py-2'>
          {projectList}
        </div>
      </div>
    </div>
  ) : loader()
}

export default ProjectsPage

'''