*GitHub Repository "ketyung/tm_users_contract"*

'''--- Cargo.toml ---
[package]
name = "tm_users_contract"
version = "0.1.0"
edition = "2021"
authors = ["Christopher Chee <ketyung@techchee.com>"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }
near-contract-standards = "4.0.0"
tm-collections-models = { version = "0.1.0", path = "../tm_collections_models" }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []
'''
'''--- LICENSE.md ---
MIT License

Copyright (c) 2022 Christopher Ket Yung Chee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'''
'''--- build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- readme.md ---
## The main smart contract for TicketMaker
The smart contract for storing and handling users and cross-contract 
calls to other contracts of TicketMaker. https://ticketmaker.xyz

## License 
MIT License
Copyright (c) 2022 Christopher Ket Yung Chee. See [License](https://github.com/ketyung/tm_users_contract/blob/master/LICENSE.md) for details

'''
'''--- src/collecton_manage.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    fn get_sub_account_id (sub_account_id : String ) -> AccountId{

        let acc_id : AccountId = format!("{}_{}.{}", 
        sub_account_id.to_lowercase(),
        env::signer_account_id().to_string().replace(".","_"),
        env::current_account_id()).parse().unwrap();

        acc_id 
    }

    pub (crate) fn get_collections_contract_id(collections_contract_id : Option<AccountId>) -> AccountId {

        if collections_contract_id.is_some(){

            return collections_contract_id.unwrap();
        }

        COLLECTIONS_CONTRACT_ID.parse().unwrap()
    }

}

const NFT_CONTRACT_CODE: &[u8] = include_bytes!("./wasm/non_fungible_token.wasm");

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

const COLLECTIONS_CONTRACT_ID :  &'static str = "tm_collections_contract.testnet";

#[near_bindgen]
impl Contract {

    pub (crate) fn to_actual_amount(init_balance : u32) -> f64 {
        
        init_balance as f64 / 1000.00
    }

    #[payable]
    pub fn create_collection_and_deploy(
        &mut self, 
        init_balance : u32, 
        collection : Collection ){

        self.is_signer_registered();

        
        let contract_id = Self::get_sub_account_id(collection.symbol.clone());

        // allow for 3 decimals, which means
        let actual_init_bal = Self::to_actual_amount(init_balance);

        // sending amount 1000 = 1 Near, 1020 = 1.020 Near, 2031 = 2.031 NEAR etc
        let bal : Balance = (actual_init_bal * (NEAR as f64)) as u128 ;

        // mark up 2 percent
        let req_deposit = (actual_init_bal * MARKUP_PERC) * (NEAR as f64);

        if env::attached_deposit() < (req_deposit as u128) {

            // refund deposit
            Promise::new(env::signer_account_id())
            .transfer(bal).as_return();

            env::panic_str(format!("Deposit is less than the required amount {} NEAR", req_deposit).as_str());
        }

    
        Promise::new(contract_id.clone())
        .create_account()
        .transfer(bal)
        .add_full_access_key(env::signer_account_pk())
        .deploy_contract(NFT_CONTRACT_CODE.to_vec())
        .then(

            Self::ext(env::current_account_id())
            .with_static_gas(Gas(CALLBACK_TGAS))
            .nft_contract_deploy_callback(contract_id, bal, collection, self.collections_contract_id.clone())
        );
    
    }
}

#[near_bindgen]
impl Contract {

    #[private]
    pub fn nft_contract_deploy_callback(
        contract_id : AccountId,
        init_balance : Balance,
        collection : Collection , 
        collections_contract_id : Option<AccountId>,
        #[callback_result] call_result: Result<(), PromiseError>) {

        if call_result.is_err() {

            // transfer back the init balance to the signer
            Promise::new(env::signer_account_id())
            .transfer(init_balance).as_return();
            
            env::log_str(
            format!("return at nft_contract_deploy_callback & tx back init_balanace {}", 
            init_balance).as_str());
            return;
        }

        let mut icon = collection.icon.clone();
        if icon.is_none() {

            icon = Some(DATA_IMAGE_SVG_NEAR_ICON.to_string());
        }

    
        env::log_str(format!("Going to init contract : {}", contract_id).as_str());

        nft_contract::ext(contract_id.clone())
        .with_static_gas(Gas(5*TGAS))
        .init_with_metadata(env::signer_account_id(), 
        collection.title.clone(), collection.symbol.clone(), icon, 
        collection.base_uri.clone(), 
        Some(vec![collections_contract_id.clone().unwrap(),
        env::current_account_id()]))
        .then(

            Self::ext(env::current_account_id())
            .with_static_gas(Gas(CALLBACK_TGAS))
            .nft_contract_init_callback(contract_id, collection, collections_contract_id)
        );
    

    }

    #[private]
    pub fn nft_contract_init_callback(
        contract_id : AccountId,
        collection : Collection, 
        collections_contract_id : Option<AccountId>,
        #[callback_result] call_result: Result<(), PromiseError>) {

        if call_result.is_err() {

            env::panic_str(format!("Failed to initialize contract {}!", contract_id.clone()).as_str());
        }

        env::log_str(format!("NFT contract {} has been initialized!", contract_id.clone()).as_str());

        collections_contract::ext(Self::get_collections_contract_id(collections_contract_id))
        .with_static_gas(Gas(5*TGAS))
        .create_collection(env::signer_account_id(), collection.title.clone(),
        collection.symbol, 
        collection.icon, collection.base_uri,
        collection.description, 
        collection.category,
        collection.total_tickets,
        collection.tickets_sold,
        collection.ticket_types,
        collection.attributes,
        collection.ticket_template_type, 
        Some(contract_id))
        .then(

            Self::ext(env::current_account_id())
            .with_static_gas(Gas(CALLBACK_TGAS))
            .nft_collection_create_callback(collection.title)
        );

    }

    #[private]
    pub fn nft_collection_create_callback(
        collection_title : String, 
        #[callback_result] call_result: Result<(), PromiseError>) 
    {

        if call_result.is_err() {

            env::panic_str(format!("Failed to create collection '{}' in NFT collection store!", 
            collection_title).as_str());
        }

        env::log_str(format!("Collection {} has been created in NFT collection store!", 
        collection_title).as_str());

    }

}

#[near_bindgen]
impl Contract {

    // A wrapper function for cross-contract calling to
    // update the collection
    pub fn update_collection (&self, title : String,
        symbol : String,
        data_for_update : CollectionDataForUpdate){
        
        let collection_id = CollectionId {
            owner : env::signer_account_id(),
            title : title,
            symbol : symbol,
        };

        collections_contract::ext(Self::get_collections_contract_id(self.collections_contract_id.clone()))
        .with_static_gas(Gas(5*TGAS))
        .update_collection(collection_id,data_for_update).as_return();
    
    }
}

#[near_bindgen]
impl Contract {

    pub fn gen_next_ticket_number (&mut self, collection_id : CollectionId,
        width : Option<usize>) {

       
        collections_contract::ext(Self::get_collections_contract_id(
        self.collections_contract_id.clone()))
        .with_static_gas(Gas(5*TGAS))
        .gen_next_ticket_number(collection_id, width)
        .then(
            Self::ext(env::current_account_id())
            .with_static_gas(Gas(CALLBACK_TGAS))
            .next_ticket_number_callback()
            .as_return()
        );

      
    }

    #[private]
    pub fn next_ticket_number_callback(
        #[callback_result] call_result: Result<String, PromiseError>) 
    {

        if call_result.is_err() {

            env::panic_str("Error!@x");
        }

        let str = call_result.unwrap();
        env::log_str(format!("<NextTicketNumber>{}</NextTicketNumber>",str  ).as_str());
    }

   
}

'''
'''--- src/ext.rs ---
use crate::*;

pub const TGAS: u64 = 1_000_000_000_000;
pub const NO_DEPOSIT: u128 = 0;
pub const XCC_SUCCESS: u64 = 1;

// For cross-contract calls
#[ext_contract(nft_contract)]
trait NftContract {
  
    fn init_with_metadata(owner_id: AccountId, name : String, symbol : String,
        icon : Option<String>, base_uri : Option<String>, 
        allowed_callers : Option<Vec<AccountId>> );    
}

// For cross-contract calls to create the collection
// in the collection store contract
#[ext_contract(collections_contract)]
trait CollectionsContract {
  
    fn create_collection (
        acc_id : AccountId,     
        title : String, 
        symbol : String,
        icon : Option<String>,
        base_uri : Option<String>,
        description : Option<String>,
        category : Option<String>,
        total_tickets : Option<u64>,
        tickets_sold : Option<u64>,
        ticket_types : Option<Vec<TicketType>>,
        attributes : Option<Vec<Attribute>>,
        template_type : Option<TicketTemplate>,
        contract_id : Option<AccountId>);

    fn update_collection (collection_id : CollectionId,
        update_collection_data : CollectionDataForUpdate);

        
    fn ticket_mint (&mut self, 
        collection_id : CollectionId, 
        token_id : TokenId, ticket_image : String,
        ticket_type : Option<TicketType>,
        extra  : Option<String>,
        ref_hash : Option<String>);
    
    fn gen_next_ticket_number (collection_id : CollectionId,
            width : Option<usize>) -> Option<String>;
          
    fn get_collection (collection_id : CollectionId) -> Option<Collection>;

}

'''
'''--- src/lib.rs ---
pub mod models;
pub mod ext;
pub mod users_view;
pub mod users_manage;
pub mod collecton_manage;
pub mod ticket_mint;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, env, ext_contract, BorshStorageKey,AccountId, Balance, Promise, Gas, PromiseError};
use near_sdk::collections::{UnorderedMap};
use near_sdk::serde::{Serialize, Deserialize};
use near_contract_standards::non_fungible_token::{TokenId};
use tm_collections_models::models::*;
use crate::models::*;
use ext::*;

const NEAR: u128 = 1000_000_000_000_000_000_000_000;

const MARKUP_PERC : f64 = 1.02;

const CALLBACK_TGAS : u64 = 1*TGAS;

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    
    users: UnorderedMap<String, User>,

    collections_contract_id : Option<AccountId>,

    date_updated : Option<u64>, 
}

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {

    UserStorageKey,
}

// Define the default, which automatically initializes the contract

impl Default for Contract{
    fn default() -> Self{
        Self{users: UnorderedMap::new(StorageKey::UserStorageKey), 
            collections_contract_id : None, 
            date_updated : Some(env::block_timestamp()) }
    }
}

/*
#[near_bindgen]
impl Contract {

    #[init]
    #[private] // Public - but only callable by env::current_account_id()
    #[allow(dead_code)]
    pub (crate) fn init() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self{users: UnorderedMap::new(StorageKey::UserStorageKey), 
        collections_contract_id : None, 
        date_updated : Some(env::block_timestamp()) }
    }

}*/

#[near_bindgen]
impl Contract {

    #[init]
    #[private] // Public - but only callable by env::current_account_id()
    pub fn init(collections_contract_id : AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let s = Self{users: UnorderedMap::new(StorageKey::UserStorageKey), 
        collections_contract_id : Some(collections_contract_id.clone()), 
        date_updated : Some(env::block_timestamp()) };

        env::log_str(
            format!("users contract initialized with {:?}", collections_contract_id).as_str());
            
        return s ;
    }

}

#[near_bindgen]
impl Contract {

    fn is_signer_registered(&self){

        if !self.has_user(&env::signer_account_id().as_str().to_string()) {

            env::panic_str(format!("User [{}] does NOT exist!", env::signer_account_id()).as_str());
      
        }
    }
}
'''
'''--- src/models.rs ---
use crate::*;

pub type AccountId = String;

#[derive(Debug, Clone, Serialize, Deserialize,BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct User {

    pub id : AccountId,

    pub first_name : Option<String>,

    pub last_name : Option<String>, 

    pub email : Option<String>,

    pub mobile_number : Option<String>,

    pub profile_image : Option<String>,

    pub date_created : Option<u64>,
    
    pub date_updated : Option<u64>,
    
}

'''
'''--- src/ticket_mint.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    #[payable]
    pub fn ticket_mint (&mut self, collection_id : CollectionId, token_id : TokenId,
    ticket_image : String,ticket_type : Option<TicketType>, extra  : Option<String>) {
    
        
        self.ticket_mint_check_signup(collection_id, token_id, ticket_image, ticket_type,
        extra); 
    
    }

}

#[near_bindgen]
impl Contract {

    /**
     * Reserve function for implementation of if a ticket collection required 
     * the check if the buyer has signed up
     */
    #[allow(dead_code)]
    #[payable]
    fn ticket_mint_check_signup (&mut self, collection_id : CollectionId, token_id : TokenId,
        ticket_image : String,ticket_type : Option<TicketType>, extra  : Option<String>){

        collections_contract::ext(Self::get_collections_contract_id(self.collections_contract_id.clone()))
        .with_static_gas(Gas(5*TGAS))
        .get_collection(collection_id.clone())
        .then(
            Self::ext(env::current_account_id())
            .with_static_gas(Gas(CALLBACK_TGAS))
            .with_attached_deposit(env::attached_deposit())
            .after_getting_collection_callback(collection_id, token_id,
            ticket_image, ticket_type, extra)
            .as_return()
        );

    
    }

    #[private]
    pub fn after_getting_collection_callback(&self,
    collection_id : CollectionId, token_id : TokenId,
    ticket_image : String,ticket_type : Option<TicketType>, extra  : Option<String>,
    #[callback_result] call_result: Result<Collection, PromiseError>) 
    {

        if call_result.is_err() {

            env::panic_str("Error!@x");
        }

     
        let collection : Collection = call_result.unwrap();

        if collection.attributes.is_some() {

            let uw_attribs = collection.attributes.unwrap();

            let req_to_sign_up = Attribute {
                name : AttributeType::BuyerRequiredToSignUp,
                value : "none".to_string(),
            };

            let index = uw_attribs.iter().position(|a| *a == req_to_sign_up);

            if index.is_some() {

                if uw_attribs[index.unwrap()].value == "true".to_string() {

                    if !self.has_user(&env::signer_account_id().to_string()) {

                        env::panic_str(format!("User {} does NOT exist!",
                        env::signer_account_id()).as_str());
                    }
            
                }
            }
            
        }

        collections_contract::ext(Self::get_collections_contract_id(self.collections_contract_id.clone()))
        .with_static_gas(Gas(5*TGAS))
        .with_attached_deposit(env::attached_deposit())
        .ticket_mint(collection_id, token_id, ticket_image, ticket_type, extra, 
        None).as_return();
   
        
      
    }

}

#[near_bindgen]
impl Contract {

    /*
    Reserved function for the check of if buyer has signed up when minting a ticket
    */
    #[allow(dead_code)]
    fn ticket_mint_force_signup (&mut self, collection_id : CollectionId, token_id : TokenId,
        ticket_image : String,ticket_type : Option<TicketType>, extra  : Option<String>){

        if !self.has_user(&env::signer_account_id().to_string()) {

            env::panic_str(format!("User {} does NOT exist!",
            env::signer_account_id()).as_str());
        }

        collections_contract::ext(Self::get_collections_contract_id(self.collections_contract_id.clone()))
        .with_static_gas(Gas(5*TGAS))
        .with_attached_deposit(env::attached_deposit())
        .ticket_mint(collection_id, token_id, ticket_image, ticket_type, extra, 
        None).as_return();
    
    }
}
'''
'''--- src/users_manage.rs ---
use crate::*;

// Implement the contract structure
#[near_bindgen]
impl Contract {
    fn check_if_authorized() {

        if env::current_account_id() != env::signer_account_id() {
            env::panic_str("Unauthorized!");
        }
    }
}

// Implement the contract structure
#[near_bindgen]
impl Contract {

    
    pub fn signup_user (&mut self, first_name : String, last_name : String,
    profile_image : Option<String>, email : Option<String>, mobile_number : Option<String> ){
        self.add_user(env::signer_account_id().to_string(), first_name, last_name, profile_image, email,mobile_number);
    }

    pub(crate) fn add_user (&mut self, id : String,  first_name : String, last_name : String, 
        profile_image : Option<String>,
        email : Option<String>,
        mobile_number : Option<String> ){

        if self.users.get(&id).is_some() {
            env::panic_str(format!("User {} already exists",id).as_str());
        }    

       // env::log_str(format!("profile_img:{:?}", profile_image).as_str());

        env::log_str(format!("storage.usage.b4:{}", env::storage_usage()).as_str());

      
        let date = env::block_timestamp();
        let user = User {
            id :id.clone(),
            first_name : Some(first_name),
            last_name : Some(last_name),
            email : email,
            mobile_number : mobile_number,
            profile_image : profile_image, 
            date_created : Some(date),
            date_updated : Some(date), 
        };

        //println!("sizeofuser:{}", std::mem::size_of::<User>());

        self.users.insert(&id, &user);

        env::log_str(format!("storage.usage.af:{}", env::storage_usage()).as_str());
        
    }

}

#[near_bindgen]
impl Contract {

    pub fn update_user (&mut self, first_name : Option<String>, last_name : Option<String>,
        profile_image : Option<String>, email : Option<String>, mobile_number : Option<String>) {

        let id = env::signer_account_id().to_string();

        let user = self.users.get(&id); 

        if user.is_some () {

            let mut wuser  = user.unwrap();
            wuser.id = id.clone(); 
            // only update field if they're not none (undefined from the client)
            if first_name.is_some() {
                wuser.first_name = first_name;
            }

            if last_name.is_some(){
                wuser.last_name = last_name;
            }

            if email.is_some() {
                wuser.email = email;
            }

            if mobile_number.is_some() {
                wuser.mobile_number = mobile_number;
            }

            wuser.profile_image = profile_image;
            
            wuser.date_updated = Some(env::block_timestamp());
            self.users.remove(&id);
            self.users.insert(&id, &wuser);

        }   
        else {
            env::panic_str(format!("User {} not found", id).as_str());
        } 
    }

}

#[near_bindgen]
impl Contract{

    pub fn remove_user (&mut self, user_id : String) {

        Self::check_if_authorized();

        let user = self.users.get(&user_id);
        if user.is_none() {

            env::panic_str(format!("User {} not found", user_id).as_str());
     
        }

        self.users.remove(&user_id);
    }

    pub fn remove_all_users (&mut self) {
        
        Self::check_if_authorized();

        self.users.clear();
    }

}
'''
'''--- src/users_view.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    pub fn get_users (&self, offset:Option<usize>, limit:Option<usize>) -> Vec<User> {
        
        let u = self.users.values_as_vector()
        .iter()
        .skip(offset.unwrap_or(0))
        .take(limit.unwrap_or(10))
        .collect::<Vec<User>>();
        
        return u; 
    }

    pub fn get_user(&self, user_id : String ) -> Option<User>{

        return self.users.get(&user_id);
    }

    pub fn users_count(&self) -> usize {
        self.users.len() as usize 
    }

    pub fn has_user(&self, user_id : &String ) -> bool{
        self.users.get(&user_id).is_some()
    }

}
'''
'''--- term_tests1.txt ---
// To deploy contract
near deploy --accountId test_tm_users_contract.testnet --wasmFile target/wasm32-unknown-unknown/release/tm_users_contract.wasm 

// Delete account
near delete test_tm_users_contract.testnet ketyung.testnet

// To initialize the contract 
near call test_tm_users_contract.testnet init '{"collections_contract_id":"test_tm_collections_contract.testnet"}' --accountId test_tm_users_contract.testnet

// To add a user 
near call test_tm_users_contract.testnet signup_user '{"first_name":"Christopher", "last_name":"Chee"}' --accountId ketyung.testnet

near call test_tm_users_contract.testnet signup_user '{"first_name":"JK", "last_name":"Wong"}' --accountId jk_wong.testnet

near call test_tm_users_contract.testnet signup_user '{"first_name":"Pei Pei", "last_name":"Chang"}' --accountId peipei007.testnet

// To view all users 
near view test_tm_users_contract.testnet get_users

// Create collection
near call test_tm_users_contract.testnet create_collection_and_deploy '{"init_balance":21075,"collection":{"title":"Test NFT Collection 030", "symbol":"TCN030", "icon":"https://k2xpcad4sovv3myhkocu4h53g55kylfaticbna4luuejbzh6o5jq.arweave.net/Vq7xAHyTq12zB1OFTh-7N3qsLKCaBBaDi6UIkOT-d1M"}}' --deposit 21.5 --gas 300000000000000 --accountId ketyung.testnet

// Update description
near call test_tm_users_contract.testnet update_collection '{"title":"Test NFT Collection 030", "symbol":"TCN030","data_for_update":{"description":"This is the Test NFT Collection 030, which contains 50 Tickets"}}' --accountId ketyung.testnet

// update ticket types
near call test_tm_users_contract.testnet update_collection '{"title":"Test NFT Collection 030", "symbol":"TCN030","data_for_update":{"ticket_types":[{"ticket_type":"Standard","price":1350}]}}' --accountId ketyung.testnet

// update total tickets
near call test_tm_users_contract.testnet update_collection '{"title":"Test NFT Collection 030", "symbol":"TCN030","data_for_update":{"total_tickets":50}}' --accountId ketyung.testnet

// update category
near call test_tm_users_contract.testnet update_collection '{"title":"Test NFT Collection 030", "symbol":"TCN030","data_for_update":{"category":"Concert Ticket"}}' --accountId ketyung.testnet

// update the sales page template id
near call test_tm_users_contract.testnet update_collection '{"title":"Test NFT Collection 030", "symbol":"TCN030","data_for_update":{"attributes":[{"name":"SalesPageTemplate","value":"1"}]}}' --accountId ketyung.testnet

// update Max ticket per wallet
near call test_tm_users_contract.testnet update_collection '{"title":"Test NFT Collection 030", "symbol":"TCN030","data_for_update":{"attributes":[{"name": "MaxTicketPerWallet","value":"1"}]}}' --accountId ketyung.testnet

// update Venue
near call test_tm_users_contract.testnet update_collection '{"title":"Test NFT Collection 030", "symbol":"TCN030","data_for_update":{"attributes":[{"name": "Venue","value":"Kota Kinabalu"}]}}' --accountId ketyung.testnet

// update StartDate
near call test_tm_users_contract.testnet update_collection '{"title":"Test NFT Collection 030", "symbol":"TCN030","data_for_update":{"attributes":[{"name":"StartDate","value":"11/Nov/2022 19:30"}]}}' --accountId ketyung.testnet

// To generate next ticket number 
near call test_tm_users_contract.testnet gen_next_ticket_number '{"collection_id":{"title":"Test NFT Collection 030", "symbol":"TCN030", "owner":"ketyung.testnet"}}' --accountId peipei007.testnet

'''