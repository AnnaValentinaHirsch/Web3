*GitHub Repository "near/wasi-stub"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- README.md ---
# WASI-STUB

This tool takes a wasm file, replace all `wasi_snapshot_preview1` import to (stub) functions defines in the same module. This is useful when executing wasm in sandbox enviroment where wasi is not available.

## Build

First build binaryen with `cmake . && make -j`. Then:
```
./build.sh
```

## Use

```
./run.sh file.wasm
```

The tool will write file.wasm inplace.
'''
'''--- build.sh ---
#!/bin/sh

gcc -I../src wasi-stub.c -L../lib -lbinaryen -lpthread -lstdc++ -o wasi-stub

'''
'''--- run.sh ---
#!/bin/bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
SYSTEM=$(uname)
if [ "${SYSTEM}" = "Linux" ]; then
    export LD_LIBRARY_PATH="${SCRIPT_DIR}"/../lib
elif [ "${SYSTEM}" = "Darwin" ]; then
    export DYLD_LIBRARY_PATH="${SCRIPT_DIR}"/../lib
else
    echo "Unsupported system ${SYSTEM}"
    exit 1
fi
"${SCRIPT_DIR}/wasi-stub" $@

'''
'''--- wasi-stub.c ---
#include <binaryen-c.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
  if (argc < 2) {
    fprintf(stderr, "Usage: wasi-stub file.wasm\n");
    exit(1);
  }

  FILE *input;
  input = fopen(argv[1], "rb");
  if (input == NULL) {
    fprintf(stderr, "Unable to open %s\n", argv[1]);
    exit(1);
  }

  fseek( input, 0, SEEK_END );
  size_t size = ftell(input);
  fseek( input, 0, SEEK_SET );
  char *buf = (char*)malloc(size);
  if (buf == NULL) {
    fprintf(stderr, "Unable to alloc buffer to read.\n");
    exit(1);
  }
  fread(buf, size, 1, input);
  fclose(input);
  BinaryenModuleRef module = BinaryenModuleRead(buf, size);
  // Optimization, wasi imports are consequtive
  int visitWasi = 0;

  BinaryenIndex numFunctions = BinaryenGetNumFunctions(module);
  for (BinaryenIndex i = 0; i < numFunctions; i++) {
    BinaryenFunctionRef fid = BinaryenGetFunctionByIndex(module, i);
    if (strcmp(BinaryenFunctionImportGetModule(fid), "wasi_snapshot_preview1") == 0) {
      visitWasi = 1;
      printf("Find and stub wasi import: %s.\n", BinaryenFunctionImportGetBase(fid));
      BinaryenType retType = BinaryenFunctionGetResults(fid);
      BinaryenFunctionImportToFunction(fid);

      if (BinaryenTypeArity(retType) == 0) {
        BinaryenExpressionRef noop = BinaryenNop(module);
        BinaryenFunctionSetBody(fid, noop);        
      } else {
        BinaryenExpressionRef ret = BinaryenReturn(module, BinaryenConst(module, BinaryenLiteralInt32(76)));
        BinaryenFunctionSetBody(fid, ret);
      }
    } else if (visitWasi) {
      break;
    }
  }

  size_t output_size = 2*size;
  char* output_buf = (char*)malloc(output_size);
  if (output_buf == NULL) {
    fprintf(stderr, "Unable to alloc buffer to write.\n");
    exit(1);
  }
  size_t output_actual_size = BinaryenModuleWrite(module, output_buf, output_size);
  FILE *output;
  output = fopen(argv[1], "wb");
  if (output == NULL) {
    fprintf(stderr, "Unable to open %s for write\n", argv[1]);
    exit(1);
  }
  fwrite(output_buf, output_actual_size, 1, output);
  fclose(output);
  free(output_buf);

  // Clean up the module, which owns all the objects we created above
  BinaryenModuleDispose(module);
  free(buf);

  return 0;
}

'''