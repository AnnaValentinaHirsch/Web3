*GitHub Repository "alexkeating/moloch"*

'''--- .eslintrc.js ---
module.exports = {
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: "module",
    ecmaFeatures: {
      jsx: true
    }
  },
  rules: {
    semi: [2, "always"],
    indent: [2, "space"]
  }
};

'''
'''--- jest.config.js ---
module.exports = {
    testEnvironment: "node",
	testTimeout: 60000,
	globals: {
		Uint8Array: Uint8Array,
	},
};

'''
'''--- notes.txt ---
Minutes
pre estimate - 05/09 - 360 (6 hours) 
05/09 - 315 (5.25 hours) 
Lindas again 6 hours
2 hours
07/01 8 hours
07/21 35 hours
07/26 1 hour
07/28 1:20
07/30 1 hour
475 minutes
08/02 222:28.29 minutes

-- Constructor
- Test cases
- Test every assert in the constructor
- Test that the contract is initialized properly

-- Submit Proposal
- Test assert cases
- Test transfer goes to contract account
- Test empty queue
- Test queue with all proposals having started
- Make sure proposal is added to the queue

Questions:
Do we need a getter for proposals?

Todos:
- Add escrow asserts in tests
- Add escrow withdrawl
- Add storage and simulation test
- Add a couple more end to end tests

---- old
Minutes
pre estimate - 05/09 - 360 (6 hours) 
05/09 - 315 (5.25 hours) 
Lindas again 6 hours
07/01 8 hours
07/21 35 hours
07/26 1 hour

-- Constructor
- Test cases
- Test every assert in the constructor
- Test that the contract is initialized properly

-- Submit Proposal
- Test assert cases
- Test transfer goes to contract account
- Test empty queue
- Test queue with all proposals having started
- Make sure proposal is added to the queue

Questions:
Do we need a getter for proposals?

Todos:
- Add escrow asserts in tests
- Add escrow withdrawl
- Add storage and simulation test
- Add a couple more end to end tests

'''
'''--- test/moloch.test.js ---
const nearAPI = require("near-api-js");
const BN = require("bn.js");
const utils = require("./utils");
const { getOrCreateAccount, config } = utils;
require("dotenv").config();

const registerFdai = async (masterAccount, accountId, ftAccountId) => {
  await masterAccount.functionCall({
    contractId: ftAccountId,
    methodName: "storage_deposit",
    args: {
      account_id: accountId
    },
    attachedDeposit: nearAPI.utils.format.parseNearAmount(".01")
  });
};

const registerMoloch = async (masterAccount, accountId, molochAccountId) => {
  console.log(masterAccount);
  console.log(accountId);
  console.log(molochAccountId);
  console.log(nearAPI.utils.format.parseNearAmount(".1"));
  await masterAccount.functionCall({
    contractId: molochAccountId,
    methodName: "storage_deposit",
    args: {
      account_id: accountId,
      registration_only: false
    },
    attachedDeposit: nearAPI.utils.format.parseNearAmount("1")
  });
};

const transferFdai = async (masterAccount, accountId, amount, ftAccountId) => {
  await masterAccount.functionCall({
    contractId: ftAccountId,
    methodName: "ft_transfer",
    args: {
      receiver_id: accountId,
      amount: amount,
      memo: "transfer",
      msg: ""
    },
    attachedDeposit: "1",
    gas: 300000000000000
  });
};

const transferCallFdai = async (
  masterAccount,
  accountId,
  amount,
  ftAccountId
) => {
  await masterAccount.functionCall({
    contractId: ftAccountId,
    methodName: "ft_transfer_call",
    args: {
      receiver_id: accountId,
      amount: amount,
      memo: "transfer",
      msg: ""
    },
    attachedDeposit: "1",
    gas: 300000000000000
  });
};

const balanceOfFdai = async (masterAccount, accountId, ftAccountId) => {
  return await masterAccount.viewFunction(ftAccountId, "ft_balance_of", {
    account_id: accountId
  });
};

const getEscrowBalance = async (masterAccount, accountId, molochAccountId) => {
  return await masterAccount.viewFunction(
    molochAccountId,
    "get_escrow_user_balance",
    { account_id: accountId }
  );
};

const getBankBalance = async (masterAccount, molochAccountId) => {
  return await masterAccount.viewFunction(
    molochAccountId,
    "get_bank_balance",
    {}
  );
};

const getCurentPeriod = async (masterAccount, molochAccountId) => {
  return await masterAccount.viewFunction(
    molochAccountId,
    "get_current_period",
    {}
  );
};

const delay = ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

describe("Moloch test", () => {
  let alice;
  let aliceId;
  let bobId;
  let bob;
  let contractAccount;
  let proposalPeriod;

  const ftAccountId = `${process.env.FDAI_ACCOUNT_ID}.mrkeating.testnet`;
  const masterContractId = process.env.MASTER_ACCOUNT_ID;
  let contractAccountId = `${process.env.MOLOCH_ACCOUNT_ID}.${masterContractId}`;
  const now = Date.now();

  beforeAll(async () => {
    /// some users
    aliceId = "alice-" + now + "." + masterContractId;
    alice = await utils.getOrCreateAccount(aliceId);
    console.log("\n\n Alice accountId:", aliceId, "\n\n");

    bobId = "bob-" + now + "." + masterContractId;
    bob = await getOrCreateAccount(bobId);
    console.log("\n\n Bob accountId:", bobId, "\n\n");

    contractAccount = await getOrCreateAccount(contractAccountId);
    console.log("\n\n contract accountId:", contractAccountId, "\n\n");

    ftAccount = await getOrCreateAccount(ftAccountId);
    console.log("\n\n contract accountId:", ftAccountId, "\n\n");

    masterAccount = await getOrCreateAccount(masterContractId);
    console.log("\n\n master accountId:", masterContractId, "\n\n");

    contract = new nearAPI.Contract(
      contractAccount,
      config.contractName,
      config.contractMethods
    );
    ftContract = new nearAPI.Contract(ftAccount, "mrkeating.testnet", {
      changeMethods: ["ft_transfer", "ft_transfer_call"],
      viewMethods: ["ft_balance_of"]
    });

    // register
    await registerFdai(masterAccount, masterContractId, ftAccountId);
    await registerFdai(masterAccount, aliceId, ftAccountId);
    await registerFdai(masterAccount, contractAccountId, ftAccountId);
    await registerFdai(masterAccount, bobId, ftAccountId);

    await registerMoloch(masterAccount, masterContractId, contractAccountId);
    await registerMoloch(masterAccount, aliceId, contractAccountId);
    await registerMoloch(masterAccount, bobId, contractAccountId);

    await transferFdai(masterAccount, aliceId, "1000", ftAccountId);
    await transferCallFdai(alice, contractAccountId, "100", ftAccountId);
    await transferCallFdai(
      masterAccount,
      contractAccountId,
      "1000",
      ftAccountId
    );
  }, 120000);

  // Create a proposal for bob
  test("Create a proposal for the first member", async () => {
    await masterAccount.functionCall({
      contractId: contractAccountId,
      methodName: "submit_proposal",
      args: {
        applicant: aliceId,
        token_tribute: "10",
        shares_requested: "10",
        details: "Let's add a second member"
      },
      gas: 300000000000000
    });

    proposalPeriod = await getCurentPeriod(masterAccount, contractAccountId);

    // Check balances are correct
    // moloch balance 1100
    const molochBalance = await balanceOfFdai(
      masterAccount,
      contractAccountId,
      ftAccountId
    );
    expect(molochBalance).toEqual("1100");
    // alice balance 900
    const aliceBalance = await balanceOfFdai(
      masterAccount,
      aliceId,
      ftAccountId
    );

    expect(aliceBalance).toEqual("900");
    // Make sure the correct ammount is in escrow
    // Check queue length
    const bankBalance = await getBankBalance(masterAccount, contractAccountId);
    expect(bankBalance).toEqual("0");

    const escrowBalance = await getEscrowBalance(
      masterAccount,
      aliceId,
      contractAccountId
    );
    expect(escrowBalance).toEqual("90");

    const escrowBalanceMaster = await getEscrowBalance(
      masterAccount,
      masterContractId,
      contractAccountId
    );
    expect(escrowBalanceMaster).toEqual("990");
  });

  test("Vote yes on member proposal", async () => {
    // Wait one period
    await delay(1000 * 10);
    await masterAccount.functionCall({
      contractId: contractAccountId,
      methodName: "submit_vote",
      args: {
        proposal_index: "0", // change to 0
        uint_vote: 1
      }
    });

    let vote = await masterAccount.viewFunction(
      contractAccountId,
      "get_member_proposal_vote",
      {
        proposal_index: "0",
        member_id: masterContractId
      }
    );
    console.log("Vote");
    console.log(vote);
    console.log(proposalPeriod);
    expect(vote).toEqual("Yes");
  });

  test("Process passed proposal", async () => {
    process_period = parseInt(proposalPeriod) + 3;
    console.log(process_period);
    current_period = await getCurentPeriod(masterAccount, contractAccountId);
    console.log(current_period);
    let periodsLeft = process_period - parseInt(current_period);
    if (periodsLeft >= 0) {
      await delay(10000 * (periodsLeft + 1));
    }
    await bob.functionCall({
      contractId: contractAccountId,
      methodName: "process_proposal",
      args: {
        proposal_index: "0"
      },
      attachedDeposit: "1",
      gas: 300000000000000
    });

    const bankBalance = await getBankBalance(masterAccount, contractAccountId);
    expect(bankBalance).toEqual("10");

    const aliceBalance = await balanceOfFdai(
      masterAccount,
      aliceId,
      ftAccountId
    );

    expect(aliceBalance).toEqual("900");

    // Pay processing reward
    const bobBalance = await balanceOfFdai(masterAccount, bobId, ftAccountId);

    expect(bobBalance).toEqual("1");

    // Return proposal deposit
    const escrowBalanceMaster = await getEscrowBalance(
      masterAccount,
      masterContractId,
      contractAccountId
    );
    expect(escrowBalanceMaster).toEqual("999");

    const molochBalance = await balanceOfFdai(
      masterAccount,
      contractAccountId,
      ftAccountId
    );
    expect(molochBalance).toEqual("1099");
  }, 120000);

  // rage quit
  test("Rage quit", async () => {
    await alice.functionCall({
      contractId: contractAccountId,
      methodName: "rage_quit",
      args: {
        shares_to_burn: "5" // 5 of 11 total
      },
      attachedDeposit: "1",
      gas: 300000000000000
    });

    // check the correct amount is withdrawn and sent alice
    const bankBalance = await getBankBalance(masterAccount, contractAccountId);
    // TODO: Double check this rounding is okay
    expect(bankBalance).toEqual("6");
  });

  // withdraw
	test("Escrow withdraw", async () => {
    const start = await getEscrowBalance(masterAccount, aliceId, contractAccountId);
		console.log(start)
    await alice.functionCall({
      contractId: contractAccountId,
      methodName: "escrow_withdraw",
      args: {
        account_id: aliceId,
        amount: "20",
      },
      attachedDeposit: "1",
      gas: 300000000000000
    });

    const end = await getEscrowBalance(masterAccount, aliceId, contractAccountId);
    expect(start - end).toEqual(20);
	})

});

'''
'''--- test/utils.js ---
const fs = require("fs");
const BN = require("bn.js");
const nearAPI = require("near-api-js");
const {
  keyStores: { InMemoryKeyStore },
  Near,
  Account,
  Contract,
  KeyPair,
  utils: {
    format: { parseNearAmount }
  }
} = nearAPI;

const config = {
  explorerUrl: "https://explorer.testnet.near.org",
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  // walletUrl: 'http://localhost:1234',
  walletUrl: "https://wallet.testnet.near.org",
  helperUrl: "https://helper.testnet.near.org",
  GAS: "200000000000000",
  DEFAULT_NEW_ACCOUNT_AMOUNT: ".5",
  DEFAULT_NEW_CONTRACT_AMOUNT: "5",
  contractName: "mrkeating.testnet",
  contractMethods: {
    changeMethods: [
      "submit_proposal",
      "send_applicant_tribute",
      "submit_vote",
      "process_proposal",
      "rage_quit",
      "abort",
      "update_delegate_key"
    ],
    viewMethods: [
      "get_current_period",
      "get_member_proposal_vote",
      "has_voting_expired"
    ]
  }
};

console.log(
  "Loading Credentials:\n",
  `${process.env.HOME}/.near-credentials/${config.networkId}/${config.contractName}.json`
);

const serializedCreds = fs
  .readFileSync(
    `${process.env.HOME}/.near-credentials/${config.networkId}/${config.contractName}.json`
  )
  .toString();
const credentials = JSON.parse(serializedCreds);
const keyStore = new InMemoryKeyStore();
keyStore.setKey(
  config.networkId,
  config.contractName,
  KeyPair.fromString(credentials.private_key)
);

const near = new Near({
  networkId: config.networkId,
  nodeUrl: config.nodeUrl,
  deps: { keyStore }
});
const { connection } = near;

function generateUniqueSubAccount() {
  return `t${Date.now()}.${config.contractName}`;
}

async function createAccount(
  accountId,
  fundingAmount = config.DEFAULT_NEW_ACCOUNT_AMOUNT,
  secret
) {
  const contractAccount = new Account(connection, config.contractName);
  const newKeyPair = secret
    ? KeyPair.fromString(secret)
    : KeyPair.fromRandom("ed25519");
  await contractAccount.createAccount(
    accountId,
    newKeyPair.publicKey,
    new BN(parseNearAmount(fundingAmount))
  );
  keyStore.setKey(config.networkId, accountId, newKeyPair);
  return new nearAPI.Account(connection, accountId);
}

async function getOrCreateAccount(
  accountId,
  fundingAmount = config.DEFAULT_NEW_ACCOUNT_AMOUNT
) {
  accountId = accountId || generateUniqueSubAccount();
  const account = new nearAPI.Account(connection, accountId);
  try {
    await account.state();
    return account;
  } catch (e) {
    if (!/does not exist/.test(e.toString())) {
      throw e;
    }
  }
  return await createAccount(accountId, fundingAmount);
}

module.exports = {
  getOrCreateAccount,
  connection,
  config
};

'''