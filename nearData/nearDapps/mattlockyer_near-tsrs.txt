*GitHub Repository "mattlockyer/near-tsrs"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- README.md ---
# NEAR Protocol Smart Contract Boilerplate

üö®üö®üö® WARNING WIP üö®üö®üö®

It's not that bad...

## Instructions

Install rust: https://www.rust-lang.org/tools/install

`yarn && yarn test:deploy`

If no contract edits (only test changes) use `yarn test`

Review code in `/test/*` and don't bother me when it doesn't work üòè

'''
'''--- contract/Cargo.toml ---
[package]
name = "near-cbp"
version = "0.1.0"
authors = ["Matt Lockyer <mattdlockyer@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
wee_alloc = { version = "0.4.5", default-features = false }
near-sys = "0.2"
bs58 = { version = "0.4.0", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm

'''
'''--- contract/src/args.rs ---

use crate::*;

pub const DOUBLE_QUOTE: &str = "\"";
pub const COMMA: &str = ",";
pub const END_JSON: &str = "}";

pub fn get_string<'a>(data: &'a str, key: &str) -> &'a str {
    let (_, value) = expect(data.split_once(key));
    let (_, value) = expect(value.split_once(DOUBLE_QUOTE));
    let (value, _) = expect(value.split_once(DOUBLE_QUOTE));
    value
}

pub fn get_uint(data: &str, key: &str) -> u128 {
    let (_, value) = expect(data.split_once(key));
    let comma_value = value.split_once(COMMA);
    let value = if let Some(comma_value) = comma_value {
        let (value, _) = comma_value;
        value
    } else {
        let (value, _) = expect(value.split_once(END_JSON));
        value
    };
    expect(value.parse().ok())
}

#[macro_export]
macro_rules! get_arg {
    ($def:ident, $data:expr, $key:expr) => {
        $def($data, $key)
    };
}

'''
'''--- contract/src/lib.rs ---

		
#![cfg_attr(target_arch = "wasm32", no_std)]
#![cfg_attr(target_arch = "wasm32", feature(alloc_error_handler))]

#![allow(non_snake_case)]

#[cfg(target_arch = "wasm32")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[cfg(target_arch = "wasm32")]
#[panic_handler]
#[no_mangle]
pub unsafe fn on_panic(_info: &::core::panic::PanicInfo) -> ! {
    core::arch::wasm32::unreachable()
}

#[cfg(target_arch = "wasm32")]
#[alloc_error_handler]
#[no_mangle]
pub unsafe fn on_alloc_error(_: core::alloc::Layout) -> ! {
    core::arch::wasm32::unreachable()
}

const TEMP_REGISTER: u64 = 0;

extern crate alloc;
use near_sys;
use alloc::format;
use alloc::string::String;
use alloc::vec;
use alloc::vec::Vec;

mod sys;
use sys::*;
mod args;
use args::*;

		
pub type AccountId<'a> = &'a str;

		

#[no_mangle]

	pub fn init()  {
			
        unsafe { near_sys::input(TEMP_REGISTER) };
        let data = register_read(TEMP_REGISTER);
        let args = expect(alloc::str::from_utf8(&data).ok());

			let b = get_arg!(get_uint, args, "\"b\":");
			let a = get_arg!(get_uint, args, "\"a\":");
			let owner_id = get_arg!(get_string, args, "\"owner_id\":");

		let temp = owner_id;
		print(temp);
		storage_write("owner_id", temp);

		printNumber(a + b as u128);

		// let randomSeed2 = env.random_seed();
		// for (let unit of randomSeed2) {
		// 	printNumber(unit.into());
		// }
		

				let mut tmp_1888427484079 = env_read_register("signer_account_pk");
				tmp_1888427484079.remove(0);
				let mut tmp_2534813217114 = String::from("11111111111111111111111111111111111111111111");
				bs58::encode(&tmp_1888427484079).into(tmp_2534813217114.as_mut_str());
				

		let pk = tmp_2534813217114;

		log(&format!("{:?}", pk));

				unsafe {
					

let tmp_1660025143946 = "testnet";

let tmp_1842354673873 = "create_account";

let tmp_2633018514522 = format!("{{\"new_account_id\":\"abc-92845698376453.testnet\",\"new_public_key\":{:?},\"temp\":10000}}", pk);

let tmp_2049098496083 = 1000000000000000000000000 as u128;

let tmp_2521703196423 = 100000000000000 as u64;

					near_sys::promise_create(
						tmp_1660025143946.len() as u64,
						tmp_1660025143946.as_ptr() as u64,
						tmp_1842354673873.len() as u64,
						tmp_1842354673873.as_ptr() as u64,
						tmp_2633018514522.len() as u64,
						tmp_2633018514522.as_ptr() as u64,
						tmp_2049098496083.to_le_bytes().as_ptr() as u64,
						tmp_2521703196423,
					);
				}

		

		
		// print(owner_id);
		// printNumber(env.storage_usage().into());
		// print(env.predecessor_account_id());
		// print(env.current_account_id());
		// print(env.signer_account_id());
		// printArray(env.signer_account_pk());
		// printNumber(env.block_index().into());
		// printNumber(env.block_timestamp().into());
		// printNumber(env.used_gas().into());
		// printNumber(env.prepaid_gas().into());

		// let randomSeed = env.random_seed();
		// for (let mut i = 0; i < randomSeed.length; i+=4) {
		// 	// use .into() because randomSeed<u8> and printNumber takes u128
		// 	printNumber(randomSeed[i].into());
		// }

		// let randomSeed3 = env.random_seed();
		// for (let mut index in randomSeed3) {
		// 	printNumber(randomSeed3[index].into());
		// }

	

		}

	// public checkOwner() {
	// 	if (env.predecessor_account_id() != env.storage_read("owner_id")) {
	// 		env.panic();
	// 	}
	// }

#[no_mangle]

	fn print(owner_id: AccountId)  {
			
		log(&format!("String {:?}",  owner_id));
	
		}

#[no_mangle]

	fn printNumber(v: u128)  {
			
		log(&format!("Number {:?}",  v));
	
		}

	// printArray(v: Array<u8>) {
	// 	console.log("String", v);
	// }

	// public viewOwner(): AccountId {
	// 	let owner = env.storage_read("owner_id");
	// 	console.log(owner);
	// 	return owner;
	// }

		
'''
'''--- contract/src/sys.rs ---

use crate::*;

pub(crate) fn panic() -> ! {
    //* SAFETY: Assumed valid panic host function implementation
    unsafe { near_sys::panic() }
}

pub(crate) fn log(message: &str) {
    unsafe {
        near_sys::log_utf8(message.len() as _, message.as_ptr() as _);
    }
}

pub(crate) fn stringify(data: &[u8]) -> &str {
    expect(alloc::str::from_utf8(&data).ok())
}

/// helper function to panic on None types.
pub(crate) fn expect<T>(v: Option<T>) -> T {
    if cfg!(target_arch = "wasm32") {
        // Allowing because false positive
        #[allow(clippy::redundant_closure)]
        v.unwrap_or_else(|| panic())
    } else {
        v.unwrap()
    }
}

/// helper function to return strings
const DOUBLE_QUOTE_BYTE: u8 = b'"';
pub(crate) fn return_string(str: &str) {
    let mut ret = vec![DOUBLE_QUOTE_BYTE];
    ret.extend_from_slice(str.as_bytes());
    ret.push(DOUBLE_QUOTE_BYTE);
    unsafe {
        near_sys::value_return(ret.len() as u64, ret.as_ptr() as u64);
    }
}

/// helper function to read registers
pub(crate) fn register_read(id: u64) -> Vec<u8> {
    let len = unsafe { near_sys::register_len(id) };
    if len == u64::MAX {
        // Register was not found
        panic()
    }
    let data = vec![0u8; len as usize];

    //* SAFETY: Length of buffer is set dynamically based on "register_len" so it will always
    //* 		be sufficient length.
    unsafe { near_sys::read_register(id, data.as_ptr() as u64) };
    data
}

/// helper function to write storage
pub(crate) fn storage_write(key: &str, value: &str) {
    //* SAFETY: Assumes valid storage_write implementation.
    unsafe {
        near_sys::storage_write(
            key.len() as u64,
            key.as_ptr() as u64,
            value.len() as u64,
            value.as_ptr() as u64,
            TEMP_REGISTER,
        );
    }
}

/// helper function to read storage
pub(crate) fn storage_read(key: &str) -> Vec<u8> {
    let key_exists =
        unsafe { near_sys::storage_read(key.len() as u64, key.as_ptr() as u64, TEMP_REGISTER) };
    if key_exists == 0 {
        // Return code of 0 means storage key had no entry.
        sys::panic()
    }
    register_read(TEMP_REGISTER)
}

/// helper function to read env values that are u64 only
pub(crate) fn env_read(key: &str) -> u64 {
    unsafe {
        match key.as_bytes() {
            b"block_index" => near_sys::block_index(),
b"block_timestamp" => near_sys::block_timestamp(),
b"prepaid_gas" => near_sys::prepaid_gas(),
b"used_gas" => near_sys::used_gas(),
b"storage_usage" => near_sys::storage_usage(),
            _ => panic(),
        }
    }
}

/// helper function to read env values that need register read
pub(crate) fn env_read_register(key: &str) -> Vec<u8> {
    unsafe {
        match key.as_bytes() {
            b"predecessor_account_id" => near_sys::predecessor_account_id(TEMP_REGISTER),
b"current_account_id" => near_sys::current_account_id(TEMP_REGISTER),
b"signer_account_id" => near_sys::signer_account_id(TEMP_REGISTER),
b"signer_account_pk" => near_sys::signer_account_pk(TEMP_REGISTER),
b"random_seed" => near_sys::random_seed(TEMP_REGISTER),
            _ => panic(),
        };
    }
    register_read(TEMP_REGISTER)
}

'''
'''--- dep-parser/args.js ---
const DOUBLE_QUOTE = `\\"`
export const toJsonKey = (key) => `"${DOUBLE_QUOTE}${key}${DOUBLE_QUOTE}:"`
export const toString = (key) => `"${key}"`
export const toArgFunc = (key) => {
    switch (key) {
        case 'u128': return 'get_uint';
        default: return 'get_string'
    }
}

export const ARGS_BASE = `
use crate::*;

pub const DOUBLE_QUOTE: &str = "${DOUBLE_QUOTE}";
pub const COMMA: &str = ",";
pub const END_JSON: &str = "}";

pub fn get_string<'a>(data: &'a str, key: &str) -> &'a str {
    let (_, value) = expect(data.split_once(key));
    let (_, value) = expect(value.split_once(DOUBLE_QUOTE));
    let (value, _) = expect(value.split_once(DOUBLE_QUOTE));
    value
}

pub fn get_uint(data: &str, key: &str) -> u128 {
    let (_, value) = expect(data.split_once(key));
    let comma_value = value.split_once(COMMA);
    let value = if let Some(comma_value) = comma_value {
        let (value, _) = comma_value;
        value
    } else {
        let (value, _) = expect(value.split_once(END_JSON));
        value
    };
    expect(value.parse().ok())
}

#[macro_export]
macro_rules! get_arg {
    ($def:ident, $data:expr, $key:expr) => {
        $def($data, $key)
    };
}
`

export const READ_ARGS = `() {
        unsafe { near_sys::input(TEMP_REGISTER) };
        let data = register_read(TEMP_REGISTER);
        let args = expect(alloc::str::from_utf8(&data).ok());
`

'''
'''--- dep-parser/helpers.js ---

import dJSON from 'dirty-json';
import { READ_ARGS, toJsonKey, toArgFunc } from './args.js';
import { stripQuotes } from './types.js';
const CONSOLE_LOG = 'console.log'

/// parse helpers
const randVar = () => `tmp${Math.floor(Math.random()*1000000000000)}`
const getMethodBody = (data, v) => {
	let body = data.substring(data.indexOf(v))
	body = body.substring(body.indexOf('{') + 1)
	body = body.substring(0, body.indexOf(body.match(/\}\s+.+\(.*\)\s*\{/gi)[0]))
	return body
}

/// parsing the TS data

export const parseInto = (data) => data.replace(/\.into_u\d+\(\)/gi, '.into()')

export const parseComments = (data) => {
	data = data.split('\n')
		.filter((l) => !/\/\//gi.test(l))
		.join('\n')

	data = data.replace(/\/\*(.*)\*\//gs, '')

	return data
}

export const parseReturnParams = (data) => {
	data.match(/\w*\s*\(.*\):\s*\w*\s*{/gi)
	?.forEach((l) => {
		let body = getMethodBody(data, l)
		const replace = body

		data = data.replace(l, l.replace(/:.*\{/gi, ' {'))
		const isNumber = /u8|u64|u128/gi.test(l)
		
		body = body.split('\n').map((l) => {
			if (!/return/.test(l)) return l
			return l.replace('return ', 'return_string(').replace(';', ');')
		}).join('\n')
		data = data.replace(replace, body)
	})
	return data
}

export const parseMethodCalls = (data) => data
.replace(/this\./gi, '')

export const parseVariables = (data) => {

	
	return data
		.replace(/var/gi, 'let mut')
		.replace(/let/gi, 'let mut')
		.replace(/const/gi, 'let')
		.replace(/:\s*string/gi, '')
		.replace(/Array</gi, 'Vec<')
}

export const parseLogic = (data) => {
	const logicMatches = data.match(/if\s*\(.*\)\s{/gi)
	if (!logicMatches) return data

	logicMatches.forEach((l) => {
		const newLine = l.replace(/if\s*\(/gi, 'if ').replace(/\)\s*\{/gi, ' {')
		data = data.replace(l, newLine)
	})

	return data
}

export const parseLoops = (data) => {
	const loopMatches = data.match(/for\s*\(.*\)\s{/gi)
	if (!loopMatches) return data

	loopMatches.forEach((l) => {

		let newLoop = ''

		// for (let i = 0; i < randomSeed.length; i+=4) {
		if (/for\s*\(\s*let\s*.*=\s*\d+;/gi.test(l)) {
			const bits = l.split(';')
			const name = bits[0].split('let')[1].split('=')[0].trim()
			const start = bits[0].split('=')[1].trim()
			const end = bits[1].split('<')[1].trim()
			const step = /\+\+/.test(bits[2]) ? 1 : bits[2].split('=')[1].split(')')[0].trim()
			newLoop = `for ${name} in (${start}..${end}).step_by(${step}) {`.replace(/length/gi, 'len()');
		}

		// for (const unit of randomSeed) {
		if (/for\s+\(.*of.*\)/gi.test(l)) {
			const bits = l.split(' of ')
			const name = bits[0].split('(')[1].trim().split(' ')[1]
			const arr = bits[1].split(')')[0].trim()

			newLoop = `for ${name} in ${arr} {`;
		}

		// for (let index in randomSeed) {
		if (/for\s+\(.*in.*\)/gi.test(l)) {
			const bits = l.split(' in ')
			const name = bits[0].split('(')[1].trim().split(' ')[1]
			const arr = bits[1].split(')')[0].trim()

			newLoop = `for (${name}, _x) in ${arr}.iter().enumerate() {`;
		}

		data = data.replace(l, newLoop)
	})

	return data
}

export const parseConsole = (data) => {

	/// transforms all console.log("some string", arg, arg, arg)
	/// into log("some string {:?} {:?} {:?}", arg, arg, arg)
	while (data.indexOf(CONSOLE_LOG) > -1) {
		let match = data.substring(data.indexOf(CONSOLE_LOG))
		match = match.substring(0, match.indexOf(`)`) + 1)
		const inner = match.substring(match.indexOf(`(`) + 1, match.length - 1)
		let newInner = `"`
		let newInnerArgs = []
		inner.split(`,`).forEach((v, i) => {
			if (i == 0 && !/"|'|`/gi.test(v.trim().charAt(0))) {
				newInner += `{:?}`
				newInnerArgs.push(v)
			} else if (i > 0) {
				newInner += ` {:?}`
				newInnerArgs.push(v)
			} else {
				newInner += stripQuotes(v)
			}
		})
		newInner += `"` + (newInnerArgs.length > 0 ? `, ${newInnerArgs.join(',')}` : ``)

		data = data.replace(match, `log(&format!(${newInner}))`)
	}

	return data
}

export const parsePublicMethods = (data) => {
	/// parse public functions
	const methodSignatureMatches = data.match(/public\s+.+\(.*\)\s*.*\s*\{/gi).map((v) => v.trim())
	methodSignatureMatches.forEach((v, i) => {
		let body = getMethodBody(data, v)
		const replace = body

		const methodName = v.substring(0, v.indexOf('('))
		data = data.replace(methodName,
`
	#[no_mangle]
	pub fn${methodName.replace('public', '')}`
		)

		const paramMatch = v.substring(v.indexOf('('), v.indexOf('{') + 1)

		if (!/\(\)/gi.test(paramMatch)) {
			data = data.replace(paramMatch, '')
			body = READ_ARGS + body

			/// loop all params
			paramMatch.split(',').forEach((p) => {
				const [argName, argType] = p.split(':').map((v) => v.replace(/\(|\)|\{/gi, ``).trim())
				body = body.insertAfter(READ_ARGS, `
			let ${argName} = get_arg!(${toArgFunc(argType)}, args, ${toJsonKey(argName)});`
				)
			})
		}

		data = data.replace(replace, body)
	})

	return data
}

export const parseMethods = (data) => {
	/// parse public functions
	data.match(/\s+.+\(.*\)\s*.*\s*\{/gi)
		.filter((v) => !/public|for|if|switch/gi.test(v))
		.map((v) => v.trim())
		.forEach((v, i) => {
			data = data.insertBefore(v, 'fn ')
		})

	return data
}

export const parseEnvCalls = (data) => {
	data.match(/env\.\w*\([^\)]*/gim)
		.map((m) => (m + ')').trim())
		.forEach((m, i) => {
			const call = m.split('.')[1].split('(')[0]
			let args = m.split('(')[1].split(')')[0].trim()
			if (args.indexOf('{') === 0) {
				args = args.replace(/\s+as\s+u\d+/gi, '')
				args = dJSON.parse(args)
			} else {
				args = args.split(',')
			}

			switch (call) {
				// panic
				case 'panic': {
					data = data.replace(m, 'panic()')
				}
				break;
				// env_read_register
				case 'predecessor_account_id':
				case 'current_account_id':
				case 'signer_account_id': {
					data = data.replace(m, `stringify(&env_read_register("${call}"))`)
				}
				break;
				case 'signer_account_pk':
				case 'random_seed': {
					data = data.replace(m, `env_read_register("${call}")`)
				}
				break;
				// env_read (u64)
				case 'block_index': 
				case 'block_timestamp': 
				case 'used_gas': 
				case 'prepaid_gas': 
				case 'storage_usage': {
					data = data.replace(m, `env_read("${call}").into()`)
				}
				break;
				// more complex sys calls
				case 'storage_read': {
					const tmp = randVar()
					data = data.insertLineBefore(m, `let ${tmp} = &storage_read(${args[0]});`)
					data = data.replace(m, `stringify(${tmp})`)
				}
				break;
				case 'storage_write': {
					data = data.replace(m, `storage_write(${args[0]}, ${args[1]})`)
				}
				break;
				// promise calls
				case 'promise_batch_create': {
					const tmp = randVar()
					data = data.insertLineBefore(m, `
		let ${tmp} = ${args[0]};`)
					data = data.insertLineBefore(m, `
		unsafe {`);
					data = data.insertLineAfter(m, `
		}`);
					data = data.replace(v, `near_sys::promise_batch_create(${tmp}.len() as u64, ${tmp}.as_ptr() as u64)`)
				}
				break;
				case 'promise': {

					data = data.insertLineBefore(m, `
		unsafe {`)
					const vars = []

					Object.entries(args).forEach(([k, v]) => {
						const tmp = randVar()
						vars.push(tmp)
						let insert = `
			let ${tmp} = `
						switch (k) {
							case 'args': insert += `"${JSON.stringify(v).replaceAll(`"`, `\\"`)}"`; break;
							case 'amount': insert += `${v} as u128`; break;
							case 'gas': insert += `${v} as u64`; break;
							default: insert += `"${v}"`
						}
						insert += ';'
						data = data.insertLineBefore(m, insert)
					})

					let insert = `
			near_sys::promise_create(`
						for (let i = 0; i < 3; i++) {
							insert += `
				${vars[i]}.len() as u64,
				${vars[i]}.as_ptr() as u64,`
						}
						insert += `
				${vars[3]}.to_le_bytes().as_ptr() as u64,
				${vars[4]},
			)
		}`
					data = data.replace(m, insert)

					
				}
			}

		})

	return data
}
'''
'''--- dep-parser/index.js ---
import fs from 'fs';
import ts from "typescript";

import './utils.js';
import { ARGS_BASE } from './args.js';
import { SYS_BASE } from './sys.js';
import { LIB_BASE } from './lib.js';
import { TYPES_BASE } from './types.js';
import {
	parseInto,
	parseComments,
	parseReturnParams,
	parseVariables,
	parseLogic,
	parseLoops,
	parseEnvCalls,
	parseConsole,
	parseMethods,
	parseMethodCalls,
	parsePublicMethods,
} from './helpers.js';

const init = async () => {

	try {
		const data = fs.readFileSync('./src/index.ts', 'utf8');
		const ast = ts.createSourceFile('', data, ts.ScriptTarget.Latest)

		let ret = ``
		const contract = ast.statements.find(s => s.ClassDeclaration)
		const methods = contract.members.filter(m => typeof m === m.Meth)

		return
		
		// optional parse comments (they get parsed into Rust and might be mangled)
		data = parseComments(data)

		// extract contract body only
		data = data.substring(data.indexOf('implements NearContract'), data.lastIndexOf('}'))
		data = data.substring(data.indexOf('{') + 1)

		return ast
		// main helpers to translate TS -> RS
		data = parseInto(data)
		data = parseReturnParams(data)
		data = parseLogic(data)
		data = parseLoops(data)
		data = parseVariables(data)
		data = parseConsole(data)
		data = parseEnvCalls(data)
		data = parseMethods(data)
		data = parseMethodCalls(data)
		data = parsePublicMethods(data)
		// console.log(data)

		// write files
		const argsData = ARGS_BASE
		const sysData = SYS_BASE

		const libData = `
${LIB_BASE}
${TYPES_BASE}
${data}
`;

		try {
			fs.writeFileSync('./contract/src/args.rs', argsData);
			fs.writeFileSync('./contract/src/sys.rs', sysData);
			fs.writeFileSync('./contract/src/lib.rs', libData);
			// file written successfully
		} catch (err) {
			console.error(err);
		}

	} catch (err) {
		console.error(err);
	}

}

init()
'''
'''--- dep-parser/lib.js ---
export const LIB_BASE = `
#![cfg_attr(target_arch = "wasm32", no_std)]
#![cfg_attr(target_arch = "wasm32", feature(alloc_error_handler))]

#![allow(non_snake_case)]

#[cfg(target_arch = "wasm32")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[cfg(target_arch = "wasm32")]
#[panic_handler]
#[no_mangle]
pub unsafe fn on_panic(_info: &::core::panic::PanicInfo) -> ! {
    core::arch::wasm32::unreachable()
}

#[cfg(target_arch = "wasm32")]
#[alloc_error_handler]
#[no_mangle]
pub unsafe fn on_alloc_error(_: core::alloc::Layout) -> ! {
    core::arch::wasm32::unreachable()
}

const TEMP_REGISTER: u64 = 0;

extern crate alloc;
use near_sys;
use alloc::format;
use alloc::vec;
use alloc::vec::Vec;

mod sys;
use sys::*;
mod args;
use args::*;
`
'''
'''--- dep-parser/sys.js ---

export const SYS_BASE = `
use crate::*;

pub(crate) fn panic() -> ! {
    //* SAFETY: Assumed valid panic host function implementation
    unsafe { near_sys::panic() }
}

pub(crate) fn log(message: &str) {
    unsafe {
        near_sys::log_utf8(message.len() as _, message.as_ptr() as _);
    }
}

pub(crate) fn stringify(data: &[u8]) -> &str {
    expect(alloc::str::from_utf8(&data).ok())
}

/// helper function to panic on None types.
pub(crate) fn expect<T>(v: Option<T>) -> T {
    if cfg!(target_arch = "wasm32") {
        // Allowing because false positive
        #[allow(clippy::redundant_closure)]
        v.unwrap_or_else(|| panic())
    } else {
        v.unwrap()
    }
}

/// helper function to return strings
const DOUBLE_QUOTE_BYTE: u8 = b'\"';
pub(crate) fn return_string(str: &str) {
    let mut ret = vec![DOUBLE_QUOTE_BYTE];
    ret.extend_from_slice(str.as_bytes());
    ret.push(DOUBLE_QUOTE_BYTE);
    unsafe {
        near_sys::value_return(ret.len() as u64, ret.as_ptr() as u64);
    }
}

/// helper function to read registers
pub(crate) fn register_read(id: u64) -> Vec<u8> {
    let len = unsafe { near_sys::register_len(id) };
    if len == u64::MAX {
        // Register was not found
        panic()
    }
    let data = vec![0u8; len as usize];

    //* SAFETY: Length of buffer is set dynamically based on "register_len" so it will always
    //* 		be sufficient length.
    unsafe { near_sys::read_register(id, data.as_ptr() as u64) };
    data
}

/// helper function to write storage
pub(crate) fn storage_write(key: &str, value: &str) {
    //* SAFETY: Assumes valid storage_write implementation.
    unsafe {
        near_sys::storage_write(
            key.len() as u64,
            key.as_ptr() as u64,
            value.len() as u64,
            value.as_ptr() as u64,
            TEMP_REGISTER,
        );
    }
}

/// helper function to read storage
pub(crate) fn storage_read(key: &str) -> Vec<u8> {
    let key_exists =
        unsafe { near_sys::storage_read(key.len() as u64, key.as_ptr() as u64, TEMP_REGISTER) };
    if key_exists == 0 {
        // Return code of 0 means storage key had no entry.
        sys::panic()
    }
    register_read(TEMP_REGISTER)
}

/// helper function to read env values that are u64 only
pub(crate) fn env_read(key: &str) -> u64 {
    unsafe {
        match key.as_bytes() {
            ${
                [
                    'block_index',
                    'block_timestamp',
                    'prepaid_gas',
                    'used_gas',
                    'storage_usage',
                ].map((v) => `b"${v}" => near_sys::${v}()`).join(',\n')
            },
            _ => panic(),
        }
    }
}

/// helper function to read env values that need register read
pub(crate) fn env_read_register(key: &str) -> Vec<u8> {
    unsafe {
        match key.as_bytes() {
            ${
                [
                    'predecessor_account_id',
                    'current_account_id',
                    'signer_account_id',
                    'signer_account_pk',
                    'random_seed'
                ].map((v) => `b"${v}" => near_sys::${v}(TEMP_REGISTER)`).join(',\n')
            },
            _ => panic(),
        };
    }
    register_read(TEMP_REGISTER)
}
`

'''
'''--- dep-parser/types.js ---

export const TYPES_BASE = `
pub type AccountId<'a> = &'a str;
`
export const stripQuotes = (v) => v.replace(/`|"|'/gi, ``)
'''
'''--- dep-parser/utils.js ---
String.prototype.insertLineBefore = function (match, string) {
	const index = this.substring(0, this.indexOf(match)).lastIndexOf('\n');
	return this.substring(0, index) + string + this.substring(index) + `\n`;
};
String.prototype.insertLineAfter = function (match, string) {
	let index = this.indexOf(match);
	index += Math.max(this.substring(this.indexOf(match)).indexOf('\n'), match.length)
	return this.substring(0, index) + string + this.substring(index) + `\n`;
};
String.prototype.insertBeforeIndex = function (index, string) {
	return this.substring(0, index) + string + this.substring(index);
};
String.prototype.insertBefore = function (match, string) {
	return this.substring(0, this.indexOf(match)) + string + this.substring(this.indexOf(match));
};
String.prototype.insertAfter = function (match, string) {
	return this.substring(0, this.indexOf(match) + match.length) + string + this.substring(this.indexOf(match) + match.length);
};
'''
'''--- package.json ---
{
	"name": "near-cbp",
	"type": "module",
	"version": "1.0.0",
	"main": "index.js",
	"author": "mattlockyer",
	"license": "MIT",
	"devDependencies": {
		"@types/node": "^17.0.35",
		"ava": "^3.15.0",
		"eslint": "^8.6.0",
		"near-api-js": "^0.44.2",
		"ts-node": "^10.8.0",
		"typescript": "^4.7.2"
	},
	"scripts": {
		"test": "yarn parse && yarn build-contract && yarn dev-deploy && yarn ava",
		"test-np": "yarn build-contract && yarn dev-deploy && yarn ava",
		"parse": "ts-node --project tsconfig-parser.json --esm ./parser/index.ts",
		"old-parse": "node ./parser/index.js",
		"build-contract": "cd contract && ./build.sh && cd ..",
		"patch-config": "node ./utils/patch-config.js",
		"dev-deploy": "rm -rf neardev && (near dev-deploy || exit 0) && yarn patch-config",
		"ava": "ava test/contract.test.js -vs --timeout=5m",
		"fix": "eslint test/ --fix"
	}
}

'''
'''--- parser/helpers.ts ---
import ts, { PropertyAssignment } from 'typescript';
import { READ_ARGS, toJsonKey, toArgFunc } from './libs/args.js';
export const stripQuotes = (v) => v.replace(/`|"|'/gi, ``)
const randVar = () => `tmp_${Math.floor(Math.random()*1000000000000 + Date.now())}`

const removeMap = ['import', 'classDef']
export const removeSyntax = (code, sf) => {
	removeMap.forEach((arr) => {
		global.nodes[arr].forEach((node) => {
			let text = node.getText(sf)
			text = text.split('\n')[0]
			code = code.replace(text, ``)
		})
	})
	return code
}

export const straightReplace = (code, sf) => {
	code = code
	.replace(/let/gi, `let mut`)
	.replace(/const/gi, `let`)
	.replace(/this\./gi, ``)
	.replace(/.into_u\d+\(\)/gi, `.into()`)

	code = code.substring(0, code.lastIndexOf(`}`))

	return code
}

export const transformConsoleCall = (code, sf) => {

	global.nodes.consoleCall.forEach((node) => {
		const text = node.getText(sf)

		const inner = text.substring(text.indexOf(`(`) + 1, text.length - 1)
		let newText = `"`
		let newTextArgs = []
		inner.split(`,`).forEach((v, i) => {
			if (i == 0 && !/"|'|`/gi.test(v.trim().charAt(0))) {
				newText += `{:?}`
				newTextArgs.push(v)
			} else if (i > 0) {
				newText += ` {:?}`
				newTextArgs.push(v)
			} else {
				newText += stripQuotes(v)
			}
		})
		newText += `"` + (newTextArgs.length > 0 ? `, ${newTextArgs.join(',')}` : ``)

		code = code.replace(text, `log(&format!(${newText}))`)
	})

	return code

}

export const transformLoops = (code, sf) => {
	global.nodes.forLoop.forEach((node) => {
		let text = node.getText(sf)
		text = text.split(`\n`)[0]

		let newLoop = ''
		const bits = text.split(';')
		const name = bits[0].split('let')[1].split('=')[0].trim()
		const start = bits[0].split('=')[1].trim()
		const end = bits[1].split('<')[1].trim()
		const step = /\+\+/.test(bits[2]) ? 1 : bits[2].split('=')[1].split(')')[0].trim()
		newLoop = `for ${name} in (${start}..${end}).step_by(${step}) {`.replace(/length/gi, 'len()');

		code = code.replace(text, newLoop)
	})

	global.nodes.forOfLoop.forEach((node) => {
		let text = node.getText(sf)
		text = text.split(`\n`)[0]

		let newLoop = ''
		const bits = text.split(' of ')
		const name = bits[0].split('(')[1].trim().split(' ')[1]
		const arr = bits[1].split(')')[0].trim()
		newLoop = `for ${name} in ${arr} {`;

		code = code.replace(text, newLoop)
	})

	global.nodes.forInLoop.forEach((node) => {
		let text = node.getText(sf)
		text = text.split(`\n`)[0]

		let newLoop = ''
		const bits = text.split(' in ')
		const name = bits[0].split('(')[1].trim().split(' ')[1]
		const arr = bits[1].split(')')[0].trim()
		newLoop = `for (${name}, _x) in ${arr}.iter().enumerate() {`;

		code = code.replace(text, newLoop)
	})

	return code
}

export const parseJsonArgs = (node, sf, obj = {}): any => {
	node.properties.forEach((p) => {
		const prop = p as PropertyAssignment
		if (ts.isObjectLiteralExpression(prop.initializer)) {
			return obj[prop.name.getText(sf)] = parseJsonArgs(prop.initializer, sf)
		}
		if (ts.isIdentifier(prop.initializer)) {
			return obj[prop.name.getText(sf)] = '__IDENTIFIER__' + prop.initializer.getText(sf)
		}
		if (ts.isStringLiteral(prop.initializer)) {
			return obj[prop.name.getText(sf)] = '__STRING__' + prop.initializer.getText(sf)
		}
		return obj[prop.name.getText(sf)] = prop.initializer.getText(sf)
	})
	return obj
}

export const formatArg = (arg) => arg.replace(/__IDENTIFIER__|__STRING__/gi, ``)

export const formatJson = (json) => {
	let res = `format!("{{`;
	let vars: string[] = [];
	Object.entries(json).forEach(([k, v]) => {
		let val = stripQuotes(v)
		if (/__IDENTIFIER__/.test(val)) {
			vars.push(formatArg(val))
			val = `{:?}`
		}
		if (/__STRING__/.test(val)) {
			val = `\\"${formatArg(val)}\\"`
		}
		res += `\\"${k}\\":${val},`
	})
	res = res.substring(0, res.length - 1)
	return res += `}}", ${vars.join(',')})`
}

export const transformEnvCall = (code, sf) => {

	global.nodes.envCall.forEach((node) => {
		const text = node.getText(sf)
		const name = node.expression?.name?.getText(sf)
		let args = node.arguments?.map((n) => {
			if (ts.isObjectLiteralExpression(n)) {
				return parseJsonArgs(n, sf)
			}
			return n.getText(sf).toString()
		})

		// we don't want to convert this. method calls
		if (/this.|into_/gi.test(text)) return

		// default cases
		let newText = `env::${name}(`

		switch (name) {
			// storage
			case 'storage_read': {
				const tmp = randVar()
				code = code.insertLineBefore(text, `let ${tmp} = &storage_read(${args[0]});`)
				newText = `stringify(${tmp})`
			}
			break;
			case 'storage_write': {
				newText = `storage_write(${args[0]}, ${args[1]})`
			}
			break;
			// reading string env vars from registers
			case 'predecessor_account_id':
			case 'current_account_id':
			case 'signer_account_id': {
				newText = `stringify(&env_read_register("${name}"))`
			}
			break;
			case 'signer_account_pk_string': {
				const tmp = randVar()
				const tmp2 = randVar()
				code = code.insertLineBefore(text, `
				let mut ${tmp} = env_read_register("signer_account_pk");
				${tmp}.remove(0);
				let mut ${tmp2} = String::from("11111111111111111111111111111111111111111111");
				bs58::encode(&${tmp}).into(${tmp2}.as_mut_str());
				`)
				newText = tmp2
			}

// let mut pk_read = env_read_register("signer_account_pk");
// pk_read.remove(0);
// log(&format!("{:?}", pk_read.len()));

// let mut tmp_2378767290755 = String::from("6E8sCci9badyRkXb3JoRpBj5p8C6Tw41ELDZoiihKEtp||||");
// bs58::encode(pk_read).into(tmp_2378767290755.as_mut()).ok();
// let pk = format!("ed25519:{}", tmp_2378767290755.replace("|", ""));
// log(&format!("{:?}", pk.len()));

// log(&format!("{:?}", pk));

			break;
			// reading vec env vars from registers
			case 'signer_account_pk':
			case 'random_seed': {
				newText = `env_read_register("${name}")`
			}
			break;
			// reading u64 env vars
			case 'block_index': 
			case 'block_timestamp': 
			case 'used_gas': 
			case 'prepaid_gas': 
			case 'storage_usage': {
				newText = `env_read("${name}")`
			}
			break;

			case 'promise': {
				newText = ''
				code = code.insertLineBefore(text, `
				unsafe {
					`)

				args = args[0]
				const tmp = randVar()
				code = code.insertLineBefore(text, `let ${tmp} = ${formatArg(args.contractId)};`)
				const tmp2 = randVar()
				code = code.insertLineBefore(text, `let ${tmp2} = ${formatArg(args.methodName)};`)
				const tmp3 = randVar()
				code = code.insertLineBefore(text, `let ${tmp3} = ${formatJson(args.args)};`)
				const tmp4 = randVar()
				code = code.insertLineBefore(text, `let ${tmp4} = ${stripQuotes(formatArg(args.amount))} as u128;`)
				const tmp5 = randVar()
				code = code.insertLineBefore(text, `let ${tmp5} = ${stripQuotes(formatArg(args.gas))};`)

				code = code.insertLineBefore(text, `
					near_sys::promise_create(
						${tmp}.len() as u64,
						${tmp}.as_ptr() as u64,
						${tmp2}.len() as u64,
						${tmp2}.as_ptr() as u64,
						${tmp3}.len() as u64,
						${tmp3}.as_ptr() as u64,
						${tmp4}.to_le_bytes().as_ptr() as u64,
						${tmp5},
					);
				}`)
			}
			break;
			
			default:
				newText += `)`
		}

		if (!newText.length) {
			code = code.replace(text + ';', text)
		}
		code = code.replace(text, newText)
	})
	
	return code
}

export const transformMethod = (code, sf) => {
	global.nodes.method.forEach((node) => {
		const text = node.getText(sf)
		code = code.insertLineBefore(text, `#[no_mangle]`)
		let newText = /public/.test(text) ? text.replace(/public/gi, 'pub fn') : text.prefix('fn ')
		newText = newText.split('\n')[0].replace(/\{|\}/gi, ``)
		let newBody = node.body.getText(sf)
		newBody = newBody.substring(newBody.indexOf('{') + 1, newBody.lastIndexOf('}'))

		if (/pub/.test(newText)) {
			newText = newText.replace(/\(.*\)/gi, `()`)

			if (node.parameters.length) {
				newBody = READ_ARGS + newBody
			}

			node.parameters.forEach((param) => {
				const p = param.getText(sf)
				const [argName, argType] = p.split(':').map((v) => v.replace(/\(|\)|\{/gi, ``).trim())
				newBody = newBody.insertLineAfter(READ_ARGS, `
			let ${argName} = get_arg!(${toArgFunc(argType)}, args, ${toJsonKey(argName)});`
				)
			})
		}

		code = code.replace(text, `${newText} {
			${newBody}
		}`)
	})
	return code
}

'''
'''--- parser/index.ts ---
import './utils.js'
import * as fs from 'fs';
import ts, {
} from 'typescript';
import {
	indexNodes
} from './traverse.js'
import {
	removeSyntax,
	transformConsoleCall,
	transformEnvCall,
	transformMethod,
	transformLoops,
	straightReplace,
} from './helpers.js'

import { ARGS_BASE } from './libs/args.js';
import { SYS_BASE } from './libs/sys.js';
import { LIB_BASE } from './libs/lib.js';
import { TYPES_BASE } from './libs/types.js';

import './utils.js'

let nodes
const emptyNodes = {
	import: [],
	classDef: [],
	envCall: [],
	forLoop: [],
	forInLoop: [],
	forOfLoop: [],
	consoleCall: [],
	call: [],
	method: [],
};
const resetNodes = () => {
	nodes = global.nodes = JSON.parse(JSON.stringify(emptyNodes))
}
resetNodes()

const transform = (code, cb) => {
	resetNodes()
	const sf = ts.createSourceFile('', code, ts.ScriptTarget.Latest)
	ts.transform(sf, [indexNodes]);
	code = cb(code, sf)
	return code
}

const init = async () => {

	try {
		let code = fs.readFileSync('./src/index.ts', 'utf8');

		/// transform from inside calls out

		// code = parseConsole(code)

		code = transform(code, straightReplace)
		code = transform(code, transformEnvCall)
		code = transform(code, transformConsoleCall)
		code = transform(code, transformMethod)
		code = transform(code, transformLoops)
		code = transform(code, removeSyntax)

		// write files
		const argsData = ARGS_BASE
		const sysData = SYS_BASE

		const libData = `
		${LIB_BASE}
		${TYPES_BASE}
		${code}
		`;

		fs.writeFileSync('./contract/src/args.rs', argsData);
		fs.writeFileSync('./contract/src/sys.rs', sysData);
		fs.writeFileSync('./contract/src/lib.rs', libData);
		
		// // Create a Printer
		// const printer = ts.createPrinter({
		// 	newLine: ts.NewLineKind.LineFeed,
		// 	removeComments: false,
		// 	omitTrailingSemicolon: true
		// });
		// const output = printer.printFile(result.transformed[0])
		// 	// return
		// 	.replace(/\)\s*:/gi, ') ->')
		// 	// variables
		// 	.replace(/var/gi, 'let mut')
		// 	.replace(/let/gi, 'let mut')
		// 	.replace(/const/gi, 'let')
		// 	.replace(/:\s*string/gi, '')
		// 	.replace(/Array</gi, 'Vec<')

		// setTimeout(() => console.log(output), 2000)

		// if (!ast) {
		// 	return console.warn('ast could not be parsed for file')
		// }

		// const contract: ClassDeclaration = ast.statements
		// 	.find((s: Statement) => ts.isClassDeclaration(s)) as ClassDeclaration;
		// if (!contract) {
		// 	return console.warn('no contract class definition found')
		// }

		// const methods: MethodDeclaration[] = contract.members
		// 	.filter((m: ClassElement) => ts.isMethodDeclaration(m))
		// 	.map((m: ClassElement) => m as MethodDeclaration)
		// if (!methods.length) {
		// 	return console.warn('no contract methods were found')
		// }

		// data = parseMethods(data, methods)

	} catch (err) {
		console.error(err);
	}

}

init()
'''
'''--- parser/libs/args.js ---
const DOUBLE_QUOTE = `\\"`
export const toJsonKey = (key) => `"${DOUBLE_QUOTE}${key}${DOUBLE_QUOTE}:"`
export const toString = (key) => `"${key}"`
export const toArgFunc = (key) => {
    switch (key) {
        case 'u128': return 'get_uint';
        default: return 'get_string'
    }
}

export const ARGS_BASE = `
use crate::*;

pub const DOUBLE_QUOTE: &str = "${DOUBLE_QUOTE}";
pub const COMMA: &str = ",";
pub const END_JSON: &str = "}";

pub fn get_string<'a>(data: &'a str, key: &str) -> &'a str {
    let (_, value) = expect(data.split_once(key));
    let (_, value) = expect(value.split_once(DOUBLE_QUOTE));
    let (value, _) = expect(value.split_once(DOUBLE_QUOTE));
    value
}

pub fn get_uint(data: &str, key: &str) -> u128 {
    let (_, value) = expect(data.split_once(key));
    let comma_value = value.split_once(COMMA);
    let value = if let Some(comma_value) = comma_value {
        let (value, _) = comma_value;
        value
    } else {
        let (value, _) = expect(value.split_once(END_JSON));
        value
    };
    expect(value.parse().ok())
}

#[macro_export]
macro_rules! get_arg {
    ($def:ident, $data:expr, $key:expr) => {
        $def($data, $key)
    };
}
`

export const READ_ARGS = `
        unsafe { near_sys::input(TEMP_REGISTER) };
        let data = register_read(TEMP_REGISTER);
        let args = expect(alloc::str::from_utf8(&data).ok());
`

'''
'''--- parser/libs/lib.js ---
export const LIB_BASE = `
#![cfg_attr(target_arch = "wasm32", no_std)]
#![cfg_attr(target_arch = "wasm32", feature(alloc_error_handler))]

#![allow(non_snake_case)]

#[cfg(target_arch = "wasm32")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[cfg(target_arch = "wasm32")]
#[panic_handler]
#[no_mangle]
pub unsafe fn on_panic(_info: &::core::panic::PanicInfo) -> ! {
    core::arch::wasm32::unreachable()
}

#[cfg(target_arch = "wasm32")]
#[alloc_error_handler]
#[no_mangle]
pub unsafe fn on_alloc_error(_: core::alloc::Layout) -> ! {
    core::arch::wasm32::unreachable()
}

const TEMP_REGISTER: u64 = 0;

extern crate alloc;
use near_sys;
use alloc::format;
use alloc::string::String;
use alloc::vec;
use alloc::vec::Vec;

mod sys;
use sys::*;
mod args;
use args::*;
`
'''
'''--- parser/libs/sys.js ---

export const SYS_BASE = `
use crate::*;

pub(crate) fn panic() -> ! {
    //* SAFETY: Assumed valid panic host function implementation
    unsafe { near_sys::panic() }
}

pub(crate) fn log(message: &str) {
    unsafe {
        near_sys::log_utf8(message.len() as _, message.as_ptr() as _);
    }
}

pub(crate) fn stringify(data: &[u8]) -> &str {
    expect(alloc::str::from_utf8(&data).ok())
}

/// helper function to panic on None types.
pub(crate) fn expect<T>(v: Option<T>) -> T {
    if cfg!(target_arch = "wasm32") {
        // Allowing because false positive
        #[allow(clippy::redundant_closure)]
        v.unwrap_or_else(|| panic())
    } else {
        v.unwrap()
    }
}

/// helper function to return strings
const DOUBLE_QUOTE_BYTE: u8 = b'\"';
pub(crate) fn return_string(str: &str) {
    let mut ret = vec![DOUBLE_QUOTE_BYTE];
    ret.extend_from_slice(str.as_bytes());
    ret.push(DOUBLE_QUOTE_BYTE);
    unsafe {
        near_sys::value_return(ret.len() as u64, ret.as_ptr() as u64);
    }
}

/// helper function to read registers
pub(crate) fn register_read(id: u64) -> Vec<u8> {
    let len = unsafe { near_sys::register_len(id) };
    if len == u64::MAX {
        // Register was not found
        panic()
    }
    let data = vec![0u8; len as usize];

    //* SAFETY: Length of buffer is set dynamically based on "register_len" so it will always
    //* 		be sufficient length.
    unsafe { near_sys::read_register(id, data.as_ptr() as u64) };
    data
}

/// helper function to write storage
pub(crate) fn storage_write(key: &str, value: &str) {
    //* SAFETY: Assumes valid storage_write implementation.
    unsafe {
        near_sys::storage_write(
            key.len() as u64,
            key.as_ptr() as u64,
            value.len() as u64,
            value.as_ptr() as u64,
            TEMP_REGISTER,
        );
    }
}

/// helper function to read storage
pub(crate) fn storage_read(key: &str) -> Vec<u8> {
    let key_exists =
        unsafe { near_sys::storage_read(key.len() as u64, key.as_ptr() as u64, TEMP_REGISTER) };
    if key_exists == 0 {
        // Return code of 0 means storage key had no entry.
        sys::panic()
    }
    register_read(TEMP_REGISTER)
}

/// helper function to read env values that are u64 only
pub(crate) fn env_read(key: &str) -> u64 {
    unsafe {
        match key.as_bytes() {
            ${
                [
                    'block_index',
                    'block_timestamp',
                    'prepaid_gas',
                    'used_gas',
                    'storage_usage',
                ].map((v) => `b"${v}" => near_sys::${v}()`).join(',\n')
            },
            _ => panic(),
        }
    }
}

/// helper function to read env values that need register read
pub(crate) fn env_read_register(key: &str) -> Vec<u8> {
    unsafe {
        match key.as_bytes() {
            ${
                [
                    'predecessor_account_id',
                    'current_account_id',
                    'signer_account_id',
                    'signer_account_pk',
                    'random_seed'
                ].map((v) => `b"${v}" => near_sys::${v}(TEMP_REGISTER)`).join(',\n')
            },
            _ => panic(),
        };
    }
    register_read(TEMP_REGISTER)
}
`

'''
'''--- parser/libs/types.js ---

export const TYPES_BASE = `
pub type AccountId<'a> = &'a str;
`
export const stripQuotes = (v) => v.replace(/`|"|'/gi, ``)
'''
'''--- parser/traverse.ts ---
import ts, {
	Node,
	Visitor,
	SourceFile,
	TransformerFactory,
} from 'typescript';

const map = [
	{ is: ts.isImportDeclaration, arr: 'import' },
	{ is: ts.isClassDeclaration, arr: 'classDef' },
	{ is: ts.isMethodDeclaration, arr: 'method' },
	{ is: ts.isForOfStatement, arr: `forOfLoop`},
	{ is: ts.isForInStatement, arr: `forInLoop`},
	{ is: ts.isForStatement, arr: `forLoop`},
]

export const indexNodes: TransformerFactory<SourceFile> = (ctx) => {
	
	const { factory: f } = ctx
	const nodes = global.nodes

	const visit: Visitor = (node: Node) => {
		// console.log(node.getText(sf))

		map.forEach(({ is, arr }) => {
			if (is(node)) {
				nodes[arr].push(node)
			}
		})

		if (ts.isCallExpression(node)) {
			const text = node.getText(sf)
			if (/console\./gi.test(text)) nodes.consoleCall.push(node);
			else if (/env\./gi.test(text)) nodes.envCall.push(node);
			else nodes.call.push(node);	
		}

		return ts.visitEachChild(node, visit, ctx)
	}
	
	let sf
	return (_sf) => {
		sf = _sf
		return ts.visitEachChild(_sf, visit, ctx)
	}
}
    

// if (ts.isMethodDeclaration(node)) {

// 	// console.log(node.getText(sf))

// 	let newName = node.name.getText(sf).prefix('fn ');

// 	/// mut
// 	node.modifiers?.forEach((s) => {
// 		if (s.getText(sf) !== 'public') return
// 		newName = newName.prefix('pub ')
// 	});

// 	node = f.updateMethodDeclaration(
// 		node,
// 		node.decorators,
// 		null,
// 		node.asteriskToken,
// 		f.createIdentifier(newName),
// 		node.questionToken,
// 		node.typeParameters,
// 		node.parameters,
// 		node.type,
// 		node.body
// 	)

// 	return node
// }
'''
'''--- parser/utils.ts ---

declare global {
	interface String {
		prefix(str: string): string;
		insertLineBefore(match: string, str: string): string;
		insertLineAfter(match: string, str: string): string;
	}
}

String.prototype.insertLineBefore = function (match: string, str: string): string {
	const index = this.substring(0, this.indexOf(match)).lastIndexOf('\n');
	return this.substring(0, index) + '\n' + str + '\n' + this.substring(index);
};

String.prototype.insertLineAfter = function (match: string, str: string): string {
	let index = this.indexOf(match);
	index += Math.max(this.substring(this.indexOf(match)).indexOf('\n'), match.length)
	return this.substring(0, index) + str + this.substring(index) + `\n`;
};

String.prototype.prefix = function (str: string): string {
	return str + this
};

export {}

'''
'''--- src/index.ts ---
import { AccountId, u128, u64, u8 } from './lib/types'
import { NearContract, env } from './lib/NearContract'

export class Contract implements NearContract {

	public init(owner_id: AccountId, a: u128, b: u128) {

		const temp = owner_id;
		this.print(temp);
		env.storage_write("owner_id", temp);

		this.printNumber(a + b as u128);

		// const randomSeed2 = env.random_seed();
		// for (const unit of randomSeed2) {
		// 	this.printNumber(unit.into_u128());
		// }
		
		const pk = env.signer_account_pk_string();

		console.log(pk);

		env.promise({
			contractId: "testnet",
			methodName: "create_account",
			args: {
				new_account_id: "abc-92845698376453.testnet",
				new_public_key: pk,
				temp: 10000,
			},
			amount: '1000000000000000000000000',
			gas: 100000000000000 as u64,
		});

		
		// this.print(owner_id);
		// this.printNumber(env.storage_usage().into_u128());
		// this.print(env.predecessor_account_id());
		// this.print(env.current_account_id());
		// this.print(env.signer_account_id());
		// this.printArray(env.signer_account_pk());
		// this.printNumber(env.block_index().into_u128());
		// this.printNumber(env.block_timestamp().into_u128());
		// this.printNumber(env.used_gas().into_u128());
		// this.printNumber(env.prepaid_gas().into_u128());

		// const randomSeed = env.random_seed();
		// for (let i = 0; i < randomSeed.length; i+=4) {
		// 	// use .into() because randomSeed<u8> and printNumber takes u128
		// 	this.printNumber(randomSeed[i].into_u128());
		// }

		// const randomSeed3 = env.random_seed();
		// for (let index in randomSeed3) {
		// 	this.printNumber(randomSeed3[index].into_u128());
		// }

	}

	// public checkOwner() {
	// 	if (env.predecessor_account_id() != env.storage_read("owner_id")) {
	// 		env.panic();
	// 	}
	// }

	print(owner_id: AccountId) {
		console.log("String", owner_id);
	}

	printNumber(v: u128) {
		console.log("Number", v);
	}

	// printArray(v: Array<u8>) {
	// 	console.log("String", v);
	// }

	// public viewOwner(): AccountId {
	// 	const owner = env.storage_read("owner_id");
	// 	console.log(owner);
	// 	return owner;
	// }

}

'''
'''--- src/lib/NearContract.ts ---
import { AccountId, u8, u64, u128 } from './types'

export interface NearContract {
	init(...args: any[]): void;
}

export const env = {
	// helper functions
	panic: (): void => {},
	// storage
	storage_write: (key: string, value: string | number) => {},
	storage_read: (key: string): string => '',
	// env_read_register
	predecessor_account_id: (): string => '',
	current_account_id: (): string => '',
	signer_account_id: (): string => '',
	signer_account_pk: (): Array<u8> => [],
	signer_account_pk_string: (): string => '',
	random_seed: (): Array<u8> => [],
	// env_read (u64)
	block_index: (): u64 => 0 as u64,
	block_timestamp: (): u64 => 0 as u64,
	prepaid_gas: (): u64 => 0 as u64,
	used_gas: (): u64 => 0 as u64,
	storage_usage: (): u64 => 0 as u64,
	// env promises
	promise_batch_create: (account: AccountId): u64 => 0 as u64,
	promise_batch_action_function_call: (
		promise_index: u64,
		method_name: string,
		args: object,
		amount: u128,
		gas: u64,
	) => {},
	// trying a simple promise
	promise: (args: {
		contractId: AccountId,
		methodName: string,
		args: object,
		amount: string,
		gas: u64,
	}) => {}
}
'''
'''--- src/lib/types.ts ---
export type AccountId = string;

type uint8<K, T> = K & ({ __uint8: T })
type uint64<K, T> = K & ({ __uint64: T })
type uint128<K, T> = K & ({ __uint128: T })

export type u8 = uint8<number, "u8">
export type u64 = uint64<number, "u64">
export type u128 = uint128<number, "u128">

declare global {
	interface Number {
		into_u8(): u8;
		into_u64(): u64;
		into_u128(): u128;
	}
}

Number.prototype.into_u8 = function(): u8 {
	return this.valueOf() as u8
}

Number.prototype.into_u64 = function(): u64 {
	return this.valueOf() as u64
}

Number.prototype.into_u128 = function(): u128 {
	return this.valueOf() as u128
}

'''
'''--- test/contract.test.js ---
import test from 'ava'
import {
	contractAccount,
} from './test-utils.js'
import getConfig from "../utils/config.js";
const {
	contractId,
	gas,
	attachedDeposit,
} = getConfig();

// test.beforeEach((t) => {
// });

test('contract init', async (t) => {
	try {
		await contractAccount.functionCall({
			contractId,
			methodName: 'init',
			args: {
				owner_id: contractId,
				a: 21,
				b: 21,
			},
			gas
		});
		t.true(true);
	} catch (e) {
		console.warn(e)
		t.true(false);
	}
});

// test('contract checkOwner', async (t) => {
// 	try {
// 		await contractAccount.functionCall({
// 			contractId,
// 			methodName: 'checkOwner',
// 			args: {},
// 			gas
// 		});
// 		t.true(true);
// 	} catch (e) {
// 		console.warn(e)
// 		t.true(false);
// 	}
// });

// test('contract viewOwner', async (t) => {
// 	try {
// 		const owner = await contractAccount.viewFunction(contractId, 'viewOwner')
// 		t.is(owner, contractId)
// 	} catch (e) {
// 		console.warn(e)
// 		t.true(false);
// 	}
// });
'''
'''--- test/test-utils.js ---
import fs from 'fs';
import BN from 'bn.js'
import * as nearAPI from 'near-api-js'
import { connection, keyStore, contractAccount } from '../utils/near-utils.js';
import getConfig from '../utils/config.js'
const {
	networkId, contractId, gas,
	NEW_ACCOUNT_AMOUNT,
} = getConfig();
const { 
	KeyPair,
	utils: { format: {
		formatNearAmount
	} }
} = nearAPI;

const init = async (owner_id = contractId) => {
	/// try to call new on contract, swallow e if already initialized
	try {
		await contractAccount.functionCall({
			contractId,
			methodName: 'init',
			args: {
				owner_id
			},
			gas
		});
	} catch (e) {
		console.log('contract already initialized');
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return contractAccount;
};

const getAccount = async (accountId, fundingAmount = NEW_ACCOUNT_AMOUNT, secret) => {
	const account = new nearAPI.Account(connection, accountId);
	try {
		const secret = await fs.readFileSync(`./neardev/${accountId}`, 'utf-8');
		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
		await account.state();
		return account;
	} catch(e) {
		if (!/no such file|does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount, secret);
};

const createAccount = async (accountId, fundingAmount = NEW_ACCOUNT_AMOUNT, secret) => {
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	fs.writeFileSync(`./neardev/${accountId}` , newKeyPair.toString(), 'utf-8');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, fundingAmount);
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
};

/// debugging

const getAccountBalance = (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();
const getAccountState = (accountId) => (new nearAPI.Account(connection, accountId)).state();
const stateCost = (balanceBefore, balanceAfter) => formatNearAmount(new BN(balanceAfter.stateStaked).sub(new BN(balanceBefore.stateStaked)).toString(), 8);
const bytesUsed = (stateBefore, stateAfter) => parseInt(stateAfter.storage_usage, 10) - parseInt(stateBefore.storage_usage);

/// analyzing

let data = {};
const recordStart = async (accountId) => {
	data[accountId] = {
		balance: await getAccountBalance(accountId),
		state: await getAccountState(accountId),
	};
};

const recordStop = async (accountId) => {
	const before = data[accountId];
	const after = {
		balance: await getAccountBalance(accountId),
		state: await getAccountState(accountId),
	};

	console.log('\nAnalysis:\n');
	console.log('State stake:', stateCost(before.balance, after.balance));
	console.log('Bytes used:', bytesUsed(before.state, after.state));
	console.log('\n');
};

export {
	init,
	getAccount,
	contractAccount,
	createAccount,
	getAccountBalance,
	getAccountState,
	stateCost,
	bytesUsed,
	recordStart,
	recordStop,
};
'''
'''--- tsconfig-parser.json ---
{
	"compilerOptions": {
		"module": "es6",
		"moduleResolution": "node16",
	}
}
'''
'''--- tsconfig.json ---
{
	"compilerOptions": {
		"module": "system",
		"strict": true,
		"allowJs": false,
		"allowUnreachableCode": false,
		"allowUnusedLabels": false,
		"alwaysStrict": true,
		"exactOptionalPropertyTypes": true,
		"noImplicitReturns": true,
		"noImplicitThis": true,
		"noFallthroughCasesInSwitch": true,
		"noUncheckedIndexedAccess": false,
		"noImplicitAny": true,
		"noUnusedLocals": true,
		"noUnusedParameters": true,
	},
	"include": [
		"src/**/*"
	],
	"exclude": [
		"node_modules",
		"**/*.spec.ts"
	]
}
'''
'''--- utils/config.js ---
const contractName = 'dev-1655854028674-33841384752670';

export default function getConfig(network = 'testnet') {
	let config = {
		networkId: "testnet",
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
	};

	switch (network) {
	case 'testnet':
		config = {
			explorerUrl: "https://explorer.testnet.near.org",
			...config,
			GAS: "200000000000000",
			gas: "200000000000000",
			attachedDeposit: '10000000000000000000000', // 0.01 N (1kb storage)
			NEW_ACCOUNT_AMOUNT: '1000000000000000000000000',
			NEW_CONTRACT_AMOUNT: '5000000000000000000000000',
			contractId: contractName,
			isBrowser: new Function("try {return this===window;}catch(e){ return false;}")(),
		};
		break;
	}

	return config;
};

'''
'''--- utils/near-utils.js ---
import fs from 'fs'
import * as nearAPI from 'near-api-js'
import getConfig from './config.js'
const { nodeUrl, walletUrl, networkId, contractId, isBrowser } = getConfig();

const {
	keyStores: { InMemoryKeyStore, BrowserLocalStorageKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

let credentials, keyStore;

if (isBrowser) {
	keyStore = new BrowserLocalStorageKeyStore();
} else {
	/// nodejs (for tests)
	try {
		console.log(`Loading Credentials: ${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`
			)
		);
	} catch(e) {
		console.warn(`Loading Credentials: ./neardev/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`./neardev/${networkId}/${contractId}.json`
			)
		);
	}
	keyStore = new InMemoryKeyStore();
	keyStore.setKey(
		networkId,
		contractId,
		KeyPair.fromString(credentials.private_key)
	);
}

const near = new Near({
	networkId,
	nodeUrl,
	walletUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractId);

export {
	near,
	credentials,
	keyStore,
	connection,
	contractId,
	contractAccount,
};

'''
'''--- utils/patch-config.js ---
import fs from 'fs'
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './utils/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''