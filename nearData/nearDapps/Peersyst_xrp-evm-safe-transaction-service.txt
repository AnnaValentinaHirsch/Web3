*GitHub Repository "Peersyst/xrp-evm-safe-transaction-service"*

'''--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: bug

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Do POST on '...'
  - Provide `json` you are submitting to the service (if it applies)
2. Then GET on '....'
3. Links to issues in other repos (if possible)

**Expected behavior**
A clear and concise description of what you expected to happen.

**Environment (please complete the following information):**
 - Staging or production?
 - Which chain?
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

'''
'''--- .github/ISSUE_TEMPLATE/feature_request.md ---
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: enhancement

---

# What is needed?
A clear and concise description of what you want to happen.

# Background
More information about the feature needed

# Related issues
Paste here the related links for the issues on the clients/safe project if applicable. Please provide at least one of the following:
- Links to epics in your repository
- Images taken from mocks
- Gitbook or any form of written documentation links, etc. Any of these alternatives will help us contextualise your request.

# Endpoint
If applicable, description on the endpoint and the result you expect:

## URL
`GET /api/v1/safes/<address>/creation/`

## Response
```
{
  created: "<iso 8601 datetime>",
  transactionHash: "<keccak-hash>",
  creator: "<checksummed-address>"
}
```

'''
'''--- .github/PULL_REQUEST_TEMPLATE.md ---
### Make sure these boxes are checked! ðŸ“¦âœ…

- [ ] You ran `./run_tests.sh`
- [ ] You ran `pre-commit run -a`
- [ ] If you want to add your network to `setup_service.py`, provide a link to your
    [safe-deployments PR](https://github.com/safe-global/safe-deployments/pulls) and check network name
    exists in [safe-eth-py](https://github.com/safe-global/safe-eth-py/blob/master/gnosis/eth/ethereum_network.py)

### What was wrong? ðŸ‘¾

Closes #

### How was it fixed? ðŸŽ¯

'''
'''--- .github/dependabot.yml ---
version: 2
updates:
  - package-ecosystem: pip
    directory: "/"
    schedule:
      interval: weekly
      day: monday
    reviewers:
      - "uxio0"

  - package-ecosystem: docker
    directory: "/docker/web"
    schedule:
      interval: weekly
      day: monday
    reviewers:
      - "uxio0"

  - package-ecosystem: github-actions
    directory: "/"
    schedule:
      interval: weekly
      day: monday
    reviewers:
      - "uxio0"

'''
'''--- .github/workflows/cla.yml ---
name: "CLA Assistant"
on:
  issue_comment:
    types: [ created ]
  pull_request_target:
    types: [ opened,closed,synchronize ]

jobs:
  CLAssistant:
    runs-on: ubuntu-latest
    steps:
      - name: "CLA Assistant"
        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'
        # Beta Release
        uses: cla-assistant/github-action@v2.2.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # the below token should have repo scope and must be manually added by you in the repository's secret
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        with:
          path-to-signatures: 'signatures/version1/cla.json'
          path-to-document: 'https://safe.global/cla/'
          # branch should not be protected
          branch: 'cla-signatures'
          allowlist: hectorgomezv,moisses89,luarx,fmrsabino,luarx,rmeissner,Uxio0,*bot # may need to update this expression if we add new bots

          #below are the optional inputs - If the optional inputs are not given, then default values will be taken
          #remote-organization-name: enter the remote organization name where the signatures should be stored (Default is storing the signatures in the same repository)
          #remote-repository-name:  enter the  remote repository name where the signatures should be stored (Default is storing the signatures in the same repository)
          #create-file-commit-message: 'For example: Creating file for storing CLA Signatures'
          #signed-commit-message: 'For example: $contributorName has signed the CLA in #$pullRequestNo'
          #custom-notsigned-prcomment: 'pull request comment with Introductory message to ask new contributors to sign'
          #custom-pr-sign-comment: 'The signature to be committed in order to sign the CLA'
          #custom-allsigned-prcomment: 'pull request comment when all contributors has signed, defaults to **CLA Assistant Lite bot** All Contributors have signed the CLA.'
          #lock-pullrequest-aftermerge: false - if you don't want this bot to automatically lock the pull request after merging (default - true)
          #use-dco-flag: true - If you are using DCO instead of CLA

'''
'''--- .github/workflows/python.yml ---
name: Python CI
on: [push, pull_request]

jobs:
  linting:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10"]

    steps:
      - uses: actions/checkout@v3
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install dependencies
        run: pip install pre-commit
      - name: Run pre-commit
        run: pre-commit run --all-files

  test-app:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10"]
    services:
      redis:
        image: redis
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
    - name: Setup and run ganache
      run: |
        docker run --detach --publish 8545:8545 --network-alias ganache -e DOCKER=true trufflesuite/ganache:latest --defaultBalanceEther 10000 --gasLimit 10000000 -a 30 --chain.chainId 1337 --chain.networkId 1337 -d
    - uses: actions/checkout@v3
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'
        cache-dependency-path: 'requirements*.txt'
    - name: Install dependencies
      run: |
        pip install wheel
        pip install -r requirements-test.txt coveralls
      env:
        PIP_USE_MIRRORS: true
    - name: Run tests and coverage
      run: |
        python manage.py check
        python manage.py makemigrations --check --dry-run
        coverage run --source=$SOURCE_FOLDER -m pytest -rxXs --reruns 3
      env:
        SOURCE_FOLDER: safe_transaction_service
        CELERY_BROKER_URL: redis://localhost:6379/0
        COINMARKETCAP_API_TOKEN: ${{ secrets.COINMARKETCAP_API_TOKEN }}
        DATABASE_URL: psql://postgres:postgres@localhost/postgres
        DJANGO_SETTINGS_MODULE: config.settings.test
        ETHEREUM_MAINNET_NODE: ${{ secrets.ETHEREUM_MAINNET_NODE }}
        ETHEREUM_NODE_URL: http://localhost:8545
        ETHEREUM_TRACING_NODE_URL: http://localhost:8545
        ETH_HASH_BACKEND: pysha3
        REDIS_URL: redis://localhost:6379/0
    - name: Send results to coveralls
      continue-on-error: true  # Ignore coveralls problems
      run: coveralls --service=github
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Required for coveralls
  docker-deploy:
    runs-on: ubuntu-latest
    needs:
      - linting
      - test-app
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/tags/')
    steps:
    - uses: actions/checkout@v3
    - name: Dockerhub login
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USER }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    - name: Deploy Master
      if: github.ref == 'refs/heads/master'
      run: bash scripts/deploy_docker.sh staging
      env:
        DOCKERHUB_PROJECT: safe-transaction-service
    - name: Deploy Develop
      if: github.ref == 'refs/heads/develop'
      run: bash scripts/deploy_docker.sh develop
      env:
        DOCKERHUB_PROJECT: safe-transaction-service
    - name: Deploy Tag
      if: startsWith(github.ref, 'refs/tags/')
      run: bash scripts/deploy_docker.sh ${GITHUB_REF##*/}
      env:
        DOCKERHUB_PROJECT: safe-transaction-service
  autodeploy:
    runs-on: ubuntu-latest
    needs: [docker-deploy]
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/tags/')
    steps:
    - uses: actions/checkout@v3
    - name: Deploy Staging
      if: github.ref == 'refs/heads/master'
      run: bash scripts/autodeploy.sh
      env:
        AUTODEPLOY_URL: ${{ secrets.AUTODEPLOY_URL }}
        AUTODEPLOY_TOKEN: ${{ secrets.AUTODEPLOY_TOKEN }}
        TARGET_ENV: "staging"
    - name: Deploy Develop
      if: github.ref == 'refs/heads/develop'
      run: bash scripts/autodeploy.sh
      env:
        AUTODEPLOY_URL: ${{ secrets.AUTODEPLOY_URL }}
        AUTODEPLOY_TOKEN: ${{ secrets.AUTODEPLOY_TOKEN }}
        TARGET_ENV: "develop"

'''
'''--- .vscode/launch.json ---
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Django: Run tests",
            "type": "python",
            "request": "launch",
            "module": "pytest",
            "args": [
                "--lf",
                "-rxXs"
            ],
            "django": true,
            "envFile": ".env.test"
        },
        {
            "name": "Run current file tests",
            "type": "python",
            "request": "launch",
            "module": "pytest",
            "args": [
                "--lf",
                "-rxXs",
                "${file}"
            ],
            "django": true,
            "envFile": ".env.test"
        }
    ]
}

'''
'''--- .vscode/settings.json ---
{
    "python.formatting.provider": "black",
    "python.linting.flake8Enabled": true,
    "python.testing.pytestArgs": [],
    "python.testing.pytestEnabled": true,
    "python.testing.unittestEnabled": false,
    "python.linting.enabled": true
}

'''
'''--- CONTRIBUTORS.txt ---
Gnosis

'''
'''--- README.md ---
![Build Status](https://github.com/safe-global/safe-transaction-service/workflows/Python%20CI/badge.svg?branch=master)
[![Coverage Status](https://coveralls.io/repos/github/safe-global/safe-transaction-service/badge.svg?branch=master)](https://coveralls.io/github/safe-global/safe-transaction-service?branch=master)
[![pre-commit](https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logoColor=white)](https://github.com/pre-commit/pre-commit)
![Python 3.10](https://img.shields.io/badge/Python-3.10-blue.svg)
![Django 4](https://img.shields.io/badge/Django-4-blue.svg)
[![Docker Image Version (latest semver)](https://img.shields.io/docker/v/safeglobal/safe-transaction-service?label=Docker&sort=semver)](https://hub.docker.com/r/safeglobal/safe-transaction-service)

# Safe Transaction Service
Keeps track of transactions sent via Safe contracts. It uses events and
[tracing](https://openethereum.github.io/JSONRPC-trace-module) to index the txs.

Transactions are detected in an automatic way, so there is no need of informing the service about the transactions
as in previous versions of the *Transaction Service*.

Transactions can also be sent to the service to allow offchain collecting of signatures or informing the owners about
a transaction that is pending to be sent to the blockchain.

[Swagger (Mainnet version)](https://safe-transaction-mainnet.safe.global/)
[Swagger (GÃ¶erli version)](https://safe-transaction-goerli.safe.global/)

## Index of contents

- [Docs]( https://docs.gnosis-safe.io/backend/service-architecture)

## Setup for development
Use a virtualenv if possible:

```bash
python -m venv venv
```

Then enter the virtualenv and install the dependencies:

```bash
source venv/bin/activate
pip install -r requirements-dev.txt
pre-commit install -f
cp .env.dev .env
./run_tests.sh
```

## Setup for development using docker
```bash
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up
```

## Setup for production (event indexing)
Since **version 3.0.0** transaction service can be configured to rely on **event indexing**
when [SafeL2 version](https://github.com/safe-global/safe-contracts/blob/v1.3.0/contracts/GnosisSafeL2.sol) is used. **Only
contracts from v1.3.0 onwards with L2 events will be indexed.**

An example environment file can be used for the L2 setup:
```bash
cp .env.l2.sample .env
```

Edit `.env` file to add `ETHEREUM_NODE_URL` (on the example a `Polygon` public node is used)
and remember to modify `DJANGO_SECRET_KEY` to **use a strong key**. The rest of the
configuration does not need to be modified. Then:

```bash
docker-compose build --force-rm
docker-compose up
```

If the network is not supported yet [contracts can be deployed using the deployment instructions
](https://github.com/safe-global/safe-contracts/tree/v1.3.0/contracts)
and then a PR should be provided to this service [adding the deployment block number and the address (address
will be the same for every network)](safe_transaction_service/history/management/commands/setup_service.py). Only
`ProxyFactory` and `GnosisSafeL2` must be configured. `+L2` must be added to the Safe contract versions, so the service
knows the contract can be indexed using events.

For more parameters check [base.py](config/settings/base.py) file.

## Setup for production (tracing mode)
This is the recommended configuration for running a production Transaction service. `docker-compose` is required
for running the project.

``bash
cp .env.tracing.sample .env
``

Configure the parameters needed on `.env`. These parameters **need to be changed**:
- `DJANGO_SECRET_KEY`: Use a **strong key**.
- `ETHEREUM_NODE_URL`: Http/s address of a ethereum node. It can be the same than `ETHEREUM_TRACING_NODE_URL`.
- `ETHEREUM_TRACING_NODE_URL`: Http/s address of an OpenEthereum node with
[tracing enabled](https://openethereum.github.io/JSONRPC-trace-module).

If you don't want to use `trace_filter` for the internal tx indexing and just rely on `trace_block`, set:
- `ETH_INTERNAL_NO_FILTER=1`

For more parameters check [base.py](config/settings/base.py) file.

Then:
```bash
docker-compose build --force-rm
docker-compose up
```

The service should be running in `localhost:8000`. You can test everything is set up:

```bash
curl 'http://localhost:8000/api/v1/about/'
```

You can go to http://localhost:5555/ to check the status of the task queue, also you can configure
[prometheus metrics](https://flower.readthedocs.io/en/latest/prometheus-integration.html).

For example, to set up a GÃ¶erli node:

Run an OpenEthereum node in your local computer:
```bash
openethereum --chain goerli --tracing on --db-path=/media/ethereum/openethereum --unsafe-expose
```

Edit `.env` so docker points to the host OpenEthereum node:
```
ETHEREUM_NODE_URL=http://172.17.0.1:8545
ETHEREUM_TRACING_NODE_URL=http://172.17.0.1:8545
```

Then:
```bash
docker-compose build --force-rm
docker-compose up
```

## Setup for private network
Instructions for production still apply, but some additional steps are required:
- Deploy the last version of the [Safe Contracts](https://github.com/safe-global/safe-contracts) on your private network.
- [Add their addresses and the number of the block they were deployed
](safe_transaction_service/history/management/commands/setup_service.py) (to optimize initial indexing).
Service is currently configured to support _Mainnet_, _Rinkeby_, _Goerli_, _Kovan_, _xDai_, _Polygon_, _EWC_...
- If you have a custom `network id` you can change this line
`ethereum_network = ethereum_client.get_network()` to `ethereum_network_id = ethereum_client.w3.net.version` and use
the `network id` instead of the `Enum`.
- Only contracts that need to be configured are the **ProxyFactory** that will be used to deploy the contracts and
the **GnosisSafe/GnosisSafeL2**.

## Use admin interface
Services come with a basic administration web ui (provided by Django) by default on http://localhost:8000/admin/

A user must be created to get access:
```bash
docker exec -it safe-transaction-service-web-1 python manage.py createsuperuser
```

## Safe Contract ABIs and addresses
- [v1.3.0](https://github.com/safe-global/safe-deployments/blob/main/src/assets/v1.3.0/gnosis_safe.json)
- [v1.3.0 L2](https://github.com/safe-global/safe-deployments/blob/main/src/assets/v1.3.0/gnosis_safe_l2.json)
- [Other related contracts and previous Safe versions](https://github.com/safe-global/safe-deployments/blob/main/src/assets)

## Troubleshooting

### Issues installing grpc on a Mac M1

If you face issues installing the `grpc` dependency locally (required by this project) on a M1 chip, set `GRPC_PYTHON_BUILD_SYSTEM_OPENSSL=1` and `GRPC_PYTHON_BUILD_SYSTEM_ZLIB=1` and then try to install the dependency again.

## Contributors
[See contributors](https://github.com/safe-global/safe-transaction-service/graphs/contributors)

'''
'''--- config/__init__.py ---
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery_app import app as celery_app

__all__ = ("celery_app",)

'''
'''--- config/celery_app.py ---
import os

from celery import Celery
from celery.signals import setup_logging

@setup_logging.connect
def on_celery_setup_logging(**kwargs):
    """
    Use Django logging instead of celery logger
    :param kwargs:
    :return:
    """
    from logging.config import dictConfig

    from django.conf import settings

    # Patch all the code to use Celery logger (if not just logs inside tasks.py are displayed with the
    # task_id and task_name). This way every log will have the context information
    if not settings.CELERY_ALWAYS_EAGER:
        for _, logger in settings.LOGGING["loggers"].items():
            key = "handlers"
            if key in logger:
                logger[key] = ["celery_console"]
        dictConfig(settings.LOGGING)

# set the default Django settings module for the 'celery' program.
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.local")

app = Celery("safe_transaction_service")

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
# - namespace='CELERY' means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object("django.conf:settings")
# app.config_from_object("django.conf:settings", namespace="CELERY")

# Load task modules from all registered Django app configs.
app.autodiscover_tasks()

'''
'''--- config/settings/__init__.py ---

'''
'''--- config/settings/base.py ---
"""
Base settings to build other settings files upon.
"""

from pathlib import Path

import environ
from corsheaders.defaults import default_headers as default_cors_headers

ROOT_DIR = Path(__file__).resolve(strict=True).parent.parent.parent
APPS_DIR = ROOT_DIR / "safe_transaction_service"

env = environ.Env()

READ_DOT_ENV_FILE = env.bool("DJANGO_READ_DOT_ENV_FILE", default=False)
DOT_ENV_FILE = env("DJANGO_DOT_ENV_FILE", default=None)
if READ_DOT_ENV_FILE or DOT_ENV_FILE:
    DOT_ENV_FILE = DOT_ENV_FILE or ".env"
    # OS environment variables take precedence over variables from .env
    env.read_env(str(ROOT_DIR / DOT_ENV_FILE))

# GENERAL
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#debug
DEBUG = env.bool("DEBUG", False)
# Local time zone. Choices are
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# though not all of them may be available with every OS.
# In Windows, this must be set to your system time zone.
TIME_ZONE = "UTC"
# https://docs.djangoproject.com/en/dev/ref/settings/#language-code
LANGUAGE_CODE = "en-us"
# https://docs.djangoproject.com/en/dev/ref/settings/#site-id
SITE_ID = 1
# https://docs.djangoproject.com/en/dev/ref/settings/#use-i18n
USE_I18N = True
# https://docs.djangoproject.com/en/dev/ref/settings/#use-l10n
USE_L10N = True
# https://docs.djangoproject.com/en/dev/ref/settings/#use-tz
USE_TZ = True
# https://docs.djangoproject.com/en/3.2/ref/settings/#force-script-name
FORCE_SCRIPT_NAME = env("FORCE_SCRIPT_NAME", default=None)

# SSO
SSO_ENABLED = False

# Enable analytics endpoints
ENABLE_ANALYTICS = env("ENABLE_ANALYTICS", default=False)

# DATABASES
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#databases
DATABASES = {
    "default": env.db("DATABASE_URL"),
}
DATABASES["default"]["ATOMIC_REQUESTS"] = False
DATABASES["default"]["ENGINE"] = "django_db_geventpool.backends.postgresql_psycopg2"
DATABASES["default"]["CONN_MAX_AGE"] = 0
DB_MAX_CONNS = env.int("DB_MAX_CONNS", default=50)
DATABASES["default"]["OPTIONS"] = {
    # https://github.com/jneight/django-db-geventpool#settings
    "MAX_CONNS": DB_MAX_CONNS,
    "REUSE_CONNS": env.int("DB_REUSE_CONNS", default=DB_MAX_CONNS),
}

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# URLS
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#root-urlconf
ROOT_URLCONF = "config.urls"
# https://docs.djangoproject.com/en/dev/ref/settings/#wsgi-application
WSGI_APPLICATION = "config.wsgi.application"

# APPS
# ------------------------------------------------------------------------------
DJANGO_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.sites",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # 'django.contrib.humanize', # Handy template tags
]
THIRD_PARTY_APPS = [
    "django_extensions",
    "corsheaders",
    "rest_framework",
    "drf_yasg",
    "django_s3_storage",
    "rest_framework.authtoken",
]
LOCAL_APPS = [
    "safe_transaction_service.contracts.apps.ContractsConfig",
    "safe_transaction_service.history.apps.HistoryConfig",
    "safe_transaction_service.notifications.apps.NotificationsConfig",
    "safe_transaction_service.safe_messages.apps.SafeMessagesConfig",
    "safe_transaction_service.tokens.apps.TokensConfig",
]
# https://docs.djangoproject.com/en/dev/ref/settings/#installed-apps
INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS

# MIDDLEWARE
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#middleware
MIDDLEWARE = [
    "safe_transaction_service.utils.loggers.LoggingMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.http.ConditionalGetMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

# STATIC
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#static-root
STATIC_ROOT = str(ROOT_DIR / "staticfiles")

# https://docs.djangoproject.com/en/dev/ref/settings/#static-url
STATIC_URL = "static/"
# https://docs.djangoproject.com/en/dev/ref/contrib/staticfiles/#std:setting-STATICFILES_DIRS
STATICFILES_DIRS = [
    str(APPS_DIR / "static"),
]
# https://docs.djangoproject.com/en/dev/ref/contrib/staticfiles/#staticfiles-finders
STATICFILES_FINDERS = [
    "django.contrib.staticfiles.finders.FileSystemFinder",
    "django.contrib.staticfiles.finders.AppDirectoriesFinder",
]

# MEDIA
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#media-root
MEDIA_ROOT = str(APPS_DIR / "media")
# https://docs.djangoproject.com/en/dev/ref/settings/#media-url
MEDIA_URL = "/media/"

# TEMPLATES
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#templates
TEMPLATES = [
    {
        # https://docs.djangoproject.com/en/dev/ref/settings/#std:setting-TEMPLATES-BACKEND
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        # https://docs.djangoproject.com/en/dev/ref/settings/#template-dirs
        "DIRS": [
            str(APPS_DIR / "templates"),
        ],
        "OPTIONS": {
            # https://docs.djangoproject.com/en/dev/ref/settings/#template-debug
            "debug": DEBUG,
            # https://docs.djangoproject.com/en/dev/ref/settings/#template-loaders
            # https://docs.djangoproject.com/en/dev/ref/templates/api/#loader-types
            "loaders": [
                "django.template.loaders.filesystem.Loader",
                "django.template.loaders.app_directories.Loader",
            ],
            # https://docs.djangoproject.com/en/dev/ref/settings/#template-context-processors
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.template.context_processors.i18n",
                "django.template.context_processors.media",
                "django.template.context_processors.static",
                "django.template.context_processors.tz",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

# CORS
# ------------------------------------------------------------------------------
CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_HEADERS = list(default_cors_headers) + [
    "if-match",
    "if-modified-since",
    "if-none-match",
]
CORS_EXPOSE_HEADERS = ["etag"]

# FIXTURES
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#fixture-dirs
FIXTURE_DIRS = (str(APPS_DIR / "fixtures"),)

# ADMIN
# ------------------------------------------------------------------------------
# Django Admin URL regex.
ADMIN_URL = "admin/"

# Celery
# ------------------------------------------------------------------------------
INSTALLED_APPS += [
    "django_celery_beat",
]

# http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-broker_url
CELERY_BROKER_URL = env("CELERY_BROKER_URL", default="django://")
# https://docs.celeryproject.org/en/stable/userguide/optimizing.html#broker-connection-pools
# https://docs.celeryq.dev/en/latest/userguide/optimizing.html#broker-connection-pools
CELERY_BROKER_POOL_LIMIT = env(
    "CELERY_BROKER_POOL_LIMIT", default=env("CELERYD_CONCURRENCY", default=1000)
)
# http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-result_backend
CELERY_RESULT_BACKEND = env("CELERY_RESULT_BACKEND", default="redis://")
# http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-accept_content
CELERY_ACCEPT_CONTENT = ["json"]
# http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-task_serializer
CELERY_TASK_SERIALIZER = "json"
# http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-result_serializer
CELERY_RESULT_SERIALIZER = "json"
# We are not interested in keeping results of tasks
CELERY_IGNORE_RESULT = True
# http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-task_always_eager
CELERY_ALWAYS_EAGER = False
# https://docs.celeryproject.org/en/latest/userguide/configuration.html#task-default-priority
# Higher = more priority on RabbitMQ, opposite on Redis Â¯\_(ãƒ„)_/Â¯
CELERY_TASK_DEFAULT_PRIORITY = 5
# https://docs.celeryproject.org/en/stable/userguide/configuration.html#task-queue-max-priority
CELERY_TASK_QUEUE_MAX_PRIORITY = 10
# https://docs.celeryproject.org/en/latest/userguide/configuration.html#broker-transport-options
CELERY_BROKER_TRANSPORT_OPTIONS = {}
# https://docs.celeryq.dev/en/stable/userguide/configuration.html#std-setting-task_routes
CELERY_ROUTES = (
    [
        (
            "safe_transaction_service.history.tasks.retry_get_metadata_task",
            {"queue": "tokens"},
        ),
        (
            "safe_transaction_service.history.tasks.send_webhook_task",
            {"queue": "webhooks"},
        ),
        ("safe_transaction_service.history.tasks.*", {"queue": "indexing"}),
        ("safe_transaction_service.contracts.tasks.*", {"queue": "contracts"}),
        ("safe_transaction_service.notifications.tasks.*", {"queue": "notifications"}),
        ("safe_transaction_service.tokens.tasks.*", {"queue": "tokens"}),
        ("safe_transaction_service.analytics.tasks.*", {"queue": "contracts"}),
    ],
)

# Django REST Framework
# ------------------------------------------------------------------------------
REST_FRAMEWORK = {
    "PAGE_SIZE": 10,
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.LimitOffsetPagination",
    "DEFAULT_PERMISSION_CLASSES": ("rest_framework.permissions.AllowAny",),
    "DEFAULT_RENDERER_CLASSES": (
        "djangorestframework_camel_case.render.CamelCaseJSONRenderer",
    ),
    "DEFAULT_PARSER_CLASSES": (
        "djangorestframework_camel_case.parser.CamelCaseJSONParser",
    ),
    "DEFAULT_AUTHENTICATION_CLASSES": (
        # 'rest_framework.authentication.BasicAuthentication',
        "rest_framework.authentication.SessionAuthentication",
        "rest_framework.authentication.TokenAuthentication",
    ),
    "DEFAULT_VERSIONING_CLASS": "rest_framework.versioning.NamespaceVersioning",
    "EXCEPTION_HANDLER": "safe_transaction_service.history.exceptions.custom_exception_handler",
}

# LOGGING
# ------------------------------------------------------------------------------
# See: https://docs.djangoproject.com/en/dev/ref/settings/#logging
# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins bon every HTTP 500 error when DEBUG=False.
# See https://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "filters": {
        "require_debug_false": {"()": "django.utils.log.RequireDebugFalse"},
        "ignore_succeeded_none": {
            "()": "safe_transaction_service.utils.loggers.IgnoreSucceededNone"
        },
    },
    "formatters": {
        "short": {"format": "%(asctime)s %(message)s"},
        "verbose": {
            "format": "%(asctime)s [%(levelname)s] [%(processName)s] %(message)s"
        },
        "celery_verbose": {
            "class": "safe_transaction_service.utils.celery.PatchedCeleryFormatter",
            "format": "%(asctime)s [%(levelname)s] [%(task_id)s/%(task_name)s] %(message)s",
            # 'format': '%(asctime)s [%(levelname)s] [%(processName)s] [%(task_id)s/%(task_name)s] %(message)s'
        },
    },
    "handlers": {
        "mail_admins": {
            "level": "ERROR",
            "filters": ["require_debug_false"],
            "class": "django.utils.log.AdminEmailHandler",
        },
        "console": {
            "level": "DEBUG",
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
        "console_short": {
            "class": "logging.StreamHandler",
            "formatter": "short",
        },
        "celery_console": {
            "level": "DEBUG",
            "filters": [] if DEBUG else ["ignore_succeeded_none"],
            "class": "logging.StreamHandler",
            "formatter": "celery_verbose",
        },
    },
    "loggers": {
        "": {
            "handlers": ["console"],
            "level": "INFO",
        },
        "web3.providers": {
            "level": "DEBUG" if DEBUG else "WARNING",
        },
        "django.geventpool": {
            "level": "DEBUG" if DEBUG else "WARNING",
        },
        "LoggingMiddleware": {
            "handlers": ["console_short"],
            "level": "INFO",
            "propagate": False,
        },
        "safe_transaction_service": {
            "level": "DEBUG" if DEBUG else "INFO",
            "handlers": ["console"],
            "propagate": False,
        },
        "safe_transaction_service.history.services.balance_service": {
            "level": "DEBUG" if DEBUG else "WARNING",
        },
        "safe_transaction_service.history.services.collectibles_service": {
            "level": "DEBUG" if DEBUG else "WARNING",
        },
        "celery": {
            "handlers": ["console"],
            "level": "DEBUG" if DEBUG else "INFO",
            "propagate": False,  # If not it will be out for the root logger too
        },
        "celery.worker.strategy": {  # All the "Received task..."
            "handlers": ["console"],
            "level": "INFO" if DEBUG else "WARNING",
            "propagate": False,  # If not it will be out for the root logger too
        },
        "django.request": {
            "handlers": ["mail_admins"],
            "level": "ERROR",
            "propagate": True,
        },
        "django.security.DisallowedHost": {
            "level": "ERROR",
            "handlers": ["console", "mail_admins"],
            "propagate": True,
        },
    },
}

REDIS_URL = env("REDIS_URL", default="redis://localhost:6379/0")

# Ethereum RPC
# ------------------------------------------------------------------------------
ETHEREUM_NODE_URL = env("ETHEREUM_NODE_URL", default=None)
ETHEREUM_TRACING_NODE_URL = env("ETHEREUM_TRACING_NODE_URL", default=None)
ETH_INTERNAL_TXS_BLOCK_PROCESS_LIMIT = env.int(
    "ETH_INTERNAL_TXS_BLOCK_PROCESS_LIMIT", default=10_000
)
ETH_INTERNAL_NO_FILTER = env.bool("ETH_INTERNAL_NO_FILTER", default=False)
ETH_INTERNAL_TRACE_TXS_BATCH_SIZE = env.int(
    "ETH_INTERNAL_TRACE_TXS_BATCH_SIZE", default=0
)
ETH_L2_NETWORK = env.bool(
    "ETH_L2_NETWORK", default=not ETHEREUM_TRACING_NODE_URL
)  # Use L2 event indexing
ETH_EVENTS_BLOCK_PROCESS_LIMIT = env.int(
    "ETH_EVENTS_BLOCK_PROCESS_LIMIT", default=50
)  # Initial number of blocks to process together when searching for events. It will be auto increased. 0 == no limit.
ETH_EVENTS_BLOCK_PROCESS_LIMIT_MAX = env.int(
    "ETH_EVENTS_BLOCK_PROCESS_LIMIT_MAX", default=0
)  # Maximum number of blocks to process together when searching for events. 0 == no limit.
ETH_EVENTS_GET_LOGS_CONCURRENCY = env.int(
    "ETH_EVENTS_GET_LOGS_CONCURRENCY", default=20
)  # Number of concurrent requests to `getLogs`
ETH_EVENTS_QUERY_CHUNK_SIZE = env.int(
    "ETH_EVENTS_QUERY_CHUNK_SIZE", default=1_000
)  # Number of addresses to use as `getLogs` parameter. `0 == no limit`. By testing `1_000` looks like a good default
ETH_EVENTS_UPDATED_BLOCK_BEHIND = env.int(
    "ETH_EVENTS_UPDATED_BLOCK_BEHIND", default=24 * 60 * 60 // 15
)  # Number of blocks to consider an address 'almost updated'.
ETH_REORG_BLOCKS = env.int(
    "ETH_REORG_BLOCKS", default=100 if ETH_L2_NETWORK else 10
)  # Number of blocks from the current block number needed to consider a block valid/stable

# Tokens
# ------------------------------------------------------------------------------
TOKENS_LOGO_BASE_URI = env.str(
    "TOKENS_LOGO_BASE_URI", default="https://tokens-logo.localhost/"
)  # Used if AWS_S3_PUBLIC_URL is not defined
TOKENS_LOGO_EXTENSION = env.str("TOKENS_LOGO_EXTENSION", default=".png")
TOKENS_ENS_IMAGE_URL = env.str(
    "TOKENS_ENS_IMAGE_URL",
    default="https://safe-transaction-assets.safe.global/tokens/logos/ENS.png",
)

# Notifications
# ------------------------------------------------------------------------------
SLACK_API_WEBHOOK = env("SLACK_API_WEBHOOK", default=None)

# Notifications
NOTIFICATIONS_FIREBASE_CREDENTIALS_PATH = env(
    "NOTIFICATIONS_FIREBASE_CREDENTIALS_PATH", default=None
)
if NOTIFICATIONS_FIREBASE_CREDENTIALS_PATH:
    import json

    NOTIFICATIONS_FIREBASE_AUTH_CREDENTIALS = json.load(
        environ.Path(NOTIFICATIONS_FIREBASE_CREDENTIALS_PATH).file(
            "firebase-credentials.json"
        )
    )

ALERT_OUT_OF_SYNC_EVENTS_THRESHOLD = env.float(
    "ALERT_OUT_OF_SYNC_EVENTS_THRESHOLD", default=0.1
)  # Percentage of Safes allowed to be out of sync without alerting. By default 10%

# AWS S3 https://github.com/etianen/django-s3-storage
# ------------------------------------------------------------------------------
# AWS_QUERYSTRING_AUTH = False  # Remove query parameter authentication from generated URLs
AWS_ACCESS_KEY_ID = env("AWS_ACCESS_KEY_ID", default=None)
AWS_S3_PUBLIC_URL = env(
    "AWS_S3_PUBLIC_URL", default=None
)  # Set custom domain for file urls (like cloudfront)
AWS_SECRET_ACCESS_KEY = env("AWS_SECRET_ACCESS_KEY", default=None)
AWS_S3_BUCKET_NAME = env("AWS_STORAGE_BUCKET_NAME", default=None)
AWS_S3_FILE_OVERWRITE = True
AWS_S3_USE_THREADS = False  # Threading not compatible with gevent
AWS_CONFIGURED = bool(
    AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY and AWS_S3_BUCKET_NAME
)

ETHERSCAN_API_KEY = env("ETHERSCAN_API_KEY", default=None)
IPFS_GATEWAY = env("IPFS_GATEWAY", default="https://ipfs.io/ipfs/")

SWAGGER_SETTINGS = {
    "SECURITY_DEFINITIONS": {
        "api_key": {"type": "apiKey", "in": "header", "name": "Authorization"}
    },
}

'''
'''--- config/settings/local.py ---
from .base import *  # noqa
from .base import env

# GENERAL
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#debug
DEBUG = True
# https://docs.djangoproject.com/en/dev/ref/settings/#secret-key
SECRET_KEY = env(
    "DJANGO_SECRET_KEY",
    default="aHdCBMHXuxIxEhfRGFRp7Cp3N9CqEZEEAvwZVlBCazKExkEnzvVs4bYWC8Qqh9lg",
)
# https://docs.djangoproject.com/en/dev/ref/settings/#allowed-hosts
ALLOWED_HOSTS = env.list("DJANGO_ALLOWED_HOSTS", default=["*"])

REDIS_URL = env.str("REDIS_URL")

# CACHES
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#caches
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": REDIS_URL,
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
            # Mimicing memcache behavior.
            # http://niwinz.github.io/django-redis/latest/#_memcached_exceptions_behavior
            "IGNORE_EXCEPTIONS": True,
        },
    }
}

# django-debug-toolbar
# ------------------------------------------------------------------------------
# https://django-debug-toolbar.readthedocs.io/en/latest/installation.html#prerequisites
INSTALLED_APPS += ["debug_toolbar"]  # noqa F405

# https://django-debug-toolbar.readthedocs.io/en/latest/installation.html#middleware
MIDDLEWARE += [  # noqa F405
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "debug_toolbar_force.middleware.ForceDebugToolbarMiddleware",
]
# https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#debug-toolbar-config
DEBUG_TOOLBAR_CONFIG = {
    "DISABLE_PANELS": [
        "debug_toolbar.panels.redirects.RedirectsPanel",
    ],
    "SHOW_TEMPLATE_CONTEXT": True,
}
# https://django-debug-toolbar.readthedocs.io/en/latest/installation.html#internal-ips
INTERNAL_IPS = ["127.0.0.1", "10.0.2.2"]

# CELERY
# ------------------------------------------------------------------------------
CELERY_RESULT_BACKEND = env("CELERY_RESULT_BACKEND", default=REDIS_URL)

'''
'''--- config/settings/production.py ---
from .base import *  # noqa
from .base import env

# GENERAL
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#secret-key
SECRET_KEY = env("DJANGO_SECRET_KEY")
# https://docs.djangoproject.com/en/dev/ref/settings/#allowed-hosts
ALLOWED_HOSTS = env.list("DJANGO_ALLOWED_HOSTS", default=["*"])

# DATABASES
# ------------------------------------------------------------------------------
# DATABASES['default'] = env.db('DATABASE_URL')  # noqa F405
DATABASES["default"]["ATOMIC_REQUESTS"] = False  # noqa F405

REDIS_URL = env.str("REDIS_URL")

# CACHES
# ------------------------------------------------------------------------------
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": REDIS_URL,
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
            # Mimicing memcache behavior.
            # http://niwinz.github.io/django-redis/latest/#_memcached_exceptions_behavior
            "IGNORE_EXCEPTIONS": True,
        },
    }
}

# SECURITY
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/middleware/#x-content-type-options-nosniff
SECURE_CONTENT_TYPE_NOSNIFF = env.bool(
    "DJANGO_SECURE_CONTENT_TYPE_NOSNIFF", default=True
)
# https://docs.djangoproject.com/en/3.2/ref/settings/#csrf-trusted-origins
CSRF_TRUSTED_ORIGINS = env.list("CSRF_TRUSTED_ORIGINS", default=[])

# SSO (tested with https://github.com/buzzfeed/sso)
# ------------------------------------------------------------------------------
# Be really careful when enabling SSO. If the `SSO_USERNAME_HEADER` can be spoofed
# auth is broken and anyone will be able to log in as any user
SSO_ENABLED = env.bool("SSO_ENABLED", default=False)
if SSO_ENABLED:
    SSO_USERNAME_HEADER = env.str(
        "SSO_USERNAME_HEADER", default="HTTP_X_FORWARDED_USER"
    )
    USE_X_FORWARDED_HOST = True
    USE_X_FORWARDED_PORT = True
    MIDDLEWARE.append(  # noqa F405
        "safe_transaction_service.utils.auth.CustomHeaderRemoteUserMiddleware"
    )
    AUTHENTICATION_BACKENDS = [
        "safe_transaction_service.utils.auth.CustomRemoteUserBackend"
        # "django.contrib.auth.backends.ModelBackend",
    ]
    # When creating a user, give superuser permissions if username is in SSO_ADMIN
    SSO_ADMINS = env.list("SSO_ADMINS", default=["richard", "uxio"])

# ADMIN
# ------------------------------------------------------------------------------
# Django Admin URL regex.
ADMIN_URL = env("DJANGO_ADMIN_URL", default="admin/")

# CELERY
# ------------------------------------------------------------------------------
CELERY_RESULT_BACKEND = env("CELERY_RESULT_BACKEND", default=REDIS_URL)

# Gunicorn
# ------------------------------------------------------------------------------
INSTALLED_APPS += ["gunicorn"]  # noqa F405

'''
'''--- config/settings/test.py ---
"""
With these settings, tests run faster.
"""

from .base import *  # noqa
from .base import env

# GENERAL
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#debug
DEBUG = False
# https://docs.djangoproject.com/en/dev/ref/settings/#secret-key
SECRET_KEY = env(
    "DJANGO_SECRET_KEY",
    default="q8lVkJGsIiHcTSQKaWIBsMVPOGnCnF6f7NDGup8KdDNmviSaZVhP0Nq3q3MolmFU",
)
# https://docs.djangoproject.com/en/dev/ref/settings/#test-runner
TEST_RUNNER = "django.test.runner.DiscoverRunner"

# CACHES
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#caches
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.dummy.DummyCache",
    },
}

# PASSWORDS
# ------------------------------------------------------------------------------
# https://docs.djangoproject.com/en/dev/ref/settings/#password-hashers
PASSWORD_HASHERS = ["django.contrib.auth.hashers.MD5PasswordHasher"]

# CELERY
CELERY_ALWAYS_EAGER = True

# Ganache #2 private key
ETHEREUM_TEST_PRIVATE_KEY = (
    "6370fd033278c143179d81c5526140625662b8daa446c22ee2d73db3707e620c"
)
ETH_REORG_BLOCKS = 1

# Fix error with `task_id` when running celery in eager mode
LOGGING["formatters"]["celery_verbose"] = LOGGING["formatters"]["verbose"]  # noqa F405
LOGGING["loggers"] = {  # noqa F405
    "safe_transaction_service": {
        "level": "DEBUG",
    }
}

'''
'''--- config/urls.py ---
from django.conf import settings
from django.conf.urls import include
from django.contrib import admin
from django.http import HttpResponse
from django.urls import path, re_path
from django.views import defaults as default_views

from drf_yasg import openapi
from drf_yasg.views import get_schema_view
from rest_framework import permissions

schema_view = get_schema_view(
    openapi.Info(
        title="Safe Transaction Service API",
        default_version="v1",
        description="API to keep track of transactions sent via Gnosis Safe smart contracts",
        contact=openapi.Contact(email="safe@gnosis.io"),
        license=openapi.License(name="MIT License"),
    ),
    validators=["flex", "ssv"],
    public=True,
    permission_classes=[permissions.AllowAny],
)

schema_cache_timeout = 60 * 5  # 5 minutes

swagger_urlpatterns = [
    path(
        "",
        schema_view.with_ui("swagger", cache_timeout=schema_cache_timeout),
        name="schema-swagger-ui",
    ),
    re_path(
        r"^swagger(?P<format>\.json|\.yaml)$",
        schema_view.without_ui(cache_timeout=schema_cache_timeout),
        name="schema-json",
    ),
    path(
        "redoc/",
        schema_view.with_ui("redoc", cache_timeout=schema_cache_timeout),
        name="schema-redoc",
    ),
]

urlpatterns_v1 = [
    path("", include("safe_transaction_service.history.urls", namespace="history")),
    path(
        "contracts/",
        include("safe_transaction_service.contracts.urls", namespace="contracts"),
    ),
    path(
        "notifications/",
        include(
            "safe_transaction_service.notifications.urls", namespace="notifications"
        ),
    ),
    path(
        "",
        include(
            "safe_transaction_service.safe_messages.urls", namespace="safe_messages"
        ),
    ),
    path(
        "tokens/", include("safe_transaction_service.tokens.urls", namespace="tokens")
    ),
]
urlpatterns_v2 = [
    path("", include("safe_transaction_service.history.urls_v2", namespace="history")),
]

if settings.ENABLE_ANALYTICS:
    urlpatterns_v1 += [
        path(
            "analytics/",
            include("safe_transaction_service.analytics.urls", namespace="analytics"),
        ),
    ]
    urlpatterns_v2 += [
        path(
            "analytics/",
            include(
                "safe_transaction_service.analytics.urls_v2", namespace="analytics"
            ),
        ),
    ]

urlpatterns = swagger_urlpatterns + [
    path(settings.ADMIN_URL, admin.site.urls),
    path("api/v1/", include((urlpatterns_v1, "v1"))),
    path("api/v2/", include((urlpatterns_v2, "v2"))),
    path("check/", lambda request: HttpResponse("Ok"), name="check"),
]

if settings.DEBUG:
    # This allows the error pages to be debugged during development, just visit
    # these url in browser to see how these error pages look like.
    urlpatterns += [
        path(
            "400/",
            default_views.bad_request,
            kwargs={"exception": Exception("Bad Request!")},
        ),
        path(
            "403/",
            default_views.permission_denied,
            kwargs={"exception": Exception("Permission Denied")},
        ),
        path(
            "404/",
            default_views.page_not_found,
            kwargs={"exception": Exception("Page not Found")},
        ),
        path("500/", default_views.server_error),
    ]
    if "debug_toolbar" in settings.INSTALLED_APPS:
        import debug_toolbar

        urlpatterns = [
            path("__debug__/", include(debug_toolbar.urls)),
        ] + urlpatterns

admin.autodiscover()

'''
'''--- config/wsgi.py ---
"""
WSGI config for Safe Transaction Service project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os
import sys

from django.core.wsgi import get_wsgi_application

# This allows easy placement of apps within the interior
# safe_transaction_service directory.
app_path = os.path.abspath(
    os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir)
)
sys.path.append(os.path.join(app_path, "safe_transaction_service"))

# We defer to a DJANGO_SETTINGS_MODULE already in the environment. This breaks
# if running multiple sites in the same mod_wsgi process. To fix this, use
# mod_wsgi daemon mode with each site in its own daemon process, or use
# os.environ["DJANGO_SETTINGS_MODULE"] = "config.settings.production"
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.production")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

'''
'''--- docker-compose.dev.yml ---
version: '3.5'

services:
  web:
    build:
      context: .
      dockerfile: docker/web/Dockerfile
    env_file:
      - .env
    depends_on:
      - db
      - redis
    working_dir: /app
    ports:
      - "8888:8888"
    volumes:
      - nginx-shared:/nginx
    command: docker/web/run_web.sh

  worker: &worker
    build:
      context: .
      dockerfile: docker/web/Dockerfile
    env_file:
      - .env
    depends_on:
      - db
      - redis
    command: docker/web/celery/worker/run.sh

  ganache:
    image: trufflesuite/ganache:latest
    command: --defaultBalanceEther 10000 --gasLimit 10000000 -a 10 --chain.chainId 1337 --chain.networkId 1337 -d --host 0.0.0.0
    ports:
      - "8545:8545"

'''
'''--- docker-compose.yml ---
version: '3.5'

volumes:
  nginx-shared:

services:
  nginx:
    image: nginx:alpine
    restart: always
    hostname: nginx
    ports:
      - "8000:8000"
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - nginx-shared:/nginx
    depends_on:
      - web

  redis:
    image: redis:alpine
    restart: always
    ports:
      - "6379:6379"
    command:
      - --appendonly yes

  rabbitmq:
    image: rabbitmq:alpine

  db:
    image: postgres:13-alpine
    restart: always
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - ./docker/db:/docker-entrypoint-initdb.d

  web:
    build:
      context: .
      dockerfile: docker/web/Dockerfile
    env_file:
      - .env
    depends_on:
      - db
      - redis
    working_dir: /app
    restart: always
    ports:
      - "8888:8888"
    volumes:
      - nginx-shared:/nginx
    command: docker/web/run_web.sh

  indexer-worker: &worker
    build:
      context: .
      dockerfile: docker/web/Dockerfile
    restart: always
    env_file:
      - .env
    environment:
      RUN_MIGRATIONS: 1
      WORKER_QUEUES: "default,indexing"
    depends_on:
      - db
      - redis
      - rabbitmq
    command: docker/web/celery/worker/run.sh

  contracts-tokens-worker:
    <<: *worker
    environment:
      WORKER_QUEUES: "contracts,tokens"

  notifications-webhooks-worker:
    <<: *worker
    environment:
      WORKER_QUEUES: "notifications,webhooks"

  scheduler:
    <<: *worker
    command: docker/web/celery/scheduler/run.sh

  flower:
    <<: *worker
    command: docker/web/celery/flower/run.sh
    ports:
      - "5555:5555"

'''
'''--- docker/db/00-init.sql ---
--
-- PostgreSQL database dump
--

-- Dumped from database version 13.11
-- Dumped by pg_dump version 14.2

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA public IS 'standard public schema';

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: auth_group; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.auth_group (
    id integer NOT NULL,
    name character varying(150) NOT NULL
);

ALTER TABLE public.auth_group OWNER TO postgres;

--
-- Name: auth_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.auth_group ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.auth_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: auth_group_permissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.auth_group_permissions (
    id bigint NOT NULL,
    group_id integer NOT NULL,
    permission_id integer NOT NULL
);

ALTER TABLE public.auth_group_permissions OWNER TO postgres;

--
-- Name: auth_group_permissions_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.auth_group_permissions ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.auth_group_permissions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: auth_permission; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.auth_permission (
    id integer NOT NULL,
    name character varying(255) NOT NULL,
    content_type_id integer NOT NULL,
    codename character varying(100) NOT NULL
);

ALTER TABLE public.auth_permission OWNER TO postgres;

--
-- Name: auth_permission_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.auth_permission ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.auth_permission_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: auth_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.auth_user (
    id integer NOT NULL,
    password character varying(128) NOT NULL,
    last_login timestamp with time zone,
    is_superuser boolean NOT NULL,
    username character varying(150) NOT NULL,
    first_name character varying(150) NOT NULL,
    last_name character varying(150) NOT NULL,
    email character varying(254) NOT NULL,
    is_staff boolean NOT NULL,
    is_active boolean NOT NULL,
    date_joined timestamp with time zone NOT NULL
);

ALTER TABLE public.auth_user OWNER TO postgres;

--
-- Name: auth_user_groups; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.auth_user_groups (
    id bigint NOT NULL,
    user_id integer NOT NULL,
    group_id integer NOT NULL
);

ALTER TABLE public.auth_user_groups OWNER TO postgres;

--
-- Name: auth_user_groups_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.auth_user_groups ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.auth_user_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: auth_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.auth_user ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.auth_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: auth_user_user_permissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.auth_user_user_permissions (
    id bigint NOT NULL,
    user_id integer NOT NULL,
    permission_id integer NOT NULL
);

ALTER TABLE public.auth_user_user_permissions OWNER TO postgres;

--
-- Name: auth_user_user_permissions_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.auth_user_user_permissions ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.auth_user_user_permissions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: authtoken_token; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.authtoken_token (
    key character varying(40) NOT NULL,
    created timestamp with time zone NOT NULL,
    user_id integer NOT NULL
);

ALTER TABLE public.authtoken_token OWNER TO postgres;

--
-- Name: contracts_contract; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contracts_contract (
    address bytea NOT NULL,
    name character varying(200) NOT NULL,
    contract_abi_id bigint,
    display_name character varying(200) NOT NULL,
    logo character varying(100) NOT NULL,
    trusted_for_delegate_call boolean NOT NULL
);

ALTER TABLE public.contracts_contract OWNER TO postgres;

--
-- Name: contracts_contractabi; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contracts_contractabi (
    id bigint NOT NULL,
    abi jsonb NOT NULL,
    description character varying(200) NOT NULL,
    relevance smallint NOT NULL,
    abi_hash bytea
);

ALTER TABLE public.contracts_contractabi OWNER TO postgres;

--
-- Name: contracts_contractabi_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.contracts_contractabi ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.contracts_contractabi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_admin_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_admin_log (
    id integer NOT NULL,
    action_time timestamp with time zone NOT NULL,
    object_id text,
    object_repr character varying(200) NOT NULL,
    action_flag smallint NOT NULL,
    change_message text NOT NULL,
    content_type_id integer,
    user_id integer NOT NULL,
    CONSTRAINT django_admin_log_action_flag_check CHECK ((action_flag >= 0))
);

ALTER TABLE public.django_admin_log OWNER TO postgres;

--
-- Name: django_admin_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_admin_log ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_admin_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_celery_beat_clockedschedule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_celery_beat_clockedschedule (
    id integer NOT NULL,
    clocked_time timestamp with time zone NOT NULL
);

ALTER TABLE public.django_celery_beat_clockedschedule OWNER TO postgres;

--
-- Name: django_celery_beat_clockedschedule_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_celery_beat_clockedschedule ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_celery_beat_clockedschedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_celery_beat_crontabschedule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_celery_beat_crontabschedule (
    id integer NOT NULL,
    minute character varying(240) NOT NULL,
    hour character varying(96) NOT NULL,
    day_of_week character varying(64) NOT NULL,
    day_of_month character varying(124) NOT NULL,
    month_of_year character varying(64) NOT NULL,
    timezone character varying(63) NOT NULL
);

ALTER TABLE public.django_celery_beat_crontabschedule OWNER TO postgres;

--
-- Name: django_celery_beat_crontabschedule_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_celery_beat_crontabschedule ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_celery_beat_crontabschedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_celery_beat_intervalschedule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_celery_beat_intervalschedule (
    id integer NOT NULL,
    every integer NOT NULL,
    period character varying(24) NOT NULL
);

ALTER TABLE public.django_celery_beat_intervalschedule OWNER TO postgres;

--
-- Name: django_celery_beat_intervalschedule_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_celery_beat_intervalschedule ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_celery_beat_intervalschedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_celery_beat_periodictask; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_celery_beat_periodictask (
    id integer NOT NULL,
    name character varying(200) NOT NULL,
    task character varying(200) NOT NULL,
    args text NOT NULL,
    kwargs text NOT NULL,
    queue character varying(200),
    exchange character varying(200),
    routing_key character varying(200),
    expires timestamp with time zone,
    enabled boolean NOT NULL,
    last_run_at timestamp with time zone,
    total_run_count integer NOT NULL,
    date_changed timestamp with time zone NOT NULL,
    description text NOT NULL,
    crontab_id integer,
    interval_id integer,
    solar_id integer,
    one_off boolean NOT NULL,
    start_time timestamp with time zone,
    priority integer,
    headers text NOT NULL,
    clocked_id integer,
    expire_seconds integer,
    CONSTRAINT django_celery_beat_periodictask_expire_seconds_check CHECK ((expire_seconds >= 0)),
    CONSTRAINT django_celery_beat_periodictask_priority_check CHECK ((priority >= 0)),
    CONSTRAINT django_celery_beat_periodictask_total_run_count_check CHECK ((total_run_count >= 0))
);

ALTER TABLE public.django_celery_beat_periodictask OWNER TO postgres;

--
-- Name: django_celery_beat_periodictask_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_celery_beat_periodictask ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_celery_beat_periodictask_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_celery_beat_periodictasks; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_celery_beat_periodictasks (
    ident smallint NOT NULL,
    last_update timestamp with time zone NOT NULL
);

ALTER TABLE public.django_celery_beat_periodictasks OWNER TO postgres;

--
-- Name: django_celery_beat_solarschedule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_celery_beat_solarschedule (
    id integer NOT NULL,
    event character varying(24) NOT NULL,
    latitude numeric(9,6) NOT NULL,
    longitude numeric(9,6) NOT NULL
);

ALTER TABLE public.django_celery_beat_solarschedule OWNER TO postgres;

--
-- Name: django_celery_beat_solarschedule_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_celery_beat_solarschedule ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_celery_beat_solarschedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_content_type; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_content_type (
    id integer NOT NULL,
    app_label character varying(100) NOT NULL,
    model character varying(100) NOT NULL
);

ALTER TABLE public.django_content_type OWNER TO postgres;

--
-- Name: django_content_type_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_content_type ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_content_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_migrations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_migrations (
    id bigint NOT NULL,
    app character varying(255) NOT NULL,
    name character varying(255) NOT NULL,
    applied timestamp with time zone NOT NULL
);

ALTER TABLE public.django_migrations OWNER TO postgres;

--
-- Name: django_migrations_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_migrations ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_migrations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: django_session; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_session (
    session_key character varying(40) NOT NULL,
    session_data text NOT NULL,
    expire_date timestamp with time zone NOT NULL
);

ALTER TABLE public.django_session OWNER TO postgres;

--
-- Name: django_site; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.django_site (
    id integer NOT NULL,
    domain character varying(100) NOT NULL,
    name character varying(50) NOT NULL
);

ALTER TABLE public.django_site OWNER TO postgres;

--
-- Name: django_site_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.django_site ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.django_site_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: history_erc20transfer; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_erc20transfer (
    id bigint NOT NULL,
    address bytea NOT NULL,
    _from bytea NOT NULL,
    "to" bytea NOT NULL,
    log_index integer NOT NULL,
    value numeric(79,0) NOT NULL,
    ethereum_tx_id bytea NOT NULL,
    block_number integer NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    CONSTRAINT history_erc20transfer_block_number_check CHECK ((block_number >= 0)),
    CONSTRAINT history_erc20transfer_log_index_check CHECK ((log_index >= 0))
);

ALTER TABLE public.history_erc20transfer OWNER TO postgres;

--
-- Name: history_erc20transfer_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.history_erc20transfer ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.history_erc20transfer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: history_erc721transfer; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_erc721transfer (
    id bigint NOT NULL,
    address bytea NOT NULL,
    _from bytea NOT NULL,
    "to" bytea NOT NULL,
    log_index integer NOT NULL,
    token_id numeric(79,0) NOT NULL,
    ethereum_tx_id bytea NOT NULL,
    block_number integer NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    CONSTRAINT history_erc721transfer_block_number_check CHECK ((block_number >= 0)),
    CONSTRAINT history_erc721transfer_log_index_check CHECK ((log_index >= 0))
);

ALTER TABLE public.history_erc721transfer OWNER TO postgres;

--
-- Name: history_erc721transfer_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.history_erc721transfer ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.history_erc721transfer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: history_ethereumblock; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_ethereumblock (
    number integer NOT NULL,
    gas_limit numeric(79,0) NOT NULL,
    gas_used numeric(79,0) NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    block_hash bytea NOT NULL,
    parent_hash bytea NOT NULL,
    confirmed boolean NOT NULL,
    CONSTRAINT history_ethereumblock_number_check CHECK ((number >= 0))
);

ALTER TABLE public.history_ethereumblock OWNER TO postgres;

--
-- Name: history_ethereumtx; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_ethereumtx (
    created timestamp with time zone NOT NULL,
    modified timestamp with time zone NOT NULL,
    tx_hash bytea NOT NULL,
    gas_used numeric(79,0),
    status integer,
    transaction_index integer,
    _from bytea,
    gas numeric(79,0) NOT NULL,
    gas_price numeric(79,0) NOT NULL,
    data bytea,
    nonce numeric(79,0) NOT NULL,
    "to" bytea,
    value numeric(79,0) NOT NULL,
    block_id integer,
    logs jsonb[],
    max_fee_per_gas numeric(79,0),
    max_priority_fee_per_gas numeric(79,0),
    type smallint NOT NULL,
    CONSTRAINT history_ethereumtx_transaction_index_check CHECK ((transaction_index >= 0)),
    CONSTRAINT history_ethereumtx_type_check CHECK ((type >= 0))
);

ALTER TABLE public.history_ethereumtx OWNER TO postgres;

--
-- Name: history_indexingstatus; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_indexingstatus (
    indexing_type smallint NOT NULL,
    block_number integer NOT NULL,
    CONSTRAINT history_indexingstatus_block_number_check CHECK ((block_number >= 0)),
    CONSTRAINT history_indexingstatus_indexing_type_check CHECK ((indexing_type >= 0))
);

ALTER TABLE public.history_indexingstatus OWNER TO postgres;

--
-- Name: history_internaltx; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_internaltx (
    id bigint NOT NULL,
    _from bytea,
    gas numeric(79,0) NOT NULL,
    data bytea,
    "to" bytea,
    value numeric(79,0) NOT NULL,
    gas_used numeric(79,0) NOT NULL,
    contract_address bytea,
    code bytea,
    output bytea,
    refund_address bytea,
    tx_type smallint NOT NULL,
    call_type smallint,
    trace_address character varying(600) NOT NULL,
    error character varying(200),
    ethereum_tx_id bytea NOT NULL,
    block_number integer NOT NULL,
    "timestamp" timestamp with time zone NOT NULL,
    CONSTRAINT history_internaltx_block_number_check CHECK ((block_number >= 0)),
    CONSTRAINT history_internaltx_call_type_check CHECK ((call_type >= 0)),
    CONSTRAINT history_internaltx_tx_type_check CHECK ((tx_type >= 0))
);

ALTER TABLE public.history_internaltx OWNER TO postgres;

--
-- Name: history_internaltx_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.history_internaltx ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.history_internaltx_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: history_internaltxdecoded; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_internaltxdecoded (
    internal_tx_id bigint NOT NULL,
    function_name character varying(256) NOT NULL,
    arguments jsonb NOT NULL,
    processed boolean NOT NULL
);

ALTER TABLE public.history_internaltxdecoded OWNER TO postgres;

--
-- Name: history_moduletransaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_moduletransaction (
    created timestamp with time zone NOT NULL,
    modified timestamp with time zone NOT NULL,
    internal_tx_id bigint NOT NULL,
    safe bytea NOT NULL,
    module bytea NOT NULL,
    "to" bytea NOT NULL,
    value numeric(79,0) NOT NULL,
    data bytea,
    operation smallint NOT NULL,
    failed boolean NOT NULL,
    CONSTRAINT history_moduletransaction_operation_check CHECK ((operation >= 0))
);

ALTER TABLE public.history_moduletransaction OWNER TO postgres;

--
-- Name: history_multisigconfirmation; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_multisigconfirmation (
    id bigint NOT NULL,
    created timestamp with time zone NOT NULL,
    modified timestamp with time zone NOT NULL,
    owner bytea NOT NULL,
    multisig_transaction_id bytea,
    signature character varying(5000),
    multisig_transaction_hash bytea,
    ethereum_tx_id bytea,
    signature_type smallint NOT NULL,
    CONSTRAINT history_multisigconfirmation_signature_type_check CHECK ((signature_type >= 0))
);

ALTER TABLE public.history_multisigconfirmation OWNER TO postgres;

--
-- Name: history_multisigconfirmation_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.history_multisigconfirmation ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.history_multisigconfirmation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: history_multisigtransaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_multisigtransaction (
    created timestamp with time zone NOT NULL,
    modified timestamp with time zone NOT NULL,
    safe_tx_hash bytea NOT NULL,
    safe bytea NOT NULL,
    "to" bytea,
    value numeric(79,0) NOT NULL,
    data bytea,
    operation smallint NOT NULL,
    safe_tx_gas numeric(79,0) NOT NULL,
    base_gas numeric(79,0) NOT NULL,
    gas_price numeric(79,0) NOT NULL,
    gas_token bytea,
    refund_receiver bytea,
    nonce numeric(79,0) NOT NULL,
    signatures bytea,
    ethereum_tx_id bytea,
    failed boolean,
    origin jsonb NOT NULL,
    trusted boolean NOT NULL,
    CONSTRAINT history_multisigtransaction_operation_check CHECK ((operation >= 0))
);

ALTER TABLE public.history_multisigtransaction OWNER TO postgres;

--
-- Name: history_proxyfactory; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_proxyfactory (
    address bytea NOT NULL,
    initial_block_number integer NOT NULL,
    tx_block_number integer
);

ALTER TABLE public.history_proxyfactory OWNER TO postgres;

--
-- Name: history_safecontract; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_safecontract (
    address bytea NOT NULL,
    ethereum_tx_id bytea NOT NULL
);

ALTER TABLE public.history_safecontract OWNER TO postgres;

--
-- Name: history_safecontractdelegate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_safecontractdelegate (
    id bigint NOT NULL,
    delegate bytea NOT NULL,
    delegator bytea NOT NULL,
    label character varying(50) NOT NULL,
    read boolean NOT NULL,
    write boolean NOT NULL,
    safe_contract_id bytea
);

ALTER TABLE public.history_safecontractdelegate OWNER TO postgres;

--
-- Name: history_safecontractdelegate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.history_safecontractdelegate ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.history_safecontractdelegate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: history_safelaststatus; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_safelaststatus (
    address bytea NOT NULL,
    owners bytea[] NOT NULL,
    threshold numeric(79,0) NOT NULL,
    nonce numeric(79,0) NOT NULL,
    master_copy bytea NOT NULL,
    fallback_handler bytea NOT NULL,
    guard bytea,
    enabled_modules bytea[] NOT NULL,
    internal_tx_id bigint NOT NULL
);

ALTER TABLE public.history_safelaststatus OWNER TO postgres;

--
-- Name: history_safemastercopy; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_safemastercopy (
    address bytea NOT NULL,
    initial_block_number integer NOT NULL,
    tx_block_number integer,
    version character varying(20) NOT NULL,
    deployer character varying(50) NOT NULL,
    l2 boolean NOT NULL
);

ALTER TABLE public.history_safemastercopy OWNER TO postgres;

--
-- Name: history_safestatus; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_safestatus (
    internal_tx_id bigint NOT NULL,
    address bytea NOT NULL,
    owners bytea[] NOT NULL,
    threshold numeric(79,0) NOT NULL,
    nonce numeric(79,0) NOT NULL,
    master_copy bytea NOT NULL,
    enabled_modules bytea[] NOT NULL,
    fallback_handler bytea NOT NULL,
    guard bytea
);

ALTER TABLE public.history_safestatus OWNER TO postgres;

--
-- Name: history_webhook; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.history_webhook (
    id bigint NOT NULL,
    address bytea,
    url character varying(255) NOT NULL,
    new_confirmation boolean NOT NULL,
    pending_multisig_transaction boolean NOT NULL,
    new_executed_multisig_transaction boolean NOT NULL,
    new_incoming_transaction boolean NOT NULL,
    new_safe boolean NOT NULL,
    new_module_transaction boolean NOT NULL,
    new_outgoing_transaction boolean NOT NULL,
    "authorization" character varying(500)
);

ALTER TABLE public.history_webhook OWNER TO postgres;

--
-- Name: history_webhook_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.history_webhook ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.history_webhook_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: notifications_firebasedevice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notifications_firebasedevice (
    uuid uuid NOT NULL,
    cloud_messaging_token character varying(200),
    build_number integer NOT NULL,
    bundle character varying(100) NOT NULL,
    device_type smallint NOT NULL,
    version character varying(50) NOT NULL,
    CONSTRAINT notifications_firebasedevice_build_number_check CHECK ((build_number >= 0)),
    CONSTRAINT notifications_firebasedevice_device_type_check CHECK ((device_type >= 0))
);

ALTER TABLE public.notifications_firebasedevice OWNER TO postgres;

--
-- Name: notifications_firebasedevice_safes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notifications_firebasedevice_safes (
    id bigint NOT NULL,
    firebasedevice_id uuid NOT NULL,
    safecontract_id bytea NOT NULL
);

ALTER TABLE public.notifications_firebasedevice_safes OWNER TO postgres;

--
-- Name: notifications_firebasedevice_safes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.notifications_firebasedevice_safes ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.notifications_firebasedevice_safes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: notifications_firebasedeviceowner; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notifications_firebasedeviceowner (
    id bigint NOT NULL,
    owner bytea NOT NULL,
    firebase_device_id uuid NOT NULL
);

ALTER TABLE public.notifications_firebasedeviceowner OWNER TO postgres;

--
-- Name: notifications_firebasedeviceowner_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.notifications_firebasedeviceowner ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.notifications_firebasedeviceowner_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: safe_messages_safemessage; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.safe_messages_safemessage (
    created timestamp with time zone NOT NULL,
    modified timestamp with time zone NOT NULL,
    message_hash bytea NOT NULL,
    safe bytea NOT NULL,
    message jsonb NOT NULL,
    proposed_by bytea NOT NULL,
    safe_app_id integer,
    CONSTRAINT safe_messages_safemessage_safe_app_id_check CHECK ((safe_app_id >= 0))
);

ALTER TABLE public.safe_messages_safemessage OWNER TO postgres;

--
-- Name: safe_messages_safemessageconfirmation; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.safe_messages_safemessageconfirmation (
    id bigint NOT NULL,
    created timestamp with time zone NOT NULL,
    modified timestamp with time zone NOT NULL,
    owner bytea NOT NULL,
    signature character varying(5000) NOT NULL,
    signature_type smallint NOT NULL,
    safe_message_id bytea,
    CONSTRAINT safe_messages_safemessageconfirmation_signature_type_check CHECK ((signature_type >= 0))
);

ALTER TABLE public.safe_messages_safemessageconfirmation OWNER TO postgres;

--
-- Name: safe_messages_safemessageconfirmation_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.safe_messages_safemessageconfirmation ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.safe_messages_safemessageconfirmation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

--
-- Name: tokens_token; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tokens_token (
    address bytea NOT NULL,
    name character varying(60) NOT NULL,
    symbol character varying(60) NOT NULL,
    decimals smallint,
    trusted boolean NOT NULL,
    spam boolean NOT NULL,
    events_bugged boolean NOT NULL,
    logo character varying(100) NOT NULL,
    copy_price bytea,
    CONSTRAINT tokens_token_decimals_check CHECK ((decimals >= 0))
);

ALTER TABLE public.tokens_token OWNER TO postgres;

--
-- Data for Name: auth_group; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: auth_group_permissions; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: auth_permission; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (1, 'Can add log entry', 1, 'add_logentry');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (2, 'Can change log entry', 1, 'change_logentry');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (3, 'Can delete log entry', 1, 'delete_logentry');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (4, 'Can view log entry', 1, 'view_logentry');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (5, 'Can add permission', 2, 'add_permission');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (6, 'Can change permission', 2, 'change_permission');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (7, 'Can delete permission', 2, 'delete_permission');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (8, 'Can view permission', 2, 'view_permission');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (9, 'Can add group', 3, 'add_group');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (10, 'Can change group', 3, 'change_group');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (11, 'Can delete group', 3, 'delete_group');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (12, 'Can view group', 3, 'view_group');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (13, 'Can add user', 4, 'add_user');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (14, 'Can change user', 4, 'change_user');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (15, 'Can delete user', 4, 'delete_user');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (16, 'Can view user', 4, 'view_user');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (17, 'Can add content type', 5, 'add_contenttype');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (18, 'Can change content type', 5, 'change_contenttype');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (19, 'Can delete content type', 5, 'delete_contenttype');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (20, 'Can view content type', 5, 'view_contenttype');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (21, 'Can add session', 6, 'add_session');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (22, 'Can change session', 6, 'change_session');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (23, 'Can delete session', 6, 'delete_session');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (24, 'Can view session', 6, 'view_session');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (25, 'Can add site', 7, 'add_site');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (26, 'Can change site', 7, 'change_site');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (27, 'Can delete site', 7, 'delete_site');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (28, 'Can view site', 7, 'view_site');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (29, 'Can add Token', 8, 'add_token');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (30, 'Can change Token', 8, 'change_token');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (31, 'Can delete Token', 8, 'delete_token');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (32, 'Can view Token', 8, 'view_token');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (33, 'Can add token', 9, 'add_tokenproxy');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (34, 'Can change token', 9, 'change_tokenproxy');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (35, 'Can delete token', 9, 'delete_tokenproxy');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (36, 'Can view token', 9, 'view_tokenproxy');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (37, 'Can add contract abi', 10, 'add_contractabi');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (38, 'Can change contract abi', 10, 'change_contractabi');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (39, 'Can delete contract abi', 10, 'delete_contractabi');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (40, 'Can view contract abi', 10, 'view_contractabi');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (41, 'Can add contract', 11, 'add_contract');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (42, 'Can change contract', 11, 'change_contract');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (43, 'Can delete contract', 11, 'delete_contract');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (44, 'Can view contract', 11, 'view_contract');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (45, 'Can add multisig transaction', 12, 'add_multisigtransaction');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (46, 'Can change multisig transaction', 12, 'change_multisigtransaction');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (47, 'Can delete multisig transaction', 12, 'delete_multisigtransaction');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (48, 'Can view multisig transaction', 12, 'view_multisigtransaction');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (49, 'Can create trusted transactions', 12, 'create_trusted');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (50, 'Can add multisig confirmation', 13, 'add_multisigconfirmation');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (51, 'Can change multisig confirmation', 13, 'change_multisigconfirmation');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (52, 'Can delete multisig confirmation', 13, 'delete_multisigconfirmation');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (53, 'Can view multisig confirmation', 13, 'view_multisigconfirmation');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (54, 'Can add ethereum block', 14, 'add_ethereumblock');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (55, 'Can change ethereum block', 14, 'change_ethereumblock');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (56, 'Can delete ethereum block', 14, 'delete_ethereumblock');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (57, 'Can view ethereum block', 14, 'view_ethereumblock');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (58, 'Can add ethereum tx', 15, 'add_ethereumtx');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (59, 'Can change ethereum tx', 15, 'change_ethereumtx');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (60, 'Can delete ethereum tx', 15, 'delete_ethereumtx');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (61, 'Can view ethereum tx', 15, 'view_ethereumtx');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (62, 'Can add internal tx', 16, 'add_internaltx');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (63, 'Can change internal tx', 16, 'change_internaltx');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (64, 'Can delete internal tx', 16, 'delete_internaltx');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (65, 'Can view internal tx', 16, 'view_internaltx');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (66, 'Can add proxy factory', 17, 'add_proxyfactory');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (67, 'Can change proxy factory', 17, 'change_proxyfactory');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (68, 'Can delete proxy factory', 17, 'delete_proxyfactory');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (69, 'Can view proxy factory', 17, 'view_proxyfactory');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (70, 'Can add safe master copy', 18, 'add_safemastercopy');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (71, 'Can change safe master copy', 18, 'change_safemastercopy');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (72, 'Can delete safe master copy', 18, 'delete_safemastercopy');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (73, 'Can view safe master copy', 18, 'view_safemastercopy');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (74, 'Can add internal tx decoded', 19, 'add_internaltxdecoded');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (75, 'Can change internal tx decoded', 19, 'change_internaltxdecoded');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (76, 'Can delete internal tx decoded', 19, 'delete_internaltxdecoded');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (77, 'Can view internal tx decoded', 19, 'view_internaltxdecoded');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (78, 'Can add safe contract', 20, 'add_safecontract');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (79, 'Can change safe contract', 20, 'change_safecontract');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (80, 'Can delete safe contract', 20, 'delete_safecontract');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (81, 'Can view safe contract', 20, 'view_safecontract');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (82, 'Can add safe status', 21, 'add_safestatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (83, 'Can change safe status', 21, 'change_safestatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (84, 'Can delete safe status', 21, 'delete_safestatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (85, 'Can view safe status', 21, 'view_safestatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (86, 'Can add web hook', 22, 'add_webhook');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (87, 'Can change web hook', 22, 'change_webhook');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (88, 'Can delete web hook', 22, 'delete_webhook');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (89, 'Can view web hook', 22, 'view_webhook');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (90, 'Can add module transaction', 23, 'add_moduletransaction');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (91, 'Can change module transaction', 23, 'change_moduletransaction');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (92, 'Can delete module transaction', 23, 'delete_moduletransaction');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (93, 'Can view module transaction', 23, 'view_moduletransaction');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (94, 'Can add safe contract delegate', 24, 'add_safecontractdelegate');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (95, 'Can change safe contract delegate', 24, 'change_safecontractdelegate');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (96, 'Can delete safe contract delegate', 24, 'delete_safecontractdelegate');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (97, 'Can view safe contract delegate', 24, 'view_safecontractdelegate');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (98, 'Can add ERC20 Transfer', 25, 'add_erc20transfer');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (99, 'Can change ERC20 Transfer', 25, 'change_erc20transfer');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (100, 'Can delete ERC20 Transfer', 25, 'delete_erc20transfer');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (101, 'Can view ERC20 Transfer', 25, 'view_erc20transfer');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (102, 'Can add ERC721 Transfer', 26, 'add_erc721transfer');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (103, 'Can change ERC721 Transfer', 26, 'change_erc721transfer');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (104, 'Can delete ERC721 Transfer', 26, 'delete_erc721transfer');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (105, 'Can view ERC721 Transfer', 26, 'view_erc721transfer');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (106, 'Can add safe last status', 27, 'add_safelaststatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (107, 'Can change safe last status', 27, 'change_safelaststatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (108, 'Can delete safe last status', 27, 'delete_safelaststatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (109, 'Can view safe last status', 27, 'view_safelaststatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (110, 'Can add indexing status', 28, 'add_indexingstatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (111, 'Can change indexing status', 28, 'change_indexingstatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (112, 'Can delete indexing status', 28, 'delete_indexingstatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (113, 'Can view indexing status', 28, 'view_indexingstatus');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (114, 'Can add Firebase Device', 29, 'add_firebasedevice');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (115, 'Can change Firebase Device', 29, 'change_firebasedevice');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (116, 'Can delete Firebase Device', 29, 'delete_firebasedevice');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (117, 'Can view Firebase Device', 29, 'view_firebasedevice');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (118, 'Can add Firebase Device Owner', 30, 'add_firebasedeviceowner');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (119, 'Can change Firebase Device Owner', 30, 'change_firebasedeviceowner');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (120, 'Can delete Firebase Device Owner', 30, 'delete_firebasedeviceowner');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (121, 'Can view Firebase Device Owner', 30, 'view_firebasedeviceowner');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (122, 'Can add safe message', 31, 'add_safemessage');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (123, 'Can change safe message', 31, 'change_safemessage');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (124, 'Can delete safe message', 31, 'delete_safemessage');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (125, 'Can view safe message', 31, 'view_safemessage');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (126, 'Can add safe message confirmation', 32, 'add_safemessageconfirmation');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (127, 'Can change safe message confirmation', 32, 'change_safemessageconfirmation');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (128, 'Can delete safe message confirmation', 32, 'delete_safemessageconfirmation');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (129, 'Can view safe message confirmation', 32, 'view_safemessageconfirmation');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (130, 'Can add token', 33, 'add_token');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (131, 'Can change token', 33, 'change_token');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (132, 'Can delete token', 33, 'delete_token');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (133, 'Can view token', 33, 'view_token');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (134, 'Can add crontab', 34, 'add_crontabschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (135, 'Can change crontab', 34, 'change_crontabschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (136, 'Can delete crontab', 34, 'delete_crontabschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (137, 'Can view crontab', 34, 'view_crontabschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (138, 'Can add interval', 35, 'add_intervalschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (139, 'Can change interval', 35, 'change_intervalschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (140, 'Can delete interval', 35, 'delete_intervalschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (141, 'Can view interval', 35, 'view_intervalschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (142, 'Can add periodic task', 36, 'add_periodictask');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (143, 'Can change periodic task', 36, 'change_periodictask');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (144, 'Can delete periodic task', 36, 'delete_periodictask');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (145, 'Can view periodic task', 36, 'view_periodictask');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (146, 'Can add periodic tasks', 37, 'add_periodictasks');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (147, 'Can change periodic tasks', 37, 'change_periodictasks');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (148, 'Can delete periodic tasks', 37, 'delete_periodictasks');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (149, 'Can view periodic tasks', 37, 'view_periodictasks');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (150, 'Can add solar event', 38, 'add_solarschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (151, 'Can change solar event', 38, 'change_solarschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (152, 'Can delete solar event', 38, 'delete_solarschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (153, 'Can view solar event', 38, 'view_solarschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (154, 'Can add clocked', 39, 'add_clockedschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (155, 'Can change clocked', 39, 'change_clockedschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (156, 'Can delete clocked', 39, 'delete_clockedschedule');
INSERT INTO public.auth_permission (id, name, content_type_id, codename) VALUES (157, 'Can view clocked', 39, 'view_clockedschedule');

--
-- Data for Name: auth_user; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: auth_user_groups; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: auth_user_user_permissions; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: authtoken_token; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: contracts_contract; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: contracts_contractabi; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: django_admin_log; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: django_celery_beat_clockedschedule; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: django_celery_beat_crontabschedule; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.django_celery_beat_crontabschedule (id, minute, hour, day_of_week, day_of_month, month_of_year, timezone) VALUES (1, '0', '4', '*', '*', '*', 'UTC');

--
-- Data for Name: django_celery_beat_intervalschedule; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (1, 3, 'minutes');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (2, 10, 'minutes');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (3, 5, 'seconds');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (4, 15, 'seconds');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (5, 14, 'seconds');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (6, 110, 'minutes');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (7, 20, 'minutes');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (8, 1, 'hours');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (9, 6, 'hours');
INSERT INTO public.django_celery_beat_intervalschedule (id, every, period) VALUES (10, 7, 'days');

--
-- Data for Name: django_celery_beat_periodictask; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (1, 'celery.backend_cleanup', 'celery.backend_cleanup', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:26.573485+00', '', 1, NULL, NULL, false, NULL, NULL, '{}', NULL, 43200);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (2, 'Check Reorgs', 'safe_transaction_service.history.tasks.check_reorgs_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.711862+00', '', NULL, 1, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (3, 'Check Sync status', 'safe_transaction_service.history.tasks.check_sync_status_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.726775+00', '', NULL, 2, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (4, 'Index Internal Txs', 'safe_transaction_service.history.tasks.index_internal_txs_task', '[]', '{}', NULL, NULL, NULL, NULL, false, NULL, 0, '2023-06-22 09:58:28.739863+00', '', NULL, 3, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (5, 'Index Safe events (L2)', 'safe_transaction_service.history.tasks.index_safe_events_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.746588+00', '', NULL, 3, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (6, 'Index new Proxies', 'safe_transaction_service.history.tasks.index_new_proxies_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.757298+00', '', NULL, 4, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (7, 'Index ERC20/721 Events', 'safe_transaction_service.history.tasks.index_erc20_events_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.771495+00', '', NULL, 5, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (8, 'Reindex master copies for the last hours', 'safe_transaction_service.history.tasks.reindex_last_hours_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.793512+00', '', NULL, 6, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (9, 'Process Internal Txs', 'safe_transaction_service.history.tasks.process_decoded_internal_txs_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.806227+00', '', NULL, 7, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (10, 'Index contract names and ABIs', 'safe_transaction_service.contracts.tasks.create_missing_contracts_with_metadata_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.817869+00', '', NULL, 8, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (11, 'Index contract names and ABIs from MultiSend transactions', 'safe_transaction_service.contracts.tasks.create_missing_multisend_contracts_with_metadata_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.83068+00', '', NULL, 9, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (12, 'Reindex contracts with missing names or ABIs', 'safe_transaction_service.contracts.tasks.reindex_contracts_without_metadata_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.842342+00', '', NULL, 10, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (13, 'Fix Pool Token Names', 'safe_transaction_service.tokens.tasks.fix_pool_tokens_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.853001+00', '', NULL, 8, NULL, false, NULL, NULL, '{}', NULL, NULL);
INSERT INTO public.django_celery_beat_periodictask (id, name, task, args, kwargs, queue, exchange, routing_key, expires, enabled, last_run_at, total_run_count, date_changed, description, crontab_id, interval_id, solar_id, one_off, start_time, priority, headers, clocked_id, expire_seconds) VALUES (14, 'Run query to get number of transactions grouped by safe-app', 'safe_transaction_service.analytics.tasks.get_transactions_per_safe_app_task', '[]', '{}', NULL, NULL, NULL, NULL, true, NULL, 0, '2023-06-22 09:58:28.867138+00', '', NULL, 10, NULL, false, NULL, NULL, '{}', NULL, NULL);

--
-- Data for Name: django_celery_beat_periodictasks; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.django_celery_beat_periodictasks (ident, last_update) VALUES (1, '2023-06-22 09:58:28.867811+00');

--
-- Data for Name: django_celery_beat_solarschedule; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: django_content_type; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.django_content_type (id, app_label, model) VALUES (1, 'admin', 'logentry');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (2, 'auth', 'permission');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (3, 'auth', 'group');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (4, 'auth', 'user');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (5, 'contenttypes', 'contenttype');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (6, 'sessions', 'session');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (7, 'sites', 'site');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (8, 'authtoken', 'token');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (9, 'authtoken', 'tokenproxy');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (10, 'contracts', 'contractabi');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (11, 'contracts', 'contract');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (12, 'history', 'multisigtransaction');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (13, 'history', 'multisigconfirmation');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (14, 'history', 'ethereumblock');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (15, 'history', 'ethereumtx');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (16, 'history', 'internaltx');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (17, 'history', 'proxyfactory');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (18, 'history', 'safemastercopy');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (19, 'history', 'internaltxdecoded');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (20, 'history', 'safecontract');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (21, 'history', 'safestatus');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (22, 'history', 'webhook');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (23, 'history', 'moduletransaction');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (24, 'history', 'safecontractdelegate');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (25, 'history', 'erc20transfer');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (26, 'history', 'erc721transfer');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (27, 'history', 'safelaststatus');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (28, 'history', 'indexingstatus');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (29, 'notifications', 'firebasedevice');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (30, 'notifications', 'firebasedeviceowner');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (31, 'safe_messages', 'safemessage');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (32, 'safe_messages', 'safemessageconfirmation');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (33, 'tokens', 'token');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (34, 'django_celery_beat', 'crontabschedule');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (35, 'django_celery_beat', 'intervalschedule');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (36, 'django_celery_beat', 'periodictask');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (37, 'django_celery_beat', 'periodictasks');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (38, 'django_celery_beat', 'solarschedule');
INSERT INTO public.django_content_type (id, app_label, model) VALUES (39, 'django_celery_beat', 'clockedschedule');

--
-- Data for Name: django_migrations; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.django_migrations (id, app, name, applied) VALUES (1, 'contenttypes', '0001_initial', '2023-06-22 09:58:18.919424+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (2, 'auth', '0001_initial', '2023-06-22 09:58:19.045386+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (3, 'admin', '0001_initial', '2023-06-22 09:58:19.089406+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (4, 'admin', '0002_logentry_remove_auto_add', '2023-06-22 09:58:19.107328+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (5, 'admin', '0003_logentry_add_action_flag_choices', '2023-06-22 09:58:19.125044+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (6, 'contenttypes', '0002_remove_content_type_name', '2023-06-22 09:58:19.159439+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (7, 'auth', '0002_alter_permission_name_max_length', '2023-06-22 09:58:19.175916+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (8, 'auth', '0003_alter_user_email_max_length', '2023-06-22 09:58:19.200431+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (9, 'auth', '0004_alter_user_username_opts', '2023-06-22 09:58:19.219113+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (10, 'auth', '0005_alter_user_last_login_null', '2023-06-22 09:58:19.24612+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (11, 'auth', '0006_require_contenttypes_0002', '2023-06-22 09:58:19.249058+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (12, 'auth', '0007_alter_validators_add_error_messages', '2023-06-22 09:58:19.26321+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (13, 'auth', '0008_alter_user_username_max_length', '2023-06-22 09:58:19.283685+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (14, 'auth', '0009_alter_user_last_name_max_length', '2023-06-22 09:58:19.297015+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (15, 'auth', '0010_alter_group_name_max_length', '2023-06-22 09:58:19.316294+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (16, 'auth', '0011_update_proxy_permissions', '2023-06-22 09:58:19.33061+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (17, 'auth', '0012_alter_user_first_name_max_length', '2023-06-22 09:58:19.344521+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (18, 'authtoken', '0001_initial', '2023-06-22 09:58:19.379879+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (19, 'authtoken', '0002_auto_20160226_1747', '2023-06-22 09:58:19.426677+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (20, 'authtoken', '0003_tokenproxy', '2023-06-22 09:58:19.435688+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (21, 'contracts', '0001_initial', '2023-06-22 09:58:19.464083+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (22, 'contracts', '0002_auto_20210119_1136', '2023-06-22 09:58:19.475829+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (23, 'contracts', '0003_auto_20210122_1352', '2023-06-22 09:58:19.482855+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (24, 'contracts', '0004_auto_20210125_0925', '2023-06-22 09:58:19.487959+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (25, 'contracts', '0005_alter_contractabi_id', '2023-06-22 09:58:19.555632+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (26, 'contracts', '0006_contractabi_abi_hash', '2023-06-22 09:58:19.588799+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (27, 'contracts', '0007_contract_trusted_for_delegate_call', '2023-06-22 09:58:19.609093+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (28, 'contracts', '0008_ethereum_address_field_v2', '2023-06-22 09:58:19.634681+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (29, 'contracts', '0009_alter_contractabi_abi_hash', '2023-06-22 09:58:19.655298+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (30, 'contracts', '0010_alter_contract_logo', '2023-06-22 09:58:19.664084+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (31, 'django_celery_beat', '0001_initial', '2023-06-22 09:58:19.721489+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (32, 'django_celery_beat', '0002_auto_20161118_0346', '2023-06-22 09:58:19.742134+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (33, 'django_celery_beat', '0003_auto_20161209_0049', '2023-06-22 09:58:19.753992+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (34, 'django_celery_beat', '0004_auto_20170221_0000', '2023-06-22 09:58:19.759094+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (35, 'django_celery_beat', '0005_add_solarschedule_events_choices', '2023-06-22 09:58:19.767762+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (36, 'django_celery_beat', '0006_auto_20180322_0932', '2023-06-22 09:58:19.799279+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (37, 'django_celery_beat', '0007_auto_20180521_0826', '2023-06-22 09:58:19.814572+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (38, 'django_celery_beat', '0008_auto_20180914_1922', '2023-06-22 09:58:19.840927+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (39, 'django_celery_beat', '0006_auto_20180210_1226', '2023-06-22 09:58:19.859977+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (40, 'django_celery_beat', '0006_periodictask_priority', '2023-06-22 09:58:19.871101+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (41, 'django_celery_beat', '0009_periodictask_headers', '2023-06-22 09:58:19.881334+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (42, 'django_celery_beat', '0010_auto_20190429_0326', '2023-06-22 09:58:19.985454+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (43, 'django_celery_beat', '0011_auto_20190508_0153', '2023-06-22 09:58:20.006671+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (44, 'django_celery_beat', '0012_periodictask_expire_seconds', '2023-06-22 09:58:20.014801+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (45, 'django_celery_beat', '0013_auto_20200609_0727', '2023-06-22 09:58:20.022511+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (46, 'django_celery_beat', '0014_remove_clockedschedule_enabled', '2023-06-22 09:58:20.028313+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (47, 'django_celery_beat', '0015_edit_solarschedule_events_choices', '2023-06-22 09:58:20.039439+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (48, 'django_celery_beat', '0016_alter_crontabschedule_timezone', '2023-06-22 09:58:20.046882+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (49, 'history', '0001_initial', '2023-06-22 09:58:20.081091+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (50, 'history', '0002_auto_20190725_0857', '2023-06-22 09:58:20.101169+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (51, 'history', '0003_auto_20191107_1459', '2023-06-22 09:58:20.431984+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (52, 'history', '0004_auto_20191118_1001', '2023-06-22 09:58:20.455607+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (53, 'history', '0005_multisigtransaction_failed', '2023-06-22 09:58:20.784023+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (54, 'history', '0006_auto_20200113_1204', '2023-06-22 09:58:20.817169+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (55, 'history', '0007_auto_20200122_1305', '2023-06-22 09:58:20.848738+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (56, 'history', '0008_ethereumtx_logs', '2023-06-22 09:58:20.858329+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (57, 'history', '0009_multisigtransaction_origin', '2023-06-22 09:58:20.878183+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (58, 'history', '0010_auto_20200226_1508', '2023-06-22 09:58:21.016409+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (59, 'history', '0011_auto_20200303_0956', '2023-06-22 09:58:21.031297+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (60, 'history', '0012_moduletransaction', '2023-06-22 09:58:21.072527+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (61, 'history', '0013_multisigtransaction_fix_failed', '2023-06-22 09:58:21.094484+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (62, 'history', '0014_auto_20200327_0954', '2023-06-22 09:58:21.155837+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (63, 'history', '0015_auto_20200327_1233', '2023-06-22 09:58:21.199792+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (64, 'history', '0016_multisigconfirmation_signature_type', '2023-06-22 09:58:21.237754+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (65, 'history', '0017_safecontractdelegate', '2023-06-22 09:58:21.264467+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (66, 'history', '0018_multisigtransaction_trusted', '2023-06-22 09:58:21.301902+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (67, 'history', '0019_transactions_data_none', '2023-06-22 09:58:21.33352+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (68, 'history', '0020_safemastercopy_version', '2023-06-22 09:58:21.339285+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (69, 'history', '0021_moduletransaction_failed', '2023-06-22 09:58:21.374955+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (70, 'history', '0022_auto_20200903_1045', '2023-06-22 09:58:21.384881+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (71, 'history', '0023_auto_20200924_0841', '2023-06-22 09:58:21.394057+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (72, 'history', '0024_auto_20201014_1523', '2023-06-22 09:58:21.403118+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (73, 'history', '0025_auto_20201015_1147', '2023-06-22 09:58:21.429917+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (74, 'history', '0026_auto_20201030_1355', '2023-06-22 09:58:21.439621+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (75, 'history', '0027_remove_errored_internal_txs_20201112_1547', '2023-06-22 09:58:21.461867+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (76, 'history', '0028_auto_20201112_1613', '2023-06-22 09:58:21.480827+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (77, 'history', '0029_auto_20201118_1015', '2023-06-22 09:58:21.499558+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (78, 'history', '0030_auto_20210203_1541', '2023-06-22 09:58:21.508116+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (79, 'history', '0031_webhook_new_safe', '2023-06-22 09:58:21.513703+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (80, 'history', '0032_webhook_new_module_transaction', '2023-06-22 09:58:21.519674+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (81, 'history', '0033_auto_20210318_1654', '2023-06-22 09:58:21.542171+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (82, 'history', '0034_webhook_new_outgoing_transaction', '2023-06-22 09:58:21.548395+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (83, 'history', '0035_safemastercopy_deployer', '2023-06-22 09:58:21.554222+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (84, 'history', '0036_fix_exec_from_module', '2023-06-22 09:58:21.579954+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (85, 'history', '0037_fix_failed_module_transactions', '2023-06-22 09:58:21.605056+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (86, 'history', '0038_safestatus_guard', '2023-06-22 09:58:21.613946+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (87, 'history', '0039_safel2mastercopy_20210519', '2023-06-22 09:58:21.636391+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (88, 'history', '0040_auto_20210607_1007', '2023-06-22 09:58:21.91073+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (89, 'history', '0041_auto_20210729_0916', '2023-06-22 09:58:21.958948+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (90, 'history', '0042_safestatus_history_saf_address_1c362b_idx', '2023-06-22 09:58:21.97146+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (91, 'history', '0043_auto_20210927_1515', '2023-06-22 09:58:22.004138+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (92, 'history', '0044_reprocess_module_txs', '2023-06-22 09:58:22.034333+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (93, 'history', '0045_erc20transfer_erc721transfer', '2023-06-22 09:58:22.123197+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (94, 'history', '0046_delete_ethereumevent', '2023-06-22 09:58:22.135075+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (95, 'history', '0047_auto_20211102_1659', '2023-06-22 09:58:22.195776+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (96, 'history', '0048_block_number_token_transfers_20211126_1443', '2023-06-22 09:58:22.473303+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (97, 'history', '0049_block_number_internaltx_20211129_1111', '2023-06-22 09:58:22.620497+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (98, 'history', '0050_ethereum_address_field_v2_20211201_1507', '2023-06-22 09:58:23.958154+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (99, 'history', '0051_ethereum_address_field_v2_update', '2023-06-22 09:58:23.998893+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (100, 'history', '0052_keccak256_field_20211209_1628', '2023-06-22 09:58:24.511866+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (101, 'history', '0053_alter_webhook_address', '2023-06-22 09:58:24.524125+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (102, 'history', '0054_webhook_authorization', '2023-06-22 09:58:24.529622+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (103, 'history', '0055_alter_multisigtransaction_options', '2023-06-22 09:58:24.540035+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (104, 'history', '0056_alter_multisigconfirmation_signature', '2023-06-22 09:58:24.551552+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (105, 'history', '0057_alter_webhook_authorization', '2023-06-22 09:58:24.557681+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (106, 'history', '0058_alter_webhook_url', '2023-06-22 09:58:24.5642+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (107, 'history', '0059_auto_20220408_1020', '2023-06-22 09:58:24.584351+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (108, 'history', '0060_add_eip1559_fields_20220419_0955', '2023-06-22 09:58:24.615783+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (109, 'history', '0061_alter_internaltx_block_number', '2023-06-22 09:58:24.630527+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (110, 'history', '0062_add_safe_last_status_20220429_0922', '2023-06-22 09:58:24.710785+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (111, 'history', '0063_alter_internaltx__from', '2023-06-22 09:58:24.748109+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (112, 'history', '0064_auto_20220523_0919', '2023-06-22 09:58:24.770163+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (113, 'history', '0065_safelaststatus_history_saf_enabled_020fea_gin', '2023-06-22 09:58:24.785437+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (114, 'history', '0066_auto_20220628_1125', '2023-06-22 09:58:24.839441+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (115, 'history', '0067_auto_20220705_1545', '2023-06-22 09:58:24.920526+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (116, 'history', '0068_alter_multisigtransaction_origin', '2023-06-22 09:58:25.002439+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (117, 'history', '0069_indexingstatus_and_more', '2023-06-22 09:58:25.094341+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (118, 'notifications', '0001_initial', '2023-06-22 09:58:25.143745+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (119, 'notifications', '0002_auto_20200806_1534', '2023-06-22 09:58:25.152326+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (120, 'notifications', '0003_firebasedeviceowner', '2023-06-22 09:58:25.186076+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (121, 'notifications', '0004_alter_firebasedeviceowner_id', '2023-06-22 09:58:25.208786+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (122, 'notifications', '0005_ethereum_address_field_v2', '2023-06-22 09:58:25.274546+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (123, 'safe_messages', '0001_initial', '2023-06-22 09:58:25.32501+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (124, 'sessions', '0001_initial', '2023-06-22 09:58:25.35831+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (125, 'sites', '0001_initial', '2023-06-22 09:58:25.380594+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (126, 'sites', '0002_alter_domain_unique', '2023-06-22 09:58:25.393577+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (127, 'tokens', '0001_initial', '2023-06-22 09:58:25.411949+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (128, 'tokens', '0002_auto_20200903_1045', '2023-06-22 09:58:25.673634+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (129, 'tokens', '0003_auto_20201222_1053', '2023-06-22 09:58:25.708847+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (130, 'tokens', '0004_ethereum_address_field_v2_20211201_1512', '2023-06-22 09:58:25.746901+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (131, 'tokens', '0005_add_logo_file_20220201_1335', '2023-06-22 09:58:25.760216+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (132, 'tokens', '0006_auto_20220214_1629', '2023-06-22 09:58:25.779944+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (133, 'tokens', '0007_alter_token_logo', '2023-06-22 09:58:25.79017+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (134, 'tokens', '0008_alter_token_copy_price', '2023-06-22 09:58:25.798005+00');
INSERT INTO public.django_migrations (id, app, name, applied) VALUES (135, 'tokens', '0009_token_token_spam_idx', '2023-06-22 09:58:25.808837+00');

--
-- Data for Name: django_session; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: django_site; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.django_site (id, domain, name) VALUES (1, 'example.com', 'example.com');

--
-- Data for Name: history_erc20transfer; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_erc721transfer; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_ethereumblock; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_ethereumtx; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_indexingstatus; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.history_indexingstatus (indexing_type, block_number) VALUES (0, 0);

--
-- Data for Name: history_internaltx; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_internaltxdecoded; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_moduletransaction; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_multisigconfirmation; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_multisigtransaction; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_proxyfactory; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.history_proxyfactory (address, initial_block_number, tx_block_number) VALUES ('\xa6b71e26c5e0845f74c812102ca7114b6a896ab2', 0, 0);

--
-- Data for Name: history_safecontract; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_safecontractdelegate; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_safelaststatus; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_safemastercopy; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.history_safemastercopy (address, initial_block_number, tx_block_number, version, deployer, l2) VALUES ('\x3e5c63644e683549055b9be8653de26e0b4cd36e', 0, 0, '1.3.0+L2', 'Gnosis', true);

--
-- Data for Name: history_safestatus; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: history_webhook; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: notifications_firebasedevice; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: notifications_firebasedevice_safes; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: notifications_firebasedeviceowner; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: safe_messages_safemessage; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: safe_messages_safemessageconfirmation; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Data for Name: tokens_token; Type: TABLE DATA; Schema: public; Owner: postgres
--

--
-- Name: auth_group_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.auth_group_id_seq', 1, false);

--
-- Name: auth_group_permissions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.auth_group_permissions_id_seq', 1, false);

--
-- Name: auth_permission_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.auth_permission_id_seq', 157, true);

--
-- Name: auth_user_groups_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.auth_user_groups_id_seq', 1, false);

--
-- Name: auth_user_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.auth_user_id_seq', 1, false);

--
-- Name: auth_user_user_permissions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.auth_user_user_permissions_id_seq', 1, false);

--
-- Name: contracts_contractabi_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.contracts_contractabi_id_seq', 1, false);

--
-- Name: django_admin_log_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_admin_log_id_seq', 1, false);

--
-- Name: django_celery_beat_clockedschedule_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_celery_beat_clockedschedule_id_seq', 1, false);

--
-- Name: django_celery_beat_crontabschedule_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_celery_beat_crontabschedule_id_seq', 1, true);

--
-- Name: django_celery_beat_intervalschedule_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_celery_beat_intervalschedule_id_seq', 10, true);

--
-- Name: django_celery_beat_periodictask_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_celery_beat_periodictask_id_seq', 14, true);

--
-- Name: django_celery_beat_solarschedule_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_celery_beat_solarschedule_id_seq', 1, false);

--
-- Name: django_content_type_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_content_type_id_seq', 39, true);

--
-- Name: django_migrations_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_migrations_id_seq', 135, true);

--
-- Name: django_site_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.django_site_id_seq', 1, true);

--
-- Name: history_erc20transfer_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.history_erc20transfer_id_seq', 1, false);

--
-- Name: history_erc721transfer_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.history_erc721transfer_id_seq', 1, false);

--
-- Name: history_internaltx_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.history_internaltx_id_seq', 1, false);

--
-- Name: history_multisigconfirmation_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.history_multisigconfirmation_id_seq', 1, false);

--
-- Name: history_safecontractdelegate_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.history_safecontractdelegate_id_seq', 1, false);

--
-- Name: history_webhook_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.history_webhook_id_seq', 1, false);

--
-- Name: notifications_firebasedevice_safes_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.notifications_firebasedevice_safes_id_seq', 1, false);

--
-- Name: notifications_firebasedeviceowner_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.notifications_firebasedeviceowner_id_seq', 1, false);

--
-- Name: safe_messages_safemessageconfirmation_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.safe_messages_safemessageconfirmation_id_seq', 1, false);

--
-- Name: auth_group auth_group_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_group
    ADD CONSTRAINT auth_group_name_key UNIQUE (name);

--
-- Name: auth_group_permissions auth_group_permissions_group_id_permission_id_0cd325b0_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_group_permissions
    ADD CONSTRAINT auth_group_permissions_group_id_permission_id_0cd325b0_uniq UNIQUE (group_id, permission_id);

--
-- Name: auth_group_permissions auth_group_permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_group_permissions
    ADD CONSTRAINT auth_group_permissions_pkey PRIMARY KEY (id);

--
-- Name: auth_group auth_group_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_group
    ADD CONSTRAINT auth_group_pkey PRIMARY KEY (id);

--
-- Name: auth_permission auth_permission_content_type_id_codename_01ab375a_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_permission
    ADD CONSTRAINT auth_permission_content_type_id_codename_01ab375a_uniq UNIQUE (content_type_id, codename);

--
-- Name: auth_permission auth_permission_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_permission
    ADD CONSTRAINT auth_permission_pkey PRIMARY KEY (id);

--
-- Name: auth_user_groups auth_user_groups_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user_groups
    ADD CONSTRAINT auth_user_groups_pkey PRIMARY KEY (id);

--
-- Name: auth_user_groups auth_user_groups_user_id_group_id_94350c0c_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user_groups
    ADD CONSTRAINT auth_user_groups_user_id_group_id_94350c0c_uniq UNIQUE (user_id, group_id);

--
-- Name: auth_user auth_user_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user
    ADD CONSTRAINT auth_user_pkey PRIMARY KEY (id);

--
-- Name: auth_user_user_permissions auth_user_user_permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user_user_permissions
    ADD CONSTRAINT auth_user_user_permissions_pkey PRIMARY KEY (id);

--
-- Name: auth_user_user_permissions auth_user_user_permissions_user_id_permission_id_14a6b632_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user_user_permissions
    ADD CONSTRAINT auth_user_user_permissions_user_id_permission_id_14a6b632_uniq UNIQUE (user_id, permission_id);

--
-- Name: auth_user auth_user_username_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user
    ADD CONSTRAINT auth_user_username_key UNIQUE (username);

--
-- Name: authtoken_token authtoken_token_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.authtoken_token
    ADD CONSTRAINT authtoken_token_pkey PRIMARY KEY (key);

--
-- Name: authtoken_token authtoken_token_user_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.authtoken_token
    ADD CONSTRAINT authtoken_token_user_id_key UNIQUE (user_id);

--
-- Name: contracts_contract contracts_contract_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contracts_contract
    ADD CONSTRAINT contracts_contract_pkey PRIMARY KEY (address);

--
-- Name: contracts_contractabi contracts_contractabi_abi_hash_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contracts_contractabi
    ADD CONSTRAINT contracts_contractabi_abi_hash_key UNIQUE (abi_hash);

--
-- Name: contracts_contractabi contracts_contractabi_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contracts_contractabi
    ADD CONSTRAINT contracts_contractabi_pkey PRIMARY KEY (id);

--
-- Name: django_admin_log django_admin_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_admin_log
    ADD CONSTRAINT django_admin_log_pkey PRIMARY KEY (id);

--
-- Name: django_celery_beat_clockedschedule django_celery_beat_clockedschedule_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_clockedschedule
    ADD CONSTRAINT django_celery_beat_clockedschedule_pkey PRIMARY KEY (id);

--
-- Name: django_celery_beat_crontabschedule django_celery_beat_crontabschedule_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_crontabschedule
    ADD CONSTRAINT django_celery_beat_crontabschedule_pkey PRIMARY KEY (id);

--
-- Name: django_celery_beat_intervalschedule django_celery_beat_intervalschedule_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_intervalschedule
    ADD CONSTRAINT django_celery_beat_intervalschedule_pkey PRIMARY KEY (id);

--
-- Name: django_celery_beat_periodictask django_celery_beat_periodictask_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_periodictask
    ADD CONSTRAINT django_celery_beat_periodictask_name_key UNIQUE (name);

--
-- Name: django_celery_beat_periodictask django_celery_beat_periodictask_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_periodictask
    ADD CONSTRAINT django_celery_beat_periodictask_pkey PRIMARY KEY (id);

--
-- Name: django_celery_beat_periodictasks django_celery_beat_periodictasks_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_periodictasks
    ADD CONSTRAINT django_celery_beat_periodictasks_pkey PRIMARY KEY (ident);

--
-- Name: django_celery_beat_solarschedule django_celery_beat_solar_event_latitude_longitude_ba64999a_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_solarschedule
    ADD CONSTRAINT django_celery_beat_solar_event_latitude_longitude_ba64999a_uniq UNIQUE (event, latitude, longitude);

--
-- Name: django_celery_beat_solarschedule django_celery_beat_solarschedule_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_solarschedule
    ADD CONSTRAINT django_celery_beat_solarschedule_pkey PRIMARY KEY (id);

--
-- Name: django_content_type django_content_type_app_label_model_76bd3d3b_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_content_type
    ADD CONSTRAINT django_content_type_app_label_model_76bd3d3b_uniq UNIQUE (app_label, model);

--
-- Name: django_content_type django_content_type_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_content_type
    ADD CONSTRAINT django_content_type_pkey PRIMARY KEY (id);

--
-- Name: django_migrations django_migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_migrations
    ADD CONSTRAINT django_migrations_pkey PRIMARY KEY (id);

--
-- Name: django_session django_session_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_session
    ADD CONSTRAINT django_session_pkey PRIMARY KEY (session_key);

--
-- Name: django_site django_site_domain_a2e37b91_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_site
    ADD CONSTRAINT django_site_domain_a2e37b91_uniq UNIQUE (domain);

--
-- Name: django_site django_site_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_site
    ADD CONSTRAINT django_site_pkey PRIMARY KEY (id);

--
-- Name: history_erc20transfer history_erc20transfer_ethereum_tx_id_log_index_c6789789_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_erc20transfer
    ADD CONSTRAINT history_erc20transfer_ethereum_tx_id_log_index_c6789789_uniq UNIQUE (ethereum_tx_id, log_index);

--
-- Name: history_erc20transfer history_erc20transfer_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_erc20transfer
    ADD CONSTRAINT history_erc20transfer_pkey PRIMARY KEY (id);

--
-- Name: history_erc721transfer history_erc721transfer_ethereum_tx_id_log_index_a874445d_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_erc721transfer
    ADD CONSTRAINT history_erc721transfer_ethereum_tx_id_log_index_a874445d_uniq UNIQUE (ethereum_tx_id, log_index);

--
-- Name: history_erc721transfer history_erc721transfer_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_erc721transfer
    ADD CONSTRAINT history_erc721transfer_pkey PRIMARY KEY (id);

--
-- Name: history_ethereumblock history_ethereumblock_block_hash_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_ethereumblock
    ADD CONSTRAINT history_ethereumblock_block_hash_key UNIQUE (block_hash);

--
-- Name: history_ethereumblock history_ethereumblock_parent_hash_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_ethereumblock
    ADD CONSTRAINT history_ethereumblock_parent_hash_key UNIQUE (parent_hash);

--
-- Name: history_ethereumblock history_ethereumblock_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_ethereumblock
    ADD CONSTRAINT history_ethereumblock_pkey PRIMARY KEY (number);

--
-- Name: history_ethereumtx history_ethereumtx_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_ethereumtx
    ADD CONSTRAINT history_ethereumtx_pkey PRIMARY KEY (tx_hash);

--
-- Name: history_indexingstatus history_indexingstatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_indexingstatus
    ADD CONSTRAINT history_indexingstatus_pkey PRIMARY KEY (indexing_type);

--
-- Name: history_internaltx history_internaltx_ethereum_tx_id_trace_address_c7c2fa9c_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_internaltx
    ADD CONSTRAINT history_internaltx_ethereum_tx_id_trace_address_c7c2fa9c_uniq UNIQUE (ethereum_tx_id, trace_address);

--
-- Name: history_internaltx history_internaltx_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_internaltx
    ADD CONSTRAINT history_internaltx_pkey PRIMARY KEY (id);

--
-- Name: history_internaltxdecoded history_internaltxdecoded_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_internaltxdecoded
    ADD CONSTRAINT history_internaltxdecoded_pkey PRIMARY KEY (internal_tx_id);

--
-- Name: history_moduletransaction history_moduletransaction_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_moduletransaction
    ADD CONSTRAINT history_moduletransaction_pkey PRIMARY KEY (internal_tx_id);

--
-- Name: history_multisigconfirmation history_multisigconfirma_multisig_transaction_has_f98adf7b_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_multisigconfirmation
    ADD CONSTRAINT history_multisigconfirma_multisig_transaction_has_f98adf7b_uniq UNIQUE (multisig_transaction_hash, owner);

--
-- Name: history_multisigconfirmation history_multisigconfirmation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_multisigconfirmation
    ADD CONSTRAINT history_multisigconfirmation_pkey PRIMARY KEY (id);

--
-- Name: history_multisigtransaction history_multisigtransaction_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_multisigtransaction
    ADD CONSTRAINT history_multisigtransaction_pkey PRIMARY KEY (safe_tx_hash);

--
-- Name: history_proxyfactory history_proxyfactory_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_proxyfactory
    ADD CONSTRAINT history_proxyfactory_pkey PRIMARY KEY (address);

--
-- Name: history_safecontract history_safecontract_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safecontract
    ADD CONSTRAINT history_safecontract_pkey PRIMARY KEY (address);

--
-- Name: history_safecontractdelegate history_safecontractdele_safe_contract_id_delegat_5fd0067a_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safecontractdelegate
    ADD CONSTRAINT history_safecontractdele_safe_contract_id_delegat_5fd0067a_uniq UNIQUE (safe_contract_id, delegate, delegator);

--
-- Name: history_safecontractdelegate history_safecontractdelegate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safecontractdelegate
    ADD CONSTRAINT history_safecontractdelegate_pkey PRIMARY KEY (id);

--
-- Name: history_safelaststatus history_safelaststatus_internal_tx_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safelaststatus
    ADD CONSTRAINT history_safelaststatus_internal_tx_id_key UNIQUE (internal_tx_id);

--
-- Name: history_safelaststatus history_safelaststatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safelaststatus
    ADD CONSTRAINT history_safelaststatus_pkey PRIMARY KEY (address);

--
-- Name: history_safemastercopy history_safemastercopy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safemastercopy
    ADD CONSTRAINT history_safemastercopy_pkey PRIMARY KEY (address);

--
-- Name: history_safestatus history_safestatus_internal_tx_id_address_14c99a89_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safestatus
    ADD CONSTRAINT history_safestatus_internal_tx_id_address_14c99a89_uniq UNIQUE (internal_tx_id, address);

--
-- Name: history_safestatus history_safestatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safestatus
    ADD CONSTRAINT history_safestatus_pkey PRIMARY KEY (internal_tx_id);

--
-- Name: history_webhook history_webhook_address_url_5d78af21_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_webhook
    ADD CONSTRAINT history_webhook_address_url_5d78af21_uniq UNIQUE (address, url);

--
-- Name: history_webhook history_webhook_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_webhook
    ADD CONSTRAINT history_webhook_pkey PRIMARY KEY (id);

--
-- Name: notifications_firebasedeviceowner notifications_firebasede_firebase_device_id_owner_74fe4cd9_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedeviceowner
    ADD CONSTRAINT notifications_firebasede_firebase_device_id_owner_74fe4cd9_uniq UNIQUE (firebase_device_id, owner);

--
-- Name: notifications_firebasedevice_safes notifications_firebasede_firebasedevice_id_safeco_980226aa_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedevice_safes
    ADD CONSTRAINT notifications_firebasede_firebasedevice_id_safeco_980226aa_uniq UNIQUE (firebasedevice_id, safecontract_id);

--
-- Name: notifications_firebasedevice notifications_firebasedevice_cloud_messaging_token_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedevice
    ADD CONSTRAINT notifications_firebasedevice_cloud_messaging_token_key UNIQUE (cloud_messaging_token);

--
-- Name: notifications_firebasedevice notifications_firebasedevice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedevice
    ADD CONSTRAINT notifications_firebasedevice_pkey PRIMARY KEY (uuid);

--
-- Name: notifications_firebasedevice_safes notifications_firebasedevice_safes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedevice_safes
    ADD CONSTRAINT notifications_firebasedevice_safes_pkey PRIMARY KEY (id);

--
-- Name: notifications_firebasedeviceowner notifications_firebasedeviceowner_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedeviceowner
    ADD CONSTRAINT notifications_firebasedeviceowner_pkey PRIMARY KEY (id);

--
-- Name: safe_messages_safemessageconfirmation safe_messages_safemessag_safe_message_id_owner_ce8adc27_uniq; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.safe_messages_safemessageconfirmation
    ADD CONSTRAINT safe_messages_safemessag_safe_message_id_owner_ce8adc27_uniq UNIQUE (safe_message_id, owner);

--
-- Name: safe_messages_safemessage safe_messages_safemessage_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.safe_messages_safemessage
    ADD CONSTRAINT safe_messages_safemessage_pkey PRIMARY KEY (message_hash);

--
-- Name: safe_messages_safemessageconfirmation safe_messages_safemessageconfirmation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.safe_messages_safemessageconfirmation
    ADD CONSTRAINT safe_messages_safemessageconfirmation_pkey PRIMARY KEY (id);

--
-- Name: tokens_token tokens_token_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tokens_token
    ADD CONSTRAINT tokens_token_pkey PRIMARY KEY (address);

--
-- Name: auth_group_name_a6ea08ec_like; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_group_name_a6ea08ec_like ON public.auth_group USING btree (name varchar_pattern_ops);

--
-- Name: auth_group_permissions_group_id_b120cbf9; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_group_permissions_group_id_b120cbf9 ON public.auth_group_permissions USING btree (group_id);

--
-- Name: auth_group_permissions_permission_id_84c5c92e; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_group_permissions_permission_id_84c5c92e ON public.auth_group_permissions USING btree (permission_id);

--
-- Name: auth_permission_content_type_id_2f476e4b; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_permission_content_type_id_2f476e4b ON public.auth_permission USING btree (content_type_id);

--
-- Name: auth_user_groups_group_id_97559544; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_user_groups_group_id_97559544 ON public.auth_user_groups USING btree (group_id);

--
-- Name: auth_user_groups_user_id_6a12ed8b; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_user_groups_user_id_6a12ed8b ON public.auth_user_groups USING btree (user_id);

--
-- Name: auth_user_user_permissions_permission_id_1fbb5f2c; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_user_user_permissions_permission_id_1fbb5f2c ON public.auth_user_user_permissions USING btree (permission_id);

--
-- Name: auth_user_user_permissions_user_id_a95ead1b; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_user_user_permissions_user_id_a95ead1b ON public.auth_user_user_permissions USING btree (user_id);

--
-- Name: auth_user_username_6821ab7c_like; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX auth_user_username_6821ab7c_like ON public.auth_user USING btree (username varchar_pattern_ops);

--
-- Name: authtoken_token_key_10f0b77e_like; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX authtoken_token_key_10f0b77e_like ON public.authtoken_token USING btree (key varchar_pattern_ops);

--
-- Name: contracts_contract_contract_abi_id_1c37b4bd; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX contracts_contract_contract_abi_id_1c37b4bd ON public.contracts_contract USING btree (contract_abi_id);

--
-- Name: django_admin_log_content_type_id_c4bce8eb; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_admin_log_content_type_id_c4bce8eb ON public.django_admin_log USING btree (content_type_id);

--
-- Name: django_admin_log_user_id_c564eba6; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_admin_log_user_id_c564eba6 ON public.django_admin_log USING btree (user_id);

--
-- Name: django_celery_beat_periodictask_clocked_id_47a69f82; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_celery_beat_periodictask_clocked_id_47a69f82 ON public.django_celery_beat_periodictask USING btree (clocked_id);

--
-- Name: django_celery_beat_periodictask_crontab_id_d3cba168; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_celery_beat_periodictask_crontab_id_d3cba168 ON public.django_celery_beat_periodictask USING btree (crontab_id);

--
-- Name: django_celery_beat_periodictask_interval_id_a8ca27da; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_celery_beat_periodictask_interval_id_a8ca27da ON public.django_celery_beat_periodictask USING btree (interval_id);

--
-- Name: django_celery_beat_periodictask_name_265a36b7_like; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_celery_beat_periodictask_name_265a36b7_like ON public.django_celery_beat_periodictask USING btree (name varchar_pattern_ops);

--
-- Name: django_celery_beat_periodictask_solar_id_a87ce72c; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_celery_beat_periodictask_solar_id_a87ce72c ON public.django_celery_beat_periodictask USING btree (solar_id);

--
-- Name: django_session_expire_date_a5c62663; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_session_expire_date_a5c62663 ON public.django_session USING btree (expire_date);

--
-- Name: django_session_session_key_c0390e0f_like; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_session_session_key_c0390e0f_like ON public.django_session USING btree (session_key varchar_pattern_ops);

--
-- Name: django_site_domain_a2e37b91_like; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX django_site_domain_a2e37b91_like ON public.django_site USING btree (domain varchar_pattern_ops);

--
-- Name: history_decoded_processed_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_decoded_processed_idx ON public.history_internaltxdecoded USING btree (processed) WHERE (NOT processed);

--
-- Name: history_erc20transfer_ethereum_tx_id_16a6036b; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc20transfer_ethereum_tx_id_16a6036b ON public.history_erc20transfer USING btree (ethereum_tx_id);

--
-- Name: history_erc20transfer_timestamp_b14c5ef4; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc20transfer_timestamp_b14c5ef4 ON public.history_erc20transfer USING btree ("timestamp");

--
-- Name: history_erc721transfer_ethereum_tx_id_aa020110; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc721transfer_ethereum_tx_id_aa020110 ON public.history_erc721transfer USING btree (ethereum_tx_id);

--
-- Name: history_erc721transfer_timestamp_aaadcf46; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc721transfer_timestamp_aaadcf46 ON public.history_erc721transfer USING btree ("timestamp");

--
-- Name: history_erc__from_64986c_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc__from_64986c_idx ON public.history_erc20transfer USING btree (_from, "timestamp");

--
-- Name: history_erc__from_72fb41_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc__from_72fb41_idx ON public.history_erc721transfer USING btree (_from, "timestamp");

--
-- Name: history_erc_address_94cee3_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc_address_94cee3_idx ON public.history_erc721transfer USING btree (address);

--
-- Name: history_erc_address_dba64d_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc_address_dba64d_idx ON public.history_erc20transfer USING btree (address);

--
-- Name: history_erc_to_02d4ab_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc_to_02d4ab_idx ON public.history_erc721transfer USING btree ("to", "timestamp");

--
-- Name: history_erc_to_f32154_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_erc_to_f32154_idx ON public.history_erc20transfer USING btree ("to", "timestamp");

--
-- Name: history_ethereumblock_confirmed_5ca6a779; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_ethereumblock_confirmed_5ca6a779 ON public.history_ethereumblock USING btree (confirmed);

--
-- Name: history_ethereumtx__from_e36d4662; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_ethereumtx__from_e36d4662 ON public.history_ethereumtx USING btree (_from);

--
-- Name: history_ethereumtx_block_id_92e7f70e; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_ethereumtx_block_id_92e7f70e ON public.history_ethereumtx USING btree (block_id);

--
-- Name: history_ethereumtx_status_d1d0de2c; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_ethereumtx_status_d1d0de2c ON public.history_ethereumtx USING btree (status);

--
-- Name: history_ethereumtx_to_9fb37c13; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_ethereumtx_to_9fb37c13 ON public.history_ethereumtx USING btree ("to");

--
-- Name: history_indexingstatus_block_number_40805e1c; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_indexingstatus_block_number_40805e1c ON public.history_indexingstatus USING btree (block_number);

--
-- Name: history_int__from_31d634_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_int__from_31d634_idx ON public.history_internaltx USING btree (_from, "timestamp");

--
-- Name: history_int_to_e72886_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_int_to_e72886_idx ON public.history_internaltx USING btree ("to", "timestamp");

--
-- Name: history_internaltx__from_36470cfd; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx__from_36470cfd ON public.history_internaltx USING btree (_from);

--
-- Name: history_internaltx_block_number_9004df5f; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx_block_number_9004df5f ON public.history_internaltx USING btree (block_number);

--
-- Name: history_internaltx_call_type_1f0c4296; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx_call_type_1f0c4296 ON public.history_internaltx USING btree (call_type);

--
-- Name: history_internaltx_contract_address_134466b3; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx_contract_address_134466b3 ON public.history_internaltx USING btree (contract_address);

--
-- Name: history_internaltx_ethereum_tx_id_e6ac35ab; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx_ethereum_tx_id_e6ac35ab ON public.history_internaltx USING btree (ethereum_tx_id);

--
-- Name: history_internaltx_refund_address_09530831; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx_refund_address_09530831 ON public.history_internaltx USING btree (refund_address);

--
-- Name: history_internaltx_timestamp_ef4d64cb; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx_timestamp_ef4d64cb ON public.history_internaltx USING btree ("timestamp");

--
-- Name: history_internaltx_tx_type_bb97604e; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx_tx_type_bb97604e ON public.history_internaltx USING btree (tx_type);

--
-- Name: history_internaltx_value_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltx_value_idx ON public.history_internaltx USING btree (value) WHERE (value > (0)::numeric);

--
-- Name: history_internaltxdecoded_function_name_333ae03e; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltxdecoded_function_name_333ae03e ON public.history_internaltxdecoded USING btree (function_name);

--
-- Name: history_internaltxdecoded_function_name_333ae03e_like; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_internaltxdecoded_function_name_333ae03e_like ON public.history_internaltxdecoded USING btree (function_name varchar_pattern_ops);

--
-- Name: history_moduletransaction_module_5bf50dd1; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_moduletransaction_module_5bf50dd1 ON public.history_moduletransaction USING btree (module);

--
-- Name: history_moduletransaction_safe_794cf9b4; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_moduletransaction_safe_794cf9b4 ON public.history_moduletransaction USING btree (safe);

--
-- Name: history_moduletransaction_to_041e4c7b; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_moduletransaction_to_041e4c7b ON public.history_moduletransaction USING btree ("to");

--
-- Name: history_multisigconfirmation_ethereum_tx_id_71e0ab73; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigconfirmation_ethereum_tx_id_71e0ab73 ON public.history_multisigconfirmation USING btree (ethereum_tx_id);

--
-- Name: history_multisigconfirmation_multisig_transaction_hash_4c8cbf7a; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigconfirmation_multisig_transaction_hash_4c8cbf7a ON public.history_multisigconfirmation USING btree (multisig_transaction_hash);

--
-- Name: history_multisigconfirmation_multisig_transaction_id_43ec94d5; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigconfirmation_multisig_transaction_id_43ec94d5 ON public.history_multisigconfirmation USING btree (multisig_transaction_id);

--
-- Name: history_multisigconfirmation_signature_type_9679d821; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigconfirmation_signature_type_9679d821 ON public.history_multisigconfirmation USING btree (signature_type);

--
-- Name: history_multisigtransaction_ethereum_tx_id_c8d3f1cf; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigtransaction_ethereum_tx_id_c8d3f1cf ON public.history_multisigtransaction USING btree (ethereum_tx_id);

--
-- Name: history_multisigtransaction_failed_4842ad6b; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigtransaction_failed_4842ad6b ON public.history_multisigtransaction USING btree (failed);

--
-- Name: history_multisigtransaction_nonce_a98eecaa; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigtransaction_nonce_a98eecaa ON public.history_multisigtransaction USING btree (nonce);

--
-- Name: history_multisigtransaction_safe_ba8bae68; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigtransaction_safe_ba8bae68 ON public.history_multisigtransaction USING btree (safe);

--
-- Name: history_multisigtransaction_to_e544fdbe; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigtransaction_to_e544fdbe ON public.history_multisigtransaction USING btree ("to");

--
-- Name: history_multisigtransaction_trusted_f8ea7938; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_multisigtransaction_trusted_f8ea7938 ON public.history_multisigtransaction USING btree (trusted);

--
-- Name: history_proxyfactory_tx_block_number_51be6689; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_proxyfactory_tx_block_number_51be6689 ON public.history_proxyfactory USING btree (tx_block_number);

--
-- Name: history_saf_address_1c362b_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_saf_address_1c362b_idx ON public.history_safestatus USING btree (address, nonce DESC, internal_tx_id DESC);

--
-- Name: history_saf_address_aa71bd_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_saf_address_aa71bd_idx ON public.history_safestatus USING btree (address, nonce DESC);

--
-- Name: history_saf_enabled_020fea_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_saf_enabled_020fea_gin ON public.history_safelaststatus USING gin (enabled_modules);

--
-- Name: history_saf_owners_5fc97e_gin; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_saf_owners_5fc97e_gin ON public.history_safelaststatus USING gin (owners);

--
-- Name: history_safecontract_ethereum_tx_id_4f63f583; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_safecontract_ethereum_tx_id_4f63f583 ON public.history_safecontract USING btree (ethereum_tx_id);

--
-- Name: history_safecontractdelegate_safe_contract_id_4389cdbf; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_safecontractdelegate_safe_contract_id_4389cdbf ON public.history_safecontractdelegate USING btree (safe_contract_id);

--
-- Name: history_safemastercopy_tx_block_number_c1b3ce4f; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_safemastercopy_tx_block_number_c1b3ce4f ON public.history_safemastercopy USING btree (tx_block_number);

--
-- Name: history_safestatus_address_68cd154d; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_safestatus_address_68cd154d ON public.history_safestatus USING btree (address);

--
-- Name: history_webhook_address_94c4e540; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX history_webhook_address_94c4e540 ON public.history_webhook USING btree (address);

--
-- Name: notifications_firebasede_cloud_messaging_token_d4feef1d_like; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX notifications_firebasede_cloud_messaging_token_d4feef1d_like ON public.notifications_firebasedevice USING btree (cloud_messaging_token varchar_pattern_ops);

--
-- Name: notifications_firebasedevice_safes_firebasedevice_id_028d88bf; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX notifications_firebasedevice_safes_firebasedevice_id_028d88bf ON public.notifications_firebasedevice_safes USING btree (firebasedevice_id);

--
-- Name: notifications_firebasedevice_safes_safecontract_id_acb5c418; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX notifications_firebasedevice_safes_safecontract_id_acb5c418 ON public.notifications_firebasedevice_safes USING btree (safecontract_id);

--
-- Name: notifications_firebasedeviceowner_firebase_device_id_6e9dd879; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX notifications_firebasedeviceowner_firebase_device_id_6e9dd879 ON public.notifications_firebasedeviceowner USING btree (firebase_device_id);

--
-- Name: notifications_firebasedeviceowner_owner_025b0ed6; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX notifications_firebasedeviceowner_owner_025b0ed6 ON public.notifications_firebasedeviceowner USING btree (owner);

--
-- Name: safe_messages_safemessage_safe_fc7e3fe6; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX safe_messages_safemessage_safe_fc7e3fe6 ON public.safe_messages_safemessage USING btree (safe);

--
-- Name: safe_messages_safemessageconfirmation_owner_b930d28f; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX safe_messages_safemessageconfirmation_owner_b930d28f ON public.safe_messages_safemessageconfirmation USING btree (owner);

--
-- Name: safe_messages_safemessageconfirmation_safe_message_id_1796dddc; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX safe_messages_safemessageconfirmation_safe_message_id_1796dddc ON public.safe_messages_safemessageconfirmation USING btree (safe_message_id);

--
-- Name: safe_messages_safemessageconfirmation_signature_type_34a29b90; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX safe_messages_safemessageconfirmation_signature_type_34a29b90 ON public.safe_messages_safemessageconfirmation USING btree (signature_type);

--
-- Name: token_events_bugged_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX token_events_bugged_idx ON public.tokens_token USING btree (events_bugged) WHERE events_bugged;

--
-- Name: token_spam_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX token_spam_idx ON public.tokens_token USING btree (spam) WHERE spam;

--
-- Name: token_trusted_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX token_trusted_idx ON public.tokens_token USING btree (trusted) WHERE trusted;

--
-- Name: tokens_token_decimals_7c745c31; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX tokens_token_decimals_7c745c31 ON public.tokens_token USING btree (decimals);

--
-- Name: auth_group_permissions auth_group_permissio_permission_id_84c5c92e_fk_auth_perm; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_group_permissions
    ADD CONSTRAINT auth_group_permissio_permission_id_84c5c92e_fk_auth_perm FOREIGN KEY (permission_id) REFERENCES public.auth_permission(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: auth_group_permissions auth_group_permissions_group_id_b120cbf9_fk_auth_group_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_group_permissions
    ADD CONSTRAINT auth_group_permissions_group_id_b120cbf9_fk_auth_group_id FOREIGN KEY (group_id) REFERENCES public.auth_group(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: auth_permission auth_permission_content_type_id_2f476e4b_fk_django_co; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_permission
    ADD CONSTRAINT auth_permission_content_type_id_2f476e4b_fk_django_co FOREIGN KEY (content_type_id) REFERENCES public.django_content_type(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: auth_user_groups auth_user_groups_group_id_97559544_fk_auth_group_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user_groups
    ADD CONSTRAINT auth_user_groups_group_id_97559544_fk_auth_group_id FOREIGN KEY (group_id) REFERENCES public.auth_group(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: auth_user_groups auth_user_groups_user_id_6a12ed8b_fk_auth_user_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user_groups
    ADD CONSTRAINT auth_user_groups_user_id_6a12ed8b_fk_auth_user_id FOREIGN KEY (user_id) REFERENCES public.auth_user(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: auth_user_user_permissions auth_user_user_permi_permission_id_1fbb5f2c_fk_auth_perm; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user_user_permissions
    ADD CONSTRAINT auth_user_user_permi_permission_id_1fbb5f2c_fk_auth_perm FOREIGN KEY (permission_id) REFERENCES public.auth_permission(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: auth_user_user_permissions auth_user_user_permissions_user_id_a95ead1b_fk_auth_user_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.auth_user_user_permissions
    ADD CONSTRAINT auth_user_user_permissions_user_id_a95ead1b_fk_auth_user_id FOREIGN KEY (user_id) REFERENCES public.auth_user(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: authtoken_token authtoken_token_user_id_35299eff_fk_auth_user_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.authtoken_token
    ADD CONSTRAINT authtoken_token_user_id_35299eff_fk_auth_user_id FOREIGN KEY (user_id) REFERENCES public.auth_user(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: contracts_contract contracts_contract_contract_abi_id_1c37b4bd_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contracts_contract
    ADD CONSTRAINT contracts_contract_contract_abi_id_1c37b4bd_fk FOREIGN KEY (contract_abi_id) REFERENCES public.contracts_contractabi(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: django_admin_log django_admin_log_content_type_id_c4bce8eb_fk_django_co; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_admin_log
    ADD CONSTRAINT django_admin_log_content_type_id_c4bce8eb_fk_django_co FOREIGN KEY (content_type_id) REFERENCES public.django_content_type(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: django_admin_log django_admin_log_user_id_c564eba6_fk_auth_user_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_admin_log
    ADD CONSTRAINT django_admin_log_user_id_c564eba6_fk_auth_user_id FOREIGN KEY (user_id) REFERENCES public.auth_user(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: django_celery_beat_periodictask django_celery_beat_p_clocked_id_47a69f82_fk_django_ce; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_periodictask
    ADD CONSTRAINT django_celery_beat_p_clocked_id_47a69f82_fk_django_ce FOREIGN KEY (clocked_id) REFERENCES public.django_celery_beat_clockedschedule(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: django_celery_beat_periodictask django_celery_beat_p_crontab_id_d3cba168_fk_django_ce; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_periodictask
    ADD CONSTRAINT django_celery_beat_p_crontab_id_d3cba168_fk_django_ce FOREIGN KEY (crontab_id) REFERENCES public.django_celery_beat_crontabschedule(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: django_celery_beat_periodictask django_celery_beat_p_interval_id_a8ca27da_fk_django_ce; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_periodictask
    ADD CONSTRAINT django_celery_beat_p_interval_id_a8ca27da_fk_django_ce FOREIGN KEY (interval_id) REFERENCES public.django_celery_beat_intervalschedule(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: django_celery_beat_periodictask django_celery_beat_p_solar_id_a87ce72c_fk_django_ce; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.django_celery_beat_periodictask
    ADD CONSTRAINT django_celery_beat_p_solar_id_a87ce72c_fk_django_ce FOREIGN KEY (solar_id) REFERENCES public.django_celery_beat_solarschedule(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_erc20transfer history_erc20transfer_ethereum_tx_id_16a6036b_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_erc20transfer
    ADD CONSTRAINT history_erc20transfer_ethereum_tx_id_16a6036b_fk FOREIGN KEY (ethereum_tx_id) REFERENCES public.history_ethereumtx(tx_hash) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_erc721transfer history_erc721transfer_ethereum_tx_id_aa020110_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_erc721transfer
    ADD CONSTRAINT history_erc721transfer_ethereum_tx_id_aa020110_fk FOREIGN KEY (ethereum_tx_id) REFERENCES public.history_ethereumtx(tx_hash) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_ethereumtx history_ethereumtx_block_id_92e7f70e_fk_history_e; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_ethereumtx
    ADD CONSTRAINT history_ethereumtx_block_id_92e7f70e_fk_history_e FOREIGN KEY (block_id) REFERENCES public.history_ethereumblock(number) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_internaltx history_internaltx_ethereum_tx_id_e6ac35ab_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_internaltx
    ADD CONSTRAINT history_internaltx_ethereum_tx_id_e6ac35ab_fk FOREIGN KEY (ethereum_tx_id) REFERENCES public.history_ethereumtx(tx_hash) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_internaltxdecoded history_internaltxdecoded_internal_tx_id_5b3e37cb_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_internaltxdecoded
    ADD CONSTRAINT history_internaltxdecoded_internal_tx_id_5b3e37cb_fk FOREIGN KEY (internal_tx_id) REFERENCES public.history_internaltx(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_moduletransaction history_moduletransaction_internal_tx_id_9fb53507_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_moduletransaction
    ADD CONSTRAINT history_moduletransaction_internal_tx_id_9fb53507_fk FOREIGN KEY (internal_tx_id) REFERENCES public.history_internaltx(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_multisigconfirmation history_multisigconfirmat_multisig_transaction_id_43ec94d5_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_multisigconfirmation
    ADD CONSTRAINT history_multisigconfirmat_multisig_transaction_id_43ec94d5_fk FOREIGN KEY (multisig_transaction_id) REFERENCES public.history_multisigtransaction(safe_tx_hash) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_multisigconfirmation history_multisigconfirmation_ethereum_tx_id_71e0ab73_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_multisigconfirmation
    ADD CONSTRAINT history_multisigconfirmation_ethereum_tx_id_71e0ab73_fk FOREIGN KEY (ethereum_tx_id) REFERENCES public.history_ethereumtx(tx_hash) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_multisigtransaction history_multisigtransaction_ethereum_tx_id_c8d3f1cf_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_multisigtransaction
    ADD CONSTRAINT history_multisigtransaction_ethereum_tx_id_c8d3f1cf_fk FOREIGN KEY (ethereum_tx_id) REFERENCES public.history_ethereumtx(tx_hash) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_safecontract history_safecontract_ethereum_tx_id_4f63f583_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safecontract
    ADD CONSTRAINT history_safecontract_ethereum_tx_id_4f63f583_fk FOREIGN KEY (ethereum_tx_id) REFERENCES public.history_ethereumtx(tx_hash) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_safecontractdelegate history_safecontractdelegate_safe_contract_id_4389cdbf_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safecontractdelegate
    ADD CONSTRAINT history_safecontractdelegate_safe_contract_id_4389cdbf_fk FOREIGN KEY (safe_contract_id) REFERENCES public.history_safecontract(address) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_safelaststatus history_safelaststat_internal_tx_id_df2261ee_fk_history_i; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safelaststatus
    ADD CONSTRAINT history_safelaststat_internal_tx_id_df2261ee_fk_history_i FOREIGN KEY (internal_tx_id) REFERENCES public.history_internaltx(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: history_safestatus history_safestatus_internal_tx_id_b447def6_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.history_safestatus
    ADD CONSTRAINT history_safestatus_internal_tx_id_b447def6_fk FOREIGN KEY (internal_tx_id) REFERENCES public.history_internaltx(id) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: notifications_firebasedeviceowner notifications_fireba_firebase_device_id_6e9dd879_fk_notificat; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedeviceowner
    ADD CONSTRAINT notifications_fireba_firebase_device_id_6e9dd879_fk_notificat FOREIGN KEY (firebase_device_id) REFERENCES public.notifications_firebasedevice(uuid) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: notifications_firebasedevice_safes notifications_fireba_firebasedevice_id_028d88bf_fk_notificat; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedevice_safes
    ADD CONSTRAINT notifications_fireba_firebasedevice_id_028d88bf_fk_notificat FOREIGN KEY (firebasedevice_id) REFERENCES public.notifications_firebasedevice(uuid) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: notifications_firebasedevice_safes notifications_fireba_safecontract_id_acb5c418_fk_history_s; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications_firebasedevice_safes
    ADD CONSTRAINT notifications_fireba_safecontract_id_acb5c418_fk_history_s FOREIGN KEY (safecontract_id) REFERENCES public.history_safecontract(address) DEFERRABLE INITIALLY DEFERRED;

--
-- Name: safe_messages_safemessageconfirmation safe_messages_safeme_safe_message_id_1796dddc_fk_safe_mess; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.safe_messages_safemessageconfirmation
    ADD CONSTRAINT safe_messages_safeme_safe_message_id_1796dddc_fk_safe_mess FOREIGN KEY (safe_message_id) REFERENCES public.safe_messages_safemessage(message_hash) DEFERRABLE INITIALLY DEFERRED;

--
-- PostgreSQL database dump complete
--

'''
'''--- docker/db/01-add-genesis-safe.sql ---
INSERT INTO public.history_ethereumblock (number, gas_limit, gas_used, "timestamp", block_hash, parent_hash, confirmed) VALUES (0, 0, 0, '2023-06-22 09:58:57.866815+00', '\x0000000000000000000000000000000000000000000000000000000000000000', '\x0000000000000000000000000000000000000000000000000000000000000000', true);
INSERT INTO public.history_ethereumtx (created, modified, tx_hash, gas_used, status, transaction_index, _from, gas, gas_price, data, nonce, "to", value, block_id, logs, max_fee_per_gas, max_priority_fee_per_gas, type) VALUES ('2023-06-22 09:58:57.903215+00', '2023-06-22 09:58:57.903215+00', '\x0000000000000000000000000000000000000000000000000000000000000000', 0, 1, 0, '\x0000000000000000000000000000000000000000', 0, 0, '\x', 0, '\x0000000000000000000000000000000000000000', 0, 0, '{}', 0, 0, 0);
INSERT INTO public.history_internaltx (id, _from, gas, data, "to", value, gas_used, contract_address, code, output, refund_address, tx_type, call_type, trace_address, error, ethereum_tx_id, block_number, "timestamp") VALUES (0, '\xb5f762798a53d543a014caf8b297cff8f2f937e8', 0, '\x', '\x0000000000000000000000000000000000000000', 0, 0, NULL, NULL, NULL, NULL, 0, 1, '1', NULL, '\x0000000000000000000000000000000000000000000000000000000000000000', 0, '2023-06-22 09:58:57.957411+00');
INSERT INTO public.history_internaltxdecoded (internal_tx_id, function_name, arguments, processed) VALUES (0, 'setup', '{"_owners": ["0x8BD6EF6EF19231096D09012988C33272BCA64D4E", "0xF371D1A18FDFDE67333A1524ABA6EA3A4AEF50AC", "0x5BC2B4240BA35FEEC3606B6602AB959D238AB18C", "0x95E653E30032E2E7EBD70E48F269C93E3AA47901"], "payment": 0, "initiator": "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2", "_threshold": 1, "initializer": "0x0000000000000000000000000000000000000000", "fallbackHandler": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4", "paymentReceiver": "0x0000000000000000000000000000000000000000"}', true);
INSERT INTO public.history_safecontract (address, ethereum_tx_id) VALUES ('\xb5f762798a53d543a014caf8b297cff8f2f937e8', '\x0000000000000000000000000000000000000000000000000000000000000000');
INSERT INTO public.history_safelaststatus (address, owners, threshold, nonce, master_copy, fallback_handler, guard, enabled_modules, internal_tx_id) VALUES ('\xb5f762798a53d543a014caf8b297cff8f2f937e8', '{"\\x8bd6ef6ef19231096d09012988c33272bca64d4e","\\xf371d1a18fdfde67333a1524aba6ea3a4aef50ac","\\x5bc2b4240ba35feec3606b6602ab959d238ab18c","\\x95e653e30032e2e7ebd70e48f269c93e3aa47901"}', 1, 0, '\x3e5c63644e683549055b9be8653de26e0b4cd36e', '\xf48f2b2d2a534e402487b3ee7c18c33aec0fe5e4', NULL, '{}', 0);
INSERT INTO public.history_safestatus (internal_tx_id, address, owners, threshold, nonce, master_copy, enabled_modules, fallback_handler, guard) VALUES (0, '\xb5f762798a53d543a014caf8b297cff8f2f937e8', '{"\\x8bd6ef6ef19231096d09012988c33272bca64d4e","\\xf371d1a18fdfde67333a1524aba6ea3a4aef50ac","\\x5bc2b4240ba35feec3606b6602ab959d238ab18c","\\x95e653e30032e2e7ebd70e48f269c93e3aa47901"}', 1, 0, '\x3e5c63644e683549055b9be8653de26e0b4cd36e', '{}', '\xf48f2b2d2a534e402487b3ee7c18c33aec0fe5e4', NULL);

'''
'''--- docker/web/celery/flower/run.sh ---
#!/bin/bash

set -euo pipefail

echo "==> $(date +%H:%M:%S) ==> Running Celery flower <=="
exec celery -C -A config.celery_app flower
'''
'''--- docker/web/celery/scheduler/run.sh ---
#!/bin/bash

set -euo pipefail

# DEBUG set in .env
if [ ${DEBUG:-0} = 1 ]; then
    log_level="debug"
else
    log_level="info"
fi

# Wait for migrations
sleep 10

echo "==> $(date +%H:%M:%S) ==> Running Celery beat <=="
exec celery -C -A config.celery_app beat -S django_celery_beat.schedulers:DatabaseScheduler --loglevel $log_level

'''
'''--- docker/web/celery/worker/run.sh ---
#!/bin/bash

set -euo pipefail

# DEBUG set in .env_docker_compose
if [ ${DEBUG:-0} = 1 ]; then
    log_level="debug"
else
    log_level="info"
fi

if [ ${RUN_MIGRATIONS:-0} = 1 ]; then
  echo "==> $(date +%H:%M:%S) ==> Migrating Django models... "
  python manage.py migrate --noinput

  echo "==> $(date +%H:%M:%S) ==> Setting up service... "
  python manage.py setup_service
fi

MAX_MEMORY_PER_CHILD="${WORKER_MAX_MEMORY_PER_CHILD:-2097152}"
MAX_TASKS_PER_CHILD="${MAX_TASKS_PER_CHILD:-1000000}"

# Run Celery as root
export C_FORCE_ROOT=true

echo "==> $(date +%H:%M:%S) ==> Running Celery worker with a max_memory_per_child of ${MAX_MEMORY_PER_CHILD} <=="
exec celery -C -A config.celery_app worker \
     --loglevel $log_level --pool=gevent \
     --concurrency=${CELERYD_CONCURRENCY:-1000} \
     --max-memory-per-child=${MAX_MEMORY_PER_CHILD} \
     --max-tasks-per-child=${MAX_TASKS_PER_CHILD} \
     -Q "$WORKER_QUEUES"

'''
'''--- docker/web/run_web.sh ---
#!/bin/bash

set -euo pipefail

echo "==> $(date +%H:%M:%S) ==> Collecting statics... "
DOCKER_SHARED_DIR=/nginx
rm -rf $DOCKER_SHARED_DIR/*
# STATIC_ROOT=$DOCKER_SHARED_DIR/staticfiles python manage.py collectstatic --noinput &
cp -r staticfiles/ $DOCKER_SHARED_DIR/

echo "==> $(date +%H:%M:%S) ==> Send via Slack info about service version and network"
python manage.py send_slack_notification &

echo "==> $(date +%H:%M:%S) ==> Running Gunicorn... "
exec gunicorn --config gunicorn.conf.py --pythonpath "$PWD" -b unix:$DOCKER_SHARED_DIR/gunicorn.socket -b 0.0.0.0:8888 config.wsgi:application

'''
'''--- docker_instructions.txt ---
# Add the docker group if it doesn't already exist.
$ sudo groupadd docker

# Add the connected user "${USER}" to the docker group.
# Change the user name to match your preferred user.
# You may have to logout and log back in again for
# this to take effect.
$ sudo gpasswd -a ${USER} docker

# Restart the Docker daemon.
$ sudo service docker restart

sudo docker-compose build
sudo docker-compose up

# Run container in bash mode
sudo docker-compose run web bash

'''
'''--- docs/__init__.py ---
# Included so that Django's startproject comment runs against the docs directory

'''
'''--- docs/conf.py ---
# Safe Transaction Service documentation build configuration file, created by
# sphinx-quickstart.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# import os
# import sys

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
# sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix of source filenames.
source_suffix = ".rst"

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = "index"

# General information about the project.
project = "Safe Transaction Service"
copyright = """2018, Gnosis"""

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = "0.1"
# The full version, including alpha/beta/rc tags.
release = "0.1"

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ["_build"]

# The reST default role (used for this markup: `text`) to use for all documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = "default"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
# html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = "safe_transaction_servicedoc"

# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    # 'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    (
        "index",
        "safe_transaction_service.tex",
        "Gnosis Transaction Service Documentation",
        """Gnosis""",
        "manual",
    )
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True

# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (
        "index",
        "safe_transaction_service",
        "Safe Transaction Service Documentation",
        ["""Gnosis"""],
        1,
    )
]

# If true, show URL addresses after external links.
# man_show_urls = False

# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (
        "index",
        "safe_transaction_service",
        "Safe Transaction Service Documentation",
        """Gnosis""",
        "Safe Transaction Service",
        """Project to manage transactions for Gnosis Safe""",
        "Miscellaneous",
    )
]

# Documents to append as an appendix to all manuals.
# texinfo_appendices = []

# If false, no module index is generated.
# texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
# texinfo_show_urls = 'footnote'

'''
'''--- gunicorn.conf.py ---
access_logfile = "-"
error_logfile = "-"
max_requests = 20_000  # Restart a worker after it has processed a given number of requests (for memory leaks)
max_requests_jitter = (
    10_000  # Randomize max_requests to prevent all workers restarting at the same time
)
# graceful_timeout = 90  # https://stackoverflow.com/a/24305939
keep_alive = 2
log_file = "-"
log_level = "info"
logger_class = "safe_transaction_service.utils.loggers.CustomGunicornLogger"
preload_app = False  # Load application code before the worker processes are forked (problems with gevent patching)
timeout = (
    60  # Worker will be restarted if it doesn't answer in more than configured seconds
)
worker_class = "gevent"
worker_connections = 2000

def post_fork(server, worker):
    try:
        from psycogreen.gevent import patch_psycopg

        worker.log.info("Making Psycopg2 Green")
        patch_psycopg()
        worker.log.info("Made Psycopg2 Green")
    except ImportError:
        worker.log.info("Psycopg2 not patched")

'''
'''--- manage.py ---
#!/usr/bin/env python
import os
import sys
from pathlib import Path

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.local")

    try:
        from django.core.management import execute_from_command_line
    except ImportError:
        # The above import may fail for some other reason. Ensure that the
        # issue is really that Django is missing to avoid masking other
        # exceptions on Python 2.
        try:
            import django  # noqa
        except ImportError:
            raise ImportError(
                "Couldn't import Django. Are you sure it's installed and "
                "available on your PYTHONPATH environment variable? Did you "
                "forget to activate a virtual environment?"
            )
        raise

    # This allows easy placement of apps within the interior
    # safe_transaction_service directory.
    current_path = Path(__file__).parent.resolve()
    sys.path.append(str(current_path / "safe_transaction_service"))

    execute_from_command_line(sys.argv)

'''
'''--- requirements-dev.txt ---
-r requirements.txt
-r requirements-test.txt
flake8
ipdb
ipython
isort
pre-commit
pylint
pylint-django

'''
'''--- requirements-test.txt ---
-r requirements.txt
coverage==6.5.0
django-stubs==1.13.1
django-test-migrations==1.2.0
factory-boy==3.2.1
faker==15.3.4
mypy==0.991
pytest==7.2.0
pytest-celery==0.0.0
pytest-django==4.5.2
pytest-env==0.8.1
pytest-rerunfailures==10.3
pytest-sugar==0.9.6

'''
'''--- requirements.txt ---
boto3==1.26.27
cachetools==5.2.0
celery==5.2.7
django==4.1.4
django-cache-memoize==0.1.10
django-celery-beat==2.4.0
django-cors-headers==3.13.0
django-db-geventpool==4.0.1
django-debug-toolbar
django-debug-toolbar-force
django-environ==0.9.0
django-extensions==3.2.1
django-filter==22.1
django-imagekit==4.1.0
django-model-utils==4.3.1
django-redis==5.2.0
django-s3-storage==0.13.11
django-timezone-field==5.0.0
djangorestframework==3.14.0
djangorestframework-camel-case==1.3.0
docutils==0.19
drf-yasg[validation]==1.21.4
firebase-admin==6.0.1
flower==1.2.0
gunicorn[gevent]==20.1.0
hexbytes==0.2.3
hiredis==2.0.0
packaging>=21.0
pillow==9.3.0
psycogreen==1.0.2
psycopg2==2.9.5
redis==4.4.0
requests==2.28.1
safe-eth-py[django]==4.8.0
web3==5.30.0

'''
'''--- run_tests.sh ---
#!/bin/bash

set -euo pipefail

export DJANGO_SETTINGS_MODULE=config.settings.test
export DJANGO_DOT_ENV_FILE=.env.test
docker compose -f docker-compose.yml -f docker-compose.dev.yml build --force-rm db redis ganache
docker compose -f docker-compose.yml -f docker-compose.dev.yml up --no-start db redis ganache
docker compose -f docker-compose.yml -f docker-compose.dev.yml start db redis ganache

sleep 10

python manage.py check
pytest -rxXs

'''
'''--- safe_transaction_service/__init__.py ---
__version__ = "4.13.0"
__version_info__ = tuple(
    int(num) if num.isdigit() else num
    for num in __version__.replace("-", ".", 1).split(".")
)

'''
'''--- safe_transaction_service/analytics/__init__.py ---

'''
'''--- safe_transaction_service/analytics/apps.py ---
from django.apps import AppConfig

class AnalyticsConfig(AppConfig):
    name = "safe_transaction_service.analytics"
    verbose_name = "Analytics for Safe Transaction Service"

'''
'''--- safe_transaction_service/analytics/serializers.py ---
from rest_framework import serializers

from gnosis.eth.django.serializers import EthereumAddressField

class AnalyticsMultisigTxsByOriginResponseSerializer(serializers.Serializer):
    origin = serializers.CharField()
    transactions = serializers.IntegerField()

class AnalyticsMultisigTxsBySafeResponseSerializer(serializers.Serializer):
    safe = EthereumAddressField()
    master_copy = EthereumAddressField()
    transactions = serializers.IntegerField()

'''
'''--- safe_transaction_service/analytics/services/__init__.py ---

'''
'''--- safe_transaction_service/analytics/services/analytics_service.py ---
import json
from functools import cache
from typing import List

from safe_transaction_service.utils.redis import get_redis

@cache
def get_analytics_service() -> "AnalyticsService":
    return AnalyticsService()

class AnalyticsService:
    REDIS_TRANSACTIONS_PER_SAFE_APP = "analytics_transactions_per_safe_app"

    def get_safe_transactions_per_safe_app(self) -> List:
        redis = get_redis()
        analytic_result = redis.get(self.REDIS_TRANSACTIONS_PER_SAFE_APP)
        if analytic_result:
            return json.loads(analytic_result)
        else:
            return []

'''
'''--- safe_transaction_service/analytics/tasks.py ---
import json

from django.db.models import Count, F, Q
from django.utils import timezone

from celery import app
from dateutil.relativedelta import relativedelta

from safe_transaction_service.analytics.services.analytics_service import (
    AnalyticsService,
)
from safe_transaction_service.history.models import MultisigTransaction
from safe_transaction_service.utils.redis import get_redis
from safe_transaction_service.utils.tasks import LOCK_TIMEOUT, SOFT_TIMEOUT

@app.shared_task(soft_time_limit=SOFT_TIMEOUT, time_limit=LOCK_TIMEOUT)
def get_transactions_per_safe_app_task():
    today = timezone.now()
    last_week = today - relativedelta(days=7)
    last_month = today - relativedelta(months=1)
    last_year = today - relativedelta(years=3)

    queryset = (
        MultisigTransaction.objects.filter(origin__name__isnull=False)
        .values(name=F("origin__name"), url=F("origin__url"))
        .annotate(
            total_tx=Count("origin__name"),
            tx_last_week=Count("origin__name", filter=Q(created__gt=last_week)),
            tx_last_month=Count("origin__name", filter=Q(created__gt=last_month)),
            tx_last_year=Count("origin__name", filter=Q(created__gt=last_year)),
        )
        .order_by("-total_tx")
    )

    if queryset:
        redis_key = AnalyticsService.REDIS_TRANSACTIONS_PER_SAFE_APP
        redis = get_redis()
        redis.set(redis_key, json.dumps(list(queryset)))
        return True
    return False

'''
'''--- safe_transaction_service/analytics/tests/__init__.py ---

'''
'''--- safe_transaction_service/analytics/tests/test_tasks.py ---
import json

from django.test import TestCase

from safe_transaction_service.analytics.services.analytics_service import (
    AnalyticsService,
)
from safe_transaction_service.analytics.tasks import get_transactions_per_safe_app_task
from safe_transaction_service.history.models import MultisigTransaction
from safe_transaction_service.history.tests.factories import MultisigTransactionFactory
from safe_transaction_service.utils.redis import get_redis

class TestTasks(TestCase):
    def test_get_transactions_per_safe_apps(self):
        redis = get_redis()
        redis.flushall()
        redis_key = AnalyticsService.REDIS_TRANSACTIONS_PER_SAFE_APP
        origin_1 = {"url": "https://example1.com", "name": "SafeApp1"}
        origin_2 = {"url": "https://example2.com", "name": "SafeApp2"}
        string_origin = "test"
        expected = [
            {
                "name": "SafeApp2",
                "url": "https://example2.com",
                "total_tx": 7,
                "tx_last_week": 7,
                "tx_last_month": 7,
                "tx_last_year": 7,
            },
            {
                "name": "SafeApp1",
                "url": "https://example1.com",
                "total_tx": 3,
                "tx_last_week": 3,
                "tx_last_month": 3,
                "tx_last_year": 3,
            },
        ]
        for _ in range(3):
            MultisigTransactionFactory(origin=origin_1)
        for _ in range(7):
            MultisigTransactionFactory(origin=origin_2)
        MultisigTransactionFactory(origin=string_origin)

        self.assertEqual(MultisigTransaction.objects.count(), 11)
        value = redis.get(redis_key)
        self.assertIsNone(value)
        # Execute the task to get data from database
        get_transactions_per_safe_app_task()
        # Get the result from redis
        value = redis.get(redis_key)
        analytic = json.loads(value)

        self.assertEqual(analytic, expected)

'''
'''--- safe_transaction_service/analytics/tests/test_views.py ---
from django.contrib.auth.models import User
from django.urls import reverse

from eth_account import Account
from rest_framework import status
from rest_framework.authtoken.models import Token
from rest_framework.test import APITestCase

from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from safe_transaction_service.history.tests.factories import (
    MultisigTransactionFactory,
    SafeStatusFactory,
)

class TestViews(SafeTestCaseMixin, APITestCase):
    def setUp(self) -> None:
        user, _ = User.objects.get_or_create(username="test", password="12345")
        token, _ = Token.objects.get_or_create(user=user)
        self.header = {"HTTP_AUTHORIZATION": "Token " + token.key}

    def test_analytics_multisig_txs_by_origin_view(self):
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-origin")
        )
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-origin"), **self.header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        origin = "Millennium Falcon Navigation Computer"
        origin_2 = "HAL 9000"
        multisig_transaction = MultisigTransactionFactory(origin=origin)
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-origin"), **self.header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected = [
            {"origin": origin, "transactions": 1},
        ]
        self.assertEqual(response.data, expected)

        for _ in range(3):
            MultisigTransactionFactory(origin=origin_2)

        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-origin"), **self.header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected = [
            {"origin": origin_2, "transactions": 3},
            {"origin": origin, "transactions": 1},
        ]
        self.assertEqual(response.data, expected)

        for _ in range(3):
            MultisigTransactionFactory(origin=origin)

        # Check sorting by the biggest
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-origin"), **self.header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected = [
            {"origin": origin, "transactions": 4},
            {"origin": origin_2, "transactions": 3},
        ]
        self.assertEqual(response.data, expected)

        # Test filters
        origin_3 = "Skynet"
        safe_address = Account.create().address
        MultisigTransactionFactory(origin=origin_3, safe=safe_address)
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-origin")
            + f"?safe={safe_address}",
            **self.header,
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected = [
            {"origin": origin_3, "transactions": 1},
        ]
        self.assertEqual(response.data, expected)

        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-origin")
            + f"?to={multisig_transaction.to}",
            **self.header,
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected = [
            {"origin": multisig_transaction.origin, "transactions": 1},
        ]
        self.assertEqual(response.data, expected)

    def test_analytics_multisig_txs_by_safe_view(self):
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-safe")
        )
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-safe"), **self.header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        safe_address_1 = Account.create().address
        safe_address_2 = Account.create().address
        safe_address_3 = Account.create().address
        MultisigTransactionFactory(safe=safe_address_1)
        MultisigTransactionFactory(safe=safe_address_1)
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-safe"), **self.header
        )
        result = response.json()
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(result["count"], 1)
        self.assertEqual(
            result["results"][0],
            {"safe": safe_address_1, "masterCopy": None, "transactions": 2},
        )
        MultisigTransactionFactory(safe=safe_address_1)
        safe_status_1 = SafeStatusFactory(address=safe_address_1)
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-safe"), **self.header
        )
        result = response.json()
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(result["count"], 1)
        self.assertIsNotNone(safe_status_1.master_copy)
        self.assertEqual(
            result["results"][0],
            {
                "safe": safe_address_1,
                "masterCopy": safe_status_1.master_copy,
                "transactions": 3,
            },
        )
        MultisigTransactionFactory(safe=safe_address_2)
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-safe"), **self.header
        )
        result = response.json()
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            result["results"],
            [
                {
                    "safe": safe_address_1,
                    "masterCopy": safe_status_1.master_copy,
                    "transactions": 3,
                },
                {"safe": safe_address_2, "masterCopy": None, "transactions": 1},
            ],
        )
        safe_status_2 = SafeStatusFactory(address=safe_address_2)
        safe_status_3 = SafeStatusFactory(address=safe_address_3)
        [MultisigTransactionFactory(safe=safe_address_3) for _ in range(4)]
        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-safe"), **self.header
        )
        result = response.json()
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            result["results"],
            [
                {
                    "safe": safe_address_3,
                    "masterCopy": safe_status_3.master_copy,
                    "transactions": 4,
                },
                {
                    "safe": safe_address_1,
                    "masterCopy": safe_status_1.master_copy,
                    "transactions": 3,
                },
                {
                    "safe": safe_address_2,
                    "masterCopy": safe_status_2.master_copy,
                    "transactions": 1,
                },
            ],
        )

        response = self.client.get(
            reverse("v1:analytics:analytics-multisig-txs-by-safe")
            + f"?master_copy={safe_status_1.master_copy}",
            **self.header,
        )
        result = response.json()
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            result["results"],
            [
                {
                    "safe": safe_address_1,
                    "masterCopy": safe_status_1.master_copy,
                    "transactions": 3,
                },
            ],
        )

'''
'''--- safe_transaction_service/analytics/tests/test_views_v2.py ---
from django.contrib.auth.models import User
from django.urls import reverse

from rest_framework import status
from rest_framework.authtoken.models import Token
from rest_framework.test import APITestCase

from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from safe_transaction_service.history.tests.factories import MultisigTransactionFactory

from ...utils.redis import get_redis
from ..tasks import get_transactions_per_safe_app_task

class TestViewsV2(SafeTestCaseMixin, APITestCase):
    def test_analytics_multisig_txs_by_origin_view(self):
        redis = get_redis()
        redis.flushall()
        response = self.client.get(
            reverse("v2:analytics:analytics-multisig-txs-by-origin")
        )
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

        user, _ = User.objects.get_or_create(username="test", password="12345")
        token, _ = Token.objects.get_or_create(user=user)
        header = {"HTTP_AUTHORIZATION": "Token " + token.key}
        response = self.client.get(
            reverse("v2:analytics:analytics-multisig-txs-by-origin"), **header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data, [])

        origin_1 = {"url": "https://example1.com", "name": "SafeApp1"}
        origin_2 = {"url": "https://example2.com", "name": "SafeApp2"}

        MultisigTransactionFactory(origin=origin_1)
        # Execute the periodic task
        get_transactions_per_safe_app_task()
        response = self.client.get(
            reverse("v2:analytics:analytics-multisig-txs-by-origin"), **header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected = [
            {
                "name": origin_1["name"],
                "url": origin_1["url"],
                "total_tx": 1,
                "tx_last_month": 1,
                "tx_last_week": 1,
                "tx_last_year": 1,
            },
        ]
        self.assertEqual(response.data, expected)

        for _ in range(3):
            MultisigTransactionFactory(origin=origin_2)

        # Execute the periodic task
        get_transactions_per_safe_app_task()

        response = self.client.get(
            reverse("v2:analytics:analytics-multisig-txs-by-origin"), **header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected = [
            {
                "name": origin_2["name"],
                "url": origin_2["url"],
                "total_tx": 3,
                "tx_last_month": 3,
                "tx_last_week": 3,
                "tx_last_year": 3,
            },
            {
                "name": origin_1["name"],
                "url": origin_1["url"],
                "total_tx": 1,
                "tx_last_month": 1,
                "tx_last_week": 1,
                "tx_last_year": 1,
            },
        ]
        self.assertEqual(response.data, expected)

        for _ in range(3):
            MultisigTransactionFactory(origin=origin_1)

        # Execute the periodic task
        get_transactions_per_safe_app_task()
        # Check sorting by the biggest
        response = self.client.get(
            reverse("v2:analytics:analytics-multisig-txs-by-origin"), **header
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected = [
            {
                "name": origin_1["name"],
                "url": origin_1["url"],
                "total_tx": 4,
                "tx_last_month": 4,
                "tx_last_week": 4,
                "tx_last_year": 4,
            },
            {
                "name": origin_2["name"],
                "url": origin_2["url"],
                "total_tx": 3,
                "tx_last_month": 3,
                "tx_last_week": 3,
                "tx_last_year": 3,
            },
        ]
        self.assertEqual(response.data, expected)

'''
'''--- safe_transaction_service/analytics/urls.py ---
from django.urls import path

from . import views

app_name = "analytics"

urlpatterns = [
    path(
        "multisig-transactions/by-safe/",
        views.AnalyticsMultisigTxsBySafeListView.as_view(),
        name="analytics-multisig-txs-by-safe",
    ),
    path(
        "multisig-transactions/by-origin/",
        views.AnalyticsMultisigTxsByOriginListView.as_view(),
        name="analytics-multisig-txs-by-origin",
    ),
]

'''
'''--- safe_transaction_service/analytics/urls_v2.py ---
from django.urls import path

from . import views_v2

app_name = "analytics"

urlpatterns = [
    path(
        "multisig-transactions/by-origin/",
        views_v2.AnalyticsMultisigTxsByOriginListView.as_view(),
        name="analytics-multisig-txs-by-origin",
    )
]

'''
'''--- safe_transaction_service/analytics/views.py ---
from django.db.models import Count

import django_filters
from rest_framework.authentication import TokenAuthentication
from rest_framework.generics import ListAPIView
from rest_framework.permissions import IsAuthenticated

from safe_transaction_service.analytics import serializers
from safe_transaction_service.history import filters
from safe_transaction_service.history.models import MultisigTransaction

class AnalyticsMultisigTxsByOriginListView(ListAPIView):
    swagger_schema = None
    filter_backends = (django_filters.rest_framework.DjangoFilterBackend,)
    filterset_class = filters.AnalyticsMultisigTxsByOriginFilter
    pagination_class = None
    authentication_classes = [TokenAuthentication]
    permission_classes = [IsAuthenticated]
    queryset = (
        MultisigTransaction.objects.values("origin")
        .annotate(transactions=Count("*"))
        .order_by("-transactions")
    )
    serializer_class = serializers.AnalyticsMultisigTxsByOriginResponseSerializer

class AnalyticsMultisigTxsBySafeListView(ListAPIView):
    swagger_schema = None
    authentication_classes = [TokenAuthentication]
    permission_classes = [IsAuthenticated]
    filter_backends = (django_filters.rest_framework.DjangoFilterBackend,)
    filterset_class = filters.AnalyticsMultisigTxsBySafeFilter
    queryset = (
        MultisigTransaction.objects.safes_with_number_of_transactions_executed_and_master_copy()
    )
    serializer_class = serializers.AnalyticsMultisigTxsBySafeResponseSerializer

'''
'''--- safe_transaction_service/analytics/views_v2.py ---
from rest_framework.authentication import TokenAuthentication
from rest_framework.generics import ListAPIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.renderers import JSONRenderer
from rest_framework.response import Response

from safe_transaction_service.analytics.services.analytics_service import (
    get_analytics_service,
)

class AnalyticsMultisigTxsByOriginListView(ListAPIView):
    pagination_class = None
    swagger_schema = None
    renderer_classes = (JSONRenderer,)
    authentication_classes = [TokenAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, request, format=None):
        analytics_service = get_analytics_service()
        return Response(analytics_service.get_safe_transactions_per_safe_app())

'''
'''--- safe_transaction_service/contracts/__init__.py ---

'''
'''--- safe_transaction_service/contracts/admin.py ---
from django.contrib import admin

from gnosis.eth.django.admin import BinarySearchAdmin

from safe_transaction_service.utils.admin import HasLogoFilterAdmin

from .models import Contract, ContractAbi

@admin.register(ContractAbi)
class ContractAbiAdmin(BinarySearchAdmin):
    list_display = ("pk", "relevance", "description", "abi_functions")
    list_filter = ("relevance",)
    ordering = ["relevance"]
    readonly_fields = ("abi_hash",)
    search_fields = ["description"]

    def abi_functions(self, obj: ContractAbi):
        return obj.abi_functions()

class HasAbiFilter(admin.SimpleListFilter):
    title = "Has ABI"
    parameter_name = "has_abi"

    def lookups(self, request, model_admin):
        return (
            ("YES", "Yes"),
            ("NO", "No"),
        )

    def queryset(self, request, queryset):
        if self.value() == "NO":
            return queryset.filter(contract_abi=None)
        elif self.value() == "YES":
            return queryset.exclude(contract_abi=None)
        else:
            return queryset

@admin.register(Contract)
class ContractAdmin(BinarySearchAdmin):
    list_display = (
        "address",
        "name",
        "display_name",
        "has_abi",
        "has_logo",
        "trusted_for_delegate_call",
        "abi_relevance",
        "contract_abi_id",
    )
    list_filter = (HasAbiFilter, HasLogoFilterAdmin, "trusted_for_delegate_call")
    list_select_related = ("contract_abi",)
    ordering = ["address"]
    raw_id_fields = ("contract_abi",)
    search_fields = [
        "=address",
        "name",
        "contract_abi__abi",
        "contract_abi__description",
    ]

    def abi_relevance(self, obj: Contract):
        if obj.contract_abi_id:
            return obj.contract_abi.relevance

    @admin.display(boolean=True)
    def has_abi(self, obj: Contract) -> bool:
        return obj.contract_abi_id is not None

    @admin.display(boolean=True)
    def has_logo(self, obj: Contract) -> bool:
        return bool(obj.logo)

'''
'''--- safe_transaction_service/contracts/apps.py ---
from django.apps import AppConfig

class ContractsConfig(AppConfig):
    name = "safe_transaction_service.contracts"
    verbose_name = "Ethereum Contracts app"

    def ready(self):
        from . import signals  # noqa

'''
'''--- safe_transaction_service/contracts/decoder_abis/__init__.py ---

'''
'''--- safe_transaction_service/contracts/decoder_abis/aave.py ---
aave_a_token = [
    {
        "inputs": [
            {
                "internalType": "contract LendingPoolAddressesProvider",
                "name": "_addressesProvider",
                "type": "address",
            },
            {"internalType": "address", "name": "_underlyingAsset", "type": "address"},
            {
                "internalType": "uint8",
                "name": "_underlyingAssetDecimals",
                "type": "uint8",
            },
            {"internalType": "string", "name": "_name", "type": "string"},
            {"internalType": "string", "name": "_symbol", "type": "string"},
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "owner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "spender",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "value",
                "type": "uint256",
            },
        ],
        "name": "Approval",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_from",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_value",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_toBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromIndex",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_toIndex",
                "type": "uint256",
            },
        ],
        "name": "BalanceTransfer",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_from",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_value",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromIndex",
                "type": "uint256",
            },
        ],
        "name": "BurnOnLiquidation",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_from",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_to",
                "type": "address",
            },
        ],
        "name": "InterestRedirectionAllowanceChanged",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_from",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_redirectedBalance",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromIndex",
                "type": "uint256",
            },
        ],
        "name": "InterestStreamRedirected",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_from",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_value",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromIndex",
                "type": "uint256",
            },
        ],
        "name": "MintOnDeposit",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_from",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_value",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fromIndex",
                "type": "uint256",
            },
        ],
        "name": "Redeem",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_targetAddress",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_targetBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_targetIndex",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_redirectedBalanceAdded",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_redirectedBalanceRemoved",
                "type": "uint256",
            },
        ],
        "name": "RedirectedBalanceUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "from",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "value",
                "type": "uint256",
            },
        ],
        "name": "Transfer",
        "type": "event",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "UINT_MAX_VALUE",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "owner", "type": "address"},
            {"internalType": "address", "name": "spender", "type": "address"},
        ],
        "name": "allowance",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "spender", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
        ],
        "name": "approve",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "spender", "type": "address"},
            {"internalType": "uint256", "name": "subtractedValue", "type": "uint256"},
        ],
        "name": "decreaseAllowance",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "spender", "type": "address"},
            {"internalType": "uint256", "name": "addedValue", "type": "uint256"},
        ],
        "name": "increaseAllowance",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "name",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "recipient", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "transfer",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "sender", "type": "address"},
            {"internalType": "address", "name": "recipient", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "transferFrom",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "underlyingAssetAddress",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_to", "type": "address"}],
        "name": "redirectInterestStream",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_from", "type": "address"},
            {"internalType": "address", "name": "_to", "type": "address"},
        ],
        "name": "redirectInterestStreamOf",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_to", "type": "address"}],
        "name": "allowInterestRedirectionTo",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "uint256", "name": "_amount", "type": "uint256"}],
        "name": "redeem",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_account", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
        ],
        "name": "mintOnDeposit",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_account", "type": "address"},
            {"internalType": "uint256", "name": "_value", "type": "uint256"},
        ],
        "name": "burnOnLiquidation",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_from", "type": "address"},
            {"internalType": "address", "name": "_to", "type": "address"},
            {"internalType": "uint256", "name": "_value", "type": "uint256"},
        ],
        "name": "transferOnLiquidation",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_user", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_user", "type": "address"}],
        "name": "principalBalanceOf",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
        ],
        "name": "isTransferAllowed",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_user", "type": "address"}],
        "name": "getUserIndex",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_user", "type": "address"}],
        "name": "getInterestRedirectionAddress",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_user", "type": "address"}],
        "name": "getRedirectedBalance",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
]
aave_lending_pool = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_borrowRateMode",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_borrowRate",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_originationFee",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_borrowBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "uint16",
                "name": "_referral",
                "type": "uint16",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "Borrow",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "uint16",
                "name": "_referral",
                "type": "uint16",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "Deposit",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_target",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_totalFee",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_protocolFee",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "FlashLoan",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_collateral",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_purchaseAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_liquidatedCollateralAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_accruedBorrowInterest",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "_liquidator",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "bool",
                "name": "_receiveAToken",
                "type": "bool",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "LiquidationCall",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_collateral",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_feeLiquidated",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_liquidatedCollateralForFee",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "OriginationFeeLiquidated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_newStableRate",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_borrowBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "RebalanceStableBorrowRate",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "RedeemUnderlying",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_repayer",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_amountMinusFees",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_fees",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_borrowBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "Repay",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
        ],
        "name": "ReserveUsedAsCollateralDisabled",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
        ],
        "name": "ReserveUsedAsCollateralEnabled",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "_reserve",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "_user",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_newRateMode",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_newRate",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_borrowBalanceIncrease",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "_timestamp",
                "type": "uint256",
            },
        ],
        "name": "Swap",
        "type": "event",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "LENDINGPOOL_REVISION",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "UINT_MAX_VALUE",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "addressesProvider",
        "outputs": [
            {
                "internalType": "contract LendingPoolAddressesProvider",
                "name": "",
                "type": "address",
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "core",
        "outputs": [
            {"internalType": "contract LendingPoolCore", "name": "", "type": "address"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "dataProvider",
        "outputs": [
            {
                "internalType": "contract LendingPoolDataProvider",
                "name": "",
                "type": "address",
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "parametersProvider",
        "outputs": [
            {
                "internalType": "contract LendingPoolParametersProvider",
                "name": "",
                "type": "address",
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract LendingPoolAddressesProvider",
                "name": "_addressesProvider",
                "type": "address",
            }
        ],
        "name": "initialize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "uint16", "name": "_referralCode", "type": "uint16"},
        ],
        "name": "deposit",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address payable", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "_aTokenBalanceAfterRedeem",
                "type": "uint256",
            },
        ],
        "name": "redeemUnderlying",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "uint256", "name": "_interestRateMode", "type": "uint256"},
            {"internalType": "uint16", "name": "_referralCode", "type": "uint16"},
        ],
        "name": "borrow",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {
                "internalType": "address payable",
                "name": "_onBehalfOf",
                "type": "address",
            },
        ],
        "name": "repay",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "swapBorrowRateMode",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "rebalanceStableBorrowRate",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "bool", "name": "_useAsCollateral", "type": "bool"},
        ],
        "name": "setUserUseReserveAsCollateral",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_collateral", "type": "address"},
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_purchaseAmount", "type": "uint256"},
            {"internalType": "bool", "name": "_receiveAToken", "type": "bool"},
        ],
        "name": "liquidationCall",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_receiver", "type": "address"},
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "bytes", "name": "_params", "type": "bytes"},
        ],
        "name": "flashLoan",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveConfigurationData",
        "outputs": [
            {"internalType": "uint256", "name": "ltv", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "liquidationThreshold",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "liquidationBonus", "type": "uint256"},
            {
                "internalType": "address",
                "name": "interestRateStrategyAddress",
                "type": "address",
            },
            {
                "internalType": "bool",
                "name": "usageAsCollateralEnabled",
                "type": "bool",
            },
            {"internalType": "bool", "name": "borrowingEnabled", "type": "bool"},
            {"internalType": "bool", "name": "stableBorrowRateEnabled", "type": "bool"},
            {"internalType": "bool", "name": "isActive", "type": "bool"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveData",
        "outputs": [
            {"internalType": "uint256", "name": "totalLiquidity", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "availableLiquidity",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "totalBorrowsStable",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "totalBorrowsVariable",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "liquidityRate", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "variableBorrowRate",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "stableBorrowRate", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "averageStableBorrowRate",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "utilizationRate", "type": "uint256"},
            {"internalType": "uint256", "name": "liquidityIndex", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "variableBorrowIndex",
                "type": "uint256",
            },
            {"internalType": "address", "name": "aTokenAddress", "type": "address"},
            {"internalType": "uint40", "name": "lastUpdateTimestamp", "type": "uint40"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_user", "type": "address"}],
        "name": "getUserAccountData",
        "outputs": [
            {"internalType": "uint256", "name": "totalLiquidityETH", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "totalCollateralETH",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "totalBorrowsETH", "type": "uint256"},
            {"internalType": "uint256", "name": "totalFeesETH", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "availableBorrowsETH",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "currentLiquidationThreshold",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "ltv", "type": "uint256"},
            {"internalType": "uint256", "name": "healthFactor", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserReserveData",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "currentATokenBalance",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "currentBorrowBalance",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "principalBorrowBalance",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "borrowRateMode", "type": "uint256"},
            {"internalType": "uint256", "name": "borrowRate", "type": "uint256"},
            {"internalType": "uint256", "name": "liquidityRate", "type": "uint256"},
            {"internalType": "uint256", "name": "originationFee", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "variableBorrowIndex",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "lastUpdateTimestamp",
                "type": "uint256",
            },
            {
                "internalType": "bool",
                "name": "usageAsCollateralEnabled",
                "type": "bool",
            },
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getReserves",
        "outputs": [{"internalType": "address[]", "name": "", "type": "address[]"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
]
aave_lending_pool_addresses_provider = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "EthereumAddressUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "FeeProviderUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "LendingPoolConfiguratorUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "LendingPoolCoreUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "LendingPoolDataProviderUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "LendingPoolLiquidationManagerUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "LendingPoolManagerUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "LendingPoolParametersProviderUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "LendingPoolUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "LendingRateOracleUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "previousOwner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newOwner",
                "type": "address",
            },
        ],
        "name": "OwnershipTransferred",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "PriceOracleUpdated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "bytes32",
                "name": "id",
                "type": "bytes32",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            },
        ],
        "name": "ProxyCreated",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "newAddress",
                "type": "address",
            }
        ],
        "name": "TokenDistributorUpdated",
        "type": "event",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "bytes32", "name": "_key", "type": "bytes32"}],
        "name": "getAddress",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isOwner",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "owner",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}],
        "name": "transferOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getLendingPool",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_pool", "type": "address"}],
        "name": "setLendingPoolImpl",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getLendingPoolCore",
        "outputs": [{"internalType": "address payable", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_lendingPoolCore", "type": "address"}
        ],
        "name": "setLendingPoolCoreImpl",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getLendingPoolConfigurator",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_configurator", "type": "address"}
        ],
        "name": "setLendingPoolConfiguratorImpl",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getLendingPoolDataProvider",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_provider", "type": "address"}],
        "name": "setLendingPoolDataProviderImpl",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getLendingPoolParametersProvider",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "address",
                "name": "_parametersProvider",
                "type": "address",
            }
        ],
        "name": "setLendingPoolParametersProviderImpl",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getFeeProvider",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_feeProvider", "type": "address"}
        ],
        "name": "setFeeProviderImpl",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getLendingPoolLiquidationManager",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_manager", "type": "address"}],
        "name": "setLendingPoolLiquidationManager",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getLendingPoolManager",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "address",
                "name": "_lendingPoolManager",
                "type": "address",
            }
        ],
        "name": "setLendingPoolManager",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getPriceOracle",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_priceOracle", "type": "address"}
        ],
        "name": "setPriceOracle",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getLendingRateOracle",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_lendingRateOracle", "type": "address"}
        ],
        "name": "setLendingRateOracle",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getTokenDistributor",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_tokenDistributor", "type": "address"}
        ],
        "name": "setTokenDistributor",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
]
aave_lending_pool_core = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "reserve",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "liquidityRate",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "stableBorrowRate",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "variableBorrowRate",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "liquidityIndex",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "variableBorrowIndex",
                "type": "uint256",
            },
        ],
        "name": "ReserveUpdated",
        "type": "event",
    },
    {"payable": True, "stateMutability": "payable", "type": "fallback"},
    {
        "constant": True,
        "inputs": [],
        "name": "CORE_REVISION",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "addressesProvider",
        "outputs": [
            {
                "internalType": "contract LendingPoolAddressesProvider",
                "name": "",
                "type": "address",
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "lendingPoolAddress",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "name": "reservesList",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract LendingPoolAddressesProvider",
                "name": "_addressesProvider",
                "type": "address",
            }
        ],
        "name": "initialize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "bool", "name": "_isFirstDeposit", "type": "bool"},
        ],
        "name": "updateStateOnDeposit",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amountRedeemed", "type": "uint256"},
            {"internalType": "bool", "name": "_userRedeemedEverything", "type": "bool"},
        ],
        "name": "updateStateOnRedeem",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {
                "internalType": "uint256",
                "name": "_availableLiquidityBefore",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "_income", "type": "uint256"},
            {"internalType": "uint256", "name": "_protocolFee", "type": "uint256"},
        ],
        "name": "updateStateOnFlashLoan",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amountBorrowed", "type": "uint256"},
            {"internalType": "uint256", "name": "_borrowFee", "type": "uint256"},
            {
                "internalType": "enum CoreLibrary.InterestRateMode",
                "name": "_rateMode",
                "type": "uint8",
            },
        ],
        "name": "updateStateOnBorrow",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {
                "internalType": "uint256",
                "name": "_paybackAmountMinusFees",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "_originationFeeRepaid",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "_balanceIncrease", "type": "uint256"},
            {"internalType": "bool", "name": "_repaidWholeLoan", "type": "bool"},
        ],
        "name": "updateStateOnRepay",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {
                "internalType": "uint256",
                "name": "_principalBorrowBalance",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "_compoundedBorrowBalance",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "_balanceIncrease", "type": "uint256"},
            {
                "internalType": "enum CoreLibrary.InterestRateMode",
                "name": "_currentRateMode",
                "type": "uint8",
            },
        ],
        "name": "updateStateOnSwapRate",
        "outputs": [
            {
                "internalType": "enum CoreLibrary.InterestRateMode",
                "name": "",
                "type": "uint8",
            },
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_principalReserve", "type": "address"},
            {
                "internalType": "address",
                "name": "_collateralReserve",
                "type": "address",
            },
            {"internalType": "address", "name": "_user", "type": "address"},
            {
                "internalType": "uint256",
                "name": "_amountToLiquidate",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "_collateralToLiquidate",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "_feeLiquidated", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "_liquidatedCollateralForFee",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "_balanceIncrease", "type": "uint256"},
            {
                "internalType": "bool",
                "name": "_liquidatorReceivesAToken",
                "type": "bool",
            },
        ],
        "name": "updateStateOnLiquidation",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_balanceIncrease", "type": "uint256"},
        ],
        "name": "updateStateOnRebalance",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "bool", "name": "_useAsCollateral", "type": "bool"},
        ],
        "name": "setUserUseReserveAsCollateral",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address payable", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
        ],
        "name": "transferToUser",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_token", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "address", "name": "_destination", "type": "address"},
        ],
        "name": "transferToFeeCollectionAddress",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_token", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "address", "name": "_destination", "type": "address"},
        ],
        "name": "liquidateFee",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address payable", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
        ],
        "name": "transferToReserve",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserBasicReserveData",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "bool", "name": "", "type": "bool"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
        ],
        "name": "isUserAllowedToBorrowAtStable",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserUnderlyingAssetBalance",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveInterestRateStrategyAddress",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveATokenAddress",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveAvailableLiquidity",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveTotalLiquidity",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveNormalizedIncome",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveTotalBorrows",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveTotalBorrowsStable",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveTotalBorrowsVariable",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveLiquidationThreshold",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveLiquidationBonus",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveCurrentVariableBorrowRate",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveCurrentStableBorrowRate",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveCurrentAverageStableBorrowRate",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveCurrentLiquidityRate",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveLiquidityCumulativeIndex",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveVariableBorrowsCumulativeIndex",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveConfiguration",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "bool", "name": "", "type": "bool"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveDecimals",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "isReserveBorrowingEnabled",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "isReserveUsageAsCollateralEnabled",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveIsStableBorrowRateEnabled",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveIsActive",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveIsFreezed",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveLastUpdate",
        "outputs": [{"internalType": "uint40", "name": "timestamp", "type": "uint40"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "getReserveUtilizationRate",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getReserves",
        "outputs": [{"internalType": "address[]", "name": "", "type": "address[]"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "isUserUseReserveAsCollateralEnabled",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserOriginationFee",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserCurrentBorrowRateMode",
        "outputs": [
            {
                "internalType": "enum CoreLibrary.InterestRateMode",
                "name": "",
                "type": "uint8",
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserCurrentStableBorrowRate",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserBorrowBalances",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserVariableBorrowCumulativeIndex",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_user", "type": "address"},
        ],
        "name": "getUserLastUpdate",
        "outputs": [
            {"internalType": "uint256", "name": "timestamp", "type": "uint256"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "refreshConfiguration",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "address", "name": "_aTokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "_decimals", "type": "uint256"},
            {
                "internalType": "address",
                "name": "_interestRateStrategyAddress",
                "type": "address",
            },
        ],
        "name": "initReserve",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {
                "internalType": "address",
                "name": "_rateStrategyAddress",
                "type": "address",
            },
        ],
        "name": "setReserveInterestRateStrategyAddress",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {
                "internalType": "bool",
                "name": "_stableBorrowRateEnabled",
                "type": "bool",
            },
        ],
        "name": "enableBorrowingOnReserve",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "disableBorrowingOnReserve",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {
                "internalType": "uint256",
                "name": "_baseLTVasCollateral",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "_liquidationThreshold",
                "type": "uint256",
            },
            {"internalType": "uint256", "name": "_liquidationBonus", "type": "uint256"},
        ],
        "name": "enableReserveAsCollateral",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "disableReserveAsCollateral",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "enableReserveStableBorrowRate",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "disableReserveStableBorrowRate",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "activateReserve",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "deactivateReserve",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "freezeReserve",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "_reserve", "type": "address"}],
        "name": "unfreezeReserve",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "uint256", "name": "_ltv", "type": "uint256"},
        ],
        "name": "setReserveBaseLTVasCollateral",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "uint256", "name": "_threshold", "type": "uint256"},
        ],
        "name": "setReserveLiquidationThreshold",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "uint256", "name": "_bonus", "type": "uint256"},
        ],
        "name": "setReserveLiquidationBonus",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_reserve", "type": "address"},
            {"internalType": "uint256", "name": "_decimals", "type": "uint256"},
        ],
        "name": "setReserveDecimals",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/admin_upgradeability_proxy.py ---
initializable_admin_upgradeability_proxy_abi = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "previousAdmin",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "newAdmin",
                "type": "address",
            },
        ],
        "name": "AdminChanged",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "implementation",
                "type": "address",
            }
        ],
        "name": "Upgraded",
        "type": "event",
    },
    {"payable": True, "stateMutability": "payable", "type": "fallback"},
    {
        "constant": False,
        "inputs": [],
        "name": "admin",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newAdmin", "type": "address"}],
        "name": "changeAdmin",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "implementation",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_logic", "type": "address"},
            {"internalType": "address", "name": "_admin", "type": "address"},
            {"internalType": "bytes", "name": "_data", "type": "bytes"},
        ],
        "name": "initialize",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_logic", "type": "address"},
            {"internalType": "bytes", "name": "_data", "type": "bytes"},
        ],
        "name": "initialize",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "newImplementation", "type": "address"}
        ],
        "name": "upgradeTo",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "newImplementation", "type": "address"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
        ],
        "name": "upgradeToAndCall",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/balancer.py ---
balancer_bactions = [
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract BFactory", "name": "factory", "type": "address"},
            {"internalType": "address[]", "name": "tokens", "type": "address[]"},
            {"internalType": "uint256[]", "name": "balances", "type": "uint256[]"},
            {"internalType": "uint256[]", "name": "denorms", "type": "uint256[]"},
            {"internalType": "uint256", "name": "swapFee", "type": "uint256"},
            {"internalType": "bool", "name": "finalize", "type": "bool"},
        ],
        "name": "create",
        "outputs": [
            {"internalType": "contract BPool", "name": "pool", "type": "address"}
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract BPool", "name": "pool", "type": "address"}
        ],
        "name": "finalize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract BPool", "name": "pool", "type": "address"},
            {"internalType": "uint256", "name": "poolAmountOut", "type": "uint256"},
            {"internalType": "uint256[]", "name": "maxAmountsIn", "type": "uint256[]"},
        ],
        "name": "joinPool",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract BPool", "name": "pool", "type": "address"},
            {"internalType": "address", "name": "tokenIn", "type": "address"},
            {"internalType": "uint256", "name": "tokenAmountIn", "type": "uint256"},
            {"internalType": "uint256", "name": "minPoolAmountOut", "type": "uint256"},
        ],
        "name": "joinswapExternAmountIn",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract BPool", "name": "pool", "type": "address"},
            {"internalType": "address", "name": "newController", "type": "address"},
        ],
        "name": "setController",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract BPool", "name": "pool", "type": "address"},
            {"internalType": "bool", "name": "publicSwap", "type": "bool"},
        ],
        "name": "setPublicSwap",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract BPool", "name": "pool", "type": "address"},
            {"internalType": "uint256", "name": "newFee", "type": "uint256"},
        ],
        "name": "setSwapFee",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract BPool", "name": "pool", "type": "address"},
            {"internalType": "address[]", "name": "tokens", "type": "address[]"},
            {"internalType": "uint256[]", "name": "balances", "type": "uint256[]"},
            {"internalType": "uint256[]", "name": "denorms", "type": "uint256[]"},
        ],
        "name": "setTokens",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
]

balancer_exchange_proxy = [
    {
        "inputs": [{"internalType": "address", "name": "_weth", "type": "address"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
    },
    {
        "anonymous": True,
        "inputs": [
            {
                "indexed": True,
                "internalType": "bytes4",
                "name": "sig",
                "type": "bytes4",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "caller",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "bytes",
                "name": "data",
                "type": "bytes",
            },
        ],
        "name": "LOG_CALL",
        "type": "event",
    },
    {"payable": True, "stateMutability": "payable", "type": "fallback"},
    {
        "constant": False,
        "inputs": [
            {
                "components": [
                    {"internalType": "address", "name": "pool", "type": "address"},
                    {
                        "internalType": "uint256",
                        "name": "tokenInParam",
                        "type": "uint256",
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenOutParam",
                        "type": "uint256",
                    },
                    {"internalType": "uint256", "name": "maxPrice", "type": "uint256"},
                ],
                "internalType": "struct ExchangeProxy.Swap[]",
                "name": "swaps",
                "type": "tuple[]",
            },
            {"internalType": "address", "name": "tokenOut", "type": "address"},
            {"internalType": "uint256", "name": "minTotalAmountOut", "type": "uint256"},
        ],
        "name": "batchEthInSwapExactIn",
        "outputs": [
            {"internalType": "uint256", "name": "totalAmountOut", "type": "uint256"}
        ],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "components": [
                    {"internalType": "address", "name": "pool", "type": "address"},
                    {
                        "internalType": "uint256",
                        "name": "tokenInParam",
                        "type": "uint256",
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenOutParam",
                        "type": "uint256",
                    },
                    {"internalType": "uint256", "name": "maxPrice", "type": "uint256"},
                ],
                "internalType": "struct ExchangeProxy.Swap[]",
                "name": "swaps",
                "type": "tuple[]",
            },
            {"internalType": "address", "name": "tokenOut", "type": "address"},
        ],
        "name": "batchEthInSwapExactOut",
        "outputs": [
            {"internalType": "uint256", "name": "totalAmountIn", "type": "uint256"}
        ],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "components": [
                    {"internalType": "address", "name": "pool", "type": "address"},
                    {
                        "internalType": "uint256",
                        "name": "tokenInParam",
                        "type": "uint256",
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenOutParam",
                        "type": "uint256",
                    },
                    {"internalType": "uint256", "name": "maxPrice", "type": "uint256"},
                ],
                "internalType": "struct ExchangeProxy.Swap[]",
                "name": "swaps",
                "type": "tuple[]",
            },
            {"internalType": "address", "name": "tokenIn", "type": "address"},
            {"internalType": "uint256", "name": "totalAmountIn", "type": "uint256"},
            {"internalType": "uint256", "name": "minTotalAmountOut", "type": "uint256"},
        ],
        "name": "batchEthOutSwapExactIn",
        "outputs": [
            {"internalType": "uint256", "name": "totalAmountOut", "type": "uint256"}
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "components": [
                    {"internalType": "address", "name": "pool", "type": "address"},
                    {
                        "internalType": "uint256",
                        "name": "tokenInParam",
                        "type": "uint256",
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenOutParam",
                        "type": "uint256",
                    },
                    {"internalType": "uint256", "name": "maxPrice", "type": "uint256"},
                ],
                "internalType": "struct ExchangeProxy.Swap[]",
                "name": "swaps",
                "type": "tuple[]",
            },
            {"internalType": "address", "name": "tokenIn", "type": "address"},
            {"internalType": "uint256", "name": "maxTotalAmountIn", "type": "uint256"},
        ],
        "name": "batchEthOutSwapExactOut",
        "outputs": [
            {"internalType": "uint256", "name": "totalAmountIn", "type": "uint256"}
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "components": [
                    {"internalType": "address", "name": "pool", "type": "address"},
                    {
                        "internalType": "uint256",
                        "name": "tokenInParam",
                        "type": "uint256",
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenOutParam",
                        "type": "uint256",
                    },
                    {"internalType": "uint256", "name": "maxPrice", "type": "uint256"},
                ],
                "internalType": "struct ExchangeProxy.Swap[]",
                "name": "swaps",
                "type": "tuple[]",
            },
            {"internalType": "address", "name": "tokenIn", "type": "address"},
            {"internalType": "address", "name": "tokenOut", "type": "address"},
            {"internalType": "uint256", "name": "totalAmountIn", "type": "uint256"},
            {"internalType": "uint256", "name": "minTotalAmountOut", "type": "uint256"},
        ],
        "name": "batchSwapExactIn",
        "outputs": [
            {"internalType": "uint256", "name": "totalAmountOut", "type": "uint256"}
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "components": [
                    {"internalType": "address", "name": "pool", "type": "address"},
                    {
                        "internalType": "uint256",
                        "name": "tokenInParam",
                        "type": "uint256",
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenOutParam",
                        "type": "uint256",
                    },
                    {"internalType": "uint256", "name": "maxPrice", "type": "uint256"},
                ],
                "internalType": "struct ExchangeProxy.Swap[]",
                "name": "swaps",
                "type": "tuple[]",
            },
            {"internalType": "address", "name": "tokenIn", "type": "address"},
            {"internalType": "address", "name": "tokenOut", "type": "address"},
            {"internalType": "uint256", "name": "maxTotalAmountIn", "type": "uint256"},
        ],
        "name": "batchSwapExactOut",
        "outputs": [
            {"internalType": "uint256", "name": "totalAmountIn", "type": "uint256"}
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/chainlink.py ---
import json

chainlink_token_abi = json.loads(
    '[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"},{"name":"_data","type":"bytes"}],"name":"transferAndCall","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_subtractedValue","type":"uint256"}],"name":"decreaseApproval","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_addedValue","type":"uint256"}],"name":"increaseApproval","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"},{"indexed":false,"name":"data","type":"bytes"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"}]'
)

'''
'''--- safe_transaction_service/contracts/decoder_abis/compound.py ---
ctoken_abi = [
    {
        "inputs": [
            {"internalType": "address", "name": "underlying_", "type": "address"},
            {
                "internalType": "contract ComptrollerInterface",
                "name": "comptroller_",
                "type": "address",
            },
            {
                "internalType": "contract InterestRateModel",
                "name": "interestRateModel_",
                "type": "address",
            },
            {
                "internalType": "uint256",
                "name": "initialExchangeRateMantissa_",
                "type": "uint256",
            },
            {"internalType": "string", "name": "name_", "type": "string"},
            {"internalType": "string", "name": "symbol_", "type": "string"},
            {"internalType": "uint8", "name": "decimals_", "type": "uint8"},
            {"internalType": "address payable", "name": "admin_", "type": "address"},
            {"internalType": "address", "name": "implementation_", "type": "address"},
            {
                "internalType": "bytes",
                "name": "becomeImplementationData",
                "type": "bytes",
            },
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
        "signature": "constructor",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "cashPrior",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "interestAccumulated",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "borrowIndex",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "totalBorrows",
                "type": "uint256",
            },
        ],
        "name": "AccrueInterest",
        "type": "event",
        "signature": "0x4dec04e750ca11537cabcd8a9eab06494de08da3735bc8871cd41250e190bc04",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "owner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "spender",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256",
            },
        ],
        "name": "Approval",
        "type": "event",
        "signature": "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "borrower",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "borrowAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "accountBorrows",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "totalBorrows",
                "type": "uint256",
            },
        ],
        "name": "Borrow",
        "type": "event",
        "signature": "0x13ed6866d4e1ee6da46f845c46d7e54120883d75c5ea9a2dacc1c4ca8984ab80",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "error",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "info",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "detail",
                "type": "uint256",
            },
        ],
        "name": "Failure",
        "type": "event",
        "signature": "0x45b96fe442630264581b197e84bbada861235052c5a1aadfff9ea4e40a969aa0",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "liquidator",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "borrower",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "repayAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "cTokenCollateral",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "seizeTokens",
                "type": "uint256",
            },
        ],
        "name": "LiquidateBorrow",
        "type": "event",
        "signature": "0x298637f684da70674f26509b10f07ec2fbc77a335ab1e7d6215a4b2484d8bb52",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "minter",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "mintAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "mintTokens",
                "type": "uint256",
            },
        ],
        "name": "Mint",
        "type": "event",
        "signature": "0x4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "oldAdmin",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "newAdmin",
                "type": "address",
            },
        ],
        "name": "NewAdmin",
        "type": "event",
        "signature": "0xf9ffabca9c8276e99321725bcb43fb076a6c66a54b7f21c4e8146d8519b417dc",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract ComptrollerInterface",
                "name": "oldComptroller",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "contract ComptrollerInterface",
                "name": "newComptroller",
                "type": "address",
            },
        ],
        "name": "NewComptroller",
        "type": "event",
        "signature": "0x7ac369dbd14fa5ea3f473ed67cc9d598964a77501540ba6751eb0b3decf5870d",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "oldImplementation",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "newImplementation",
                "type": "address",
            },
        ],
        "name": "NewImplementation",
        "type": "event",
        "signature": "0xd604de94d45953f9138079ec1b82d533cb2160c906d1076d1f7ed54befbca97a",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract InterestRateModel",
                "name": "oldInterestRateModel",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "contract InterestRateModel",
                "name": "newInterestRateModel",
                "type": "address",
            },
        ],
        "name": "NewMarketInterestRateModel",
        "type": "event",
        "signature": "0xedffc32e068c7c95dfd4bdfd5c4d939a084d6b11c4199eac8436ed234d72f926",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "oldPendingAdmin",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "newPendingAdmin",
                "type": "address",
            },
        ],
        "name": "NewPendingAdmin",
        "type": "event",
        "signature": "0xca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a9",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "oldReserveFactorMantissa",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newReserveFactorMantissa",
                "type": "uint256",
            },
        ],
        "name": "NewReserveFactor",
        "type": "event",
        "signature": "0xaaa68312e2ea9d50e16af5068410ab56e1a1fd06037b1a35664812c30f821460",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "redeemer",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "redeemAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "redeemTokens",
                "type": "uint256",
            },
        ],
        "name": "Redeem",
        "type": "event",
        "signature": "0xe5b754fb1abb7f01b499791d0b820ae3b6af3424ac1c59768edb53f4ec31a929",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "payer",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "borrower",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "repayAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "accountBorrows",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "totalBorrows",
                "type": "uint256",
            },
        ],
        "name": "RepayBorrow",
        "type": "event",
        "signature": "0x1a2a22cb034d26d1854bdc6666a5b91fe25efbbb5dcad3b0355478d6f5c362a1",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "benefactor",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "addAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newTotalReserves",
                "type": "uint256",
            },
        ],
        "name": "ReservesAdded",
        "type": "event",
        "signature": "0xa91e67c5ea634cd43a12c5a482724b03de01e85ca68702a53d0c2f45cb7c1dc5",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "admin",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "reduceAmount",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newTotalReserves",
                "type": "uint256",
            },
        ],
        "name": "ReservesReduced",
        "type": "event",
        "signature": "0x3bad0c59cf2f06e7314077049f48a93578cd16f5ef92329f1dab1420a99c177e",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "from",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256",
            },
        ],
        "name": "Transfer",
        "type": "event",
        "signature": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
    },
    {"payable": True, "stateMutability": "payable", "type": "fallback"},
    {
        "constant": False,
        "inputs": [],
        "name": "_acceptAdmin",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xe9c714f2",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "uint256", "name": "addAmount", "type": "uint256"}],
        "name": "_addReserves",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x3e941010",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "reduceAmount", "type": "uint256"}
        ],
        "name": "_reduceReserves",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x601a0bf1",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract ComptrollerInterface",
                "name": "newComptroller",
                "type": "address",
            }
        ],
        "name": "_setComptroller",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x4576b5db",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "implementation_", "type": "address"},
            {"internalType": "bool", "name": "allowResign", "type": "bool"},
            {
                "internalType": "bytes",
                "name": "becomeImplementationData",
                "type": "bytes",
            },
        ],
        "name": "_setImplementation",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x555bcc40",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract InterestRateModel",
                "name": "newInterestRateModel",
                "type": "address",
            }
        ],
        "name": "_setInterestRateModel",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xf2b3abbd",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "address payable",
                "name": "newPendingAdmin",
                "type": "address",
            }
        ],
        "name": "_setPendingAdmin",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xb71d1a0c",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "newReserveFactorMantissa",
                "type": "uint256",
            }
        ],
        "name": "_setReserveFactor",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xfca7820b",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "accrualBlockNumber",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x6c540baf",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "accrueInterest",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xa6afed95",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "admin",
        "outputs": [{"internalType": "address payable", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xf851a440",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "owner", "type": "address"},
            {"internalType": "address", "name": "spender", "type": "address"},
        ],
        "name": "allowance",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xdd62ed3e",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "spender", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "approve",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x095ea7b3",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x70a08231",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "owner", "type": "address"}],
        "name": "balanceOfUnderlying",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x3af9e669",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "borrowAmount", "type": "uint256"}
        ],
        "name": "borrow",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xc5ebeaec",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "borrowBalanceCurrent",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x17bfdfbc",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "borrowBalanceStored",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x95dd9193",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "borrowIndex",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xaa5af0fd",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "borrowRatePerBlock",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xf8f9da28",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "comptroller",
        "outputs": [
            {
                "internalType": "contract ComptrollerInterface",
                "name": "",
                "type": "address",
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x5fe3b567",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x313ce567",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "bytes", "name": "data", "type": "bytes"}],
        "name": "delegateToImplementation",
        "outputs": [{"internalType": "bytes", "name": "", "type": "bytes"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x0933c1ed",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "bytes", "name": "data", "type": "bytes"}],
        "name": "delegateToViewImplementation",
        "outputs": [{"internalType": "bytes", "name": "", "type": "bytes"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x4487152f",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "exchangeRateCurrent",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xbd6d894d",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "exchangeRateStored",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x182df0f5",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "getAccountSnapshot",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xc37f68e2",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getCash",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x3b1d21a2",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "implementation",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x5c60da1b",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "interestRateModel",
        "outputs": [
            {
                "internalType": "contract InterestRateModel",
                "name": "",
                "type": "address",
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xf3fdb15a",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isCToken",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xfe9c44ae",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "repayAmount", "type": "uint256"},
            {
                "internalType": "contract CTokenInterface",
                "name": "cTokenCollateral",
                "type": "address",
            },
        ],
        "name": "liquidateBorrow",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xf5e3c462",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "mintAmount", "type": "uint256"}
        ],
        "name": "mint",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xa0712d68",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "name",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x06fdde03",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "pendingAdmin",
        "outputs": [{"internalType": "address payable", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x26782247",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "redeemTokens", "type": "uint256"}
        ],
        "name": "redeem",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xdb006a75",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "redeemAmount", "type": "uint256"}
        ],
        "name": "redeemUnderlying",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x852a12e3",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "repayAmount", "type": "uint256"}
        ],
        "name": "repayBorrow",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x0e752702",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "repayAmount", "type": "uint256"},
        ],
        "name": "repayBorrowBehalf",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x2608f818",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "reserveFactorMantissa",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x173b9904",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "liquidator", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "seizeTokens", "type": "uint256"},
        ],
        "name": "seize",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xb2a02ff1",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "supplyRatePerBlock",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xae9d70b0",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x95d89b41",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "totalBorrows",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x47bd3718",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "totalBorrowsCurrent",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x73acee98",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "totalReserves",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x8f840ddd",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x18160ddd",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "dst", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "transfer",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xa9059cbb",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "src", "type": "address"},
            {"internalType": "address", "name": "dst", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "transferFrom",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x23b872dd",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "underlying",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x6f307dc3",
    },
]

comptroller_abi = [
    {
        "constant": True,
        "inputs": [],
        "name": "pendingAdmin",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x26782247",
    },
    {
        "constant": False,
        "inputs": [{"name": "newPendingAdmin", "type": "address"}],
        "name": "_setPendingAdmin",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xb71d1a0c",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "comptrollerImplementation",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xbb82aa5e",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "_acceptImplementation",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xc1e80334",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "pendingComptrollerImplementation",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xdcfbc0c7",
    },
    {
        "constant": False,
        "inputs": [{"name": "newPendingImplementation", "type": "address"}],
        "name": "_setPendingImplementation",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xe992a041",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "_acceptAdmin",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xe9c714f2",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "admin",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xf851a440",
    },
    {
        "inputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
        "signature": "constructor",
    },
    {"payable": True, "stateMutability": "payable", "type": "fallback"},
    {
        "anonymous": False,
        "inputs": [
            {"indexed": False, "name": "oldPendingImplementation", "type": "address"},
            {"indexed": False, "name": "newPendingImplementation", "type": "address"},
        ],
        "name": "NewPendingImplementation",
        "type": "event",
        "signature": "0xe945ccee5d701fc83f9b8aa8ca94ea4219ec1fcbd4f4cab4f0ea57c5c3e1d815",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": False, "name": "oldImplementation", "type": "address"},
            {"indexed": False, "name": "newImplementation", "type": "address"},
        ],
        "name": "NewImplementation",
        "type": "event",
        "signature": "0xd604de94d45953f9138079ec1b82d533cb2160c906d1076d1f7ed54befbca97a",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": False, "name": "oldPendingAdmin", "type": "address"},
            {"indexed": False, "name": "newPendingAdmin", "type": "address"},
        ],
        "name": "NewPendingAdmin",
        "type": "event",
        "signature": "0xca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a9",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": False, "name": "oldAdmin", "type": "address"},
            {"indexed": False, "name": "newAdmin", "type": "address"},
        ],
        "name": "NewAdmin",
        "type": "event",
        "signature": "0xf9ffabca9c8276e99321725bcb43fb076a6c66a54b7f21c4e8146d8519b417dc",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "error",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "info",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "detail",
                "type": "uint256",
            },
        ],
        "name": "Failure",
        "type": "event",
        "signature": "0x45b96fe442630264581b197e84bbada861235052c5a1aadfff9ea4e40a969aa0",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isComptroller",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x007e3dd2",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "payer", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "actualRepayAmount", "type": "uint256"},
            {"internalType": "uint256", "name": "borrowerIndex", "type": "uint256"},
        ],
        "name": "repayBorrowVerify",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x1ededc91",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "payer", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "repayAmount", "type": "uint256"},
        ],
        "name": "repayBorrowAllowed",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x24008a62",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "newCloseFactorMantissa",
                "type": "uint256",
            }
        ],
        "name": "_setCloseFactor",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x317b0b77",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "minter", "type": "address"},
            {"internalType": "uint256", "name": "actualMintAmount", "type": "uint256"},
            {"internalType": "uint256", "name": "mintTokens", "type": "uint256"},
        ],
        "name": "mintVerify",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x41c728b9",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cTokenBorrowed", "type": "address"},
            {"internalType": "address", "name": "cTokenCollateral", "type": "address"},
            {"internalType": "address", "name": "liquidator", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "actualRepayAmount", "type": "uint256"},
            {"internalType": "uint256", "name": "seizeTokens", "type": "uint256"},
        ],
        "name": "liquidateBorrowVerify",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x47ef3b3b",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "liquidationIncentiveMantissa",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x4ada90af",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "minter", "type": "address"},
            {"internalType": "uint256", "name": "mintAmount", "type": "uint256"},
        ],
        "name": "mintAllowed",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x4ef4c3e1",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "uint256",
                "name": "newLiquidationIncentiveMantissa",
                "type": "uint256",
            }
        ],
        "name": "_setLiquidationIncentive",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x4fd42e17",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "redeemer", "type": "address"},
            {"internalType": "uint256", "name": "redeemAmount", "type": "uint256"},
            {"internalType": "uint256", "name": "redeemTokens", "type": "uint256"},
        ],
        "name": "redeemVerify",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x51dff989",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract PriceOracle",
                "name": "newOracle",
                "type": "address",
            }
        ],
        "name": "_setPriceOracle",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x55ee1fe1",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "borrowAmount", "type": "uint256"},
        ],
        "name": "borrowVerify",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x5c778605",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "getAccountLiquidity",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x5ec88c79",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cTokenBorrowed", "type": "address"},
            {"internalType": "address", "name": "cTokenCollateral", "type": "address"},
            {"internalType": "address", "name": "liquidator", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "repayAmount", "type": "uint256"},
        ],
        "name": "liquidateBorrowAllowed",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x5fc7e71e",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "src", "type": "address"},
            {"internalType": "address", "name": "dst", "type": "address"},
            {"internalType": "uint256", "name": "transferTokens", "type": "uint256"},
        ],
        "name": "transferVerify",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x6a56947e",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cTokenCollateral", "type": "address"},
            {"internalType": "address", "name": "cTokenBorrowed", "type": "address"},
            {"internalType": "address", "name": "liquidator", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "seizeTokens", "type": "uint256"},
        ],
        "name": "seizeVerify",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x6d35bf91",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "oracle",
        "outputs": [
            {"internalType": "contract PriceOracle", "name": "", "type": "address"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x7dc0d1d0",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "markets",
        "outputs": [
            {"internalType": "bool", "name": "isListed", "type": "bool"},
            {
                "internalType": "uint256",
                "name": "collateralFactorMantissa",
                "type": "uint256",
            },
            {"internalType": "bool", "name": "isComped", "type": "bool"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x8e8f294b",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "account", "type": "address"},
            {"internalType": "contract CToken", "name": "cToken", "type": "address"},
        ],
        "name": "checkMembership",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x929fe9a1",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "maxAssets",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x94b2294b",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract CToken", "name": "cToken", "type": "address"}
        ],
        "name": "_supportMarket",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xa76b3fda",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "getAssetsIn",
        "outputs": [
            {"internalType": "contract CToken[]", "name": "", "type": "address[]"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xabfceffc",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "src", "type": "address"},
            {"internalType": "address", "name": "dst", "type": "address"},
            {"internalType": "uint256", "name": "transferTokens", "type": "uint256"},
        ],
        "name": "transferAllowed",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xbdcdc258",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address[]", "name": "cTokens", "type": "address[]"}
        ],
        "name": "enterMarkets",
        "outputs": [{"internalType": "uint256[]", "name": "", "type": "uint256[]"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xc2998238",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "cTokenBorrowed", "type": "address"},
            {"internalType": "address", "name": "cTokenCollateral", "type": "address"},
            {"internalType": "uint256", "name": "actualRepayAmount", "type": "uint256"},
        ],
        "name": "liquidateCalculateSeizeTokens",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xc488847b",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cTokenCollateral", "type": "address"},
            {"internalType": "address", "name": "cTokenBorrowed", "type": "address"},
            {"internalType": "address", "name": "liquidator", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "seizeTokens", "type": "uint256"},
        ],
        "name": "seizeAllowed",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xd02f7351",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "newMaxAssets", "type": "uint256"}
        ],
        "name": "_setMaxAssets",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xd9226ced",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "borrower", "type": "address"},
            {"internalType": "uint256", "name": "borrowAmount", "type": "uint256"},
        ],
        "name": "borrowAllowed",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xda3d454c",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "", "type": "address"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "name": "accountAssets",
        "outputs": [{"internalType": "contract CToken", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xdce15449",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract CToken", "name": "cToken", "type": "address"},
            {
                "internalType": "uint256",
                "name": "newCollateralFactorMantissa",
                "type": "uint256",
            },
        ],
        "name": "_setCollateralFactor",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xe4028eee",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "closeFactorMantissa",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xe8755446",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cToken", "type": "address"},
            {"internalType": "address", "name": "redeemer", "type": "address"},
            {"internalType": "uint256", "name": "redeemTokens", "type": "uint256"},
        ],
        "name": "redeemAllowed",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xeabe7d91",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "cTokenAddress", "type": "address"}
        ],
        "name": "exitMarket",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xede4edd0",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            }
        ],
        "name": "MarketListed",
        "type": "event",
        "signature": "0xcf583bb0c569eb967f806b11601c4cb93c10310485c67add5f8362c2f212321f",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "account",
                "type": "address",
            },
        ],
        "name": "MarketEntered",
        "type": "event",
        "signature": "0x3ab23ab0d51cccc0c3085aec51f99228625aa1a922b3a8ca89a26b0f2027a1a5",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "account",
                "type": "address",
            },
        ],
        "name": "MarketExited",
        "type": "event",
        "signature": "0xe699a64c18b07ac5b7301aa273f36a2287239eb9501d81950672794afba29a0d",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "oldCloseFactorMantissa",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newCloseFactorMantissa",
                "type": "uint256",
            },
        ],
        "name": "NewCloseFactor",
        "type": "event",
        "signature": "0x3b9670cf975d26958e754b57098eaa2ac914d8d2a31b83257997b9f346110fd9",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "oldCollateralFactorMantissa",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newCollateralFactorMantissa",
                "type": "uint256",
            },
        ],
        "name": "NewCollateralFactor",
        "type": "event",
        "signature": "0x70483e6592cd5182d45ac970e05bc62cdcc90e9d8ef2c2dbe686cf383bcd7fc5",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "oldLiquidationIncentiveMantissa",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newLiquidationIncentiveMantissa",
                "type": "uint256",
            },
        ],
        "name": "NewLiquidationIncentive",
        "type": "event",
        "signature": "0xaeba5a6c40a8ac138134bff1aaa65debf25971188a58804bad717f82f0ec1316",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "oldMaxAssets",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newMaxAssets",
                "type": "uint256",
            },
        ],
        "name": "NewMaxAssets",
        "type": "event",
        "signature": "0x7093cf1eb653f749c3ff531d6df7f92764536a7fa0d13530cd26e070780c32ea",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract PriceOracle",
                "name": "oldPriceOracle",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "contract PriceOracle",
                "name": "newPriceOracle",
                "type": "address",
            },
        ],
        "name": "NewPriceOracle",
        "type": "event",
        "signature": "0xd52b2b9b7e9ee655fcb95d2e5b9e0c9f69e7ef2b8e9d2d0ea78402d576d22e22",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "string",
                "name": "action",
                "type": "string",
            },
            {
                "indexed": False,
                "internalType": "bool",
                "name": "pauseState",
                "type": "bool",
            },
        ],
        "name": "ActionPaused",
        "type": "event",
        "signature": "0xef159d9a32b2472e32b098f954f3ce62d232939f1c207070b584df1814de2de0",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "string",
                "name": "action",
                "type": "string",
            },
            {
                "indexed": False,
                "internalType": "bool",
                "name": "pauseState",
                "type": "bool",
            },
        ],
        "name": "ActionPaused",
        "type": "event",
        "signature": "0x71aec636243f9709bb0007ae15e9afb8150ab01716d75fd7573be5cc096e03b0",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "oldPauseGuardian",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "newPauseGuardian",
                "type": "address",
            },
        ],
        "name": "NewPauseGuardian",
        "type": "event",
        "signature": "0x0613b6ee6a04f0d09f390e4d9318894b9f6ac7fd83897cd8d18896ba579c401e",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract Unitroller",
                "name": "unitroller",
                "type": "address",
            }
        ],
        "name": "_become",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x1d504dc6",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "_borrowGuardianPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xe6653f3d",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "_mintGuardianPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x3c94786f",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract CToken", "name": "cToken", "type": "address"},
            {"internalType": "bool", "name": "state", "type": "bool"},
        ],
        "name": "_setBorrowPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x18c882a5",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "contract CToken", "name": "cToken", "type": "address"},
            {"internalType": "bool", "name": "state", "type": "bool"},
        ],
        "name": "_setMintPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x3bcf7ec1",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "newPauseGuardian", "type": "address"}
        ],
        "name": "_setPauseGuardian",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x5f5af1aa",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "bool", "name": "state", "type": "bool"}],
        "name": "_setSeizePaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x2d70db78",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "bool", "name": "state", "type": "bool"}],
        "name": "_setTransferPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x8ebf6364",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "borrowGuardianPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x6d154ea5",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "mintGuardianPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x731f0c2b",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "pauseGuardian",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x24a3d622",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "seizeGuardianPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xac0b0bb7",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "transferGuardianPaused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x87f76303",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newSpeed",
                "type": "uint256",
            },
        ],
        "name": "CompSpeedUpdated",
        "type": "event",
        "signature": "0x2ab93f65628379309f36cb125e90d7c902454a545c4f8b8cb0794af75c24b807",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "borrower",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "compDelta",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "compBorrowIndex",
                "type": "uint256",
            },
        ],
        "name": "DistributedBorrowerComp",
        "type": "event",
        "signature": "0x1fc3ecc087d8d2d15e23d0032af5a47059c3892d003d8e139fdcb6bb327c99a6",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "supplier",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "compDelta",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "compSupplyIndex",
                "type": "uint256",
            },
        ],
        "name": "DistributedSupplierComp",
        "type": "event",
        "signature": "0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract CToken",
                "name": "cToken",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "bool",
                "name": "isComped",
                "type": "bool",
            },
        ],
        "name": "MarketComped",
        "type": "event",
        "signature": "0x93c1f3e36ed71139f466a4ce8c9751790e2e33f5afb2df0dcfb3aeabe55d5aa2",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "oldCompRate",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "newCompRate",
                "type": "uint256",
            },
        ],
        "name": "NewCompRate",
        "type": "event",
        "signature": "0xc227c9272633c3a307d9845bf2bc2509cefb20d655b5f3c1002d8e1e3f22c8b0",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address[]", "name": "cTokens", "type": "address[]"}
        ],
        "name": "_addCompMarkets",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xce485c5e",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract Unitroller",
                "name": "unitroller",
                "type": "address",
            },
            {"internalType": "uint256", "name": "compRate_", "type": "uint256"},
            {
                "internalType": "address[]",
                "name": "compMarketsToAdd",
                "type": "address[]",
            },
            {
                "internalType": "address[]",
                "name": "otherMarketsToAdd",
                "type": "address[]",
            },
        ],
        "name": "_become",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x992c5294",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "compRate_", "type": "uint256"},
            {
                "internalType": "address[]",
                "name": "compMarketsToAdd",
                "type": "address[]",
            },
            {
                "internalType": "address[]",
                "name": "otherMarketsToAdd",
                "type": "address[]",
            },
        ],
        "name": "_becomeG3",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x2327c7df",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "cToken", "type": "address"}],
        "name": "_dropCompMarket",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x3aa729b4",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "uint256", "name": "compRate_", "type": "uint256"}],
        "name": "_setCompRate",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x6a491112",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "name": "allMarkets",
        "outputs": [{"internalType": "contract CToken", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x52d84d1e",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "holder", "type": "address"},
            {
                "internalType": "contract CToken[]",
                "name": "cTokens",
                "type": "address[]",
            },
        ],
        "name": "claimComp",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x1c3db2e0",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address[]", "name": "holders", "type": "address[]"},
            {
                "internalType": "contract CToken[]",
                "name": "cTokens",
                "type": "address[]",
            },
            {"internalType": "bool", "name": "borrowers", "type": "bool"},
            {"internalType": "bool", "name": "suppliers", "type": "bool"},
        ],
        "name": "claimComp",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x6810dfa6",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "holder", "type": "address"}],
        "name": "claimComp",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0xe9af0292",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "compAccrued",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xcc7ebdc4",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "compBorrowState",
        "outputs": [
            {"internalType": "uint224", "name": "index", "type": "uint224"},
            {"internalType": "uint32", "name": "block", "type": "uint32"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x8c57804e",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "", "type": "address"},
            {"internalType": "address", "name": "", "type": "address"},
        ],
        "name": "compBorrowerIndex",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xca0af043",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "compClaimThreshold",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x747026c9",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "compInitialIndex",
        "outputs": [{"internalType": "uint224", "name": "", "type": "uint224"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xa7f0e231",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "compRate",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xaa900754",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "compSpeeds",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x1d7b33d7",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "", "type": "address"},
            {"internalType": "address", "name": "", "type": "address"},
        ],
        "name": "compSupplierIndex",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xb21be7fd",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "compSupplyState",
        "outputs": [
            {"internalType": "uint224", "name": "index", "type": "uint224"},
            {"internalType": "uint32", "name": "block", "type": "uint32"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x6b79c38d",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getAllMarkets",
        "outputs": [
            {"internalType": "contract CToken[]", "name": "", "type": "address[]"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0xb0772d0b",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getBlockNumber",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x42cbb15c",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getCompAddress",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x9d1b5a0a",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "account", "type": "address"},
            {"internalType": "address", "name": "cTokenModify", "type": "address"},
            {"internalType": "uint256", "name": "redeemTokens", "type": "uint256"},
            {"internalType": "uint256", "name": "borrowAmount", "type": "uint256"},
        ],
        "name": "getHypotheticalAccountLiquidity",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
        "signature": "0x4e79238f",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "refreshCompSpeeds",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
        "signature": "0x4d8e5037",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/gnosis_protocol.py ---
# flake8: noqa E501
import json

gnosis_protocol_abi = json.loads(
    '[{"constant":true,"inputs":[],"name":"IMPROVEMENT_DENOMINATOR","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getSecondsRemainingInBatch","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getEncodedOrders","outputs":[{"name":"elements","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"buyToken","type":"uint16"},{"name":"sellToken","type":"uint16"},{"name":"validUntil","type":"uint32"},{"name":"buyAmount","type":"uint128"},{"name":"sellAmount","type":"uint128"}],"name":"placeOrder","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"batchId","type":"uint32"},{"name":"claimedObjectiveValue","type":"uint256"},{"name":"owners","type":"address[]"},{"name":"orderIds","type":"uint16[]"},{"name":"buyVolumes","type":"uint128[]"},{"name":"prices","type":"uint128[]"},{"name":"tokenIdsForPrice","type":"uint16[]"}],"name":"submitSolution","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"id","type":"uint16"}],"name":"tokenIdToAddressMap","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"token","type":"address"},{"name":"amount","type":"uint256"}],"name":"requestWithdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"FEE_FOR_LISTING_TOKEN_IN_OWL","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"previousPageUser","type":"address"},{"name":"pageSize","type":"uint16"}],"name":"getUsersPaginated","outputs":[{"name":"users","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"token","type":"address"},{"name":"amount","type":"uint256"}],"name":"deposit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"orderIds","type":"uint16[]"}],"name":"cancelOrders","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"AMOUNT_MINIMUM","outputs":[{"name":"","type":"uint128"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"feeToken","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"buyTokens","type":"uint16[]"},{"name":"sellTokens","type":"uint16[]"},{"name":"validFroms","type":"uint32[]"},{"name":"validUntils","type":"uint32[]"},{"name":"buyAmounts","type":"uint128[]"},{"name":"sellAmounts","type":"uint128[]"}],"name":"placeValidFromOrders","outputs":[{"name":"orderIds","type":"uint16[]"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint16"}],"name":"currentPrices","outputs":[{"name":"","type":"uint128"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"user","type":"address"}],"name":"getEncodedUserOrders","outputs":[{"name":"elements","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"},{"name":"","type":"uint256"}],"name":"orders","outputs":[{"name":"buyToken","type":"uint16"},{"name":"sellToken","type":"uint16"},{"name":"validFrom","type":"uint32"},{"name":"validUntil","type":"uint32"},{"name":"priceNumerator","type":"uint128"},{"name":"priceDenominator","type":"uint128"},{"name":"usedAmount","type":"uint128"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"UNLIMITED_ORDER_AMOUNT","outputs":[{"name":"","type":"uint128"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"numTokens","outputs":[{"name":"","type":"uint16"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"},{"name":"","type":"address"}],"name":"lastCreditBatchId","outputs":[{"name":"","type":"uint32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"previousPageUser","type":"address"},{"name":"previousPageUserOffset","type":"uint16"},{"name":"pageSize","type":"uint16"}],"name":"getEncodedUsersPaginated","outputs":[{"name":"elements","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"addr","type":"address"}],"name":"hasToken","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"latestSolution","outputs":[{"name":"batchId","type":"uint32"},{"name":"solutionSubmitter","type":"address"},{"name":"feeReward","type":"uint256"},{"name":"objectiveValue","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"user","type":"address"},{"name":"token","type":"address"}],"name":"getPendingDeposit","outputs":[{"name":"","type":"uint256"},{"name":"","type":"uint32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"cancellations","type":"uint16[]"},{"name":"buyTokens","type":"uint16[]"},{"name":"sellTokens","type":"uint16[]"},{"name":"validFroms","type":"uint32[]"},{"name":"validUntils","type":"uint32[]"},{"name":"buyAmounts","type":"uint128[]"},{"name":"sellAmounts","type":"uint128[]"}],"name":"replaceOrders","outputs":[{"name":"","type":"uint16[]"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"user","type":"address"},{"name":"token","type":"address"}],"name":"getPendingWithdraw","outputs":[{"name":"","type":"uint256"},{"name":"","type":"uint32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"batchId","type":"uint32"}],"name":"acceptingSolutions","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"token","type":"address"}],"name":"addToken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"user","type":"address"},{"name":"token","type":"address"}],"name":"getBalance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"FEE_DENOMINATOR","outputs":[{"name":"","type":"uint128"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"ENCODED_AUCTION_ELEMENT_WIDTH","outputs":[{"name":"","type":"uint128"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"BATCH_TIME","outputs":[{"name":"","type":"uint32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getCurrentBatchId","outputs":[{"name":"","type":"uint32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"user","type":"address"},{"name":"offset","type":"uint16"},{"name":"pageSize","type":"uint16"}],"name":"getEncodedUserOrdersPaginated","outputs":[{"name":"elements","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"addr","type":"address"}],"name":"tokenAddressToIdMap","outputs":[{"name":"","type":"uint16"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"token","type":"address"},{"name":"amount","type":"uint256"},{"name":"batchId","type":"uint32"}],"name":"requestFutureWithdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"user","type":"address"},{"name":"token","type":"address"}],"name":"hasValidWithdrawRequest","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MAX_TOKENS","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"user","type":"address"},{"name":"token","type":"address"}],"name":"withdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"MAX_TOUCHED_ORDERS","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getCurrentObjectiveValue","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"maxTokens","type":"uint256"},{"name":"_feeToken","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"index","type":"uint16"},{"indexed":true,"name":"buyToken","type":"uint16"},{"indexed":true,"name":"sellToken","type":"uint16"},{"indexed":false,"name":"validFrom","type":"uint32"},{"indexed":false,"name":"validUntil","type":"uint32"},{"indexed":false,"name":"priceNumerator","type":"uint128"},{"indexed":false,"name":"priceDenominator","type":"uint128"}],"name":"OrderPlacement","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"id","type":"uint16"}],"name":"TokenListing","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"id","type":"uint16"}],"name":"OrderCancellation","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"id","type":"uint16"}],"name":"OrderDeletion","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"orderId","type":"uint16"},{"indexed":true,"name":"sellToken","type":"uint16"},{"indexed":false,"name":"buyToken","type":"uint16"},{"indexed":false,"name":"executedSellAmount","type":"uint128"},{"indexed":false,"name":"executedBuyAmount","type":"uint128"}],"name":"Trade","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"orderId","type":"uint16"},{"indexed":true,"name":"sellToken","type":"uint16"},{"indexed":false,"name":"buyToken","type":"uint16"},{"indexed":false,"name":"executedSellAmount","type":"uint128"},{"indexed":false,"name":"executedBuyAmount","type":"uint128"}],"name":"TradeReversion","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"submitter","type":"address"},{"indexed":false,"name":"utility","type":"uint256"},{"indexed":false,"name":"disregardedUtility","type":"uint256"},{"indexed":false,"name":"burntFees","type":"uint256"},{"indexed":false,"name":"lastAuctionBurntFees","type":"uint256"},{"indexed":false,"name":"prices","type":"uint128[]"},{"indexed":false,"name":"tokenIdsForPrice","type":"uint16[]"}],"name":"SolutionSubmission","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"user","type":"address"},{"indexed":true,"name":"token","type":"address"},{"indexed":false,"name":"amount","type":"uint256"},{"indexed":false,"name":"batchId","type":"uint32"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"user","type":"address"},{"indexed":true,"name":"token","type":"address"},{"indexed":false,"name":"amount","type":"uint256"},{"indexed":false,"name":"batchId","type":"uint32"}],"name":"WithdrawRequest","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"user","type":"address"},{"indexed":true,"name":"token","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Withdraw","type":"event"}]'
)

fleet_factory_deterministic_abi = json.loads(
    '[{"constant":true,"inputs":[],"name":"proxyFactory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"size","type":"uint256"},{"name":"template","type":"address"},{"name":"saltNonce","type":"uint256"}],"name":"deployFleetWithNonce","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"_proxyFactory","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"fleet","type":"address[]"}],"name":"FleetDeployed","type":"event"}]'
)
fleet_factory_abi = json.loads(
    '[{"constant":false,"inputs":[{"name":"owner","type":"address"},{"name":"size","type":"uint256"},{"name":"template","type":"address"}],"name":"deployFleet","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"proxyFactory","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_proxyFactory","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":false,"name":"fleet","type":"address[]"}],"name":"FleetDeployed","type":"event"}]'
)

'''
'''--- safe_transaction_service/contracts/decoder_abis/gnosis_safe.py ---
# flake8: noqa E501
import json

gnosis_safe_allowance_module_abi = json.loads(
    '[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"safe","type":"address"},{"indexed":false,"internalType":"address","name":"delegate","type":"address"}],"name":"AddDelegate","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"safe","type":"address"},{"indexed":false,"internalType":"address","name":"delegate","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"}],"name":"DeleteAllowance","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"safe","type":"address"},{"indexed":false,"internalType":"address","name":"delegate","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint96","name":"value","type":"uint96"},{"indexed":false,"internalType":"uint16","name":"nonce","type":"uint16"}],"name":"ExecuteAllowanceTransfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"safe","type":"address"},{"indexed":false,"internalType":"address","name":"delegate","type":"address"},{"indexed":false,"internalType":"address","name":"paymentToken","type":"address"},{"indexed":false,"internalType":"address","name":"paymentReceiver","type":"address"},{"indexed":false,"internalType":"uint96","name":"payment","type":"uint96"}],"name":"PayAllowanceTransfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"safe","type":"address"},{"indexed":false,"internalType":"address","name":"delegate","type":"address"}],"name":"RemoveDelegate","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"safe","type":"address"},{"indexed":false,"internalType":"address","name":"delegate","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"}],"name":"ResetAllowance","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"safe","type":"address"},{"indexed":false,"internalType":"address","name":"delegate","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint96","name":"allowanceAmount","type":"uint96"},{"indexed":false,"internalType":"uint16","name":"resetTime","type":"uint16"}],"name":"SetAllowance","type":"event"},{"inputs":[],"name":"ALLOWANCE_TRANSFER_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DOMAIN_SEPARATOR_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NAME","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"delegate","type":"address"}],"name":"addDelegate","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"allowances","outputs":[{"internalType":"uint96","name":"amount","type":"uint96"},{"internalType":"uint96","name":"spent","type":"uint96"},{"internalType":"uint16","name":"resetTimeMin","type":"uint16"},{"internalType":"uint32","name":"lastResetMin","type":"uint32"},{"internalType":"uint16","name":"nonce","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint48","name":"","type":"uint48"}],"name":"delegates","outputs":[{"internalType":"address","name":"delegate","type":"address"},{"internalType":"uint48","name":"prev","type":"uint48"},{"internalType":"uint48","name":"next","type":"uint48"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"delegatesStart","outputs":[{"internalType":"uint48","name":"","type":"uint48"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"delegate","type":"address"},{"internalType":"address","name":"token","type":"address"}],"name":"deleteAllowance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract GnosisSafe","name":"safe","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"address payable","name":"to","type":"address"},{"internalType":"uint96","name":"amount","type":"uint96"},{"internalType":"address","name":"paymentToken","type":"address"},{"internalType":"uint96","name":"payment","type":"uint96"},{"internalType":"address","name":"delegate","type":"address"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"executeAllowanceTransfer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"safe","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint96","name":"amount","type":"uint96"},{"internalType":"address","name":"paymentToken","type":"address"},{"internalType":"uint96","name":"payment","type":"uint96"},{"internalType":"uint16","name":"nonce","type":"uint16"}],"name":"generateTransferHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getChainId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"safe","type":"address"},{"internalType":"uint48","name":"start","type":"uint48"},{"internalType":"uint8","name":"pageSize","type":"uint8"}],"name":"getDelegates","outputs":[{"internalType":"address[]","name":"results","type":"address[]"},{"internalType":"uint48","name":"next","type":"uint48"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"safe","type":"address"},{"internalType":"address","name":"delegate","type":"address"},{"internalType":"address","name":"token","type":"address"}],"name":"getTokenAllowance","outputs":[{"internalType":"uint256[5]","name":"","type":"uint256[5]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"safe","type":"address"},{"internalType":"address","name":"delegate","type":"address"}],"name":"getTokens","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"delegate","type":"address"},{"internalType":"bool","name":"removeAllowances","type":"bool"}],"name":"removeDelegate","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"delegate","type":"address"},{"internalType":"address","name":"token","type":"address"}],"name":"resetAllowance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"delegate","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint96","name":"allowanceAmount","type":"uint96"},{"internalType":"uint16","name":"resetTimeMin","type":"uint16"},{"internalType":"uint32","name":"resetBaseMin","type":"uint32"}],"name":"setAllowance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"tokens","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]'
)
gnosis_multisend_abi = json.loads(
    '[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"constant":false,"inputs":[{"internalType":"bytes","name":"transactions","type":"bytes"}],"name":"multiSend","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]'
)

'''
'''--- safe_transaction_service/contracts/decoder_abis/idle.py ---
idle_token_v3 = [
    {
        "inputs": [
            {"internalType": "string", "name": "_name", "type": "string"},
            {"internalType": "string", "name": "_symbol", "type": "string"},
            {"internalType": "uint8", "name": "_decimals", "type": "uint8"},
            {"internalType": "address", "name": "_token", "type": "address"},
            {"internalType": "address", "name": "_cToken", "type": "address"},
            {"internalType": "address", "name": "_iToken", "type": "address"},
            {"internalType": "address", "name": "_rebalancer", "type": "address"},
            {"internalType": "address", "name": "_priceCalculator", "type": "address"},
            {"internalType": "address", "name": "_idleCompound", "type": "address"},
            {"internalType": "address", "name": "_idleFulcrum", "type": "address"},
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "owner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "spender",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "value",
                "type": "uint256",
            },
        ],
        "name": "Approval",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "previousOwner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newOwner",
                "type": "address",
            },
        ],
        "name": "OwnershipTransferred",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "account",
                "type": "address",
            }
        ],
        "name": "Paused",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "account",
                "type": "address",
            }
        ],
        "name": "PauserAdded",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "account",
                "type": "address",
            }
        ],
        "name": "PauserRemoved",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "from",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "value",
                "type": "uint256",
            },
        ],
        "name": "Transfer",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "account",
                "type": "address",
            }
        ],
        "name": "Unpaused",
        "type": "event",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "addPauser",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "name": "allAvailableTokens",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "owner", "type": "address"},
            {"internalType": "address", "name": "spender", "type": "address"},
        ],
        "name": "allowance",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "spender", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "approve",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "spender", "type": "address"},
            {"internalType": "uint256", "name": "subtractedValue", "type": "uint256"},
        ],
        "name": "decreaseAllowance",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "fee",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "feeAddress",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "gst2",
        "outputs": [
            {"internalType": "contract GasToken", "name": "", "type": "address"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "iToken",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "spender", "type": "address"},
            {"internalType": "uint256", "name": "addedValue", "type": "uint256"},
        ],
        "name": "increaseAllowance",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isNewProtocolDelayed",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isOwner",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "isPauser",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isRiskAdjusted",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "name": "lastAllocations",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "lastITokenPrice",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "manualPlay",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "name",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "owner",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "pause",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "paused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "priceCalculator",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "protocolWrappers",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "rebalancer",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "releaseTimes",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "renouncePauser",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "token",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "tokenDecimals",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}],
        "name": "transferOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "unpause",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
        "name": "userAvgPrices",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_rebalancer", "type": "address"}
        ],
        "name": "setRebalancer",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_priceCalculator", "type": "address"}
        ],
        "name": "setPriceCalculator",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_token", "type": "address"},
            {"internalType": "address", "name": "_wrapper", "type": "address"},
        ],
        "name": "setProtocolWrapper",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "bool", "name": "_manualPlay", "type": "bool"}],
        "name": "setManualPlay",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "bool", "name": "_isRiskAdjusted", "type": "bool"}],
        "name": "setIsRiskAdjusted",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "delayNewProtocols",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "uint256", "name": "_fee", "type": "uint256"}],
        "name": "setFee",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_feeAddress", "type": "address"}
        ],
        "name": "setFeeAddress",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256[]", "name": "_amounts", "type": "uint256[]"}
        ],
        "name": "setGasParams",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "tokenPrice",
        "outputs": [{"internalType": "uint256", "name": "price", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getAPRs",
        "outputs": [
            {"internalType": "address[]", "name": "addresses", "type": "address[]"},
            {"internalType": "uint256[]", "name": "aprs", "type": "uint256[]"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getAvgAPR",
        "outputs": [{"internalType": "uint256", "name": "avgApr", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "sender", "type": "address"},
            {"internalType": "address", "name": "recipient", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "transferFrom",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "recipient", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "transfer",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "bool", "name": "_skipWholeRebalance", "type": "bool"},
        ],
        "name": "mintIdleToken",
        "outputs": [
            {"internalType": "uint256", "name": "mintedTokens", "type": "uint256"}
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "uint256[]", "name": "", "type": "uint256[]"},
        ],
        "name": "mintIdleToken",
        "outputs": [
            {"internalType": "uint256", "name": "mintedTokens", "type": "uint256"}
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "bool", "name": "_skipRebalance", "type": "bool"},
            {"internalType": "uint256[]", "name": "", "type": "uint256[]"},
        ],
        "name": "redeemIdleToken",
        "outputs": [
            {"internalType": "uint256", "name": "redeemedTokens", "type": "uint256"}
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "uint256", "name": "_amount", "type": "uint256"}],
        "name": "redeemInterestBearingTokens",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "uint256[]",
                "name": "_newAllocations",
                "type": "uint256[]",
            }
        ],
        "name": "openRebalance",
        "outputs": [
            {"internalType": "bool", "name": "", "type": "bool"},
            {"internalType": "uint256", "name": "avgApr", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "rebalanceWithGST",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "rebalance",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "uint256[]", "name": "", "type": "uint256[]"},
        ],
        "name": "rebalance",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getCurrentAllocations",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "tokenAddresses",
                "type": "address[]",
            },
            {"internalType": "uint256[]", "name": "amounts", "type": "uint256[]"},
            {"internalType": "uint256", "name": "total", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/maker_dao.py ---
import json

maker_dao_erc20_fee_proxy = json.loads(
    '[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"tokenAddress","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":true,"internalType":"bytes","name":"paymentReference","type":"bytes"},{"indexed":false,"internalType":"uint256","name":"feeAmount","type":"uint256"},{"indexed":false,"internalType":"address","name":"feeAddress","type":"address"}],"name":"TransferWithReferenceAndFee","type":"event"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"constant":false,"inputs":[{"internalType":"address","name":"_tokenAddress","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"},{"internalType":"bytes","name":"_paymentReference","type":"bytes"},{"internalType":"uint256","name":"_feeAmount","type":"uint256"},{"internalType":"address","name":"_feeAddress","type":"address"}],"name":"transferFromWithReferenceAndFee","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]'
)
maker_dao_abis = [
    maker_dao_erc20_fee_proxy,
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "vat", "type": "address"},
                {"internalType": "address", "name": "dai", "type": "address"},
            ],
            "name": "newDaiJoin",
            "outputs": [
                {
                    "internalType": "contract DaiJoin",
                    "name": "daiJoin",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSValue",
                    "name": "value",
                    "type": "address",
                },
                {"internalType": "bytes32", "name": "wut", "type": "bytes32"},
            ],
            "name": "doPoke",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "contract DSValue", "name": "value", "type": "address"}
            ],
            "name": "doVoid",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "vat_", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "base",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "drip",
            "outputs": [{"internalType": "uint256", "name": "rate", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "ilks",
            "outputs": [
                {"internalType": "uint256", "name": "duty", "type": "uint256"},
                {"internalType": "uint256", "name": "rho", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "init",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vow",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "end", "type": "address"}],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "address", "name": "to", "type": "address"},
            ],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "dripAndFile",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "dripAndFile",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
            ],
            "name": "init",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "address", "name": "to", "type": "address"},
            ],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "newAuthority", "type": "address"},
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "newAuthority", "type": "address"},
                {"internalType": "uint256", "name": "newDelay", "type": "uint256"},
            ],
            "name": "setAuthorityAndDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "uint256", "name": "newDelay", "type": "uint256"},
            ],
            "name": "setDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "cat_", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "flip",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "cat",
                    "type": "address",
                },
            ],
            "name": "Deny",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "flip",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
            ],
            "name": "Rely",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "oldAuthority",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "newAuthority",
                    "type": "address",
                },
            ],
            "name": "SetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "oldOwner",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "newOwner",
                    "type": "address",
                },
            ],
            "name": "SetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cat",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "flip", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "flip", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "authority_", "type": "address"}
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "address", "name": "dai_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dai",
            "outputs": [
                {"internalType": "contract DSTokenLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "address", "name": "flapper_", "type": "address"},
                {"internalType": "address", "name": "flopper_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "Ash",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "Sin",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "bump",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dump",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "tab", "type": "uint256"}],
            "name": "fess",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "flap",
            "outputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flapper",
            "outputs": [
                {"internalType": "contract FlapLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "era", "type": "uint256"}],
            "name": "flog",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "flop",
            "outputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flopper",
            "outputs": [
                {"internalType": "contract FlopLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "rad", "type": "uint256"}],
            "name": "heal",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "hump",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "rad", "type": "uint256"}],
            "name": "kiss",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "name": "sin",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "sump",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "wait",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                }
            ],
            "name": "LogDeny",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                }
            ],
            "name": "LogRely",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "newRoot",
                    "type": "address",
                }
            ],
            "name": "LogSetRoot",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "canCall",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "root",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "setRoot",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "name": "setAuthorityAndDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "id",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "lot",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "bid",
                    "type": "uint256",
                },
            ],
            "name": "Kick",
            "type": "event",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "beg",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "name": "bids",
            "outputs": [
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint48", "name": "tic", "type": "uint48"},
                {"internalType": "uint48", "name": "end", "type": "uint48"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "rad", "type": "uint256"}],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "deal",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
            ],
            "name": "kick",
            "outputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "kicks",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "tau",
            "outputs": [{"internalType": "uint48", "name": "", "type": "uint48"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "id", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
            ],
            "name": "tend",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "tick",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ttl",
            "outputs": [{"internalType": "uint48", "name": "", "type": "uint48"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "yank",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "implementations",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "address",
                    "name": "implementation",
                    "type": "address",
                },
                {"internalType": "uint256", "name": "permitted", "type": "uint256"},
            ],
            "name": "setImplementation",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "vat", "type": "address"}],
            "name": "newSpotter",
            "outputs": [
                {
                    "internalType": "contract Spotter",
                    "name": "spotter",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract DSChief",
                    "name": "chief_",
                    "type": "address",
                },
                {"internalType": "contract DSToken", "name": "gov_", "type": "address"},
                {"internalType": "contract DSToken", "name": "iou_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "approveGov",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "approveIou",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "amt", "type": "uint256"}],
            "name": "doChiefFree",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "amt", "type": "uint256"}],
            "name": "doChiefLock",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "amt", "type": "uint256"}],
            "name": "doProxyFree",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "doProxyFreeAll",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "amt", "type": "uint256"}],
            "name": "doProxyLock",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address[]", "name": "yays", "type": "address[]"}
            ],
            "name": "doProxyVote",
            "outputs": [
                {"internalType": "bytes32", "name": "slate", "type": "bytes32"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "slate", "type": "bytes32"}],
            "name": "doProxyVote",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "amt", "type": "uint256"},
            ],
            "name": "doTransfer",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "proxy",
            "outputs": [
                {"internalType": "contract VoteProxy", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract VoteProxy",
                    "name": "proxy_",
                    "type": "address",
                }
            ],
            "name": "setProxy",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract VatFab",
                    "name": "vatFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract JugFab",
                    "name": "jugFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract VowFab",
                    "name": "vowFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract CatFab",
                    "name": "catFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract DaiFab",
                    "name": "daiFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract DaiJoinFab",
                    "name": "daiJoinFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract FlapFab",
                    "name": "flapFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract FlopFab",
                    "name": "flopFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract FlipFab",
                    "name": "flipFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract SpotFab",
                    "name": "spotFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract PotFab",
                    "name": "potFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract EndFab",
                    "name": "endFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract ESMFab",
                    "name": "esmFab_",
                    "type": "address",
                },
                {
                    "internalType": "contract PauseFab",
                    "name": "pauseFab_",
                    "type": "address",
                },
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cat",
            "outputs": [
                {"internalType": "contract Cat", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "catFab",
            "outputs": [
                {"internalType": "contract CatFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dai",
            "outputs": [
                {"internalType": "contract Dai", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "daiFab",
            "outputs": [
                {"internalType": "contract DaiFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "daiJoin",
            "outputs": [
                {"internalType": "contract DaiJoin", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "daiJoinFab",
            "outputs": [
                {"internalType": "contract DaiJoinFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "gov", "type": "address"}],
            "name": "deployAuctions",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "join", "type": "address"},
                {"internalType": "address", "name": "pip", "type": "address"},
            ],
            "name": "deployCollateral",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "chainId", "type": "uint256"}
            ],
            "name": "deployDai",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "deployLiquidator",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "delay", "type": "uint256"},
                {"internalType": "address", "name": "authority", "type": "address"},
            ],
            "name": "deployPause",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gov", "type": "address"},
                {"internalType": "address", "name": "pit", "type": "address"},
                {"internalType": "uint256", "name": "min", "type": "uint256"},
            ],
            "name": "deployShutdown",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "deployTaxation",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "deployVat",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "end",
            "outputs": [
                {"internalType": "contract End", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "endFab",
            "outputs": [
                {"internalType": "contract EndFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "esm",
            "outputs": [
                {"internalType": "contract ESM", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "esmFab",
            "outputs": [
                {"internalType": "contract ESMFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flap",
            "outputs": [
                {"internalType": "contract Flapper", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flapFab",
            "outputs": [
                {"internalType": "contract FlapFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flipFab",
            "outputs": [
                {"internalType": "contract FlipFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flop",
            "outputs": [
                {"internalType": "contract Flopper", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flopFab",
            "outputs": [
                {"internalType": "contract FlopFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "ilks",
            "outputs": [
                {"internalType": "contract Flipper", "name": "flip", "type": "address"},
                {"internalType": "address", "name": "join", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "jug",
            "outputs": [
                {"internalType": "contract Jug", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "jugFab",
            "outputs": [
                {"internalType": "contract JugFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "pause",
            "outputs": [
                {"internalType": "contract DSPause", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "pauseFab",
            "outputs": [
                {"internalType": "contract PauseFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "pot",
            "outputs": [
                {"internalType": "contract Pot", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "potFab",
            "outputs": [
                {"internalType": "contract PotFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "releaseAuth",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "releaseAuthFlip",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "spotFab",
            "outputs": [
                {"internalType": "contract SpotFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "spotter",
            "outputs": [
                {"internalType": "contract Spotter", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "step",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract Vat", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vatFab",
            "outputs": [
                {"internalType": "contract VatFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vow",
            "outputs": [
                {"internalType": "contract Vow", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vowFab",
            "outputs": [
                {"internalType": "contract VowFab", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract DSChief",
                    "name": "chief_",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "cold",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "hot",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "voteProxy",
                    "type": "address",
                },
            ],
            "name": "LinkConfirmed",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "cold",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "hot",
                    "type": "address",
                },
            ],
            "name": "LinkRequested",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "cold", "type": "address"}],
            "name": "approveLink",
            "outputs": [
                {
                    "internalType": "contract VoteProxy",
                    "name": "voteProxy",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "breakLink",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "chief",
            "outputs": [
                {"internalType": "contract DSChief", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "coldMap",
            "outputs": [
                {"internalType": "contract VoteProxy", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "hasProxy",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "hotMap",
            "outputs": [
                {"internalType": "contract VoteProxy", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "hot", "type": "address"}],
            "name": "initiateLink",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "linkRequests",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "linkSelf",
            "outputs": [
                {
                    "internalType": "contract VoteProxy",
                    "name": "voteProxy",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "implementation",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "address",
                    "name": "newImplementation",
                    "type": "address",
                }
            ],
            "name": "setImplementation",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {
                    "components": [
                        {
                            "internalType": "address",
                            "name": "target",
                            "type": "address",
                        },
                        {"internalType": "bytes", "name": "callData", "type": "bytes"},
                    ],
                    "internalType": "struct Multicall.Call[]",
                    "name": "calls",
                    "type": "tuple[]",
                }
            ],
            "name": "aggregate",
            "outputs": [
                {"internalType": "uint256", "name": "blockNumber", "type": "uint256"},
                {"internalType": "bytes[]", "name": "returnData", "type": "bytes[]"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "uint256", "name": "blockNumber", "type": "uint256"}
            ],
            "name": "getBlockHash",
            "outputs": [
                {"internalType": "bytes32", "name": "blockHash", "type": "bytes32"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "getCurrentBlockCoinbase",
            "outputs": [
                {"internalType": "address", "name": "coinbase", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "getCurrentBlockDifficulty",
            "outputs": [
                {"internalType": "uint256", "name": "difficulty", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "getCurrentBlockGasLimit",
            "outputs": [
                {"internalType": "uint256", "name": "gaslimit", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "getCurrentBlockTimestamp",
            "outputs": [
                {"internalType": "uint256", "name": "timestamp", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "addr", "type": "address"}],
            "name": "getEthBalance",
            "outputs": [
                {"internalType": "uint256", "name": "balance", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "getLastBlockHash",
            "outputs": [
                {"internalType": "bytes32", "name": "blockHash", "type": "bytes32"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "vat", "type": "address"},
                {"internalType": "address", "name": "gov", "type": "address"},
            ],
            "name": "newFlop",
            "outputs": [
                {"internalType": "contract Flopper", "name": "flop", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "factory_", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "build",
            "outputs": [
                {"internalType": "address payable", "name": "proxy", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "owner", "type": "address"}],
            "name": "build",
            "outputs": [
                {"internalType": "address payable", "name": "proxy", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "proxies",
            "outputs": [
                {"internalType": "contract DSProxy", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "apt", "type": "address"},
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "daiJoin_join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Deposit",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Withdrawal",
            "type": "event",
        },
        {"payable": True, "stateMutability": "payable", "type": "fallback"},
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "deposit",
            "outputs": [],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "withdraw",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "vat", "type": "address"}],
            "name": "newCat",
            "outputs": [
                {"internalType": "contract Cat", "name": "cat", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "sender",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "proxy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "cache",
                    "type": "address",
                },
            ],
            "name": "Created",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "build",
            "outputs": [
                {"internalType": "address payable", "name": "proxy", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "owner", "type": "address"}],
            "name": "build",
            "outputs": [
                {"internalType": "address payable", "name": "proxy", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cache",
            "outputs": [
                {"internalType": "contract DSProxyCache", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "isProxy",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "chainId_", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "DOMAIN_SEPARATOR",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "PERMIT_TYPEHASH",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "burn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "mint",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "move",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "nonces",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "holder", "type": "address"},
                {"internalType": "address", "name": "spender", "type": "address"},
                {"internalType": "uint256", "name": "nonce", "type": "uint256"},
                {"internalType": "uint256", "name": "expiry", "type": "uint256"},
                {"internalType": "bool", "name": "allowed", "type": "bool"},
                {"internalType": "uint8", "name": "v", "type": "uint8"},
                {"internalType": "bytes32", "name": "r", "type": "bytes32"},
                {"internalType": "bytes32", "name": "s", "type": "bytes32"},
            ],
            "name": "permit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "pull",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "push",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "version",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "bids",
            "outputs": [
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint48", "name": "tic", "type": "uint48"},
                {"internalType": "uint48", "name": "end", "type": "uint48"},
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "address", "name": "gal", "type": "address"},
                {"internalType": "uint256", "name": "tab", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "yank",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "address", "name": "gal", "type": "address"},
                {"internalType": "uint256", "name": "tab", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
            ],
            "name": "kick",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "constant": True,
            "inputs": [{"internalType": "bytes", "name": "_code", "type": "bytes"}],
            "name": "read",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes", "name": "_code", "type": "bytes"}],
            "name": "write",
            "outputs": [
                {"internalType": "address", "name": "target", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "getCdpsAsc",
            "outputs": [
                {"internalType": "uint256[]", "name": "ids", "type": "uint256[]"},
                {"internalType": "address[]", "name": "urns", "type": "address[]"},
                {"internalType": "bytes32[]", "name": "ilks", "type": "bytes32[]"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "getCdpsDesc",
            "outputs": [
                {"internalType": "uint256[]", "name": "ids", "type": "uint256[]"},
                {"internalType": "address[]", "name": "urns", "type": "address[]"},
                {"internalType": "bytes32[]", "name": "ilks", "type": "bytes32[]"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [{"payable": False, "stateMutability": "nonpayable", "type": "fallback"}],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "vat", "type": "address"}],
            "name": "newJug",
            "outputs": [
                {"internalType": "contract Jug", "name": "jug", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "constant": True,
            "inputs": [],
            "name": "get",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "_val", "type": "uint256"}],
            "name": "getAdd",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "getAnd10",
            "outputs": [
                {"internalType": "uint256", "name": "", "type": "uint256"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "_val", "type": "uint256"}],
            "name": "set",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Deposit",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Withdrawal",
            "type": "event",
        },
        {"payable": True, "stateMutability": "payable", "type": "fallback"},
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "deposit",
            "outputs": [],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "join",
            "outputs": [],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "withdraw",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "foo",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "bar",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "fax",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "peek",
            "outputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "bool", "name": "", "type": "bool"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "wut", "type": "bytes32"}],
            "name": "poke",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "read",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "void",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cap1",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cap2",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flag1",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "flag2",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "id",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "lot",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "bid",
                    "type": "uint256",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "gal",
                    "type": "address",
                },
            ],
            "name": "Kick",
            "type": "event",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "beg",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "name": "bids",
            "outputs": [
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint48", "name": "tic", "type": "uint48"},
                {"internalType": "uint48", "name": "end", "type": "uint48"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "deal",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "id", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
            ],
            "name": "dent",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gal", "type": "address"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
            ],
            "name": "kick",
            "outputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "kicks",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "pad",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "tau",
            "outputs": [{"internalType": "uint48", "name": "", "type": "uint48"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "tick",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ttl",
            "outputs": [{"internalType": "uint48", "name": "", "type": "uint48"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vow",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "yank",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract DSChief",
                    "name": "_chief",
                    "type": "address",
                },
                {"internalType": "address", "name": "_cold", "type": "address"},
                {"internalType": "address", "name": "_hot", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "chief",
            "outputs": [
                {"internalType": "contract DSChief", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cold",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "free",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "freeAll",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gov",
            "outputs": [
                {"internalType": "contract DSToken", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "hot",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "iou",
            "outputs": [
                {"internalType": "contract DSToken", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "lock",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "slate", "type": "bytes32"}],
            "name": "vote",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address[]", "name": "yays", "type": "address[]"}
            ],
            "name": "vote",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "vat", "type": "address"},
                {"internalType": "address", "name": "gov", "type": "address"},
            ],
            "name": "newFlap",
            "outputs": [
                {"internalType": "contract Flapper", "name": "flap", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract DSToken",
                    "name": "token_",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "owner", "type": "address"},
                {"internalType": "address", "name": "spender", "type": "address"},
            ],
            "name": "doAllowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "doApprove",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "recipient", "type": "address"},
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "doApprove",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "who", "type": "address"}],
            "name": "doBalanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "doBurn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "doBurn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "doMint",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "doMint",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "doMove",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "doPull",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "doPush",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "name", "type": "bytes32"}],
            "name": "doSetName",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "to", "type": "address"},
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "doTransfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "from", "type": "address"},
                {"internalType": "address", "name": "to", "type": "address"},
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "doTransferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract FlipperMom",
                    "name": "mom_",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "flip", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "flip", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "newAuthority", "type": "address"}
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "newOwner", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "bytes32", "name": "symbol_", "type": "bytes32"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Burn",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Mint",
            "type": "event",
        },
        {"anonymous": False, "inputs": [], "name": "Start", "type": "event"},
        {"anonymous": False, "inputs": [], "name": "Stop", "type": "event"},
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "burn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "burn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "mint",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "mint",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "move",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "pull",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "push",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "name_", "type": "bytes32"}],
            "name": "setName",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "start",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "stop",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "stopped",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract MkrAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "burn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "burn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "mint",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "notMintOrBurn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "setRoot",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "address", "name": "cat_", "type": "address"},
                {"internalType": "address", "name": "spot_", "type": "address"},
            ],
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "ilk",
                    "type": "bytes32",
                }
            ],
            "name": "AddIlk",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                }
            ],
            "name": "Deny",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "ilk",
                    "type": "bytes32",
                }
            ],
            "name": "NameError",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                }
            ],
            "name": "Rely",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "ilk",
                    "type": "bytes32",
                }
            ],
            "name": "RemoveIlk",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "ilk",
                    "type": "bytes32",
                }
            ],
            "name": "SymbolError",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "ilk",
                    "type": "bytes32",
                }
            ],
            "name": "UpdateIlk",
            "type": "event",
        },
        {
            "inputs": [
                {"internalType": "address", "name": "adapter", "type": "address"}
            ],
            "name": "add",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "cat",
            "outputs": [
                {"internalType": "contract CatLike", "name": "", "type": "address"}
            ],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "count",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "string", "name": "data", "type": "string"},
            ],
            "name": "file",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "flip",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "gem",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "uint256", "name": "pos", "type": "uint256"}],
            "name": "get",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "ilkData",
            "outputs": [
                {"internalType": "uint256", "name": "pos", "type": "uint256"},
                {"internalType": "address", "name": "gem", "type": "address"},
                {"internalType": "address", "name": "pip", "type": "address"},
                {"internalType": "address", "name": "join", "type": "address"},
                {"internalType": "address", "name": "flip", "type": "address"},
                {"internalType": "uint256", "name": "dec", "type": "uint256"},
                {"internalType": "string", "name": "name", "type": "string"},
                {"internalType": "string", "name": "symbol", "type": "string"},
            ],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "info",
            "outputs": [
                {"internalType": "string", "name": "name", "type": "string"},
                {"internalType": "string", "name": "symbol", "type": "string"},
                {"internalType": "uint256", "name": "dec", "type": "uint256"},
                {"internalType": "address", "name": "gem", "type": "address"},
                {"internalType": "address", "name": "pip", "type": "address"},
                {"internalType": "address", "name": "join", "type": "address"},
                {"internalType": "address", "name": "flip", "type": "address"},
            ],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "join",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "list",
            "outputs": [{"internalType": "bytes32[]", "name": "", "type": "bytes32[]"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "uint256", "name": "start", "type": "uint256"},
                {"internalType": "uint256", "name": "end", "type": "uint256"},
            ],
            "name": "list",
            "outputs": [{"internalType": "bytes32[]", "name": "", "type": "bytes32[]"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "pip",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "pos",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "remove",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "removeAuth",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "spot",
            "outputs": [
                {"internalType": "contract SpotLike", "name": "", "type": "address"}
            ],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "update",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "authorized_caller_",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authorized_caller",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "bytes4", "name": "", "type": "bytes4"},
            ],
            "name": "canCall",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "target",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "bool",
                    "name": "exact",
                    "type": "bool",
                },
            ],
            "name": "eventListener",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "",
                    "type": "bytes32",
                }
            ],
            "name": "log_bytes32",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "key",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "val",
                    "type": "address",
                },
            ],
            "name": "log_named_address",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "key",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "val",
                    "type": "bytes32",
                },
            ],
            "name": "log_named_bytes32",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "key",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "int256",
                    "name": "val",
                    "type": "int256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "decimals",
                    "type": "uint256",
                },
            ],
            "name": "log_named_decimal_int",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "key",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "val",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "decimals",
                    "type": "uint256",
                },
            ],
            "name": "log_named_decimal_uint",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "key",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "int256",
                    "name": "val",
                    "type": "int256",
                },
            ],
            "name": "log_named_int",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "key",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "string",
                    "name": "val",
                    "type": "string",
                },
            ],
            "name": "log_named_string",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "key",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "val",
                    "type": "uint256",
                },
            ],
            "name": "log_named_uint",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {"indexed": False, "internalType": "bytes", "name": "", "type": "bytes"}
            ],
            "name": "logs",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "IS_TEST",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "end", "type": "address"}],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "from", "type": "address"},
                {"internalType": "address", "name": "to", "type": "address"},
            ],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "deploy",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "deployKeepAuth",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "dripAndFile",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "dripAndFile",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "failed",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "from", "type": "address"},
                {"internalType": "address", "name": "to", "type": "address"},
            ],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "newAuthority", "type": "address"}
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "newAuthority", "type": "address"},
                {"internalType": "uint256", "name": "newDelay", "type": "uint256"},
            ],
            "name": "setAuthorityAndDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "newDelay", "type": "uint256"}
            ],
            "name": "setDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "setUp",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gov", "type": "address"},
                {"internalType": "address", "name": "end", "type": "address"},
                {"internalType": "address", "name": "pit", "type": "address"},
                {"internalType": "uint256", "name": "min", "type": "uint256"},
            ],
            "name": "newESM",
            "outputs": [
                {"internalType": "contract ESM", "name": "esm", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "vat", "type": "address"},
                {"internalType": "address", "name": "cat", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
            ],
            "name": "newFlip",
            "outputs": [
                {"internalType": "contract Flipper", "name": "flip", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "contract DSToken", "name": "GOV", "type": "address"},
                {"internalType": "contract DSToken", "name": "IOU", "type": "address"},
                {"internalType": "uint256", "name": "MAX_YAYS", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "slate",
                    "type": "bytes32",
                }
            ],
            "name": "Etch",
            "type": "event",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "foo",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "bar",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "fax",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "GOV",
            "outputs": [
                {"internalType": "contract DSToken", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "IOU",
            "outputs": [
                {"internalType": "contract DSToken", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "MAX_YAYS",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "approvals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "caller", "type": "address"},
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "canCall",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "deposits",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address[]", "name": "yays", "type": "address[]"}
            ],
            "name": "etch",
            "outputs": [
                {"internalType": "bytes32", "name": "slate", "type": "bytes32"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "free",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "getCapabilityRoles",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "who", "type": "address"}],
            "name": "getUserRoles",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "uint8", "name": "role", "type": "uint8"},
            ],
            "name": "hasUserRole",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "hat",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "isCapabilityPublic",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "who", "type": "address"}],
            "name": "isUserRoot",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "whom", "type": "address"}],
            "name": "lift",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "lock",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
                {"internalType": "bool", "name": "enabled", "type": "bool"},
            ],
            "name": "setPublicCapability",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint8", "name": "role", "type": "uint8"},
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
                {"internalType": "bool", "name": "enabled", "type": "bool"},
            ],
            "name": "setRoleCapability",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bool", "name": "enabled", "type": "bool"},
            ],
            "name": "setRootUser",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "uint8", "name": "role", "type": "uint8"},
                {"internalType": "bool", "name": "enabled", "type": "bool"},
            ],
            "name": "setUserRole",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "name": "slates",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "slate", "type": "bytes32"}],
            "name": "vote",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address[]", "name": "yays", "type": "address[]"}
            ],
            "name": "vote",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "votes",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "end", "type": "address"}],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "from", "type": "address"},
                {"internalType": "address", "name": "to", "type": "address"},
            ],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "dripAndFile",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "dripAndFile",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "from", "type": "address"},
                {"internalType": "address", "name": "to", "type": "address"},
            ],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "newAuthority", "type": "address"}
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "newAuthority", "type": "address"},
                {"internalType": "uint256", "name": "newDelay", "type": "uint256"},
            ],
            "name": "setAuthorityAndDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "newDelay", "type": "uint256"}
            ],
            "name": "setDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "caller", "type": "address"},
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "canCall",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "getCapabilityRoles",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "who", "type": "address"}],
            "name": "getUserRoles",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "uint8", "name": "role", "type": "uint8"},
            ],
            "name": "hasUserRole",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "isCapabilityPublic",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "who", "type": "address"}],
            "name": "isUserRoot",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
                {"internalType": "bool", "name": "enabled", "type": "bool"},
            ],
            "name": "setPublicCapability",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint8", "name": "role", "type": "uint8"},
                {"internalType": "address", "name": "code", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
                {"internalType": "bool", "name": "enabled", "type": "bool"},
            ],
            "name": "setRoleCapability",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bool", "name": "enabled", "type": "bool"},
            ],
            "name": "setRootUser",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "uint8", "name": "role", "type": "uint8"},
                {"internalType": "bool", "name": "enabled", "type": "bool"},
            ],
            "name": "setUserRole",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "osms",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "authority_", "type": "address"}
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "osm", "type": "address"},
            ],
            "name": "setOsm",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "stop",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Exit",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Join",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "address", "name": "end", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "cashETH",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "address", "name": "end", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "cashGem",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "apt", "type": "address"},
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "daiJoin_join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "address", "name": "end", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
            ],
            "name": "freeETH",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "address", "name": "end", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
            ],
            "name": "freeGem",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "address", "name": "end", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "pack",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "delay_", "type": "uint256"},
                {"internalType": "address", "name": "owner_", "type": "address"},
                {"internalType": "address", "name": "authority_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "foo",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "bar",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "fax",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "delay",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "bytes32", "name": "tag", "type": "bytes32"},
                {"internalType": "bytes", "name": "fax", "type": "bytes"},
                {"internalType": "uint256", "name": "eta", "type": "uint256"},
            ],
            "name": "drop",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "bytes32", "name": "tag", "type": "bytes32"},
                {"internalType": "bytes", "name": "fax", "type": "bytes"},
                {"internalType": "uint256", "name": "eta", "type": "uint256"},
            ],
            "name": "exec",
            "outputs": [{"internalType": "bytes", "name": "out", "type": "bytes"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "plans",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "bytes32", "name": "tag", "type": "bytes32"},
                {"internalType": "bytes", "name": "fax", "type": "bytes"},
                {"internalType": "uint256", "name": "eta", "type": "uint256"},
            ],
            "name": "plot",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "proxy",
            "outputs": [
                {"internalType": "contract DSPauseProxy", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "authority_", "type": "address"}
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "delay_", "type": "uint256"}
            ],
            "name": "setDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "canCall",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        }
    ],
    [
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "canCall",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "bytes4", "name": "sig", "type": "bytes4"},
            ],
            "name": "permit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "foo",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "bar",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "fax",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [],
            "name": "newVat",
            "outputs": [
                {"internalType": "contract Vat", "name": "vat", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "vat_", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "own",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "uint256",
                    "name": "cdp",
                    "type": "uint256",
                },
            ],
            "name": "NewCdp",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "ok", "type": "uint256"},
            ],
            "name": "cdpAllow",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "cdpCan",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cdpi",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "count",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
            ],
            "name": "enter",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "first",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "flux",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "flux",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "int256", "name": "dink", "type": "int256"},
                {"internalType": "int256", "name": "dart", "type": "int256"},
            ],
            "name": "frob",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
            ],
            "name": "give",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "name": "ilks",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "last",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "name": "list",
            "outputs": [
                {"internalType": "uint256", "name": "prev", "type": "uint256"},
                {"internalType": "uint256", "name": "next", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "rad", "type": "uint256"},
            ],
            "name": "move",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "usr", "type": "address"},
            ],
            "name": "open",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "name": "owns",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
            ],
            "name": "quit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "cdpSrc", "type": "uint256"},
                {"internalType": "uint256", "name": "cdpDst", "type": "uint256"},
            ],
            "name": "shift",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "ok", "type": "uint256"},
            ],
            "name": "urnAllow",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "urnCan",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "name": "urns",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg3",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "Line",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "can",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "dai",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "debt",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "flux",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "i", "type": "bytes32"},
                {"internalType": "address", "name": "u", "type": "address"},
                {"internalType": "int256", "name": "rate", "type": "int256"},
            ],
            "name": "fold",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "int256", "name": "dink", "type": "int256"},
                {"internalType": "int256", "name": "dart", "type": "int256"},
            ],
            "name": "fork",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "i", "type": "bytes32"},
                {"internalType": "address", "name": "u", "type": "address"},
                {"internalType": "address", "name": "v", "type": "address"},
                {"internalType": "address", "name": "w", "type": "address"},
                {"internalType": "int256", "name": "dink", "type": "int256"},
                {"internalType": "int256", "name": "dart", "type": "int256"},
            ],
            "name": "frob",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "gem",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "i", "type": "bytes32"},
                {"internalType": "address", "name": "u", "type": "address"},
                {"internalType": "address", "name": "v", "type": "address"},
                {"internalType": "address", "name": "w", "type": "address"},
                {"internalType": "int256", "name": "dink", "type": "int256"},
                {"internalType": "int256", "name": "dart", "type": "int256"},
            ],
            "name": "grab",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "rad", "type": "uint256"}],
            "name": "heal",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "hope",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "ilks",
            "outputs": [
                {"internalType": "uint256", "name": "Art", "type": "uint256"},
                {"internalType": "uint256", "name": "rate", "type": "uint256"},
                {"internalType": "uint256", "name": "spot", "type": "uint256"},
                {"internalType": "uint256", "name": "line", "type": "uint256"},
                {"internalType": "uint256", "name": "dust", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "init",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "rad", "type": "uint256"},
            ],
            "name": "move",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "nope",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "sin",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "int256", "name": "wad", "type": "int256"},
            ],
            "name": "slip",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "u", "type": "address"},
                {"internalType": "address", "name": "v", "type": "address"},
                {"internalType": "uint256", "name": "rad", "type": "uint256"},
            ],
            "name": "suck",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "urns",
            "outputs": [
                {"internalType": "uint256", "name": "ink", "type": "uint256"},
                {"internalType": "uint256", "name": "art", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vice",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "amt",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "done",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gem", "type": "address"},
                {"internalType": "address[]", "name": "addrs", "type": "address[]"},
            ],
            "name": "gulp",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "gem", "type": "address"}],
            "name": "gulp",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "hope",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "list",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "nope",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gem", "type": "address"},
                {"internalType": "uint256", "name": "amt_", "type": "uint256"},
            ],
            "name": "setAmt",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "contract ERC20Like", "name": "gem", "type": "address"}
            ],
            "name": "shut",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "address", "name": "gem", "type": "address"},
            ],
            "name": "undo",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "apt", "type": "address"},
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "daiJoin_join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "address", "name": "pot", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "address", "name": "pot", "type": "address"},
            ],
            "name": "exitAll",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "address", "name": "pot", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "pot_", "type": "address"},
                {"internalType": "address", "name": "daiJoin_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Exit",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Join",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dai",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "daiBalance",
            "outputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "daiJoin",
            "outputs": [
                {"internalType": "contract JoinLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "dst", "type": "address"}],
            "name": "exitAll",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "pieOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "pot",
            "outputs": [
                {"internalType": "contract PotLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "supply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "creator",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "token",
                    "type": "address",
                },
            ],
            "name": "LogMake",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "make",
            "outputs": [
                {"internalType": "contract WETH9_", "name": "result", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "amt",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "done",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gem", "type": "address"},
                {"internalType": "address[]", "name": "addrs", "type": "address[]"},
            ],
            "name": "gulp",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "gem", "type": "address"}],
            "name": "gulp",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gem", "type": "address"},
                {"internalType": "uint256", "name": "amt_", "type": "uint256"},
            ],
            "name": "setAmt",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "contract ERC20Like", "name": "gem", "type": "address"}
            ],
            "name": "shut",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract DSChief",
                    "name": "chief_",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSToken",
                    "name": "token",
                    "type": "address",
                },
                {"internalType": "address", "name": "recipient", "type": "address"},
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address[]", "name": "guys", "type": "address[]"}
            ],
            "name": "etch",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "amt", "type": "uint256"}],
            "name": "free",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "candidate", "type": "address"}
            ],
            "name": "lift",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "amt", "type": "uint256"}],
            "name": "lock",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "amt", "type": "uint256"}],
            "name": "tryFree",
            "outputs": [{"internalType": "bool", "name": "ok", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "id", "type": "bytes32"}],
            "name": "vote",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address[]", "name": "guys", "type": "address[]"}
            ],
            "name": "vote",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "contract DSToken", "name": "GOV_", "type": "address"},
                {"internalType": "contract DSToken", "name": "IOU_", "type": "address"},
                {"internalType": "uint256", "name": "MAX_YAYS_", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "slate",
                    "type": "bytes32",
                }
            ],
            "name": "Etch",
            "type": "event",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "foo",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "bar",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "fax",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "GOV",
            "outputs": [
                {"internalType": "contract DSToken", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "IOU",
            "outputs": [
                {"internalType": "contract DSToken", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "MAX_YAYS",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "approvals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "deposits",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address[]", "name": "yays", "type": "address[]"}
            ],
            "name": "etch",
            "outputs": [
                {"internalType": "bytes32", "name": "slate", "type": "bytes32"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "free",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "hat",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "whom", "type": "address"}],
            "name": "lift",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "lock",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "name": "slates",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "slate", "type": "bytes32"}],
            "name": "vote",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address[]", "name": "yays", "type": "address[]"}
            ],
            "name": "vote",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "votes",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract VoteProxyFactory",
                    "name": "voteProxyFactory_",
                    "type": "address",
                }
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "cold", "type": "address"}],
            "name": "doApproveLink",
            "outputs": [
                {"internalType": "contract VoteProxy", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "doBreakLink",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "hot", "type": "address"}],
            "name": "doInitiateLink",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "doLinkSelf",
            "outputs": [
                {"internalType": "contract VoteProxy", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "_proxy", "type": "address"},
                {
                    "internalType": "contract DSToken",
                    "name": "_token",
                    "type": "address",
                },
            ],
            "name": "proxyApprove",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract VoteProxy",
                    "name": "_proxy",
                    "type": "address",
                },
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "proxyFree",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract VoteProxy",
                    "name": "_proxy",
                    "type": "address",
                },
                {"internalType": "uint256", "name": "amount", "type": "uint256"},
            ],
            "name": "proxyLock",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "tryBreakLink",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "contract WETH9", "name": "_weth", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {"payable": True, "stateMutability": "payable", "type": "fallback"},
        {
            "constant": False,
            "inputs": [
                {"internalType": "contract Guy", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "join",
            "outputs": [],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "contract Guy", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "contract Guy", "name": "src", "type": "address"},
                {"internalType": "contract Guy", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "vat", "type": "address"},
                {"internalType": "address", "name": "flap", "type": "address"},
                {"internalType": "address", "name": "flop", "type": "address"},
            ],
            "name": "newVow",
            "outputs": [
                {"internalType": "contract Vow", "name": "vow", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "contract OsmMom", "name": "mom_", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "newAuthority", "type": "address"}
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "osm", "type": "address"},
            ],
            "name": "setOsm",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "newOwner", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "stop",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "vat", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        }
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "token", "type": "address"}],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "address", "name": "token", "type": "address"}],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [],
            "name": "newEnd",
            "outputs": [
                {"internalType": "contract End", "name": "end", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "cat_", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "flip",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
            ],
            "name": "Deny",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "flip",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
            ],
            "name": "Rely",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "oldAuthority",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "newAuthority",
                    "type": "address",
                },
            ],
            "name": "SetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "oldDelay",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "newDelay",
                    "type": "uint256",
                },
            ],
            "name": "SetDelay",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "oldOwner",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "newOwner",
                    "type": "address",
                },
            ],
            "name": "SetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cat",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "delay",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "flip", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "flip", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "authority_", "type": "address"}
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "delay_", "type": "uint256"}
            ],
            "name": "setDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "vat_", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "ilk",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "val",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "spot",
                    "type": "uint256",
                },
            ],
            "name": "Poke",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "pip_", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "ilks",
            "outputs": [
                {"internalType": "contract PipLike", "name": "pip", "type": "address"},
                {"internalType": "uint256", "name": "mat", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "par",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "poke",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "vat_", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "ilk",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "urn",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "ink",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "art",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "tab",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "flip",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "id",
                    "type": "uint256",
                },
            ],
            "name": "Bite",
            "type": "event",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "urn", "type": "address"},
            ],
            "name": "bite",
            "outputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "box",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "rad", "type": "uint256"}],
            "name": "claw",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "flip", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "ilks",
            "outputs": [
                {"internalType": "address", "name": "flip", "type": "address"},
                {"internalType": "uint256", "name": "chop", "type": "uint256"},
                {"internalType": "uint256", "name": "dunk", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "litter",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vow",
            "outputs": [
                {"internalType": "contract VowLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "bytes", "name": "fax", "type": "bytes"},
            ],
            "name": "exec",
            "outputs": [{"internalType": "bytes", "name": "out", "type": "bytes"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "vat", "type": "address"}],
            "name": "newPot",
            "outputs": [
                {"internalType": "contract Pot", "name": "pot", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "address", "name": "cat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "id",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "lot",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "bid",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "tab",
                    "type": "uint256",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "gal",
                    "type": "address",
                },
            ],
            "name": "Kick",
            "type": "event",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "beg",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "name": "bids",
            "outputs": [
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint48", "name": "tic", "type": "uint48"},
                {"internalType": "uint48", "name": "end", "type": "uint48"},
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "address", "name": "gal", "type": "address"},
                {"internalType": "uint256", "name": "tab", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cat",
            "outputs": [
                {"internalType": "contract CatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "deal",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "id", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
            ],
            "name": "dent",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "address", "name": "gal", "type": "address"},
                {"internalType": "uint256", "name": "tab", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
            ],
            "name": "kick",
            "outputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "kicks",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "tau",
            "outputs": [{"internalType": "uint48", "name": "", "type": "uint48"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "id", "type": "uint256"},
                {"internalType": "uint256", "name": "lot", "type": "uint256"},
                {"internalType": "uint256", "name": "bid", "type": "uint256"},
            ],
            "name": "tend",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "tick",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ttl",
            "outputs": [{"internalType": "uint48", "name": "", "type": "uint48"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
            "name": "yank",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {
                    "internalType": "contract DSToken",
                    "name": "token_",
                    "type": "address",
                },
                {
                    "internalType": "contract RestrictedTokenFaucet",
                    "name": "faucet_",
                    "type": "address",
                },
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "doGulp",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "doHope",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "doNope",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "tok", "type": "address"},
                {"internalType": "uint256", "name": "amt", "type": "uint256"},
            ],
            "name": "doSetAmt",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "doShut",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "doUndo",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "ilks",
            "outputs": [
                {"internalType": "contract PipLike", "name": "pip", "type": "address"},
                {"internalType": "uint256", "name": "mat", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "par",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
                {"internalType": "uint256", "name": "decimals", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "src_", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "bytes32",
                    "name": "val",
                    "type": "bytes32",
                }
            ],
            "name": "LogValue",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "bud",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "src_", "type": "address"}],
            "name": "change",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address[]", "name": "a", "type": "address[]"}],
            "name": "diss",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "a", "type": "address"}],
            "name": "diss",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "hop",
            "outputs": [{"internalType": "uint16", "name": "", "type": "uint16"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address[]", "name": "a", "type": "address[]"}],
            "name": "kiss",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "a", "type": "address"}],
            "name": "kiss",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "pass",
            "outputs": [{"internalType": "bool", "name": "ok", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "peek",
            "outputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "bool", "name": "", "type": "bool"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "peep",
            "outputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "bool", "name": "", "type": "bool"},
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "poke",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "read",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "src",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "start",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint16", "name": "ts", "type": "uint16"}],
            "name": "step",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "stop",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "stopped",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "void",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "zzz",
            "outputs": [{"internalType": "uint64", "name": "", "type": "uint64"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "chainId", "type": "uint256"}
            ],
            "name": "newDai",
            "outputs": [
                {"internalType": "contract Dai", "name": "dai", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "implementations",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "address",
                    "name": "implementation",
                    "type": "address",
                },
                {"internalType": "uint256", "name": "permitted", "type": "uint256"},
            ],
            "name": "setImplementation",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "delay", "type": "uint256"},
                {"internalType": "address", "name": "owner", "type": "address"},
                {"internalType": "address", "name": "authority", "type": "address"},
            ],
            "name": "newPause",
            "outputs": [
                {"internalType": "contract DSPause", "name": "pause", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [{"internalType": "address", "name": "vat_", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "Pie",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "chi",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "drip",
            "outputs": [{"internalType": "uint256", "name": "tmp", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dsr",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "addr", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "pie",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "rho",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vow",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "_initialSupply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "spender",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "value",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": False,
                    "internalType": "address",
                    "name": "newAddress",
                    "type": "address",
                }
            ],
            "name": "Deprecate",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "from",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "to",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "value",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "MAX_UINT",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "_owner", "type": "address"},
                {"internalType": "address", "name": "_spender", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [
                {"internalType": "uint256", "name": "remaining", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "allowed",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "_spender", "type": "address"},
                {"internalType": "uint256", "name": "_value", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "_owner", "type": "address"}
            ],
            "name": "balanceOf",
            "outputs": [
                {"internalType": "uint256", "name": "balance", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "balances",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "basisPointsRate",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_basisPointsRate",
                    "type": "uint256",
                },
                {"internalType": "uint256", "name": "_maximumFee", "type": "uint256"},
            ],
            "name": "changeFees",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_upgradedAddress",
                    "type": "address",
                }
            ],
            "name": "deprecate",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "deprecated",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "maximumFee",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "_to", "type": "address"},
                {"internalType": "uint256", "name": "_value", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "_from", "type": "address"},
                {"internalType": "address", "name": "_to", "type": "address"},
                {"internalType": "uint256", "name": "_value", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "upgradedAddress",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "uint256", "name": "amount", "type": "uint256"}
            ],
            "name": "withdraw",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "constant": True,
            "inputs": [],
            "name": "fail",
            "outputs": [],
            "payable": False,
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "get48Bytes",
            "outputs": [{"internalType": "bytes", "name": "result", "type": "bytes"}],
            "payable": False,
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "getBytes32",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "getBytes32AndUint",
            "outputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "uint256", "name": "amount", "type": "uint256"}
            ],
            "name": "getMultipleValues",
            "outputs": [
                {"internalType": "bytes32[]", "name": "result", "type": "bytes32[]"}
            ],
            "payable": False,
            "stateMutability": "pure",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "implementations",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "address",
                    "name": "implementation",
                    "type": "address",
                },
                {"internalType": "uint256", "name": "permitted", "type": "uint256"},
            ],
            "name": "setImplementation",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "erc20Impl",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "address",
                    "name": "newImplementation",
                    "type": "address",
                }
            ],
            "name": "setImplementation",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "gem_", "type": "address"},
                {"internalType": "address", "name": "end_", "type": "address"},
                {"internalType": "address", "name": "pit_", "type": "address"},
                {"internalType": "uint256", "name": "min_", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "Sum",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "end",
            "outputs": [
                {"internalType": "contract EndLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "fire",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "fired",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "min",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "pit",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "sum",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "_cacheAddr", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "foo",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "bar",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "fax",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {"payable": True, "stateMutability": "payable", "type": "fallback"},
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cache",
            "outputs": [
                {"internalType": "contract DSProxyCache", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "_target", "type": "address"},
                {"internalType": "bytes", "name": "_data", "type": "bytes"},
            ],
            "name": "execute",
            "outputs": [{"internalType": "bytes", "name": "response", "type": "bytes"}],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes", "name": "_code", "type": "bytes"},
                {"internalType": "bytes", "name": "_data", "type": "bytes"},
            ],
            "name": "execute",
            "outputs": [
                {"internalType": "address", "name": "target", "type": "address"},
                {"internalType": "bytes", "name": "response", "type": "bytes"},
            ],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "_cacheAddr", "type": "address"}
            ],
            "name": "setCache",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "actions", "type": "address"},
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "dripAndFile",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "actions", "type": "address"},
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "dripAndFile",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "actions", "type": "address"},
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "actions", "type": "address"},
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "actions", "type": "address"},
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "actions", "type": "address"},
                {"internalType": "address", "name": "who", "type": "address"},
                {"internalType": "address", "name": "to", "type": "address"},
            ],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "pause", "type": "address"},
                {"internalType": "address", "name": "actions", "type": "address"},
                {"internalType": "address", "name": "newAuthority", "type": "address"},
                {"internalType": "uint256", "name": "newDelay", "type": "uint256"},
            ],
            "name": "setAuthorityAndDelay",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "bags",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "make",
            "outputs": [{"internalType": "address", "name": "bag", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "make",
            "outputs": [{"internalType": "address", "name": "bag", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Burn",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "authority",
                    "type": "address",
                }
            ],
            "name": "LogSetAuthority",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "owner",
                    "type": "address",
                }
            ],
            "name": "LogSetOwner",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Mint",
            "type": "event",
        },
        {"anonymous": False, "inputs": [], "name": "Start", "type": "event"},
        {"anonymous": False, "inputs": [], "name": "Stop", "type": "event"},
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "", "type": "address"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "authority",
            "outputs": [
                {"internalType": "contract DSAuthority", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "burn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "burn",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "mint",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "mint",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "move",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "owner",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "pull",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "push",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {
                    "internalType": "contract DSAuthority",
                    "name": "authority_",
                    "type": "address",
                }
            ],
            "name": "setAuthority",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "name_", "type": "bytes32"}],
            "name": "setName",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "owner_", "type": "address"}
            ],
            "name": "setOwner",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "start",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "stop",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "stopped",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "vat_", "type": "address"},
                {"internalType": "bytes32", "name": "ilk_", "type": "bytes32"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "dec",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ilk",
            "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "usr", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "contract DSToken", "name": "gov", "type": "address"},
                {"internalType": "uint256", "name": "MAX_YAYS", "type": "uint256"},
            ],
            "name": "newChief",
            "outputs": [
                {"internalType": "contract DSChief", "name": "chief", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        }
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": True,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "bytes4",
                    "name": "sig",
                    "type": "bytes4",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "usr",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg1",
                    "type": "bytes32",
                },
                {
                    "indexed": True,
                    "internalType": "bytes32",
                    "name": "arg2",
                    "type": "bytes32",
                },
                {
                    "indexed": False,
                    "internalType": "bytes",
                    "name": "data",
                    "type": "bytes",
                },
            ],
            "name": "LogNote",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "Art",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "bag",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "cage",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "cash",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "cat",
            "outputs": [
                {"internalType": "contract CatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "debt",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "deny",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "uint256", "name": "data", "type": "uint256"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "what", "type": "bytes32"},
                {"internalType": "address", "name": "data", "type": "address"},
            ],
            "name": "file",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "fix",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "flow",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "bytes32", "name": "ilk", "type": "bytes32"}],
            "name": "free",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "gap",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "live",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "bytes32", "name": "", "type": "bytes32"},
                {"internalType": "address", "name": "", "type": "address"},
            ],
            "name": "out",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "uint256", "name": "wad", "type": "uint256"}],
            "name": "pack",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "pot",
            "outputs": [
                {"internalType": "contract PotLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [{"internalType": "address", "name": "guy", "type": "address"}],
            "name": "rely",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "urn", "type": "address"},
            ],
            "name": "skim",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "uint256", "name": "id", "type": "uint256"},
            ],
            "name": "skip",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "spot",
            "outputs": [
                {"internalType": "contract Spotty", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
            "name": "tag",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [],
            "name": "thaw",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vat",
            "outputs": [
                {"internalType": "contract VatLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "vow",
            "outputs": [
                {"internalType": "contract VowLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "wait",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "", "type": "address"}],
            "name": "wards",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "when",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "uint256", "name": "supply", "type": "uint256"}
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "guy",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Approval",
            "type": "event",
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "src",
                    "type": "address",
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "dst",
                    "type": "address",
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "wad",
                    "type": "uint256",
                },
            ],
            "name": "Transfer",
            "type": "event",
        },
        {
            "constant": True,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "guy", "type": "address"},
            ],
            "name": "allowance",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "guy", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "approve",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [{"internalType": "address", "name": "src", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "decimals",
            "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "name",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "symbol",
            "outputs": [{"internalType": "string", "name": "", "type": "string"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "transferFrom",
            "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "ok", "type": "uint256"},
            ],
            "name": "cdpAllow",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "apt", "type": "address"},
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "daiJoin_join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "jug", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "draw",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "src", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
            ],
            "name": "enter",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "apt", "type": "address"},
                {"internalType": "address", "name": "urn", "type": "address"},
            ],
            "name": "ethJoin_join",
            "outputs": [],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exitETH",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "amt", "type": "uint256"},
            ],
            "name": "exitGem",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "flux",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "freeETH",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "amt", "type": "uint256"},
            ],
            "name": "freeGem",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "int256", "name": "dink", "type": "int256"},
                {"internalType": "int256", "name": "dart", "type": "int256"},
            ],
            "name": "frob",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "apt", "type": "address"},
                {"internalType": "address", "name": "urn", "type": "address"},
                {"internalType": "uint256", "name": "amt", "type": "uint256"},
                {"internalType": "bool", "name": "transferFrom", "type": "bool"},
            ],
            "name": "gemJoin_join",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "usr", "type": "address"},
            ],
            "name": "give",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "proxyRegistry", "type": "address"},
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
            ],
            "name": "giveToProxy",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "obj", "type": "address"},
                {"internalType": "address", "name": "usr", "type": "address"},
            ],
            "name": "hope",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
            ],
            "name": "lockETH",
            "outputs": [],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "jug", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "wadD", "type": "uint256"},
            ],
            "name": "lockETHAndDraw",
            "outputs": [],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "amt", "type": "uint256"},
                {"internalType": "bool", "name": "transferFrom", "type": "bool"},
            ],
            "name": "lockGem",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "jug", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "amtC", "type": "uint256"},
                {"internalType": "uint256", "name": "wadD", "type": "uint256"},
                {"internalType": "bool", "name": "transferFrom", "type": "bool"},
            ],
            "name": "lockGemAndDraw",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gemJoin", "type": "address"}
            ],
            "name": "makeGemBag",
            "outputs": [{"internalType": "address", "name": "bag", "type": "address"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "rad", "type": "uint256"},
            ],
            "name": "move",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "obj", "type": "address"},
                {"internalType": "address", "name": "usr", "type": "address"},
            ],
            "name": "nope",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "address", "name": "usr", "type": "address"},
            ],
            "name": "open",
            "outputs": [{"internalType": "uint256", "name": "cdp", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "jug", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "uint256", "name": "wadD", "type": "uint256"},
            ],
            "name": "openLockETHAndDraw",
            "outputs": [{"internalType": "uint256", "name": "cdp", "type": "uint256"}],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "jug", "type": "address"},
                {"internalType": "address", "name": "gntJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "uint256", "name": "amtC", "type": "uint256"},
                {"internalType": "uint256", "name": "wadD", "type": "uint256"},
            ],
            "name": "openLockGNTAndDraw",
            "outputs": [
                {"internalType": "address", "name": "bag", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "jug", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "bytes32", "name": "ilk", "type": "bytes32"},
                {"internalType": "uint256", "name": "amtC", "type": "uint256"},
                {"internalType": "uint256", "name": "wadD", "type": "uint256"},
                {"internalType": "bool", "name": "transferFrom", "type": "bool"},
            ],
            "name": "openLockGemAndDraw",
            "outputs": [{"internalType": "uint256", "name": "cdp", "type": "uint256"}],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "dst", "type": "address"},
            ],
            "name": "quit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "owner", "type": "address"},
            ],
            "name": "safeLockETH",
            "outputs": [],
            "payable": True,
            "stateMutability": "payable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "amt", "type": "uint256"},
                {"internalType": "bool", "name": "transferFrom", "type": "bool"},
                {"internalType": "address", "name": "owner", "type": "address"},
            ],
            "name": "safeLockGem",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
                {"internalType": "address", "name": "owner", "type": "address"},
            ],
            "name": "safeWipe",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "address", "name": "owner", "type": "address"},
            ],
            "name": "safeWipeAll",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "uint256", "name": "cdpSrc", "type": "uint256"},
                {"internalType": "uint256", "name": "cdpOrg", "type": "uint256"},
            ],
            "name": "shift",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "gem", "type": "address"},
                {"internalType": "address", "name": "dst", "type": "address"},
                {"internalType": "uint256", "name": "amt", "type": "uint256"},
            ],
            "name": "transfer",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "ok", "type": "uint256"},
            ],
            "name": "urnAllow",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "wipe",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
            ],
            "name": "wipeAll",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "wadC", "type": "uint256"},
            ],
            "name": "wipeAllAndFreeETH",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "amtC", "type": "uint256"},
            ],
            "name": "wipeAllAndFreeGem",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "ethJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "wadC", "type": "uint256"},
                {"internalType": "uint256", "name": "wadD", "type": "uint256"},
            ],
            "name": "wipeAndFreeETH",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "manager", "type": "address"},
                {"internalType": "address", "name": "gemJoin", "type": "address"},
                {"internalType": "address", "name": "daiJoin", "type": "address"},
                {"internalType": "uint256", "name": "cdp", "type": "uint256"},
                {"internalType": "uint256", "name": "amtC", "type": "uint256"},
                {"internalType": "uint256", "name": "wadD", "type": "uint256"},
            ],
            "name": "wipeAndFreeGem",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
    ],
    [
        {
            "inputs": [
                {"internalType": "address", "name": "lad_", "type": "address"},
                {"internalType": "address", "name": "gem_", "type": "address"},
            ],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "constructor",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "ada",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": False,
            "inputs": [
                {"internalType": "address", "name": "usr", "type": "address"},
                {"internalType": "uint256", "name": "wad", "type": "uint256"},
            ],
            "name": "exit",
            "outputs": [],
            "payable": False,
            "stateMutability": "nonpayable",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "gem",
            "outputs": [
                {"internalType": "contract GemLike", "name": "", "type": "address"}
            ],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
        {
            "constant": True,
            "inputs": [],
            "name": "lad",
            "outputs": [{"internalType": "address", "name": "", "type": "address"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function",
        },
    ],
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/open_zeppelin.py ---
open_zeppelin_admin_upgradeability_proxy = [
    {
        "inputs": [
            {"internalType": "address", "name": "_logic", "type": "address"},
            {"internalType": "address", "name": "_admin", "type": "address"},
            {"internalType": "bytes", "name": "_data", "type": "bytes"},
        ],
        "payable": True,
        "stateMutability": "payable",
        "type": "constructor",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "previousAdmin",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "newAdmin",
                "type": "address",
            },
        ],
        "name": "AdminChanged",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "implementation",
                "type": "address",
            }
        ],
        "name": "Upgraded",
        "type": "event",
    },
    {"payable": True, "stateMutability": "payable", "type": "fallback"},
    {
        "constant": False,
        "inputs": [],
        "name": "admin",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newAdmin", "type": "address"}],
        "name": "changeAdmin",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "implementation",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "newImplementation", "type": "address"}
        ],
        "name": "upgradeTo",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "newImplementation", "type": "address"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
        ],
        "name": "upgradeToAndCall",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
]

open_zeppelin_proxy_admin = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "previousOwner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newOwner",
                "type": "address",
            },
        ],
        "name": "OwnershipTransferred",
        "type": "event",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract AdminUpgradeabilityProxy",
                "name": "proxy",
                "type": "address",
            },
            {"internalType": "address", "name": "newAdmin", "type": "address"},
        ],
        "name": "changeProxyAdmin",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {
                "internalType": "contract AdminUpgradeabilityProxy",
                "name": "proxy",
                "type": "address",
            }
        ],
        "name": "getProxyAdmin",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {
                "internalType": "contract AdminUpgradeabilityProxy",
                "name": "proxy",
                "type": "address",
            }
        ],
        "name": "getProxyImplementation",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isOwner",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "owner",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}],
        "name": "transferOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract AdminUpgradeabilityProxy",
                "name": "proxy",
                "type": "address",
            },
            {"internalType": "address", "name": "implementation", "type": "address"},
        ],
        "name": "upgrade",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "contract AdminUpgradeabilityProxy",
                "name": "proxy",
                "type": "address",
            },
            {"internalType": "address", "name": "implementation", "type": "address"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
        ],
        "name": "upgradeAndCall",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/request.py ---
request_erc20_proxy = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "tokenAddress",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "bytes",
                "name": "paymentReference",
                "type": "bytes",
            },
        ],
        "name": "TransferWithReference",
        "type": "event",
    },
    {"payable": True, "stateMutability": "payable", "type": "fallback"},
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_tokenAddress", "type": "address"},
            {"internalType": "address", "name": "_to", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "bytes", "name": "_paymentReference", "type": "bytes"},
        ],
        "name": "transferFromWithReference",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
]
request_erc20_swap_to_pay = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_swapRouterAddress",
                "type": "address",
            },
            {
                "internalType": "address",
                "name": "_paymentProxyAddress",
                "type": "address",
            },
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "previousOwner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newOwner",
                "type": "address",
            },
        ],
        "name": "OwnershipTransferred",
        "type": "event",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_erc20Address", "type": "address"}
        ],
        "name": "approvePaymentProxyToSpend",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_erc20Address", "type": "address"}
        ],
        "name": "approveRouterToSpend",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "owner",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "paymentProxy",
        "outputs": [
            {"internalType": "contract IERC20FeeProxy", "name": "", "type": "address"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "address",
                "name": "_paymentProxyAddress",
                "type": "address",
            }
        ],
        "name": "setPaymentProxy",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {
                "internalType": "address",
                "name": "_newSwapRouterAddress",
                "type": "address",
            }
        ],
        "name": "setRouter",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "swapRouter",
        "outputs": [
            {
                "internalType": "contract IUniswapV2Router02",
                "name": "",
                "type": "address",
            }
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "_to", "type": "address"},
            {"internalType": "uint256", "name": "_amount", "type": "uint256"},
            {"internalType": "uint256", "name": "_amountInMax", "type": "uint256"},
            {"internalType": "address[]", "name": "_path", "type": "address[]"},
            {"internalType": "bytes", "name": "_paymentReference", "type": "bytes"},
            {"internalType": "uint256", "name": "_feeAmount", "type": "uint256"},
            {"internalType": "address", "name": "_feeAddress", "type": "address"},
            {"internalType": "uint256", "name": "_deadline", "type": "uint256"},
        ],
        "name": "swapTransferWithReference",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}],
        "name": "transferOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
]
request_ethereum_proxy = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "bytes",
                "name": "paymentReference",
                "type": "bytes",
            },
        ],
        "name": "TransferWithReference",
        "type": "event",
    },
    {"payable": True, "stateMutability": "payable", "type": "fallback"},
    {
        "constant": False,
        "inputs": [
            {"internalType": "address payable", "name": "_to", "type": "address"},
            {"internalType": "bytes", "name": "_paymentReference", "type": "bytes"},
        ],
        "name": "transferWithReference",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/sablier.py ---
sablier_ctoken_manager = [
    {
        "constant": True,
        "inputs": [],
        "name": "owner",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isOwner",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "sender", "type": "address"}],
        "name": "initialize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}],
        "name": "transferOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "previousOwner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newOwner",
                "type": "address",
            },
        ],
        "name": "OwnershipTransferred",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "tokenAddress",
                "type": "address",
            }
        ],
        "name": "DiscardCToken",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "tokenAddress",
                "type": "address",
            }
        ],
        "name": "WhitelistCToken",
        "type": "event",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "tokenAddress", "type": "address"}
        ],
        "name": "whitelistCToken",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "tokenAddress", "type": "address"}
        ],
        "name": "discardCToken",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "tokenAddress", "type": "address"}
        ],
        "name": "isCToken",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
]
sablier_payroll = [
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "", "type": "address"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "name": "relayers",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "sablier",
        "outputs": [
            {"internalType": "contract Sablier", "name": "", "type": "address"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "getHubAddr",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "bytes", "name": "context", "type": "bytes"}],
        "name": "preRelayedCall",
        "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "owner",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isOwner",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "relayHubVersion",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "nextSalaryId",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "bytes", "name": "context", "type": "bytes"},
            {"internalType": "bool", "name": "success", "type": "bool"},
            {"internalType": "uint256", "name": "actualCharge", "type": "uint256"},
            {"internalType": "bytes32", "name": "preRetVal", "type": "bytes32"},
        ],
        "name": "postRelayedCall",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}],
        "name": "transferOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "salaryId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "streamId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "company",
                "type": "address",
            },
        ],
        "name": "CreateSalary",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "salaryId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "streamId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "company",
                "type": "address",
            },
        ],
        "name": "WithdrawFromSalary",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "salaryId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "streamId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "company",
                "type": "address",
            },
        ],
        "name": "CancelSalary",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "oldRelayHub",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newRelayHub",
                "type": "address",
            },
        ],
        "name": "RelayHubChanged",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "previousOwner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newOwner",
                "type": "address",
            },
        ],
        "name": "OwnershipTransferred",
        "type": "event",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "trustedSigner", "type": "address"}
        ],
        "name": "initialize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "ownerAddress", "type": "address"},
            {"internalType": "address", "name": "signerAddress", "type": "address"},
            {"internalType": "address", "name": "sablierAddress", "type": "address"},
        ],
        "name": "initialize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "initialize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "relayer", "type": "address"},
            {"internalType": "uint256", "name": "salaryId", "type": "uint256"},
        ],
        "name": "whitelistRelayer",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "relayer", "type": "address"},
            {"internalType": "uint256", "name": "salaryId", "type": "uint256"},
        ],
        "name": "discardRelayer",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "relay", "type": "address"},
            {"internalType": "address", "name": "from", "type": "address"},
            {"internalType": "bytes", "name": "encodedFunction", "type": "bytes"},
            {"internalType": "uint256", "name": "transactionFee", "type": "uint256"},
            {"internalType": "uint256", "name": "gasPrice", "type": "uint256"},
            {"internalType": "uint256", "name": "gasLimit", "type": "uint256"},
            {"internalType": "uint256", "name": "nonce", "type": "uint256"},
            {"internalType": "bytes", "name": "approvalData", "type": "bytes"},
            {"internalType": "uint256", "name": "", "type": "uint256"},
        ],
        "name": "acceptRelayedCall",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "bytes", "name": "", "type": "bytes"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "salaryId", "type": "uint256"}],
        "name": "getSalary",
        "outputs": [
            {"internalType": "address", "name": "company", "type": "address"},
            {"internalType": "address", "name": "employee", "type": "address"},
            {"internalType": "uint256", "name": "salary", "type": "uint256"},
            {"internalType": "address", "name": "tokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "startTime", "type": "uint256"},
            {"internalType": "uint256", "name": "stopTime", "type": "uint256"},
            {"internalType": "uint256", "name": "remainingBalance", "type": "uint256"},
            {"internalType": "uint256", "name": "rate", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "employee", "type": "address"},
            {"internalType": "uint256", "name": "salary", "type": "uint256"},
            {"internalType": "address", "name": "tokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "startTime", "type": "uint256"},
            {"internalType": "uint256", "name": "stopTime", "type": "uint256"},
        ],
        "name": "createSalary",
        "outputs": [{"internalType": "uint256", "name": "salaryId", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "employee", "type": "address"},
            {"internalType": "uint256", "name": "salary", "type": "uint256"},
            {"internalType": "address", "name": "tokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "startTime", "type": "uint256"},
            {"internalType": "uint256", "name": "stopTime", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "senderSharePercentage",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "recipientSharePercentage",
                "type": "uint256",
            },
        ],
        "name": "createCompoundingSalary",
        "outputs": [{"internalType": "uint256", "name": "salaryId", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "salaryId", "type": "uint256"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "withdrawFromSalary",
        "outputs": [{"internalType": "bool", "name": "success", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "uint256", "name": "salaryId", "type": "uint256"}],
        "name": "cancelSalary",
        "outputs": [{"internalType": "bool", "name": "success", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
]
sablier_abi = [
    {
        "constant": True,
        "inputs": [],
        "name": "nextStreamId",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "unpause",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "isPauser",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "paused",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "initialize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "addPauser",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [],
        "name": "pause",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "owner",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "isOwner",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "sender", "type": "address"}],
        "name": "initialize",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "cTokenManager",
        "outputs": [
            {"internalType": "contract ICTokenManager", "name": "", "type": "address"}
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "fee",
        "outputs": [{"internalType": "uint256", "name": "mantissa", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "address", "name": "newOwner", "type": "address"}],
        "name": "transferOwnership",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "cTokenManagerAddress",
                "type": "address",
            }
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "streamId",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "exchangeRate",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "senderSharePercentage",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "recipientSharePercentage",
                "type": "uint256",
            },
        ],
        "name": "CreateCompoundingStream",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "streamId",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "senderInterest",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "recipientInterest",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "sablierInterest",
                "type": "uint256",
            },
        ],
        "name": "PayInterest",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "tokenAddress",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256",
            },
        ],
        "name": "TakeEarnings",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "fee",
                "type": "uint256",
            }
        ],
        "name": "UpdateFee",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "account",
                "type": "address",
            }
        ],
        "name": "Paused",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "account",
                "type": "address",
            }
        ],
        "name": "Unpaused",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "account",
                "type": "address",
            }
        ],
        "name": "PauserAdded",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "account",
                "type": "address",
            }
        ],
        "name": "PauserRemoved",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "previousOwner",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "newOwner",
                "type": "address",
            },
        ],
        "name": "OwnershipTransferred",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "streamId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "sender",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "recipient",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "deposit",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "tokenAddress",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "startTime",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "stopTime",
                "type": "uint256",
            },
        ],
        "name": "CreateStream",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "streamId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "recipient",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256",
            },
        ],
        "name": "WithdrawFromStream",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "uint256",
                "name": "streamId",
                "type": "uint256",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "sender",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "recipient",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "senderBalance",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "recipientBalance",
                "type": "uint256",
            },
        ],
        "name": "CancelStream",
        "type": "event",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "feePercentage", "type": "uint256"}
        ],
        "name": "updateFee",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "tokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "takeEarnings",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "streamId", "type": "uint256"}],
        "name": "getStream",
        "outputs": [
            {"internalType": "address", "name": "sender", "type": "address"},
            {"internalType": "address", "name": "recipient", "type": "address"},
            {"internalType": "uint256", "name": "deposit", "type": "uint256"},
            {"internalType": "address", "name": "tokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "startTime", "type": "uint256"},
            {"internalType": "uint256", "name": "stopTime", "type": "uint256"},
            {"internalType": "uint256", "name": "remainingBalance", "type": "uint256"},
            {"internalType": "uint256", "name": "ratePerSecond", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "streamId", "type": "uint256"}],
        "name": "deltaOf",
        "outputs": [{"internalType": "uint256", "name": "delta", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "uint256", "name": "streamId", "type": "uint256"},
            {"internalType": "address", "name": "who", "type": "address"},
        ],
        "name": "balanceOf",
        "outputs": [{"internalType": "uint256", "name": "balance", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "streamId", "type": "uint256"}],
        "name": "isCompoundingStream",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"internalType": "uint256", "name": "streamId", "type": "uint256"}],
        "name": "getCompoundingStream",
        "outputs": [
            {"internalType": "address", "name": "sender", "type": "address"},
            {"internalType": "address", "name": "recipient", "type": "address"},
            {"internalType": "uint256", "name": "deposit", "type": "uint256"},
            {"internalType": "address", "name": "tokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "startTime", "type": "uint256"},
            {"internalType": "uint256", "name": "stopTime", "type": "uint256"},
            {"internalType": "uint256", "name": "remainingBalance", "type": "uint256"},
            {"internalType": "uint256", "name": "ratePerSecond", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "exchangeRateInitial",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "senderSharePercentage",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "recipientSharePercentage",
                "type": "uint256",
            },
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "streamId", "type": "uint256"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "interestOf",
        "outputs": [
            {"internalType": "uint256", "name": "senderInterest", "type": "uint256"},
            {"internalType": "uint256", "name": "recipientInterest", "type": "uint256"},
            {"internalType": "uint256", "name": "sablierInterest", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"internalType": "address", "name": "tokenAddress", "type": "address"}
        ],
        "name": "getEarnings",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "recipient", "type": "address"},
            {"internalType": "uint256", "name": "deposit", "type": "uint256"},
            {"internalType": "address", "name": "tokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "startTime", "type": "uint256"},
            {"internalType": "uint256", "name": "stopTime", "type": "uint256"},
        ],
        "name": "createStream",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "address", "name": "recipient", "type": "address"},
            {"internalType": "uint256", "name": "deposit", "type": "uint256"},
            {"internalType": "address", "name": "tokenAddress", "type": "address"},
            {"internalType": "uint256", "name": "startTime", "type": "uint256"},
            {"internalType": "uint256", "name": "stopTime", "type": "uint256"},
            {
                "internalType": "uint256",
                "name": "senderSharePercentage",
                "type": "uint256",
            },
            {
                "internalType": "uint256",
                "name": "recipientSharePercentage",
                "type": "uint256",
            },
        ],
        "name": "createCompoundingStream",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"internalType": "uint256", "name": "streamId", "type": "uint256"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"},
        ],
        "name": "withdrawFromStream",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"internalType": "uint256", "name": "streamId", "type": "uint256"}],
        "name": "cancelStream",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/sight.py ---
# flake8: noqa E501
import json

conditional_token_abi = json.loads(
    '[{"constant":true,"inputs":[{"name":"owner","type":"address"},{"name":"id","type":"uint256"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes32"},{"name":"","type":"uint256"}],"name":"payoutNumerators","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"ids","type":"uint256[]"},{"name":"values","type":"uint256[]"},{"name":"data","type":"bytes"}],"name":"safeBatchTransferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"owners","type":"address[]"},{"name":"ids","type":"uint256[]"}],"name":"balanceOfBatch","outputs":[{"name":"","type":"uint256[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"operator","type":"address"},{"name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes32"}],"name":"payoutDenominator","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"owner","type":"address"},{"name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"id","type":"uint256"},{"name":"value","type":"uint256"},{"name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"conditionId","type":"bytes32"},{"indexed":true,"name":"oracle","type":"address"},{"indexed":true,"name":"questionId","type":"bytes32"},{"indexed":false,"name":"outcomeSlotCount","type":"uint256"}],"name":"ConditionPreparation","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"conditionId","type":"bytes32"},{"indexed":true,"name":"oracle","type":"address"},{"indexed":true,"name":"questionId","type":"bytes32"},{"indexed":false,"name":"outcomeSlotCount","type":"uint256"},{"indexed":false,"name":"payoutNumerators","type":"uint256[]"}],"name":"ConditionResolution","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"stakeholder","type":"address"},{"indexed":false,"name":"collateralToken","type":"address"},{"indexed":true,"name":"parentCollectionId","type":"bytes32"},{"indexed":true,"name":"conditionId","type":"bytes32"},{"indexed":false,"name":"partition","type":"uint256[]"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"PositionSplit","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"stakeholder","type":"address"},{"indexed":false,"name":"collateralToken","type":"address"},{"indexed":true,"name":"parentCollectionId","type":"bytes32"},{"indexed":true,"name":"conditionId","type":"bytes32"},{"indexed":false,"name":"partition","type":"uint256[]"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"PositionsMerge","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"redeemer","type":"address"},{"indexed":true,"name":"collateralToken","type":"address"},{"indexed":true,"name":"parentCollectionId","type":"bytes32"},{"indexed":false,"name":"conditionId","type":"bytes32"},{"indexed":false,"name":"indexSets","type":"uint256[]"},{"indexed":false,"name":"payout","type":"uint256"}],"name":"PayoutRedemption","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"operator","type":"address"},{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"id","type":"uint256"},{"indexed":false,"name":"value","type":"uint256"}],"name":"TransferSingle","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"operator","type":"address"},{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"ids","type":"uint256[]"},{"indexed":false,"name":"values","type":"uint256[]"}],"name":"TransferBatch","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"operator","type":"address"},{"indexed":false,"name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"value","type":"string"},{"indexed":true,"name":"id","type":"uint256"}],"name":"URI","type":"event"},{"constant":false,"inputs":[{"name":"oracle","type":"address"},{"name":"questionId","type":"bytes32"},{"name":"outcomeSlotCount","type":"uint256"}],"name":"prepareCondition","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"questionId","type":"bytes32"},{"name":"payouts","type":"uint256[]"}],"name":"reportPayouts","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"collateralToken","type":"address"},{"name":"parentCollectionId","type":"bytes32"},{"name":"conditionId","type":"bytes32"},{"name":"partition","type":"uint256[]"},{"name":"amount","type":"uint256"}],"name":"splitPosition","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"collateralToken","type":"address"},{"name":"parentCollectionId","type":"bytes32"},{"name":"conditionId","type":"bytes32"},{"name":"partition","type":"uint256[]"},{"name":"amount","type":"uint256"}],"name":"mergePositions","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"collateralToken","type":"address"},{"name":"parentCollectionId","type":"bytes32"},{"name":"conditionId","type":"bytes32"},{"name":"indexSets","type":"uint256[]"}],"name":"redeemPositions","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"conditionId","type":"bytes32"}],"name":"getOutcomeSlotCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"oracle","type":"address"},{"name":"questionId","type":"bytes32"},{"name":"outcomeSlotCount","type":"uint256"}],"name":"getConditionId","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":true,"inputs":[{"name":"parentCollectionId","type":"bytes32"},{"name":"conditionId","type":"bytes32"},{"name":"indexSet","type":"uint256"}],"name":"getCollectionId","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"collateralToken","type":"address"},{"name":"collectionId","type":"bytes32"}],"name":"getPositionId","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"pure","type":"function"}]'
)
market_maker_abi = json.loads(
    '[{"constant":true,"inputs":[{"name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"resume","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"pmSystem","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"outcomeTokenAmounts","type":"int256[]"},{"name":"collateralLimit","type":"int256"}],"name":"trade","outputs":[{"name":"netCost","type":"int256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"close","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"withdrawFees","outputs":[{"name":"fees","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"renounceOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[],"name":"pause","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"fundingChange","type":"int256"}],"name":"changeFunding","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"isOwner","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"whitelist","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"outcomeTokenCost","type":"uint256"}],"name":"calcMarketFee","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"collateralToken","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_operator","type":"address"},{"name":"","type":"address"},{"name":"","type":"uint256[]"},{"name":"","type":"uint256[]"},{"name":"","type":"bytes"}],"name":"onERC1155BatchReceived","outputs":[{"name":"","type":"bytes4"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"stage","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"funding","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"conditionIds","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"atomicOutcomeSlotCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"fee","outputs":[{"name":"","type":"uint64"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_fee","type":"uint64"}],"name":"changeFee","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"operator","type":"address"},{"name":"","type":"address"},{"name":"","type":"uint256"},{"name":"","type":"uint256"},{"name":"","type":"bytes"}],"name":"onERC1155Received","outputs":[{"name":"","type":"bytes4"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"FEE_RANGE","outputs":[{"name":"","type":"uint64"}],"payable":false,"stateMutability":"view","type":"function"},{"anonymous":false,"inputs":[{"indexed":false,"name":"initialFunding","type":"uint256"}],"name":"AMMCreated","type":"event"},{"anonymous":false,"inputs":[],"name":"AMMPaused","type":"event"},{"anonymous":false,"inputs":[],"name":"AMMResumed","type":"event"},{"anonymous":false,"inputs":[],"name":"AMMClosed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"fundingChange","type":"int256"}],"name":"AMMFundingChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"newFee","type":"uint64"}],"name":"AMMFeeChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"fees","type":"uint256"}],"name":"AMMFeeWithdrawal","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"transactor","type":"address"},{"indexed":false,"name":"outcomeTokenAmounts","type":"int256[]"},{"indexed":false,"name":"outcomeTokenNetCost","type":"int256"},{"indexed":false,"name":"marketFees","type":"uint256"}],"name":"AMMOutcomeTokenTrade","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"previousOwner","type":"address"},{"indexed":true,"name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"constant":true,"inputs":[{"name":"outcomeTokenAmounts","type":"int256[]"}],"name":"calcNetCost","outputs":[{"name":"netCost","type":"int256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"outcomeTokenIndex","type":"uint8"}],"name":"calcMarginalPrice","outputs":[{"name":"price","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"}]'
)
market_maker_factory_abi = json.loads(
    '[{"constant":true,"inputs":[],"name":"implementationMaster","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"creator","type":"address"},{"indexed":false,"name":"lmsrMarketMaker","type":"address"},{"indexed":false,"name":"pmSystem","type":"address"},{"indexed":false,"name":"collateralToken","type":"address"},{"indexed":false,"name":"conditionIds","type":"bytes32[]"},{"indexed":false,"name":"fee","type":"uint64"},{"indexed":false,"name":"funding","type":"uint256"}],"name":"LMSRMarketMakerCreation","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"previousOwner","type":"address"},{"indexed":true,"name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"initialFunding","type":"uint256"}],"name":"AMMCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"target","type":"address"},{"indexed":false,"name":"clone","type":"address"}],"name":"CloneCreated","type":"event"},{"constant":false,"inputs":[{"name":"consData","type":"bytes"}],"name":"cloneConstructor","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"pmSystem","type":"address"},{"name":"collateralToken","type":"address"},{"name":"conditionIds","type":"bytes32[]"},{"name":"fee","type":"uint64"},{"name":"whitelist","type":"address"},{"name":"funding","type":"uint256"}],"name":"createLMSRMarketMaker","outputs":[{"name":"lmsrMarketMaker","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"function"}]'
)

'''
'''--- safe_transaction_service/contracts/decoder_abis/snapshot.py ---
snapshot_delegate_registry_abi = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "delegator",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "bytes32",
                "name": "id",
                "type": "bytes32",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "delegate",
                "type": "address",
            },
        ],
        "name": "ClearDelegate",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "delegator",
                "type": "address",
            },
            {
                "indexed": True,
                "internalType": "bytes32",
                "name": "id",
                "type": "bytes32",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "delegate",
                "type": "address",
            },
        ],
        "name": "SetDelegate",
        "type": "event",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "", "type": "address"},
            {"internalType": "bytes32", "name": "", "type": "bytes32"},
        ],
        "name": "delegation",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "bytes32", "name": "id", "type": "bytes32"},
            {"internalType": "address", "name": "delegate", "type": "address"},
        ],
        "name": "setDelegate",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "bytes32", "name": "id", "type": "bytes32"}],
        "name": "clearDelegate",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/contracts/decoder_abis/timelock.py ---
import json

timelock_abi = json.loads(
    '[{"inputs":[{"internalType":"address","name":"admin_","type":"address"},{"internalType":"uint256","name":"delay_","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"txHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"target","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"},{"indexed":false,"internalType":"string","name":"signature","type":"string"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"},{"indexed":false,"internalType":"uint256","name":"eta","type":"uint256"}],"name":"CancelTransaction","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"txHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"target","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"},{"indexed":false,"internalType":"string","name":"signature","type":"string"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"},{"indexed":false,"internalType":"uint256","name":"eta","type":"uint256"}],"name":"ExecuteTransaction","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newAdmin","type":"address"}],"name":"NewAdmin","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"newDelay","type":"uint256"}],"name":"NewDelay","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newPendingAdmin","type":"address"}],"name":"NewPendingAdmin","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"txHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"target","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"},{"indexed":false,"internalType":"string","name":"signature","type":"string"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"},{"indexed":false,"internalType":"uint256","name":"eta","type":"uint256"}],"name":"QueueTransaction","type":"event"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"constant":true,"inputs":[],"name":"GRACE_PERIOD","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MAXIMUM_DELAY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MINIMUM_DELAY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"acceptAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"admin_initialized","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"target","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"string","name":"signature","type":"string"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"uint256","name":"eta","type":"uint256"}],"name":"cancelTransaction","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"delay","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"target","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"string","name":"signature","type":"string"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"uint256","name":"eta","type":"uint256"}],"name":"executeTransaction","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[],"name":"pendingAdmin","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"target","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"string","name":"signature","type":"string"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"uint256","name":"eta","type":"uint256"}],"name":"queueTransaction","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"queuedTransactions","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"delay_","type":"uint256"}],"name":"setDelay","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"pendingAdmin_","type":"address"}],"name":"setPendingAdmin","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]'
)

'''
'''--- safe_transaction_service/contracts/management/__init__.py ---

'''
'''--- safe_transaction_service/contracts/management/commands/__init__.py ---

'''
'''--- safe_transaction_service/contracts/management/commands/index_contracts_with_metadata.py ---
from django.core.management.base import BaseCommand

from ...tasks import (
    create_missing_contracts_with_metadata_task,
    reindex_contracts_without_metadata_task,
)

class Command(BaseCommand):
    help = "Index contracts from etherscan/sourcify"

    def add_arguments(self, parser):
        parser.add_argument(
            "--reindex",
            help="Try to fetch contract names/ABIS for contracts already indexed. "
            "If not provided only missing contracts will be processed",
            action="store_true",
            default=False,
        )
        parser.add_argument(
            "--sync",
            help="Command will wait for the command to run. If not provided an async task will be used",
            action="store_true",
            default=False,
        )

    def handle(self, *args, **options):
        reindex = options["reindex"]
        sync = options["sync"]

        if reindex:
            self.stdout.write(
                self.style.SUCCESS(
                    "Calling `reindex_contracts_without_metadata_task` task"
                )
            )
            task = reindex_contracts_without_metadata_task
        else:
            self.stdout.write(
                self.style.SUCCESS(
                    "Calling `create_missing_contracts_with_metadata_task` task"
                )
            )
            task = create_missing_contracts_with_metadata_task

        if sync:
            task()
            self.stdout.write(self.style.SUCCESS("Processing finished"))
        else:
            task.delay()
            self.stdout.write(self.style.SUCCESS("Task was sent"))

'''
'''--- safe_transaction_service/contracts/migrations/0001_initial.py ---
# Generated by Django 3.1.4 on 2020-12-11 10:28

import django.db.models.deletion
from django.db import migrations, models

import gnosis.eth.django.models

import safe_transaction_service.contracts.models

class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="ContractAbi",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "abi",
                    models.JSONField(
                        validators=[
                            safe_transaction_service.contracts.models.validate_abi
                        ]
                    ),
                ),
                ("description", models.CharField(blank=True, max_length=200)),
                ("relevance", models.SmallIntegerField(default=100)),
            ],
        ),
        migrations.CreateModel(
            name="Contract",
            fields=[
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(
                        primary_key=True, serialize=False
                    ),
                ),
                ("name", models.CharField(blank=True, default="", max_length=200)),
                (
                    "contract_abi",
                    models.ForeignKey(
                        default=None,
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="contracts",
                        to="contracts.contractabi",
                    ),
                ),
            ],
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0002_auto_20210119_1136.py ---
# Generated by Django 3.1.5 on 2021-01-19 11:36

from django.db import migrations, models

import safe_transaction_service.contracts.models

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="contract",
            name="display_name",
            field=models.CharField(blank=True, default="", max_length=200),
        ),
        migrations.AddField(
            model_name="contract",
            name="logo",
            field=models.ImageField(
                default=None,
                null=True,
                upload_to=safe_transaction_service.contracts.models.get_contract_logo_path,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0003_auto_20210122_1352.py ---
# Generated by Django 3.1.5 on 2021-01-22 13:52

from django.db import migrations, models

import safe_transaction_service.contracts.models

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0002_auto_20210119_1136"),
    ]

    operations = [
        migrations.AlterField(
            model_name="contract",
            name="logo",
            field=models.ImageField(
                blank=True,
                default="",
                upload_to=safe_transaction_service.contracts.models.get_contract_logo_path,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0004_auto_20210125_0925.py ---
# Generated by Django 3.1.5 on 2021-01-25 09:25

import django.db.models.deletion
from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0003_auto_20210122_1352"),
    ]

    operations = [
        migrations.AlterField(
            model_name="contract",
            name="contract_abi",
            field=models.ForeignKey(
                blank=True,
                default=None,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="contracts",
                to="contracts.contractabi",
            ),
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0005_alter_contractabi_id.py ---
# Generated by Django 3.2.4 on 2021-06-07 10:07

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0004_auto_20210125_0925"),
    ]

    operations = [
        migrations.AlterField(
            model_name="contractabi",
            name="id",
            field=models.BigAutoField(
                auto_created=True, primary_key=True, serialize=False, verbose_name="ID"
            ),
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0006_contractabi_abi_hash.py ---
# Generated by Django 3.2.5 on 2021-07-15 12:39
import json

from django.db import IntegrityError, migrations, transaction

from web3 import Web3

import gnosis.eth.django.models

def add_hash_for_contract_abis(apps, schema_editor):
    ContractAbi = apps.get_model("contracts", "ContractAbi")
    for contract_abi in ContractAbi.objects.iterator():
        try:
            with transaction.atomic():
                contract_abi.abi_hash = Web3.keccak(
                    text=json.dumps(contract_abi.abi, separators=(",", ":"))
                )
                contract_abi.save(update_fields=["abi_hash"])
        except IntegrityError:
            contract_abi.delete()

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0005_alter_contractabi_id"),
    ]

    operations = [
        migrations.AddField(
            model_name="contractabi",
            name="abi_hash",
            field=gnosis.eth.django.models.Sha3HashField(
                blank=True, default=None, null=True, unique=True
            ),
        ),
        migrations.RunPython(
            add_hash_for_contract_abis, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0007_contract_trusted_for_delegate_call.py ---
# Generated by Django 3.2.9 on 2021-12-02 11:28

from django.db import migrations, models

def add_trusted_contracts(apps, schema_editor):
    Contract = apps.get_model("contracts", "Contract")
    Contract.objects.filter(
        address__in=[
            # Multisend v1.3.0
            # "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761", Not safe, allows nested delegate calls
            "0x998739BFdAAdde7C933B942a68053933098f9EDa",
            "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
            "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
            # Multisend v1.1.1
            # "0x8D29bE29923b68abfDD21e541b9374737B49cdAD", Not safe, allows nested delegate calls
        ]
    ).update(trusted_for_delegate_call=True)

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0006_contractabi_abi_hash"),
    ]

    operations = [
        migrations.AddField(
            model_name="contract",
            name="trusted_for_delegate_call",
            field=models.BooleanField(default=False),
        ),
        migrations.RunPython(
            add_trusted_contracts, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0008_ethereum_address_field_v2.py ---
# Generated by Django 3.2.9 on 2021-12-01 16:06

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0007_contract_trusted_for_delegate_call"),
    ]

    operations = [
        migrations.RunSQL(
            """
            DROP INDEX IF EXISTS
                notifications_firebasede_safecontract_id_acb5c418_like,
                notifications_firebasedeviceowner_owner_025b0ed6_like,
                contracts_contract_address_858bb34d_like;
            ALTER TABLE "contracts_contract" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex');
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        migrations.AlterField(
            model_name="contract",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                primary_key=True, serialize=False
            ),
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0009_alter_contractabi_abi_hash.py ---
# Generated by Django 3.2.9 on 2021-12-09 16:28

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0008_ethereum_address_field_v2"),
    ]

    operations = [
        migrations.RunSQL(
            """
            DROP INDEX IF EXISTS "contracts_contractabi_abi_hash_602e726b_like";
            ALTER TABLE "contracts_contractabi" ALTER COLUMN "abi_hash" TYPE bytea USING DECODE("abi_hash", 'hex');
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        migrations.AlterField(
            model_name="contractabi",
            name="abi_hash",
            field=gnosis.eth.django.models.Keccak256Field(
                blank=True, default=None, null=True, unique=True
            ),
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/0010_alter_contract_logo.py ---
# Generated by Django 3.2.12 on 2022-02-16 11:19

from django.db import migrations

import imagekit.models.fields

import safe_transaction_service.contracts.models

class Migration(migrations.Migration):

    dependencies = [
        ("contracts", "0009_alter_contractabi_abi_hash"),
    ]

    operations = [
        migrations.AlterField(
            model_name="contract",
            name="logo",
            field=imagekit.models.fields.ProcessedImageField(
                blank=True,
                default="",
                upload_to=safe_transaction_service.contracts.models.get_contract_logo_path,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/contracts/migrations/__init__.py ---

'''
'''--- safe_transaction_service/contracts/models.py ---
import json
import operator
import os
from logging import getLogger
from typing import Any, Dict, List, Optional

from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.files.storage import default_storage
from django.db import models
from django.db.models import JSONField, Q
from django.utils.translation import gettext_lazy as _

from botocore.exceptions import ClientError
from cachetools import TTLCache, cachedmethod
from imagekit.models import ProcessedImageField
from pilkit.processors import Resize
from web3._utils.normalizers import normalize_abi

from gnosis.eth.clients import (
    BlockscoutClient,
    BlockScoutConfigurationProblem,
    EtherscanClient,
    EtherscanClientConfigurationProblem,
    Sourcify,
)
from gnosis.eth.django.models import EthereumAddressV2Field, Keccak256Field
from gnosis.eth.ethereum_client import EthereumClientProvider, EthereumNetwork
from gnosis.eth.utils import fast_keccak

logger = getLogger(__name__)

def get_contract_logo_path(instance: "Contract", filename):
    # file will be uploaded to MEDIA_ROOT/<address>
    _, extension = os.path.splitext(filename)
    return f"contracts/logos/{instance.address}{extension}"  # extension includes '.'

def get_file_storage():
    if settings.AWS_CONFIGURED:
        from django_s3_storage.storage import S3Storage

        return S3Storage()
    else:
        return default_storage

def validate_abi(value: Dict[str, Any]):
    try:
        if not value:
            raise ValueError("Empty ABI not allowed")
        normalize_abi(value)
    except ValueError as exc:
        raise ValidationError(
            _("%(value)s is not a valid Ethereum Contract ABI: %(reason)s"),
            params={"value": value, "reason": str(exc)},
        ) from exc

class ContractAbi(models.Model):
    """
    This model holds contract ABIs. Contract ABIS don't have to be tied to a contract
    (e.g. generic ERC20/721 ABI)
    """

    abi = JSONField(validators=[validate_abi])
    description = models.CharField(max_length=200, blank=True)
    relevance = models.SmallIntegerField(
        default=100
    )  # A lower number will indicate more relevance
    abi_hash = Keccak256Field(default=None, blank=True, null=True, unique=True)

    def __str__(self):
        return f"ContractABI {self.relevance} - {self.description}"

    def abi_functions(self) -> List[str]:
        return [x["name"] for x in self.abi if x["type"] == "function"]

    def save(self, *args, **kwargs) -> None:
        if update_fields := kwargs.get("update_fields"):
            if "abi_hash" not in update_fields:
                update_fields.append("abi_hash")
        if isinstance(self.abi, str):
            self.abi = json.loads(self.abi)
        self.abi_hash = fast_keccak(
            json.dumps(self.abi, separators=(",", ":")).encode()
        )
        try:
            # ABI already exists, overwrite
            contract_abi = self.__class__.objects.get(abi_hash=self.abi_hash)
            self.id = contract_abi.id
            self.description = self.description or contract_abi.description
        except self.__class__.DoesNotExist:
            pass
        return super().save(*args, **kwargs)

class ContractManager(models.Manager):
    def create_from_address(
        self, address: str, network: Optional[EthereumNetwork] = None
    ) -> "Contract":
        """
        Create contract and try to fetch information from APIs

        :param address:
        :param network:
        :return: Contract instance populated with all the information found
        """
        contract = super().create(address=address)
        contract.sync_abi_from_api(network=network)
        return contract

    def fix_missing_logos(self) -> int:
        """
        Syncs contracts with empty logos with files that exist on S3 and match the address

        :return: Number of synced logos
        """
        synced_logos = 0
        for contract in self.without_logo():
            filename = get_contract_logo_path(contract, f"{contract.address}.png")
            contract.logo.name = filename
            try:
                if contract.logo.size:
                    synced_logos += 1
                    contract.save(update_fields=["logo"])
                    logger.info("Found logo on url %s", contract.logo.url)
            except (ClientError, FileNotFoundError):  # Depending on aws or filesystem
                logger.error("Error retrieving url %s", contract.logo.url)
        return synced_logos

class ContractQuerySet(models.QuerySet):
    cache_trusted_addresses_for_delegate_call = TTLCache(
        maxsize=2048, ttl=60 * 5
    )  # 5 minutes of caching
    no_logo_query = Q(logo=None) | Q(logo="")

    def with_logo(self):
        return self.exclude(self.no_logo_query)

    def without_logo(self):
        return self.filter(self.no_logo_query)

    def without_metadata(self):
        return self.filter(Q(contract_abi=None) | Q(name=""))

    def trusted_for_delegate_call(self):
        return self.filter(trusted_for_delegate_call=True)

    @cachedmethod(
        cache=operator.attrgetter("cache_trusted_addresses_for_delegate_call")
    )
    def trusted_addresses_for_delegate_call(self):
        return self.trusted_for_delegate_call().values_list("address", flat=True)

class Contract(models.Model):  # Known contract addresses by the service
    objects = ContractManager.from_queryset(ContractQuerySet)()
    address = EthereumAddressV2Field(primary_key=True)
    name = models.CharField(max_length=200, blank=True, default="")
    display_name = models.CharField(max_length=200, blank=True, default="")
    logo = ProcessedImageField(
        blank=True,
        default="",
        upload_to=get_contract_logo_path,
        storage=get_file_storage,
        format="PNG",
        processors=[Resize(256, 256, upscale=False)],
    )
    contract_abi = models.ForeignKey(
        ContractAbi,
        on_delete=models.SET_NULL,
        null=True,
        default=None,
        blank=True,
        related_name="contracts",
    )
    # Trusted for doing delegate calls, as it's very dangerous doing delegate calls to other contracts
    trusted_for_delegate_call = models.BooleanField(default=False)

    def __str__(self):
        has_abi = self.contract_abi_id is not None
        logo = " with logo" if self.logo else " without logo"
        return f"Contract {self.address} - {self.name} - with abi {has_abi}{logo}"

    def sync_abi_from_api(self, network: Optional[EthereumNetwork] = None) -> bool:
        """
        Sync ABI from Sourcify, then from Etherscan and Blockscout if available

        :param network: Can be provided to save requests to the node
        :return: True if updated, False otherwise
        """
        ethereum_client = EthereumClientProvider()
        network = network or ethereum_client.get_network()
        sourcify = Sourcify(network)

        try:
            etherscan_client = EtherscanClient(
                network, api_key=settings.ETHERSCAN_API_KEY
            )
        except EtherscanClientConfigurationProblem:
            logger.info(
                "Etherscan client is not available for current network %s", network
            )
            etherscan_client = None

        try:
            blockscout_client = BlockscoutClient(network)
        except BlockScoutConfigurationProblem:
            logger.info(
                "Blockscout client is not available for current network %s", network
            )
            blockscout_client = None

        contract_abi: Optional[ContractAbi] = None
        for client in (sourcify, etherscan_client, blockscout_client):
            if not client:
                continue
            try:
                contract_metadata = client.get_contract_metadata(self.address)
                if contract_metadata:
                    name = contract_metadata.name or ""
                    contract_abi, _ = ContractAbi.objects.get_or_create(
                        abi=contract_metadata.abi, defaults={"description": name}
                    )
                    if name:
                        if not contract_abi.description:
                            contract_abi.description = name
                            contract_abi.save(update_fields=["description"])
                        if not self.name:
                            self.name = name
                    self.contract_abi = contract_abi
                    self.save(update_fields=["name", "contract_abi"])
                    break
            except IOError:
                pass

        return bool(contract_abi)

'''
'''--- safe_transaction_service/contracts/pagination.py ---
from rest_framework.pagination import LimitOffsetPagination

class DefaultPagination(LimitOffsetPagination):
    max_limit = 200
    default_limit = 100

class SmallPagination(LimitOffsetPagination):
    max_limit = 100
    default_limit = 20

'''
'''--- safe_transaction_service/contracts/serializers.py ---
from rest_framework import serializers

from gnosis.eth.django.serializers import EthereumAddressField

class ContractAbiSerializer(serializers.Serializer):
    abi = serializers.ListField(child=serializers.DictField())
    description = serializers.CharField()
    relevance = serializers.IntegerField()

class ContractSerializer(serializers.Serializer):
    address = EthereumAddressField()
    name = serializers.CharField()
    display_name = serializers.CharField()
    logo_uri = serializers.ImageField(source="logo")
    contract_abi = ContractAbiSerializer()
    trusted_for_delegate_call = serializers.BooleanField()

'''
'''--- safe_transaction_service/contracts/signals.py ---
import logging
from typing import Sequence, Type

from django.core.cache import cache as django_cache
from django.db.models import Model
from django.db.models.signals import post_save
from django.dispatch import receiver

from eth_typing import ChecksumAddress

from .models import Contract, ContractAbi
from .tx_decoder import get_db_tx_decoder, is_db_tx_decoder_loaded

logger = logging.getLogger(__name__)

def get_contract_cache_key(address: ChecksumAddress) -> str:
    return f"contracts:{address}"

def clear_contracts_cache(addresses: Sequence[ChecksumAddress]) -> None:
    keys = [get_contract_cache_key(address) for address in addresses]
    return django_cache.delete_many(keys)

@receiver(post_save, sender=Contract, dispatch_uid="contract.clear_cache")
def clear_contract_cache(
    sender: Type[Model], instance: Contract, created: bool, **kwargs
) -> None:
    """
    Clear Contract cache when a contract is updated

    :param sender:
    :param instance:
    :param created:
    :param kwargs:
    :return:
    """
    return clear_contracts_cache([instance.address])

@receiver(
    post_save, sender=ContractAbi, dispatch_uid="contract_abi.add_abi_to_tx_decoder"
)
def add_abi_in_tx_decoder(
    sender: Type[Model], instance: ContractAbi, created: bool, **kwargs
) -> None:
    """
    When a `ContractAbi` is saved, TxDecoder must be updated and caches must be flushed

    :param sender: ContractAbi
    :param instance: Instance of ContractAbi
    :param created: `True` if model has just been created, `False` otherwise
    :param kwargs:
    :return:
    """

    clear_contracts_cache(instance.contracts.values_list("address", flat=True))
    if instance.abi:
        if is_db_tx_decoder_loaded():
            db_tx_decoder = get_db_tx_decoder()
            if db_tx_decoder.add_abi(instance.abi):
                logger.info(
                    "ABI for ContractAbi %s was loaded on the TxDecoder", instance
                )

'''
'''--- safe_transaction_service/contracts/tasks.py ---
import datetime
from enum import Enum
from itertools import chain

from django.db import IntegrityError, transaction
from django.utils import timezone

from celery import app
from celery.utils.log import get_task_logger
from eth_typing import ChecksumAddress

from gnosis.eth.clients import EtherscanRateLimitError
from gnosis.safe.multi_send import MultiSend

from safe_transaction_service.history.models import (
    ModuleTransaction,
    MultisigTransaction,
)
from safe_transaction_service.utils.ethereum import get_ethereum_network
from safe_transaction_service.utils.utils import close_gevent_db_connection_decorator

from .models import Contract

logger = get_task_logger(__name__)

class ContractAction(Enum):
    CREATED = 0
    UPDATED = 1
    NOT_MODIFIED = 2

@app.shared_task()
@close_gevent_db_connection_decorator
def create_missing_contracts_with_metadata_task() -> int:
    """
    Insert detected contracts the users are interacting with on database
    and retrieve metadata (name, abi) if possible

    :return: Number of contracts missing
    """
    addresses = chain(
        MultisigTransaction.objects.not_indexed_metadata_contract_addresses().iterator(),
        ModuleTransaction.objects.not_indexed_metadata_contract_addresses().iterator(),
    )
    i = 0
    for address in addresses:
        logger.info("Detected missing contract %s", address)
        create_or_update_contract_with_metadata_task.apply_async(
            (address,), priority=1
        )  # Lowest priority
        i += 1
    return i

@app.shared_task()
@close_gevent_db_connection_decorator
def create_missing_multisend_contracts_with_metadata_task() -> int:
    """
    Insert detected contracts the users are interacting with using Multisend for the last day
    and retrieve metadata (name, abi) if possible

    :return: Number of contracts missing
    """
    addresses = set()
    for data in (
        MultisigTransaction.objects.trusted()
        .multisend()
        .with_data()
        .filter(created__gte=timezone.now() - datetime.timedelta(days=1))
        .values_list("data", flat=True)
        .iterator()
    ):
        for multisend_tx in MultiSend.from_transaction_data(bytes(data)):
            address = multisend_tx.to
            # Only index not existing contracts
            if not Contract.objects.filter(address=address).exists():
                addresses.add(address)

    for address in addresses:
        logger.info("Detected missing contract %s called using MultiSend", address)
        create_or_update_contract_with_metadata_task.apply_async(
            (address,), priority=1
        )  # Lowest priority
    return len(addresses)

@app.shared_task()
@close_gevent_db_connection_decorator
def reindex_contracts_without_metadata_task() -> int:
    """
    Try to reindex existing contracts without metadata

    :return: Number of contracts missing
    """
    i = 0
    for address in (
        Contract.objects.without_metadata().values_list("address", flat=True).iterator()
    ):
        logger.info("Reindexing contract %s", address)
        create_or_update_contract_with_metadata_task.apply_async(
            (address,), priority=1
        )  # Lowest priority
        i += 1
    return i

@app.shared_task(
    autoretry_for=(EtherscanRateLimitError,),
    retry_backoff=10,
    retry_kwargs={"max_retries": 5},
)
@close_gevent_db_connection_decorator
def create_or_update_contract_with_metadata_task(
    address: ChecksumAddress,
) -> ContractAction:
    """
    Creates or updates a contract using 3rd party information (contract name, ABI...)

    :param address: Contract address
    :return: ContractAction
    """
    logger.info("Searching metadata for contract %s", address)
    ethereum_network = get_ethereum_network()
    try:
        with transaction.atomic():
            contract = Contract.objects.create_from_address(
                address, network=ethereum_network
            )
            action = ContractAction.CREATED
    except IntegrityError:
        contract = Contract.objects.get(address=address)
        if contract.sync_abi_from_api():
            action = ContractAction.UPDATED
        else:
            action = ContractAction.NOT_MODIFIED

    logger.info(
        "%s contract with address=%s name=%s abi-found=%s",
        action,
        address,
        contract.name,
        contract.contract_abi is not None,
    )
    return action

'''
'''--- safe_transaction_service/contracts/tests/__init__.py ---

'''
'''--- safe_transaction_service/contracts/tests/factories.py ---
import factory
from eth_account import Account
from factory.django import DjangoModelFactory

from gnosis.eth.tests.clients.mocks import sourcify_safe_metadata

from ..models import Contract, ContractAbi

class ContractAbiFactory(DjangoModelFactory):
    class Meta:
        model = ContractAbi

    # Prevent duplicated abis
    abi = factory.Sequence(
        lambda n: sourcify_safe_metadata["output"]["abi"]
        + [
            {
                "anonymous": False,
                "inputs": [
                    {
                        "indexed": False,
                        "internalType": "address",
                        "name": "owner",
                        "type": "address",
                    }
                ],
                "name": f"EventToPreventUniqueError-{n}",
                "type": "event",
            }
        ]
    )
    description = "Gnosis Safe v1.2.0 ABI"
    relevance = 1

class ContractFactory(DjangoModelFactory):
    class Meta:
        model = Contract

    address = factory.LazyFunction(lambda: Account.create().address)
    name = factory.Faker("cryptocurrency_name")
    display_name = ""
    logo = factory.django.ImageField(color="green")
    contract_abi = factory.SubFactory(ContractAbiFactory)
    trusted_for_delegate_call = False

'''
'''--- safe_transaction_service/contracts/tests/test_admin.py ---
from django.contrib.admin import site
from django.contrib.auth.models import User
from django.test import RequestFactory, TestCase

from safe_transaction_service.contracts.admin import ContractAdmin
from safe_transaction_service.contracts.tests.factories import (
    ContractAbiFactory,
    ContractFactory,
)

from ..models import Contract

class TestContractAdmin(TestCase):
    request_factory = RequestFactory()

    @classmethod
    def setUpTestData(cls) -> None:
        cls.superuser = User.objects.create_superuser(
            "alfred", "alfred@example.com", "password"
        )
        cls.contract1 = ContractFactory.create(
            contract_abi=ContractAbiFactory.create(relevance=3), logo=None
        )
        cls.contract2 = ContractFactory.create(contract_abi=None)
        cls.contract3 = ContractFactory.create(
            contract_abi=ContractAbiFactory.create(relevance=4)
        )
        cls.contracts = {cls.contract1, cls.contract2, cls.contract3}

    def setUp(self) -> None:
        self.contract_admin = ContractAdmin(Contract, site)
        return super().setUp()

    def test_lookups(self) -> None:
        request = self.request_factory.get("/")
        request.user = self.superuser

        changelist = self.contract_admin.get_changelist_instance(request)

        filterspec = changelist.get_filters(request)
        expected_choices = [("YES", "Yes"), ("NO", "No")]
        self.assertEqual(filterspec[0][0].lookup_choices, expected_choices)
        self.assertEqual(filterspec[0][1].lookup_choices, expected_choices)

    def test_unfiltered_lookup(self) -> None:
        request = self.request_factory.get("/")
        request.user = self.superuser

        changelist = self.contract_admin.get_changelist_instance(request)

        # Queryset should contain all the contracts (no filter specified)
        self.assertEqual(
            set(changelist.get_queryset(request)),
            self.contracts,
        )

    def test_has_abi_filter_lookup(self) -> None:
        request = self.request_factory.get("/", {"has_abi": "YES"})
        request.user = self.superuser

        changelist = self.contract_admin.get_changelist_instance(request)

        # Queryset should contain contracts with ABI (contract1 and contract3)
        self.assertEqual(
            set(changelist.get_queryset(request)), {self.contract1, self.contract3}
        )

    def test_has_abi_exclusion_filter_lookup(self) -> None:
        request = self.request_factory.get("/", {"has_abi": "NO"})
        request.user = self.superuser

        changelist = self.contract_admin.get_changelist_instance(request)

        # Queryset should contain contracts with ABI (contract1 and contract3)
        self.assertEqual(set(changelist.get_queryset(request)), {self.contract2})

    def test_has_logo_filter_lookup(self) -> None:
        request = self.request_factory.get("/", {"has_logo": "YES"})
        request.user = self.superuser

        changelist = self.contract_admin.get_changelist_instance(request)

        # Queryset should contain contracts with logo (contract2 and contract3)
        self.assertEqual(
            set(changelist.get_queryset(request)), {self.contract2, self.contract3}
        )

    def test_get_contracts_abi_relevance(self) -> None:
        expected_relevances = map(
            lambda i: None if (i.contract_abi is None) else i.contract_abi.relevance,
            self.contracts,
        )

        relevances = map(lambda c: self.contract_admin.abi_relevance(c), self.contracts)
        self.assertEqual(set(expected_relevances), set(relevances))

'''
'''--- safe_transaction_service/contracts/tests/test_commands.py ---
from io import StringIO

from django.core.management import call_command
from django.test import TestCase

class TestCommands(TestCase):
    def test_index_contracts_with_metadata(self):
        command = "index_contracts_with_metadata"

        buf = StringIO()
        call_command(command, stdout=buf)
        self.assertIn(
            "Calling `create_missing_contracts_with_metadata_task` task", buf.getvalue()
        )
        self.assertIn("Task was sent", buf.getvalue())

        buf = StringIO()
        call_command(command, "--reindex", "--sync", stdout=buf)
        self.assertIn(
            "Calling `reindex_contracts_without_metadata_task` task", buf.getvalue()
        )
        self.assertIn("Processing finished", buf.getvalue())

'''
'''--- safe_transaction_service/contracts/tests/test_models.py ---
import json
from unittest import mock
from unittest.mock import MagicMock

from django.core.exceptions import ValidationError
from django.db import IntegrityError
from django.db.models.fields.files import ImageFieldFile
from django.db.transaction import atomic
from django.test import TestCase

from eth_account import Account

from gnosis.eth.clients import (
    BlockscoutClient,
    ContractMetadata,
    EtherscanClient,
    Sourcify,
)
from gnosis.eth.ethereum_client import EthereumNetwork
from gnosis.eth.tests.clients.mocks import (
    etherscan_source_code_mock,
    sourcify_safe_metadata,
)

from ..models import Contract, ContractAbi, validate_abi
from .factories import ContractAbiFactory, ContractFactory

class TestContractAbi(TestCase):
    def test_contract_abi_hash(self):
        abi = sourcify_safe_metadata["output"]["abi"]
        contract_abi = ContractAbi.objects.create(abi=abi, description="testing")
        self.assertIsNotNone(contract_abi.abi_hash)
        self.assertGreater(len(str(contract_abi)), 1)

        with self.assertRaisesMessage(IntegrityError, "violates unique constraint"):
            with atomic():
                ContractAbi.objects.create(
                    abi=json.dumps(abi), description="another testing"
                )

        ContractAbi.objects.create(abi={}, description="testing 3")

    def test_contract_abi_save(self):
        contract_abi = ContractAbiFactory()
        abi_hash = contract_abi.abi_hash
        contract_abi.abi = {}
        contract_abi.save(update_fields=["abi"])
        self.assertNotEqual(contract_abi.abi_hash, abi_hash)

        description = "testing"
        # Description will be updated
        ContractAbi(abi={}, description=description).save()
        contract_abi.refresh_from_db()
        self.assertEqual(contract_abi.description, description)

class TestContract(TestCase):
    @mock.patch.object(
        Sourcify, "_do_request", autospec=True, return_value=sourcify_safe_metadata
    )
    @mock.patch.object(
        EtherscanClient,
        "_do_request",
        autospec=True,
        return_value=etherscan_source_code_mock,
    )
    def test_contract_create_from_address(
        self, etherscan_request_mock: MagicMock, sourcify_request_mock: MagicMock
    ):
        safe_contract_address = "0x6851D6fDFAfD08c0295C392436245E5bc78B0185"
        network = EthereumNetwork.MAINNET
        contract = Contract.objects.create_from_address(
            safe_contract_address, network=network
        )
        self.assertEqual(contract.name, "GnosisSafe")
        self.assertTrue(contract.contract_abi.abi)
        self.assertEqual(len(contract.contract_abi.abi_functions()), 31)

        with self.assertRaises(IntegrityError):
            with atomic():
                Contract.objects.create_from_address(
                    safe_contract_address, network=network
                )

        sourcify_request_mock.return_value = None

        # Use etherscan API
        with self.assertRaises(IntegrityError):
            with atomic():
                Contract.objects.create_from_address(
                    safe_contract_address, network=network
                )

        contract.delete()
        contract = Contract.objects.create_from_address(
            safe_contract_address, network=network
        )
        self.assertEqual(contract.name, "GnosisSafe")
        self.assertTrue(contract.contract_abi.abi)
        self.assertEqual(len(contract.contract_abi.abi_functions()), 31)

        etherscan_request_mock.return_value = None
        new_safe_contract_address = Account.create().address
        contract_without_metadata = Contract.objects.create_from_address(
            new_safe_contract_address, network=network
        )
        self.assertEqual(contract_without_metadata.name, "")
        self.assertIsNone(contract_without_metadata.contract_abi)

    def test_fix_missing_logos(self):
        self.assertEqual(Contract.objects.fix_missing_logos(), 0)
        contract_name = "test-contract"
        contract_display_name = "awesome-contract"
        contract = ContractFactory(logo="", name=contract_name, display_name="")
        contract.display_name = contract_display_name
        contract.save()
        self.assertIn("without logo", str(contract))
        self.assertEqual(Contract.objects.with_logo().count(), 0)
        self.assertEqual(Contract.objects.without_logo().count(), 1)
        self.assertEqual(contract.logo, "")
        self.assertEqual(Contract.objects.fix_missing_logos(), 0)
        with mock.patch.object(ImageFieldFile, "size", return_value=1):
            self.assertEqual(Contract.objects.fix_missing_logos(), 1)

        contract.refresh_from_db()
        self.assertIn("with logo", str(contract))
        self.assertIn(f"{contract.address}.png", contract.logo.name)
        self.assertEqual(Contract.objects.with_logo().count(), 1)
        self.assertEqual(Contract.objects.without_logo().count(), 0)

    @mock.patch.object(EtherscanClient, "get_contract_metadata", autospec=True)
    @mock.patch.object(
        BlockscoutClient, "get_contract_metadata", autospec=True, side_effect=IOError
    )
    @mock.patch.object(Sourcify, "get_contract_metadata", autospec=True)
    def test_sync_abi_from_api(
        self,
        sourcify_get_contract_metadata_mock: MagicMock,
        blockscout_client_mock: MagicMock,
        etherscan_get_contract_abi_mock: MagicMock,
    ):
        etherscan_get_contract_abi_mock.return_value = ContractMetadata(
            "Etherscan Uxio Contract",
            [
                {
                    "anonymous": False,
                    "inputs": [
                        {
                            "indexed": False,
                            "internalType": "address",
                            "name": "etherscanParam",
                            "type": "address",
                        }
                    ],
                    "name": "AddedOwner",
                    "type": "event",
                }
            ],
            False,
        )
        sourcify_get_contract_metadata_mock.return_value = ContractMetadata(
            "Sourcify Uxio Contract",
            [
                {
                    "anonymous": False,
                    "inputs": [
                        {
                            "indexed": False,
                            "internalType": "address",
                            "name": "sourcifyParam",
                            "type": "address",
                        }
                    ],
                    "name": "AddedOwner",
                    "type": "event",
                }
            ],
            False,
        )
        contract_name = "Hello"
        contract = Contract.objects.create(
            address="0xaE32496491b53841efb51829d6f886387708F99B",
            name=contract_name,
            contract_abi=None,
        )
        network = EthereumNetwork.MAINNET
        self.assertIsNone(contract.contract_abi)
        self.assertEqual(ContractAbi.objects.count(), 0)
        self.assertTrue(contract.sync_abi_from_api(network=network))
        # Remove contract_abi description and sync again to check that's filled
        contract.contract_abi.description = ""
        contract.contract_abi.save()
        self.assertTrue(contract.sync_abi_from_api(network=network))
        self.assertIsNotNone(contract.contract_abi)
        self.assertEqual(contract.name, contract_name)
        contract_abi = contract.contract_abi
        self.assertEqual(
            contract_abi.description,
            sourcify_get_contract_metadata_mock.return_value.name,
        )
        self.assertEqual(
            contract_abi.abi, sourcify_get_contract_metadata_mock.return_value.abi
        )
        sourcify_get_contract_metadata_mock.side_effect = (
            IOError  # Now etherscan should be used
        )
        self.assertTrue(contract.sync_abi_from_api(network=network))
        self.assertEqual(ContractAbi.objects.count(), 2)  # A new ABI was inserted
        self.assertNotEqual(
            contract.contract_abi, contract_abi
        )  # Contract_abi was changed
        contract_abi.refresh_from_db()
        self.assertEqual(
            contract_abi.description,
            sourcify_get_contract_metadata_mock.return_value.name,
        )  # Description should not change

        etherscan_get_contract_abi_mock.side_effect = IOError
        self.assertFalse(contract.sync_abi_from_api(network=network))

    def test_without_metadata(self):
        ContractFactory(name="aloha", contract_abi=None)
        ContractFactory(name="")
        self.assertEqual(Contract.objects.without_metadata().count(), 2)
        ContractFactory()
        self.assertEqual(Contract.objects.without_metadata().count(), 2)

    def test_validate_abi(self):
        with self.assertRaises(ValidationError):
            validate_abi([])

        with self.assertRaises(ValidationError):
            validate_abi([1])

        with self.assertRaises(ValidationError):
            validate_abi(["a"])

        validate_abi(sourcify_safe_metadata["output"]["abi"])

'''
'''--- safe_transaction_service/contracts/tests/test_tasks.py ---
import datetime
from unittest import mock

from django.test import TestCase
from django.utils import timezone

from eth_account import Account
from hexbytes import HexBytes

from gnosis.eth.clients import Sourcify
from gnosis.eth.tests.clients.mocks import sourcify_safe_metadata

from safe_transaction_service.history.tests.factories import MultisigTransactionFactory

from ..models import Contract
from ..tasks import (
    ContractAction,
    create_missing_contracts_with_metadata_task,
    create_missing_multisend_contracts_with_metadata_task,
    create_or_update_contract_with_metadata_task,
    reindex_contracts_without_metadata_task,
)

class TestTasks(TestCase):
    def test_contract_tasks(self):
        self.assertEqual(create_missing_contracts_with_metadata_task.delay().result, 0)
        [
            MultisigTransactionFactory(
                to=Account.create().address, data=b"12", trusted=True
            )
            for _ in range(2)
        ]
        self.assertEqual(create_missing_contracts_with_metadata_task.delay().result, 2)
        self.assertEqual(Contract.objects.count(), 2)
        self.assertEqual(
            Contract.objects.filter(contract_abi=None).count(), 2
        )  # Contract ABIs were not found
        self.assertEqual(create_missing_contracts_with_metadata_task.delay().result, 0)

        with mock.patch.object(
            Sourcify, "_do_request", autospec=True, return_value=sourcify_safe_metadata
        ):
            multisig_tx = MultisigTransactionFactory(
                to=Account.create().address, data=b"12", trusted=True
            )
            contract_metadata = Sourcify().get_contract_metadata(multisig_tx.to)
            self.assertEqual(
                create_missing_contracts_with_metadata_task.delay().result, 1
            )
            self.assertEqual(
                Contract.objects.without_metadata().count(), 2
            )  # Previously inserted contracts were not processed
            contract = Contract.objects.select_related("contract_abi").get(
                address=multisig_tx.to
            )
            self.assertEqual(contract.name, contract_metadata.name)
            self.assertEqual(contract.contract_abi.abi, contract_metadata.abi)
            contract_abi_id = contract.contract_abi_id

            # Reindex all the contracts, they should have the same abi
            self.assertEqual(reindex_contracts_without_metadata_task.delay().result, 2)
            self.assertEqual(
                Contract.objects.filter(contract_abi_id=contract_abi_id).count(), 3
            )

    def test_create_missing_multisend_contracts_with_metadata_task(self):
        self.assertEqual(
            create_missing_multisend_contracts_with_metadata_task.delay().result, 0
        )
        [
            MultisigTransactionFactory(to=Account.create().address, data=b"12")
            for _ in range(2)
        ]
        self.assertEqual(
            create_missing_multisend_contracts_with_metadata_task.delay().result, 0
        )

        # 2 Multisend transactions 1 day in the past
        one_day_ago = timezone.now() - datetime.timedelta(days=1)
        multisig_transactions = [
            MultisigTransactionFactory(
                created=one_day_ago,
                trusted=True,
                to="0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
                data=HexBytes(
                    "0x8d80ff0a0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000017200cfbfac74c26f8647cbdb8c5caf80bb5b32e4313400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024e71bdf41000000000000000000000000611b13d54f0423bc87abdc113aa9d2512a47273500d7155ccde93ab2a956f26767462c0783535932c3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a4beaeb388000000000000000000000000611b13d54f0423bc87abdc113aa9d2512a4727350000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008e1bc9bf040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                ),
            ),
            MultisigTransactionFactory(
                created=one_day_ago,
                trusted=True,
                to="0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
                data=HexBytes("0x12345"),
            ),
        ]

        # Transactions should not be picked as they should be at much 1 day old
        self.assertEqual(
            create_missing_multisend_contracts_with_metadata_task.delay().result, 0
        )

        for multisig_transaction in multisig_transactions:
            multisig_transaction.created = timezone.now()
            multisig_transaction.save(update_fields=["created"])

        # Not valid multisend transaction should not break the indexer
        self.assertEqual(
            create_missing_multisend_contracts_with_metadata_task.delay().result, 2
        )

        self.assertEqual(
            Contract.objects.filter(
                address__in=[
                    "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
                    "0xD7155cCDE93AB2A956F26767462C0783535932c3",
                ]
            ).count(),
            2,
        )

        # Try again, nothing should be indexed
        self.assertEqual(
            create_missing_multisend_contracts_with_metadata_task.delay().result, 0
        )

    def test_create_or_update_contract_with_metadata_task(self):
        with mock.patch.object(
            Sourcify, "_do_request", autospec=True, return_value=sourcify_safe_metadata
        ) as sourcify_mock:
            random_address = Account.create().address

            self.assertFalse(Contract.objects.filter(address=random_address).exists())
            contract_action = create_or_update_contract_with_metadata_task(
                random_address
            )
            self.assertEqual(contract_action, ContractAction.CREATED)
            self.assertTrue(Contract.objects.filter(address=random_address).exists())

            # Try with a contract already created
            contract_action = create_or_update_contract_with_metadata_task(
                random_address
            )
            self.assertEqual(contract_action, ContractAction.UPDATED)
            self.assertTrue(Contract.objects.filter(address=random_address).exists())

            sourcify_mock.side_effect = IOError
            contract_action = create_or_update_contract_with_metadata_task(
                random_address
            )
            self.assertEqual(contract_action, ContractAction.NOT_MODIFIED)

'''
'''--- safe_transaction_service/contracts/tests/test_tx_decoder.py ---
import logging

from django.test import TestCase

from hexbytes import HexBytes
from web3 import Web3

from gnosis.eth.constants import NULL_ADDRESS
from gnosis.safe.multi_send import MultiSendOperation

from safe_transaction_service.contracts.tests.factories import (
    ContractAbiFactory,
    ContractFactory,
)

from ..tx_decoder import (
    CannotDecode,
    DbTxDecoder,
    SafeTxDecoder,
    TxDecoder,
    get_db_tx_decoder,
    get_safe_tx_decoder,
    get_tx_decoder,
    is_db_tx_decoder_loaded,
)

logger = logging.getLogger(__name__)

class TestTxDecoder(TestCase):
    def test_singleton(self):
        self.assertTrue(isinstance(get_tx_decoder(), TxDecoder))
        self.assertTrue(isinstance(get_safe_tx_decoder(), SafeTxDecoder))
        self.assertFalse(is_db_tx_decoder_loaded())
        self.assertTrue(isinstance(get_db_tx_decoder(), DbTxDecoder))
        self.assertTrue(is_db_tx_decoder_loaded())

    def test_decode_execute_transaction(self):
        data = HexBytes(
            "0x6a761202000000000000000000000000d9ab7371432d7cc74503290412618c948cddacf200000000000000000"
            "0000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000"
            "0000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000030d400000000000000000000000000000000000"
            "0000000000000000000000000186a000000000000000000000000000000000000000000000000000000004a817c"
            "8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "0000000000180000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "00000000000000000000041512215e7f982c8f8e8429c9008068366dcb96bb3abd9c969f3bf2f97f013da6941e1"
            "59f13ca524a6b449accf1ce6765ad811ee7b7151f74749e38ac8bc94fb3b1c00000000000000000000000000000"
            "000000000000000000000000000000000"
        )

        safe_tx_decoder = get_safe_tx_decoder()
        function_name, arguments = safe_tx_decoder.decode_transaction(data)
        self.assertEqual(function_name, "execTransaction")
        self.assertIn("baseGas", arguments)
        self.assertEqual(type(arguments["data"]), str)
        self.assertEqual(
            type(arguments["baseGas"]), int
        )  # SafeTxDecoder does not change numbers

        safe_tx_decoder = get_tx_decoder()
        function_name, arguments = safe_tx_decoder.decode_transaction(data)
        self.assertEqual(function_name, "execTransaction")
        self.assertIn("baseGas", arguments)
        self.assertEqual(type(arguments["data"]), str)
        self.assertEqual(
            type(arguments["baseGas"]), str
        )  # TxDecoder casts numbers to strings

    def test_decode_execute_transaction_with_types(self):
        data = HexBytes(
            "0x6a7612020000000000000000000000005592ec0cfb4dbc12d3ab100b257153436a1f0fea0000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000014000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000001c00000000000000000000000000000000000000000000000000000"
            "000000000044a9059cbb0000000000000000000000000dc0dfd22c6beab74672eade5f9be5234a"
            "aa43cc00000000000000000000000000000000000000000000000000005af3107a400000000000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "00000000000000000000000000000000820000000000000000000000000dc0dfd22c6beab74672"
            "eade5f9be5234aaa43cc0000000000000000000000000000000000000000000000000000000000"
            "00000001000000000000000000000000c791cb32ddb43de8260e6a2762b3b03498b615e5000000"
            "000000000000000000000000000000000000000000000000000000000001000000000000000000"
            "000000000000000000000000000000000000000000"
        )

        safe_tx_decoder = get_safe_tx_decoder()
        function_name, arguments = safe_tx_decoder.decode_transaction_with_types(data)
        self.assertEqual(function_name, "execTransaction")
        self.assertEqual(
            arguments,
            [
                {
                    "name": "to",
                    "type": "address",
                    "value": "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa",
                },
                {"name": "value", "type": "uint256", "value": 0},
                {
                    "name": "data",
                    "type": "bytes",
                    "value": "0xa9059cbb0000000000000000000000000dc0dfd22c6beab74672eade5f9be5234aaa4"
                    "3cc00000000000000000000000000000000000000000000000000005af3107a4000",
                },
                {"name": "operation", "type": "uint8", "value": 0},
                {"name": "safeTxGas", "type": "uint256", "value": 0},
                {"name": "baseGas", "type": "uint256", "value": 0},
                {"name": "gasPrice", "type": "uint256", "value": 0},
                {
                    "name": "gasToken",
                    "type": "address",
                    "value": "0x0000000000000000000000000000000000000000",
                },
                {
                    "name": "refundReceiver",
                    "type": "address",
                    "value": "0x0000000000000000000000000000000000000000",
                },
                {
                    "name": "signatures",
                    "type": "bytes",
                    "value": "0x0000000000000000000000000dc0dfd22c6beab74672eade5f9be5234aaa43cc00000"
                    "00000000000000000000000000000000000000000000000000000000000010000000000"
                    "00000000000000c791cb32ddb43de8260e6a2762b3b03498b615e500000000000000000"
                    "0000000000000000000000000000000000000000000000001",
                },
            ],
        )

    def test_decode_old_execute_transaction(self):
        data = HexBytes(
            "0x6a761202000000000000000000000000a8cc2fc5756f1cba332fefa093ea1d3c6faf559c00000000000000000000"
            "0000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000000000"
            "0000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000030d400000000000000000000000000000000000000000000000"
            "0000000000000186a000000000000000000000000000000000000000000000000000000004a817c800000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000018000000000"
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000000000000"
        )

        safe_tx_decoder = get_safe_tx_decoder()
        function_name, arguments = safe_tx_decoder.decode_transaction(data)
        self.assertEqual(function_name, "execTransaction")
        # self.assertIn('dataGas', arguments)
        self.assertIn("baseGas", arguments)  # Signature of the tx is the same

    def test_decode_multisend(self):
        # Change Safe contract master copy and set fallback manager multisend transaction
        safe_contract_address = "0x5B9ea52Aaa931D4EEf74C8aEaf0Fe759434FeD74"
        value = "0"
        operation = MultiSendOperation.CALL.value
        data = HexBytes(
            "0x8d80ff0a0000000000000000000000000000000000000000000000000000000000000020000000000000000000"
            "00000000000000000000000000000000000000000000f2005b9ea52aaa931d4eef74c8aeaf0fe759434fed740000"
            "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000247de7edef00000000000000000000000034cfac646f301356faa8b21e9422"
            "7e3583fe3f5f005b9ea52aaa931d4eef74c8aeaf0fe759434fed7400000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024f0"
            "8a0323000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000"
            "000000"
        )
        change_master_copy_data = HexBytes(
            "0x7de7edef00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f"
        )
        change_fallback_manager_data = HexBytes(
            "0xf08a0323000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cd"
            "bdf44"
        )
        tx_decoder = get_tx_decoder()
        expected = [
            {
                "operation": operation,
                "to": safe_contract_address,
                "value": value,
                "data": change_master_copy_data.hex(),
                "data_decoded": {
                    "method": "changeMasterCopy",
                    "parameters": [
                        {
                            "name": "_masterCopy",
                            "type": "address",
                            "value": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
                        }
                    ],
                },
            },
            {
                "operation": operation,
                "to": safe_contract_address,
                "value": value,
                "data": change_fallback_manager_data.hex(),
                "data_decoded": {
                    "method": "setFallbackHandler",
                    "parameters": [
                        {
                            "name": "handler",
                            "type": "address",
                            "value": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
                        }
                    ],
                },
            },
        ]
        # Get just the multisend object
        self.assertEqual(tx_decoder.decode_multisend_data(data), expected)

        # Now decode all the data
        expected = (
            "multiSend",
            [
                {
                    "name": "transactions",
                    "type": "bytes",
                    "value": "0x005b9ea52aaa931d4eef74c8aeaf0fe759434fed74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000247de7edef00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f005b9ea52aaa931d4eef74c8aeaf0fe759434fed7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024f08a0323000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf44",
                    "value_decoded": [
                        {
                            "operation": operation,
                            "to": safe_contract_address,
                            "value": value,
                            "data": change_master_copy_data.hex(),
                            "data_decoded": {
                                "method": "changeMasterCopy",
                                "parameters": [
                                    {
                                        "name": "_masterCopy",
                                        "type": "address",
                                        "value": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
                                    }
                                ],
                            },
                        },
                        {
                            "operation": operation,
                            "to": safe_contract_address,
                            "value": value,
                            "data": change_fallback_manager_data.hex(),
                            "data_decoded": {
                                "method": "setFallbackHandler",
                                "parameters": [
                                    {
                                        "name": "handler",
                                        "type": "address",
                                        "value": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
                                    }
                                ],
                            },
                        },
                    ],
                }
            ],
        )
        self.assertEqual(tx_decoder.decode_transaction_with_types(data), expected)

        # Safe tx decoder cannot decode it. It would be problematic for the internal tx indexer
        safe_tx_decoder = get_safe_tx_decoder()
        with self.assertRaises(CannotDecode):
            safe_tx_decoder.decode_transaction_with_types(data)

    def test_decode_multisend_not_valid(self):
        # Same data with some stuff deleted
        data = HexBytes(
            "0x8d80ff0a0000000000000000000000000000000000000000000000000000000000000020000000000000000000"
            "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            "000000000000000000000000000000247de7edef00000000000000000000000034cfac646f301356faa8b21e9422"
            "7e3583fe3f5f005b9ea52aaa931d4eef74c8aeaf0fe759434fed7400000000000000000000000000000000000000"
            "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024f0"
            "8a0323000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000"
            "000000"
        )
        tx_decoder = get_tx_decoder()
        self.assertEqual(tx_decoder.decode_multisend_data(data), [])
        self.assertEqual(
            tx_decoder.decode_transaction_with_types(data),
            (
                "multiSend",
                [
                    {
                        "name": "transactions",
                        "type": "bytes",
                        "value": "0x",
                        "value_decoded": [],
                    }
                ],
            ),
        )

    def test_decode_safe_exec_transaction(self):
        data = HexBytes(
            "0x6a761202000000000000000000000000b522a9f781924ed250a11c54105e51840b138add00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000bd4a50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066000000000000000000000000000000000000000000000000000000000000004e48d80ff0a0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000048f003d9819210a31b4961b30ef54be2aed79b9c9cd3b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000084c29982380000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000039aa39c021dfbae8fac545936693ac917d5e7563000000000000000000000000f650c3d88d12db855b8bf7d11be6c55a4e07dcc900a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b300000000000000000000000039aa39c021dfbae8fac545936693ac917d5e756300000000000000000000000000000000000000000000000000000000009896800039aa39c021dfbae8fac545936693ac917d5e756300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024a0712d68000000000000000000000000000000000000000000000000000000000098968000f650c3d88d12db855b8bf7d11be6c55a4e07dcc900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024c5ebeaec00000000000000000000000000000000000000000000000000000000001e848000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000006f400810b62df8e13fded51be75ff5393eaa841f00000000000000000000000000000000000000000000000000000000001e8480006f400810b62df8e13fded51be75ff5393eaa841f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a426c3d3940000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000005265c000000000000000000000000000000000000000000000000000000000001e5d7000000000000000000000000000000000000000000000000000000000001e8480006f400810b62df8e13fded51be75ff5393eaa841f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004447e7ef24000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000001e848000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000825cce27c16c9431409a311e1bfc7fb00cf28f223f309af6917bea47a1f787cb84117521c8dd216993ab576ddbf2850a65ed434577ae9153c666d96e9138ddcc901c000000000000000000000000ae5fb390e5c4fa1962e39e98dbfb0ed8055ed7a9000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000"
        )
        tx_decoder = get_tx_decoder()
        self.assertEqual(
            tx_decoder.get_data_decoded(data),
            {
                "method": "execTransaction",
                "parameters": [
                    {
                        "name": "to",
                        "type": "address",
                        "value": "0xB522a9f781924eD250A11C54105E51840B138AdD",
                    },
                    {"name": "value", "type": "uint256", "value": "0"},
                    {
                        "name": "data",
                        "type": "bytes",
                        "value": "0x8d80ff0a0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000048f003d9819210a31b4961b30ef54be2aed79b9c9cd3b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000084c29982380000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000039aa39c021dfbae8fac545936693ac917d5e7563000000000000000000000000f650c3d88d12db855b8bf7d11be6c55a4e07dcc900a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b300000000000000000000000039aa39c021dfbae8fac545936693ac917d5e756300000000000000000000000000000000000000000000000000000000009896800039aa39c021dfbae8fac545936693ac917d5e756300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024a0712d68000000000000000000000000000000000000000000000000000000000098968000f650c3d88d12db855b8bf7d11be6c55a4e07dcc900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024c5ebeaec00000000000000000000000000000000000000000000000000000000001e848000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000006f400810b62df8e13fded51be75ff5393eaa841f00000000000000000000000000000000000000000000000000000000001e8480006f400810b62df8e13fded51be75ff5393eaa841f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a426c3d3940000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000005265c000000000000000000000000000000000000000000000000000000000001e5d7000000000000000000000000000000000000000000000000000000000001e8480006f400810b62df8e13fded51be75ff5393eaa841f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004447e7ef24000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000001e84800000000000000000000000000000000000",
                        "value_decoded": {
                            "method": "multiSend",
                            "parameters": [
                                {
                                    "name": "transactions",
                                    "type": "bytes",
                                    "value": "0x003d9819210a31b4961b30ef54be2aed79b9c9cd3b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000084c29982380000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000039aa39c021dfbae8fac545936693ac917d5e7563000000000000000000000000f650c3d88d12db855b8bf7d11be6c55a4e07dcc900a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b300000000000000000000000039aa39c021dfbae8fac545936693ac917d5e756300000000000000000000000000000000000000000000000000000000009896800039aa39c021dfbae8fac545936693ac917d5e756300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024a0712d68000000000000000000000000000000000000000000000000000000000098968000f650c3d88d12db855b8bf7d11be6c55a4e07dcc900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024c5ebeaec00000000000000000000000000000000000000000000000000000000001e848000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000006f400810b62df8e13fded51be75ff5393eaa841f00000000000000000000000000000000000000000000000000000000001e8480006f400810b62df8e13fded51be75ff5393eaa841f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a426c3d3940000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000005265c000000000000000000000000000000000000000000000000000000000001e5d7000000000000000000000000000000000000000000000000000000000001e8480006f400810b62df8e13fded51be75ff5393eaa841f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004447e7ef24000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000001e8480",
                                    "value_decoded": [
                                        {
                                            "operation": 0,
                                            "to": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
                                            "value": "0",
                                            "data": "0xc29982380000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000039aa39c021dfbae8fac545936693ac917d5e7563000000000000000000000000f650c3d88d12db855b8bf7d11be6c55a4e07dcc9",
                                            "data_decoded": {
                                                "method": "enterMarkets",
                                                "parameters": [
                                                    {
                                                        "name": "cTokens",
                                                        "type": "address[]",
                                                        "value": [
                                                            "0x39AA39c021dfbaE8faC545936693aC917d5E7563",
                                                            "0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9",
                                                        ],
                                                    }
                                                ],
                                            },
                                        },
                                        {
                                            "operation": 0,
                                            "to": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                                            "value": "0",
                                            "data": "0x095ea7b300000000000000000000000039aa39c021dfbae8fac545936693ac917d5e75630000000000000000000000000000000000000000000000000000000000989680",
                                            "data_decoded": {
                                                "method": "approve",
                                                "parameters": [
                                                    {
                                                        "name": "spender",
                                                        "type": "address",
                                                        "value": "0x39AA39c021dfbaE8faC545936693aC917d5E7563",
                                                    },
                                                    {
                                                        "name": "value",
                                                        "type": "uint256",
                                                        "value": "10000000",
                                                    },
                                                ],
                                            },
                                        },
                                        {
                                            "operation": 0,
                                            "to": "0x39AA39c021dfbaE8faC545936693aC917d5E7563",
                                            "value": "0",
                                            "data": "0xa0712d680000000000000000000000000000000000000000000000000000000000989680",
                                            "data_decoded": {
                                                "method": "mint",
                                                "parameters": [
                                                    {
                                                        "name": "mintAmount",
                                                        "type": "uint256",
                                                        "value": "10000000",
                                                    }
                                                ],
                                            },
                                        },
                                        {
                                            "operation": 0,
                                            "to": "0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9",
                                            "value": "0",
                                            "data": "0xc5ebeaec00000000000000000000000000000000000000000000000000000000001e8480",
                                            "data_decoded": {
                                                "method": "borrow",
                                                "parameters": [
                                                    {
                                                        "name": "borrowAmount",
                                                        "type": "uint256",
                                                        "value": "2000000",
                                                    }
                                                ],
                                            },
                                        },
                                        {
                                            "operation": 0,
                                            "to": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
                                            "value": "0",
                                            "data": "0x095ea7b30000000000000000000000006f400810b62df8e13fded51be75ff5393eaa841f00000000000000000000000000000000000000000000000000000000001e8480",
                                            "data_decoded": {
                                                "method": "approve",
                                                "parameters": [
                                                    {
                                                        "name": "spender",
                                                        "type": "address",
                                                        "value": "0x6F400810b62df8E13fded51bE75fF5393eaa841F",
                                                    },
                                                    {
                                                        "name": "value",
                                                        "type": "uint256",
                                                        "value": "2000000",
                                                    },
                                                ],
                                            },
                                        },
                                        {
                                            "operation": 0,
                                            "to": "0x6F400810b62df8E13fded51bE75fF5393eaa841F",
                                            "value": "0",
                                            "data": "0x26c3d3940000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000005265c000000000000000000000000000000000000000000000000000000000001e5d7000000000000000000000000000000000000000000000000000000000001e8480",
                                            "data_decoded": {
                                                "method": "placeOrder",
                                                "parameters": [
                                                    {
                                                        "name": "buyToken",
                                                        "type": "uint16",
                                                        "value": "4",
                                                    },
                                                    {
                                                        "name": "sellToken",
                                                        "type": "uint16",
                                                        "value": "2",
                                                    },
                                                    {
                                                        "name": "validUntil",
                                                        "type": "uint32",
                                                        "value": "5400000",
                                                    },
                                                    {
                                                        "name": "buyAmount",
                                                        "type": "uint128",
                                                        "value": "1990000",
                                                    },
                                                    {
                                                        "name": "sellAmount",
                                                        "type": "uint128",
                                                        "value": "2000000",
                                                    },
                                                ],
                                            },
                                        },
                                        {
                                            "operation": 0,
                                            "to": "0x6F400810b62df8E13fded51bE75fF5393eaa841F",
                                            "value": "0",
                                            "data": "0x47e7ef24000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000000000000000000000000000000000000001e8480",
                                            "data_decoded": {
                                                "method": "deposit",
                                                "parameters": [
                                                    {
                                                        "name": "token",
                                                        "type": "address",
                                                        "value": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
                                                    },
                                                    {
                                                        "name": "amount",
                                                        "type": "uint256",
                                                        "value": "2000000",
                                                    },
                                                ],
                                            },
                                        },
                                    ],
                                }
                            ],
                        },
                    },
                    {"name": "operation", "type": "uint8", "value": "1"},
                    {"name": "safeTxGas", "type": "uint256", "value": "775333"},
                    {"name": "baseGas", "type": "uint256", "value": "0"},
                    {"name": "gasPrice", "type": "uint256", "value": "0"},
                    {
                        "name": "gasToken",
                        "type": "address",
                        "value": "0x0000000000000000000000000000000000000000",
                    },
                    {
                        "name": "refundReceiver",
                        "type": "address",
                        "value": "0x0000000000000000000000000000000000000000",
                    },
                    {
                        "name": "signatures",
                        "type": "bytes",
                        "value": "0x5cce27c16c9431409a311e1bfc7fb00cf28f223f309af6917bea47a1f787cb84117521c8dd216993ab576ddbf2850a65ed434577ae9153c666d96e9138ddcc901c000000000000000000000000ae5fb390e5c4fa1962e39e98dbfb0ed8055ed7a9000000000000000000000000000000000000000000000000000000000000000001",
                    },
                ],
            },
        )

    def test_supported_fn_selectors(self):
        for tx_decoder in (TxDecoder(), get_tx_decoder(), get_safe_tx_decoder()):
            self.assertIn(
                b"jv\x12\x02", tx_decoder.fn_selectors_with_abis
            )  # execTransaction for Safe >= V1.0.0
            self.assertIn(
                b"\xb6>\x80\r", tx_decoder.fn_selectors_with_abis
            )  # setup for Safe V1.1.0
            self.assertIn(
                b"\xa9z\xb1\x8a", tx_decoder.fn_selectors_with_abis
            )  # setup for Safe V1.0.0

    def test_db_tx_decoder(self):
        example_abi = [
            {
                "inputs": [
                    {"internalType": "uint256", "name": "droidId", "type": "uint256"},
                    {
                        "internalType": "uint256",
                        "name": "numberOfDroids",
                        "type": "uint256",
                    },
                ],
                "name": "buyDroid",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function",
            },
        ]

        example_data = (
            Web3()
            .eth.contract(abi=example_abi)
            .functions.buyDroid(4, 10)
            .build_transaction({"gas": 0, "gasPrice": 0, "to": NULL_ADDRESS})["data"]
        )

        db_tx_decoder = DbTxDecoder()
        with self.assertRaises(CannotDecode):
            db_tx_decoder.decode_transaction(example_data)

        # Test `add_abi`
        db_tx_decoder.add_abi(example_abi)
        fn_name, arguments = db_tx_decoder.decode_transaction(example_data)
        self.assertEqual(fn_name, "buyDroid")
        self.assertEqual(arguments, {"droidId": "4", "numberOfDroids": "10"})

        # Test load a new DbTxDecoder
        ContractAbiFactory(abi=example_abi)
        db_tx_decoder = DbTxDecoder()
        fn_name, arguments = db_tx_decoder.decode_transaction(example_data)
        self.assertEqual(fn_name, "buyDroid")
        self.assertEqual(arguments, {"droidId": "4", "numberOfDroids": "10"})

        # Swap ABI parameters
        swapped_abi = [
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "numberOfDroids",
                        "type": "uint256",
                    },
                    {"internalType": "uint256", "name": "droidId", "type": "uint256"},
                ],
                "name": "buyDroid",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function",
            },
        ]

        swapped_contract_abi = ContractAbiFactory(abi=swapped_abi)
        contract = ContractFactory(contract_abi=swapped_contract_abi)
        fn_name, arguments = db_tx_decoder.decode_transaction(
            example_data, address=contract.address
        )
        self.assertEqual(fn_name, "buyDroid")
        self.assertEqual(arguments, {"numberOfDroids": "4", "droidId": "10"})
        self.assertIn((contract.address,), DbTxDecoder.cache_abis_by_address)

'''
'''--- safe_transaction_service/contracts/tests/test_views.py ---
import logging
from urllib.parse import urljoin

from django.urls import reverse

from eth_account import Account
from rest_framework import status
from rest_framework.test import APITestCase

from .factories import ContractFactory

logger = logging.getLogger(__name__)

class TestContractViews(APITestCase):
    def _build_full_file_url(self, path: str):
        return urljoin("http://testserver/", path)

    def test_contract_view(self):
        contract_address = "0x"  # Invalid format
        response = self.client.get(
            reverse("v1:contracts:detail", args=(contract_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        contract_address = Account.create().address
        response = self.client.get(
            reverse("v1:contracts:detail", args=(contract_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        contract = ContractFactory(address=contract_address)
        response = self.client.get(
            reverse("v1:contracts:detail", args=(contract_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.data,
            {
                "address": contract.address,
                "name": contract.name,
                "display_name": contract.display_name,
                "logo_uri": self._build_full_file_url(contract.logo.url),
                "contract_abi": {
                    "abi": contract.contract_abi.abi,
                    "description": contract.contract_abi.description,
                    "relevance": contract.contract_abi.relevance,
                },
                "trusted_for_delegate_call": False,
            },
        )

        display_name = "SharinganContract"
        contract.contract_abi = None
        contract.display_name = display_name
        contract.logo = None
        contract.save()
        response = self.client.get(
            reverse("v1:contracts:detail", args=(contract_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.data,
            {
                "address": contract.address,
                "name": contract.name,
                "display_name": display_name,
                "logo_uri": None,
                "contract_abi": None,
                "trusted_for_delegate_call": False,
            },
        )

    def test_contracts_view(self):
        contract_address = Account.create().address
        response = self.client.get(reverse("v1:contracts:list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)
        self.assertEqual(response.data["results"], [])

        contract = ContractFactory(address=contract_address)
        response = self.client.get(reverse("v1:contracts:list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.data["results"],
            [
                {
                    "address": contract.address,
                    "name": contract.name,
                    "display_name": contract.display_name,
                    "logo_uri": self._build_full_file_url(contract.logo.url),
                    "contract_abi": {
                        "abi": contract.contract_abi.abi,
                        "description": contract.contract_abi.description,
                        "relevance": contract.contract_abi.relevance,
                    },
                    "trusted_for_delegate_call": False,
                }
            ],
        )

        ContractFactory(contract_abi__abi=[])
        response = self.client.get(reverse("v1:contracts:list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 2)

'''
'''--- safe_transaction_service/contracts/tx_decoder.py ---
import itertools
import operator
from functools import cache, cached_property
from logging import getLogger
from typing import (
    Any,
    Dict,
    Iterable,
    List,
    Optional,
    Sequence,
    Tuple,
    Type,
    TypedDict,
    Union,
    cast,
)

import gevent
from cachetools import TTLCache, cachedmethod
from eth_abi.exceptions import DecodingError
from eth_typing import ChecksumAddress, HexStr
from eth_utils import function_abi_to_4byte_selector
from hexbytes import HexBytes
from web3 import Web3
from web3._utils.abi import get_abi_input_names, get_abi_input_types, map_abi_data
from web3._utils.normalizers import BASE_RETURN_NORMALIZERS
from web3.contract import Contract
from web3.types import ABIFunction

from gnosis.eth.contracts import (
    get_erc20_contract,
    get_erc721_contract,
    get_kyber_network_proxy_contract,
    get_multi_send_contract,
    get_safe_V0_0_1_contract,
    get_safe_V1_0_0_contract,
    get_safe_V1_1_1_contract,
    get_safe_V1_3_0_contract,
    get_uniswap_exchange_contract,
)
from gnosis.safe.multi_send import MultiSend

from safe_transaction_service.contracts.models import ContractAbi
from safe_transaction_service.utils.utils import running_on_gevent

from .decoder_abis.aave import (
    aave_a_token,
    aave_lending_pool,
    aave_lending_pool_addresses_provider,
    aave_lending_pool_core,
)
from .decoder_abis.admin_upgradeability_proxy import (
    initializable_admin_upgradeability_proxy_abi,
)
from .decoder_abis.balancer import balancer_bactions, balancer_exchange_proxy
from .decoder_abis.chainlink import chainlink_token_abi
from .decoder_abis.compound import comptroller_abi, ctoken_abi
from .decoder_abis.gnosis_protocol import (
    fleet_factory_abi,
    fleet_factory_deterministic_abi,
    gnosis_protocol_abi,
)
from .decoder_abis.gnosis_safe import gnosis_safe_allowance_module_abi
from .decoder_abis.idle import idle_token_v3
from .decoder_abis.maker_dao import maker_dao_abis
from .decoder_abis.open_zeppelin import (
    open_zeppelin_admin_upgradeability_proxy,
    open_zeppelin_proxy_admin,
)
from .decoder_abis.request import (
    request_erc20_proxy,
    request_erc20_swap_to_pay,
    request_ethereum_proxy,
)
from .decoder_abis.sablier import sablier_abi, sablier_ctoken_manager, sablier_payroll
from .decoder_abis.sight import (
    conditional_token_abi,
    market_maker_abi,
    market_maker_factory_abi,
)
from .decoder_abis.snapshot import snapshot_delegate_registry_abi
from .decoder_abis.timelock import timelock_abi

logger = getLogger(__name__)

class TxDecoderException(Exception):
    pass

class UnexpectedProblemDecoding(TxDecoderException):
    pass

class CannotDecode(TxDecoderException):
    pass

class ParameterDecoded(TypedDict):
    name: str
    type: str
    value: Any

class DataDecoded(TypedDict):
    method: str
    parameters: List[ParameterDecoded]

class MultisendDecoded(TypedDict):
    operation: int
    to: ChecksumAddress
    value: str
    data: Optional[HexStr]
    data_decoded: Optional[DataDecoded]

@cache
def get_db_tx_decoder() -> "DbTxDecoder":
    def _get_db_tx_decoder() -> "DbTxDecoder":
        return DbTxDecoder()

    if running_on_gevent():
        # It's a very intensive CPU task, so to prevent blocking
        # http://www.gevent.org/api/gevent.threadpool.html
        pool = gevent.get_hub().threadpool
        return pool.spawn(_get_db_tx_decoder).get()
    return _get_db_tx_decoder()

def is_db_tx_decoder_loaded() -> bool:
    return get_db_tx_decoder.cache_info().currsize != 0

@cache
def get_tx_decoder() -> "TxDecoder":
    return TxDecoder()

@cache
def get_safe_tx_decoder() -> "SafeTxDecoder":
    return SafeTxDecoder()

class SafeTxDecoder:
    """
    Decode simple txs for Safe contracts. No multisend or nested transactions are decoded
    """

    EXEC_TRANSACTION_SELECTOR = HexBytes("0x6a761202")

    dummy_w3 = Web3()

    def __init__(self):
        logger.info("%s: Loading contract ABIs for decoding", self.__class__.__name__)
        self.fn_selectors_with_abis: Dict[
            bytes, ABIFunction
        ] = self._generate_selectors_with_abis_from_abis(self.get_supported_abis())
        logger.info(
            "%s: Contract ABIs for decoding were loaded", self.__class__.__name__
        )

    def get_abi_function(
        self, data: bytes, address: Optional[ChecksumAddress] = None
    ) -> Optional[ABIFunction]:
        """
        :param data: transaction data
        :param address: contract address in case of ABI colliding
        :return: Abi function for data if it can be decoded, `None` if not found
        """
        try:
            return self.fn_selectors_with_abis[data[:4]]
        except KeyError:
            return None

    def _decode_data(
        self, data: Union[bytes, str], address: Optional[ChecksumAddress] = None
    ) -> Tuple[str, List[Tuple[str, str, Any]]]:
        """
        Decode tx data

        :param data: Tx data as `hex string` or `bytes`
        :param address: contract address in case of ABI colliding
        :return: Tuple with the `function name` and a List of sorted tuples with
            the `name` of the argument, `type` and `value`
        :raises: CannotDecode if data cannot be decoded. You should catch this exception when using this function
        :raises: UnexpectedProblemDecoding if there's an unexpected problem decoding (it shouldn't happen)
        """

        if not data:
            raise CannotDecode(data)

        data = HexBytes(data)
        params = data[4:]
        fn_abi = self.get_abi_function(data, address)
        if not fn_abi:
            raise CannotDecode(data.hex())
        try:
            names = get_abi_input_names(fn_abi)
            types = get_abi_input_types(fn_abi)
            decoded = self.dummy_w3.codec.decode_abi(types, cast(HexBytes, params))
            normalized = map_abi_data(BASE_RETURN_NORMALIZERS, types, decoded)
            values = map(self._parse_decoded_arguments, normalized)
        except (ValueError, DecodingError) as exc:
            logger.warning("Cannot decode %s", data.hex())
            raise UnexpectedProblemDecoding(data) from exc

        return fn_abi["name"], list(zip(names, types, values))

    def _generate_selectors_with_abis_from_abi(
        self, abi: ABIFunction
    ) -> Dict[bytes, ABIFunction]:
        """
        :param abi: ABI
        :return: Dictionary with function selector as bytes and the ContractFunction
        """
        return {
            function_abi_to_4byte_selector(fn_abi): fn_abi
            for fn_abi in abi
            if fn_abi["type"] == "function"
        }

    def _generate_selectors_with_abis_from_abis(
        self, abis: Sequence[ABIFunction]
    ) -> Dict[bytes, ABIFunction]:
        """
        :param abis: Contract ABIs. Last ABIs on the Sequence have preference if there's a collision on the
        selector
        :return: Dictionary with function selector as bytes and the function abi
        """
        return {
            fn_selector: fn_abi
            for supported_abi in abis
            for fn_selector, fn_abi in self._generate_selectors_with_abis_from_abi(
                supported_abi
            ).items()
        }

    def _parse_decoded_arguments(self, value_decoded: Any) -> Any:
        """
        Parse decoded arguments, like converting `bytes` to hexadecimal `str` or `int` and `float` to `str` (to
        prevent problems when deserializing in another languages like JavaScript

        :param value_decoded:
        :return: Dict[str, Any]
        """
        if isinstance(value_decoded, bytes):
            value_decoded = HexBytes(value_decoded).hex()
        return value_decoded

    def add_abi(self, abi: ABIFunction) -> bool:
        """
        Add a new abi without rebuilding the entire decoder

        :return: True if decoder updated, False otherwise
        """
        updated = False
        for selector, new_abi in self._generate_selectors_with_abis_from_abi(
            abi
        ).items():
            if selector not in self.fn_selectors_with_abis:
                self.fn_selectors_with_abis[selector] = new_abi
                updated = True
        return updated

    def decode_parameters_data(
        self, data: bytes, parameters: Sequence[Dict[str, Any]]
    ) -> Sequence[Dict[str, Any]]:
        """
        Decode inner data for function parameters, e.g. Multisend `data` or `data` in Gnosis Safe `execTransaction`

        :param data:
        :param parameters:
        :return: Parameters with extra data
        """
        return parameters

    def decode_transaction_with_types(
        self, data: Union[bytes, str], address: Optional[ChecksumAddress] = None
    ) -> Tuple[str, List[ParameterDecoded]]:
        """
        Decode tx data and return a list of dictionaries

        :param data: Tx data as `hex string` or `bytes`
        :param address: contract address in case of ABI colliding
        :return: Tuple with the `function name` and a list of dictionaries
            [{'name': str, 'type': str, 'value': `depending on type`}...]
        :raises: CannotDecode if data cannot be decoded. You should catch this exception when using this function
        :raises: UnexpectedProblemDecoding if there's an unexpected problem decoding (it shouldn't happen)
        """
        data = HexBytes(data)
        fn_name, raw_parameters = self._decode_data(data, address=address)
        # Parameters are returned as tuple, convert it to a dictionary
        parameters = [
            {"name": name, "type": argument_type, "value": value}
            for name, argument_type, value in raw_parameters
        ]
        nested_parameters = self.decode_parameters_data(data, parameters)
        return fn_name, nested_parameters

    def decode_transaction(
        self, data: Union[bytes, str], address: Optional[ChecksumAddress] = None
    ) -> Tuple[str, Dict[str, Any]]:
        """
        Decode tx data and return all the parameters in the same dictionary

        :param data: Tx data as `hex string` or `bytes`
        :param address: contract address in case of ABI colliding
        :return: Tuple with the `function name` and a dictionary with the arguments of the function
        :raises: CannotDecode if data cannot be decoded. You should catch this exception when using this function
        :raises: UnexpectedProblemDecoding if there's an unexpected problem decoding (it shouldn't happen)
        """
        fn_name, decoded_transactions_with_types = self.decode_transaction_with_types(
            data, address=address
        )
        decoded_transactions = {
            d["name"]: d["value"] for d in decoded_transactions_with_types
        }
        return fn_name, decoded_transactions

    def get_supported_abis(self) -> Iterable[ABIFunction]:
        safe_abis = [
            get_safe_V0_0_1_contract(self.dummy_w3).abi,
            get_safe_V1_0_0_contract(self.dummy_w3).abi,
            get_safe_V1_1_1_contract(self.dummy_w3).abi,
            get_safe_V1_3_0_contract(self.dummy_w3).abi,
        ]

        # Order is important. If signature is the same (e.g. renaming of `baseGas`) last elements in the list
        # will take preference
        return safe_abis

    def get_data_decoded(
        self, data: Union[str, bytes], address: Optional[ChecksumAddress] = None
    ) -> Optional[DataDecoded]:
        """
        Return data prepared for serializing

        :param data:
        :param address: contract address in case of ABI colliding
        :return:
        """
        if not data:
            return None
        try:
            fn_name, parameters = self.decode_transaction_with_types(
                data, address=address
            )
            return {"method": fn_name, "parameters": parameters}
        except TxDecoderException:
            return None

class TxDecoder(SafeTxDecoder):
    """
    Decode MultiSend and use some hardcoded ABIs (Gnosis contracts, erc20/721 tokens...)
    """

    @cached_property
    def multisend_abis(self) -> List[ABIFunction]:
        return [get_multi_send_contract(self.dummy_w3).abi]

    @cached_property
    def multisend_fn_selectors_with_abis(self) -> Dict[bytes, ABIFunction]:
        return self._generate_selectors_with_abis_from_abis(self.multisend_abis)

    def decode_multisend_data(self, data: Union[bytes, str]) -> List[MultisendDecoded]:
        """
        Decodes Multisend raw data to Multisend dictionary

        :param data:
        :return:
        """
        try:
            multisend_txs = MultiSend.from_transaction_data(data)
            return [
                {
                    "operation": multisend_tx.operation.value,
                    "to": multisend_tx.to,
                    "value": str(multisend_tx.value),
                    "data": multisend_tx.data.hex() if multisend_tx.data else None,
                    "data_decoded": self.get_data_decoded(
                        multisend_tx.data, address=multisend_tx.to
                    ),
                }
                for multisend_tx in multisend_txs
            ]
        except ValueError:
            logger.warning(
                "Problem decoding multisend transaction with data=%s",
                HexBytes(data).hex(),
                exc_info=True,
            )

    def _parse_decoded_arguments(self, value_decoded: Any) -> Any:
        """
        Add custom parsing to the decoded function arguments. Convert numbers to strings and
        recursively parse lists, tuples and sets.

        :param value_decoded:
        :return:
        """
        value_decoded = super()._parse_decoded_arguments(value_decoded)
        if isinstance(value_decoded, (int, float)):
            value_decoded = str(
                value_decoded
            )  # Return numbers as `str` for json compatibility
        elif isinstance(value_decoded, (list, tuple, set)):
            value_decoded = [
                self._parse_decoded_arguments(e) for e in value_decoded
            ]  # Recursive parsing inside sequences
        return value_decoded

    def get_supported_abis(self) -> Iterable[ABIFunction]:
        supported_abis = super().get_supported_abis()

        aave_contracts = [
            aave_a_token,
            aave_lending_pool,
            aave_lending_pool_addresses_provider,
            aave_lending_pool_core,
        ]
        initializable_admin_upgradeability_proxy_contracts = [
            initializable_admin_upgradeability_proxy_abi
        ]
        balancer_contracts = [balancer_bactions, balancer_exchange_proxy]
        chainlink_contracts = [chainlink_token_abi]
        compound_contracts = [ctoken_abi, comptroller_abi]
        idle_contracts = [idle_token_v3]
        maker_dao_contracts = maker_dao_abis
        open_zeppelin_contracts = [
            open_zeppelin_admin_upgradeability_proxy,
            open_zeppelin_proxy_admin,
        ]
        request_contracts = [
            request_erc20_proxy,
            request_erc20_swap_to_pay,
            request_ethereum_proxy,
        ]
        sablier_contracts = [sablier_ctoken_manager, sablier_payroll, sablier_abi]

        snapshot_contracts = [snapshot_delegate_registry_abi]

        exchanges = [
            get_uniswap_exchange_contract(self.dummy_w3).abi,
            get_kyber_network_proxy_contract(self.dummy_w3).abi,
        ]

        sight_contracts = [
            conditional_token_abi,
            market_maker_abi,
            market_maker_factory_abi,
        ]
        gnosis_protocol = [
            gnosis_protocol_abi,
            fleet_factory_deterministic_abi,
            fleet_factory_abi,
        ]

        gnosis_safe = [gnosis_safe_allowance_module_abi]
        erc_contracts = [
            get_erc721_contract(self.dummy_w3).abi,
            get_erc20_contract(self.dummy_w3).abi,
        ]

        timelock_contracts = [timelock_abi]

        # Order is important. If signature is the same (e.g. renaming of `baseGas`) last elements in the list
        # will take preference
        return (
            timelock_contracts
            + initializable_admin_upgradeability_proxy_contracts
            + aave_contracts
            + balancer_contracts
            + chainlink_contracts
            + idle_contracts
            + maker_dao_contracts
            + request_contracts
            + sablier_contracts
            + snapshot_contracts
            + open_zeppelin_contracts
            + compound_contracts
            + exchanges
            + sight_contracts
            + gnosis_protocol
            + gnosis_safe
            + erc_contracts
            + self.multisend_abis
            + supported_abis
        )

    def decode_parameters_data(
        self, data: bytes, parameters: Sequence[Dict[str, Any]]
    ) -> Sequence[Dict[str, Any]]:
        """
        Decode inner data for function parameters, in this case Multisend `data` and
        `data` in Gnosis Safe `execTransaction`

        :param data:
        :param parameters:
        :return: Parameters with an extra object with key `value_decoded` if decoding is possible
        """
        fn_selector = data[:4]
        if fn_selector in self.multisend_fn_selectors_with_abis:
            # If multisend, decode the transactions
            parameters[0]["value_decoded"] = self.decode_multisend_data(data)

        elif (
            fn_selector == self.EXEC_TRANSACTION_SELECTOR
            and len(parameters) > 2
            and (data := HexBytes(parameters[2]["value"]))
        ):
            # If Gnosis Safe `execTransaction` decode the inner transaction
            # function execTransaction(address to, uint256 value, bytes calldata data...)
            # selector is `0x6a761202` and parameters[2] is data
            try:
                parameters[2]["value_decoded"] = self.get_data_decoded(
                    data, address=parameters[0]["value"]
                )
            except TxDecoderException:
                logger.warning("Cannot decode `execTransaction`", exc_info=True)
        return parameters

class DbTxDecoder(TxDecoder):
    """
    Decode contracts from ABIs in database
    """

    cache_abis_by_address = TTLCache(maxsize=2048, ttl=60 * 5)  # 5 minutes of caching

    @cachedmethod(cache=operator.attrgetter("cache_abis_by_address"))
    def get_contract_abi(
        self, address: ChecksumAddress
    ) -> Optional[Dict[bytes, ABIFunction]]:
        """
        :param address: Contract address
        :return: Dictionary of function selects with ABIFunction if found, `None` otherwise
        """
        abis = ContractAbi.objects.filter(contracts__address=address).values_list(
            "abi", flat=True
        )
        if abis:
            return self._generate_selectors_with_abis_from_abi(abis[0])

    def get_abi_function(
        self, data: bytes, address: Optional[ChecksumAddress] = None
    ) -> Optional[ABIFunction]:
        """
        :param data: transaction data
        :param address: contract address in case of ABI colliding
        :return: Abi function for data if it can be decoded, `None` if not found
        """
        selector = data[:4]
        # Check first that selector is supported on our database
        if selector in self.fn_selectors_with_abis:
            # Try to use specific ABI if address provided
            if address:
                contract_selectors_with_abis = self.get_contract_abi(address)
                if (
                    contract_selectors_with_abis
                    and selector in contract_selectors_with_abis
                ):
                    # If the selector is available in the abi specific for the address we will use that one
                    # Otherwise we fallback to the general abi that matches the selector
                    return contract_selectors_with_abis[selector]
            return self.fn_selectors_with_abis[selector]

    def get_supported_abis(self) -> Iterable[Type[Contract]]:
        supported_abis = super().get_supported_abis()
        db_abis = (
            ContractAbi.objects.all()
            .order_by("-relevance")
            .values_list("abi", flat=True)
            .iterator()
        )
        return itertools.chain(db_abis, supported_abis)

'''
'''--- safe_transaction_service/contracts/urls.py ---
from django.urls import path

from . import views

app_name = "contracts"

urlpatterns = [
    path("", views.ContractsView.as_view(), name="list"),
    path("<str:address>/", views.ContractView.as_view(), name="detail"),
]

'''
'''--- safe_transaction_service/contracts/views.py ---
from django.core.cache import cache as django_cache

import django_filters
from rest_framework.filters import OrderingFilter
from rest_framework.generics import ListAPIView, RetrieveAPIView

from . import pagination, serializers
from .models import Contract
from .signals import get_contract_cache_key

class ContractView(RetrieveAPIView):
    lookup_field = "address"
    queryset = Contract.objects.select_related("contract_abi")
    serializer_class = serializers.ContractSerializer

    def get(self, request, address, *args, **kwargs):
        cache_key = get_contract_cache_key(address)
        if not (response := django_cache.get(cache_key)):
            response = super().get(request, address, *args, **kwargs)
            response.add_post_render_callback(
                lambda r: (
                    django_cache.set(
                        cache_key, response, timeout=60 * 60
                    ),  # Cache 1 hour:
                    r,
                )[
                    1
                ]  # Return r, if not redis has issues
            )
        return response

class ContractsView(ListAPIView):
    filter_backends = [
        django_filters.rest_framework.DjangoFilterBackend,
        OrderingFilter,
    ]
    ordering = ["address"]
    ordering_fields = ["address", "name"]
    pagination_class = pagination.DefaultPagination
    queryset = Contract.objects.select_related("contract_abi")
    serializer_class = serializers.ContractSerializer

'''
'''--- safe_transaction_service/history/__init__.py ---

'''
'''--- safe_transaction_service/history/admin.py ---
from typing import Any, Optional

from django import forms
from django.contrib import admin
from django.db.models import Exists, F, OuterRef, Q
from django.db.models.functions import Greatest
from django.db.transaction import atomic
from django.http import HttpRequest

from hexbytes import HexBytes
from rest_framework.authtoken.admin import TokenAdmin

from gnosis.eth import EthereumClientProvider
from gnosis.eth.django.admin import BinarySearchAdmin
from gnosis.safe import SafeTx

from .models import (
    ERC20Transfer,
    ERC721Transfer,
    EthereumBlock,
    EthereumTx,
    IndexingStatus,
    InternalTx,
    InternalTxDecoded,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    ProxyFactory,
    SafeContract,
    SafeContractDelegate,
    SafeLastStatus,
    SafeMasterCopy,
    SafeStatus,
    WebHook,
)
from .services import IndexServiceProvider
from .utils import HexField

# By default, TokenAdmin doesn't allow key edition
# IFF you have a service that requests from multiple safe-transaction-service
# you might want to share that key for convenience between instances.
TokenAdmin.fields = (
    "user",
    "key",
)

# Inline objects ------------------------------
class ERC20TransferInline(admin.TabularInline):
    model = ERC20Transfer
    raw_id_fields = ("ethereum_tx",)

class ERC721TransferInline(admin.TabularInline):
    model = ERC721Transfer
    raw_id_fields = ("ethereum_tx",)

class EthereumTxInline(admin.TabularInline):
    model = EthereumTx
    raw_id_fields = ("block",)

class InternalTxDecodedInline(admin.TabularInline):
    model = InternalTxDecoded
    raw_id_fields = ("internal_tx",)

class MultisigTransactionInline(admin.TabularInline):
    model = MultisigTransaction
    raw_id_fields = ("ethereum_tx",)

class MultisigConfirmationInline(admin.TabularInline):
    model = MultisigConfirmation
    raw_id_fields = ("ethereum_tx", "multisig_transaction")

class SafeContractInline(admin.TabularInline):
    model = SafeContract
    raw_id_fields = ("ethereum_tx",)

class SafeContractDelegateInline(admin.TabularInline):
    model = SafeContractDelegate
    raw_id_fields = ("safe_contract",)

# Admin models ------------------------------
@admin.register(IndexingStatus)
class IndexingStatusAdmin(admin.ModelAdmin):
    list_display = (
        "indexing_type",
        "block_number",
    )
    list_filter = ("indexing_type",)
    search_fields = [
        "=block_number",
    ]
    ordering = ["-indexing_type"]

@admin.register(EthereumBlock)
class EthereumBlockAdmin(admin.ModelAdmin):
    date_hierarchy = "timestamp"
    inlines = (EthereumTxInline,)
    list_display = (
        "number",
        "timestamp",
        "confirmed",
        "gas_limit",
        "gas_used",
        "block_hash",
    )
    list_filter = ("confirmed",)
    search_fields = [
        "number",
        "=block_hash",
    ]
    ordering = ["-number"]

class TokenTransferAdmin(BinarySearchAdmin):
    date_hierarchy = "timestamp"
    list_display = (
        "timestamp",
        "block_number",
        "log_index",
        "address",
        "_from",
        "to",
        "value",
        "ethereum_tx_id",
    )
    list_select_related = ("ethereum_tx",)
    ordering = ["-timestamp"]
    search_fields = ["=_from", "=to", "=address", "=ethereum_tx__tx_hash"]
    raw_id_fields = ("ethereum_tx",)

@admin.register(ERC20Transfer)
class ERC20TransferAdmin(TokenTransferAdmin):
    actions = ["to_erc721"]

    @admin.action(description="Convert to ERC721 Transfer")
    @atomic
    def to_erc721(self, request, queryset):
        for element in queryset:
            element.to_erc721_transfer().save()
        queryset.delete()

@admin.register(ERC721Transfer)
class ERC721TransferAdmin(TokenTransferAdmin):
    actions = ["to_erc20"]

    @admin.action(description="Convert to ERC20 Transfer")
    @atomic
    def to_erc20(self, request, queryset):
        for element in queryset:
            element.to_erc20_transfer().save()
        queryset.delete()

@admin.register(EthereumTx)
class EthereumTxAdmin(BinarySearchAdmin):
    inlines = (
        ERC20TransferInline,
        ERC721TransferInline,
        SafeContractInline,
        MultisigTransactionInline,
        MultisigConfirmationInline,
    )
    list_display = ("block_id", "tx_hash", "nonce", "_from", "to")
    list_filter = ("status", "type")
    search_fields = ["=tx_hash", "=_from", "=to"]
    ordering = ["-block_id"]
    raw_id_fields = ("block",)

@admin.register(InternalTx)
class InternalTxAdmin(BinarySearchAdmin):
    date_hierarchy = "timestamp"
    inlines = (InternalTxDecodedInline,)
    list_display = (
        "timestamp",
        "block_number",
        "call_type",
        "ethereum_tx_id",
        "_from",
        "to",
        "value",
        "trace_address",
    )
    list_filter = ("tx_type", "call_type")
    list_select_related = ("ethereum_tx",)
    ordering = [
        "-block_number",
        "-ethereum_tx__transaction_index",
        "-pk",
    ]
    raw_id_fields = ("ethereum_tx",)
    search_fields = [
        "block_number",
        "=_from",
        "=to",
        "=ethereum_tx__tx_hash",
        "=contract_address",
    ]

class InternalTxDecodedOfficialListFilter(admin.SimpleListFilter):
    title = "Gnosis official Safes"
    parameter_name = "official_safes"

    def lookups(self, request, model_admin):
        return (("YES", "Yes"),)

    def queryset(self, request, queryset):
        if self.value() == "YES":
            return queryset.filter(
                Q(
                    Exists(
                        SafeContract.objects.filter(
                            address=OuterRef("internal_tx___from")
                        )
                    )
                )  # Just Safes indexed
                | Q(function_name="setup")  # Safes pending to be indexed
            )

@admin.register(InternalTxDecoded)
class InternalTxDecodedAdmin(BinarySearchAdmin):
    actions = ["process_again"]
    list_display = (
        "block_number",
        "processed",
        "internal_tx_id",
        "tx_hash",
        "address",
        "function_name",
        "arguments",
    )
    list_filter = ("function_name", "processed", InternalTxDecodedOfficialListFilter)
    list_select_related = ("internal_tx__ethereum_tx",)
    ordering = [
        "-internal_tx__block_number",
        "-internal_tx__ethereum_tx__transaction_index",
        "-internal_tx_id",
    ]
    raw_id_fields = ("internal_tx",)
    search_fields = [
        "function_name",
        "arguments",
        "=internal_tx__to",
        "=internal_tx___from",
        "=internal_tx__ethereum_tx__tx_hash",
        "=internal_tx__block_number",
    ]

    @admin.action(description="Process internal tx again")
    def process_again(self, request, queryset):
        queryset.filter(processed=True).update(processed=False)

class MultisigConfirmationListFilter(admin.SimpleListFilter):
    title = "Has multisig transaction"
    parameter_name = "has_multisig_tx"

    def lookups(self, request, model_admin):
        return (
            ("YES", "Yes"),
            ("NO", "No"),
        )

    def queryset(self, request, queryset):
        if self.value() == "YES":
            return queryset.exclude(multisig_transaction=None)
        elif self.value() == "NO":
            return queryset.filter(multisig_transaction=None)

@admin.register(MultisigConfirmation)
class MultisigConfirmationAdmin(BinarySearchAdmin):
    list_display = (
        "block_number",
        "multisig_transaction_hash",
        "has_multisig_tx",
        "ethereum_tx_id",
        "signature_type",
        "owner",
    )
    list_filter = (MultisigConfirmationListFilter, "signature_type")
    list_select_related = ("ethereum_tx",)
    ordering = ["-created"]
    raw_id_fields = ("ethereum_tx", "multisig_transaction")
    search_fields = [
        "=multisig_transaction__safe",
        "=ethereum_tx__tx_hash",
        "=multisig_transaction_hash",
        "=owner",
    ]

    @admin.display()
    def block_number(self, obj: MultisigConfirmation) -> Optional[int]:
        if obj.ethereum_tx:
            return obj.ethereum_tx.block_id

    @admin.display(boolean=True)
    def has_multisig_tx(self, obj: MultisigConfirmation) -> bool:
        return bool(obj.multisig_transaction_id)

class MultisigTransactionExecutedListFilter(admin.SimpleListFilter):
    title = "Executed"
    parameter_name = "executed"

    def lookups(self, request, model_admin):
        return (
            ("YES", "Transaction executed (mined)"),
            ("NO", "Transaction not executed"),
        )

    def queryset(self, request, queryset):
        if self.value() == "YES":
            return queryset.executed()
        elif self.value() == "NO":
            return queryset.not_executed()

class MultisigTransactionDataListFilter(admin.SimpleListFilter):
    title = "Has data"
    parameter_name = "has_data"

    def lookups(self, request, model_admin):
        return (
            ("YES", "Transaction has data"),
            ("NO", "Transaction data is empty"),
        )

    def queryset(self, request, queryset):
        if self.value() == "YES":
            return queryset.with_data()
        elif self.value() == "NO":
            return queryset.without_data()

class MultisigTransactionAdminForm(forms.ModelForm):
    data = HexField(required=False)

@admin.register(MultisigTransaction)
class MultisigTransactionAdmin(BinarySearchAdmin):
    date_hierarchy = "created"
    form = MultisigTransactionAdminForm
    inlines = (MultisigConfirmationInline,)
    list_display = (
        "created",
        "nonce",
        "safe",
        "executed",
        "successful",
        "safe_tx_hash",
        "ethereum_tx_id",
        "to",
        "value",
    )
    list_filter = (
        MultisigTransactionExecutedListFilter,
        MultisigTransactionDataListFilter,
        "operation",
        "failed",
        "trusted",
    )
    list_select_related = ("ethereum_tx",)
    ordering = ["-created"]
    raw_id_fields = ("ethereum_tx",)
    readonly_fields = ("safe_tx_hash",)
    search_fields = ["=ethereum_tx__tx_hash", "=safe", "=to", "=safe_tx_hash"]

    @admin.display(boolean=True)
    def executed(self, obj: MultisigTransaction):
        return obj.executed

    @admin.display(boolean=True)
    def successful(self, obj: MultisigTransaction):
        return not obj.failed

    def save_model(
        self, request: HttpRequest, obj: MultisigTransaction, form: Any, change: Any
    ) -> None:
        if obj.safe_tx_hash:
            # When modifying the primary key, another instance will be created so we delete the previous one if not executed
            MultisigTransaction.objects.not_executed().filter(
                safe_tx_hash=obj.safe_tx_hash
            ).delete()

        # Calculate new tx hash
        # All the numbers are decimals, they need to be parsed as integers for SafeTx
        safe_tx = SafeTx(
            EthereumClientProvider(),
            obj.safe,
            obj.to,
            int(obj.value),
            obj.data,
            int(obj.operation),
            int(obj.safe_tx_gas),
            int(obj.base_gas),
            int(obj.gas_price),
            obj.gas_token,
            obj.refund_receiver,
            obj.signatures,
            safe_nonce=int(obj.nonce),
        )
        obj.safe_tx_hash = safe_tx.safe_tx_hash
        return super().save_model(request, obj, form, change)

@admin.register(ModuleTransaction)
class ModuleTransactionAdmin(BinarySearchAdmin):
    date_hierarchy = "created"
    list_display = (
        "created",
        "failed",
        "safe",
        "tx_hash",
        "module",
        "to",
        "operation",
        "value",
        "data_hex",
    )
    list_filter = ("failed", "operation", "module")
    list_select_related = ("internal_tx",)
    ordering = ["-created"]
    raw_id_fields = ("internal_tx",)
    search_fields = ["=safe", "=module", "=to"]

    def data_hex(self, o: ModuleTransaction):
        return HexBytes(o.data.tobytes()).hex() if o.data else None

    def tx_hash(self, o: ModuleTransaction):
        return o.internal_tx.ethereum_tx_id

class MonitoredAddressAdmin(BinarySearchAdmin):
    actions = ["reindex", "reindex_last_day", "reindex_last_week", "reindex_last_month"]
    list_display = ("address", "initial_block_number", "tx_block_number")
    readonly_fields = ["initial_block_number"]
    search_fields = ["=address"]

    @admin.action(description="Reindex from initial block")
    def reindex(self, request, queryset):
        queryset.update(tx_block_number=F("initial_block_number"))

    @admin.action(description="Reindex last 24 hours")
    def reindex_last_day(self, request, queryset):
        queryset.update(
            tx_block_number=Greatest(
                F("tx_block_number") - 6000, F("initial_block_number")
            )
        )

    @admin.action(description="Reindex last week")
    def reindex_last_week(self, request, queryset):
        queryset.update(
            tx_block_number=Greatest(
                F("tx_block_number") - 42000, F("initial_block_number")
            )
        )

    @admin.action(description="Reindex last month")
    def reindex_last_month(self, request, queryset):
        queryset.update(
            tx_block_number=Greatest(
                F("tx_block_number") - 200000, F("initial_block_number")
            )
        )

@admin.register(SafeMasterCopy)
class SafeMasterCopyAdmin(MonitoredAddressAdmin):
    list_display = (
        "address",
        "initial_block_number",
        "tx_block_number",
        "version",
        "l2",
        "deployer",
    )
    list_filter = ("deployer",)

@admin.register(ProxyFactory)
class ProxyFactoryAdmin(MonitoredAddressAdmin):
    pass

class SafeContractERC20ListFilter(admin.SimpleListFilter):
    # Human-readable title which will be displayed in the
    # right admin sidebar just above the filter options.
    title = "ERC20 Indexation"

    # Parameter for the filter that will be used in the URL query.
    parameter_name = "erc20_indexation"

    def lookups(self, request, model_admin):
        return (
            ("YES", "ERC20 Indexation updated"),
            ("NO", "ERC20 Indexation not updated"),
        )

    def queryset(self, request, queryset):
        current_block_number = EthereumClientProvider().current_block_number
        condition = {"erc20_block_number__gte": current_block_number - 200}
        if self.value() == "YES":
            return queryset.filter(**condition)
        elif self.value() == "NO":
            return queryset.exclude(**condition)

@admin.register(SafeContract)
class SafeContractAdmin(BinarySearchAdmin):
    inlines = (SafeContractDelegateInline,)
    list_display = (
        "created_block_number",
        "address",
        "ethereum_tx_id",
    )
    list_filter = (SafeContractERC20ListFilter,)
    list_select_related = ("ethereum_tx",)
    ordering = ["-ethereum_tx__block_id"]
    raw_id_fields = ("ethereum_tx",)
    search_fields = ["=address", "=ethereum_tx__tx_hash"]

@admin.register(SafeContractDelegate)
class SafeContractDelegateAdmin(BinarySearchAdmin):
    list_display = ("safe_contract", "read", "write", "delegate", "delegator")
    list_filter = ("read", "write")
    ordering = ["safe_contract_id"]
    raw_id_fields = ("safe_contract",)
    search_fields = ["=safe_contract__address", "=delegate", "=delegator"]

class SafeStatusModulesListFilter(admin.SimpleListFilter):
    title = "Modules enabled in Safe"
    parameter_name = "enabled_modules"

    def lookups(self, request, model_admin):
        return (
            ("YES", "Yes"),
            ("NO", "No"),
        )

    def queryset(self, request, queryset):
        parameters = {"enabled_modules__len__gt": 0}
        if self.value() == "YES":
            return queryset.filter(**parameters)
        elif self.value() == "NO":
            return queryset.exclude(**parameters)

@admin.register(SafeLastStatus)
class SafeLastStatusAdmin(BinarySearchAdmin):
    actions = ["remove_and_index"]
    fields = (
        "internal_tx",
        "address",
        "owners",
        "threshold",
        "nonce",
        "master_copy",
        "fallback_handler",
        "enabled_modules",
        "function_name",
        "arguments",
    )
    readonly_fields = ("function_name", "arguments")
    list_display = (
        "block_number",
        "internal_tx_id",
        "function_name",
        "address",
        "owners",
        "threshold",
        "nonce",
        "master_copy",
        "fallback_handler",
        "guard",
        "enabled_modules",
    )
    list_filter = (
        "threshold",
        "master_copy",
        "fallback_handler",
        "guard",
        SafeStatusModulesListFilter,
    )
    list_select_related = ("internal_tx__ethereum_tx", "internal_tx__decoded_tx")
    ordering = ["-internal_tx__ethereum_tx__block_id", "-internal_tx_id"]
    raw_id_fields = ("internal_tx",)
    search_fields = [
        "=address",
        "owners__icontains",
        "=internal_tx__ethereum_tx__tx_hash",
        "enabled_modules__icontains",
    ]

    def function_name(self, obj: SafeStatus) -> str:
        return obj.internal_tx.decoded_tx.function_name

    def arguments(self, obj: SafeStatus) -> str:
        return obj.internal_tx.decoded_tx.arguments

    def has_delete_permission(self, request, obj=None):
        return False

    @admin.action(description="Remove and process transactions again")
    def remove_and_index(self, request, queryset):
        safe_addresses = list(queryset.distinct().values_list("address", flat=True))
        IndexServiceProvider().reprocess_addresses(safe_addresses)

@admin.register(SafeStatus)
class SafeStatusAdmin(SafeLastStatusAdmin):
    pass

@admin.register(WebHook)
class WebHookAdmin(BinarySearchAdmin):
    list_display = (
        "pk",
        "url",
        "authorization",
        "address",
        "pending_multisig_transaction",
        "new_confirmation",
        "new_executed_multisig_transaction",
        "new_incoming_transaction",
        "new_safe",
        "new_module_transaction",
        "new_outgoing_transaction",
    )
    list_filter = (
        "pending_multisig_transaction",
        "new_confirmation",
        "new_executed_multisig_transaction",
        "new_incoming_transaction",
        "new_safe",
        "new_module_transaction",
        "new_outgoing_transaction",
    )
    ordering = ["-pk"]
    search_fields = ["=address", "url"]

'''
'''--- safe_transaction_service/history/apps.py ---
from django.apps import AppConfig

class HistoryConfig(AppConfig):
    name = "safe_transaction_service.history"
    verbose_name = "Safe Transaction Service"

    def ready(self):
        from . import signals  # noqa

'''
'''--- safe_transaction_service/history/clients/__init__.py ---
# flake8: noqa F401
from .ens_client import EnsClient

'''
'''--- safe_transaction_service/history/clients/ens_client.py ---
from functools import lru_cache
from typing import Any, Dict, List, Optional, Union

import requests
from cache_memoize import cache_memoize
from hexbytes import HexBytes

class EnsClient:
    def __init__(self, network_id: int):
        base_url = "https://api.thegraph.com/subgraphs/name/ensdomains/"
        if network_id == 3:  # Ropsten
            url = base_url + "ensropsten"
        elif network_id == 4:  # Rinkeby
            url = base_url + "ensrinkeby"
        elif network_id == 5:  # Goerli
            url = base_url + "ensgoerli"
        else:  # Fallback to mainnet
            url = base_url + "ens"
        self.url: str = url
        self.request_timeout = 5  # Seconds
        self.request_session = requests.Session()

    def is_available(self):
        """
        :return: True if service is available, False if it's down
        """
        try:
            return self.request_session.get(self.url, timeout=self.request_timeout).ok
        except IOError:
            return False

    @staticmethod
    def domain_hash_to_hex_str(domain_hash: Union[str, bytes, int]) -> str:
        """
        :param domain_hash:
        :return: Domain hash as an hex string of 66 chars (counting with 0x), padding with zeros if needed
        """
        if not domain_hash:
            domain_hash = b""
        return "0x" + HexBytes(domain_hash).hex()[2:].rjust(64, "0")

    @lru_cache
    @cache_memoize(60 * 60 * 24, prefix="ens-_query_by_domain_hash")  # 1 day
    def _query_by_domain_hash(self, domain_hash_str: str) -> Optional[str]:
        query = """
                {
                    domains(where: {labelhash: "domain_hash"}) {
                        labelName
                    }
                }
                """.replace(
            "domain_hash", domain_hash_str
        )
        try:
            r = self.request_session.post(
                self.url, json={"query": query}, timeout=self.request_timeout
            )
        except IOError:
            return None

        if not r.ok:
            return None

        """
        Example:
        {
            "data": {
                "domains": [
                    {
                        "labelName": "safe-multisig"
                    }
                ]
            }
        }
        """
        data = r.json()
        if data:
            domains = data.get("data", {}).get("domains")
            if domains:
                return domains[0].get("labelName")

    def query_by_domain_hash(
        self, domain_hash: Union[str, bytes, int]
    ) -> Optional[str]:
        """
        Get domain label from domain_hash (keccak of domain name without the TLD, don't confuse with namehash)
        used for ENS ERC721 token_id. Use another method for caching purposes (use same parameter type)

        :param domain_hash: keccak of domain name without the TLD, don't confuse with namehash. E.g. For
            batman.eth it would be just keccak('batman')
        :return: domain label if found
        """
        domain_hash_str = self.domain_hash_to_hex_str(domain_hash)
        return self._query_by_domain_hash(domain_hash_str)

    def query_by_account(self, account: str) -> Optional[List[Dict[str, Any]]]:
        """
        :param account: ethereum account to search for ENS registered addresses
        :return: None if there's a problem or not found, otherwise example of dictionary returned:
        {
            "registrations": [
                {
                    "domain": {
                        "isMigrated": true,
                        "labelName": "gilfoyle",
                        "labelhash": "0xadfd886b420023026d5c0b1be0ffb5f18bb2f37143dff545aeaea0d23a4ba910",
                        "name": "gilfoyle.eth",
                        "parent": {
                            "name": "eth"
                        }
                    },
                    "expiryDate": "1905460880"
                }
            ]
        }
        """
        query = """query getRegistrations {
          account(id: "account_id") {
            registrations {
              expiryDate
              domain {
                labelName
                labelhash
                name
                isMigrated
                parent {
                  name
                }
              }
            }
          }
        }""".replace(
            "account_id", account.lower()
        )
        try:
            r = self.request_session.post(
                self.url, json={"query": query}, timeout=self.request_timeout
            )
        except IOError:
            return None

        if not r.ok:
            return None
        else:
            data = r.json()
            if data:
                return data.get("data", {}).get("account")

'''
'''--- safe_transaction_service/history/exceptions.py ---
import logging

from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import exception_handler

logger = logging.getLogger(__name__)

def custom_exception_handler(exc, context):

    if isinstance(exc, NodeConnectionException):
        response = Response(status=status.HTTP_503_SERVICE_UNAVAILABLE)

        if str(exc):
            exception_str = "{}: {}".format(exc.__class__.__name__, exc)
        else:
            exception_str = exc.__class__.__name__
        response.data = {
            "exception": "Problem connecting to Ethereum network",
            "trace": exception_str,
        }

        logger.warning(
            "%s - Exception: %s - Data received %s",
            context["request"].build_absolute_uri(),
            exception_str,
            context["request"].data,
            exc_info=exc,
        )
    else:
        # Call REST framework's default exception handler,
        # to get the standard error response.
        response = exception_handler(exc, context)

    return response

class NodeConnectionException(IOError):
    pass

'''
'''--- safe_transaction_service/history/filters.py ---
from django.db.models import Q

import django_filters
from django_filters import rest_framework as filters
from rest_framework.exceptions import ValidationError

from gnosis.eth.django.filters import EthereumAddressFilter, Keccak256Filter
from gnosis.eth.django.models import (
    EthereumAddressField,
    EthereumAddressV2Field,
    Keccak256Field,
    Uint256Field,
)

from .models import ModuleTransaction, MultisigTransaction

filter_overrides = {
    Uint256Field: {"filter_class": django_filters.NumberFilter},
    Keccak256Field: {"filter_class": Keccak256Filter},
    EthereumAddressField: {"filter_class": EthereumAddressFilter},
    EthereumAddressV2Field: {"filter_class": EthereumAddressFilter},
}

class DelegateListFilter(filters.FilterSet):
    safe = EthereumAddressFilter(field_name="safe_contract_id")
    delegate = EthereumAddressFilter()
    delegator = EthereumAddressFilter()
    label = django_filters.CharFilter()

    def filter_queryset(self, queryset):
        # Check at least one value is present
        for name, value in self.form.cleaned_data.items():
            if value:
                return super().filter_queryset(queryset)
        raise ValidationError("At least one query param must be provided")

class TransferListFilter(filters.FilterSet):
    _from = EthereumAddressFilter()
    block_number = django_filters.NumberFilter(field_name="block")
    block_number__gt = django_filters.NumberFilter(field_name="block", lookup_expr="gt")
    block_number__lt = django_filters.NumberFilter(field_name="block", lookup_expr="lt")
    execution_date__gte = django_filters.IsoDateTimeFilter(
        field_name="execution_date", lookup_expr="gte"
    )
    execution_date__lte = django_filters.IsoDateTimeFilter(
        field_name="execution_date", lookup_expr="lte"
    )
    execution_date__gt = django_filters.IsoDateTimeFilter(
        field_name="execution_date", lookup_expr="gt"
    )
    execution_date__lt = django_filters.IsoDateTimeFilter(
        field_name="execution_date", lookup_expr="lt"
    )
    to = EthereumAddressFilter()
    token_address = EthereumAddressFilter()
    transaction_hash = Keccak256Filter(field_name="transaction_hash")
    value = django_filters.NumberFilter(field_name="_value")
    value__gt = django_filters.NumberFilter(field_name="_value", lookup_expr="gt")
    value__lt = django_filters.NumberFilter(field_name="_value", lookup_expr="lt")
    erc20 = django_filters.BooleanFilter(method="filter_erc20")
    erc721 = django_filters.BooleanFilter(method="filter_erc721")
    ether = django_filters.BooleanFilter(method="filter_ether")

    def filter_erc20(self, queryset, name: str, value: bool):
        query = ~Q(_value=None) & ~Q(token_address=None)
        if value:
            return queryset.filter(query)
        else:
            return queryset.exclude(query)

    def filter_erc721(self, queryset, name: str, value: bool):
        query = ~Q(_token_id=None)
        if value:
            return queryset.filter(query)
        else:
            return queryset.exclude(query)

    def filter_ether(self, queryset, name: str, value: bool):
        query = ~Q(_value=None) & Q(token_address=None)
        if value:
            return queryset.filter(query)
        else:
            return queryset.exclude(query)

class MultisigTransactionFilter(filters.FilterSet):
    executed = django_filters.BooleanFilter(method="filter_executed")
    has_confirmations = django_filters.BooleanFilter(method="filter_confirmations")
    trusted = django_filters.BooleanFilter(method="filter_trusted")
    execution_date__gte = django_filters.IsoDateTimeFilter(
        field_name="ethereum_tx__block__timestamp", lookup_expr="gte"
    )
    execution_date__lte = django_filters.IsoDateTimeFilter(
        field_name="ethereum_tx__block__timestamp", lookup_expr="lte"
    )
    submission_date__gte = django_filters.IsoDateTimeFilter(
        field_name="created", lookup_expr="gte"
    )
    submission_date__lte = django_filters.IsoDateTimeFilter(
        field_name="created", lookup_expr="lte"
    )
    transaction_hash = Keccak256Filter(field_name="ethereum_tx_id")

    def filter_confirmations(self, queryset, name: str, value: bool):
        if value:
            return queryset.with_confirmations()
        else:
            return queryset.without_confirmations()

    def filter_executed(self, queryset, name: str, value: bool):
        if value:
            return queryset.executed()
        else:
            return queryset.not_executed()

    def filter_trusted(self, queryset, name: str, value: bool):
        return queryset.filter(trusted=value)

    class Meta:
        model = MultisigTransaction
        fields = {
            "failed": ["exact"],
            "modified": ["lt", "gt", "lte", "gte"],
            "nonce": ["lt", "gt", "lte", "gte", "exact"],
            "safe_tx_hash": ["exact"],
            "to": ["exact"],
            "value": ["lt", "gt", "exact"],
        }
        filter_overrides = filter_overrides

class ModuleTransactionFilter(filters.FilterSet):
    block_number = django_filters.NumberFilter(
        field_name="internal_tx__ethereum_tx__block_id"
    )
    block_number__gt = django_filters.NumberFilter(
        field_name="internal_tx__ethereum_tx__block_id", lookup_expr="gt"
    )
    block_number__lt = django_filters.NumberFilter(
        field_name="internal_tx__ethereum_tx__block_id", lookup_expr="lt"
    )
    transaction_hash = Keccak256Filter(field_name="internal_tx__ethereum_tx_id")

    class Meta:
        model = ModuleTransaction
        fields = {
            "safe": ["exact"],
            "module": ["exact"],
            "to": ["exact"],
            "operation": ["exact"],
            "failed": ["exact"],
        }

        filter_overrides = filter_overrides

class AnalyticsMultisigTxsByOriginFilter(filters.FilterSet):
    class Meta:
        model = MultisigTransaction
        fields = {
            "safe": ["exact"],
            "to": ["exact"],
            "value": ["lt", "gt", "lte", "gte", "exact"],
            "operation": ["exact"],
            "failed": ["exact"],
            "safe_tx_gas": ["lt", "gt", "lte", "gte", "exact"],
            "base_gas": ["lt", "gt", "lte", "gte", "exact"],
            "gas_price": ["lt", "gt", "lte", "gte", "exact"],
            "gas_token": ["exact"],
            "refund_receiver": ["exact"],
            "trusted": ["exact"],
        }

        filter_overrides = filter_overrides

class AnalyticsMultisigTxsBySafeFilter(filters.FilterSet):
    master_copy = EthereumAddressFilter()

'''
'''--- safe_transaction_service/history/helpers.py ---
import time
from typing import List

from eth_typing import ChecksumAddress
from eth_utils import keccak

class DelegateSignatureHelper:
    @classmethod
    def calculate_totp(
        cls, totp_tx: int = 3600, totp_t0: int = 0, previous: bool = False
    ) -> int:
        """
        https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm

        :param totp_tx: the Unix time from which to start counting time steps (default is 0)
        :param totp_t0: an interval which will be used to calculate the value of the
            counter CT (default is 3600 seconds).
        :param previous: Calculate totp for the previous interval
        :return: totp
        """
        if previous:
            totp_t0 += totp_tx  # Allow previous interval

        return int((time.time() - totp_t0) // totp_tx)

    @classmethod
    def calculate_hash(
        cls,
        address: ChecksumAddress,
        eth_sign: bool = False,
        previous_totp: bool = False,
    ) -> bytes:
        totp = cls.calculate_totp(previous=previous_totp)
        message = address + str(totp)
        if eth_sign:
            return keccak(
                text="\x19Ethereum Signed Message:\n" + str(len(message)) + message
            )
        else:
            return keccak(text=message)

    @classmethod
    def calculate_all_possible_hashes(cls, delegate: ChecksumAddress) -> List[bytes]:
        return [
            cls.calculate_hash(delegate),
            cls.calculate_hash(delegate, eth_sign=True),
            cls.calculate_hash(delegate, previous_totp=True),
            cls.calculate_hash(delegate, eth_sign=True, previous_totp=True),
        ]

'''
'''--- safe_transaction_service/history/indexers/__init__.py ---
# flake8: noqa F401
from .erc20_events_indexer import Erc20EventsIndexer, Erc20EventsIndexerProvider
from .ethereum_indexer import EthereumIndexer, FindRelevantElementsException
from .internal_tx_indexer import InternalTxIndexer, InternalTxIndexerProvider
from .proxy_factory_indexer import ProxyFactoryIndexer, ProxyFactoryIndexerProvider
from .safe_events_indexer import SafeEventsIndexer, SafeEventsIndexerProvider

'''
'''--- safe_transaction_service/history/indexers/abis/__init__.py ---

'''
'''--- safe_transaction_service/history/indexers/abis/gnosis.py ---
gnosis_safe_l2_v1_3_0_abi = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "owner",
                "type": "address",
            }
        ],
        "name": "AddedOwner",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "bytes32",
                "name": "approvedHash",
                "type": "bytes32",
            },
            {
                "indexed": True,
                "internalType": "address",
                "name": "owner",
                "type": "address",
            },
        ],
        "name": "ApproveHash",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "handler",
                "type": "address",
            }
        ],
        "name": "ChangedFallbackHandler",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "guard",
                "type": "address",
            }
        ],
        "name": "ChangedGuard",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "threshold",
                "type": "uint256",
            }
        ],
        "name": "ChangedThreshold",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "module",
                "type": "address",
            }
        ],
        "name": "DisabledModule",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "module",
                "type": "address",
            }
        ],
        "name": "EnabledModule",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "bytes32",
                "name": "txHash",
                "type": "bytes32",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "payment",
                "type": "uint256",
            },
        ],
        "name": "ExecutionFailure",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "module",
                "type": "address",
            }
        ],
        "name": "ExecutionFromModuleFailure",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "module",
                "type": "address",
            }
        ],
        "name": "ExecutionFromModuleSuccess",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "bytes32",
                "name": "txHash",
                "type": "bytes32",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "payment",
                "type": "uint256",
            },
        ],
        "name": "ExecutionSuccess",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "owner",
                "type": "address",
            }
        ],
        "name": "RemovedOwner",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "module",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "value",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "bytes",
                "name": "data",
                "type": "bytes",
            },
            {
                "indexed": False,
                "internalType": "enum Enum.Operation",
                "name": "operation",
                "type": "uint8",
            },
        ],
        "name": "SafeModuleTransaction",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "address",
                "name": "to",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "value",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "bytes",
                "name": "data",
                "type": "bytes",
            },
            {
                "indexed": False,
                "internalType": "enum Enum.Operation",
                "name": "operation",
                "type": "uint8",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "safeTxGas",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "baseGas",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "gasPrice",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "gasToken",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address payable",
                "name": "refundReceiver",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "bytes",
                "name": "signatures",
                "type": "bytes",
            },
            {
                "indexed": False,
                "internalType": "bytes",
                "name": "additionalInfo",
                "type": "bytes",
            },
        ],
        "name": "SafeMultiSigTransaction",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "sender",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "value",
                "type": "uint256",
            },
        ],
        "name": "SafeReceived",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "address",
                "name": "initiator",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address[]",
                "name": "owners",
                "type": "address[]",
            },
            {
                "indexed": False,
                "internalType": "uint256",
                "name": "threshold",
                "type": "uint256",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "initializer",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "fallbackHandler",
                "type": "address",
            },
        ],
        "name": "SafeSetup",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": True,
                "internalType": "bytes32",
                "name": "msgHash",
                "type": "bytes32",
            }
        ],
        "name": "SignMsg",
        "type": "event",
    },
    {"stateMutability": "nonpayable", "type": "fallback"},
    {
        "inputs": [],
        "name": "VERSION",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "owner", "type": "address"},
            {"internalType": "uint256", "name": "_threshold", "type": "uint256"},
        ],
        "name": "addOwnerWithThreshold",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "bytes32", "name": "hashToApprove", "type": "bytes32"}
        ],
        "name": "approveHash",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "", "type": "address"},
            {"internalType": "bytes32", "name": "", "type": "bytes32"},
        ],
        "name": "approvedHashes",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "_threshold", "type": "uint256"}
        ],
        "name": "changeThreshold",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "bytes32", "name": "dataHash", "type": "bytes32"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {"internalType": "bytes", "name": "signatures", "type": "bytes"},
            {
                "internalType": "uint256",
                "name": "requiredSignatures",
                "type": "uint256",
            },
        ],
        "name": "checkNSignatures",
        "outputs": [],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "bytes32", "name": "dataHash", "type": "bytes32"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {"internalType": "bytes", "name": "signatures", "type": "bytes"},
        ],
        "name": "checkSignatures",
        "outputs": [],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "prevModule", "type": "address"},
            {"internalType": "address", "name": "module", "type": "address"},
        ],
        "name": "disableModule",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "domainSeparator",
        "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "address", "name": "module", "type": "address"}],
        "name": "enableModule",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {
                "internalType": "enum Enum.Operation",
                "name": "operation",
                "type": "uint8",
            },
            {"internalType": "uint256", "name": "safeTxGas", "type": "uint256"},
            {"internalType": "uint256", "name": "baseGas", "type": "uint256"},
            {"internalType": "uint256", "name": "gasPrice", "type": "uint256"},
            {"internalType": "address", "name": "gasToken", "type": "address"},
            {"internalType": "address", "name": "refundReceiver", "type": "address"},
            {"internalType": "uint256", "name": "_nonce", "type": "uint256"},
        ],
        "name": "encodeTransactionData",
        "outputs": [{"internalType": "bytes", "name": "", "type": "bytes"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {
                "internalType": "enum Enum.Operation",
                "name": "operation",
                "type": "uint8",
            },
            {"internalType": "uint256", "name": "safeTxGas", "type": "uint256"},
            {"internalType": "uint256", "name": "baseGas", "type": "uint256"},
            {"internalType": "uint256", "name": "gasPrice", "type": "uint256"},
            {"internalType": "address", "name": "gasToken", "type": "address"},
            {
                "internalType": "address payable",
                "name": "refundReceiver",
                "type": "address",
            },
            {"internalType": "bytes", "name": "signatures", "type": "bytes"},
        ],
        "name": "execTransaction",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {
                "internalType": "enum Enum.Operation",
                "name": "operation",
                "type": "uint8",
            },
        ],
        "name": "execTransactionFromModule",
        "outputs": [{"internalType": "bool", "name": "success", "type": "bool"}],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {
                "internalType": "enum Enum.Operation",
                "name": "operation",
                "type": "uint8",
            },
        ],
        "name": "execTransactionFromModuleReturnData",
        "outputs": [
            {"internalType": "bool", "name": "success", "type": "bool"},
            {"internalType": "bytes", "name": "returnData", "type": "bytes"},
        ],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "getChainId",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "start", "type": "address"},
            {"internalType": "uint256", "name": "pageSize", "type": "uint256"},
        ],
        "name": "getModulesPaginated",
        "outputs": [
            {"internalType": "address[]", "name": "array", "type": "address[]"},
            {"internalType": "address", "name": "next", "type": "address"},
        ],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "getOwners",
        "outputs": [{"internalType": "address[]", "name": "", "type": "address[]"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "offset", "type": "uint256"},
            {"internalType": "uint256", "name": "length", "type": "uint256"},
        ],
        "name": "getStorageAt",
        "outputs": [{"internalType": "bytes", "name": "", "type": "bytes"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "getThreshold",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {
                "internalType": "enum Enum.Operation",
                "name": "operation",
                "type": "uint8",
            },
            {"internalType": "uint256", "name": "safeTxGas", "type": "uint256"},
            {"internalType": "uint256", "name": "baseGas", "type": "uint256"},
            {"internalType": "uint256", "name": "gasPrice", "type": "uint256"},
            {"internalType": "address", "name": "gasToken", "type": "address"},
            {"internalType": "address", "name": "refundReceiver", "type": "address"},
            {"internalType": "uint256", "name": "_nonce", "type": "uint256"},
        ],
        "name": "getTransactionHash",
        "outputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "address", "name": "module", "type": "address"}],
        "name": "isModuleEnabled",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "address", "name": "owner", "type": "address"}],
        "name": "isOwner",
        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "nonce",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "prevOwner", "type": "address"},
            {"internalType": "address", "name": "owner", "type": "address"},
            {"internalType": "uint256", "name": "_threshold", "type": "uint256"},
        ],
        "name": "removeOwner",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {
                "internalType": "enum Enum.Operation",
                "name": "operation",
                "type": "uint8",
            },
        ],
        "name": "requiredTxGas",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "address", "name": "handler", "type": "address"}],
        "name": "setFallbackHandler",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "address", "name": "guard", "type": "address"}],
        "name": "setGuard",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address[]", "name": "_owners", "type": "address[]"},
            {"internalType": "uint256", "name": "_threshold", "type": "uint256"},
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {"internalType": "address", "name": "fallbackHandler", "type": "address"},
            {"internalType": "address", "name": "paymentToken", "type": "address"},
            {"internalType": "uint256", "name": "payment", "type": "uint256"},
            {
                "internalType": "address payable",
                "name": "paymentReceiver",
                "type": "address",
            },
        ],
        "name": "setup",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "bytes32", "name": "", "type": "bytes32"}],
        "name": "signedMessages",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "targetContract", "type": "address"},
            {"internalType": "bytes", "name": "calldataPayload", "type": "bytes"},
        ],
        "name": "simulateAndRevert",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "prevOwner", "type": "address"},
            {"internalType": "address", "name": "oldOwner", "type": "address"},
            {"internalType": "address", "name": "newOwner", "type": "address"},
        ],
        "name": "swapOwner",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {"stateMutability": "payable", "type": "receive"},
]

proxy_factory_v1_3_0_abi = [
    {
        "anonymous": False,
        "inputs": [
            {
                "indexed": False,
                "internalType": "contract GnosisSafeProxy",
                "name": "proxy",
                "type": "address",
            },
            {
                "indexed": False,
                "internalType": "address",
                "name": "singleton",
                "type": "address",
            },
        ],
        "name": "ProxyCreation",
        "type": "event",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "_singleton", "type": "address"},
            {"internalType": "bytes", "name": "initializer", "type": "bytes"},
            {"internalType": "uint256", "name": "saltNonce", "type": "uint256"},
        ],
        "name": "calculateCreateProxyWithNonceAddress",
        "outputs": [
            {
                "internalType": "contract GnosisSafeProxy",
                "name": "proxy",
                "type": "address",
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "singleton", "type": "address"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
        ],
        "name": "createProxy",
        "outputs": [
            {
                "internalType": "contract GnosisSafeProxy",
                "name": "proxy",
                "type": "address",
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "_singleton", "type": "address"},
            {"internalType": "bytes", "name": "initializer", "type": "bytes"},
            {"internalType": "uint256", "name": "saltNonce", "type": "uint256"},
            {
                "internalType": "contract IProxyCreationCallback",
                "name": "callback",
                "type": "address",
            },
        ],
        "name": "createProxyWithCallback",
        "outputs": [
            {
                "internalType": "contract GnosisSafeProxy",
                "name": "proxy",
                "type": "address",
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "address", "name": "_singleton", "type": "address"},
            {"internalType": "bytes", "name": "initializer", "type": "bytes"},
            {"internalType": "uint256", "name": "saltNonce", "type": "uint256"},
        ],
        "name": "createProxyWithNonce",
        "outputs": [
            {
                "internalType": "contract GnosisSafeProxy",
                "name": "proxy",
                "type": "address",
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "proxyCreationCode",
        "outputs": [{"internalType": "bytes", "name": "", "type": "bytes"}],
        "stateMutability": "pure",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "proxyRuntimeCode",
        "outputs": [{"internalType": "bytes", "name": "", "type": "bytes"}],
        "stateMutability": "pure",
        "type": "function",
    },
]

'''
'''--- safe_transaction_service/history/indexers/erc20_events_indexer.py ---
import operator
from collections import OrderedDict
from logging import getLogger
from typing import Iterator, List, Optional, Sequence

from django.db.models import QuerySet

from cache_memoize import cache_memoize
from cachetools import cachedmethod
from eth_abi.exceptions import DecodingError
from eth_typing import ChecksumAddress
from web3.contract import ContractEvent
from web3.exceptions import BadFunctionCallOutput
from web3.types import EventData, LogReceipt

from gnosis.eth import EthereumClient

from safe_transaction_service.tokens.models import Token

from ..models import (
    ERC20Transfer,
    ERC721Transfer,
    IndexingStatus,
    MonitoredAddress,
    SafeContract,
    TokenTransfer,
)
from .events_indexer import EventsIndexer

logger = getLogger(__name__)

class Erc20EventsIndexerProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            from django.conf import settings

            cls.instance = Erc20EventsIndexer(
                EthereumClient(settings.ETHEREUM_NODE_URL)
            )
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class Erc20EventsIndexer(EventsIndexer):
    _cache_is_erc20 = {}

    """
    Indexes ERC20 and ERC721 `Transfer` Event (as ERC721 has the same topic)
    """

    @property
    def contract_events(self) -> List[ContractEvent]:
        """
        :return: Web3 ContractEvent to listen to
        """
        return []  # Use custom function to get transfer events

    @property
    def database_field(self):
        return "erc20_block_number"

    @property
    def database_queryset(self):
        return SafeContract.objects.all()

    def _do_node_query(
        self,
        addresses: List[ChecksumAddress],
        from_block_number: int,
        to_block_number: int,
    ) -> List[LogReceipt]:
        """
        Override function to call custom `get_total_transfer_history` function

        :param addresses:
        :param from_block_number:
        :param to_block_number:
        :return:
        """

        # If not too much addresses it's alright to filter in the RPC server
        parameter_addresses = (
            None if len(addresses) > self.query_chunk_size else addresses
        )

        with self.auto_adjust_block_limit(from_block_number, to_block_number):
            transfer_events = self.ethereum_client.erc20.get_total_transfer_history(
                parameter_addresses,
                from_block=from_block_number,
                to_block=to_block_number,
            )

        if parameter_addresses:
            return transfer_events

        # Every ERC20/721 event is returned, we need to filter ourselves
        addresses_set = set(addresses)
        return [
            transfer_event
            for transfer_event in transfer_events
            if transfer_event["args"]["to"] in addresses_set
            or transfer_event["args"]["from"] in addresses_set
        ]

    @cachedmethod(cache=operator.attrgetter("_cache_is_erc20"))
    @cache_memoize(60 * 60 * 24, prefix="erc20-events-indexer-is-erc20")  # 1 day
    def _is_erc20(self, token_address: str) -> bool:
        try:
            token = Token.objects.get(address=token_address)
            return token.is_erc20()
        except Token.DoesNotExist:
            try:
                decimals = self.ethereum_client.erc20.get_decimals(token_address)
                return decimals is not None
            except (ValueError, BadFunctionCallOutput, DecodingError):
                return False

    def _process_decoded_element(self, event: EventData) -> EventData:
        """
        :param event: Be careful, it will be modified instead of copied
        :return: The same event if it's a ERC20/ERC721. Tries to tell apart if it's not defined (`unknown` instead
            of `value` or `tokenId`)
        """
        event_args = event["args"]
        if "unknown" in event_args:  # Not standard event
            event_args["value"] = event_args.pop("unknown")

        if self._is_erc20(event["address"]):
            if "tokenId" in event_args:
                event_args["value"] = event_args.pop("tokenId")
        else:
            if "value" in event_args:
                event_args["tokenId"] = event_args.pop("value")
        return event

    def events_to_erc20_transfer(
        self, log_receipts: Sequence[EventData]
    ) -> Iterator[ERC20Transfer]:
        for log_receipt in log_receipts:
            try:
                yield ERC20Transfer.from_decoded_event(log_receipt)
            except ValueError:
                pass

    def events_to_erc721_transfer(
        self, log_receipts: Sequence[EventData]
    ) -> Iterator[ERC721Transfer]:
        for log_receipt in log_receipts:
            try:
                yield ERC721Transfer.from_decoded_event(log_receipt)
            except ValueError:
                pass

    def process_elements(
        self, log_receipts: Sequence[EventData]
    ) -> List[TokenTransfer]:
        """
        Process all events found by `find_relevant_elements`

        :param log_receipts: Events to store in database
        :return: List of `TokenTransfer` already stored in database
        """
        tx_hashes = OrderedDict.fromkeys(
            [log_receipt["transactionHash"] for log_receipt in log_receipts]
        ).keys()
        if not tx_hashes:
            return []
        else:
            logger.debug("Prefetching and storing %d ethereum txs", len(tx_hashes))
            self.index_service.txs_create_or_update_from_tx_hashes(tx_hashes)
            logger.debug("End prefetching and storing of ethereum txs")

            logger.debug("Storing TokenTransfer objects")
            result_erc20 = ERC20Transfer.objects.bulk_create_from_generator(
                self.events_to_erc20_transfer(log_receipts), ignore_conflicts=True
            )
            result_erc721 = ERC721Transfer.objects.bulk_create_from_generator(
                self.events_to_erc721_transfer(log_receipts), ignore_conflicts=True
            )
            logger.debug("Stored TokenTransfer objects")
            return range(
                result_erc20 + result_erc721
            )  # TODO Hack to prevent returning `TokenTransfer` and using too much RAM

    def get_almost_updated_addresses(
        self, current_block_number: int
    ) -> QuerySet[MonitoredAddress]:
        """

        :param current_block_number:
        :return: Monitored addresses to be processed
        """

        logger.debug("%s: Retrieving monitored addresses", self.__class__.__name__)

        addresses = self.database_queryset.all()

        logger.debug("%s: Retrieved monitored addresses", self.__class__.__name__)
        return addresses

    def get_not_updated_addresses(
        self, current_block_number: int
    ) -> QuerySet[MonitoredAddress]:
        """
        :param current_block_number:
        :return: Monitored addresses to be processed
        """
        return []

    def get_minimum_block_number(
        self, addresses: Optional[Sequence[str]] = None
    ) -> Optional[int]:
        return IndexingStatus.objects.get_erc20_721_indexing_status().block_number

    def update_monitored_address(
        self, addresses: Sequence[str], from_block_number: int, to_block_number: int
    ) -> int:
        return int(
            IndexingStatus.objects.set_erc20_721_indexing_status(to_block_number)
        )

'''
'''--- safe_transaction_service/history/indexers/ethereum_indexer.py ---
import time
from abc import ABC, abstractmethod
from contextlib import contextmanager
from logging import getLogger
from typing import Any, List, Optional, Sequence, Tuple

from django.db.models import Min, QuerySet

from celery.exceptions import SoftTimeLimitExceeded

from gnosis.eth import EthereumClient

from ..models import MonitoredAddress
from ..services import IndexingException, IndexService, IndexServiceProvider

logger = getLogger(__name__)

class FindRelevantElementsException(IndexingException):
    pass

class EthereumIndexer(ABC):
    """
    This service allows indexing of Ethereum blockchain.
    `database_field` should be defined with the field used to store the current block number for a monitored address
    `find_relevant_elements` elements should be defined with the query to get the relevant txs/events/etc.
    `process_elements` defines what happens with elements found
    So the flow would be `start()` -> `process_addresses` -> `find_revelant_elements` -> `process_elements` ->
    `process_element`
    """

    def __init__(
        self,
        ethereum_client: EthereumClient,
        confirmations: int = 0,
        block_process_limit: int = 2000,
        block_process_limit_max: int = 0,
        blocks_to_reindex_again: int = 0,
        updated_blocks_behind: int = 20,
        query_chunk_size: Optional[int] = 1_000,
        block_auto_process_limit: bool = True,
    ):
        """
        :param ethereum_client:
        :param confirmations: Don't index last `confirmations` blocks to prevent from reorgs
        :param block_process_limit: Number of blocks to scan at a time for relevant data. `0` == `No limit`
        :param block_process_limit_max: Maximum bumber of blocks to scan at a time for relevant data. `0` == `No limit`
        :param blocks_to_reindex_again: Number of blocks to reindex every time the indexer runs, in case something
            was missed.
        :param updated_blocks_behind: Number of blocks scanned for an address that can be behind and
            still be considered as almost updated. For example, if `updated_blocks_behind` is 100,
            `current block number` is 200, and last scan for an address was stopped on block 150, address
            is almost updated (200 - 100 < 150). Almost updated addresses are prioritized
        :param query_chunk_size: Number of addresses to query for relevant data in the same request. By testing,
            it seems that `5000` can be a good value (for `eth_getLogs`). If `0`, process all together
        :param block_auto_process_limit: Auto increase or decrease the `block_process_limit`
            based on congestion algorithm
        """
        self.ethereum_client = ethereum_client
        self.index_service: IndexService = IndexServiceProvider()
        self.index_service.ethereum_client = (
            self.ethereum_client
        )  # Use tracing ethereum client
        self.confirmations = confirmations
        self.initial_block_process_limit = block_process_limit
        self.block_process_limit = block_process_limit
        self.block_process_limit_max = block_process_limit_max
        self.blocks_to_reindex_again = blocks_to_reindex_again
        self.updated_blocks_behind = updated_blocks_behind
        self.query_chunk_size = query_chunk_size
        self.block_auto_process_limit = block_auto_process_limit

    @property
    @abstractmethod
    def database_field(self):
        """
        :return: Database field for `database_queryset` to store scan status
        """

    @property
    @abstractmethod
    def database_queryset(self):
        """
        :return: Queryset of objects being scanned
        """

    @abstractmethod
    def find_relevant_elements(
        self,
        addresses: Sequence[str],
        from_block_number: int,
        to_block_number: int,
        current_block_number: Optional[int] = None,
    ) -> Sequence[Any]:
        """
        Find blockchain relevant elements for the `addresses`

        :param addresses:
        :param from_block_number
        :param to_block_number
        :param current_block_number:
        :return: Set of relevant elements
        """

    def process_element(self, element: Any) -> List[Any]:
        """
        Process provided `element` to retrieve relevant data (internal txs, events...)

        :param element:
        :return:
        """
        raise NotImplementedError

    def process_elements(self, elements: Sequence[Any]) -> Sequence[Any]:
        processed_objects = []
        for i, element in enumerate(elements):
            logger.info(
                "%s: Processing element %d/%d",
                i + 1,
                self.__class__.__name__,
                len(list(elements)),
            )
            processed_objects.append(self.process_element(element))
        # processed_objects = [self.process_element(element) for element in elements]
        return [item for sublist in processed_objects for item in sublist]

    def get_block_numbers_for_search(
        self, addresses: Sequence[str], current_block_number: Optional[int] = None
    ) -> Optional[Sequence[Tuple[int, int]]]:
        """
        :param addresses:
        :param current_block_number: To prevent fetching it again
        :return: Minimum common `from_block_number` and `to_block_number` for search of relevant `tx hashes`
        """
        current_block_number = (
            current_block_number or self.ethereum_client.current_block_number
        )

        common_minimum_block_number = self.get_minimum_block_number(addresses)
        if common_minimum_block_number is None:  # Empty queryset
            return None

        from_block_number = common_minimum_block_number + 1
        if (from_block_number + self.block_process_limit) >= (
            current_block_number - self.confirmations
        ):
            # Reindex again when it's almost synced to prevent reorg/missing elements issues
            from_block_number = max(from_block_number - self.blocks_to_reindex_again, 0)

        if (current_block_number - common_minimum_block_number) <= self.confirmations:
            return  # We don't want problems with reorgs

        to_block_number = self.get_to_block_number(
            from_block_number, current_block_number
        )
        return from_block_number, to_block_number

    def get_to_block_number(
        self, from_block_number: int, current_block_number: int
    ) -> int:
        """
        :param from_block_number:
        :param current_block_number:
        :return: Top block number to process
        """
        return min(
            from_block_number + self.block_process_limit,
            current_block_number - self.confirmations,
        )

    def get_minimum_block_number(
        self, addresses: Optional[Sequence[str]] = None
    ) -> Optional[int]:
        """
        :param addresses:
        :return: Minimum block number for all the `addresses` provided. If not provided, return
            minimum block number for every `address` on the table.
        """
        logger.debug(
            "%s: Getting minimum-block-number for %s addresses",
            self.__class__.__name__,
            len(addresses) if addresses else "all the",
        )
        queryset = (
            self.database_queryset.filter(address__in=addresses)
            if addresses
            else self.database_queryset
        )
        minimum_block_number = queryset.aggregate(
            **{self.database_field: Min(self.database_field)}
        )[self.database_field]
        logger.debug(
            "%s: Got minimum-block-number=%s",
            self.__class__.__name__,
            minimum_block_number,
        )
        return minimum_block_number

    def get_almost_updated_addresses(
        self, current_block_number: int
    ) -> QuerySet[MonitoredAddress]:
        """

        :param current_block_number:
        :return: Addresses almost updated (< `updated_blocks_behind` blocks) to be processed
        """

        logger.debug(
            "%s: Retrieving almost updated monitored addresses", self.__class__.__name__
        )

        from_block_number = max(
            self.get_minimum_block_number() or 0,
            current_block_number - self.updated_blocks_behind,
        )
        to_block_number = current_block_number - self.confirmations
        almost_updated_addresses = self.database_queryset.filter(
            **{
                self.database_field + "__lt": to_block_number,
                self.database_field + "__gte": from_block_number,
            }
        ).order_by(self.database_field)

        logger.debug(
            "%s: Retrieved almost updated monitored addresses", self.__class__.__name__
        )
        return almost_updated_addresses

    def get_not_updated_addresses(
        self, current_block_number: int
    ) -> QuerySet[MonitoredAddress]:
        """
        :param current_block_number:
        :return: Addresses not updated (> `updated_blocks_behind` blocks) to be processed
        """
        logger.debug(
            "%s: Retrieving not updated monitored addresses",
            self.__class__.__name__,
        )

        not_updated_addresses = self.database_queryset.filter(
            **{self.database_field + "__lt": current_block_number - self.confirmations}
        ).order_by(self.database_field)

        logger.debug(
            "%s: Retrieved not updated monitored addresses",
            self.__class__.__name__,
        )
        return not_updated_addresses

    def update_monitored_address(
        self, addresses: Sequence[str], from_block_number: int, to_block_number: int
    ) -> int:
        """
        :param addresses: Addresses to have the block number updated
        :param from_block_number: Make sure that no reorg has happened checking that block number was not rollbacked
        :param to_block_number: Block number to be updated
        :return: Number of addresses updated
        """

        logger.debug(
            "%s: Updating monitored addresses",
            self.__class__.__name__,
        )

        updated_addresses = self.database_queryset.filter(
            **{
                "address__in": addresses,
                self.database_field
                + "__gte": from_block_number
                - 1,  # Protect in case of reorg
                self.database_field
                + "__lte": to_block_number,  # Don't update to a lower block number
            }
        ).update(**{self.database_field: to_block_number})

        if updated_addresses != len(addresses):
            logger.warning(
                "%s: Possible reorg - Cannot update all indexed addresses... Updated %d/%d addresses "
                "from-block-number=%d to-block-number=%d",
                self.__class__.__name__,
                updated_addresses,
                len(addresses),
                from_block_number,
                to_block_number,
            )

        logger.debug(
            "%s: Updated monitored addresses",
            self.__class__.__name__,
        )

        return updated_addresses

    @contextmanager
    def auto_adjust_block_limit(self, from_block_number: int, to_block_number: int):
        """
        Optimize number of elements processed every time (block process limit)
        based on how fast the block interval is retrieved
        """

        # Check that we are processing the `block_process_limit`, if not, measures are not valid
        if not (
            self.block_auto_process_limit
            and (to_block_number - from_block_number) == self.block_process_limit
        ):
            yield
        else:
            start = int(time.time())
            yield
            delta = int(time.time()) - start
            if delta > 30:
                self.block_process_limit = max(self.block_process_limit // 2, 1)
                logger.info(
                    "%s: block_process_limit halved to %d",
                    self.__class__.__name__,
                    self.block_process_limit,
                )
            elif delta > 10:
                new_block_process_limit = max(self.block_process_limit - 20, 1)
                self.block_process_limit = new_block_process_limit
                logger.info(
                    "%s: block_process_limit decreased to %d",
                    self.__class__.__name__,
                    self.block_process_limit,
                )
            elif delta < 2:
                self.block_process_limit *= 2
                logger.info(
                    "%s: block_process_limit duplicated to %d",
                    self.__class__.__name__,
                    self.block_process_limit,
                )
            elif delta < 5:
                self.block_process_limit += 20
                logger.info(
                    "%s: block_process_limit increased to %d",
                    self.__class__.__name__,
                    self.block_process_limit,
                )

            if (
                self.block_process_limit_max
                and self.block_process_limit > self.block_process_limit_max
            ):
                self.block_process_limit = self.block_process_limit_max
                logger.info(
                    "%s: block_process_limit %d is bigger than block_process_limit_max %d, reducing",
                    self.__class__.__name__,
                    self.block_process_limit,
                    self.block_process_limit_max,
                )

    def process_addresses(
        self, addresses: Sequence[str], current_block_number: Optional[int] = None
    ) -> Tuple[Sequence[Any], int, bool]:
        """
        Find and process relevant data for `addresses`, then store and return it

        :param addresses: Addresses to process
        :param current_block_number: To prevent fetching it again
        :return: Tuple with a sequence of `processed data`, `last_block_number` processed
            and `True` if no more blocks to scan, `False` otherwise
        """
        assert addresses, "Addresses cannot be empty!"

        current_block_number = (
            current_block_number or self.ethereum_client.current_block_number
        )
        parameters = self.get_block_numbers_for_search(addresses, current_block_number)
        if parameters is None:
            return [], current_block_number, True
        from_block_number, to_block_number = parameters

        updated = to_block_number == (current_block_number - self.confirmations)

        try:
            elements = self.find_relevant_elements(
                addresses,
                from_block_number,
                to_block_number,
                current_block_number=current_block_number,
            )
        except (FindRelevantElementsException, SoftTimeLimitExceeded) as e:
            self.block_process_limit = 1  # Set back to the very minimum
            logger.info(
                "%s: block_process_limit set back to %d",
                self.__class__.__name__,
                self.block_process_limit,
            )
            raise e

        processed_elements = self.process_elements(elements)

        self.update_monitored_address(addresses, from_block_number, to_block_number)
        return processed_elements, to_block_number, updated

    def start(self) -> int:
        """
        Find and process relevant data for existing database addresses

        :return: Number of elements processed
        """
        current_block_number = self.ethereum_client.current_block_number
        logger.debug(
            "%s: Current RPC block number=%d",
            self.__class__.__name__,
            current_block_number,
        )
        number_processed_elements = 0

        almost_updated_addresses = list(
            self.get_almost_updated_addresses(current_block_number)
        )
        if almost_updated_addresses:
            logger.info(
                "%s: Processing %d almost updated addresses",
                self.__class__.__name__,
                len(almost_updated_addresses),
            )
            updated = False
            while not updated:
                almost_updated_addresses_to_process = [
                    monitored_contract.address
                    for monitored_contract in almost_updated_addresses
                ]
                processed_elements, _, updated = self.process_addresses(
                    almost_updated_addresses_to_process,
                    current_block_number=current_block_number,
                )
                number_processed_elements += len(processed_elements)
        else:
            logger.debug(
                "%s: No almost updated addresses to process", self.__class__.__name__
            )

        not_updated_addresses = list(
            self.get_not_updated_addresses(current_block_number)
        )
        if not_updated_addresses:
            logger.info(
                "%s: Processing %d not updated addresses total",
                self.__class__.__name__,
                len(not_updated_addresses),
            )

            # Not updated addresses are sorted by tx_block_number
            minimum_block_number = getattr(
                not_updated_addresses[0], self.database_field
            )
            from_block_number = minimum_block_number + 1
            updated = False
            while not updated:
                # Estimate to_block_number
                to_block_number_expected = self.get_to_block_number(
                    from_block_number, current_block_number
                )

                # Only process addresses whose block is under the `to_block_number`, don't reprocess addresses
                not_updated_addresses_to_process = [
                    monitored_contract.address
                    for monitored_contract in not_updated_addresses
                    if getattr(monitored_contract, self.database_field)
                    < to_block_number_expected
                ]
                # Get real `to_block_number` processed
                (
                    processed_elements,
                    to_block_number,
                    updated,
                ) = self.process_addresses(
                    not_updated_addresses_to_process,
                    current_block_number=current_block_number,
                )
                number_processed_elements += len(processed_elements)
                from_block_number = to_block_number + 1
        else:
            logger.debug(
                "%s: No not updated addresses to process", self.__class__.__name__
            )

        return number_processed_elements

'''
'''--- safe_transaction_service/history/indexers/events_indexer.py ---
from abc import abstractmethod
from functools import cached_property
from logging import getLogger
from typing import Any, Dict, List, Optional, OrderedDict, Sequence

from django.conf import settings

import gevent
from eth_typing import ChecksumAddress
from eth_utils import event_abi_to_log_topic
from gevent import pool
from hexbytes import HexBytes
from web3.contract import ContractEvent
from web3.exceptions import LogTopicError
from web3.types import EventData, FilterParams, LogReceipt

from safe_transaction_service.utils.utils import chunks

from .ethereum_indexer import EthereumIndexer, FindRelevantElementsException

logger = getLogger(__name__)

class EventsIndexer(EthereumIndexer):
    """
    Indexes Ethereum events
    """

    # If True, don't use addresses to filter logs
    # Be careful, some nodes have limitations
    # https://docs.nodereal.io/nodereal/meganode/api-docs/bnb-smart-chain-api/eth_getlogs-bsc
    # https://docs.infura.io/infura/networks/ethereum/json-rpc-methods/eth_getlogs#limitations
    IGNORE_ADDRESSES_ON_LOG_FILTER: bool = False

    def __init__(self, *args, **kwargs):
        kwargs.setdefault(
            "block_process_limit", settings.ETH_EVENTS_BLOCK_PROCESS_LIMIT
        )
        kwargs.setdefault(
            "block_process_limit_max", settings.ETH_EVENTS_BLOCK_PROCESS_LIMIT_MAX
        )
        kwargs.setdefault(
            "blocks_to_reindex_again", 10
        )  # Reindex last 10 blocks every run of the indexer
        kwargs.setdefault(
            "query_chunk_size", settings.ETH_EVENTS_QUERY_CHUNK_SIZE
        )  # Number of elements to process together when calling `eth_getLogs`
        kwargs.setdefault(
            "updated_blocks_behind", settings.ETH_EVENTS_UPDATED_BLOCK_BEHIND
        )  # For last x blocks, consider them almost updated and process them first

        # Number of concurrent requests to `getLogs`
        self.get_logs_concurrency = settings.ETH_EVENTS_GET_LOGS_CONCURRENCY

        super().__init__(*args, **kwargs)

    @property
    @abstractmethod
    def contract_events(self) -> List[ContractEvent]:
        """
        :return: Web3 ContractEvent to listen to
        """

    @cached_property
    def events_to_listen(self) -> Dict[bytes, ContractEvent]:
        return {
            HexBytes(event_abi_to_log_topic(event.abi)).hex(): event
            for event in self.contract_events
        }

    def _do_node_query(
        self,
        addresses: List[ChecksumAddress],
        from_block_number: int,
        to_block_number: int,
    ) -> List[LogReceipt]:
        """
        Perform query to the node

        :param addresses:
        :param from_block_number:
        :param to_block_number:
        :return:
        """
        filter_topics = list(self.events_to_listen.keys())
        parameters: FilterParams = {
            "fromBlock": from_block_number,
            "toBlock": to_block_number,
            "topics": [filter_topics],
        }

        if not self.IGNORE_ADDRESSES_ON_LOG_FILTER:
            # Search logs only for the provided addresses
            if self.query_chunk_size:
                addresses_chunks = chunks(addresses, self.query_chunk_size)
            else:
                addresses_chunks = [addresses]

            multiple_parameters = [
                {**parameters, "address": addresses_chunk}
                for addresses_chunk in addresses_chunks
            ]

            gevent_pool = pool.Pool(self.get_logs_concurrency)
            jobs = [
                gevent_pool.spawn(
                    self.ethereum_client.slow_w3.eth.get_logs, single_parameters
                )
                for single_parameters in multiple_parameters
            ]

            with self.auto_adjust_block_limit(from_block_number, to_block_number):
                # Check how long the first job takes
                gevent.joinall(jobs[:1])

            gevent.joinall(jobs)
            return [log_receipt for job in jobs for log_receipt in job.get()]
        else:
            with self.auto_adjust_block_limit(from_block_number, to_block_number):
                return self.ethereum_client.slow_w3.eth.get_logs(parameters)

    def _find_elements_using_topics(
        self,
        addresses: List[ChecksumAddress],
        from_block_number: int,
        to_block_number: int,
    ) -> List[LogReceipt]:
        """
        It will get Safe events using all the Gnosis Safe topics for filtering.

        :param addresses:
        :param from_block_number:
        :param to_block_number:
        :return: LogReceipt for matching events
        """

        try:
            return self._do_node_query(addresses, from_block_number, to_block_number)
        except IOError as e:
            raise FindRelevantElementsException(
                f"Request error retrieving events "
                f"from-block={from_block_number} to-block={to_block_number}"
            ) from e
        except ValueError as e:
            # For example, Polygon returns:
            #   ValueError({'code': -32005, 'message': 'eth_getLogs block range too large, range: 138001, max: 100000'})
            # BSC returns:
            #   ValueError({'code': -32000, 'message': 'exceed maximum block range: 5000'})
            logger.warning(
                "%s: Value error retrieving events from-block=%d to-block=%d : %s",
                self.__class__.__name__,
                from_block_number,
                to_block_number,
                e,
            )
            raise FindRelevantElementsException(
                f"Request error retrieving events "
                f"from-block={from_block_number} to-block={to_block_number}"
            ) from e

    @abstractmethod
    def _process_decoded_element(self, decoded_element: EventData) -> Any:
        pass

    def find_relevant_elements(
        self,
        addresses: List[ChecksumAddress],
        from_block_number: int,
        to_block_number: int,
        current_block_number: Optional[int] = None,
    ) -> List[LogReceipt]:
        """
        Search for log receipts for Safe events

        :param addresses: Not used
        :param from_block_number: Starting block number
        :param to_block_number: Ending block number
        :param current_block_number: Current block number (for cache purposes)
        :return: LogReceipt for matching events
        """
        len_addresses = len(addresses)
        logger.debug(
            "%s: Filtering for events from block-number=%d to block-number=%d for %d addresses",
            self.__class__.__name__,
            from_block_number,
            to_block_number,
            len_addresses,
        )
        log_receipts = self._find_elements_using_topics(
            addresses, from_block_number, to_block_number
        )

        len_log_receipts = len(log_receipts)
        logger_fn = logger.info if len_log_receipts else logger.debug
        logger_fn(
            "%s: Found %d events from block-number=%d to block-number=%d for %d addresses",
            self.__class__.__name__,
            len_log_receipts,
            from_block_number,
            to_block_number,
            len_addresses,
        )
        return log_receipts

    def decode_elements(self, log_receipts: Sequence[LogReceipt]) -> List[EventData]:
        decoded_elements = []
        for log_receipt in log_receipts:
            try:
                decoded_elements.append(
                    self.events_to_listen[log_receipt["topics"][0].hex()].processLog(
                        log_receipt
                    )
                )
            except LogTopicError:
                logger.error(
                    "Unexpected log format for log-receipt %s",
                    log_receipt,
                    exc_info=True,
                )
        return decoded_elements

    def process_elements(self, log_receipts: Sequence[LogReceipt]) -> List[Any]:
        """
        Process all events found by `find_relevant_elements`

        :param log_receipts: Events to store in database
        :return: List of events already stored in database
        """
        if not log_receipts:
            return []

        decoded_elements: List[EventData] = self.decode_elements(log_receipts)
        tx_hashes = OrderedDict.fromkeys(
            [event["transactionHash"] for event in log_receipts]
        ).keys()
        logger.debug("Prefetching and storing %d ethereum txs", len(tx_hashes))
        self.index_service.txs_create_or_update_from_tx_hashes(tx_hashes)
        logger.debug("End prefetching and storing of ethereum txs")
        logger.debug("Processing %d decoded events", len(decoded_elements))
        processed_elements = []
        for decoded_element in decoded_elements:
            processed_element = self._process_decoded_element(decoded_element)
            if processed_element:
                processed_elements.append(processed_element)
        logger.debug("End processing %d decoded events", len(decoded_elements))
        return processed_elements

'''
'''--- safe_transaction_service/history/indexers/internal_tx_indexer.py ---
from collections import OrderedDict
from logging import getLogger
from typing import Dict, Generator, Iterable, List, Optional, Sequence, Set

from django.conf import settings
from django.db import transaction

from eth_typing import HexStr
from web3.types import ParityBlockTrace, ParityFilterTrace

from gnosis.eth import EthereumClient

from safe_transaction_service.contracts.tx_decoder import (
    CannotDecode,
    get_safe_tx_decoder,
)
from safe_transaction_service.utils.utils import chunks

from ..models import InternalTx, InternalTxDecoded, MonitoredAddress, SafeMasterCopy
from .ethereum_indexer import EthereumIndexer, FindRelevantElementsException

logger = getLogger(__name__)

class InternalTxIndexerProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            from django.conf import settings

            if settings.ETH_INTERNAL_NO_FILTER:
                instance_class = InternalTxIndexerWithTraceBlock
            else:
                instance_class = InternalTxIndexer

            cls.instance = instance_class(
                EthereumClient(settings.ETHEREUM_TRACING_NODE_URL),
            )
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class InternalTxIndexer(EthereumIndexer):
    def __init__(self, *args, **kwargs):
        kwargs.setdefault(
            "block_process_limit", settings.ETH_INTERNAL_TXS_BLOCK_PROCESS_LIMIT
        )
        kwargs.setdefault("blocks_to_reindex_again", 6)
        super().__init__(*args, **kwargs)

        self.trace_txs_batch_size: int = settings.ETH_INTERNAL_TRACE_TXS_BATCH_SIZE
        self.number_trace_blocks: int = (
            10  # Use `trace_block` for last `number_trace_blocks` blocks indexing
        )
        self.tx_decoder = get_safe_tx_decoder()

    @property
    def database_field(self):
        return "tx_block_number"

    @property
    def database_queryset(self):
        return SafeMasterCopy.objects.all()

    def find_relevant_elements(
        self,
        addresses: Sequence[str],
        from_block_number: int,
        to_block_number: int,
        current_block_number: Optional[int] = None,
    ) -> OrderedDict[HexStr, Optional[ParityFilterTrace]]:
        current_block_number = (
            current_block_number or self.ethereum_client.current_block_number
        )
        # Use `trace_block` for last `number_trace_blocks` blocks and `trace_filter` for the others
        trace_block_number = max(current_block_number - self.number_trace_blocks, 0)
        if from_block_number > trace_block_number:  # Just trace_block
            logger.debug(
                "Using trace_block from-block=%d to-block=%d",
                from_block_number,
                to_block_number,
            )
            return self._find_relevant_elements_using_trace_block(
                addresses, from_block_number, to_block_number
            )
        elif to_block_number < trace_block_number:  # Just trace_filter
            logger.debug(
                "Using trace_filter from-block=%d to-block=%d",
                from_block_number,
                to_block_number,
            )
            return self._find_relevant_elements_using_trace_filter(
                addresses, from_block_number, to_block_number
            )
        else:  # trace_filter for old blocks and trace_filter for the most recent ones
            logger.debug(
                "Using trace_filter from-block=%d to-block=%d and trace_block from-block=%d to-block=%d",
                from_block_number,
                trace_block_number,
                trace_block_number,
                to_block_number,
            )
            relevant_elements = self._find_relevant_elements_using_trace_filter(
                addresses, from_block_number, trace_block_number
            )
            relevant_elements.update(
                self._find_relevant_elements_using_trace_block(
                    addresses, trace_block_number, to_block_number
                )
            )
            return relevant_elements

    def _find_relevant_elements_using_trace_block(
        self, addresses: Sequence[str], from_block_number: int, to_block_number: int
    ) -> OrderedDict[HexStr, ParityFilterTrace]:
        addresses_set = set(addresses)  # More optimal to use with `in`
        try:
            block_numbers = list(range(from_block_number, to_block_number + 1))

            with self.auto_adjust_block_limit(from_block_number, to_block_number):
                blocks_traces: ParityBlockTrace = (
                    self.ethereum_client.parity.trace_blocks(block_numbers)
                )
            traces: OrderedDict[HexStr, ParityFilterTrace] = OrderedDict()
            relevant_tx_hashes: Set[HexStr] = set()
            for block_number, block_traces in zip(block_numbers, blocks_traces):
                if not block_traces:
                    logger.warning("Empty `trace_block` for block=%d", block_number)

                for trace in block_traces:
                    transaction_hash = trace.get("transactionHash")
                    if transaction_hash:
                        traces.setdefault(transaction_hash, []).append(trace)
                        # We're only interested in traces related to the provided addresses
                        if (
                            trace.get("action", {}).get("from") in addresses_set
                            or trace.get("action", {}).get("to") in addresses_set
                        ):
                            relevant_tx_hashes.add(transaction_hash)

            # Remove not relevant traces
            for tx_hash in list(traces.keys()):
                if tx_hash not in relevant_tx_hashes:
                    del traces[tx_hash]

            return traces
        except IOError as e:
            raise FindRelevantElementsException(
                "Request error calling `trace_block`"
            ) from e

    def _find_relevant_elements_using_trace_filter(
        self, addresses: Sequence[str], from_block_number: int, to_block_number: int
    ) -> OrderedDict[HexStr, List]:
        """
        Search for tx hashes with internal txs (in and out) of a `address`

        :param addresses:
        :param from_block_number: Starting block number
        :param to_block_number: Ending block number
        :return: Tx hashes of txs with internal txs relevant for the `addresses`
        """
        logger.debug(
            "Searching for internal txs from block-number=%d to block-number=%d - Addresses=%s",
            from_block_number,
            to_block_number,
            addresses,
        )

        try:
            # We only need to search for traces `to` the provided addresses
            with self.auto_adjust_block_limit(from_block_number, to_block_number):
                to_traces = self.ethereum_client.parity.trace_filter(
                    from_block=from_block_number,
                    to_block=to_block_number,
                    to_address=addresses,
                )
        except IOError as e:
            raise FindRelevantElementsException(
                "Request error calling `trace_filter`"
            ) from e

        # Log INFO if traces found, DEBUG if not
        traces: OrderedDict[HexStr, None] = OrderedDict()
        for trace in to_traces:
            transaction_hash = trace.get("transactionHash")
            if transaction_hash:
                # Leave this empty, as we are missing traces for the transaction and will need to be fetched later
                traces[transaction_hash] = []

        log_fn = logger.info if traces else logger.debug
        log_fn(
            "Found %d relevant txs with internal txs between block-number=%d and block-number=%d. Addresses=%s",
            len(traces),
            from_block_number,
            to_block_number,
            addresses,
        )

        return traces

    def _get_internal_txs_to_decode(
        self, tx_hashes: Sequence[str]
    ) -> Generator[InternalTxDecoded, None, None]:
        """
        Use generator to be more RAM friendly
        """
        for internal_tx in InternalTx.objects.can_be_decoded().filter(
            ethereum_tx__in=tx_hashes
        ):
            try:
                function_name, arguments = self.tx_decoder.decode_transaction(
                    bytes(internal_tx.data)
                )
                if (
                    internal_tx.pk is None
                ):  # pk is not populated on `bulk_create ignore_conflicts=True`
                    internal_tx = InternalTx.objects.get(
                        ethereum_tx=internal_tx.ethereum_tx,
                        trace_address=internal_tx.trace_address,
                    )
                yield InternalTxDecoded(
                    internal_tx=internal_tx,
                    function_name=function_name,
                    arguments=arguments,
                    processed=False,
                )
            except CannotDecode:
                pass

    def trace_transactions(
        self, tx_hashes: Sequence[HexStr], batch_size: int
    ) -> Iterable[List[ParityFilterTrace]]:
        batch_size = batch_size or len(tx_hashes)  # If `0`, don't use batches
        for tx_hash_chunk in chunks(list(tx_hashes), batch_size):
            tx_hash_chunk = list(tx_hash_chunk)
            try:
                yield from self.ethereum_client.parity.trace_transactions(tx_hash_chunk)
            except IOError:
                logger.error(
                    "Problem calling `trace_transactions` with %d txs. "
                    "Try lowering ETH_INTERNAL_TRACE_TXS_BATCH_SIZE",
                    len(tx_hash_chunk),
                    exc_info=True,
                )
                raise

    def process_elements(
        self, tx_hash_with_traces: OrderedDict[HexStr, Optional[ParityFilterTrace]]
    ) -> List[InternalTx]:
        # Prefetch ethereum txs
        if not tx_hash_with_traces:
            return []

        logger.debug(
            "Prefetching and storing %d ethereum txs", len(tx_hash_with_traces)
        )
        tx_hashes = list(tx_hash_with_traces.keys())
        ethereum_txs = self.index_service.txs_create_or_update_from_tx_hashes(tx_hashes)
        logger.debug("End prefetching and storing of ethereum txs")

        logger.debug("Prefetching of traces(internal txs)")
        tx_hashes_missing_traces = [
            tx_hash for tx_hash, trace in tx_hash_with_traces.items() if not trace
        ]
        missing_traces_lists = self.trace_transactions(
            tx_hashes_missing_traces, batch_size=self.trace_txs_batch_size
        )
        for tx_hash_missing_traces, missing_traces in zip(
            tx_hashes_missing_traces, missing_traces_lists
        ):
            tx_hash_with_traces[tx_hash_missing_traces] = missing_traces

        internal_txs = (
            InternalTx.objects.build_from_trace(trace, ethereum_tx)
            for ethereum_tx in ethereum_txs
            for trace in self.ethereum_client.parity.filter_out_errored_traces(
                tx_hash_with_traces[ethereum_tx.tx_hash]
            )
        )

        revelant_internal_txs_batch = (
            trace for trace in internal_txs if trace.is_relevant
        )
        logger.debug("End prefetching of traces(internal txs)")

        logger.debug("Storing traces")
        with transaction.atomic():
            traces_stored = InternalTx.objects.bulk_create_from_generator(
                revelant_internal_txs_batch, ignore_conflicts=True
            )
            logger.debug("End storing of %d traces", traces_stored)

            logger.debug("Start decoding and storing of decoded traces")
            internal_txs_decoded = InternalTxDecoded.objects.bulk_create_from_generator(
                self._get_internal_txs_to_decode(tx_hashes), ignore_conflicts=True
            )
            logger.debug(
                "End decoding and storing of %d decoded traces", internal_txs_decoded
            )
            return tx_hashes

class InternalTxIndexerWithTraceBlock(InternalTxIndexer):
    """
    Indexer for nodes not supporting `trace_filter`, so it will always use `trace_block`
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def get_almost_updated_addresses(
        self, current_block_number: int
    ) -> List[MonitoredAddress]:
        """
        Return every address. As we are using `trace_block` every master copy should be processed together

        :param current_block_number:
        :return:
        """
        return self.get_not_updated_addresses(current_block_number)

    def find_relevant_elements(
        self,
        addresses: Sequence[str],
        from_block_number: int,
        to_block_number: int,
        current_block_number: Optional[int] = None,
    ) -> Dict[HexStr, ParityFilterTrace]:
        logger.debug(
            "Using trace_block from-block=%d to-block=%d",
            from_block_number,
            to_block_number,
        )
        return self._find_relevant_elements_using_trace_block(
            addresses, from_block_number, to_block_number
        )

'''
'''--- safe_transaction_service/history/indexers/proxy_factory_indexer.py ---
from functools import cached_property
from logging import getLogger
from typing import List, Optional, Sequence

from web3.contract import ContractEvent
from web3.types import EventData, LogReceipt

from gnosis.eth import EthereumClient
from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.contracts import (
    get_proxy_factory_contract,
    get_proxy_factory_V1_1_1_contract,
)

from ..models import ProxyFactory, SafeContract
from .events_indexer import EventsIndexer

logger = getLogger(__name__)

class ProxyFactoryIndexerProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            from django.conf import settings

            cls.instance = ProxyFactoryIndexer(
                EthereumClient(settings.ETHEREUM_NODE_URL)
            )

        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class ProxyFactoryIndexer(EventsIndexer):
    @cached_property
    def contract_events(self) -> List[ContractEvent]:
        old_proxy_factory_contract = get_proxy_factory_V1_1_1_contract(
            self.ethereum_client.w3
        )
        proxy_factory_contract = get_proxy_factory_contract(self.ethereum_client.w3)
        return [
            old_proxy_factory_contract.events.ProxyCreation(),
            proxy_factory_contract.events.ProxyCreation(),
        ]

    @property
    def database_field(self):
        return "tx_block_number"

    @property
    def database_queryset(self):
        return ProxyFactory.objects.all()

    def _process_decoded_element(
        self, decoded_element: EventData
    ) -> Optional[SafeContract]:
        contract_address = decoded_element["args"]["proxy"]
        if contract_address != NULL_ADDRESS:
            if (block_number := decoded_element["blockNumber"]) == 0:
                transaction_hash = decoded_element["transactionHash"].hex()
                log_msg = (
                    f"Events are reporting blockNumber=0 for tx-hash={transaction_hash}"
                )
                logger.error(log_msg)
                raise ValueError(log_msg)

            return SafeContract(
                address=contract_address,
                ethereum_tx_id=decoded_element["transactionHash"],
            )

    def process_elements(
        self, log_receipts: Sequence[LogReceipt]
    ) -> List[SafeContract]:
        """
        Process all logs

        :param log_receipts: Iterable of Events fetched using `web3.eth.getLogs`
        :return: List of `SafeContract` already stored in database
        """
        safe_contracts = super().process_elements(log_receipts)
        if safe_contracts:
            SafeContract.objects.bulk_create(safe_contracts, ignore_conflicts=True)
        return safe_contracts

'''
'''--- safe_transaction_service/history/indexers/safe_events_indexer.py ---
from functools import cached_property
from logging import getLogger
from typing import List, Optional

from django.db import IntegrityError, transaction

from eth_abi import decode_abi
from eth_typing import ChecksumAddress
from hexbytes import HexBytes
from web3.contract import ContractEvent
from web3.types import EventData

from gnosis.eth import EthereumClient
from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.contracts import get_safe_V1_1_1_contract

from ..models import (
    EthereumBlock,
    EthereumTxCallType,
    InternalTx,
    InternalTxDecoded,
    InternalTxType,
    SafeMasterCopy,
)
from .abis.gnosis import gnosis_safe_l2_v1_3_0_abi, proxy_factory_v1_3_0_abi
from .events_indexer import EventsIndexer

logger = getLogger(__name__)

class SafeEventsIndexerProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            from django.conf import settings

            cls.instance = SafeEventsIndexer(EthereumClient(settings.ETHEREUM_NODE_URL))
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class SafeEventsIndexer(EventsIndexer):
    """
    Indexes Gnosis Safe L2 events
    """

    IGNORE_ADDRESSES_ON_LOG_FILTER = (
        True  # Search for logs in every address (like the ProxyFactory)
    )

    @cached_property
    def contract_events(self) -> List[ContractEvent]:
        """
        event SafeMultiSigTransaction(
            address to,
            uint256 value,
            bytes data,
            Enum.Operation operation,
            uint256 safeTxGas,
            uint256 baseGas,
            uint256 gasPrice,
            address gasToken,
            address payable refundReceiver,
            bytes signatures,
            // We combine nonce, sender and threshold into one to avoid stack too deep
            // Dev note: additionalInfo should not contain `bytes`, as this complicates decoding
            bytes additionalInfo  // abi.encode(nonce, msg.sender, threshold);
        );

        event SafeModuleTransaction(
            address module,
            address to,
            uint256 value,
            bytes data,
            Enum.Operation operation,
        );

        event SafeSetup(
            address indexed initiator,
            address[] owners,
            uint256 threshold,
            address initializer,
            address fallbackHandler
        );

        event ApproveHash(
            bytes32 indexed approvedHash,
            address indexed owner
        );

        event SignMsg(
            bytes32 indexed msgHash
        );

        event ExecutionFailure(
            bytes32 txHash, uint256 payment
        );

        event ExecutionSuccess(
            bytes32 txHash, uint256 payment
        );

        event EnabledModule(address module);
        event DisabledModule(address module);
        event ExecutionFromModuleSuccess(address indexed module);
        event ExecutionFromModuleFailure(address indexed module);

        event AddedOwner(address owner);
        event RemovedOwner(address owner);
        event ChangedThreshold(uint256 threshold);

        event SafeReceived(address indexed sender, uint256 value);  // Incoming ether

        event ChangedFallbackHandler(address handler);
        event ChangedGuard(address guard);

        # ProxyFactory
        event ProxyCreation(GnosisSafeProxy proxy, address singleton);

        :return:
        """
        l2_contract = self.ethereum_client.w3.eth.contract(
            abi=gnosis_safe_l2_v1_3_0_abi
        )
        proxy_factory_contract = self.ethereum_client.w3.eth.contract(
            abi=proxy_factory_v1_3_0_abi
        )
        old_contract = get_safe_V1_1_1_contract(self.ethereum_client.w3)
        return [
            l2_contract.events.SafeMultiSigTransaction(),
            l2_contract.events.SafeModuleTransaction(),
            l2_contract.events.SafeSetup(),
            l2_contract.events.ApproveHash(),
            l2_contract.events.SignMsg(),
            l2_contract.events.ExecutionFailure(),
            l2_contract.events.ExecutionSuccess(),
            # Modules
            l2_contract.events.EnabledModule(),
            l2_contract.events.DisabledModule(),
            l2_contract.events.ExecutionFromModuleSuccess(),
            l2_contract.events.ExecutionFromModuleFailure(),
            # Owners
            l2_contract.events.AddedOwner(),
            l2_contract.events.RemovedOwner(),
            l2_contract.events.ChangedThreshold(),
            # Incoming Ether
            l2_contract.events.SafeReceived(),
            # Changed FallbackHandler
            l2_contract.events.ChangedFallbackHandler(),
            # Changed Guard
            l2_contract.events.ChangedGuard(),
            # Change Master Copy
            old_contract.events.ChangedMasterCopy(),
            # Proxy creation
            proxy_factory_contract.events.ProxyCreation(),
        ]

    @property
    def database_field(self):
        return "tx_block_number"

    @property
    def database_queryset(self):
        return SafeMasterCopy.objects.l2()

    def _is_setup_indexed(self, safe_address: ChecksumAddress):
        """
        Check if ``SafeSetup`` + ``ProxyCreation`` events were already processed. Makes indexing idempotent,
        as we modify the `trace_address` when processing `ProxyCreation`

        :param safe_address:
        :return: ``True`` if ``SafeSetup`` event was processed, ``False`` otherwise
        """
        return InternalTxDecoded.objects.filter(
            function_name="setup",
            internal_tx___from=safe_address,
            internal_tx__contract_address=None,
        ).exists()

    @transaction.atomic
    def decode_elements(self, *args) -> List[EventData]:
        return super().decode_elements(*args)

    @transaction.atomic
    def _process_decoded_element(
        self, decoded_element: EventData
    ) -> Optional[InternalTx]:
        safe_address = decoded_element["address"]
        event_name = decoded_element["event"]
        # As log
        log_index = decoded_element["logIndex"]
        trace_address = str(log_index)
        args = dict(decoded_element["args"])
        ethereum_tx_hash = decoded_element["transactionHash"]
        ethereum_block = EthereumBlock.objects.values("number", "timestamp").get(
            txs=ethereum_tx_hash
        )

        internal_tx = InternalTx(
            ethereum_tx_id=ethereum_tx_hash,
            timestamp=ethereum_block["timestamp"],
            block_number=ethereum_block["number"],
            _from=safe_address,
            gas=50000,
            data=b"",
            to=NULL_ADDRESS,  # It should be Master copy address but we cannot detect it
            value=0,
            gas_used=50000,
            contract_address=None,
            code=None,
            output=None,
            refund_address=None,
            tx_type=InternalTxType.CALL.value,
            call_type=EthereumTxCallType.DELEGATE_CALL.value,
            trace_address=trace_address,
            error=None,
        )
        child_internal_tx = None  # For Ether transfers
        internal_tx_decoded = InternalTxDecoded(
            internal_tx=internal_tx,
            function_name="",
            arguments=args,
        )
        if event_name == "ProxyCreation":
            # Should be the 2nd event to be indexed, after `SafeSetup`
            safe_address = args.pop("proxy")

            if self._is_setup_indexed(safe_address):
                internal_tx = None
            else:
                new_trace_address = f"{trace_address},0"
                to = args.pop("singleton")

                # Try to update InternalTx created by SafeSetup (if Safe was created using the ProxyFactory) with
                # the master copy used. Without tracing it cannot be detected otherwise
                InternalTx.objects.filter(
                    contract_address=safe_address, decoded_tx__function_name="setup"
                ).update(to=to, contract_address=None, trace_address=new_trace_address)
                # Add creation internal tx. _from is the address of the proxy instead of the safe_address
                internal_tx.contract_address = safe_address
                internal_tx.tx_type = InternalTxType.CREATE.value
                internal_tx.call_type = None
                internal_tx_decoded = None
        elif event_name == "SafeSetup":
            # Should be the 1st event to be indexed, unless custom `to` and `data` are set
            if self._is_setup_indexed(safe_address):
                internal_tx = None
            else:
                # Usually ProxyCreation is called before SafeSetup, but it can be the opposite if someone
                # creates a Safe and configure it in the next transaction. Remove it if that's the case
                InternalTx.objects.filter(contract_address=safe_address).delete()
                internal_tx.contract_address = safe_address
                internal_tx_decoded.function_name = "setup"
                args["payment"] = 0
                args["paymentReceiver"] = NULL_ADDRESS
                args["_threshold"] = args.pop("threshold")
                args["_owners"] = args.pop("owners")
        elif event_name == "SafeMultiSigTransaction":
            internal_tx_decoded.function_name = "execTransaction"
            data = HexBytes(args["data"])
            args["data"] = data.hex()
            args["signatures"] = HexBytes(args["signatures"]).hex()
            args["nonce"], args["sender"], args["threshold"] = decode_abi(
                ["uint256", "address", "uint256"],
                internal_tx_decoded.arguments.pop("additionalInfo"),
            )
            if args["value"] and not data:  # Simulate ether transfer
                child_internal_tx = InternalTx(
                    ethereum_tx_id=ethereum_tx_hash,
                    timestamp=ethereum_block["timestamp"],
                    block_number=ethereum_block["number"],
                    _from=safe_address,
                    gas=23000,
                    data=b"",
                    to=args["to"],
                    value=args["value"],
                    gas_used=23000,
                    contract_address=None,
                    code=None,
                    output=None,
                    refund_address=None,
                    tx_type=InternalTxType.CALL.value,
                    call_type=EthereumTxCallType.CALL.value,
                    trace_address=f"{trace_address},0",
                    error=None,
                )
        elif event_name == "SafeModuleTransaction":
            internal_tx_decoded.function_name = "execTransactionFromModule"
            args["data"] = HexBytes(args["data"]).hex()
        elif event_name == "ApproveHash":
            internal_tx_decoded.function_name = "approveHash"
            args["hashToApprove"] = args.pop("approvedHash").hex()
        elif event_name == "EnabledModule":
            internal_tx_decoded.function_name = "enableModule"
        elif event_name == "DisabledModule":
            internal_tx_decoded.function_name = "disableModule"
        elif event_name == "AddedOwner":
            internal_tx_decoded.function_name = "addOwnerWithThreshold"
            args["_threshold"] = None
        elif event_name == "RemovedOwner":
            internal_tx_decoded.function_name = "removeOwner"
            args["_threshold"] = None
        elif event_name == "ChangedThreshold":
            internal_tx_decoded.function_name = "changeThreshold"
            args["_threshold"] = args.pop("threshold")
        elif event_name == "ChangedFallbackHandler":
            internal_tx_decoded.function_name = "setFallbackHandler"
        elif event_name == "ChangedGuard":
            internal_tx_decoded.function_name = "setGuard"
        elif event_name == "SafeReceived":  # Received ether
            internal_tx.call_type = EthereumTxCallType.CALL.value
            internal_tx._from = args["sender"]
            internal_tx.to = safe_address
            internal_tx.value = args["value"]
            internal_tx_decoded = None
        elif event_name == "ChangedMasterCopy":
            internal_tx_decoded.function_name = "changeMasterCopy"
            internal_tx.arguments = {
                "_masterCopy": args.get("singleton") or args.get("masterCopy")
            }
        else:
            # 'SignMsg', 'ExecutionFailure', 'ExecutionSuccess',
            # 'ExecutionFromModuleSuccess', 'ExecutionFromModuleFailure'
            internal_tx_decoded = None

        if internal_tx:
            with transaction.atomic():
                try:
                    internal_tx.save()
                    if child_internal_tx:
                        child_internal_tx.save()
                    if internal_tx_decoded:
                        internal_tx_decoded.save()
                except IntegrityError as exc:
                    logger.info(
                        "Ignoring already processed event %s for Safe %s on tx-hash=%s: %s",
                        event_name,
                        safe_address,
                        decoded_element["transactionHash"].hex(),
                        exc,
                    )
                    return None

        return internal_tx

'''
'''--- safe_transaction_service/history/indexers/tx_processor.py ---
from abc import ABC, abstractmethod
from logging import getLogger
from typing import Dict, Iterator, List, Optional, Sequence, Union

from django.db import transaction

from eth_typing import ChecksumAddress, HexStr
from eth_utils import event_abi_to_log_topic
from hexbytes import HexBytes
from packaging.version import Version
from web3 import Web3

from gnosis.eth import EthereumClient
from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.contracts import get_safe_V1_0_0_contract, get_safe_V1_3_0_contract
from gnosis.safe import SafeTx
from gnosis.safe.safe_signature import SafeSignature, SafeSignatureApprovedHash

from safe_transaction_service.safe_messages import models as safe_message_models

from ..models import (
    EthereumTx,
    InternalTx,
    InternalTxDecoded,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    SafeContract,
    SafeLastStatus,
    SafeMasterCopy,
    SafeStatus,
)

logger = getLogger(__name__)

class TxProcessorException(Exception):
    pass

class OwnerCannotBeRemoved(TxProcessorException):
    pass

class SafeTxProcessorProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            from django.conf import settings

            node_url = (
                settings.ETHEREUM_TRACING_NODE_URL
                if settings.ETHEREUM_TRACING_NODE_URL
                else settings.ETHEREUM_NODE_URL
            )
            cls.instance = SafeTxProcessor(EthereumClient(node_url))
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class TxProcessor(ABC):
    @abstractmethod
    def process_decoded_transaction(
        self, internal_tx_decoded: InternalTxDecoded
    ) -> bool:
        pass

    def process_decoded_transactions(
        self, internal_txs_decoded: Sequence[InternalTxDecoded]
    ) -> List[bool]:
        return [
            self.process_decoded_transaction(decoded_transaction)
            for decoded_transaction in internal_txs_decoded
        ]

class SafeTxProcessor(TxProcessor):
    """
    Processor for txs on Safe Contracts v0.0.1 - v1.0.0
    """

    def __init__(self, ethereum_client: EthereumClient):
        # This safe_tx_failure events allow us to detect a failed safe transaction
        self.ethereum_client = ethereum_client
        dummy_w3 = Web3()
        self.safe_tx_failure_events = [
            get_safe_V1_0_0_contract(dummy_w3).events.ExecutionFailed(),
            get_safe_V1_3_0_contract(dummy_w3).events.ExecutionFailure(),
        ]
        self.safe_tx_module_failure_events = [
            get_safe_V1_3_0_contract(dummy_w3).events.ExecutionFromModuleFailure()
        ]

        self.safe_tx_failure_events_topics = {
            event_abi_to_log_topic(event.abi) for event in self.safe_tx_failure_events
        }
        self.safe_tx_module_failure_topics = {
            event_abi_to_log_topic(event.abi)
            for event in self.safe_tx_module_failure_events
        }
        self.safe_last_status_cache: Dict[str, SafeLastStatus] = {}
        self.signature_breaking_versions = (  # Versions where signing changed
            Version("1.0.0"),  # Safes >= 1.0.0 Renamed `baseGas` to `dataGas`
            Version("1.3.0"),  # ChainId was included
        )

    def clear_cache(self, safe_address: Optional[ChecksumAddress] = None) -> None:
        if safe_address:
            if safe_address in self.safe_last_status_cache:
                del self.safe_last_status_cache[safe_address]
        else:
            self.safe_last_status_cache.clear()

    def is_failed(
        self, ethereum_tx: EthereumTx, safe_tx_hash: Union[HexStr, bytes]
    ) -> bool:
        """
        Detects failure events on a Safe Multisig Tx
        :param ethereum_tx:
        :param safe_tx_hash:
        :return: True if a Multisig Transaction is failed, False otherwise
        """
        # TODO Refactor this function to `Safe` in gnosis-py, it doesn't belong here
        safe_tx_hash = HexBytes(safe_tx_hash).hex()
        for log in ethereum_tx.logs:
            if (
                log["topics"]
                and log["data"]
                and HexBytes(log["topics"][0]) in self.safe_tx_failure_events_topics
                and log["data"][:66] == safe_tx_hash
            ):  # 66 is the beginning of the event data, the rest is payment
                return True
        return False

    def is_module_failed(
        self, ethereum_tx: EthereumTx, module_address: str, safe_address: str
    ) -> bool:
        """
        Detects module failure events on a Safe Module Tx
        :param ethereum_tx:
        :param module_address:
        :param safe_address:
        :return: True if a Module Transaction is failed, False otherwise
        """
        # TODO Refactor this function to `Safe` in gnosis-py, it doesn't belong here
        for log in ethereum_tx.logs:
            if (
                len(log["topics"]) == 2
                and (log["address"] == safe_address if "address" in log else True)
                and HexBytes(log["topics"][0]) in self.safe_tx_module_failure_topics
                and HexBytes(log["topics"][1])[-20:]
                == HexBytes(module_address)  # 20 address size in bytes
            ):
                return True
        return False

    def get_safe_version_from_master_copy(
        self, master_copy: ChecksumAddress
    ) -> Optional[str]:
        """
        :param master_copy:
        :return: Safe version for master copy address
        """
        return SafeMasterCopy.objects.get_version_for_address(master_copy)

    def get_last_safe_status_for_address(
        self, address: ChecksumAddress
    ) -> Optional[SafeLastStatus]:
        try:
            safe_status = self.safe_last_status_cache.get(
                address
            ) or SafeLastStatus.objects.get_or_generate(address)
            return safe_status
        except SafeLastStatus.DoesNotExist:
            logger.error("SafeLastStatus not found for address=%s", address)

    def is_version_breaking_signatures(
        self, old_safe_version: str, new_safe_version: str
    ) -> bool:
        """
        :param old_safe_version:
        :param new_safe_version:
        :return: `True` if migrating from a Master Copy old version to a new version breaks signatures,
        `False` otherwise
        """
        old_version = Version(
            Version(old_safe_version).base_version
        )  # Remove things like -alpha or +L2
        new_version = Version(Version(new_safe_version).base_version)
        if new_version < old_version:
            new_version, old_version = old_version, new_version
        for breaking_version in self.signature_breaking_versions:
            if old_version < breaking_version <= new_version:
                return True
        return False

    def swap_owner(
        self,
        internal_tx: InternalTx,
        safe_status: SafeStatus,
        owner: ChecksumAddress,
        new_owner: Optional[ChecksumAddress],
    ) -> None:
        """
        :param internal_tx:
        :param safe_status:
        :param owner:
        :param new_owner: If provided, `owner` will be replaced by `new_owner`. If not, `owner` will be removed
        :return:
        """
        contract_address = internal_tx._from
        if owner not in safe_status.owners:
            logger.error(
                "Error processing trace=%s for contract=%s with tx-hash=%s. Cannot remove owner=%s . "
                "Current owners=%s",
                internal_tx.trace_address,
                contract_address,
                internal_tx.ethereum_tx_id,
                owner,
                safe_status.owners,
            )
            raise OwnerCannotBeRemoved(
                f"Cannot remove owner {owner}. Current owners {safe_status.owners}"
            )

        if not new_owner:
            safe_status.owners.remove(owner)
        else:
            # Replace owner by new_owner in the same place of the list
            safe_status.owners = [
                new_owner if current_owner == owner else current_owner
                for current_owner in safe_status.owners
            ]
        MultisigConfirmation.objects.remove_unused_confirmations(
            contract_address, safe_status.nonce, owner
        )
        safe_message_models.SafeMessageConfirmation.objects.filter(owner=owner).delete()

    def store_new_safe_status(
        self, safe_last_status: SafeLastStatus, internal_tx: InternalTx
    ) -> SafeLastStatus:
        """
        Updates `SafeLastStatus`. An entry to `SafeStatus` is added too via a Django signal.

        :param safe_last_status:
        :param internal_tx:
        :return: Updated `SafeLastStatus`
        """
        safe_last_status.internal_tx = internal_tx
        safe_last_status.save()
        self.safe_last_status_cache[safe_last_status.address] = safe_last_status
        return safe_last_status

    @transaction.atomic
    def process_decoded_transaction(
        self, internal_tx_decoded: InternalTxDecoded
    ) -> bool:
        processed_successfully = self.__process_decoded_transaction(internal_tx_decoded)
        internal_tx_decoded.set_processed()
        self.clear_cache()
        return processed_successfully

    @transaction.atomic
    def process_decoded_transactions(
        self, internal_txs_decoded: Iterator[InternalTxDecoded]
    ) -> List[bool]:
        """
        Optimize to process multiple transactions in a batch
        :param internal_txs_decoded:
        :return:
        """
        internal_tx_ids = []
        results = []

        for internal_tx_decoded in internal_txs_decoded:
            internal_tx_ids.append(internal_tx_decoded.internal_tx_id)
            results.append(self.__process_decoded_transaction(internal_tx_decoded))

        # Set all as decoded in the same batch
        InternalTxDecoded.objects.filter(internal_tx__in=internal_tx_ids).update(
            processed=True
        )
        self.clear_cache()
        return results

    def __process_decoded_transaction(
        self, internal_tx_decoded: InternalTxDecoded
    ) -> bool:
        """
        Decode internal tx and creates needed models
        :param internal_tx_decoded: InternalTxDecoded to process. It will be set as `processed`
        :return: True if tx could be processed, False otherwise
        """
        internal_tx = internal_tx_decoded.internal_tx
        logger.debug(
            "Start processing InternalTxDecoded in tx-hash=%s",
            HexBytes(internal_tx_decoded.internal_tx.ethereum_tx_id).hex(),
        )

        if internal_tx.gas_used < 1000:
            # When calling a non existing function, fallback of the proxy does not return any error but we can detect
            # this kind of functions due to little gas used. Some of this transactions get decoded as they were
            # valid in old versions of the proxies, like changes to `setup`
            logger.debug(
                "Calling a non existing function, will not process it",
            )
            return False

        function_name = internal_tx_decoded.function_name
        arguments = internal_tx_decoded.arguments
        contract_address = internal_tx._from
        master_copy = internal_tx.to
        processed_successfully = True

        if function_name == "setup" and contract_address != NULL_ADDRESS:
            # Index new Safes
            logger.debug("Processing Safe setup")
            owners = arguments["_owners"]
            threshold = arguments["_threshold"]
            fallback_handler = arguments.get("fallbackHandler", NULL_ADDRESS)
            nonce = 0
            try:
                safe_contract: SafeContract = SafeContract.objects.get(
                    address=contract_address
                )
                if not safe_contract.ethereum_tx_id:
                    safe_contract.ethereum_tx = internal_tx.ethereum_tx
                    safe_contract.save(update_fields=["ethereum_tx"])
            except SafeContract.DoesNotExist:
                SafeContract.objects.create(
                    address=contract_address,
                    ethereum_tx=internal_tx.ethereum_tx,
                )
                logger.info("Found new Safe=%s", contract_address)

            self.store_new_safe_status(
                SafeLastStatus(
                    internal_tx=internal_tx,
                    address=contract_address,
                    owners=owners,
                    threshold=threshold,
                    nonce=nonce,
                    master_copy=master_copy,
                    fallback_handler=fallback_handler,
                ),
                internal_tx,
            )
        else:
            safe_last_status = self.get_last_safe_status_for_address(contract_address)
            if not safe_last_status:
                # Usually this happens from Safes coming from a not supported Master Copy
                # TODO When archive node is available, build SafeStatus from blockchain status
                logger.debug(
                    "Cannot process trace as `SafeLastStatus` is not found for Safe=%s",
                    contract_address,
                )
                processed_successfully = False
            elif function_name in (
                "addOwnerWithThreshold",
                "removeOwner",
                "removeOwnerWithThreshold",
            ):
                logger.debug("Processing owner/threshold modification")
                safe_last_status.threshold = (
                    arguments["_threshold"] or safe_last_status.threshold
                )  # Event doesn't have threshold
                owner = arguments["owner"]
                if function_name == "addOwnerWithThreshold":
                    safe_last_status.owners.insert(0, owner)
                else:  # removeOwner, removeOwnerWithThreshold
                    self.swap_owner(internal_tx, safe_last_status, owner, None)
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name == "swapOwner":
                logger.debug("Processing owner swap")
                old_owner = arguments["oldOwner"]
                new_owner = arguments["newOwner"]
                self.swap_owner(internal_tx, safe_last_status, old_owner, new_owner)
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name == "changeThreshold":
                logger.debug("Processing threshold change")
                safe_last_status.threshold = arguments["_threshold"]
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name == "changeMasterCopy":
                logger.debug("Processing master copy change")
                # TODO Ban address if it doesn't have a valid master copy
                old_safe_version = self.get_safe_version_from_master_copy(
                    safe_last_status.master_copy
                )
                safe_last_status.master_copy = arguments["_masterCopy"]
                new_safe_version = self.get_safe_version_from_master_copy(
                    safe_last_status.master_copy
                )
                if (
                    old_safe_version
                    and new_safe_version
                    and self.is_version_breaking_signatures(
                        old_safe_version, new_safe_version
                    )
                ):
                    # Transactions queued not executed are not valid anymore
                    MultisigTransaction.objects.queued(contract_address).delete()
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name == "setFallbackHandler":
                logger.debug("Setting FallbackHandler")
                safe_last_status.fallback_handler = arguments["handler"]
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name == "setGuard":
                safe_last_status.guard = (
                    arguments["guard"] if arguments["guard"] != NULL_ADDRESS else None
                )
                if safe_last_status.guard:
                    logger.debug("Setting Guard")
                else:
                    logger.debug("Unsetting Guard")
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name == "enableModule":
                logger.debug("Enabling Module")
                safe_last_status.enabled_modules.append(arguments["module"])
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name == "disableModule":
                logger.debug("Disabling Module")
                safe_last_status.enabled_modules.remove(arguments["module"])
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name in {
                "execTransactionFromModule",
                "execTransactionFromModuleReturnData",
            }:
                logger.debug("Executing Tx from Module")
                # TODO Add test with previous traces for processing a module transaction
                ethereum_tx = internal_tx.ethereum_tx
                if "module" in arguments:
                    # L2 Safe with event SafeModuleTransaction indexed using events
                    module_address = arguments["module"]
                else:
                    # Regular Safe indexed using tracing
                    # Someone calls Module -> Module calls Safe Proxy -> Safe Proxy delegate calls Master Copy
                    # The trace that is been processed is the last one, so indexer needs to get the previous trace
                    previous_trace = self.ethereum_client.parity.get_previous_trace(
                        internal_tx.ethereum_tx_id,
                        internal_tx.trace_address_as_list,
                        skip_delegate_calls=True,
                    )
                    if not previous_trace:
                        message = (
                            f"Cannot find previous trace for tx-hash={HexBytes(internal_tx.ethereum_tx_id).hex()} "
                            f"and trace-address={internal_tx.trace_address}"
                        )
                        logger.warning(message)
                        raise ValueError(message)
                    module_internal_tx = InternalTx.objects.build_from_trace(
                        previous_trace, internal_tx.ethereum_tx
                    )
                    module_address = (
                        module_internal_tx._from if module_internal_tx else NULL_ADDRESS
                    )
                failed = self.is_module_failed(
                    ethereum_tx, module_address, contract_address
                )
                module_data = HexBytes(arguments["data"])
                ModuleTransaction.objects.get_or_create(
                    internal_tx=internal_tx,
                    defaults={
                        "created": internal_tx.timestamp,
                        "safe": contract_address,
                        "module": module_address,
                        "to": arguments["to"],
                        "value": arguments["value"],
                        "data": module_data if module_data else None,
                        "operation": arguments["operation"],
                        "failed": failed,
                    },
                )

            elif function_name == "approveHash":
                logger.debug("Processing hash approval")
                multisig_transaction_hash = arguments["hashToApprove"]
                ethereum_tx = internal_tx.ethereum_tx
                if "owner" in arguments:  # Event approveHash
                    owner = arguments["owner"]
                else:
                    previous_trace = self.ethereum_client.parity.get_previous_trace(
                        internal_tx.ethereum_tx_id,
                        internal_tx.trace_address_as_list,
                        skip_delegate_calls=True,
                    )
                    if not previous_trace:
                        message = (
                            f"Cannot find previous trace for tx-hash={HexBytes(internal_tx.ethereum_tx_id).hex()} and "
                            f"trace-address={internal_tx.trace_address}"
                        )
                        logger.warning(message)
                        raise ValueError(message)
                    previous_internal_tx = InternalTx.objects.build_from_trace(
                        previous_trace, internal_tx.ethereum_tx
                    )
                    owner = previous_internal_tx._from
                safe_signature = SafeSignatureApprovedHash.build_for_owner(
                    owner, multisig_transaction_hash
                )
                (multisig_confirmation, _) = MultisigConfirmation.objects.get_or_create(
                    multisig_transaction_hash=multisig_transaction_hash,
                    owner=owner,
                    defaults={
                        "created": internal_tx.timestamp,
                        "ethereum_tx": ethereum_tx,
                        "signature": safe_signature.export_signature(),
                        "signature_type": safe_signature.signature_type.value,
                    },
                )
                if not multisig_confirmation.ethereum_tx_id:
                    multisig_confirmation.ethereum_tx = ethereum_tx
                    multisig_confirmation.save(update_fields=["ethereum_tx"])
            elif function_name == "execTransaction":
                logger.debug("Processing transaction execution")
                # Events for L2 Safes store information about nonce
                nonce = (
                    arguments["nonce"]
                    if "nonce" in arguments
                    else safe_last_status.nonce
                )
                if (
                    "baseGas" in arguments
                ):  # `dataGas` was renamed to `baseGas` in v1.0.0
                    base_gas = arguments["baseGas"]
                    safe_version = (
                        self.get_safe_version_from_master_copy(
                            safe_last_status.master_copy
                        )
                        or "1.0.0"
                    )
                else:
                    base_gas = arguments["dataGas"]
                    safe_version = "0.0.1"
                safe_tx = SafeTx(
                    None,
                    contract_address,
                    arguments["to"],
                    arguments["value"],
                    arguments["data"],
                    arguments["operation"],
                    arguments["safeTxGas"],
                    base_gas,
                    arguments["gasPrice"],
                    arguments["gasToken"],
                    arguments["refundReceiver"],
                    HexBytes(arguments["signatures"]),
                    safe_nonce=nonce,
                    safe_version=safe_version,
                    chain_id=self.ethereum_client.get_chain_id(),
                )
                safe_tx_hash = safe_tx.safe_tx_hash

                ethereum_tx = internal_tx.ethereum_tx

                failed = self.is_failed(ethereum_tx, safe_tx_hash)
                multisig_tx, _ = MultisigTransaction.objects.get_or_create(
                    safe_tx_hash=safe_tx_hash,
                    defaults={
                        "created": internal_tx.timestamp,
                        "safe": contract_address,
                        "ethereum_tx": ethereum_tx,
                        "to": safe_tx.to,
                        "value": safe_tx.value,
                        "data": safe_tx.data if safe_tx.data else None,
                        "operation": safe_tx.operation,
                        "safe_tx_gas": safe_tx.safe_tx_gas,
                        "base_gas": safe_tx.base_gas,
                        "gas_price": safe_tx.gas_price,
                        "gas_token": safe_tx.gas_token,
                        "refund_receiver": safe_tx.refund_receiver,
                        "nonce": safe_tx.safe_nonce,
                        "signatures": safe_tx.signatures,
                        "failed": failed,
                        "trusted": True,
                    },
                )

                # Don't modify created
                if not multisig_tx.ethereum_tx_id:
                    multisig_tx.ethereum_tx = ethereum_tx
                    multisig_tx.failed = failed
                    multisig_tx.signatures = HexBytes(arguments["signatures"])
                    multisig_tx.trusted = True
                    multisig_tx.save(
                        update_fields=["ethereum_tx", "failed", "signatures", "trusted"]
                    )

                for safe_signature in SafeSignature.parse_signature(
                    safe_tx.signatures, safe_tx_hash
                ):
                    (
                        multisig_confirmation,
                        _,
                    ) = MultisigConfirmation.objects.get_or_create(
                        multisig_transaction_hash=safe_tx_hash,
                        owner=safe_signature.owner,
                        defaults={
                            "created": internal_tx.timestamp,
                            "ethereum_tx": None,
                            "multisig_transaction": multisig_tx,
                            "signature": safe_signature.export_signature(),
                            "signature_type": safe_signature.signature_type.value,
                        },
                    )
                    if multisig_confirmation.signature != safe_signature.signature:
                        multisig_confirmation.signature = (
                            safe_signature.export_signature()
                        )
                        multisig_confirmation.signature_type = (
                            safe_signature.signature_type.value
                        )
                        multisig_confirmation.save(
                            update_fields=["signature", "signature_type"]
                        )

                safe_last_status.nonce = nonce + 1
                self.store_new_safe_status(safe_last_status, internal_tx)
            elif function_name == "execTransactionFromModule":
                logger.debug("Not processing execTransactionFromModule")
                # No side effects or nonce increasing, but trace will be set as processed
            else:
                processed_successfully = False
                logger.warning(
                    "Cannot process InternalTxDecoded function_name=%s and arguments=%s",
                    function_name,
                    arguments,
                )
        logger.debug("End processing")
        return processed_successfully

'''
'''--- safe_transaction_service/history/management/__init__.py ---

'''
'''--- safe_transaction_service/history/management/commands/__init__.py ---

'''
'''--- safe_transaction_service/history/management/commands/add_webhook.py ---
from django.core.management.base import BaseCommand

from ...models import WebHook

class Command(BaseCommand):
    help = "Binds confirmations with multisig txs"

    def add_arguments(self, parser):
        parser.add_argument("--url", help="url to send webhooks to", required=True)

    def handle(self, *args, **options):
        url = options["url"]
        WebHook.objects.get_or_create(url=url, address="")

        self.stdout.write(self.style.SUCCESS(f"Created webhook for {url}"))

'''
'''--- safe_transaction_service/history/management/commands/bind_confirmations.py ---
from django.core.management.base import BaseCommand

from ...models import MultisigConfirmation, MultisigTransaction

class Command(BaseCommand):
    help = "Binds confirmations with multisig txs"

    def add_arguments(self, parser):
        # Positional arguments
        # parser.add_argument('--deployer-key', help='Private key for deployer')
        pass

    def handle(self, *args, **options):
        for multisig_confirmation in MultisigConfirmation.objects.without_transaction():
            try:
                tx = MultisigTransaction.objects.get(
                    safe_tx_hash=multisig_confirmation.multisig_transaction_hash
                )
                multisig_confirmation.multisig_transaction = tx
                multisig_confirmation.save(update_fields=["multisig_transaction"])
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Bind confirmation with multisig tx={tx.safe_tx_hash}"
                    )
                )
            except MultisigTransaction.DoesNotExist:
                pass

'''
'''--- safe_transaction_service/history/management/commands/check_index_problems.py ---
from django.conf import settings
from django.core.management.base import BaseCommand

from gnosis.eth import EthereumClient
from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.contracts import get_safe_V1_3_0_contract

from ...models import MultisigTransaction, SafeLastStatus
from ...services import IndexServiceProvider

class Command(BaseCommand):
    help = "Check nonce calculated by the indexer is the same that blockchain nonce"

    def add_arguments(self, parser):
        parser.add_argument(
            "--fix", help="Fix nonce problems", action="store_true", default=False
        )

        parser.add_argument(
            "--force-batch-call",
            help="Force batch call instead of multicall for nonce recovery",
            action="store_true",
            default=False,
        )

    def get_nonce_fn(self, ethereum_client: EthereumClient):
        return get_safe_V1_3_0_contract(
            ethereum_client.w3, address=NULL_ADDRESS
        ).functions.nonce()

    def handle(self, *args, **options):
        fix = options["fix"]
        force_batch_call = options["force_batch_call"]

        queryset = SafeLastStatus.objects.all()
        if settings.ETH_L2_NETWORK:
            # Filter nonce=0 to exclude not initialized or non L2 Safes in a L2 network
            queryset = queryset.exclude(nonce=0)

        count = queryset.count()
        batch = 1000
        index_service = IndexServiceProvider()
        ethereum_client = index_service.ethereum_client
        nonce_fn = self.get_nonce_fn(ethereum_client)
        first_issue_block_number = ethereum_client.current_block_number
        all_addresses_to_reindex = set()

        for i in range(0, count, batch):
            self.stdout.write(self.style.SUCCESS(f"Processed {i}/{count}"))
            safe_statuses = queryset[i : i + batch]
            safe_statuses_list = list(safe_statuses)  # Force retrieve queryset from DB

            blockchain_nonces = ethereum_client.batch_call_same_function(
                nonce_fn,
                [safe_status.address for safe_status in safe_statuses_list],
                raise_exception=False,
                force_batch_call=force_batch_call,
            )

            addresses_to_reindex = set()
            for safe_status, blockchain_nonce in zip(
                safe_statuses_list, blockchain_nonces
            ):
                address = safe_status.address
                nonce = safe_status.nonce
                if safe_status.is_corrupted():
                    self.stdout.write(
                        self.style.WARNING(
                            f"Safe={address} is corrupted, has some old "
                            f"transactions missing"
                        )
                    )
                    addresses_to_reindex.add(address)

                if blockchain_nonce is None:
                    self.stdout.write(
                        self.style.WARNING(
                            f"Safe={address} looks problematic, "
                            f"cannot retrieve blockchain-nonce"
                        )
                    )
                elif nonce != blockchain_nonce:
                    self.stdout.write(
                        self.style.WARNING(
                            f"Safe={address} stored nonce={nonce} is "
                            f"different from blockchain-nonce={blockchain_nonce}"
                        )
                    )
                    if last_valid_transaction := MultisigTransaction.objects.last_valid_transaction(
                        address
                    ):
                        self.stdout.write(
                            self.style.WARNING(
                                f"Last valid transaction for Safe={address} has safe-nonce={last_valid_transaction.nonce} "
                                f"safe-transaction-hash={last_valid_transaction.safe_tx_hash} and "
                                f"ethereum-tx-hash={last_valid_transaction.ethereum_tx_id}"
                            )
                        )
                        first_issue_block_number = min(
                            last_valid_transaction.ethereum_tx.block_id,
                            first_issue_block_number,
                        )
                    addresses_to_reindex.add(address)

            if fix and addresses_to_reindex:
                all_addresses_to_reindex |= addresses_to_reindex
                self.stdout.write(
                    self.style.SUCCESS(f"Fixing Safes={addresses_to_reindex}")
                )
                index_service.reprocess_addresses(addresses_to_reindex)

        if all_addresses_to_reindex:
            self.stdout.write(
                self.style.SUCCESS(
                    f"First issue found on {first_issue_block_number} - Fixed Safes {all_addresses_to_reindex}"
                )
            )

'''
'''--- safe_transaction_service/history/management/commands/decode_txs_again.py ---
from django.core.management.base import BaseCommand

from safe_transaction_service.contracts.tx_decoder import (
    CannotDecode,
    get_safe_tx_decoder,
)

from ...models import InternalTx, InternalTxDecoded

class Command(BaseCommand):
    help = "Decode txs again. Useful when you add a new abi to decode to process old indexed transactions"

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS("Decoding txs again"))
        tx_decoder = get_safe_tx_decoder()
        found = 0
        total = InternalTx.objects.can_be_decoded().count()
        for i, internal_tx in enumerate(InternalTx.objects.can_be_decoded().iterator()):
            if i % 50 == 0:
                self.stdout.write(self.style.SUCCESS(f"Processing {i}/{total}"))
            try:
                function_name, arguments = tx_decoder.decode_transaction(
                    bytes(internal_tx.data)
                )
                InternalTxDecoded.objects.create(
                    internal_tx=internal_tx,
                    function_name=function_name,
                    arguments=arguments,
                )
                found += 1
                self.stdout.write(
                    self.style.SUCCESS(
                        f"A new tx with fn-name={function_name} has been decoded"
                    )
                )
            except CannotDecode:
                pass
        self.stdout.write(
            self.style.SUCCESS(
                f"End decoding of txs. {found} new txs have been decoded"
            )
        )

'''
'''--- safe_transaction_service/history/management/commands/export_multisig_tx_data.py ---
import json

from django.core.management.base import BaseCommand

from safe_transaction_service.contracts.tx_decoder import get_db_tx_decoder

from ...models import MultisigTransaction

class Command(BaseCommand):
    help = "Exports multisig tx data"

    def add_arguments(self, parser):
        parser.add_argument("--file-name", help="Filename", default="result.csv")

    def handle(self, *args, **options):
        file_name = options["file_name"]

        queryset = MultisigTransaction.objects.exclude(origin__exact={}).exclude(
            ethereum_tx=None
        )
        count = queryset.count()
        self.stdout.write(
            self.style.SUCCESS(
                f"Start exporting of {queryset.count()} "
                f"multisig tx data to {file_name}"
            )
        )
        if count:
            with open(file_name, "w") as f:
                decoder = get_db_tx_decoder()
                f.write(
                    "|".join(
                        [
                            "Execution date",
                            "tx-hash",
                            "safe-address",
                            "gas_price",
                            "gas_limit",
                            "gas_used",
                            "to",
                            "failed",
                            "origin",
                            "decodedData",
                        ]
                    )
                    + "\n"
                )
                for m in queryset.select_related("ethereum_tx__block"):
                    ethereum_tx = m.ethereum_tx
                    f.write(
                        "|".join(
                            [
                                str(m.execution_date),
                                m.ethereum_tx_id,
                                m.safe,
                                str(ethereum_tx.gas_price),
                                str(m.ethereum_tx.gas),
                                str(m.ethereum_tx.gas_used),
                                m.to,
                                str(m.failed),
                                m.origin,
                                json.dumps(decoder.get_data_decoded(m.data.tobytes()))
                                if m.data
                                else "",
                            ]
                        )
                        + "\n"
                    )
            self.stdout.write(
                self.style.SUCCESS(f"Multisig tx data was exported to {file_name}")
            )

'''
'''--- safe_transaction_service/history/management/commands/fix_ethereum_logs.py ---
from django.core.management.base import BaseCommand

from gnosis.eth import EthereumClientProvider

from ...models import EthereumTx
from ...utils import clean_receipt_log

class Command(BaseCommand):
    help = "Add missing address to every EthereumTx log"

    def handle(self, *args, **options):
        # We need to add `address` to the logs, so we exclude empty logs and logs already containing `address`
        ethereum_client = EthereumClientProvider()
        queryset = EthereumTx.objects.exclude(logs__0__has_key="address").exclude(
            logs=[]
        )
        total = queryset.count()
        processed = 200
        self.stdout.write(
            self.style.SUCCESS(f"Fixing ethereum logs. {total} remaining to be fixed")
        )
        while True:
            ethereum_txs = queryset[:processed]
            if not ethereum_txs:
                break

            tx_hashes = [ethereum_tx.tx_hash for ethereum_tx in ethereum_txs]
            try:
                tx_receipts = ethereum_client.get_transaction_receipts(tx_hashes)
                for ethereum_tx, tx_receipt in zip(ethereum_txs, tx_receipts):
                    ethereum_tx.logs = [
                        clean_receipt_log(log) for log in tx_receipt["logs"]
                    ]
                    ethereum_tx.save(update_fields=["logs"])
                    total -= 1

                self.stdout.write(
                    self.style.SUCCESS(
                        f"Fixed {processed} ethereum logs. {total} remaining to be fixed"
                    )
                )
            except IOError:
                self.stdout.write(
                    self.style.WARNING(
                        "Node connection error when retrieving tx receipts"
                    )
                )
        self.stdout.write(
            self.style.SUCCESS(f"End fixing txs. {total} have been fixed")
        )

'''
'''--- safe_transaction_service/history/management/commands/fix_ethereum_txs.py ---
from typing import Iterator

from django.core.management.base import BaseCommand

from gnosis.eth import EthereumClientProvider

from ...models import EthereumTx

class Command(BaseCommand):
    help = "Fix EIP1559 transactions"

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.ethereum_client = EthereumClientProvider()

    def fix_ethereum_txs(self, ethereum_txs: Iterator[EthereumTx]):
        if ethereum_txs:
            txs = self.ethereum_client.get_transactions(
                [ethereum_tx.tx_hash for ethereum_tx in ethereum_txs]
            )
            for tx, ethereum_tx in zip(txs, ethereum_txs):
                if tx and "maxFeePerGas" in tx:
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Fixing tx with tx-hash={ethereum_tx.tx_hash}"
                        )
                    )
                    ethereum_tx.max_fee_per_gas = tx.get("maxFeePerGas")
                    ethereum_tx.max_priority_fee_per_gas = tx.get(
                        "maxPriorityFeePerGas"
                    )
                    ethereum_tx.type = int(tx.get("type", "0x0"), 0)
                    ethereum_tx.save(
                        update_fields=[
                            "max_fee_per_gas",
                            "max_priority_fee_per_gas",
                            "type",
                        ]
                    )

    def handle(self, *args, **options):
        queryset = EthereumTx.objects.filter(type=0).order_by("-block_id")
        total = queryset.count()
        self.stdout.write(
            self.style.SUCCESS(f"Fixing ethereum txs. {total} remaining to be fixed")
        )
        ethereum_txs = []
        for i, ethereum_tx in enumerate(queryset.iterator()):
            ethereum_txs.append(ethereum_tx)
            if len(ethereum_txs) == 500:
                self.fix_ethereum_txs(ethereum_txs)
                ethereum_txs.clear()
                self.stdout.write(self.style.SUCCESS(f"Processing {i}/{total}"))

        self.fix_ethereum_txs(ethereum_txs)

'''
'''--- safe_transaction_service/history/management/commands/index_erc20.py ---
from django.core.management.base import BaseCommand

from ...tasks import index_erc20_events_out_of_sync_task

class Command(BaseCommand):
    help = "Force indexing of ERC20/721 if transfers are not updated for a Safe"

    def add_arguments(self, parser):
        group = parser.add_mutually_exclusive_group()
        group.add_argument("--addresses", nargs="+", help="Safe addresses")
        group.add_argument(
            "--number-of-addresses",
            type=int,
            help="Number of not updated addresses to process",
            default=100,
        )

        parser.add_argument(
            "--block-process-limit",
            type=int,
            help="Number of blocks to query each time",
            default=None,
        )
        parser.add_argument(
            "--block-process-limit-max",
            type=int,
            help="Max number of blocks to query each time",
            default=None,
        )
        parser.add_argument(
            "--sync",
            help="Don't trigger an async task",
            action="store_true",
            default=False,
        )

    def handle(self, *args, **options):
        addresses = options["addresses"]
        number_of_addresses = options["number_of_addresses"]
        sync = options["sync"]

        if block_process_limit := options["block_process_limit"]:
            self.stdout.write(
                self.style.SUCCESS(
                    f"Setting block-process-limit to {block_process_limit}"
                )
            )
        if block_process_limit_max := options["block_process_limit_max"]:
            self.stdout.write(
                self.style.SUCCESS(
                    f"Setting block-process-limit-max to {block_process_limit_max}"
                )
            )
        arguments = {
            "block_process_limit": block_process_limit,
            "block_process_limit_max": block_process_limit_max,
            "addresses": addresses,
            "number_of_addresses": number_of_addresses,
        }
        if sync:
            index_erc20_events_out_of_sync_task(**arguments)
        else:
            index_erc20_events_out_of_sync_task.delay(**arguments)

'''
'''--- safe_transaction_service/history/management/commands/process_txs_again.py ---
import logging

from django.core.management import call_command
from django.core.management.base import BaseCommand
from django.db import transaction

from ...models import InternalTxDecoded
from ...services import IndexServiceProvider
from ...tasks import process_decoded_internal_txs_task
from . import decode_txs_again

class Command(BaseCommand):
    help = "Delete processed entities and process traces again"

    def add_arguments(self, parser):
        parser.add_argument(
            "--sync", help="Don't use an async task", action="store_true", default=False
        )
        parser.add_argument(
            "--decode", help="Decode txs again", action="store_true", default=False
        )

    def handle(self, *args, **options):
        sync = options["sync"]
        decode = options["decode"]

        with transaction.atomic():
            if decode:
                self.stdout.write(self.style.SUCCESS("Deleting InternalTxDecoded"))
                InternalTxDecoded.objects.all().delete()
                self.stdout.write(self.style.SUCCESS("Decoding InternalTxs"))
                call_command(decode_txs_again.Command(), verbosity=0)
                self.stdout.write(self.style.SUCCESS("Decoded InternalTxs"))

            self.stdout.write(self.style.SUCCESS("Removing elements from database"))
            IndexServiceProvider().reprocess_all()

        if not sync:
            process_decoded_internal_txs_task.delay()
        else:
            root_logger = logging.getLogger("")
            root_logger.setLevel(logging.INFO)
            process_decoded_internal_txs_task()
        self.stdout.write(self.style.SUCCESS("All prepared to process again"))

'''
'''--- safe_transaction_service/history/management/commands/reindex_erc20.py ---
from typing import Optional, Sequence

from eth_typing import ChecksumAddress

from ...services import IndexServiceProvider
from .reindex_master_copies import Command as ReindexMasterCopiesCommand

class Command(ReindexMasterCopiesCommand):
    help = "Force reindexing of erc20/721 events"

    def reindex(
        self,
        from_block_number: int,
        block_process_limit: Optional[int],
        addresses: Optional[Sequence[ChecksumAddress]],
    ) -> None:
        return IndexServiceProvider().reindex_erc20_events(
            from_block_number,
            block_process_limit=block_process_limit,
            addresses=addresses,
        )

'''
'''--- safe_transaction_service/history/management/commands/reindex_master_copies.py ---
from typing import Optional, Sequence

from django.core.management.base import BaseCommand

from eth_typing import ChecksumAddress

from ...services import IndexServiceProvider

class Command(BaseCommand):
    help = "Force reindexing of Safe events/traces (depending on the running mode)"

    def add_arguments(self, parser):
        parser.add_argument(
            "--addresses",
            nargs="+",
            help="Safe addresses. If not provided all will be reindexed",
        )
        parser.add_argument(
            "--block-process-limit",
            type=int,
            help="Number of blocks to query each time",
            default=100,
        )
        parser.add_argument(
            "--from-block-number",
            type=int,
            help="Which block to start reindexing from",
            required=True,
        )

    def handle(self, *args, **options):
        block_process_limit = options["block_process_limit"]
        from_block_number = options["from_block_number"]
        self.stdout.write(
            self.style.SUCCESS(f"Setting block-process-limit to {block_process_limit}")
        )
        self.stdout.write(
            self.style.SUCCESS(f"Setting from-block-number to {from_block_number}")
        )

        self.reindex(from_block_number, block_process_limit, options["addresses"])

    def reindex(
        self,
        from_block_number: int,
        block_process_limit: Optional[int],
        addresses: Optional[Sequence[ChecksumAddress]],
    ) -> None:
        return IndexServiceProvider().reindex_master_copies(
            from_block_number,
            block_process_limit=block_process_limit,
            addresses=addresses,
        )

'''
'''--- safe_transaction_service/history/management/commands/send_slack_notification.py ---
from django.apps import apps
from django.conf import settings
from django.core.management.base import BaseCommand

import requests
from requests import RequestException

from gnosis.eth import EthereumClientProvider

from safe_transaction_service import __version__

class Command(BaseCommand):
    help = "Send slack notification"

    def handle(self, *args, **options):
        ethereum_client = EthereumClientProvider()
        app_name = apps.get_app_config("history").verbose_name
        network_name = ethereum_client.get_network().name.capitalize()
        startup_message = f"Starting {app_name} version {__version__} on {network_name}"
        self.stdout.write(self.style.SUCCESS(startup_message))

        if settings.SLACK_API_WEBHOOK:
            try:
                r = requests.post(
                    settings.SLACK_API_WEBHOOK,
                    json={"text": startup_message},
                    timeout=5,
                )
                if r.ok:
                    self.stdout.write(
                        self.style.SUCCESS(
                            f'Slack configured, "{startup_message}" sent'
                        )
                    )
                else:
                    raise RequestException()
            except RequestException as e:
                self.stdout.write(
                    self.style.ERROR(
                        f"Cannot send slack notification to webhook "
                        f'({settings.SLACK_API_WEBHOOK}): "{e}"'
                    )
                )
        else:
            self.stdout.write(self.style.SUCCESS("Slack not configured, ignoring"))

'''
'''--- safe_transaction_service/history/management/commands/setup_service.py ---
from dataclasses import dataclass
from typing import Dict, List, Sequence, Tuple

from django.conf import settings
from django.core.management.base import BaseCommand

from django_celery_beat.models import IntervalSchedule, PeriodicTask

from gnosis.eth import EthereumClientProvider
from gnosis.eth.ethereum_client import EthereumNetwork

from ...models import ProxyFactory, SafeMasterCopy

@dataclass
class CeleryTaskConfiguration:
    name: str
    description: str
    interval: int
    period: str
    enabled: bool = True

    def create_task(self) -> Tuple[PeriodicTask, bool]:
        interval_schedule, _ = IntervalSchedule.objects.get_or_create(
            every=self.interval, period=self.period
        )
        periodic_task, created = PeriodicTask.objects.get_or_create(
            task=self.name,
            defaults={
                "name": self.description,
                "interval": interval_schedule,
                "enabled": self.enabled,
            },
        )
        if not created:
            periodic_task.name = self.description
            periodic_task.interval = interval_schedule
            periodic_task.enabled = self.enabled
            periodic_task.save()

        return periodic_task, created

TASKS = [
    CeleryTaskConfiguration(
        "safe_transaction_service.history.tasks.check_reorgs_task",
        "Check Reorgs",
        3,
        IntervalSchedule.MINUTES,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.history.tasks.check_sync_status_task",
        "Check Sync status",
        10,
        IntervalSchedule.MINUTES,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.history.tasks.index_internal_txs_task",
        "Index Internal Txs",
        5,
        IntervalSchedule.SECONDS,
        enabled=not settings.ETH_L2_NETWORK,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.history.tasks.index_safe_events_task",
        "Index Safe events (L2)",
        5,
        IntervalSchedule.SECONDS,
        enabled=settings.ETH_L2_NETWORK,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.history.tasks.index_new_proxies_task",
        "Index new Proxies",
        15,
        IntervalSchedule.SECONDS,
        enabled=settings.ETH_L2_NETWORK,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.history.tasks.index_erc20_events_task",
        "Index ERC20/721 Events",
        14,
        IntervalSchedule.SECONDS,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.history.tasks.reindex_last_hours_task",
        "Reindex master copies for the last hours",
        110,
        IntervalSchedule.MINUTES,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.history.tasks.process_decoded_internal_txs_task",
        "Process Internal Txs",
        20,
        IntervalSchedule.MINUTES,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.contracts.tasks.create_missing_contracts_with_metadata_task",
        "Index contract names and ABIs",
        1,
        IntervalSchedule.HOURS,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.contracts.tasks.create_missing_multisend_contracts_with_metadata_task",
        "Index contract names and ABIs from MultiSend transactions",
        6,
        IntervalSchedule.HOURS,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.contracts.tasks.reindex_contracts_without_metadata_task",
        "Reindex contracts with missing names or ABIs",
        7,
        IntervalSchedule.DAYS,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.tokens.tasks.fix_pool_tokens_task",
        "Fix Pool Token Names",
        1,
        IntervalSchedule.HOURS,
    ),
    CeleryTaskConfiguration(
        "safe_transaction_service.analytics.tasks.get_transactions_per_safe_app_task",
        "Run query to get number of transactions grouped by safe-app",
        7,
        IntervalSchedule.DAYS,
    ),
]

MASTER_COPIES: Dict[EthereumNetwork, List[Tuple[str, int, str]]] = {
    EthereumNetwork.MAINNET: [
        ("0x3E5c63644E683549055b9Be8653de26E0B4CD36E", 0, "1.3.0+L2"),
    ],
}

PROXY_FACTORIES: Dict[EthereumNetwork, List[Tuple[str, int]]] = {
    EthereumNetwork.MAINNET: [
        ("0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2", 0),  # v1.3.0
    ],
}

class Command(BaseCommand):
    help = "Setup Transaction Service Required Tasks"

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS("Removing old tasks"))
        PeriodicTask.objects.filter(
            task__startswith="safe_transaction_service"
        ).delete()
        self.stdout.write(self.style.SUCCESS("Old tasks were removed"))

        for task in TASKS:
            _, created = task.create_task()
            if created:
                self.stdout.write(
                    self.style.SUCCESS("Created Periodic Task %s" % task.name)
                )
            else:
                self.stdout.write(
                    self.style.SUCCESS("Task %s was already created" % task.name)
                )

        self.stdout.write(self.style.SUCCESS("Setting up Safe Contract Addresses"))
        ethereum_network = EthereumNetwork.MAINNET
        if ethereum_network in MASTER_COPIES:
            self.stdout.write(
                self.style.SUCCESS(f"Setting up {ethereum_network.name} safe addresses")
            )
            self._setup_safe_master_copies(MASTER_COPIES[ethereum_network])
        if ethereum_network in PROXY_FACTORIES:
            self.stdout.write(
                self.style.SUCCESS(
                    f"Setting up {ethereum_network.name} proxy factory addresses"
                )
            )
            self._setup_safe_proxy_factories(PROXY_FACTORIES[ethereum_network])

        if not (
            ethereum_network in MASTER_COPIES and ethereum_network in PROXY_FACTORIES
        ):
            self.stdout.write(
                self.style.WARNING("Cannot detect a valid ethereum-network")
            )

    def _setup_safe_master_copies(
        self, safe_master_copies: Sequence[Tuple[str, int, str]]
    ):
        for address, initial_block_number, version in safe_master_copies:
            safe_master_copy, _ = SafeMasterCopy.objects.get_or_create(
                address=address,
                defaults={
                    "initial_block_number": initial_block_number,
                    "tx_block_number": initial_block_number,
                    "version": version,
                    "l2": version.endswith("+L2"),
                },
            )
            if (
                safe_master_copy.version != version
                or safe_master_copy.initial_block_number != initial_block_number
            ):
                safe_master_copy.version = initial_block_number
                safe_master_copy.version = version
                safe_master_copy.save(update_fields=["initial_block_number", "version"])

    def _setup_safe_proxy_factories(
        self, safe_proxy_factories: Sequence[Tuple[str, int]]
    ):
        for address, initial_block_number in safe_proxy_factories:
            ProxyFactory.objects.get_or_create(
                address=address,
                defaults={
                    "initial_block_number": initial_block_number,
                    "tx_block_number": initial_block_number,
                },
            )

'''
'''--- safe_transaction_service/history/migrations/0001_initial.py ---
# Generated by Django 2.2.2 on 2019-06-18 16:13

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models

import model_utils.fields

import gnosis.eth.django.models

class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="MultisigTransaction",
            fields=[
                (
                    "created",
                    model_utils.fields.AutoCreatedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="created",
                    ),
                ),
                (
                    "modified",
                    model_utils.fields.AutoLastModifiedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="modified",
                    ),
                ),
                (
                    "safe_tx_hash",
                    gnosis.eth.django.models.Sha3HashField(
                        primary_key=True, serialize=False
                    ),
                ),
                ("safe", gnosis.eth.django.models.EthereumAddressField()),
                ("to", gnosis.eth.django.models.EthereumAddressField()),
                ("value", gnosis.eth.django.models.Uint256Field()),
                ("data", models.BinaryField(null=True)),
                (
                    "operation",
                    models.PositiveSmallIntegerField(
                        choices=[(0, "CALL"), (1, "DELEGATE_CALL"), (2, "CREATE")]
                    ),
                ),
                ("safe_tx_gas", gnosis.eth.django.models.Uint256Field()),
                ("base_gas", gnosis.eth.django.models.Uint256Field()),
                ("gas_price", gnosis.eth.django.models.Uint256Field()),
                ("gas_token", gnosis.eth.django.models.EthereumAddressField(null=True)),
                (
                    "refund_receiver",
                    gnosis.eth.django.models.EthereumAddressField(null=True),
                ),
                ("nonce", gnosis.eth.django.models.Uint256Field()),
                ("mined", models.BooleanField(default=False)),
                ("execution_date", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "abstract": False,
            },
        ),
        migrations.CreateModel(
            name="MultisigConfirmation",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "created",
                    model_utils.fields.AutoCreatedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="created",
                    ),
                ),
                (
                    "modified",
                    model_utils.fields.AutoLastModifiedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="modified",
                    ),
                ),
                ("owner", gnosis.eth.django.models.EthereumAddressField()),
                ("transaction_hash", gnosis.eth.django.models.Sha3HashField()),
                (
                    "confirmation_type",
                    models.PositiveSmallIntegerField(
                        choices=[(0, "CONFIRMATION"), (1, "EXECUTION")]
                    ),
                ),
                ("block_number", gnosis.eth.django.models.Uint256Field()),
                ("block_date_time", models.DateTimeField()),
                ("mined", models.BooleanField(default=False)),
                (
                    "multisig_transaction",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="confirmations",
                        to="history.MultisigTransaction",
                    ),
                ),
            ],
            options={
                "unique_together": {
                    ("multisig_transaction", "owner", "confirmation_type")
                },
            },
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0002_auto_20190725_0857.py ---
# Generated by Django 2.2.2 on 2019-07-25 08:57

from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="multisigconfirmation",
            name="signature",
            field=gnosis.eth.django.models.HexField(max_length=500, null=True),
        ),
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="block_date_time",
            field=models.DateTimeField(null=True),
        ),
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="block_number",
            field=gnosis.eth.django.models.Uint256Field(null=True),
        ),
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="transaction_hash",
            field=gnosis.eth.django.models.Sha3HashField(null=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0003_auto_20191107_1459.py ---
# Generated by Django 2.2.7 on 2019-11-07 14:59

import django.contrib.postgres.fields
import django.contrib.postgres.fields.jsonb
import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models

import model_utils.fields

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0002_auto_20190725_0857"),
    ]

    operations = [
        migrations.CreateModel(
            name="EthereumBlock",
            fields=[
                (
                    "number",
                    models.PositiveIntegerField(
                        primary_key=True, serialize=False, unique=True
                    ),
                ),
                ("gas_limit", models.PositiveIntegerField()),
                ("gas_used", models.PositiveIntegerField()),
                ("timestamp", models.DateTimeField()),
                ("block_hash", gnosis.eth.django.models.Sha3HashField(unique=True)),
                ("parent_hash", gnosis.eth.django.models.Sha3HashField(unique=True)),
                ("confirmed", models.BooleanField(db_index=True, default=False)),
            ],
        ),
        migrations.CreateModel(
            name="EthereumTx",
            fields=[
                (
                    "created",
                    model_utils.fields.AutoCreatedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="created",
                    ),
                ),
                (
                    "modified",
                    model_utils.fields.AutoLastModifiedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="modified",
                    ),
                ),
                (
                    "tx_hash",
                    gnosis.eth.django.models.Sha3HashField(
                        primary_key=True, serialize=False, unique=True
                    ),
                ),
                (
                    "gas_used",
                    gnosis.eth.django.models.Uint256Field(default=None, null=True),
                ),
                ("status", models.IntegerField(default=None, null=True)),
                (
                    "transaction_index",
                    models.PositiveIntegerField(default=None, null=True),
                ),
                (
                    "_from",
                    gnosis.eth.django.models.EthereumAddressField(
                        db_index=True, null=True
                    ),
                ),
                ("gas", gnosis.eth.django.models.Uint256Field()),
                ("gas_price", gnosis.eth.django.models.Uint256Field()),
                ("data", models.BinaryField(null=True)),
                ("nonce", gnosis.eth.django.models.Uint256Field()),
                (
                    "to",
                    gnosis.eth.django.models.EthereumAddressField(
                        db_index=True, null=True
                    ),
                ),
                ("value", gnosis.eth.django.models.Uint256Field()),
                (
                    "block",
                    models.ForeignKey(
                        default=None,
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="txs",
                        to="history.EthereumBlock",
                    ),
                ),
            ],
            options={
                "abstract": False,
            },
        ),
        migrations.CreateModel(
            name="InternalTx",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "_from",
                    gnosis.eth.django.models.EthereumAddressField(
                        db_index=True, null=True
                    ),
                ),
                ("gas", gnosis.eth.django.models.Uint256Field()),
                ("data", models.BinaryField(null=True)),
                (
                    "to",
                    gnosis.eth.django.models.EthereumAddressField(
                        db_index=True, null=True
                    ),
                ),
                ("value", gnosis.eth.django.models.Uint256Field()),
                ("gas_used", gnosis.eth.django.models.Uint256Field()),
                (
                    "contract_address",
                    gnosis.eth.django.models.EthereumAddressField(
                        db_index=True, null=True
                    ),
                ),
                ("code", models.BinaryField(null=True)),
                ("output", models.BinaryField(null=True)),
                (
                    "refund_address",
                    gnosis.eth.django.models.EthereumAddressField(
                        db_index=True, null=True
                    ),
                ),
                (
                    "tx_type",
                    models.PositiveSmallIntegerField(
                        choices=[(0, "CALL"), (1, "CREATE"), (2, "SELF_DESTRUCT")],
                        db_index=True,
                    ),
                ),
                (
                    "call_type",
                    models.PositiveSmallIntegerField(
                        choices=[(0, "CALL"), (1, "DELEGATE_CALL")],
                        db_index=True,
                        null=True,
                    ),
                ),
                ("trace_address", models.CharField(max_length=100)),
                ("error", models.CharField(max_length=100, null=True)),
                (
                    "ethereum_tx",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="internal_txs",
                        to="history.EthereumTx",
                    ),
                ),
            ],
            options={
                "unique_together": {("ethereum_tx", "trace_address")},
            },
        ),
        migrations.CreateModel(
            name="ProxyFactory",
            fields=[
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(
                        primary_key=True, serialize=False
                    ),
                ),
                ("initial_block_number", models.IntegerField(default=0)),
                ("tx_block_number", models.IntegerField(default=None, null=True)),
            ],
            options={
                "verbose_name_plural": "Proxy factories",
                "ordering": ["tx_block_number"],
            },
        ),
        migrations.CreateModel(
            name="SafeMasterCopy",
            fields=[
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(
                        primary_key=True, serialize=False
                    ),
                ),
                ("initial_block_number", models.IntegerField(default=0)),
                ("tx_block_number", models.IntegerField(default=None, null=True)),
            ],
            options={
                "verbose_name_plural": "Safe master copies",
                "ordering": ["tx_block_number"],
            },
        ),
        migrations.RemoveField(
            model_name="multisigtransaction",
            name="execution_date",
        ),
        migrations.RemoveField(
            model_name="multisigtransaction",
            name="mined",
        ),
        migrations.AddField(
            model_name="multisigconfirmation",
            name="multisig_transaction_hash",
            field=gnosis.eth.django.models.Sha3HashField(db_index=True, null=True),
        ),
        migrations.AddField(
            model_name="multisigtransaction",
            name="signatures",
            field=models.BinaryField(null=True),
        ),
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="multisig_transaction",
            field=models.ForeignKey(
                null=True,
                on_delete=django.db.models.deletion.CASCADE,
                related_name="confirmations",
                to="history.MultisigTransaction",
            ),
        ),
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="signature",
            field=gnosis.eth.django.models.HexField(
                default=None, max_length=500, null=True
            ),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressField(
                db_index=True, null=True
            ),
        ),
        migrations.AlterUniqueTogether(
            name="multisigconfirmation",
            unique_together={("multisig_transaction_hash", "owner")},
        ),
        migrations.CreateModel(
            name="InternalTxDecoded",
            fields=[
                (
                    "internal_tx",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        primary_key=True,
                        related_name="decoded_tx",
                        serialize=False,
                        to="history.InternalTx",
                    ),
                ),
                ("function_name", models.CharField(max_length=256)),
                ("arguments", django.contrib.postgres.fields.jsonb.JSONField()),
                ("processed", models.BooleanField(default=False)),
            ],
            options={
                "verbose_name_plural": "Internal txs decoded",
            },
        ),
        migrations.CreateModel(
            name="SafeContract",
            fields=[
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(
                        primary_key=True, serialize=False
                    ),
                ),
                ("erc20_block_number", models.IntegerField(default=0)),
                (
                    "ethereum_tx",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="safe_contracts",
                        to="history.EthereumTx",
                    ),
                ),
            ],
        ),
        migrations.RemoveField(
            model_name="multisigconfirmation",
            name="block_date_time",
        ),
        migrations.RemoveField(
            model_name="multisigconfirmation",
            name="block_number",
        ),
        migrations.RemoveField(
            model_name="multisigconfirmation",
            name="confirmation_type",
        ),
        migrations.RemoveField(
            model_name="multisigconfirmation",
            name="mined",
        ),
        migrations.RemoveField(
            model_name="multisigconfirmation",
            name="transaction_hash",
        ),
        migrations.AddField(
            model_name="multisigconfirmation",
            name="ethereum_tx",
            field=models.ForeignKey(
                null=True,
                on_delete=django.db.models.deletion.CASCADE,
                related_name="multisig_confirmations",
                to="history.EthereumTx",
            ),
        ),
        migrations.AddField(
            model_name="multisigtransaction",
            name="ethereum_tx",
            field=models.ForeignKey(
                blank=True,
                default=None,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="multisig_txs",
                to="history.EthereumTx",
            ),
        ),
        migrations.CreateModel(
            name="SafeStatus",
            fields=[
                (
                    "internal_tx",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        primary_key=True,
                        related_name="safe_status",
                        serialize=False,
                        to="history.InternalTx",
                    ),
                ),
                ("address", gnosis.eth.django.models.EthereumAddressField()),
                (
                    "owners",
                    django.contrib.postgres.fields.ArrayField(
                        base_field=gnosis.eth.django.models.EthereumAddressField(),
                        size=None,
                    ),
                ),
                ("threshold", gnosis.eth.django.models.Uint256Field()),
                ("nonce", gnosis.eth.django.models.Uint256Field(default=0)),
                ("master_copy", gnosis.eth.django.models.EthereumAddressField()),
            ],
            options={
                "verbose_name_plural": "Safe statuses",
                "unique_together": {("internal_tx", "address")},
            },
        ),
        migrations.CreateModel(
            name="EthereumEvent",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("log_index", models.PositiveIntegerField()),
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(db_index=True),
                ),
                ("topic", gnosis.eth.django.models.Sha3HashField(db_index=True)),
                (
                    "topics",
                    django.contrib.postgres.fields.ArrayField(
                        base_field=gnosis.eth.django.models.Sha3HashField(), size=None
                    ),
                ),
                ("arguments", django.contrib.postgres.fields.jsonb.JSONField()),
                (
                    "ethereum_tx",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="events",
                        to="history.EthereumTx",
                    ),
                ),
            ],
            options={
                "unique_together": {("ethereum_tx", "log_index")},
            },
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0004_auto_20191118_1001.py ---
# Generated by Django 2.2.7 on 2019-11-18 10:01

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0003_auto_20191107_1459"),
    ]

    operations = [
        migrations.AlterField(
            model_name="internaltx",
            name="error",
            field=models.CharField(max_length=200, null=True),
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="trace_address",
            field=models.CharField(max_length=600),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0005_multisigtransaction_failed.py ---
# Generated by Django 2.2.8 on 2019-12-20 12:39

from django.db import migrations, models

from safe_transaction_service.history.indexers.tx_processor import (
    SafeTxProcessorProvider,
)

def set_failed_for_multisig_txs(apps, schema_editor):
    # We can't import the Person model directly as it may be a newer
    # version than this migration expects. We use the historical version.
    safe_tx_processor = SafeTxProcessorProvider()
    MultisigTransaction = apps.get_model("history", "MultisigTransaction")
    for multisig_tx in MultisigTransaction.objects.filter(failed=None).exclude(
        ethereum_tx=None
    ):
        multisig_tx.failed = safe_tx_processor.is_failed(
            multisig_tx.ethereum_tx_id, multisig_tx.safe_tx_hash
        )
        multisig_tx.save(update_fields=["failed"])

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0004_auto_20191118_1001"),
    ]

    operations = [
        migrations.AddField(
            model_name="multisigtransaction",
            name="failed",
            field=models.NullBooleanField(default=None),
        ),
        migrations.RunPython(
            set_failed_for_multisig_txs, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0006_auto_20200113_1204.py ---
# Generated by Django 2.2.8 on 2020-01-13 12:04

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0005_multisigtransaction_failed"),
    ]

    operations = [
        migrations.AlterField(
            model_name="multisigtransaction",
            name="nonce",
            field=gnosis.eth.django.models.Uint256Field(db_index=True),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="safe",
            field=gnosis.eth.django.models.EthereumAddressField(db_index=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0007_auto_20200122_1305.py ---
# Generated by Django 3.0.2 on 2020-01-22 13:05

from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0006_auto_20200113_1204"),
    ]

    operations = [
        migrations.AlterField(
            model_name="safestatus",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressField(db_index=True),
        ),
        migrations.CreateModel(
            name="WebHook",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(db_index=True),
                ),
                ("url", models.URLField()),
                ("new_confirmation", models.BooleanField(default=True)),
                ("pending_outgoing_transaction", models.BooleanField(default=True)),
                (
                    "new_executed_outgoing_transaction",
                    models.BooleanField(default=True),
                ),
                ("new_incoming_transaction", models.BooleanField(default=True)),
            ],
            options={
                "unique_together": {("address", "url")},
            },
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0008_ethereumtx_logs.py ---
# Generated by Django 3.0.2 on 2020-01-27 10:17

import django.contrib.postgres.fields
import django.contrib.postgres.fields.jsonb
from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0007_auto_20200122_1305"),
    ]

    operations = [
        migrations.AddField(
            model_name="ethereumtx",
            name="logs",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=django.contrib.postgres.fields.jsonb.JSONField(),
                default=None,
                null=True,
                size=None,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0009_multisigtransaction_origin.py ---
# Generated by Django 3.0.3 on 2020-02-12 13:04

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0008_ethereumtx_logs"),
    ]

    operations = [
        migrations.AddField(
            model_name="multisigtransaction",
            name="origin",
            field=models.CharField(default=None, max_length=100, null=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0010_auto_20200226_1508.py ---
# Generated by Django 3.0.3 on 2020-02-26 15:08

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0009_multisigtransaction_origin"),
    ]

    operations = [
        migrations.AlterField(
            model_name="webhook",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressField(
                blank=True, db_index=True
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0011_auto_20200303_0956.py ---
# Generated by Django 3.0.3 on 2020-03-03 09:56

import django.contrib.postgres.fields
from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0010_auto_20200226_1508"),
    ]

    operations = [
        migrations.AddField(
            model_name="safestatus",
            name="enabled_modules",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=gnosis.eth.django.models.EthereumAddressField(),
                default=list,
                size=None,
            ),
        ),
        migrations.AddField(
            model_name="safestatus",
            name="fallback_handler",
            field=gnosis.eth.django.models.EthereumAddressField(
                default="0x0000000000000000000000000000000000000000"
            ),
            preserve_default=False,
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0012_moduletransaction.py ---
# Generated by Django 3.0.3 on 2020-03-03 16:33

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models

import model_utils.fields

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0011_auto_20200303_0956"),
    ]

    operations = [
        migrations.CreateModel(
            name="ModuleTransaction",
            fields=[
                (
                    "created",
                    model_utils.fields.AutoCreatedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="created",
                    ),
                ),
                (
                    "modified",
                    model_utils.fields.AutoLastModifiedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="modified",
                    ),
                ),
                (
                    "internal_tx",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        primary_key=True,
                        related_name="module_tx",
                        serialize=False,
                        to="history.InternalTx",
                    ),
                ),
                ("safe", gnosis.eth.django.models.EthereumAddressField(db_index=True)),
                (
                    "module",
                    gnosis.eth.django.models.EthereumAddressField(db_index=True),
                ),
                ("to", gnosis.eth.django.models.EthereumAddressField(db_index=True)),
                ("value", gnosis.eth.django.models.Uint256Field()),
                ("data", models.BinaryField(null=True)),
                (
                    "operation",
                    models.PositiveSmallIntegerField(
                        choices=[(0, "CALL"), (1, "DELEGATE_CALL"), (2, "CREATE")]
                    ),
                ),
            ],
            options={
                "abstract": False,
            },
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0013_multisigtransaction_fix_failed.py ---
from django.db import migrations
from django.db.models import Q

from safe_transaction_service.history.indexers.tx_processor import (
    SafeTxProcessor,
    SafeTxProcessorProvider,
)

def set_failed_for_multisig_txs(apps, schema_editor):
    # We can't import the Person model directly as it may be a newer
    # version than this migration expects. We use the historical version.
    safe_tx_processor: SafeTxProcessor = SafeTxProcessorProvider()
    MultisigTransaction = apps.get_model("history", "MultisigTransaction")
    for multisig_tx in MultisigTransaction.objects.exclude(
        Q(ethereum_tx=None) | Q(failed=True)
    ).select_related("ethereum_tx"):
        current_failed = multisig_tx.failed
        multisig_tx.failed = safe_tx_processor.is_failed(
            multisig_tx.ethereum_tx, multisig_tx.safe_tx_hash
        )
        if multisig_tx.failed != current_failed:
            multisig_tx.save(update_fields=["failed"])

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0012_moduletransaction"),
    ]

    operations = [
        migrations.RunPython(
            set_failed_for_multisig_txs, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0014_auto_20200327_0954.py ---
# Generated by Django 3.0.4 on 2020-03-27 09:54

from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0013_multisigtransaction_fix_failed"),
    ]

    operations = [
        migrations.AlterField(
            model_name="ethereumblock",
            name="number",
            field=models.PositiveIntegerField(primary_key=True, serialize=False),
        ),
        migrations.AlterField(
            model_name="ethereumtx",
            name="status",
            field=models.IntegerField(db_index=True, default=None, null=True),
        ),
        migrations.AlterField(
            model_name="ethereumtx",
            name="tx_hash",
            field=gnosis.eth.django.models.Sha3HashField(
                primary_key=True, serialize=False
            ),
        ),
        migrations.AlterField(
            model_name="internaltxdecoded",
            name="function_name",
            field=models.CharField(db_index=True, max_length=256),
        ),
        migrations.AlterField(
            model_name="internaltxdecoded",
            name="processed",
            field=models.BooleanField(db_index=True, default=False),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="failed",
            field=models.NullBooleanField(db_index=True, default=None),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0015_auto_20200327_1233.py ---
# Generated by Django 3.0.4 on 2020-03-27 12:33

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0014_auto_20200327_0954"),
    ]

    operations = [
        migrations.AlterField(
            model_name="internaltxdecoded",
            name="processed",
            field=models.BooleanField(default=False),
        ),
        migrations.AlterField(
            model_name="proxyfactory",
            name="tx_block_number",
            field=models.IntegerField(db_index=True, default=None, null=True),
        ),
        migrations.AlterField(
            model_name="safecontract",
            name="erc20_block_number",
            field=models.IntegerField(db_index=True, default=0),
        ),
        migrations.AlterField(
            model_name="safemastercopy",
            name="tx_block_number",
            field=models.IntegerField(db_index=True, default=None, null=True),
        ),
        migrations.AddIndex(
            model_name="internaltxdecoded",
            index=models.Index(
                condition=models.Q(processed=False),
                fields=["processed"],
                name="history_decoded_processed_idx",
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0016_multisigconfirmation_signature_type.py ---
# Generated by Django 3.0.4 on 2020-04-01 09:42

from django.db import migrations, models

from hexbytes import HexBytes

from gnosis.safe.safe_signature import (
    SafeSignature,
    SafeSignatureApprovedHash,
    SafeSignatureType,
)

def add_signature_type(apps, schema_editor):
    MultisigConfirmation = apps.get_model("history", "MultisigConfirmation")
    MultisigTransaction = apps.get_model("history", "MultisigTransaction")

    for multisig_confirmation in MultisigConfirmation.objects.all():
        if not multisig_confirmation.signature:  # It's an approvedHash
            multisig_confirmation.signature = SafeSignatureApprovedHash.build_for_owner(
                multisig_confirmation.owner,
                multisig_confirmation.multisig_transaction_hash,
            ).export_signature()

            multisig_confirmation.signature_type = SafeSignatureType.APPROVED_HASH.value
            multisig_confirmation.save(update_fields=["signature_type", "signature"])
        else:
            for safe_signature in SafeSignature.parse_signature(
                multisig_confirmation.signature,
                multisig_confirmation.multisig_transaction_hash,
            ):
                multisig_confirmation.signature_type = (
                    safe_signature.signature_type.value
                )
                multisig_confirmation.save(update_fields=["signature_type"])

    for multisig_tx in MultisigTransaction.objects.exclude(signatures=None):
        for safe_signature in SafeSignature.parse_signature(
            multisig_tx.signatures.tobytes(), HexBytes(multisig_tx.safe_tx_hash)
        ):
            multisig_confirmation, _ = MultisigConfirmation.objects.get_or_create(
                multisig_transaction_hash=multisig_tx.safe_tx_hash,
                owner=safe_signature.owner,
                defaults={
                    "ethereum_tx": None,
                    "multisig_transaction": multisig_tx,
                    "signature": safe_signature.export_signature(),
                    "signature_type": safe_signature.signature_type.value,
                },
            )
            if (
                multisig_confirmation.signature != safe_signature.export_signature()
                or multisig_confirmation.signature_type
                != safe_signature.signature_type.value
            ):

                multisig_confirmation.signature = safe_signature.export_signature()
                multisig_confirmation.signature_type = (
                    safe_signature.signature_type.value
                )
                multisig_confirmation.save(
                    update_fields=["signature", "signature_type"]
                )

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0015_auto_20200327_1233"),
    ]

    operations = [
        migrations.AddField(
            model_name="multisigconfirmation",
            name="signature_type",
            field=models.PositiveSmallIntegerField(
                choices=[
                    (0, "CONTRACT_SIGNATURE"),
                    (1, "APPROVED_HASH"),
                    (2, "EOA"),
                    (3, "ETH_SIGN"),
                ],
                db_index=True,
                default=1,
            ),
            preserve_default=False,
        ),
        migrations.RunPython(
            add_signature_type, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0017_safecontractdelegate.py ---
# Generated by Django 3.0.4 on 2020-04-15 10:04

import django.db.models.deletion
from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0016_multisigconfirmation_signature_type"),
    ]

    operations = [
        migrations.CreateModel(
            name="SafeContractDelegate",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("delegate", gnosis.eth.django.models.EthereumAddressField()),
                ("delegator", gnosis.eth.django.models.EthereumAddressField()),
                ("label", models.CharField(max_length=50)),
                ("read", models.BooleanField(default=True)),
                ("write", models.BooleanField(default=True)),
                (
                    "safe_contract",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="safe_contract_delegates",
                        to="history.SafeContract",
                    ),
                ),
            ],
            options={
                "unique_together": {("safe_contract", "delegate")},
            },
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0018_multisigtransaction_trusted.py ---
# Generated by Django 3.0.6 on 2020-05-25 15:23

from django.db import migrations, models

def set_confirmed_txs_trusted(apps, schema_editor):
    MultisigTransaction = apps.get_model("history", "MultisigTransaction")
    MultisigTransaction.objects.exclude(confirmations__isnull=True).update(trusted=True)

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0017_safecontractdelegate"),
    ]

    operations = [
        migrations.AddField(
            model_name="multisigtransaction",
            name="trusted",
            field=models.BooleanField(db_index=True, default=False),
        ),
        migrations.RunPython(
            set_confirmed_txs_trusted, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0019_transactions_data_none.py ---
from django.db import migrations

def set_data_none(apps, schema_editor):
    MultisigTransaction = apps.get_model("history", "MultisigTransaction")
    ModuleTransaction = apps.get_model("history", "ModuleTransaction")
    EthereumTx = apps.get_model("history", "EthereumTx")
    for Model in (MultisigTransaction, ModuleTransaction, EthereumTx):
        Model.objects.filter(data=b"").update(data=None)

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0018_multisigtransaction_trusted"),
    ]

    operations = [
        migrations.RunPython(set_data_none, reverse_code=migrations.RunPython.noop),
    ]

'''
'''--- safe_transaction_service/history/migrations/0020_safemastercopy_version.py ---
# Generated by Django 3.0.8 on 2020-07-27 12:13

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0019_transactions_data_none"),
    ]

    operations = [
        migrations.AddField(
            model_name="safemastercopy",
            name="version",
            field=models.CharField(default="unknown", max_length=20),
            preserve_default=False,
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0021_moduletransaction_failed.py ---
# Generated by Django 3.0.8 on 2020-07-28 11:14

from django.db import migrations, models

from ..indexers.tx_processor import SafeTxProcessor, SafeTxProcessorProvider

def set_failed_for_module_txs(apps, schema_editor):
    safe_tx_processor: SafeTxProcessor = SafeTxProcessorProvider()
    ModuleTransaction = apps.get_model("history", "ModuleTransaction")
    for module_tx in ModuleTransaction.objects.select_related(
        "internal_tx__ethereum_tx"
    ).iterator():
        current_failed = module_tx.failed
        module_tx.failed = safe_tx_processor.is_module_failed(
            module_tx.internal_tx.ethereum_tx, module_tx.module, module_tx.safe
        )
        if module_tx.failed != current_failed:
            module_tx.save(update_fields=["failed"])

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0020_safemastercopy_version"),
    ]

    operations = [
        migrations.AddField(
            model_name="moduletransaction",
            name="failed",
            field=models.BooleanField(default=False),
        ),
        migrations.RunPython(
            set_failed_for_module_txs, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0022_auto_20200903_1045.py ---
# Generated by Django 3.0.9 on 2020-09-03 10:45

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0021_moduletransaction_failed"),
    ]

    operations = [
        migrations.AlterModelOptions(
            name="multisigconfirmation",
            options={"ordering": ["created"]},
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0023_auto_20200924_0841.py ---
# Generated by Django 3.0.9 on 2020-09-24 08:41

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0022_auto_20200903_1045"),
    ]

    operations = [
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="signature",
            field=gnosis.eth.django.models.HexField(
                default=None, max_length=2000, null=True
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0024_auto_20201014_1523.py ---
# Generated by Django 3.0.10 on 2020-10-14 15:23

import django.contrib.postgres.indexes
from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0023_auto_20200924_0841"),
    ]

    operations = [
        migrations.AddIndex(
            model_name="ethereumevent",
            index=django.contrib.postgres.indexes.GinIndex(
                fields=["arguments"], name="history_eth_argumen_ba76e0_gin"
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0025_auto_20201015_1147.py ---
# Generated by Django 3.1.2 on 2020-10-15 11:47

import django.contrib.postgres.fields
from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0024_auto_20201014_1523"),
    ]

    operations = [
        migrations.AlterField(
            model_name="ethereumevent",
            name="arguments",
            field=models.JSONField(),
        ),
        migrations.AlterField(
            model_name="ethereumtx",
            name="logs",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=models.JSONField(), default=None, null=True, size=None
            ),
        ),
        migrations.AlterField(
            model_name="internaltxdecoded",
            name="arguments",
            field=models.JSONField(),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="failed",
            field=models.BooleanField(db_index=True, default=None, null=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0026_auto_20201030_1355.py ---
# Generated by Django 3.1.2 on 2020-10-30 13:55

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0025_auto_20201015_1147"),
    ]

    operations = [
        # Create btree index for EthereumEvents
        migrations.RunSQL(
            "CREATE INDEX history_ethereumevent_arguments_to ON history_ethereumevent USING BTREE (((arguments->'to')::text))",
            reverse_sql="DROP INDEX history_ethereumevent_arguments_to",
        ),
        migrations.RunSQL(
            "CREATE INDEX history_ethereumevent_arguments_from ON history_ethereumevent USING BTREE (((arguments->'from')::text))",
            reverse_sql="DROP INDEX history_ethereumevent_arguments_from",
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0027_remove_errored_internal_txs_20201112_1547.py ---
# Generated by Django 3.1.3 on 2020-11-12 15:47

from django.db import migrations
from django.db.migrations import RunPython
from django.db.models.expressions import F, OuterRef, RawSQL, Subquery

def delete_errored_internal_txs(apps, schema_editor):
    """
    Previously all traces were stored, even the errored ones. This method will delete old errored traces still present
    on the database
    :param apps:
    :param schema_editor:
    :return:
    """
    InternalTx = apps.get_model("history", "InternalTx")

    parent_errored_query = (
        InternalTx.objects.annotate(
            child_trace_address=RawSQL('"history_internaltx"."trace_address"', tuple())
            #  Django bug, so we use RawSQL instead of: child_trace_address=OuterRef('trace_address')
        )
        .filter(
            child_trace_address__startswith=F("trace_address"),
            ethereum_tx=OuterRef("ethereum_tx"),
        )
        .exclude(error=None)
    )

    InternalTx.objects.annotate(
        parent_errored=Subquery(parent_errored_query.values("pk")[:1])
    ).exclude(
        parent_errored=None,
    ).delete()

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0026_auto_20201030_1355"),
    ]

    operations = [
        RunPython(delete_errored_internal_txs, reverse_code=migrations.RunPython.noop)
    ]

'''
'''--- safe_transaction_service/history/migrations/0028_auto_20201112_1613.py ---
# Generated by Django 3.1.3 on 2020-11-12 16:13

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0027_remove_errored_internal_txs_20201112_1547"),
    ]

    operations = [
        migrations.AlterField(
            model_name="internaltx",
            name="call_type",
            field=models.PositiveSmallIntegerField(
                choices=[
                    (0, "CALL"),
                    (1, "DELEGATE_CALL"),
                    (2, "CALL_CODE"),
                    (3, "STATIC_CALL"),
                ],
                db_index=True,
                null=True,
            ),
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="tx_type",
            field=models.PositiveSmallIntegerField(
                choices=[
                    (0, "CALL"),
                    (1, "CREATE"),
                    (2, "SELF_DESTRUCT"),
                    (3, "REWARD"),
                ],
                db_index=True,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0029_auto_20201118_1015.py ---
# Generated by Django 3.1.3 on 2020-11-18 10:15

import django.contrib.postgres.fields
from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0028_auto_20201112_1613"),
    ]

    operations = [
        migrations.AlterField(
            model_name="safestatus",
            name="owners",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=gnosis.eth.django.models.EthereumAddressField(),
                db_index=True,
                size=None,
            ),
        ),
        migrations.AddIndex(
            model_name="safestatus",
            index=models.Index(
                fields=["address", "-nonce"], name="history_saf_address_aa71bd_idx"
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0030_auto_20210203_1541.py ---
# Generated by Django 3.1.5 on 2021-02-03 15:41

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0029_auto_20201118_1015"),
    ]

    operations = [
        migrations.AlterField(
            model_name="multisigtransaction",
            name="origin",
            field=models.CharField(default=None, max_length=200, null=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0031_webhook_new_safe.py ---
# Generated by Django 3.1.7 on 2021-03-08 13:58

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0030_auto_20210203_1541"),
    ]

    operations = [
        migrations.AddField(
            model_name="webhook",
            name="new_safe",
            field=models.BooleanField(default=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0032_webhook_new_module_transaction.py ---
# Generated by Django 3.1.7 on 2021-03-18 13:17

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0031_webhook_new_safe"),
    ]

    operations = [
        migrations.AddField(
            model_name="webhook",
            name="new_module_transaction",
            field=models.BooleanField(default=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0033_auto_20210318_1654.py ---
# Generated by Django 3.1.7 on 2021-03-18 16:54

import django.contrib.postgres.fields
import django.contrib.postgres.indexes
from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0032_webhook_new_module_transaction"),
    ]

    operations = [
        migrations.AlterField(
            model_name="safestatus",
            name="owners",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=gnosis.eth.django.models.EthereumAddressField(), size=None
            ),
        ),
        migrations.AddIndex(
            model_name="safestatus",
            index=django.contrib.postgres.indexes.GinIndex(
                fields=["owners"], name="history_saf_owners_295490_gin"
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0034_webhook_new_outgoing_transaction.py ---
# Generated by Django 3.1.7 on 2021-03-31 12:20

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0033_auto_20210318_1654"),
    ]

    operations = [
        migrations.AddField(
            model_name="webhook",
            name="new_outgoing_transaction",
            field=models.BooleanField(default=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0035_safemastercopy_deployer.py ---
# Generated by Django 3.1.7 on 2021-04-05 10:38

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0034_webhook_new_outgoing_transaction"),
    ]

    operations = [
        migrations.AddField(
            model_name="safemastercopy",
            name="deployer",
            field=models.CharField(default="Gnosis", max_length=50),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0036_fix_exec_from_module.py ---
# Generated by Django 3.1.8 on 2021-04-07 11:35
import logging

from django.db import migrations

from gnosis.eth import EthereumClientProvider

from ..utils import clean_receipt_log

logger = logging.getLogger(__name__)

def fix_module_transactions(apps, schema_editor):
    InternalTxDecoded = apps.get_model("history", "InternalTxDecoded")
    InternalTxDecoded.objects.filter(
        function_name="execTransactionFromModuleReturnData"
    ).update(processed=False)

def fix_ethereum_logs(apps, schema_editor):
    EthereumTx = apps.get_model("history", "EthereumTx")
    ethereum_client = EthereumClientProvider()

    # We need to add `address` to the logs, so we exclude empty logs and logs already containing `address`
    queryset = EthereumTx.objects.exclude(logs__0__has_key="address").exclude(logs=[])
    total = queryset.count()
    processed = 200
    logger.info("Fixing ethereum logs. %d remaining to be fixed", total)
    while True:
        ethereum_txs = queryset[:processed]
        if not ethereum_txs:
            break

        tx_hashes = [ethereum_tx.tx_hash for ethereum_tx in ethereum_txs]
        try:
            tx_receipts = ethereum_client.get_transaction_receipts(tx_hashes)
            for ethereum_tx, tx_receipt in zip(ethereum_txs, tx_receipts):
                ethereum_tx.logs = [
                    clean_receipt_log(log) for log in tx_receipt["logs"]
                ]
                ethereum_tx.save(update_fields=["logs"])
                total -= 1

            logger.info(
                "Fixed %d ethereum logs. %d remaining to be fixed", processed, total
            )
        except IOError:
            logger.warning("Node connection error when retrieving tx receipts")

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0035_safemastercopy_deployer"),
    ]

    operations = [
        #  migrations.RunPython(fix_ethereum_logs, reverse_code=migrations.RunPython.noop),
        #  Use management command `fix_ethereum_logs`
        migrations.RunPython(
            fix_module_transactions, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0037_fix_failed_module_transactions.py ---
# Generated by Django 3.1.8 on 2021-04-08 10:49

from django.db import migrations

from ..indexers.tx_processor import SafeTxProcessorProvider

def fix_failed_module_transactions(apps, schema_editor):
    ModuleTransaction = apps.get_model("history", "ModuleTransaction")
    safe_tx_processor = SafeTxProcessorProvider()
    for m in ModuleTransaction.objects.select_related(
        "internal_tx__ethereum_tx"
    ).iterator():
        if safe_tx_processor.is_module_failed(
            m.internal_tx.ethereum_tx, m.module, m.safe
        ):
            m.failed = True
            m.save(update_fields=["failed"])

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0036_fix_exec_from_module"),
    ]

    operations = [
        migrations.RunPython(
            fix_failed_module_transactions, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0038_safestatus_guard.py ---
# Generated by Django 3.1.8 on 2021-04-28 12:44

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0037_fix_failed_module_transactions"),
    ]

    operations = [
        migrations.AddField(
            model_name="safestatus",
            name="guard",
            field=gnosis.eth.django.models.EthereumAddressField(
                default=None, null=True
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0039_safel2mastercopy_20210519.py ---
# Generated by Django 3.1.11 on 2021-05-19 16:08

import django.db.models.manager
from django.db import migrations, models

import gnosis.eth.django.models

import safe_transaction_service.history.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0038_safestatus_guard"),
    ]

    operations = [
        migrations.CreateModel(
            name="SafeL2MasterCopy",
            fields=[
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(
                        primary_key=True, serialize=False
                    ),
                ),
                ("initial_block_number", models.IntegerField(default=0)),
                (
                    "tx_block_number",
                    models.IntegerField(db_index=True, default=None, null=True),
                ),
                (
                    "version",
                    models.CharField(
                        max_length=20,
                        validators=[
                            safe_transaction_service.history.models.validate_version
                        ],
                    ),
                ),
                ("deployer", models.CharField(default="Gnosis", max_length=50)),
            ],
            options={
                "verbose_name_plural": "Safe L2 master copies",
            },
            managers=[
                ("custom_manager", django.db.models.manager.Manager()),
            ],
        ),
        migrations.AlterModelOptions(
            name="safemastercopy",
            options={"verbose_name_plural": "Safe master copies"},
        ),
        migrations.AlterModelManagers(
            name="safemastercopy",
            managers=[
                ("custom_manager", django.db.models.manager.Manager()),
            ],
        ),
        migrations.AlterField(
            model_name="safemastercopy",
            name="version",
            field=models.CharField(
                max_length=20,
                validators=[safe_transaction_service.history.models.validate_version],
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0040_auto_20210607_1007.py ---
# Generated by Django 3.2.4 on 2021-06-07 10:07

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0039_safel2mastercopy_20210519"),
    ]

    operations = [
        migrations.AlterModelOptions(
            name="safel2mastercopy",
            options={
                "ordering": ["tx_block_number"],
                "verbose_name_plural": "Safe L2 master copies",
            },
        ),
        migrations.AlterModelOptions(
            name="safemastercopy",
            options={
                "ordering": ["tx_block_number"],
                "verbose_name_plural": "Safe master copies",
            },
        ),
        migrations.AlterField(
            model_name="ethereumevent",
            name="id",
            field=models.BigAutoField(
                auto_created=True, primary_key=True, serialize=False, verbose_name="ID"
            ),
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="id",
            field=models.BigAutoField(
                auto_created=True, primary_key=True, serialize=False, verbose_name="ID"
            ),
        ),
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="id",
            field=models.BigAutoField(
                auto_created=True, primary_key=True, serialize=False, verbose_name="ID"
            ),
        ),
        migrations.AlterField(
            model_name="safecontractdelegate",
            name="id",
            field=models.BigAutoField(
                auto_created=True, primary_key=True, serialize=False, verbose_name="ID"
            ),
        ),
        migrations.AlterField(
            model_name="webhook",
            name="id",
            field=models.BigAutoField(
                auto_created=True, primary_key=True, serialize=False, verbose_name="ID"
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0041_auto_20210729_0916.py ---
# Generated by Django 3.2.5 on 2021-07-29 09:16

from django.db import migrations, models

def migrate_l2_master_copies(apps, schema_editor):
    """
    Migrate SafeL2MasterCopy table elements to SafeMasterCopy table

    :param apps:
    :param schema_editor:
    :return:
    """
    SafeMasterCopy = apps.get_model("history", "SafeMasterCopy")
    SafeL2MasterCopy = apps.get_model("history", "SafeL2MasterCopy")

    for l2_master_copy in SafeL2MasterCopy.custom_manager.all():
        safe_master_copy, _ = SafeMasterCopy.objects.update_or_create(
            address=l2_master_copy.address,
            defaults={
                "initial_block_number": l2_master_copy.initial_block_number,
                "tx_block_number": l2_master_copy.tx_block_number,
                "version": l2_master_copy.version,
                "l2": True,
            },
        )

def migrate_back_l2_master_copies(apps, schema_editor):
    SafeMasterCopy = apps.get_model("history", "SafeMasterCopy")
    SafeL2MasterCopy = apps.get_model("history", "SafeL2MasterCopy")

    for master_copy in SafeMasterCopy.objects.all():
        safe_master_copy, _ = SafeL2MasterCopy.custom_manager.update_or_create(
            address=master_copy.address,
            defaults={
                "initial_block_number": master_copy.initial_block_number,
                "tx_block_number": master_copy.tx_block_number,
                "version": master_copy.version,
            },
        )

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0040_auto_20210607_1007"),
    ]

    operations = [
        migrations.AlterModelManagers(
            name="safemastercopy",
            managers=[],
        ),
        migrations.AddField(
            model_name="safemastercopy",
            name="l2",
            field=models.BooleanField(default=False),
        ),
        migrations.RunPython(
            migrate_l2_master_copies, reverse_code=migrate_back_l2_master_copies
        ),
        migrations.DeleteModel(
            name="SafeL2MasterCopy",
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0042_safestatus_history_saf_address_1c362b_idx.py ---
# Generated by Django 3.2.5 on 2021-07-30 12:55

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0041_auto_20210729_0916"),
    ]

    operations = [
        migrations.AddIndex(
            model_name="safestatus",
            index=models.Index(
                fields=["address", "-nonce", "-internal_tx"],
                name="history_saf_address_1c362b_idx",
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0043_auto_20210927_1515.py ---
# Generated by Django 3.2.7 on 2021-09-27 15:15

import django.db.models.deletion
from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0042_safestatus_history_saf_address_1c362b_idx"),
    ]

    operations = [
        migrations.AlterField(
            model_name="safecontractdelegate",
            name="safe_contract",
            field=models.ForeignKey(
                default=None,
                null=True,
                on_delete=django.db.models.deletion.CASCADE,
                related_name="safe_contract_delegates",
                to="history.safecontract",
            ),
        ),
        migrations.AlterUniqueTogether(
            name="safecontractdelegate",
            unique_together={("safe_contract", "delegate", "delegator")},
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0044_reprocess_module_txs.py ---
# Generated by Django 3.2.8 on 2021-10-26 11:56

from django.db import migrations

def reprocess_module_txs(apps, schema_editor):
    ModuleTransaction = apps.get_model("history", "ModuleTransaction")
    InternalTxDecoded = apps.get_model("history", "InternalTxDecoded")
    ModuleTransaction.objects.all().delete()
    InternalTxDecoded.objects.filter(
        function_name__startswith="execTransactionFromModule"
    ).update(processed=False)

class Migration(migrations.Migration):
    dependencies = [
        ("history", "0043_auto_20210927_1515"),
    ]

    operations = [
        migrations.RunPython(
            reprocess_module_txs, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0045_erc20transfer_erc721transfer.py ---
# Generated by Django 3.2.8 on 2021-10-29 11:13

import django.db.models.deletion
from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0044_reprocess_module_txs"),
    ]

    operations = [
        migrations.CreateModel(
            name="ERC20Transfer",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(db_index=True),
                ),
                ("_from", gnosis.eth.django.models.EthereumAddressField(db_index=True)),
                ("to", gnosis.eth.django.models.EthereumAddressField(db_index=True)),
                ("log_index", models.PositiveIntegerField()),
                ("value", gnosis.eth.django.models.Uint256Field()),
                (
                    "ethereum_tx",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to="history.ethereumtx",
                    ),
                ),
            ],
            options={
                "verbose_name": "ERC20 Transfer",
                "verbose_name_plural": "ERC20 Transfers",
            },
        ),
        migrations.CreateModel(
            name="ERC721Transfer",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(db_index=True),
                ),
                ("_from", gnosis.eth.django.models.EthereumAddressField(db_index=True)),
                ("to", gnosis.eth.django.models.EthereumAddressField(db_index=True)),
                ("log_index", models.PositiveIntegerField()),
                ("token_id", gnosis.eth.django.models.Uint256Field()),
                (
                    "ethereum_tx",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to="history.ethereumtx",
                    ),
                ),
            ],
            options={
                "verbose_name": "ERC721 Transfer",
                "verbose_name_plural": "ERC721 Transfers",
            },
        ),
        migrations.RunSQL(
            """
            INSERT INTO history_erc20transfer(address, ethereum_tx_id, "_from", "to", log_index, value)
            SELECT address, ethereum_tx_id, arguments->>'from', arguments->>'to', log_index, (arguments->>'value')::numeric
            FROM history_ethereumevent WHERE arguments ? 'value'
            """
        ),
        migrations.RunSQL(
            """
            INSERT INTO history_erc721transfer(address, ethereum_tx_id, "_from", "to", log_index, token_id)
            SELECT address, ethereum_tx_id, arguments->>'from', arguments->>'to', log_index, (arguments->>'tokenId')::numeric
            FROM history_ethereumevent WHERE arguments ? 'tokenId'
            """
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0046_delete_ethereumevent.py ---
# Generated by Django 3.2.8 on 2021-10-29 15:24

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0045_erc20transfer_erc721transfer"),
    ]

    operations = [
        migrations.DeleteModel(
            name="EthereumEvent",
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0047_auto_20211102_1659.py ---
# Generated by Django 3.2.7 on 2021-11-02 16:59

from django.db import migrations
from django.db.models import Count

def _remove_duplicated(TokenTransferModel):
    for transfer in (
        TokenTransferModel.objects.values_list("ethereum_tx", "log_index")
        .annotate(c=Count("*"))
        .filter(c__gt=1)
    ):
        for transfer_to_delete in list(
            TokenTransferModel.objects.filter(
                ethereum_tx_id=transfer[0], log_index=transfer[1]
            )[1:]
        ):
            transfer_to_delete.delete()

def remove_duplicated(apps, schema_editor):
    ERC20Transfer = apps.get_model("history", "ERC20Transfer")
    ERC721Transfer = apps.get_model("history", "ERC721Transfer")

    _remove_duplicated(ERC20Transfer)
    _remove_duplicated(ERC721Transfer)

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0046_delete_ethereumevent"),
    ]

    operations = [
        migrations.RunPython(remove_duplicated, reverse_code=migrations.RunPython.noop),
        migrations.AlterUniqueTogether(
            name="erc20transfer",
            unique_together={("ethereum_tx", "log_index")},
        ),
        migrations.AlterUniqueTogether(
            name="erc721transfer",
            unique_together={("ethereum_tx", "log_index")},
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0048_block_number_token_transfers_20211126_1443.py ---
# Generated by Django 3.2.8 on 2021-11-26 15:57

import django.utils.timezone
from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0047_auto_20211102_1659"),
    ]

    operations = [
        migrations.AddField(
            model_name="erc20transfer",
            name="block_number",
            field=models.PositiveIntegerField(default=0),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="erc20transfer",
            name="timestamp",
            field=models.DateTimeField(
                db_index=True, default=django.utils.timezone.now
            ),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="erc721transfer",
            name="block_number",
            field=models.PositiveIntegerField(default=0),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="erc721transfer",
            name="timestamp",
            field=models.DateTimeField(
                db_index=True, default=django.utils.timezone.now
            ),
            preserve_default=False,
        ),
        migrations.AlterField(
            model_name="erc20transfer",
            name="_from",
            field=gnosis.eth.django.models.EthereumAddressField(),
        ),
        migrations.AlterField(
            model_name="erc20transfer",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressField(),
        ),
        migrations.AlterField(
            model_name="erc721transfer",
            name="_from",
            field=gnosis.eth.django.models.EthereumAddressField(),
        ),
        migrations.AlterField(
            model_name="erc721transfer",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressField(),
        ),
        migrations.AddIndex(
            model_name="erc20transfer",
            index=models.Index(
                fields=["_from", "timestamp"], name="history_erc__from_64986c_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="erc20transfer",
            index=models.Index(
                fields=["to", "timestamp"], name="history_erc_to_f32154_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="erc721transfer",
            index=models.Index(
                fields=["_from", "timestamp"], name="history_erc__from_72fb41_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="erc721transfer",
            index=models.Index(
                fields=["to", "timestamp"], name="history_erc_to_02d4ab_idx"
            ),
        ),
        migrations.AlterField(
            model_name="erc20transfer",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressField(),
        ),
        migrations.AlterField(
            model_name="erc721transfer",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressField(),
        ),
        migrations.AddIndex(
            model_name="erc20transfer",
            index=models.Index(
                fields=["address"], name="history_erc_address_dba64d_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="erc721transfer",
            index=models.Index(
                fields=["address"], name="history_erc_address_94cee3_idx"
            ),
        ),
        migrations.RunSQL(
            """
            UPDATE "history_erc20transfer" SET (block_number, timestamp) =
            (
                SELECT "history_ethereumblock"."number", "history_ethereumblock"."timestamp"
                FROM "history_ethereumtx" INNER JOIN "history_ethereumblock" ON (
                    "history_ethereumtx"."block_id" = "history_ethereumblock"."number"
                ) WHERE "history_erc20transfer"."ethereum_tx_id" = "history_ethereumtx"."tx_hash");
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        migrations.RunSQL(
            """
            UPDATE "history_erc721transfer" SET (block_number, timestamp) =
            (
                SELECT "history_ethereumblock"."number", "history_ethereumblock"."timestamp"
                FROM "history_ethereumtx" INNER JOIN "history_ethereumblock" ON (
                    "history_ethereumtx"."block_id" = "history_ethereumblock"."number"
                ) WHERE "history_erc721transfer"."ethereum_tx_id" = "history_ethereumtx"."tx_hash");
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0049_block_number_internaltx_20211129_1111.py ---
# Generated by Django 3.2.9 on 2021-11-29 11:11

import django.utils.timezone
from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0048_block_number_token_transfers_20211126_1443"),
    ]

    operations = [
        migrations.AddField(
            model_name="internaltx",
            name="block_number",
            field=models.PositiveIntegerField(default=0),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="internaltx",
            name="timestamp",
            field=models.DateTimeField(
                db_index=True, default=django.utils.timezone.now
            ),
            preserve_default=False,
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="_from",
            field=gnosis.eth.django.models.EthereumAddressField(null=True),
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressField(null=True),
        ),
        migrations.AddIndex(
            model_name="internaltx",
            index=models.Index(
                condition=models.Q(("value__gt", 0)),
                fields=["value"],
                name="history_internaltx_value_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="internaltx",
            index=models.Index(
                fields=["_from", "timestamp"], name="history_int__from_31d634_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="internaltx",
            index=models.Index(
                fields=["to", "timestamp"], name="history_int_to_e72886_idx"
            ),
        ),
        migrations.RunSQL(
            """
            UPDATE "history_internaltx" SET (block_number, timestamp) =
            (
                SELECT "history_ethereumblock"."number", "history_ethereumblock"."timestamp"
                FROM "history_ethereumtx" INNER JOIN "history_ethereumblock" ON (
                    "history_ethereumtx"."block_id" = "history_ethereumblock"."number"
                ) WHERE "history_internaltx"."ethereum_tx_id" = "history_ethereumtx"."tx_hash");
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0050_ethereum_address_field_v2_20211201_1507.py ---
# Generated by Django 3.2.9 on 2021-12-01 15:07

import django.contrib.postgres.fields
from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0049_block_number_internaltx_20211129_1111"),
    ]

    operations = [
        migrations.RunSQL(
            """
            DROP INDEX IF EXISTS
                history_erc20transfer_ethereum_tx_id_16a6036b_like,
                history_erc721transfer_ethereum_tx_id_aa020110_like,
                history_ethereumblock_block_hash_106040a5_like,
                history_ethereumblock_parent_hash_9ffab967_like,
                history_ethereumtx__from_e36d4662_like,
                history_ethereumtx_to_9fb37c13_like,
                history_ethereumtx_tx_hash_c3adab3a_like,
                history_internaltx_contract_address_134466b3_like,
                history_internaltx_ethereum_tx_id_e6ac35ab_like,
                history_internaltx_refund_address_09530831_like,
                history_moduletransaction_module_5bf50dd1_like,
                history_moduletransaction_safe_794cf9b4_like,
                history_moduletransaction_to_041e4c7b_like,
                history_multisigconfirma_multisig_transaction_has_4c8cbf7a_like,
                history_multisigconfirma_multisig_transaction_id_43ec94d5_like,
                history_multisigconfirmation_ethereum_tx_id_71e0ab73_like,
                history_multisigtransaction_ethereum_tx_id_c8d3f1cf_like,
                history_multisigtransaction_safe_ba8bae68_like,
                history_multisigtransaction_safe_tx_hash_4d740966_like,
                history_multisigtransaction_to_e544fdbe_like,
                history_proxyfactory_address_ecff62ff_like,
                history_safecontract_address_b3109ec5_like,
                history_safecontract_ethereum_tx_id_4f63f583_like,
                history_safecontractdelegate_safe_contract_id_4389cdbf_like,
                history_safemastercopy_address_d1f56f9e_like,
                history_safestatus_address_68cd154d_like,
                history_webhook_address_94c4e540_like,
                notifications_firebasede_safecontract_id_acb5c418_like,
                notifications_firebasedeviceowner_owner_025b0ed6_like
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        migrations.RunSQL(
            """
            ALTER TABLE "history_erc20transfer" ALTER COLUMN "_from" TYPE bytea USING DECODE(SUBSTRING("_from", 3), 'hex');
            ALTER TABLE "history_erc20transfer" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex');
            ALTER TABLE "history_erc20transfer" ALTER COLUMN "to" TYPE bytea USING DECODE(SUBSTRING("to", 3), 'hex');
            ALTER TABLE "history_erc721transfer" ALTER COLUMN "_from" TYPE bytea USING DECODE(SUBSTRING("_from", 3), 'hex');
            ALTER TABLE "history_erc721transfer" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex');
            ALTER TABLE "history_erc721transfer" ALTER COLUMN "to" TYPE bytea USING DECODE(SUBSTRING("to", 3), 'hex');
            ALTER TABLE "history_ethereumtx" ALTER COLUMN "_from" TYPE bytea USING DECODE(SUBSTRING("_from", 3), 'hex');
            ALTER TABLE "history_ethereumtx" ALTER COLUMN "to" TYPE bytea USING DECODE(SUBSTRING("to", 3), 'hex');
            ALTER TABLE "history_internaltx" ALTER COLUMN "_from" TYPE bytea USING DECODE(SUBSTRING("_from", 3), 'hex');
            ALTER TABLE "history_internaltx" ALTER COLUMN "contract_address" TYPE bytea USING DECODE(SUBSTRING("contract_address", 3), 'hex');
            ALTER TABLE "history_internaltx" ALTER COLUMN "refund_address" TYPE bytea USING DECODE(SUBSTRING("refund_address", 3), 'hex');
            ALTER TABLE "history_internaltx" ALTER COLUMN "to" TYPE bytea USING DECODE(SUBSTRING("to", 3), 'hex');
            ALTER TABLE "history_moduletransaction" ALTER COLUMN "module" TYPE bytea USING DECODE(SUBSTRING("module", 3), 'hex');
            ALTER TABLE "history_moduletransaction" ALTER COLUMN "safe" TYPE bytea USING DECODE(SUBSTRING("safe", 3), 'hex');
            ALTER TABLE "history_moduletransaction" ALTER COLUMN "to" TYPE bytea USING DECODE(SUBSTRING("to", 3), 'hex');
            ALTER TABLE "history_multisigconfirmation" ALTER COLUMN "owner" TYPE bytea USING DECODE(SUBSTRING("owner", 3), 'hex');
            ALTER TABLE "history_multisigtransaction" ALTER COLUMN "gas_token" TYPE bytea USING DECODE(SUBSTRING("gas_token", 3), 'hex');
            ALTER TABLE "history_multisigtransaction" ALTER COLUMN "refund_receiver" TYPE bytea USING DECODE(SUBSTRING("refund_receiver", 3), 'hex');
            ALTER TABLE "history_multisigtransaction" ALTER COLUMN "safe" TYPE bytea USING DECODE(SUBSTRING("safe", 3), 'hex');
            ALTER TABLE "history_multisigtransaction" ALTER COLUMN "to" TYPE bytea USING DECODE(SUBSTRING("to", 3), 'hex');
            ALTER TABLE "history_proxyfactory" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex');
            SET CONSTRAINTS "history_safecontract_safe_contract_id_4389cdbf_fk_history_s" IMMEDIATE;
            ALTER TABLE "history_safecontractdelegate" DROP CONSTRAINT "history_safecontract_safe_contract_id_4389cdbf_fk_history_s";
            ALTER TABLE "history_safecontractdelegate" ADD CONSTRAINT "history_safecontractdelegate_safe_contract_id_4389cdbf_fk" FOREIGN KEY ("safe_contract_id") REFERENCES "history_safecontract" ("address") DEFERRABLE INITIALLY DEFERRED;
            -- ALTER TABLE "history_safecontract" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex')::bytea;
            -- ALTER TABLE "history_safecontractdelegate" ALTER COLUMN "safe_contract_id" TYPE bytea USING DECODE(SUBSTRING("safe_contract_id", 3), 'hex');
            ALTER TABLE "history_safecontractdelegate" ALTER COLUMN "delegate" TYPE bytea USING DECODE(SUBSTRING("delegate", 3), 'hex');
            ALTER TABLE "history_safecontractdelegate" ALTER COLUMN "delegator" TYPE bytea USING DECODE(SUBSTRING("delegator", 3), 'hex');
            ALTER TABLE "history_safemastercopy" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex');
            ALTER TABLE "history_safestatus" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex');
            ALTER TABLE "history_safestatus" ALTER COLUMN "enabled_modules" TYPE bytea[] USING "enabled_modules"::bytea[];
            ALTER TABLE "history_safestatus" ALTER COLUMN "fallback_handler" TYPE bytea USING DECODE(SUBSTRING("fallback_handler", 3), 'hex');
            ALTER TABLE "history_safestatus" ALTER COLUMN "guard" TYPE bytea USING DECODE(SUBSTRING("guard", 3), 'hex');
            ALTER TABLE "history_safestatus" ALTER COLUMN "master_copy" TYPE bytea USING DECODE(SUBSTRING("master_copy", 3), 'hex');
            ALTER TABLE "history_safestatus" ALTER COLUMN "owners" TYPE bytea[] USING "owners"::bytea[];
            ALTER TABLE "history_webhook" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex'), ALTER COLUMN "address" DROP NOT NULL;
            """
        ),
        migrations.AlterField(
            model_name="erc20transfer",
            name="_from",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="erc20transfer",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="erc20transfer",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="erc721transfer",
            name="_from",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="erc721transfer",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="erc721transfer",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="ethereumtx",
            name="_from",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                db_index=True, null=True
            ),
        ),
        migrations.AlterField(
            model_name="ethereumtx",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                db_index=True, null=True
            ),
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="_from",
            field=gnosis.eth.django.models.EthereumAddressV2Field(null=True),
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="contract_address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                db_index=True, null=True
            ),
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="refund_address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                db_index=True, null=True
            ),
        ),
        migrations.AlterField(
            model_name="internaltx",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressV2Field(null=True),
        ),
        migrations.AlterField(
            model_name="moduletransaction",
            name="module",
            field=gnosis.eth.django.models.EthereumAddressV2Field(db_index=True),
        ),
        migrations.AlterField(
            model_name="moduletransaction",
            name="safe",
            field=gnosis.eth.django.models.EthereumAddressV2Field(db_index=True),
        ),
        migrations.AlterField(
            model_name="moduletransaction",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressV2Field(db_index=True),
        ),
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="owner",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="gas_token",
            field=gnosis.eth.django.models.EthereumAddressV2Field(null=True),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="refund_receiver",
            field=gnosis.eth.django.models.EthereumAddressV2Field(null=True),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="safe",
            field=gnosis.eth.django.models.EthereumAddressV2Field(db_index=True),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="to",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                db_index=True, null=True
            ),
        ),
        migrations.AlterField(
            model_name="proxyfactory",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                primary_key=True, serialize=False
            ),
        ),
        migrations.AlterField(
            model_name="safecontract",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                primary_key=True, serialize=False
            ),
        ),
        migrations.AlterField(
            model_name="safecontractdelegate",
            name="delegate",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="safecontractdelegate",
            name="delegator",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="safemastercopy",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                primary_key=True, serialize=False
            ),
        ),
        migrations.AlterField(
            model_name="safestatus",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(db_index=True),
        ),
        migrations.AlterField(
            model_name="safestatus",
            name="enabled_modules",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=gnosis.eth.django.models.EthereumAddressV2Field(),
                default=list,
                size=None,
            ),
        ),
        migrations.AlterField(
            model_name="safestatus",
            name="fallback_handler",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="safestatus",
            name="guard",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                default=None, null=True
            ),
        ),
        migrations.AlterField(
            model_name="safestatus",
            name="master_copy",
            field=gnosis.eth.django.models.EthereumAddressV2Field(),
        ),
        migrations.AlterField(
            model_name="safestatus",
            name="owners",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=gnosis.eth.django.models.EthereumAddressV2Field(), size=None
            ),
        ),
        migrations.AlterField(
            model_name="webhook",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                db_index=True, null=True
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0051_ethereum_address_field_v2_update.py ---
# Generated by Django 3.2.9 on 2021-12-01 15:07

import django.contrib.postgres.fields
from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0050_ethereum_address_field_v2_20211201_1507"),
    ]

    operations = [
        migrations.RunSQL(
            # Create function to migrate bytea[]
            """
            CREATE OR REPLACE FUNCTION array_address_parse(bytea[])
            RETURNS bytea[]
            AS
            $$
            DECLARE
               arrBytes ALIAS FOR $1;
               retVal bytea[];
            BEGIN
               IF array_upper(arrBytes, 1) is NULL THEN
                 RETURN ARRAY[]::bytea[];
               END IF;
               FOR I IN array_lower(arrBytes, 1)..array_upper(arrBytes, 1) LOOP
                 retVal[I] := decode(substring(encode(arrBytes[I], 'escape'), 3), 'hex');
               END LOOP;
            RETURN retVal;
            END;
            $$
            LANGUAGE plpgsql
               STABLE
            RETURNS NULL ON NULL INPUT;

            UPDATE "history_safestatus"
            SET
                owners = array_address_parse(owners),
                enabled_modules = array_address_parse(enabled_modules);

            UPDATE history_webhook SET address=null WHERE address='';

            DROP FUNCTION array_address_parse(bytea[]);
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        migrations.RunSQL(
            """
            UPDATE "history_safecontract"
                SET "address" = DECODE(SUBSTRING(ENCODE("address", 'escape'), 3), 'hex');
            UPDATE "history_safecontractdelegate"
                SET "safe_contract_id" = DECODE(SUBSTRING(ENCODE("safe_contract_id", 'escape'), 3), 'hex');
            """,
            migrations.RunSQL.noop,
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0052_keccak256_field_20211209_1628.py ---
# Generated by Django 3.2.9 on 2021-12-09 16:28

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0051_ethereum_address_field_v2_update"),
    ]
    operations = [
        migrations.RunSQL(
            """
            -- Alter field block_hash on ethereumblock
            --
            DROP INDEX IF EXISTS "history_ethereumblock_block_hash_106040a5_like";
            ALTER TABLE "history_ethereumblock" ALTER COLUMN "block_hash" TYPE bytea USING DECODE("block_hash", 'hex');
            --
            -- Alter field parent_hash on ethereumblock
            --
            DROP INDEX IF EXISTS "history_ethereumblock_parent_hash_9ffab967_like";
            ALTER TABLE "history_ethereumblock" ALTER COLUMN "parent_hash" TYPE bytea USING DECODE("parent_hash", 'hex');
            --
            -- Alter field tx_hash on ethereumtx
            --
            DROP INDEX IF EXISTS "history_ethereumtx_tx_hash_c3adab3a_like";
            SET CONSTRAINTS "history_erc721transf_ethereum_tx_id_aa020110_fk_history_e" IMMEDIATE; ALTER TABLE "history_erc721transfer" DROP CONSTRAINT "history_erc721transf_ethereum_tx_id_aa020110_fk_history_e";
            SET CONSTRAINTS "history_multisigtran_ethereum_tx_id_c8d3f1cf_fk_history_e" IMMEDIATE; ALTER TABLE "history_multisigtransaction" DROP CONSTRAINT "history_multisigtran_ethereum_tx_id_c8d3f1cf_fk_history_e";
            SET CONSTRAINTS "history_internaltx_ethereum_tx_id_e6ac35ab_fk_history_e" IMMEDIATE; ALTER TABLE "history_internaltx" DROP CONSTRAINT "history_internaltx_ethereum_tx_id_e6ac35ab_fk_history_e";
            SET CONSTRAINTS "history_safecontract_ethereum_tx_id_4f63f583_fk_history_e" IMMEDIATE; ALTER TABLE "history_safecontract" DROP CONSTRAINT "history_safecontract_ethereum_tx_id_4f63f583_fk_history_e";
            SET CONSTRAINTS "history_multisigconf_ethereum_tx_id_71e0ab73_fk_history_e" IMMEDIATE; ALTER TABLE "history_multisigconfirmation" DROP CONSTRAINT "history_multisigconf_ethereum_tx_id_71e0ab73_fk_history_e";
            SET CONSTRAINTS "history_erc20transfe_ethereum_tx_id_16a6036b_fk_history_e" IMMEDIATE; ALTER TABLE "history_erc20transfer" DROP CONSTRAINT "history_erc20transfe_ethereum_tx_id_16a6036b_fk_history_e";
            ALTER TABLE "history_ethereumtx" ALTER COLUMN "tx_hash" TYPE bytea USING DECODE("tx_hash", 'hex');
            ALTER TABLE "history_erc721transfer" ALTER COLUMN "ethereum_tx_id" TYPE bytea USING DECODE("ethereum_tx_id", 'hex');
            ALTER TABLE "history_multisigtransaction" ALTER COLUMN "ethereum_tx_id" TYPE bytea USING DECODE("ethereum_tx_id", 'hex');
            ALTER TABLE "history_internaltx" ALTER COLUMN "ethereum_tx_id" TYPE bytea USING DECODE("ethereum_tx_id", 'hex');
            ALTER TABLE "history_safecontract" ALTER COLUMN "ethereum_tx_id" TYPE bytea USING DECODE("ethereum_tx_id", 'hex');
            ALTER TABLE "history_multisigconfirmation" ALTER COLUMN "ethereum_tx_id" TYPE bytea USING DECODE("ethereum_tx_id", 'hex');
            ALTER TABLE "history_erc20transfer" ALTER COLUMN "ethereum_tx_id" TYPE bytea USING DECODE("ethereum_tx_id", 'hex');
            ALTER TABLE "history_erc721transfer" ADD CONSTRAINT "history_erc721transfer_ethereum_tx_id_aa020110_fk" FOREIGN KEY ("ethereum_tx_id") REFERENCES "history_ethereumtx" ("tx_hash") DEFERRABLE INITIALLY DEFERRED;
            ALTER TABLE "history_multisigtransaction" ADD CONSTRAINT "history_multisigtransaction_ethereum_tx_id_c8d3f1cf_fk" FOREIGN KEY ("ethereum_tx_id") REFERENCES "history_ethereumtx" ("tx_hash") DEFERRABLE INITIALLY DEFERRED;
            ALTER TABLE "history_internaltx" ADD CONSTRAINT "history_internaltx_ethereum_tx_id_e6ac35ab_fk" FOREIGN KEY ("ethereum_tx_id") REFERENCES "history_ethereumtx" ("tx_hash") DEFERRABLE INITIALLY DEFERRED;
            ALTER TABLE "history_safecontract" ADD CONSTRAINT "history_safecontract_ethereum_tx_id_4f63f583_fk" FOREIGN KEY ("ethereum_tx_id") REFERENCES "history_ethereumtx" ("tx_hash") DEFERRABLE INITIALLY DEFERRED;
            ALTER TABLE "history_multisigconfirmation" ADD CONSTRAINT "history_multisigconfirmation_ethereum_tx_id_71e0ab73_fk" FOREIGN KEY ("ethereum_tx_id") REFERENCES "history_ethereumtx" ("tx_hash") DEFERRABLE INITIALLY DEFERRED;
            ALTER TABLE "history_erc20transfer" ADD CONSTRAINT "history_erc20transfer_ethereum_tx_id_16a6036b_fk" FOREIGN KEY ("ethereum_tx_id") REFERENCES "history_ethereumtx" ("tx_hash") DEFERRABLE INITIALLY DEFERRED;
            --
            -- Alter field multisig_transaction_hash on multisigconfirmation
            --
            DROP INDEX IF EXISTS "history_multisigconfirma_multisig_transaction_has_4c8cbf7a_like";
            ALTER TABLE "history_multisigconfirmation" ALTER COLUMN "multisig_transaction_hash" TYPE bytea USING DECODE("multisig_transaction_hash", 'hex');
            --
            -- Alter field safe_tx_hash on multisigtransaction
            --
            DROP INDEX IF EXISTS "history_multisigtransaction_safe_tx_hash_4d740966_like";
            SET CONSTRAINTS "history_multisigconf_multisig_transaction_43ec94d5_fk_history_m" IMMEDIATE; ALTER TABLE "history_multisigconfirmation" DROP CONSTRAINT "history_multisigconf_multisig_transaction_43ec94d5_fk_history_m";
            ALTER TABLE "history_multisigtransaction" ALTER COLUMN "safe_tx_hash" TYPE bytea USING DECODE("safe_tx_hash", 'hex');
            ALTER TABLE "history_multisigconfirmation" ALTER COLUMN "multisig_transaction_id" TYPE bytea USING DECODE("multisig_transaction_id", 'hex');
            ALTER TABLE "history_multisigconfirmation" ADD CONSTRAINT "history_multisigconfirmat_multisig_transaction_id_43ec94d5_fk" FOREIGN KEY ("multisig_transaction_id") REFERENCES "history_multisigtransaction" ("safe_tx_hash") DEFERRABLE INITIALLY DEFERRED;
            -- End of custom migration
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        migrations.AlterField(
            model_name="ethereumblock",
            name="block_hash",
            field=gnosis.eth.django.models.Keccak256Field(unique=True),
        ),
        migrations.AlterField(
            model_name="ethereumblock",
            name="parent_hash",
            field=gnosis.eth.django.models.Keccak256Field(unique=True),
        ),
        migrations.AlterField(
            model_name="ethereumtx",
            name="tx_hash",
            field=gnosis.eth.django.models.Keccak256Field(
                primary_key=True, serialize=False
            ),
        ),
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="multisig_transaction_hash",
            field=gnosis.eth.django.models.Keccak256Field(db_index=True, null=True),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="safe_tx_hash",
            field=gnosis.eth.django.models.Keccak256Field(
                primary_key=True, serialize=False
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0053_alter_webhook_address.py ---
# Generated by Django 3.2.10 on 2021-12-20 11:28

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0052_keccak256_field_20211209_1628"),
    ]

    operations = [
        migrations.AlterField(
            model_name="webhook",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                blank=True, db_index=True, null=True
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0054_webhook_authorization.py ---
# Generated by Django 3.2.12 on 2022-02-18 13:03

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0053_alter_webhook_address"),
    ]

    operations = [
        migrations.AddField(
            model_name="webhook",
            name="authorization",
            field=models.CharField(
                default=None,
                help_text="Set HTTP Authorization header with the value",
                max_length=500,
                null=True,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0055_alter_multisigtransaction_options.py ---
# Generated by Django 4.0.2 on 2022-03-07 13:11

from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0054_webhook_authorization"),
    ]

    operations = [
        migrations.AlterModelOptions(
            name="multisigtransaction",
            options={
                "permissions": [("create_trusted", "Can create trusted transactions")]
            },
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0056_alter_multisigconfirmation_signature.py ---
# Generated by Django 3.2.12 on 2022-03-21 09:59

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0055_alter_multisigtransaction_options"),
    ]

    operations = [
        migrations.AlterField(
            model_name="multisigconfirmation",
            name="signature",
            field=gnosis.eth.django.models.HexField(
                default=None, max_length=5000, null=True
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0057_alter_webhook_authorization.py ---
# Generated by Django 3.2.12 on 2022-03-30 09:12

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0056_alter_multisigconfirmation_signature"),
    ]

    operations = [
        migrations.AlterField(
            model_name="webhook",
            name="authorization",
            field=models.CharField(
                blank=True,
                default=None,
                help_text="Set HTTP Authorization header with the value",
                max_length=500,
                null=True,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0058_alter_webhook_url.py ---
# Generated by Django 3.2.12 on 2022-03-30 09:25

from django.db import migrations, models

import safe_transaction_service.history.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0057_alter_webhook_authorization"),
    ]

    operations = [
        migrations.AlterField(
            model_name="webhook",
            name="url",
            field=models.CharField(
                max_length=255,
                validators=[
                    safe_transaction_service.history.models._validate_webhook_url
                ],
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0059_auto_20220408_1020.py ---
# Generated by Django 3.2.12 on 2022-04-08 10:20

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0058_alter_webhook_url"),
    ]

    operations = [
        migrations.RenameField(
            model_name="webhook",
            old_name="new_executed_outgoing_transaction",
            new_name="new_executed_multisig_transaction",
        ),
        migrations.RenameField(
            model_name="webhook",
            old_name="pending_outgoing_transaction",
            new_name="pending_multisig_transaction",
        ),
        migrations.AlterField(
            model_name="webhook",
            name="new_executed_multisig_transaction",
            field=models.BooleanField(
                default=True, help_text="New mined multisig transaction"
            ),
        ),
        migrations.AlterField(
            model_name="webhook",
            name="pending_multisig_transaction",
            field=models.BooleanField(
                default=True, help_text="New pending multisig transaction"
            ),
        ),
        migrations.AlterField(
            model_name="webhook",
            name="new_confirmation",
            field=models.BooleanField(default=True, help_text="New confirmation"),
        ),
        migrations.AlterField(
            model_name="webhook",
            name="new_incoming_transaction",
            field=models.BooleanField(
                default=True, help_text="New incoming transaction of eth/token"
            ),
        ),
        migrations.AlterField(
            model_name="webhook",
            name="new_module_transaction",
            field=models.BooleanField(
                default=True, help_text="New mined module transaction"
            ),
        ),
        migrations.AlterField(
            model_name="webhook",
            name="new_outgoing_transaction",
            field=models.BooleanField(
                default=True, help_text="New outgoing transaction of eth/token"
            ),
        ),
        migrations.AlterField(
            model_name="webhook",
            name="new_safe",
            field=models.BooleanField(default=True, help_text="New Safe created"),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0060_add_eip1559_fields_20220419_0955.py ---
# Generated by Django 3.2.12 on 2022-04-19 09:55

from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0059_auto_20220408_1020"),
    ]

    operations = [
        migrations.AddField(
            model_name="ethereumtx",
            name="max_fee_per_gas",
            field=gnosis.eth.django.models.Uint256Field(
                blank=True, default=None, null=True
            ),
        ),
        migrations.AddField(
            model_name="ethereumtx",
            name="max_priority_fee_per_gas",
            field=gnosis.eth.django.models.Uint256Field(
                blank=True, default=None, null=True
            ),
        ),
        migrations.AddField(
            model_name="ethereumtx",
            name="type",
            field=models.PositiveSmallIntegerField(default=0),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0061_alter_internaltx_block_number.py ---
# Generated by Django 3.2.13 on 2022-05-10 10:56

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0060_add_eip1559_fields_20220419_0955"),
    ]

    operations = [
        migrations.AlterField(
            model_name="internaltx",
            name="block_number",
            field=models.PositiveIntegerField(db_index=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0062_add_safe_last_status_20220429_0922.py ---
# Generated by Django 3.2.13 on 2022-04-29 09:22

import django.contrib.postgres.fields
import django.contrib.postgres.indexes
import django.db.models.deletion
from django.db import migrations, models

import gnosis.eth.django.models

def init_safe_last_status(apps, schema_editor):
    SafeStatus = apps.get_model("history", "SafeStatus")
    SafeLastStatus = apps.get_model("history", "SafeLastStatus")

    # We cannot use Managers in migrations
    last_for_every_address = SafeStatus.objects.distinct("address").order_by(
        "address",
        "-nonce",
        "-internal_tx__block_number",
        "-internal_tx__ethereum_tx__transaction_index",
        "-internal_tx__trace_address",
    )

    for safe_status in last_for_every_address.iterator():
        SafeLastStatus.objects.update_or_create(
            address=safe_status.address,
            defaults={
                "internal_tx": safe_status.internal_tx,
                "owners": safe_status.owners,
                "threshold": safe_status.threshold,
                "nonce": safe_status.nonce,
                "master_copy": safe_status.master_copy,
                "fallback_handler": safe_status.fallback_handler,
                "guard": safe_status.guard,
                "enabled_modules": safe_status.enabled_modules,
            },
        )

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0061_alter_internaltx_block_number"),
    ]

    operations = [
        migrations.CreateModel(
            name="SafeLastStatus",
            fields=[
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressV2Field(
                        db_index=True, primary_key=True, serialize=False
                    ),
                ),
                (
                    "owners",
                    django.contrib.postgres.fields.ArrayField(
                        base_field=gnosis.eth.django.models.EthereumAddressV2Field(),
                        size=None,
                    ),
                ),
                ("threshold", gnosis.eth.django.models.Uint256Field()),
                ("nonce", gnosis.eth.django.models.Uint256Field(default=0)),
                ("master_copy", gnosis.eth.django.models.EthereumAddressV2Field()),
                ("fallback_handler", gnosis.eth.django.models.EthereumAddressV2Field()),
                (
                    "guard",
                    gnosis.eth.django.models.EthereumAddressV2Field(
                        default=None, null=True
                    ),
                ),
                (
                    "enabled_modules",
                    django.contrib.postgres.fields.ArrayField(
                        base_field=gnosis.eth.django.models.EthereumAddressV2Field(),
                        default=list,
                        size=None,
                    ),
                ),
            ],
            options={
                "verbose_name_plural": "Safe last statuses",
            },
        ),
        migrations.RemoveIndex(
            model_name="safestatus",
            name="history_saf_owners_295490_gin",
        ),
        migrations.AddField(
            model_name="safelaststatus",
            name="internal_tx",
            field=models.OneToOneField(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="safe_last_status",
                to="history.internaltx",
            ),
        ),
        migrations.AddIndex(
            model_name="safelaststatus",
            index=django.contrib.postgres.indexes.GinIndex(
                fields=["owners"], name="history_saf_owners_5fc97e_gin"
            ),
        ),
        migrations.RunPython(
            init_safe_last_status, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0063_alter_internaltx__from.py ---
# Generated by Django 3.2.13 on 2022-05-19 14:24

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0062_add_safe_last_status_20220429_0922"),
    ]

    operations = [
        migrations.AlterField(
            model_name="internaltx",
            name="_from",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                db_index=True, null=True
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0064_auto_20220523_0919.py ---
# Generated by Django 3.2.13 on 2022-05-23 09:19

import django.contrib.postgres.fields
from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0063_alter_internaltx__from"),
    ]

    operations = [
        migrations.AlterField(
            model_name="safelaststatus",
            name="enabled_modules",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=gnosis.eth.django.models.EthereumAddressV2Field(),
                blank=True,
                default=list,
                size=None,
            ),
        ),
        migrations.AlterField(
            model_name="safestatus",
            name="enabled_modules",
            field=django.contrib.postgres.fields.ArrayField(
                base_field=gnosis.eth.django.models.EthereumAddressV2Field(),
                blank=True,
                default=list,
                size=None,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0065_safelaststatus_history_saf_enabled_020fea_gin.py ---
# Generated by Django 3.2.13 on 2022-06-10 14:54

import django.contrib.postgres.indexes
from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0064_auto_20220523_0919"),
    ]

    operations = [
        migrations.AddIndex(
            model_name="safelaststatus",
            index=django.contrib.postgres.indexes.GinIndex(
                fields=["enabled_modules"], name="history_saf_enabled_020fea_gin"
            ),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0066_auto_20220628_1125.py ---
# Generated by Django 3.2.13 on 2022-06-28 11:25

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0065_safelaststatus_history_saf_enabled_020fea_gin"),
    ]

    operations = [
        migrations.AlterField(
            model_name="ethereumblock",
            name="gas_limit",
            field=gnosis.eth.django.models.Uint256Field(),
        ),
        migrations.AlterField(
            model_name="ethereumblock",
            name="gas_used",
            field=gnosis.eth.django.models.Uint256Field(),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0067_auto_20220705_1545.py ---
# Generated by Django 3.2.13 on 2022-07-05 15:45

from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0066_auto_20220628_1125"),
    ]

    operations = [
        migrations.AlterField(
            model_name="multisigtransaction",
            name="data",
            field=models.BinaryField(blank=True, editable=True, null=True),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="failed",
            field=models.BooleanField(
                blank=True, db_index=True, default=None, null=True
            ),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="gas_token",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                blank=True, null=True
            ),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="origin",
            field=models.CharField(blank=True, default=None, max_length=200, null=True),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="refund_receiver",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                blank=True, null=True
            ),
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="signatures",
            field=models.BinaryField(blank=True, null=True),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0068_alter_multisigtransaction_origin.py ---
# Generated by Django 4.1.2 on 2022-11-14 18:39

import json

from django.db import migrations, models
from django.db.models import Q

def prepare_migration_charfield_to_jsonfield(apps, schema_editor):
    MultisigTransaction = apps.get_model("history", "MultisigTransaction")
    transactions = MultisigTransaction.objects.all().iterator()
    for transaction in transactions:
        try:
            json.loads(transaction.origin)
        except Exception:
            if transaction.origin == "" or transaction.origin is None:
                transaction.origin = "{}"
            else:
                transaction.origin = json.dumps(transaction.origin)
            transaction.save()

def repair_backward_migration(apps, schema_editor):
    MultisigTransaction = apps.get_model("history", "MultisigTransaction")
    # Empty objects should be None
    MultisigTransaction.objects.filter(Q(origin="{}") | Q(origin='"{}"')).update(
        origin=None
    )
    # Remove duplicated quotes example: '"hello"'
    transactions = MultisigTransaction.objects.filter(origin__isnull=False).iterator()
    for transaction in transactions:
        value = json.loads(transaction.origin)
        if type(value) == str:
            transaction.origin = value
            transaction.save()

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0067_auto_20220705_1545"),
    ]

    operations = [
        migrations.RunPython(
            prepare_migration_charfield_to_jsonfield,
            reverse_code=repair_backward_migration,
        ),
        migrations.AlterField(
            model_name="multisigtransaction",
            name="origin",
            field=models.JSONField(default=dict),
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/0069_indexingstatus_and_more.py ---
# Generated by Django 4.1.3 on 2022-12-07 13:07
from django.conf import settings
from django.db import migrations, models
from django.db.models import Min

from ..models import IndexingStatusType

def create_indexing_status(apps, schema_editor):
    SafeContract = apps.get_model("history", "SafeContract")
    IndexingStatus = apps.get_model("history", "IndexingStatus")

    erc20_block_number = SafeContract.objects.aggregate(
        min_erc20_block_number=Min("erc20_block_number")
    )["min_erc20_block_number"]

    if erc20_block_number:
        block_number = erc20_block_number
    else:
        SafeMasterCopy = apps.get_model("history", "SafeMasterCopy")
        queryset = (
            SafeMasterCopy.objects.filter(l2=True)
            if settings.ETH_L2_NETWORK
            else SafeMasterCopy.objects.all()
        )
        min_master_copies_block_number = queryset.aggregate(
            min_master_copies_block_number=Min("initial_block_number")
        )["min_master_copies_block_number"]
        block_number = (
            min_master_copies_block_number if min_master_copies_block_number else 0
        )

    IndexingStatus.objects.update_or_create(
        indexing_type=IndexingStatusType.ERC20_721_EVENTS.value,
        defaults={"block_number": block_number},
    )

def remove_indexing_status(apps, schema_editor):
    SafeContract = apps.get_model("history", "SafeContract")
    IndexingStatus = apps.get_model("history", "IndexingStatus")

    try:
        block_number = IndexingStatus.objects.get(
            indexing_type=IndexingStatusType.ERC20_721_EVENTS.value
        ).block_number
    except IndexingStatus.DoesNotExist:
        block_number = 0
    SafeContract.objects.update(erc20_block_number=block_number)

class Migration(migrations.Migration):

    dependencies = [
        ("history", "0068_alter_multisigtransaction_origin"),
    ]

    operations = [
        migrations.CreateModel(
            name="IndexingStatus",
            fields=[
                (
                    "indexing_type",
                    models.PositiveSmallIntegerField(
                        choices=[(0, "ERC20_721_EVENTS")],
                        primary_key=True,
                        serialize=False,
                    ),
                ),
                ("block_number", models.PositiveIntegerField(db_index=True)),
            ],
        ),
        migrations.RunPython(
            create_indexing_status, reverse_code=remove_indexing_status
        ),
        migrations.RemoveField(
            model_name="safecontract",
            name="erc20_block_number",
        ),
    ]

'''
'''--- safe_transaction_service/history/migrations/__init__.py ---

'''
'''--- safe_transaction_service/history/models.py ---
import datetime
from decimal import Decimal
from enum import Enum
from functools import cache, lru_cache
from itertools import islice
from logging import getLogger
from typing import (
    Any,
    Dict,
    Iterable,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    Type,
    TypedDict,
    Union,
)
from urllib.parse import urlparse

from django.conf import settings
from django.contrib.postgres.fields import ArrayField
from django.contrib.postgres.indexes import GinIndex
from django.core.exceptions import ValidationError
from django.db import IntegrityError, connection, models, transaction
from django.db.models import Case, Count, Exists, Index, JSONField, Max, Q, QuerySet
from django.db.models.expressions import F, OuterRef, RawSQL, Subquery, Value, When
from django.db.models.functions import Coalesce
from django.db.models.signals import post_save
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from eth_typing import ChecksumAddress
from hexbytes import HexBytes
from model_utils.models import TimeStampedModel
from packaging.version import Version
from web3.types import EventData

from gnosis.eth.constants import ERC20_721_TRANSFER_TOPIC, NULL_ADDRESS
from gnosis.eth.django.models import (
    EthereumAddressV2Field,
    HexField,
    Keccak256Field,
    Uint256Field,
)
from gnosis.eth.utils import fast_to_checksum_address
from gnosis.safe import SafeOperation
from gnosis.safe.safe import SafeInfo
from gnosis.safe.safe_signature import SafeSignature, SafeSignatureType

from safe_transaction_service.contracts.models import Contract

from .utils import clean_receipt_log

logger = getLogger(__name__)

class ConfirmationType(Enum):
    CONFIRMATION = 0
    EXECUTION = 1

class EthereumTxCallType(Enum):
    # https://ethereum.stackexchange.com/questions/63743/whats-the-difference-between-type-and-calltype-in-parity-trace
    CALL = 0
    DELEGATE_CALL = 1
    CALL_CODE = 2
    STATIC_CALL = 3

    @staticmethod
    def parse_call_type(call_type: Optional[str]):
        if not call_type:
            return None

        call_type = call_type.lower()
        if call_type == "call":
            return EthereumTxCallType.CALL
        elif call_type == "delegatecall":
            return EthereumTxCallType.DELEGATE_CALL
        elif call_type == "callcode":
            return EthereumTxCallType.CALL_CODE
        elif call_type == "staticcall":
            return EthereumTxCallType.STATIC_CALL
        else:
            return None

class InternalTxType(Enum):
    CALL = 0
    CREATE = 1
    SELF_DESTRUCT = 2
    REWARD = 3

    @staticmethod
    def parse(tx_type: str):
        tx_type = tx_type.upper()
        if tx_type == "CALL":
            return InternalTxType.CALL
        elif tx_type == "CREATE":
            return InternalTxType.CREATE
        elif tx_type in ("SUICIDE", "SELFDESTRUCT"):
            return InternalTxType.SELF_DESTRUCT
        elif tx_type == "REWARD":
            return InternalTxType.REWARD
        else:
            raise ValueError(f"{tx_type} is not a valid InternalTxType")

class IndexingStatusType(Enum):
    ERC20_721_EVENTS = 0

class TransferDict(TypedDict):
    block_number: int
    transaction_hash: HexBytes
    to: str
    _from: str
    _value: int
    execution_date: datetime.datetime
    _token_id: int
    token_address: str

class BulkCreateSignalMixin:
    def bulk_create(
        self, objs, batch_size: Optional[int] = None, ignore_conflicts: bool = False
    ):
        objs = list(objs)  # If not it won't be iterated later
        result = super().bulk_create(
            objs, batch_size=batch_size, ignore_conflicts=ignore_conflicts
        )
        for obj in objs:
            post_save.send(obj.__class__, instance=obj, created=True)
        return result

    def bulk_create_from_generator(
        self, objs: Iterable[Any], batch_size: int = 100, ignore_conflicts: bool = False
    ) -> int:
        """
        Implementation in Django is not ok, as it will do `objs = list(objs)`. If objects come from a generator
        they will be brought to RAM. This approach is more friendly
        :return: Count of inserted elements
        """
        assert batch_size is not None and batch_size > 0
        total = 0
        while True:
            if inserted := len(
                self.bulk_create(
                    islice(objs, batch_size), ignore_conflicts=ignore_conflicts
                )
            ):
                total += inserted
            else:
                return total

class IndexingStatusManager(models.Manager):
    def get_erc20_721_indexing_status(self) -> "IndexingStatus":
        return self.get(indexing_type=IndexingStatusType.ERC20_721_EVENTS.value)

    def set_erc20_721_indexing_status(self, block_number: int) -> bool:
        return bool(
            self.filter(indexing_type=IndexingStatusType.ERC20_721_EVENTS.value).update(
                block_number=block_number
            )
        )

class IndexingStatus(models.Model):
    objects = IndexingStatusManager()
    indexing_type = models.PositiveSmallIntegerField(
        primary_key=True,
        choices=[(tag.value, tag.name) for tag in IndexingStatusType],
    )
    block_number = models.PositiveIntegerField(db_index=True)

class EthereumBlockManager(models.Manager):
    def get_or_create_from_block(self, block: Dict[str, Any], confirmed: bool = False):
        try:
            return self.get(block_hash=block["hash"])
        except self.model.DoesNotExist:
            return self.create_from_block(block, confirmed=confirmed)

    def create_from_block(
        self, block: Dict[str, Any], confirmed: bool = False
    ) -> "EthereumBlock":
        """
        :param block: Block Dict returned by Web3
        :param confirmed: If True we will not check for reorgs in the future
        :return: EthereumBlock model
        """
        try:
            with transaction.atomic():  # Needed for handling IntegrityError
                return super().create(
                    number=block["number"],
                    gas_limit=block["gasLimit"],
                    gas_used=block["gasUsed"],
                    timestamp=datetime.datetime.fromtimestamp(
                        block["timestamp"], datetime.timezone.utc
                    ),
                    block_hash=block["hash"].hex(),
                    parent_hash=block["parentHash"].hex(),
                    confirmed=confirmed,
                )
        except IntegrityError:
            db_block = self.get(number=block["number"])
            if HexBytes(db_block.block_hash) == block["hash"]:  # pragma: no cover
                # Block was inserted by another task
                return db_block
            else:
                # There's a wrong block with the same number
                db_block.confirmed = False  # Will be taken care of by the reorg task
                db_block.save(update_fields=["confirmed"])
                raise IntegrityError(
                    f"Error inserting block with hash={block['hash'].hex()}, "
                    f"there is a block with the same number={block['number']} inserted. "
                    f"Marking block as not confirmed"
                )

    @lru_cache(maxsize=10000)
    def get_timestamp_by_hash(self, block_hash: HexBytes) -> datetime.datetime:
        try:
            return self.values("timestamp").get(block_hash=block_hash)["timestamp"]
        except self.model.DoesNotExist:
            logger.error(
                "Block with hash=%s does not exist on database", block_hash.hex()
            )
            raise

class EthereumBlockQuerySet(models.QuerySet):
    def oldest_than(self, seconds: int):
        """
        :param seconds: Seconds
        :return: Blocks oldest than second, ordered by timestamp descending
        """
        return self.filter(
            timestamp__lte=timezone.now() - datetime.timedelta(seconds=seconds)
        ).order_by("-timestamp")

    def not_confirmed(self, to_block_number: Optional[int] = None):
        """
        :param to_block_number:
        :return: Block not confirmed until ``to_block_number``, if provided
        """
        queryset = self.filter(confirmed=False)
        if to_block_number is not None:
            queryset = queryset.filter(number__lte=to_block_number)
        return queryset

class EthereumBlock(models.Model):
    objects = EthereumBlockManager.from_queryset(EthereumBlockQuerySet)()
    number = models.PositiveIntegerField(primary_key=True)
    gas_limit = Uint256Field()
    gas_used = Uint256Field()
    timestamp = models.DateTimeField()
    block_hash = Keccak256Field(unique=True)
    parent_hash = Keccak256Field(unique=True)
    # For reorgs, True if `current_block_number` - `number` >= MIN_CONFIRMATIONS
    confirmed = models.BooleanField(default=False, db_index=True)

    def __str__(self):
        return f"Block number={self.number} on {self.timestamp}"

    def _set_confirmed(self, confirmed: bool):
        if self.confirmed != confirmed:
            self.confirmed = confirmed
            self.save(update_fields=["confirmed"])

    def set_confirmed(self):
        return self._set_confirmed(True)

    def set_not_confirmed(self):
        return self._set_confirmed(False)

class EthereumTxManager(models.Manager):
    def create_from_tx_dict(
        self,
        tx: Dict[str, Any],
        tx_receipt: Optional[Dict[str, Any]] = None,
        ethereum_block: Optional[EthereumBlock] = None,
    ) -> "EthereumTx":
        data = HexBytes(tx.get("data") or tx.get("input"))
        logs = tx_receipt and [
            clean_receipt_log(log) for log in tx_receipt.get("logs", [])
        ]
        return super().create(
            block=ethereum_block,
            tx_hash=HexBytes(tx["hash"]).hex(),
            gas_used=tx_receipt and tx_receipt["gasUsed"],
            _from=tx["from"],
            gas=tx["gas"],
            gas_price=(tx_receipt and tx_receipt.get("effectiveGasPrice", 0))
            or tx.get("gasPrice", 0),
            max_fee_per_gas=tx.get("maxFeePerGas"),
            max_priority_fee_per_gas=tx.get("maxPriorityFeePerGas"),
            logs=logs,
            status=tx_receipt and tx_receipt.get("status"),
            transaction_index=tx_receipt and tx_receipt["transactionIndex"],
            data=data if data else None,
            nonce=tx["nonce"],
            to=tx.get("to"),
            value=tx["value"],
            type=int(tx.get("type", "0x0"), 0),
        )

class EthereumTx(TimeStampedModel):
    objects = EthereumTxManager()
    block = models.ForeignKey(
        EthereumBlock,
        on_delete=models.CASCADE,
        null=True,
        default=None,
        related_name="txs",
    )  # If mined
    tx_hash = Keccak256Field(primary_key=True)
    gas_used = Uint256Field(null=True, default=None)  # If mined
    status = models.IntegerField(
        null=True, default=None, db_index=True
    )  # If mined. Old txs don't have `status`
    logs = ArrayField(JSONField(), null=True, default=None)  # If mined
    transaction_index = models.PositiveIntegerField(null=True, default=None)  # If mined
    _from = EthereumAddressV2Field(null=True, db_index=True)
    gas = Uint256Field()
    gas_price = Uint256Field()
    max_fee_per_gas = Uint256Field(null=True, blank=True, default=None)
    max_priority_fee_per_gas = Uint256Field(null=True, blank=True, default=None)
    data = models.BinaryField(null=True)
    nonce = Uint256Field()
    to = EthereumAddressV2Field(null=True, db_index=True)
    value = Uint256Field()
    type = models.PositiveSmallIntegerField(default=0)

    def __str__(self):
        return "{} status={} from={} to={}".format(
            self.tx_hash, self.status, self._from, self.to
        )

    @property
    def execution_date(self) -> Optional[datetime.datetime]:
        if self.block_id is not None:
            return self.block.timestamp
        return None

    @property
    def success(self) -> Optional[bool]:
        if self.status is not None:
            return self.status == 1

    def update_with_block_and_receipt(
        self, ethereum_block: "EthereumBlock", tx_receipt: Dict[str, Any]
    ):
        if self.block is None:
            self.block = ethereum_block
            self.gas_price = tx_receipt["effectiveGasPrice"]
            self.gas_used = tx_receipt["gasUsed"]
            self.logs = [clean_receipt_log(log) for log in tx_receipt.get("logs", [])]
            self.status = tx_receipt.get("status")
            self.transaction_index = tx_receipt["transactionIndex"]
            return self.save(
                update_fields=[
                    "block",
                    "gas_price",
                    "gas_used",
                    "logs",
                    "status",
                    "transaction_index",
                ]
            )

class TokenTransferQuerySet(models.QuerySet):
    def token_address(self, address: ChecksumAddress):
        """
        :param address:
        :return: Results filtered by token_address
        """
        return self.filter(address=address)

    def to_or_from(self, address: ChecksumAddress):
        """
        :param address:
        :return: Transfers with to or from equal to the provided `address`
        """
        return self.filter(Q(to=address) | Q(_from=address))

    def incoming(self, address: ChecksumAddress):
        return self.filter(to=address)

    def outgoing(self, address: ChecksumAddress):
        return self.filter(_from=address)

    def token_txs(self):
        raise NotImplementedError

class TokenTransferManager(BulkCreateSignalMixin, models.Manager):
    def tokens_used_by_address(self, address: ChecksumAddress) -> Set[ChecksumAddress]:
        return set(
            self.to_or_from(address).values_list("address", flat=True).distinct()
        )

class TokenTransfer(models.Model):
    objects = TokenTransferManager.from_queryset(TokenTransferQuerySet)()
    ethereum_tx = models.ForeignKey(EthereumTx, on_delete=models.CASCADE)
    timestamp = models.DateTimeField(db_index=True)
    block_number = models.PositiveIntegerField()
    address = EthereumAddressV2Field()  # Token address
    _from = EthereumAddressV2Field()
    to = EthereumAddressV2Field()
    log_index = models.PositiveIntegerField()

    class Meta:
        abstract = True
        indexes = [
            Index(fields=["address"]),
            Index(fields=["_from", "timestamp"]),
            Index(fields=["to", "timestamp"]),
        ]
        unique_together = (("ethereum_tx", "log_index"),)

    def __str__(self):
        return f"Token Transfer from={self._from} to={self.to}"

    @staticmethod
    def _prepare_parameters_from_decoded_event(event_data: EventData) -> Dict[str, Any]:
        topic = HexBytes(event_data["topics"][0])
        expected_topic = HexBytes(ERC20_721_TRANSFER_TOPIC)
        if topic != expected_topic:
            raise ValueError(
                f"Not supported EventData, topic {topic.hex()} does not match expected {expected_topic.hex()}"
            )

        try:
            timestamp = EthereumBlock.objects.get_timestamp_by_hash(
                event_data["blockHash"]
            )
            return {
                "timestamp": timestamp,
                "block_number": event_data["blockNumber"],
                "ethereum_tx_id": event_data["transactionHash"],
                "log_index": event_data["logIndex"],
                "address": event_data["address"],
                "_from": event_data["args"]["from"],
                "to": event_data["args"]["to"],
            }
        except EthereumBlock.DoesNotExist:
            # Block is not found and should be present on DB. Reorg
            EthereumTx.objects.get(
                event_data["transactionHash"]
            ).block.set_not_confirmed()
            raise

    @classmethod
    def from_decoded_event(cls, event_data: EventData):
        raise NotImplementedError

    @property
    def created(self):
        return self.timestamp

class ERC20TransferQuerySet(TokenTransferQuerySet):
    def token_txs(self):
        return self.annotate(
            _value=F("value"),
            transaction_hash=F("ethereum_tx_id"),
            block=F("block_number"),
            execution_date=F("timestamp"),
            _token_id=RawSQL("NULL::numeric", ()),
            token_address=F("address"),
        )

class ERC20Transfer(TokenTransfer):
    objects = TokenTransferManager.from_queryset(ERC20TransferQuerySet)()
    value = Uint256Field()

    class Meta(TokenTransfer.Meta):
        abstract = False
        verbose_name = "ERC20 Transfer"
        verbose_name_plural = "ERC20 Transfers"
        unique_together = (("ethereum_tx", "log_index"),)

    def __str__(self):
        return f"ERC20 Transfer from={self._from} to={self.to} value={self.value}"

    @classmethod
    def from_decoded_event(cls, event_data: EventData) -> Union["ERC20Transfer"]:
        """
        Does not create the model, as it requires that `ethereum_tx` exists

        :param event_data:
        :return: `ERC20Transfer`
        :raises: ValueError
        """

        parameters = cls._prepare_parameters_from_decoded_event(event_data)

        if "value" in event_data["args"]:
            parameters["value"] = event_data["args"]["value"]
            return ERC20Transfer(**parameters)
        else:
            raise ValueError(
                f"Not supported EventData, `value` not present {event_data}"
            )

    def to_erc721_transfer(self):
        return ERC721Transfer(
            timestamp=self.timestamp,
            block_number=self.block_number,
            ethereum_tx=self.ethereum_tx,
            address=self.address,
            _from=self._from,
            to=self.to,
            log_index=self.log_index,
            token_id=self.value,
        )

class ERC721TransferManager(TokenTransferManager):
    def erc721_owned_by(
        self,
        address: ChecksumAddress,
        only_trusted: Optional[bool] = None,
        exclude_spam: Optional[bool] = None,
    ) -> List[Tuple[ChecksumAddress, int]]:
        """
        Returns erc721 owned by address, removing the ones sent

        :return: List of tuples(token_address: str, token_id: int)
        """

        owned_by_query = """
        SELECT Q1.address, Q1.token_id
        FROM (SELECT address,
                     token_id,
                     Count(*) AS count
              FROM   history_erc721transfer
              WHERE  "to" = %s AND "to" != "_from"
              GROUP  BY address,
                        token_id) Q1
             LEFT JOIN (SELECT address,
                               token_id,
                               Count(*) AS count
                        FROM   history_erc721transfer
                        WHERE  "_from" = %s AND "to" != "_from"
                        GROUP  BY address,
                                  token_id) Q2
                    ON Q1.address = Q2.address
                       AND Q1.token_id = Q2.token_id
        WHERE Q1.count > COALESCE(Q2.count, 0)
        """

        if only_trusted:
            owned_by_query += " AND Q1.address IN (SELECT address FROM tokens_token WHERE trusted = TRUE)"
        elif exclude_spam:
            owned_by_query += " AND Q1.address NOT IN (SELECT address FROM tokens_token WHERE spam = TRUE)"

        # Sort by token `address`, then by `token_id` to be stable
        owned_by_query += " ORDER BY Q1.address, Q2.token_id"

        with connection.cursor() as cursor:
            hex_address = HexBytes(address)
            # Queries all the ERC721 IN and all OUT and only returns the ones currently owned
            cursor.execute(owned_by_query, [hex_address, hex_address])
            return [
                (fast_to_checksum_address(bytes(address)), int(token_id))
                for address, token_id in cursor.fetchall()
            ]

class ERC721TransferQuerySet(TokenTransferQuerySet):
    def token_txs(self):
        return self.annotate(
            _value=RawSQL("NULL::numeric", ()),
            transaction_hash=F("ethereum_tx_id"),
            block=F("block_number"),
            execution_date=F("timestamp"),
            _token_id=F("token_id"),
            token_address=F("address"),
        )

class ERC721Transfer(TokenTransfer):
    objects = ERC721TransferManager.from_queryset(ERC721TransferQuerySet)()
    token_id = Uint256Field()

    class Meta(TokenTransfer.Meta):
        abstract = False
        verbose_name = "ERC721 Transfer"
        verbose_name_plural = "ERC721 Transfers"
        unique_together = (("ethereum_tx", "log_index"),)

    def __str__(self):
        return (
            f"ERC721 Transfer from={self._from} to={self.to} token_id={self.token_id}"
        )

    @classmethod
    def from_decoded_event(cls, event_data: EventData) -> Union["ERC721Transfer"]:
        """
        Does not create the model, as it requires that `ethereum_tx` exists

        :param event_data:
        :return: `ERC721Transfer`
        :raises: ValueError
        """

        parameters = cls._prepare_parameters_from_decoded_event(event_data)

        if "tokenId" in event_data["args"]:
            parameters["token_id"] = event_data["args"]["tokenId"]
            return ERC721Transfer(**parameters)
        else:
            raise ValueError(
                f"Not supported EventData, `tokenId` not present {event_data}"
            )

    @property
    def value(self) -> Decimal:
        """
        Behave as a ERC20Transfer so it's easier to handle
        """
        return self.token_id

    def to_erc20_transfer(self):
        return ERC20Transfer(
            timestamp=self.timestamp,
            block_number=self.block_number,
            ethereum_tx=self.ethereum_tx,
            address=self.address,
            _from=self._from,
            to=self.to,
            log_index=self.log_index,
            value=self.token_id,
        )

class InternalTxManager(BulkCreateSignalMixin, models.Manager):
    def _trace_address_to_str(self, trace_address: Sequence[int]) -> str:
        return ",".join([str(address) for address in trace_address])

    def build_from_trace(
        self, trace: Dict[str, Any], ethereum_tx: EthereumTx
    ) -> "InternalTx":
        """
        Build a InternalTx object from trace, but it doesn't insert it on database
        :param trace:
        :param ethereum_tx:
        :return: InternalTx not inserted
        """
        data = trace["action"].get("input") or trace["action"].get("init")
        tx_type = InternalTxType.parse(trace["type"])
        call_type = EthereumTxCallType.parse_call_type(trace["action"].get("callType"))
        trace_address_str = self._trace_address_to_str(trace["traceAddress"])
        return InternalTx(
            ethereum_tx=ethereum_tx,
            timestamp=ethereum_tx.block.timestamp,
            block_number=ethereum_tx.block_id,
            trace_address=trace_address_str,
            _from=trace["action"].get("from"),
            gas=trace["action"].get("gas", 0),
            data=data if data else None,
            to=trace["action"].get("to") or trace["action"].get("address"),
            value=trace["action"].get("value") or trace["action"].get("balance", 0),
            gas_used=(trace.get("result") or {}).get("gasUsed", 0),
            contract_address=(trace.get("result") or {}).get("address"),
            code=(trace.get("result") or {}).get("code"),
            output=(trace.get("result") or {}).get("output"),
            refund_address=trace["action"].get("refundAddress"),
            tx_type=tx_type.value,
            call_type=call_type.value if call_type else None,
            error=trace.get("error"),
        )

    def get_or_create_from_trace(
        self, trace: Dict[str, Any], ethereum_tx: EthereumTx
    ) -> Tuple["InternalTx", bool]:
        tx_type = InternalTxType.parse(trace["type"])
        call_type = EthereumTxCallType.parse_call_type(trace["action"].get("callType"))
        trace_address_str = self._trace_address_to_str(trace["traceAddress"])
        return self.get_or_create(
            ethereum_tx=ethereum_tx,
            trace_address=trace_address_str,
            defaults={
                "timestamp": ethereum_tx.block.timestamp,
                "block_number": ethereum_tx.block_id,
                "_from": trace["action"].get("from"),
                "gas": trace["action"].get("gas", 0),
                "data": trace["action"].get("input") or trace["action"].get("init"),
                "to": trace["action"].get("to") or trace["action"].get("address"),
                "value": trace["action"].get("value")
                or trace["action"].get("balance", 0),
                "gas_used": (trace.get("result") or {}).get("gasUsed", 0),
                "contract_address": (trace.get("result") or {}).get("address"),
                "code": (trace.get("result") or {}).get("code"),
                "output": (trace.get("result") or {}).get("output"),
                "refund_address": trace["action"].get("refundAddress"),
                "tx_type": tx_type.value,
                "call_type": call_type.value if call_type else None,
                "error": trace.get("error"),
            },
        )

class InternalTxQuerySet(models.QuerySet):
    def ether_txs(self):
        return self.filter(
            call_type=EthereumTxCallType.CALL.value, value__gt=0
        ).annotate(
            _value=F("value"),
            transaction_hash=F("ethereum_tx_id"),
            block=F("block_number"),
            execution_date=F("timestamp"),
            _token_id=RawSQL("NULL::numeric", ()),
            token_address=Value(None, output_field=EthereumAddressV2Field()),
        )

    def ether_txs_for_address(self, address: str):
        return self.ether_txs().filter(Q(to=address) | Q(_from=address))

    def ether_incoming_txs_for_address(self, address: str):
        return self.ether_txs().filter(to=address)

    def token_txs(self):
        values = [
            "block",
            "transaction_hash",
            "to",
            "_from",
            "_value",
            "execution_date",
            "_token_id",
            "token_address",
        ]
        erc20_queryset = ERC20Transfer.objects.token_txs()
        erc721_queryset = ERC721Transfer.objects.token_txs()
        return (
            erc20_queryset.values(*values)
            .union(erc721_queryset.values(*values), all=True)
            .order_by("-block")
        )

    def token_incoming_txs_for_address(self, address: str):
        values = [
            "block",
            "transaction_hash",
            "to",
            "_from",
            "_value",
            "execution_date",
            "_token_id",
            "token_address",
        ]
        erc20_queryset = ERC20Transfer.objects.incoming(address).token_txs()
        erc721_queryset = ERC721Transfer.objects.incoming(address).token_txs()
        return (
            erc20_queryset.values(*values)
            .union(erc721_queryset.values(*values), all=True)
            .order_by("-block")
        )

    def ether_and_token_txs(self, address: str):
        erc20_queryset = ERC20Transfer.objects.to_or_from(address).token_txs()
        erc721_queryset = ERC721Transfer.objects.to_or_from(address).token_txs()
        ether_queryset = self.ether_txs_for_address(address)
        return self.union_ether_and_token_txs(
            erc20_queryset, erc721_queryset, ether_queryset
        )

    def ether_and_token_incoming_txs(self, address: str):
        erc20_queryset = ERC20Transfer.objects.incoming(address).token_txs()
        erc721_queryset = ERC721Transfer.objects.incoming(address).token_txs()
        ether_queryset = self.ether_incoming_txs_for_address(address)
        return self.union_ether_and_token_txs(
            erc20_queryset, erc721_queryset, ether_queryset
        )

    def union_ether_and_token_txs(
        self,
        erc20_queryset: QuerySet,
        erc721_queryset: QuerySet,
        ether_queryset: QuerySet,
    ) -> TransferDict:
        values = [
            "block",
            "transaction_hash",
            "to",
            "_from",
            "_value",
            "execution_date",
            "_token_id",
            "token_address",
        ]
        return (
            ether_queryset.values(*values)
            .union(erc20_queryset.values(*values), all=True)
            .union(erc721_queryset.values(*values), all=True)
            .order_by("-block")
        )

    def can_be_decoded(self):
        """
        Every InternalTx can be decoded if:
            - Has data
            - InternalTx is not errored
            - EthereumTx is successful (not reverted or out of gas)
            - CallType is a DELEGATE_CALL (to the master copy contract)
            - Not already decoded
        :return: Txs that can be decoded
        """
        return self.exclude(data=None).filter(
            call_type=EthereumTxCallType.DELEGATE_CALL.value,
            error=None,
            ethereum_tx__status=1,
            decoded_tx=None,
        )

class InternalTx(models.Model):
    objects = InternalTxManager.from_queryset(InternalTxQuerySet)()
    ethereum_tx = models.ForeignKey(
        EthereumTx, on_delete=models.CASCADE, related_name="internal_txs"
    )
    timestamp = models.DateTimeField(db_index=True)
    block_number = models.PositiveIntegerField(db_index=True)
    _from = EthereumAddressV2Field(
        null=True, db_index=True
    )  # For SELF-DESTRUCT it can be null
    gas = Uint256Field()
    data = models.BinaryField(null=True)  # `input` for Call, `init` for Create
    to = EthereumAddressV2Field(null=True)
    value = Uint256Field()
    gas_used = Uint256Field()
    contract_address = EthereumAddressV2Field(null=True, db_index=True)  # Create
    code = models.BinaryField(null=True)  # Create
    output = models.BinaryField(null=True)  # Call
    refund_address = EthereumAddressV2Field(
        null=True, db_index=True
    )  # For SELF-DESTRUCT
    tx_type = models.PositiveSmallIntegerField(
        choices=[(tag.value, tag.name) for tag in InternalTxType], db_index=True
    )
    call_type = models.PositiveSmallIntegerField(
        null=True,
        choices=[(tag.value, tag.name) for tag in EthereumTxCallType],
        db_index=True,
    )  # Call
    trace_address = models.CharField(max_length=600)  # Stringified traceAddress
    error = models.CharField(max_length=200, null=True)

    class Meta:
        unique_together = (("ethereum_tx", "trace_address"),)
        indexes = [
            models.Index(
                name="history_internaltx_value_idx",
                fields=["value"],
                condition=Q(value__gt=0),
            ),
            Index(fields=["_from", "timestamp"]),
            Index(fields=["to", "timestamp"]),
        ]

    def __str__(self):
        if self.to:
            return "Internal tx hash={} from={} to={}".format(
                HexBytes(self.ethereum_tx_id).hex(), self._from, self.to
            )
        else:
            return "Internal tx hash={} from={}".format(
                HexBytes(self.ethereum_tx_id).hex(), self._from
            )

    @property
    def created(self):
        return self.timestamp

    @property
    def can_be_decoded(self) -> bool:
        return bool(
            self.is_delegate_call
            and not self.error
            and self.data
            and self.ethereum_tx.success
        )

    @property
    def is_call(self):
        return InternalTxType(self.tx_type) == InternalTxType.CALL

    @property
    def is_create(self):
        return InternalTxType(self.tx_type) == InternalTxType.CREATE

    @property
    def is_decoded(self):
        try:
            return bool(self.decoded_tx)
        except InternalTxDecoded.DoesNotExist:
            return False

    @property
    def is_delegate_call(self) -> bool:
        if self.call_type is None:
            return False
        else:
            return (
                EthereumTxCallType(self.call_type) == EthereumTxCallType.DELEGATE_CALL
            )

    @property
    def is_ether_transfer(self) -> bool:
        return self.call_type == EthereumTxCallType.CALL.value and self.value > 0

    @property
    def is_relevant(self):
        return self.can_be_decoded or self.is_ether_transfer or self.contract_address

    @property
    def trace_address_as_list(self) -> List[int]:
        if not self.trace_address:
            return []
        else:
            return [int(x) for x in self.trace_address.split(",")]

    def get_parent(self) -> Optional["InternalTx"]:
        if (
            "," not in self.trace_address
        ):  # We are expecting something like 0,0,1 or 1,1
            return None
        parent_trace_address = ",".join(self.trace_address.split(",")[:-1])
        try:
            return InternalTx.objects.filter(
                ethereum_tx_id=self.ethereum_tx_id, trace_address=parent_trace_address
            ).get()
        except InternalTx.DoesNotExist:
            return None

    def get_child(self, index: int) -> Optional["InternalTx"]:
        child_trace_address = f"{self.trace_address},{index}"
        try:
            return InternalTx.objects.filter(
                ethereum_tx_id=self.ethereum_tx_id, trace_address=child_trace_address
            ).get()
        except InternalTx.DoesNotExist:
            return None

class InternalTxDecodedManager(BulkCreateSignalMixin, models.Manager):
    def out_of_order_for_safe(self, safe_address: ChecksumAddress):
        """
        :param safe_address:
        :return: `True` if there are transactions out of order (processed transactions newer
            than no processed transactions, due to a reindex), `False` otherwise
        """

        return (
            self.for_safe(safe_address)
            .not_processed()
            .filter(
                internal_tx__block_number__lt=self.for_safe(safe_address)
                .processed()
                .order_by("-internal_tx__block_number")
                .values("internal_tx__block_number")[:1]
            )
            .exists()
        )

class InternalTxDecodedQuerySet(models.QuerySet):
    def for_safe(self, safe_address: ChecksumAddress):
        """
        :param safe_address:
        :return: Queryset of all InternalTxDecoded for one Safe with `safe_address`
        """
        return self.filter(internal_tx___from=safe_address)

    def processed(self):
        return self.filter(processed=True)

    def not_processed(self):
        return self.filter(processed=False)

    def order_by_processing_queue(self):
        """
        :return: Transactions ordered to be processed. First `setup` and then older transactions
        """
        return self.annotate(
            is_setup=Case(
                When(function_name="setup", then=Value(0)),
                default=Value(1),
            )
        ).order_by(
            "is_setup",
            "internal_tx__block_number",
            "internal_tx__ethereum_tx__transaction_index",
            "internal_tx_id",
        )

    def pending_for_safes(self):
        """
        :return: Pending `InternalTxDecoded` sorted by block number and then transaction index inside the block
        """
        return self.not_processed().order_by_processing_queue()

    def pending_for_safe(self, safe_address: ChecksumAddress):
        """
        :return: Pending `InternalTxDecoded` sorted by block number and then transaction index inside the block
        """
        return (
            self.pending_for_safes()
            .filter(internal_tx___from=safe_address)
            .select_related("internal_tx")
        )

    def safes_pending_to_be_processed(self) -> QuerySet[ChecksumAddress]:
        """
        :return: List of Safe addresses that have transactions pending to be processed
        """
        return (
            self.not_processed()
            .values_list("internal_tx___from", flat=True)
            .distinct("internal_tx___from")
        )

class InternalTxDecoded(models.Model):
    objects = InternalTxDecodedManager.from_queryset(InternalTxDecodedQuerySet)()
    internal_tx = models.OneToOneField(
        InternalTx,
        on_delete=models.CASCADE,
        related_name="decoded_tx",
        primary_key=True,
    )
    function_name = models.CharField(max_length=256, db_index=True)
    arguments = JSONField()
    processed = models.BooleanField(default=False)

    class Meta:
        indexes = [
            models.Index(
                name="history_decoded_processed_idx",
                fields=["processed"],
                condition=Q(processed=False),
            )
        ]
        verbose_name_plural = "Internal txs decoded"

    def __str__(self):
        return (
            f'{"Processed" if self.processed else "Not Processed"} '
            f"fn-name={self.function_name} with arguments={self.arguments}"
        )

    @property
    def address(self) -> str:
        return self.internal_tx._from

    @property
    def block_number(self) -> Type[int]:
        return self.internal_tx.block_number

    @property
    def tx_hash(self) -> Type[int]:
        return self.internal_tx.ethereum_tx_id

    def set_processed(self):
        self.processed = True
        return self.save(update_fields=["processed"])

class MultisigTransactionManager(models.Manager):
    def last_nonce(self, safe: str) -> Optional[int]:
        """
        :param safe:
        :return: nonce of the last executed and mined transaction. It will be None if there's no transactions or none
        of them is mined
        """
        nonce_query = (
            self.filter(safe=safe)
            .exclude(ethereum_tx=None)
            .order_by("-nonce")
            .values("nonce")
            .first()
        )
        if nonce_query:
            return nonce_query["nonce"]

    def last_valid_transaction(self, safe: str) -> Optional["MultisigTransaction"]:
        """
        Find last transaction where signers match the owners registered for that Safe. Transactions out of sync
        have an invalid `safeNonce`, so `safeTxHash` is not valid and owners recovered from the signatures wouldn't be
        valid. We exclude `Approved hashes` and `Contract signatures` as that owners are not retrieved using the
        signature, so they will show the right owner even if `safeNonce` is not valid

        :param safe:
        :return: Last valid indexed transaction mined
        """
        # Build list of every owner known for that Safe (even if it was deleted/replaced). Changes of collision for
        # invalid recovered owners from signatures are almost impossible
        owners_set = set()
        for owners_list in (
            SafeStatus.objects.filter(address=safe)
            .values_list("owners", flat=True)
            .distinct()
            .iterator()
        ):
            owners_set.update(owners_list)

        return (
            self.executed()
            .filter(
                safe=safe,
                confirmations__owner__in=owners_set,
                confirmations__signature_type__in=[
                    SafeSignatureType.EOA.value,
                    SafeSignatureType.ETH_SIGN.value,
                ],
            )
            .order_by("-nonce")
            .first()
        )

    def safes_with_number_of_transactions_executed(self):
        return (
            self.executed()
            .values("safe")
            .annotate(transactions=Count("safe"))
            .order_by("-transactions")
        )

    def safes_with_number_of_transactions_executed_and_master_copy(self):
        master_copy_query = (
            SafeStatus.objects.filter(address=OuterRef("safe"))
            .order_by("-nonce")
            .values("master_copy")
        )

        return (
            self.safes_with_number_of_transactions_executed()
            .annotate(master_copy=Subquery(master_copy_query[:1]))
            .order_by("-transactions")
        )

    def not_indexed_metadata_contract_addresses(self):
        """
        Find contracts with metadata (abi, contract name) not indexed

        :return:
        """
        return (
            self.trusted()
            .exclude(data=None)
            .exclude(Exists(Contract.objects.filter(address=OuterRef("to"))))
            .values_list("to", flat=True)
            .distinct()
        )

class MultisigTransactionQuerySet(models.QuerySet):
    def ether_transfers(self):
        return self.exclude(value=0)

    def executed(self):
        return self.exclude(ethereum_tx=None)

    def not_executed(self):
        return self.filter(ethereum_tx=None)

    def with_data(self):
        return self.exclude(data=None)

    def without_data(self):
        return self.filter(data=None)

    def with_confirmations(self):
        return self.exclude(confirmations__isnull=True)

    def without_confirmations(self):
        return self.filter(confirmations__isnull=True)

    def trusted(self):
        return self.filter(trusted=True)

    def multisend(self):
        # TODO Use MultiSend.MULTISEND_ADDRESSES + MultiSend MULTISEND_CALL_ONLY_ADDRESSES
        return self.filter(
            to__in=[
                "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",  # MultiSend v1.3.0
                "0x998739BFdAAdde7C933B942a68053933098f9EDa",  # MultiSend v1.3.0 (EIP-155)
                "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",  # MultiSend Call Only v1.3.0
                "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",  # MultiSend Call Only v1.3.0 (EIP-155)
            ]
        )

    def with_confirmations_required(self):
        """
        Add confirmations required for execution when the tx was mined (threshold of the Safe at that point)

        :return: queryset with `confirmations_required: int` field
        """
        threshold_safe_status_query = (
            SafeStatus.objects.filter(internal_tx__ethereum_tx=OuterRef("ethereum_tx"))
            .sorted_reverse_by_mined()
            .values("threshold")
        )

        threshold_safe_last_status_query = SafeLastStatus.objects.filter(
            address=OuterRef("safe")
        ).values("threshold")

        threshold_queries = Case(
            When(
                ethereum_tx__isnull=True,
                then=Subquery(threshold_safe_last_status_query[:1]),
            ),
            default=Subquery(threshold_safe_status_query[:1]),
        )

        return self.annotate(confirmations_required=threshold_queries)

    def queued(self, safe_address: str):
        """
        :return: Transactions not executed with safe-nonce greater than the last executed nonce. If no transaction is
        executed every transaction is returned
        """
        subquery = (
            self.executed()
            .filter(safe=safe_address)
            .values("safe")
            .annotate(max_nonce=Max("nonce"))
            .values("max_nonce")
        )
        return (
            self.not_executed()
            .annotate(
                max_executed_nonce=Coalesce(
                    Subquery(subquery), Value(-1), output_field=Uint256Field()
                )
            )
            .filter(nonce__gt=F("max_executed_nonce"), safe=safe_address)
        )

class MultisigTransaction(TimeStampedModel):
    objects = MultisigTransactionManager.from_queryset(MultisigTransactionQuerySet)()
    safe_tx_hash = Keccak256Field(primary_key=True)
    safe = EthereumAddressV2Field(db_index=True)
    ethereum_tx = models.ForeignKey(
        EthereumTx,
        null=True,
        default=None,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="multisig_txs",
    )
    to = EthereumAddressV2Field(null=True, db_index=True)
    value = Uint256Field()
    data = models.BinaryField(null=True, blank=True, editable=True)
    operation = models.PositiveSmallIntegerField(
        choices=[(tag.value, tag.name) for tag in SafeOperation]
    )
    safe_tx_gas = Uint256Field()
    base_gas = Uint256Field()
    gas_price = Uint256Field()
    gas_token = EthereumAddressV2Field(null=True, blank=True)
    refund_receiver = EthereumAddressV2Field(null=True, blank=True)
    signatures = models.BinaryField(null=True, blank=True)  # When tx is executed
    nonce = Uint256Field(db_index=True)
    failed = models.BooleanField(null=True, blank=True, default=None, db_index=True)
    origin = models.JSONField(default=dict)  # To store arbitrary data on the tx
    trusted = models.BooleanField(
        default=False, db_index=True
    )  # Txs proposed by a delegate or with one confirmation

    class Meta:
        permissions = [
            ("create_trusted", "Can create trusted transactions"),
        ]

    def __str__(self):
        return f"{self.safe} - {self.nonce} - {self.safe_tx_hash}"

    @property
    def execution_date(self) -> Optional[datetime.datetime]:
        if self.ethereum_tx_id and self.ethereum_tx.block_id is not None:
            return self.ethereum_tx.block.timestamp
        return None

    @property
    def executed(self) -> bool:
        return bool(self.ethereum_tx_id and (self.ethereum_tx.block_id is not None))

    @property
    def owners(self) -> Optional[List[str]]:
        if not self.signatures:
            return []
        else:
            signatures = bytes(self.signatures)
            safe_signatures = SafeSignature.parse_signature(
                signatures, self.safe_tx_hash
            )
            return [safe_signature.owner for safe_signature in safe_signatures]

    def data_should_be_decoded(self) -> bool:
        """
        Decoding could lead people to be tricked, and this is real critical when using DELEGATE_CALL as the operation

        :return: `True` if data should be decoded, `False` otherwise
        """
        return not (
            self.operation == SafeOperation.DELEGATE_CALL.value
            and self.to not in Contract.objects.trusted_addresses_for_delegate_call()
        )

class ModuleTransactionManager(models.Manager):
    def not_indexed_metadata_contract_addresses(self):
        """
        Find contracts with metadata (abi, contract name) not indexed
        :return:
        """
        return (
            self.exclude(Exists(Contract.objects.filter(address=OuterRef("module"))))
            .values_list("module", flat=True)
            .distinct()
        )

class ModuleTransaction(TimeStampedModel):
    objects = ModuleTransactionManager()
    internal_tx = models.OneToOneField(
        InternalTx, on_delete=models.CASCADE, related_name="module_tx", primary_key=True
    )
    safe = EthereumAddressV2Field(
        db_index=True
    )  # Just for convenience, it could be retrieved from `internal_tx`
    module = EthereumAddressV2Field(
        db_index=True
    )  # Just for convenience, it could be retrieved from `internal_tx`
    to = EthereumAddressV2Field(db_index=True)
    value = Uint256Field()
    data = models.BinaryField(null=True)
    operation = models.PositiveSmallIntegerField(
        choices=[(tag.value, tag.name) for tag in SafeOperation]
    )
    failed = models.BooleanField(default=False)

    def __str__(self):
        if self.value:
            return f"{self.safe} - {self.to} - {self.value}"
        else:
            return f"{self.safe} - {self.to} - 0x{bytes(self.data).hex()[:6]}"

    @property
    def execution_date(self) -> datetime.datetime:
        return self.internal_tx.timestamp

class MultisigConfirmationManager(models.Manager):
    def remove_unused_confirmations(
        self, safe: str, current_safe_none: int, owner: str
    ) -> int:
        """
        :return: Remove confirmations for not executed transactions with nonce higher or equal than
        the current Safe nonce for a Safe and an owner (as an owner can be an owner of multiple Safes).
        Used when an owner is removed from the Safe.
        """
        return self.filter(
            multisig_transaction__ethereum_tx=None,  # Not executed
            multisig_transaction__safe=safe,
            multisig_transaction__nonce__gte=current_safe_none,
            owner=owner,
        ).delete()[0]

class MultisigConfirmationQuerySet(models.QuerySet):
    def without_transaction(self):
        return self.filter(multisig_transaction=None)

    def with_transaction(self):
        return self.exclude(multisig_transaction=None)

class MultisigConfirmation(TimeStampedModel):
    objects = MultisigConfirmationManager.from_queryset(MultisigConfirmationQuerySet)()
    ethereum_tx = models.ForeignKey(
        EthereumTx,
        on_delete=models.CASCADE,
        related_name="multisig_confirmations",
        null=True,
    )  # `null=True` for signature confirmations
    multisig_transaction = models.ForeignKey(
        MultisigTransaction,
        on_delete=models.CASCADE,
        null=True,
        related_name="confirmations",
    )
    multisig_transaction_hash = Keccak256Field(
        null=True, db_index=True
    )  # Use this while we don't have a `multisig_transaction`
    owner = EthereumAddressV2Field()

    signature = HexField(null=True, default=None, max_length=5000)
    signature_type = models.PositiveSmallIntegerField(
        choices=[(tag.value, tag.name) for tag in SafeSignatureType], db_index=True
    )

    class Meta:
        unique_together = (("multisig_transaction_hash", "owner"),)
        ordering = ["created"]

    def __str__(self):
        if self.multisig_transaction_id:
            return f"Confirmation of owner={self.owner} for transaction-hash={self.multisig_transaction_hash}"
        else:
            return f"Confirmation of owner={self.owner} for existing transaction={self.multisig_transaction_hash}"

class MonitoredAddress(models.Model):
    address = EthereumAddressV2Field(primary_key=True)
    initial_block_number = models.IntegerField(
        default=0
    )  # Block number when address received first tx
    tx_block_number = models.IntegerField(
        null=True, default=None, db_index=True
    )  # Block number when last internal tx scan ended

    class Meta:
        abstract = True
        verbose_name_plural = "Monitored addresses"

    def __str__(self):
        return (
            f"Address={self.address} - Initial-block-number={self.initial_block_number}"
            f" - Tx-block-number={self.tx_block_number}"
        )

class ProxyFactory(MonitoredAddress):
    class Meta:
        verbose_name_plural = "Proxy factories"
        ordering = ["tx_block_number"]

def validate_version(value: str):
    try:
        if not value:
            raise ValueError("Empty version not allowed")
        Version(value)
    except ValueError as exc:
        raise ValidationError(
            _("%(value)s is not a valid version: %(reason)s"),
            params={"value": value, "reason": str(exc)},
        )

class SafeMasterCopyManager(models.Manager):
    @cache
    def get_version_for_address(self, address: ChecksumAddress) -> Optional[str]:
        try:
            return self.filter(address=address).only("version").get().version
        except self.model.DoesNotExist:
            return None

class SafeMasterCopyQueryset(models.QuerySet):
    def l2(self):
        return self.filter(l2=True)

    def not_l2(self):
        return self.filter(l2=False)

    def relevant(self):
        """
        :return: Relevant master copies for this network. If network is `L2`, only `L2` master copies are returned.
            Otherwise, all master copies are returned
        """
        if settings.ETH_L2_NETWORK:
            return self.l2()
        else:
            return self.all()

class SafeMasterCopy(MonitoredAddress):
    objects = SafeMasterCopyManager.from_queryset(SafeMasterCopyQueryset)()
    version = models.CharField(max_length=20, validators=[validate_version])
    deployer = models.CharField(max_length=50, default="Gnosis")
    l2 = models.BooleanField(default=False)

    class Meta:
        verbose_name_plural = "Safe master copies"
        ordering = ["tx_block_number"]

class SafeContract(models.Model):
    address = EthereumAddressV2Field(primary_key=True)
    ethereum_tx = models.ForeignKey(
        EthereumTx, on_delete=models.CASCADE, related_name="safe_contracts"
    )

    def __str__(self):
        return f"Safe address={self.address} - ethereum-tx={self.ethereum_tx_id}"

    @property
    def created(self):
        return self.ethereum_tx.block.timestamp

    @property
    def created_block_number(self) -> Optional[Type[int]]:
        if self.ethereum_tx:
            return self.ethereum_tx.block_id

class SafeContractDelegateManager(models.Manager):
    def get_delegates_for_safe(self, address: ChecksumAddress) -> Set[ChecksumAddress]:
        return set(
            self.filter(safe_contract_id=address)
            .values_list("delegate", flat=True)
            .distinct()
        )

    def get_delegates_for_safe_and_owners(
        self, safe_address: ChecksumAddress, owner_addresses: Sequence[ChecksumAddress]
    ) -> Set[ChecksumAddress]:
        if not owner_addresses:
            return set()
        return set(
            self.filter(
                # If safe_contract is null on SafeContractDelegate, delegates are valid for every Safe
                Q(safe_contract_id=safe_address)
                | Q(safe_contract=None)
            )
            .filter(delegator__in=owner_addresses)
            .values_list("delegate", flat=True)
            .distinct()
        )

class SafeContractDelegate(models.Model):
    """
    The owners of the Safe can add users so they can propose/retrieve txs as if they were the owners of the Safe
    """

    objects = SafeContractDelegateManager()
    safe_contract = models.ForeignKey(
        SafeContract,
        on_delete=models.CASCADE,
        related_name="safe_contract_delegates",
        null=True,
        default=None,
    )
    delegate = EthereumAddressV2Field()
    delegator = EthereumAddressV2Field()  # Owner who created the delegate
    label = models.CharField(max_length=50)
    read = models.BooleanField(default=True)  # For permissions in the future
    write = models.BooleanField(default=True)

    class Meta:
        unique_together = (("safe_contract", "delegate", "delegator"),)

    def __str__(self):
        return (
            f"Delegator={self.delegator} Delegate={self.delegate} for Safe={self.safe_contract_id} - "
            f"Label={self.label}"
        )

class SafeStatusBase(models.Model):
    internal_tx = models.OneToOneField(
        InternalTx,
        on_delete=models.CASCADE,
        related_name="safe_last_status",
        unique=True,
    )
    address = EthereumAddressV2Field(db_index=True, primary_key=True)
    owners = ArrayField(EthereumAddressV2Field())
    threshold = Uint256Field()
    nonce = Uint256Field(default=0)
    master_copy = EthereumAddressV2Field()
    fallback_handler = EthereumAddressV2Field()
    guard = EthereumAddressV2Field(default=None, null=True)
    enabled_modules = ArrayField(EthereumAddressV2Field(), default=list, blank=True)

    class Meta:
        abstract = True

    def _to_str(self):
        return f"safe={self.address} threshold={self.threshold} owners={self.owners} nonce={self.nonce}"

    @property
    def block_number(self) -> int:
        return self.internal_tx.ethereum_tx.block_id

    def is_corrupted(self) -> bool:
        """
        SafeStatus nonce must be incremental. If current nonce is bigger than the number of SafeStatus for that Safe
        something is wrong. There could be more SafeStatus than nonce (e.g. a call to a MultiSend
        adding owners and enabling a Module in the same contract `execTransaction`)

        :return: `True` if corrupted, `False` otherwise
        """
        return (
            SafeStatus.objects.distinct("nonce")
            .filter(address=self.address, nonce__lte=self.nonce)
            .count()
            <= self.nonce
        )

    @classmethod
    def from_status_instance(
        cls, safe_status_base: "SafeStatusBase"
    ) -> Union["SafeStatus", "SafeLastStatus"]:
        """
        Converts from SafeStatus to SafeLastStatus and vice versa
        """
        return cls(
            internal_tx=safe_status_base.internal_tx,
            address=safe_status_base.address,
            owners=safe_status_base.owners,
            threshold=safe_status_base.threshold,
            nonce=safe_status_base.nonce,
            master_copy=safe_status_base.master_copy,
            fallback_handler=safe_status_base.fallback_handler,
            guard=safe_status_base.guard,
            enabled_modules=safe_status_base.enabled_modules,
        )

class SafeLastStatusManager(models.Manager):
    def get_or_generate(self, address: ChecksumAddress) -> "SafeLastStatus":
        """
        :param address:
        :return: `SafeLastStatus` if it exists. If not, it will try to build it from `SafeStatus` table
        """
        try:
            return SafeLastStatus.objects.get(address=address)
        except self.model.DoesNotExist:
            safe_status = SafeStatus.objects.last_for_address(address)
            if safe_status:
                return SafeLastStatus.objects.update_or_create_from_safe_status(
                    safe_status
                )
            raise

    def update_or_create_from_safe_status(
        self, safe_status: "SafeStatus"
    ) -> "SafeLastStatus":
        obj, _ = self.update_or_create(
            address=safe_status.address,
            defaults={
                "internal_tx": safe_status.internal_tx,
                "owners": safe_status.owners,
                "threshold": safe_status.threshold,
                "nonce": safe_status.nonce,
                "master_copy": safe_status.master_copy,
                "fallback_handler": safe_status.fallback_handler,
                "guard": safe_status.guard,
                "enabled_modules": safe_status.enabled_modules,
            },
        )
        return obj

    def addresses_for_module(self, module_address: str) -> QuerySet[str]:
        """
        :param module_address:
        :return: Safes where the provided `module_address` is enabled
        """

        return self.filter(enabled_modules__contains=[module_address]).values_list(
            "address", flat=True
        )

    def addresses_for_owner(self, owner_address: str) -> QuerySet[str]:
        """
        :param owner_address:
        :return: Safes where the provided `owner_address` is an owner
        """

        return self.filter(owners__contains=[owner_address]).values_list(
            "address", flat=True
        )

class SafeLastStatus(SafeStatusBase):
    objects = SafeLastStatusManager()

    class Meta:
        indexes = [
            GinIndex(fields=["owners"]),
            GinIndex(fields=["enabled_modules"]),
        ]
        verbose_name_plural = "Safe last statuses"

    def __str__(self):
        return "LastStatus: " + self._to_str()

    def get_safe_info(self) -> SafeInfo:
        """
        :return: SafeInfo built from SafeLastStatus (not requiring connection to Ethereum RPC)
        """
        master_copy_version = SafeMasterCopy.objects.get_version_for_address(
            self.master_copy
        )

        return SafeInfo(
            self.address,
            self.fallback_handler,
            self.guard or NULL_ADDRESS,
            self.master_copy,
            self.enabled_modules,
            self.nonce,
            self.owners,
            self.threshold,
            master_copy_version,
        )

class SafeStatusManager(models.Manager):
    pass

class SafeStatusQuerySet(models.QuerySet):
    def sorted_by_mined(self):
        """
        Last SafeStatus first. Usually ordering by `nonce` it should be enough, but in some cases
        (MultiSend, calling functions inside the Safe like adding/removing owners...) there could be multiple
        transactions with the same nonce. `address` must be part of the expression to use `distinct()` later

        :return: SafeStatus QuerySet sorted
        """
        return self.order_by(
            "address",
            "-nonce",
            "-internal_tx__block_number",
            "-internal_tx__ethereum_tx__transaction_index",
            "-internal_tx_id",
        )

    def sorted_reverse_by_mined(self):
        return self.order_by(
            "address",
            "nonce",
            "internal_tx__block_number",
            "internal_tx__ethereum_tx__transaction_index",
            "internal_tx_id",
        )

    def last_for_every_address(self) -> QuerySet:
        return (
            self.distinct("address")  # Uses PostgreSQL `DISTINCT ON`
            .select_related("internal_tx__ethereum_tx")
            .sorted_by_mined()
        )

    def last_for_address(self, address: str) -> Optional["SafeStatus"]:
        return self.filter(address=address).sorted_by_mined().first()

class SafeStatus(SafeStatusBase):
    objects = SafeStatusManager.from_queryset(SafeStatusQuerySet)()
    internal_tx = models.OneToOneField(
        InternalTx,
        on_delete=models.CASCADE,
        related_name="safe_status",
        primary_key=True,
    )  # Make internal_tx the primary key
    address = EthereumAddressV2Field(db_index=True)  # Address is not the primary key

    class Meta:
        indexes = [
            Index(fields=["address", "-nonce"]),  # Index on address and nonce DESC
            Index(fields=["address", "-nonce", "-internal_tx"]),  # For Window search
        ]
        unique_together = (("internal_tx", "address"),)
        verbose_name_plural = "Safe statuses"

    def __str__(self):
        return "Status: " + self._to_str()

    @property
    def block_number(self) -> int:
        return self.internal_tx.ethereum_tx.block_id

    def previous(self) -> Optional["SafeStatus"]:
        """
        :return: SafeStatus with the previous nonce
        """
        return (
            self.__class__.objects.filter(address=self.address, nonce__lt=self.nonce)
            .sorted_by_mined()
            .first()
        )

class WebHookType(Enum):
    NEW_CONFIRMATION = 0
    PENDING_MULTISIG_TRANSACTION = 1
    EXECUTED_MULTISIG_TRANSACTION = 2
    INCOMING_ETHER = 3
    INCOMING_TOKEN = 4
    CONFIRMATION_REQUEST = 5
    SAFE_CREATED = 6
    MODULE_TRANSACTION = 7
    OUTGOING_ETHER = 8
    OUTGOING_TOKEN = 9

class WebHookQuerySet(models.QuerySet):
    def matching_for_address(self, address: str):
        return self.filter(Q(address=address) | Q(address=None))

def _validate_webhook_url(url: str) -> None:
    result = urlparse(url)
    if not all(
        (
            result.scheme
            in (
                "http",
                "https",
            ),
            result.netloc,
        )
    ):
        raise ValidationError(f"{url} is not a valid url")

class WebHook(models.Model):
    objects = WebHookQuerySet.as_manager()
    address = EthereumAddressV2Field(db_index=True, null=True, blank=True)
    url = models.CharField(max_length=255, validators=[_validate_webhook_url])
    authorization = models.CharField(
        max_length=500,
        null=True,
        blank=True,
        default=None,
        help_text="Set HTTP Authorization header with the value",
    )
    # Configurable webhook types to listen to
    new_confirmation = models.BooleanField(default=True, help_text="New confirmation")
    pending_multisig_transaction = models.BooleanField(
        default=True, help_text="New pending multisig transaction"
    )
    new_executed_multisig_transaction = models.BooleanField(
        default=True, help_text="New mined multisig transaction"
    )
    new_incoming_transaction = models.BooleanField(
        default=True, help_text="New incoming transaction of eth/token"
    )
    new_safe = models.BooleanField(default=True, help_text="New Safe created")
    new_module_transaction = models.BooleanField(
        default=True, help_text="New mined module transaction"
    )
    new_outgoing_transaction = models.BooleanField(
        default=True, help_text="New outgoing transaction of eth/token"
    )

    class Meta:
        unique_together = (("address", "url"),)

    def __str__(self):
        if self.address:
            return f"Webhook for safe={self.address} to url={self.url}"
        else:
            return f"Webhook to every address to url={self.url}"

    def is_valid_for_webhook_type(self, webhook_type: WebHookType):
        if webhook_type == WebHookType.NEW_CONFIRMATION and not self.new_confirmation:
            return False
        elif (
            webhook_type == WebHookType.PENDING_MULTISIG_TRANSACTION
            and not self.pending_multisig_transaction
        ):
            return False
        elif (
            webhook_type == WebHookType.EXECUTED_MULTISIG_TRANSACTION
            and not self.new_executed_multisig_transaction
        ):
            return False
        elif (
            webhook_type in (WebHookType.INCOMING_TOKEN, WebHookType.INCOMING_ETHER)
            and not self.new_incoming_transaction
        ):
            return False
        elif webhook_type == WebHookType.SAFE_CREATED and not self.new_safe:
            return False
        elif (
            webhook_type == WebHookType.MODULE_TRANSACTION
            and not self.new_module_transaction
        ):
            return False
        elif (
            webhook_type in (WebHookType.OUTGOING_TOKEN, WebHookType.OUTGOING_ETHER)
            and not self.new_outgoing_transaction
        ):
            return False
        else:
            return True

'''
'''--- safe_transaction_service/history/pagination.py ---
from django.http import HttpRequest

from rest_framework.pagination import LimitOffsetPagination

class DefaultPagination(LimitOffsetPagination):
    max_limit = 200
    default_limit = 100

class SmallPagination(LimitOffsetPagination):
    max_limit = 100
    default_limit = 20

class ListPagination(LimitOffsetPagination):
    max_limit = 10

    def __init__(self, request: HttpRequest):
        super().__init__()
        self.request = request
        self.limit = self.get_limit(request)
        self.offset = self.get_offset(request)
        self.count: int = 0

    def set_count(self, value):
        self.count = value

'''
'''--- safe_transaction_service/history/serializers.py ---
import json
from enum import Enum
from typing import Any, Dict, List, Optional

from drf_yasg.utils import swagger_serializer_method
from eth_typing import ChecksumAddress
from rest_framework import serializers
from rest_framework.exceptions import NotFound, ValidationError

from gnosis.eth import EthereumClient, EthereumClientProvider
from gnosis.eth.django.models import EthereumAddressV2Field as EthereumAddressDbField
from gnosis.eth.django.models import Keccak256Field as Keccak256DbField
from gnosis.eth.django.serializers import (
    EthereumAddressField,
    HexadecimalField,
    Sha3HashField,
)
from gnosis.safe import Safe
from gnosis.safe.safe_signature import SafeSignature, SafeSignatureType
from gnosis.safe.serializers import SafeMultisigTxSerializerV1

from safe_transaction_service.contracts.tx_decoder import (
    TxDecoderException,
    get_db_tx_decoder,
)
from safe_transaction_service.tokens.serializers import TokenInfoResponseSerializer
from safe_transaction_service.utils.serializers import get_safe_owners, get_safe_version

from .exceptions import NodeConnectionException
from .helpers import DelegateSignatureHelper
from .models import (
    EthereumTx,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    SafeContract,
    SafeContractDelegate,
    TransferDict,
)
from .services.safe_service import SafeCreationInfo

def get_data_decoded_from_data(data: bytes, address: Optional[ChecksumAddress] = None):
    tx_decoder = get_db_tx_decoder()
    try:
        return tx_decoder.get_data_decoded(data, address=address)
    except TxDecoderException:
        return None

class GnosisBaseModelSerializer(serializers.ModelSerializer):
    serializer_field_mapping = (
        serializers.ModelSerializer.serializer_field_mapping.copy()
    )
    serializer_field_mapping[EthereumAddressDbField] = serializers.CharField
    serializer_field_mapping[Keccak256DbField] = serializers.CharField

# ================================================ #
#            Request Serializers
# ================================================ #
class SafeMultisigConfirmationSerializer(serializers.Serializer):
    signature = HexadecimalField(min_length=65)  # Signatures must be at least 65 bytes

    def validate_signature(self, signature: bytes):
        safe_tx_hash = self.context["safe_tx_hash"]
        try:
            multisig_transaction = MultisigTransaction.objects.select_related(
                "ethereum_tx"
            ).get(safe_tx_hash=safe_tx_hash)
        except MultisigTransaction.DoesNotExist as exc:
            raise NotFound(
                f"Multisig transaction with safe-tx-hash={safe_tx_hash} was not found"
            ) from exc

        safe_address = multisig_transaction.safe
        if multisig_transaction.executed:
            raise ValidationError(
                f"Transaction with safe-tx-hash={safe_tx_hash} was already executed"
            )

        safe_owners = get_safe_owners(safe_address)
        parsed_signatures = SafeSignature.parse_signature(signature, safe_tx_hash)
        signature_owners = []
        ethereum_client = EthereumClientProvider()
        for safe_signature in parsed_signatures:
            owner = safe_signature.owner
            if owner not in safe_owners:
                raise ValidationError(
                    f"Signer={owner} is not an owner. Current owners={safe_owners}"
                )
            if not safe_signature.is_valid(ethereum_client, safe_address):
                raise ValidationError(
                    f"Signature={safe_signature.signature.hex()} for owner={owner} is not valid"
                )
            if owner in signature_owners:
                raise ValidationError(f"Signature for owner={owner} is duplicated")

            signature_owners.append(owner)
        return signature

    def save(self, **kwargs):
        safe_tx_hash = self.context["safe_tx_hash"]
        signature = self.validated_data["signature"]
        multisig_confirmations = []
        parsed_signatures = SafeSignature.parse_signature(signature, safe_tx_hash)
        for safe_signature in parsed_signatures:
            multisig_confirmation, _ = MultisigConfirmation.objects.get_or_create(
                multisig_transaction_hash=safe_tx_hash,
                owner=safe_signature.owner,
                defaults={
                    "multisig_transaction_id": safe_tx_hash,
                    "signature": safe_signature.export_signature(),
                    "signature_type": safe_signature.signature_type.value,
                },
            )
            multisig_confirmations.append(multisig_confirmation)

        if self.validated_data["signature"]:
            MultisigTransaction.objects.filter(safe_tx_hash=safe_tx_hash).update(
                trusted=True
            )
        return multisig_confirmations

class SafeMultisigTransactionSerializer(SafeMultisigTxSerializerV1):
    contract_transaction_hash = Sha3HashField()
    sender = EthereumAddressField()
    # TODO Make signature mandatory
    signature = HexadecimalField(
        allow_null=True, required=False, min_length=65
    )  # Signatures must be at least 65 bytes
    origin = serializers.CharField(max_length=200, allow_null=True, default=None)

    def validate_origin(self, origin):
        # Origin field on db is a JsonField
        if origin:
            try:
                origin = json.loads(origin)
            except ValueError:
                pass
        else:
            origin = {}

        return origin

    def validate(self, attrs):
        super().validate(attrs)

        ethereum_client = EthereumClientProvider()
        safe_address = attrs["safe"]
        safe_version = get_safe_version(safe_address)

        safe = Safe(safe_address, EthereumClientProvider())
        safe_tx = safe.build_multisig_tx(
            attrs["to"],
            attrs["value"],
            attrs["data"],
            attrs["operation"],
            attrs["safe_tx_gas"],
            attrs["base_gas"],
            attrs["gas_price"],
            attrs["gas_token"],
            attrs["refund_receiver"],
            safe_nonce=attrs["nonce"],
            safe_version=safe_version,
        )
        contract_transaction_hash = safe_tx.safe_tx_hash

        # Check safe tx hash matches
        if contract_transaction_hash != attrs["contract_transaction_hash"]:
            raise ValidationError(
                f"Contract-transaction-hash={contract_transaction_hash.hex()} "
                f'does not match provided contract-tx-hash={attrs["contract_transaction_hash"].hex()}'
            )

        # Check there's not duplicated tx with same `nonce` or same `safeTxHash` for the same Safe.
        # We allow duplicated if existing tx is not executed
        multisig_transactions = MultisigTransaction.objects.filter(
            safe=safe_address, nonce=attrs["nonce"]
        ).executed()
        if multisig_transactions:
            for multisig_transaction in multisig_transactions:
                if multisig_transaction.safe_tx_hash == contract_transaction_hash.hex():
                    raise ValidationError(
                        f"Tx with safe-tx-hash={contract_transaction_hash.hex()} "
                        f"for safe={safe_address} was already executed in "
                        f"tx-hash={multisig_transaction.ethereum_tx_id}"
                    )

            raise ValidationError(
                f"Tx with nonce={safe_tx.safe_nonce} for safe={safe_address} "
                f"already executed in tx-hash={multisig_transactions[0].ethereum_tx_id}"
            )

        safe_owners = get_safe_owners(safe_address)
        attrs["safe_owners"] = safe_owners

        delegates = SafeContractDelegate.objects.get_delegates_for_safe_and_owners(
            safe_address, safe_owners
        )
        allowed_senders = set(safe_owners) | delegates
        if not attrs["sender"] in allowed_senders:
            raise ValidationError(
                f'Sender={attrs["sender"]} is not an owner or delegate. '
                f"Current owners={safe_owners}. Delegates={delegates}"
            )

        signature_owners = []
        # TODO Make signature mandatory
        signature = attrs.get("signature", b"")
        parsed_signatures = SafeSignature.parse_signature(
            signature, contract_transaction_hash
        )
        attrs["parsed_signatures"] = parsed_signatures
        # If there's at least one signature, transaction is trusted (until signatures are mandatory)
        attrs["trusted"] = bool(parsed_signatures)
        for safe_signature in parsed_signatures:
            owner = safe_signature.owner
            if not safe_signature.is_valid(ethereum_client, safe_address):
                raise ValidationError(
                    f"Signature={safe_signature.signature.hex()} for owner={owner} is not valid"
                )

            if owner in delegates and len(parsed_signatures) > 1:
                raise ValidationError(
                    "Just one signature is expected if using delegates"
                )
            if owner not in allowed_senders:
                raise ValidationError(
                    f"Signer={owner} is not an owner or delegate. "
                    f"Current owners={safe_owners}. Delegates={delegates}"
                )
            if owner in signature_owners:
                raise ValidationError(f"Signature for owner={owner} is duplicated")

            signature_owners.append(owner)

        # TODO Make signature mandatory. len(signature_owners) must be >= 1
        if signature_owners and attrs["sender"] not in signature_owners:
            raise ValidationError(
                f'Signature does not match sender={attrs["sender"]}. '
                f"Calculated owners={signature_owners}"
            )

        return attrs

    def save(self, **kwargs):
        safe_tx_hash = self.validated_data["contract_transaction_hash"]
        origin = self.validated_data["origin"]
        trusted = self.validated_data["trusted"]
        if not trusted:
            # Check user permission
            if (
                self.context
                and (request := self.context.get("request"))
                and (user := request.user)
            ):
                trusted = user.has_perm("history.create_trusted")

        multisig_transaction, created = MultisigTransaction.objects.get_or_create(
            safe_tx_hash=safe_tx_hash,
            defaults={
                "safe": self.validated_data["safe"],
                "to": self.validated_data["to"],
                "value": self.validated_data["value"],
                "data": self.validated_data["data"]
                if self.validated_data["data"]
                else None,
                "operation": self.validated_data["operation"],
                "safe_tx_gas": self.validated_data["safe_tx_gas"],
                "base_gas": self.validated_data["base_gas"],
                "gas_price": self.validated_data["gas_price"],
                "gas_token": self.validated_data["gas_token"],
                "refund_receiver": self.validated_data["refund_receiver"],
                "nonce": self.validated_data["nonce"],
                "origin": origin,
                "trusted": trusted,
            },
        )

        if not created and trusted and not multisig_transaction.trusted:
            multisig_transaction.origin = origin
            multisig_transaction.trusted = trusted
            multisig_transaction.save(update_fields=["origin", "trusted"])

        for safe_signature in self.validated_data.get("parsed_signatures"):
            if safe_signature.owner in self.validated_data["safe_owners"]:
                MultisigConfirmation.objects.get_or_create(
                    multisig_transaction_hash=safe_tx_hash,
                    owner=safe_signature.owner,
                    defaults={
                        "multisig_transaction": multisig_transaction,
                        "signature": safe_signature.export_signature(),
                        "signature_type": safe_signature.signature_type.value,
                    },
                )
        return multisig_transaction

class SafeMultisigTransactionEstimateSerializer(serializers.Serializer):
    to = EthereumAddressField()
    value = serializers.IntegerField(min_value=0)
    data = HexadecimalField(default=None, allow_null=True, allow_blank=True)
    operation = serializers.IntegerField(min_value=0)

    def save(self, **kwargs):
        safe_address = self.context["safe_address"]
        ethereum_client = EthereumClientProvider()
        safe = Safe(safe_address, ethereum_client)
        exc = None
        # Retry thrice to get an estimation
        for _ in range(3):
            try:
                safe_tx_gas = safe.estimate_tx_gas(
                    self.validated_data["to"],
                    self.validated_data["value"],
                    self.validated_data["data"],
                    self.validated_data["operation"],
                )
                return {"safe_tx_gas": safe_tx_gas}
            except (IOError, ValueError) as _exc:
                exc = _exc
        raise NodeConnectionException(
            f"Node connection error when estimating gas for Safe {safe_address}"
        ) from exc

class DelegateSignatureCheckerMixin:
    """
    Mixin to include delegate signature validation
    """

    def check_delegate_signature(
        self,
        ethereum_client: EthereumClient,
        signature: bytes,
        operation_hash: bytes,
        delegator: ChecksumAddress,
    ) -> bool:
        """
        Checks signature and returns a valid owner if found, None otherwise

        :param ethereum_client:
        :param signature:
        :param operation_hash:
        :param delegator:
        :return: `True` if signature is valid for the delegator, `False` otherwise
        """
        safe_signatures = SafeSignature.parse_signature(signature, operation_hash)
        if not safe_signatures:
            raise ValidationError("Signature is not valid")

        if len(safe_signatures) > 1:
            raise ValidationError(
                "More than one signatures detected, just one is expected"
            )

        safe_signature = safe_signatures[0]
        owner = safe_signature.owner
        if owner == delegator:
            if not safe_signature.is_valid(ethereum_client, owner):
                raise ValidationError(
                    f"Signature of type={safe_signature.signature_type.name} "
                    f"for delegator={delegator} is not valid"
                )
            return True
        return False

class DelegateSerializer(DelegateSignatureCheckerMixin, serializers.Serializer):
    safe = EthereumAddressField(allow_null=True, required=False)
    delegate = EthereumAddressField()
    delegator = EthereumAddressField()
    signature = HexadecimalField(min_length=65)
    label = serializers.CharField(max_length=50)

    def validate(self, attrs):
        super().validate(attrs)

        safe_address: Optional[ChecksumAddress] = attrs.get("safe")
        if (
            safe_address
            and not SafeContract.objects.filter(address=safe_address).exists()
        ):
            raise ValidationError(
                f"Safe={safe_address} does not exist or it's still not indexed"
            )

        signature = attrs["signature"]
        delegate = attrs["delegate"]  # Delegate address to be added/removed
        delegator = attrs[
            "delegator"
        ]  # Delegator giving permissions to delegate (signer)

        ethereum_client = EthereumClientProvider()
        if safe_address:
            # Valid delegators must be owners
            valid_delegators = get_safe_owners(safe_address)
            if delegator not in valid_delegators:
                raise ValidationError(
                    f"Provided delegator={delegator} is not an owner of Safe={safe_address}"
                )

        # Tries to find a valid delegator using multiple strategies
        for operation_hash in DelegateSignatureHelper.calculate_all_possible_hashes(
            delegate
        ):
            if self.check_delegate_signature(
                ethereum_client, signature, operation_hash, delegator
            ):
                return attrs

        raise ValidationError(
            f"Signature does not match provided delegator={delegator}"
        )

    def save(self, **kwargs):
        safe_address = self.validated_data["safe"]
        delegate = self.validated_data["delegate"]
        delegator = self.validated_data["delegator"]
        label = self.validated_data["label"]
        obj, _ = SafeContractDelegate.objects.update_or_create(
            safe_contract_id=safe_address,
            delegate=delegate,
            delegator=delegator,
            defaults={
                "label": label,
            },
        )
        return obj

class DelegateDeleteSerializer(DelegateSignatureCheckerMixin, serializers.Serializer):
    delegate = EthereumAddressField()
    delegator = EthereumAddressField()
    signature = HexadecimalField(min_length=65)

    def validate(self, attrs):
        super().validate(attrs)

        signature = attrs["signature"]
        delegate = attrs["delegate"]  # Delegate address to be added/removed
        delegator = attrs["delegator"]  # Delegator

        ethereum_client = EthereumClientProvider()
        # Tries to find a valid delegator using multiple strategies
        for operation_hash in DelegateSignatureHelper.calculate_all_possible_hashes(
            delegate
        ):
            for signer in (delegate, delegator):
                if self.check_delegate_signature(
                    ethereum_client, signature, operation_hash, signer
                ):
                    return attrs

        raise ValidationError(
            f"Signature does not match provided delegate={delegate} or delegator={delegator}"
        )

class DataDecoderSerializer(serializers.Serializer):
    data = HexadecimalField(allow_null=False, allow_blank=False, min_length=4)
    to = EthereumAddressField(allow_null=True, required=False)

# ================================================ #
#            Response Serializers
# ================================================ #
class SafeModuleTransactionResponseSerializer(GnosisBaseModelSerializer):
    execution_date = serializers.DateTimeField()
    data = HexadecimalField(allow_null=True, allow_blank=True)
    data_decoded = serializers.SerializerMethodField()
    transaction_hash = serializers.SerializerMethodField()
    block_number = serializers.SerializerMethodField()
    is_successful = serializers.SerializerMethodField()

    class Meta:
        model = ModuleTransaction
        fields = (
            "created",
            "execution_date",
            "block_number",
            "is_successful",
            "transaction_hash",
            "safe",
            "module",
            "to",
            "value",
            "data",
            "operation",
            "data_decoded",
        )

    def get_block_number(self, obj: ModuleTransaction) -> Optional[int]:
        return obj.internal_tx.block_number

    def get_data_decoded(self, obj: ModuleTransaction) -> Dict[str, Any]:
        return get_data_decoded_from_data(
            obj.data.tobytes() if obj.data else b"", address=obj.to
        )

    def get_is_successful(self, obj: ModuleTransaction) -> bool:
        return not obj.failed

    def get_transaction_hash(self, obj: ModuleTransaction) -> str:
        return obj.internal_tx.ethereum_tx_id

class SafeMultisigConfirmationResponseSerializer(GnosisBaseModelSerializer):
    submission_date = serializers.DateTimeField(source="created")
    transaction_hash = serializers.SerializerMethodField()
    signature = HexadecimalField()
    signature_type = serializers.SerializerMethodField()

    class Meta:
        model = MultisigConfirmation
        fields = (
            "owner",
            "submission_date",
            "transaction_hash",
            "signature",
            "signature_type",
        )

    def get_transaction_hash(self, obj: MultisigConfirmation) -> str:
        return obj.ethereum_tx_id

    def get_signature_type(self, obj: MultisigConfirmation) -> str:
        return SafeSignatureType(obj.signature_type).name

class SafeMultisigTransactionResponseSerializer(SafeMultisigTxSerializerV1):
    execution_date = serializers.DateTimeField()
    submission_date = serializers.DateTimeField(
        source="created"
    )  # First seen by this service
    modified = serializers.DateTimeField()
    block_number = serializers.SerializerMethodField()
    transaction_hash = Sha3HashField(source="ethereum_tx_id")
    safe_tx_hash = Sha3HashField()
    executor = serializers.SerializerMethodField()
    value = serializers.CharField()
    is_executed = serializers.BooleanField(source="executed")
    is_successful = serializers.SerializerMethodField()
    gas_price = serializers.CharField()
    eth_gas_price = serializers.SerializerMethodField()
    max_fee_per_gas = serializers.SerializerMethodField()
    max_priority_fee_per_gas = serializers.SerializerMethodField()
    gas_used = serializers.SerializerMethodField()
    fee = serializers.SerializerMethodField()
    origin = serializers.CharField()
    data_decoded = serializers.SerializerMethodField()
    confirmations_required = serializers.IntegerField()
    confirmations = serializers.SerializerMethodField()
    trusted = serializers.BooleanField()
    signatures = HexadecimalField(allow_null=True, required=False)

    def get_block_number(self, obj: MultisigTransaction) -> Optional[int]:
        if obj.ethereum_tx_id:
            return obj.ethereum_tx.block_id

    @swagger_serializer_method(
        serializer_or_field=SafeMultisigConfirmationResponseSerializer
    )
    def get_confirmations(self, obj: MultisigTransaction) -> Dict[str, Any]:
        """
        Filters confirmations queryset
        :param obj: MultisigConfirmation instance
        :return: Serialized queryset
        """
        return SafeMultisigConfirmationResponseSerializer(
            obj.confirmations, many=True
        ).data

    def get_executor(self, obj: MultisigTransaction) -> Optional[str]:
        if obj.ethereum_tx_id:
            return obj.ethereum_tx._from

    def get_fee(self, obj: MultisigTransaction) -> Optional[int]:
        if obj.ethereum_tx:
            if obj.ethereum_tx.gas_used and obj.ethereum_tx.gas_price:
                return str(obj.ethereum_tx.gas_used * obj.ethereum_tx.gas_price)

    def get_eth_gas_price(self, obj: MultisigTransaction) -> Optional[str]:
        if obj.ethereum_tx and obj.ethereum_tx.gas_price:
            return str(obj.ethereum_tx.gas_price)

    def get_max_fee_per_gas(self, obj: MultisigTransaction) -> Optional[str]:
        if obj.ethereum_tx and obj.ethereum_tx.max_fee_per_gas:
            return str(obj.ethereum_tx.max_fee_per_gas)

    def get_max_priority_fee_per_gas(self, obj: MultisigTransaction) -> Optional[str]:
        if obj.ethereum_tx and obj.ethereum_tx.max_priority_fee_per_gas:
            return str(obj.ethereum_tx.max_priority_fee_per_gas)

    def get_gas_used(self, obj: MultisigTransaction) -> Optional[int]:
        if obj.ethereum_tx and obj.ethereum_tx.gas_used:
            return obj.ethereum_tx.gas_used

    def get_is_successful(self, obj: MultisigTransaction) -> Optional[bool]:
        return None if obj.failed is None else not obj.failed

    def get_data_decoded(self, obj: MultisigTransaction) -> Dict[str, Any]:
        # If delegate call contract must be whitelisted (security)
        if obj.data_should_be_decoded():
            return get_data_decoded_from_data(
                obj.data.tobytes() if obj.data else b"", address=obj.to
            )

class IndexingStatusSerializer(serializers.Serializer):
    current_block_number = serializers.IntegerField()
    erc20_block_number = serializers.IntegerField()
    erc20_synced = serializers.BooleanField()
    master_copies_block_number = serializers.IntegerField()
    master_copies_synced = serializers.BooleanField()
    synced = serializers.BooleanField()

class ERC20IndexingStatusSerializer(serializers.Serializer):
    current_block_number = serializers.IntegerField()
    erc20_block_number = serializers.IntegerField()
    erc20_synced = serializers.BooleanField()

class Erc20InfoSerializer(serializers.Serializer):
    name = serializers.CharField()
    symbol = serializers.CharField()
    decimals = serializers.IntegerField()
    logo_uri = serializers.CharField()

class SafeBalanceResponseSerializer(serializers.Serializer):
    token_address = serializers.CharField()
    token = Erc20InfoSerializer()
    balance = serializers.CharField()

class SafeBalanceUsdResponseSerializer(SafeBalanceResponseSerializer):
    eth_value = serializers.CharField()
    timestamp = serializers.DateTimeField()
    fiat_balance = serializers.CharField()
    fiat_conversion = serializers.CharField()
    fiat_code = serializers.CharField()

class SafeCollectibleResponseSerializer(serializers.Serializer):
    address = serializers.CharField()
    token_name = serializers.CharField()
    token_symbol = serializers.CharField()
    logo_uri = serializers.CharField()
    id = serializers.CharField()
    uri = serializers.CharField()
    name = serializers.CharField()
    description = serializers.CharField()
    image_uri = serializers.CharField()
    metadata = serializers.DictField()

class SafeMultisigTransactionEstimateResponseSerializer(serializers.Serializer):
    safe_tx_gas = serializers.CharField()

class SafeDelegateResponseSerializer(serializers.Serializer):
    safe = EthereumAddressField(source="safe_contract_id")
    delegate = EthereumAddressField()
    delegator = EthereumAddressField()
    label = serializers.CharField(max_length=50)

class SafeCreationInfoResponseSerializer(serializers.Serializer):
    created = serializers.DateTimeField()
    creator = EthereumAddressField()
    transaction_hash = Sha3HashField()
    factory_address = EthereumAddressField()
    master_copy = EthereumAddressField(allow_null=True)
    setup_data = HexadecimalField(allow_null=True)
    data_decoded = serializers.SerializerMethodField()

    def get_data_decoded(self, obj: SafeCreationInfo) -> Dict[str, Any]:
        return get_data_decoded_from_data(obj.setup_data or b"")

class SafeInfoResponseSerializer(serializers.Serializer):
    address = EthereumAddressField()
    nonce = serializers.IntegerField()
    threshold = serializers.IntegerField()
    owners = serializers.ListField(child=EthereumAddressField())
    master_copy = EthereumAddressField()
    modules = serializers.ListField(child=EthereumAddressField())
    fallback_handler = EthereumAddressField()
    guard = EthereumAddressField()
    version = serializers.CharField(allow_null=True)

class MasterCopyResponseSerializer(serializers.Serializer):
    address = EthereumAddressField()
    version = serializers.CharField()
    deployer = serializers.CharField()
    deployed_block_number = serializers.IntegerField(source="initial_block_number")
    last_indexed_block_number = serializers.IntegerField(source="tx_block_number")
    l2 = serializers.BooleanField()

class ModulesResponseSerializer(serializers.Serializer):
    safes = serializers.ListField(child=EthereumAddressField())

class OwnerResponseSerializer(serializers.Serializer):
    safes = serializers.ListField(child=EthereumAddressField())

class TransferType(Enum):
    ETHER_TRANSFER = 0
    ERC20_TRANSFER = 1
    ERC721_TRANSFER = 2
    UNKNOWN = 3

class TransferResponseSerializer(serializers.Serializer):
    type = serializers.SerializerMethodField()
    execution_date = serializers.DateTimeField()
    block_number = serializers.IntegerField(source="block")
    transaction_hash = Sha3HashField()
    to = EthereumAddressField()
    from_ = EthereumAddressField(source="_from", allow_zero_address=True)
    value = serializers.CharField(allow_null=True, source="_value")
    token_id = serializers.CharField(allow_null=True, source="_token_id")
    token_address = EthereumAddressField(allow_null=True, default=None)

    def get_fields(self):
        result = super().get_fields()
        # Rename `from_` to `from`
        from_ = result.pop("from_")
        result["from"] = from_
        return result

    def get_type(self, obj: TransferDict) -> str:
        if obj["token_address"] is None:
            return TransferType.ETHER_TRANSFER.name
        else:
            if obj["_value"] is not None:
                return TransferType.ERC20_TRANSFER.name
            if obj["_token_id"] is not None:
                return TransferType.ERC721_TRANSFER.name
            return TransferType.UNKNOWN.name

    def validate(self, attrs):
        super().validate(attrs)
        if attrs["value"] is None and attrs["token_id"] is None:
            raise ValidationError("Both value and token_id cannot be null")
        return attrs

class TransferWithTokenInfoResponseSerializer(TransferResponseSerializer):
    token_info = TokenInfoResponseSerializer(source="token")

    def get_type(self, obj: TransferDict) -> str:
        """
        Sometimes ERC20/721 `Transfer` events look the same, if token info is available better use that information
        to check

        :param obj:
        :return: `TransferType` as a string
        """
        transfer_type = super().get_type(obj)
        if transfer_type in (
            TransferType.ERC20_TRANSFER.name,
            TransferType.ERC721_TRANSFER.name,
        ):
            if token := obj["token"]:
                decimals = (
                    token["decimals"] if isinstance(token, dict) else token.decimals
                )
                if decimals is None:
                    transfer_type = TransferType.ERC721_TRANSFER.name
                    if obj["_token_id"] is None:
                        obj["_token_id"], obj["_value"] = (
                            obj["_value"],
                            obj["_token_id"],
                        )
                else:
                    transfer_type = TransferType.ERC20_TRANSFER.name
                    if obj["_value"] is None:
                        obj["_token_id"], obj["_value"] = (
                            obj["_value"],
                            obj["_token_id"],
                        )
        return transfer_type

# All txs serializers
class TxType(Enum):
    ETHEREUM_TRANSACTION = 0
    MULTISIG_TRANSACTION = 1
    MODULE_TRANSACTION = 2

class SafeModuleTransactionWithTransfersResponseSerializer(
    SafeModuleTransactionResponseSerializer
):
    class Meta:
        model = SafeModuleTransactionResponseSerializer.Meta.model
        fields = SafeModuleTransactionResponseSerializer.Meta.fields + (
            "transfers",
            "tx_type",
        )

    transfers = TransferWithTokenInfoResponseSerializer(many=True)
    tx_type = serializers.SerializerMethodField()

    def get_tx_type(self, obj):
        return TxType.MODULE_TRANSACTION.name

class SafeMultisigTransactionWithTransfersResponseSerializer(
    SafeMultisigTransactionResponseSerializer
):
    transfers = TransferWithTokenInfoResponseSerializer(many=True)
    tx_type = serializers.SerializerMethodField()

    def get_tx_type(self, obj):
        return TxType.MULTISIG_TRANSACTION.name

class EthereumTxWithTransfersResponseSerializer(serializers.Serializer):
    class Meta:
        model = EthereumTx
        exclude = ("block",)

    execution_date = serializers.DateTimeField()
    _from = EthereumAddressField(
        allow_null=False, allow_zero_address=True, source="_from"
    )
    to = EthereumAddressField(allow_null=True, allow_zero_address=True)
    data = HexadecimalField()
    tx_hash = HexadecimalField()
    block_number = serializers.SerializerMethodField()
    transfers = TransferWithTokenInfoResponseSerializer(many=True)
    tx_type = serializers.SerializerMethodField()

    def get_tx_type(self, obj) -> str:
        return TxType.ETHEREUM_TRANSACTION.name

    def get_fields(self):
        result = super().get_fields()
        # Rename `_from` to `from`
        _from = result.pop("_from")
        result["from"] = _from
        return result

    def get_block_number(self, obj: EthereumTx) -> Optional[int]:
        if obj.block_id:
            return obj.block_id

class AllTransactionsSchemaSerializer(serializers.Serializer):
    """
    Just for the purpose of documenting, don't use it
    """

    tx_type_1 = SafeModuleTransactionWithTransfersResponseSerializer()
    tx_type_2 = SafeMultisigTransactionWithTransfersResponseSerializer()
    tx_type_3 = EthereumTxWithTransfersResponseSerializer()

# Deprecated ---------------------------------------------------------------

class SafeDelegateDeleteSerializer(serializers.Serializer):
    """
    Deprecated in favour of DelegateDeleteSerializer
    """

    safe = EthereumAddressField()
    delegate = EthereumAddressField()
    signature = HexadecimalField(min_length=65)

    def get_valid_delegators(
        self,
        ethereum_client: EthereumClient,
        safe_address: ChecksumAddress,
        delegate: ChecksumAddress,
    ) -> List[ChecksumAddress]:
        """
        :param ethereum_client:
        :param safe_address:
        :param delegate:
        :return: Valid delegators for a Safe. A delegate should be able to remove itself
        """
        return get_safe_owners(safe_address) + [delegate]

    def check_signature(
        self,
        ethereum_client: EthereumClient,
        safe_address: ChecksumAddress,
        signature: bytes,
        operation_hash: bytes,
        valid_delegators: List[ChecksumAddress],
    ) -> Optional[ChecksumAddress]:
        """
        Checks signature and returns a valid owner if found, None otherwise

        :param ethereum_client:
        :param safe_address:
        :param signature:
        :param operation_hash:
        :param valid_delegators:
        :return: Valid delegator address if found, None otherwise
        """
        safe_signatures = SafeSignature.parse_signature(signature, operation_hash)
        if not safe_signatures:
            raise ValidationError("Signature is not valid")

        if len(safe_signatures) > 1:
            raise ValidationError(
                "More than one signatures detected, just one is expected"
            )

        safe_signature = safe_signatures[0]
        delegator = safe_signature.owner
        if delegator in valid_delegators:
            if not safe_signature.is_valid(ethereum_client, safe_address):
                raise ValidationError(
                    f"Signature of type={safe_signature.signature_type.name} "
                    f"for delegator={delegator} is not valid"
                )
            return delegator

    def validate(self, attrs):
        super().validate(attrs)

        safe_address = attrs["safe"]
        if not SafeContract.objects.filter(address=safe_address).exists():
            raise ValidationError(
                f"Safe={safe_address} does not exist or it's still not indexed"
            )

        signature = attrs["signature"]
        delegate = attrs["delegate"]  # Delegate address to be added/removed

        ethereum_client = EthereumClientProvider()
        valid_delegators = self.get_valid_delegators(
            ethereum_client, safe_address, delegate
        )

        # Tries to find a valid delegator using multiple strategies
        for operation_hash in DelegateSignatureHelper.calculate_all_possible_hashes(
            delegate
        ):
            delegator = self.check_signature(
                ethereum_client,
                safe_address,
                signature,
                operation_hash,
                valid_delegators,
            )
            if delegator:
                break

        if not delegator:
            raise ValidationError("Signing owner is not an owner of the Safe")

        attrs["delegator"] = delegator
        return attrs

class SafeDelegateSerializer(SafeDelegateDeleteSerializer):
    """
    Deprecated in favour of DelegateSerializer
    """

    label = serializers.CharField(max_length=50)

    def get_valid_delegators(
        self,
        ethereum_client: EthereumClient,
        safe_address: ChecksumAddress,
        delegate: ChecksumAddress,
    ) -> List[ChecksumAddress]:
        """
        :param ethereum_client:
        :param safe_address:
        :param delegate:
        :return: Valid delegators for a Safe. A delegate shouldn't be able to add itself
        """
        return get_safe_owners(safe_address)

    def save(self, **kwargs):
        safe_address = self.validated_data["safe"]
        delegate = self.validated_data["delegate"]
        delegator = self.validated_data["delegator"]
        label = self.validated_data["label"]
        obj, _ = SafeContractDelegate.objects.update_or_create(
            safe_contract_id=safe_address,
            delegate=delegate,
            defaults={
                "label": label,
                "delegator": delegator,
            },
        )
        return obj

'''
'''--- safe_transaction_service/history/services/__init__.py ---
# flake8: noqa F401
from .balance_service import BalanceService, BalanceServiceProvider
from .collectibles_service import CollectiblesService, CollectiblesServiceProvider
from .index_service import IndexingException, IndexService, IndexServiceProvider
from .reorg_service import ReorgService, ReorgServiceProvider
from .safe_service import SafeService, SafeServiceProvider
from .transaction_service import TransactionService, TransactionServiceProvider

'''
'''--- safe_transaction_service/history/services/balance_service.py ---
import logging
import operator
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional, Sequence

from django.core.cache import cache as django_cache
from django.db.models import Q

from cache_memoize import cache_memoize
from cachetools import TTLCache, cachedmethod
from eth_typing import ChecksumAddress
from redis import Redis

from gnosis.eth import EthereumClient, EthereumClientProvider
from gnosis.eth.utils import fast_is_checksum_address

from safe_transaction_service.tokens.clients import CannotGetPrice
from safe_transaction_service.tokens.models import Token
from safe_transaction_service.tokens.services.price_service import (
    FiatCode,
    PriceService,
    PriceServiceProvider,
)
from safe_transaction_service.utils.redis import get_redis

from ..exceptions import NodeConnectionException
from ..models import ERC20Transfer, InternalTx, MultisigTransaction

logger = logging.getLogger(__name__)

class BalanceServiceException(Exception):
    pass

@dataclass
class Erc20InfoWithLogo:
    address: ChecksumAddress
    name: str
    symbol: str
    decimals: int
    copy_price: Optional[ChecksumAddress]
    logo_uri: str

    @classmethod
    def from_token(cls, token: Token):
        return cls(
            token.address,
            token.name,
            token.symbol,
            token.decimals,
            token.copy_price,
            token.get_full_logo_uri(),
        )

@dataclass
class Balance:
    token_address: Optional[ChecksumAddress]  # For ether, `token_address` is `None`
    token: Optional[Erc20InfoWithLogo]
    balance: int

    def get_price_address(self) -> ChecksumAddress:
        """
        :return: Address to use to retrieve the token price
        """
        if self.token and self.token.copy_price:
            return self.token.copy_price
        return self.token_address

@dataclass
class BalanceWithFiat(Balance):
    eth_value: float  # Value in ether
    timestamp: datetime  # Calculated timestamp
    fiat_balance: float
    fiat_conversion: float
    fiat_code: str = FiatCode.USD.name

class BalanceServiceProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = BalanceService(
                EthereumClientProvider(), PriceServiceProvider(), get_redis()
            )
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class BalanceService:
    def __init__(
        self, ethereum_client: EthereumClient, price_service: PriceService, redis: Redis
    ):
        self.ethereum_client = ethereum_client
        self.ethereum_network = self.ethereum_client.get_network()
        self.price_service = price_service
        self.redis = redis
        self.cache_token_info = TTLCache(
            maxsize=4096, ttl=60 * 30
        )  # 2 hours of caching

    def _filter_addresses(
        self,
        erc20_addresses: Sequence[ChecksumAddress],
        only_trusted: bool,
        exclude_spam: bool,
    ) -> List[ChecksumAddress]:
        """
        :param erc20_addresses:
        :param only_trusted:
        :param exclude_spam:
        :return: ERC20 tokens filtered by spam or trusted
        """
        base_queryset = Token.objects.filter(
            Q(address__in=erc20_addresses) | Q(events_bugged=True)
        ).order_by("name")
        if only_trusted:
            addresses = list(
                base_queryset.erc20()
                .filter(trusted=True)
                .values_list("address", flat=True)
            )
        elif exclude_spam:
            addresses = list(
                base_queryset.erc20()
                .filter(spam=False)
                .values_list("address", flat=True)
            )
        else:
            # There could be some addresses that are not in the list
            addresses_set = set(erc20_addresses)
            addresses = []
            for token in base_queryset:
                if token.is_erc20():
                    addresses.append(token.address)
                if (
                    token.address in addresses_set
                ):  # events_bugged tokens might not be on the `addresses_set`
                    addresses_set.remove(token.address)
            # Add unknown addresses
            addresses.extend(addresses_set)

        return addresses

    def get_balances(
        self,
        safe_address: ChecksumAddress,
        only_trusted: bool = False,
        exclude_spam: bool = False,
    ):
        """
        :param safe_address:
        :param only_trusted: If True, return balance only for trusted tokens
        :param exclude_spam: If True, exclude spam tokens
        :return: `{'token_address': str, 'balance': int}`. For ether, `token_address` is `None`. Elements are cached
        for one hour
        """

        # Cache based on the number of erc20 events and the ether transferred, and also check outgoing ether
        # transactions that will not emit events on non L2 networks
        events_sending_eth = (
            MultisigTransaction.objects.ether_transfers()
            .executed()
            .filter(safe=safe_address)
            .count()
        )
        number_erc20_events = ERC20Transfer.objects.to_or_from(safe_address).count()
        number_eth_events = InternalTx.objects.ether_txs_for_address(
            safe_address
        ).count()
        cache_key = (
            f"balances:{safe_address}:{only_trusted}:{exclude_spam}:"
            f"{number_erc20_events}:{number_eth_events}:{events_sending_eth}"
        )
        if balances := django_cache.get(cache_key):
            return balances
        else:
            balances = self._get_balances(safe_address, only_trusted, exclude_spam)
            django_cache.set(cache_key, balances, 60 * 10)  # 10 minutes cache
            return balances

    def _get_balances(
        self,
        safe_address: ChecksumAddress,
        only_trusted: bool = False,
        exclude_spam: bool = False,
    ) -> List[Balance]:
        """
        :param safe_address:
        :param only_trusted: If True, return balance only for trusted tokens
        :param exclude_spam: If True, exclude spam tokens
        :return: `{'token_address': str, 'balance': int}`. For ether, `token_address` is `None`
        """
        assert fast_is_checksum_address(
            safe_address
        ), f"Not valid address {safe_address} for getting balances"

        all_erc20_addresses = ERC20Transfer.objects.tokens_used_by_address(safe_address)
        for address in all_erc20_addresses:
            # Store tokens in database if not present
            self.get_token_info(address)  # This is cached
        erc20_addresses = self._filter_addresses(
            all_erc20_addresses, only_trusted, exclude_spam
        )

        try:
            raw_balances = self.ethereum_client.erc20.get_balances(
                safe_address, erc20_addresses
            )
        except (IOError, ValueError) as exc:
            raise NodeConnectionException from exc

        balances = []
        for balance in raw_balances:
            if not balance["token_address"]:  # Ether
                balance["token"] = None
            elif balance["balance"] > 0:
                balance["token"] = self.get_token_info(balance["token_address"])
                if not balance["token"]:  # Ignore ERC20 tokens that cannot be queried
                    continue
            else:
                continue
            balances.append(Balance(**balance))
        return balances

    @cachedmethod(cache=operator.attrgetter("cache_token_info"))
    @cache_memoize(60 * 60, prefix="balances-get_token_info")  # 1 hour
    def get_token_info(
        self, token_address: ChecksumAddress
    ) -> Optional[Erc20InfoWithLogo]:
        try:
            token = Token.objects.get(address=token_address)
            return Erc20InfoWithLogo.from_token(token)
        except Token.DoesNotExist:
            if token := Token.objects.create_from_blockchain(token_address):
                return Erc20InfoWithLogo.from_token(token)
            else:
                logger.warning(
                    "Cannot get erc20 token info for token-address=%s", token_address
                )
                return None

    def get_usd_balances(
        self,
        safe_address: ChecksumAddress,
        only_trusted: bool = False,
        exclude_spam: bool = False,
    ) -> List[BalanceWithFiat]:
        """
        All this could be more optimal (e.g. batching requests), but as everything is cached
        I think we should be alright

        :param safe_address:
        :param only_trusted: If True, return balance only for trusted tokens
        :param exclude_spam: If True, exclude spam tokens
        :return: List of BalanceWithFiat
        """
        # TODO Use price service get_cached_usd_values
        balances: List[Balance] = self.get_balances(
            safe_address, only_trusted, exclude_spam
        )
        try:
            eth_price = self.price_service.get_native_coin_usd_price()
        except CannotGetPrice:
            logger.warning("Cannot get network ether price", exc_info=True)
            eth_price = 0
        balances_with_usd = []
        price_token_addresses = [balance.get_price_address() for balance in balances]
        token_eth_values_with_timestamp = (
            self.price_service.get_cached_token_eth_values(price_token_addresses)
        )
        for balance, token_eth_value_with_timestamp in zip(
            balances, token_eth_values_with_timestamp
        ):
            token_eth_value = token_eth_value_with_timestamp.eth_value
            token_address = balance.token_address
            if not token_address:  # Ether
                fiat_conversion = eth_price
                fiat_balance = fiat_conversion * (balance.balance / 10**18)
            else:
                fiat_conversion = eth_price * token_eth_value
                balance_with_decimals = balance.balance / 10**balance.token.decimals
                fiat_balance = fiat_conversion * balance_with_decimals

            balances_with_usd.append(
                BalanceWithFiat(
                    balance.token_address,
                    balance.token,
                    balance.balance,
                    token_eth_value,
                    token_eth_value_with_timestamp.timestamp,
                    round(fiat_balance, 4),
                    round(fiat_conversion, 4),
                    FiatCode.USD.name,
                )
            )

        return balances_with_usd

'''
'''--- safe_transaction_service/history/services/collectibles_service.py ---
import dataclasses
import json
import logging
import operator
import random
from typing import Any, Dict, List, Optional, Sequence, Tuple
from urllib.parse import urljoin

from django.conf import settings
from django.core.cache import cache as django_cache

import gevent
import requests
from cache_memoize import cache_memoize
from cachetools import TTLCache, cachedmethod
from eth_typing import ChecksumAddress
from redis import Redis

from gnosis.eth import EthereumClient, EthereumClientProvider

from safe_transaction_service.tokens.constants import (
    CRYPTO_KITTIES_CONTRACT_ADDRESSES,
    ENS_CONTRACTS_WITH_TLD,
)
from safe_transaction_service.tokens.models import Token
from safe_transaction_service.utils.redis import get_redis
from safe_transaction_service.utils.utils import chunks

from ..clients import EnsClient
from ..exceptions import NodeConnectionException
from ..models import ERC721Transfer

logger = logging.getLogger(__name__)

class CollectiblesServiceException(Exception):
    pass

class MetadataRetrievalException(CollectiblesServiceException):
    pass

class MetadataRetrievalExceptionTimeout(CollectiblesServiceException):
    pass

def ipfs_to_http(uri: Optional[str]) -> Optional[str]:
    if uri and uri.startswith("ipfs://"):
        uri = uri.replace("ipfs://ipfs/", "ipfs://")
        return urljoin(
            settings.IPFS_GATEWAY, uri.replace("ipfs://", "", 1)
        )  # Use ipfs gateway
    return uri

@dataclasses.dataclass
class Erc721InfoWithLogo:
    """
    ERC721 info from Blockchain
    """

    address: str
    name: str
    symbol: str
    logo_uri: str

    @classmethod
    def from_token(cls, token: Token):
        return cls(
            token.address,
            token.name,
            token.symbol,
            token.get_full_logo_uri(),
        )

@dataclasses.dataclass
class Collectible:
    """
    Collectible built from ERC721InfoWithLogo
    """

    token_name: str
    token_symbol: str
    logo_uri: str
    address: str
    id: int
    uri: str

@dataclasses.dataclass
class CollectibleWithMetadata(Collectible):
    """
    Collectible with metadata parsed if possible
    """

    metadata: Dict[str, Any]
    name: Optional[str] = dataclasses.field(init=False)
    description: Optional[str] = dataclasses.field(init=False)
    image_uri: Optional[str] = dataclasses.field(init=False)

    def get_name(self) -> Optional[str]:
        if self.metadata:
            for key in ("name",):
                if key in self.metadata:
                    return self.metadata[key]

    def get_description(self) -> Optional[str]:
        if self.metadata:
            for key in ("description",):
                if key in self.metadata:
                    return self.metadata[key]

    def get_metadata_image(self) -> Optional[str]:
        if not self.metadata:
            return None

        for key in ("image", "image_url", "image_uri", "imageUri", "imageUrl"):
            if key in self.metadata:
                return self.metadata[key]

        for key, value in self.metadata.items():
            if (
                key.lower().startswith("image")
                and isinstance(value, str)
                and value.startswith("http")
            ):
                return value

    def __post_init__(self):
        self.name = self.get_name()
        self.description = self.get_description()
        self.image_uri = ipfs_to_http(self.get_metadata_image())

class CollectiblesServiceProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = CollectiblesService(EthereumClientProvider(), get_redis())

        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class CollectiblesService:
    METADATA_MAX_CONTENT_LENGTH = int(
        0.2 * 1024 * 1024
    )  # 0.2Mb is the maximum metadata size allowed
    COLLECTIBLE_EXPIRATION = int(
        60 * 60 * 24 * 2
    )  # Keep collectibles by 2 days in cache
    TOKEN_EXPIRATION = int(60 * 60)

    def __init__(self, ethereum_client: EthereumClient, redis: Redis):
        self.ethereum_client = ethereum_client
        self.ethereum_network = ethereum_client.get_network()
        self.redis = redis
        self.ens_service: EnsClient = EnsClient(self.ethereum_network.value)

        self.cache_token_info: TTLCache[ChecksumAddress, Erc721InfoWithLogo] = TTLCache(
            maxsize=4096, ttl=self.TOKEN_EXPIRATION
        )
        self.ens_image_url = settings.TOKENS_ENS_IMAGE_URL

    def get_metadata_cache_key(self, address: str, token_id: int):
        return f"metadata:{address}:{token_id}"

    def _retrieve_metadata_from_uri(self, uri: str) -> Any:
        """
        Get metadata from URI. Currently just ipfs/http/https is supported

        :param uri: Metadata URI, like http://example.org/token/3 or ipfs://<keccak256>
        :return: Metadata as a decoded json
        """

        uri = ipfs_to_http(uri)

        if not uri or not uri.startswith("http"):
            raise MetadataRetrievalException(uri)

        try:
            logger.debug("Getting metadata for uri=%s", uri)
            with requests.get(uri, timeout=15, stream=True) as response:
                if not response.ok:
                    logger.debug("Cannot get metadata for uri=%s", uri)
                    raise MetadataRetrievalException(uri)

                content_length = response.headers.get("content-length", 0)
                content_type = response.headers.get("content-type", "")
                if int(content_length) > self.METADATA_MAX_CONTENT_LENGTH:
                    raise MetadataRetrievalException(
                        f"Content-length={content_length} for uri={uri} is too big"
                    )

                if "application/json" not in content_type:
                    raise MetadataRetrievalException(
                        f"Content-type={content_type} for uri={uri} is not valid, "
                        f'expected "application/json"'
                    )

                logger.debug("Got metadata for uri=%s", uri)

                # Some requests don't provide `Content-Length` on the headers
                if len(response.content) > self.METADATA_MAX_CONTENT_LENGTH:
                    raise MetadataRetrievalException(
                        f"Retrieved content for uri={uri} is too big"
                    )

                return response.json()
        except (IOError, ValueError) as e:
            raise MetadataRetrievalExceptionTimeout(uri) from e

    def build_collectible(
        self,
        token_info: Optional[Erc721InfoWithLogo],
        token_address: ChecksumAddress,
        token_id: int,
        token_metadata_uri: Optional[str],
    ) -> Collectible:
        """
        Build a collectible from the input parameters
        :param token_info: information of collectible like name, symbol...
        :param token_address:
        :param token_id:
        :param token_metadata_uri:
        """
        if not token_metadata_uri:
            if token_address in CRYPTO_KITTIES_CONTRACT_ADDRESSES:
                token_metadata_uri = f"https://api.cryptokitties.co/kitties/{token_id}"
            else:
                logger.info(
                    "Not available token_uri to retrieve metadata for ERC721 token=%s with token-id=%d",
                    token_address,
                    token_id,
                )
        name = token_info.name if token_info else ""
        symbol = token_info.symbol if token_info else ""
        logo_uri = token_info.logo_uri if token_info else ""
        return Collectible(
            name, symbol, logo_uri, token_address, token_id, token_metadata_uri
        )

    def get_metadata(self, collectible: Collectible | CollectibleWithMetadata) -> Any:
        """
        Return metadata for a collectible
        :param collectible
        """
        if tld := ENS_CONTRACTS_WITH_TLD.get(
            collectible.address
        ):  # Special case for ENS
            label_name = self.ens_service.query_by_domain_hash(collectible.id)
            return {
                "name": f"{label_name}.{tld}" if label_name else f".{tld}",
                "description": ("" if label_name else "Unknown ")
                + f".{tld} ENS Domain",
                "image": self.ens_image_url,
            }

        return self._retrieve_metadata_from_uri(collectible.uri)

    def get_collectibles(
        self,
        safe_address: ChecksumAddress,
        only_trusted: bool = False,
        exclude_spam: bool = False,
        limit: Optional[int] = None,
        offset: int = 0,
    ) -> Tuple[List[Collectible], int]:
        """
        :param safe_address:
        :param only_trusted: If True, return balance only for trusted tokens
        :param exclude_spam: If True, exclude spam tokens
        :param limit: page size
        :param offset: page position
        :return: Collectibles (using the owner, addresses and the token_ids) and count (total of collectibles)
        """

        # Cache based on the number of erc721 events
        number_erc721_events = ERC721Transfer.objects.to_or_from(safe_address).count()

        if number_erc721_events == 0:
            # No need for further DB/Cache calls
            return [], 0

        cache_key = f"collectibles:{safe_address}:{only_trusted}:{exclude_spam}:{limit}{offset}:{number_erc721_events}"
        cache_key_count = (
            f"collectibles_count:{safe_address}:{only_trusted}:{exclude_spam}"
        )
        if collectibles := django_cache.get(cache_key):
            count = django_cache.get(cache_key_count)
            return collectibles, count
        else:
            collectibles, count = self._get_collectibles(
                safe_address,
                only_trusted,
                exclude_spam,
                limit=limit,
                offset=offset,
            )
            django_cache.set(cache_key, collectibles, 60 * 10)  # 10 minutes cache
            django_cache.set(cache_key_count, count, 60 * 10)  # 10 minutes cache
            return collectibles, count

    def _get_collectibles(
        self,
        safe_address: ChecksumAddress,
        only_trusted: bool = False,
        exclude_spam: bool = False,
        limit: Optional[int] = None,
        offset: int = 0,
    ) -> Tuple[List[Collectible], int]:
        """
        :param safe_address:
        :param only_trusted: If True, return balance only for trusted tokens
        :param exclude_spam: If True, exclude spam tokens
        :param limit: page size
        :param offset: page position
        :return: Collectibles (using the owner, addresses and the token_ids) and count (total of collectibles)
        """
        addresses_with_token_ids = ERC721Transfer.objects.erc721_owned_by(
            safe_address, only_trusted=only_trusted, exclude_spam=exclude_spam
        )
        if not addresses_with_token_ids:
            return [], 0

        count = len(addresses_with_token_ids)
        # TODO Paginate on DB
        if limit is not None:
            addresses_with_token_ids = addresses_with_token_ids[offset : offset + limit]

        for address, _ in addresses_with_token_ids:
            # Store tokens in database if not present
            self.get_token_info(address)  # This is cached

        logger.debug("Getting token_uris for %s", addresses_with_token_ids)
        # Chunk token uris to prevent stressing the node
        token_uris = []

        for addresses_with_token_ids_chunk in chunks(addresses_with_token_ids, 25):
            token_uris.extend(self.get_token_uris(addresses_with_token_ids_chunk))
        logger.debug("Got token_uris for %s", addresses_with_token_ids)
        collectibles = []
        for (token_address, token_id), token_uri in zip(
            addresses_with_token_ids, token_uris
        ):
            token_info = self.get_token_info(token_address)
            collectible = self.build_collectible(
                token_info, token_address, token_id, token_uri
            )
            collectibles.append(collectible)

        return collectibles, count

    def _get_collectibles_with_metadata(
        self,
        safe_address: ChecksumAddress,
        only_trusted: bool = False,
        exclude_spam: bool = False,
        limit: Optional[int] = None,
        offset: int = 0,
    ) -> Tuple[List[CollectibleWithMetadata], int]:
        """
        Get collectibles using the owner, addresses and the token_ids

        :param safe_address:
        :param only_trusted: If True, return balance only for trusted tokens
        :param exclude_spam: If True, exclude spam tokens
        :param limit: page size
        :param offset: page position
        :return: collectibles and count
        """

        # Async retry for getting metadata if fetching fails
        from ..tasks import retry_get_metadata_task

        collectibles_with_metadata: List[CollectibleWithMetadata] = []
        collectibles, count = self.get_collectibles(
            safe_address,
            only_trusted=only_trusted,
            exclude_spam=exclude_spam,
            limit=limit,
            offset=offset,
        )
        metadata_cache_keys = [
            self.get_metadata_cache_key(collectible.address, collectible.id)
            for collectible in collectibles
        ]
        cached_results = self.redis.mget(metadata_cache_keys)

        collectibles_not_cached = []
        jobs = []
        for cached, collectible in zip(cached_results, collectibles):
            if cached:
                collectible_cache = json.loads(cached)
                collectibles_with_metadata.append(
                    CollectibleWithMetadata(
                        collectible_cache["token_name"],
                        collectible_cache["token_symbol"],
                        collectible_cache["logo_uri"],
                        collectible_cache["address"],
                        collectible_cache["id"],
                        collectible_cache["uri"],
                        collectible_cache["metadata"],
                    )
                )
            else:
                collectibles_not_cached.append(collectible)
                jobs.append(gevent.spawn(self.get_metadata, collectible))
                collectibles_with_metadata.append(None)  # Keeps the order

        _ = gevent.joinall(jobs)
        collectibles_with_metadata_not_cached = []
        redis_pipe = self.redis.pipeline()
        for collectible, job in zip(collectibles_not_cached, jobs):
            try:
                metadata = job.get()
                if not isinstance(metadata, dict):
                    metadata = {}
                    logger.warning(
                        "A dictionary metadata was expected on token-uri=%s for token-address=%s",
                        collectible.uri,
                        collectible.address,
                    )
            except MetadataRetrievalException:
                metadata = {}
                logger.warning(
                    "Cannot retrieve metadata on token-uri=%s for token-address=%s",
                    collectible.uri,
                    collectible.address,
                )
            except MetadataRetrievalExceptionTimeout:
                metadata = {}
                logger.warning(
                    "Timeout retrieving metadata on token-uri=%s for token-address=%s, retrying asyncronous ",
                    collectible.uri,
                    collectible.address,
                )
                retry_get_metadata_task.apply_async(
                    (collectible.address, collectible.id),
                    countdown=random.randint(0, 60),  # Don't retry all at once
                )

            collectible_with_metadata = CollectibleWithMetadata(
                collectible.token_name,
                collectible.token_symbol,
                collectible.logo_uri,
                collectible.address,
                collectible.id,
                collectible.uri,
                metadata,
            )
            collectibles_with_metadata_not_cached.append(collectible_with_metadata)
            redis_pipe.set(
                self.get_metadata_cache_key(collectible.address, collectible.id),
                json.dumps(dataclasses.asdict(collectible_with_metadata)),
                self.COLLECTIBLE_EXPIRATION,
            )
        redis_pipe.execute()

        # Creates a collectibles metadata keeping the initial order
        for collectible_metadata_cached_index in range(len(collectibles_with_metadata)):
            if collectibles_with_metadata[collectible_metadata_cached_index] is None:
                collectibles_with_metadata[
                    collectible_metadata_cached_index
                ] = collectibles_with_metadata_not_cached.pop(0)

        return collectibles_with_metadata, count

    def get_collectibles_with_metadata(
        self,
        safe_address: ChecksumAddress,
        only_trusted: bool = False,
        exclude_spam: bool = False,
    ) -> List[CollectibleWithMetadata]:
        """
        Get collectibles v1 returns no paginated response

        :param safe_address:
        :param only_trusted: If True, return balance only for trusted tokens
        :param exclude_spam: If True, exclude spam tokens
        :return: collectibles
        """
        collectibles, _ = self._get_collectibles_with_metadata(
            safe_address, only_trusted, exclude_spam, limit=50, offset=0
        )
        return collectibles

    def get_collectibles_with_metadata_paginated(
        self,
        safe_address: ChecksumAddress,
        only_trusted: bool = False,
        exclude_spam: bool = False,
        limit: int = 10,
        offset: int = 0,
    ) -> Tuple[List[CollectibleWithMetadata], int]:
        """
        Get collectibles paginated

        :param safe_address:
        :param only_trusted: If True, return balance only for trusted tokens
        :param exclude_spam: If True, exclude spam tokens
        :param limit: page size
        :param offset: page position
        :return: collectibles and count
        """
        return self._get_collectibles_with_metadata(
            safe_address, only_trusted, exclude_spam, limit=limit, offset=offset
        )

    @cachedmethod(cache=operator.attrgetter("cache_token_info"))
    @cache_memoize(TOKEN_EXPIRATION, prefix="collectibles-get_token_info")  # 1 hour
    def get_token_info(
        self, token_address: ChecksumAddress
    ) -> Optional[Erc721InfoWithLogo]:
        """
        :param token_address:
        :return: Erc721 name and symbol. If it cannot be found, `name=''` and `symbol=''`
        """
        try:
            token = Token.objects.get(address=token_address)
            return Erc721InfoWithLogo.from_token(token)
        except Token.DoesNotExist:
            if token := Token.objects.create_from_blockchain(token_address):
                return Erc721InfoWithLogo.from_token(token)

    def get_token_uris(
        self, addresses_with_token_ids: Sequence[Tuple[ChecksumAddress, int]]
    ) -> List[Optional[str]]:
        """
        Cache token_uris, as they shouldn't change

        :param addresses_with_token_ids:
        :return: List of token_uris in the same other that `addresses_with_token_ids` were provided
        """

        def get_redis_key(address_with_token_id: Tuple[ChecksumAddress, int]) -> str:
            token_address, token_id = address_with_token_id
            return f"token-uri:{token_address}:{token_id}"

        # Try finding missing token uris in redis
        redis_token_uris = self.redis.mget(
            get_redis_key(address_with_token_id)
            for address_with_token_id in addresses_with_token_ids
        )
        # Redis does not allow `None`, so empty string is used for uris searched but not found
        found_uris: Dict[Tuple[ChecksumAddress, int], Optional[str]] = {}
        not_found_uris: List[Tuple[ChecksumAddress, int]] = []

        for address_with_token_id, token_uri in zip(
            addresses_with_token_ids, redis_token_uris
        ):
            if token_uri is None:
                not_found_uris.append(address_with_token_id)
            else:
                found_uris[address_with_token_id] = (
                    token_uri.decode() if token_uri else None
                )

        try:
            # Find missing token uris in blockchain
            logger.debug(
                "Getting token uris from blockchain for %d addresses with tokenIds",
                len(not_found_uris),
            )
            blockchain_token_uris = {
                address_with_token_id: token_uri if token_uri else None
                for address_with_token_id, token_uri in zip(
                    not_found_uris,
                    self.ethereum_client.erc721.get_token_uris(not_found_uris),
                )
            }
            logger.debug("Got token uris from blockchain")
        except (IOError, ValueError):
            logger.warning(
                "Problem when getting token uris from blockchain, trying individually",
                exc_info=True,
            )
            blockchain_token_uris = {}
            for not_found_uri in not_found_uris:
                try:
                    token_uri = self.ethereum_client.erc721.get_token_uris(
                        [not_found_uri]
                    )[0]
                    blockchain_token_uris[not_found_uri] = (
                        token_uri if token_uri else None
                    )
                except ValueError:
                    blockchain_token_uris[not_found_uri] = None
                    logger.warning(
                        "ValueError when getting token uri from blockchain for token and tokenId %s",
                        not_found_uri,
                        exc_info=True,
                    )
                except IOError as exc:
                    raise NodeConnectionException from exc

        if blockchain_token_uris:
            pipe = self.redis.pipeline()
            redis_map_to_store = {
                get_redis_key(address_with_token_id): token_uri
                if token_uri is not None
                else ""
                for address_with_token_id, token_uri in blockchain_token_uris.items()
            }
            pipe.mset(redis_map_to_store)
            for key in redis_map_to_store.keys():
                pipe.expire(key, self.COLLECTIBLE_EXPIRATION)
            pipe.execute()
            found_uris.update(blockchain_token_uris)

        return [
            found_uris[address_with_token_id]
            for address_with_token_id in addresses_with_token_ids
        ]

'''
'''--- safe_transaction_service/history/services/index_service.py ---
import logging
from dataclasses import dataclass
from typing import Collection, List, Optional, OrderedDict, Union

from django.db import IntegrityError, transaction
from django.db.models import Min, Q

from eth_typing import ChecksumAddress
from hexbytes import HexBytes

from gnosis.eth import EthereumClient, EthereumClientProvider

from ..models import EthereumBlock, EthereumTx
from ..models import IndexingStatus as IndexingStatusDb
from ..models import (
    InternalTxDecoded,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    SafeMasterCopy,
    SafeStatus,
)

logger = logging.getLogger(__name__)

@dataclass
class IndexingStatus:
    current_block_number: int
    erc20_block_number: int
    erc20_synced: bool
    master_copies_block_number: int
    master_copies_synced: bool
    synced: bool

@dataclass
class ERC20IndexingStatus:
    current_block_number: int
    erc20_block_number: int
    erc20_synced: bool

class IndexingException(Exception):
    pass

class TransactionNotFoundException(IndexingException):
    pass

class TransactionWithoutBlockException(IndexingException):
    pass

class BlockNotFoundException(IndexingException):
    pass

class IndexServiceProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            from django.conf import settings

            cls.instance = IndexService(
                EthereumClientProvider(),
                settings.ETH_REORG_BLOCKS,
                settings.ETH_L2_NETWORK,
                settings.ALERT_OUT_OF_SYNC_EVENTS_THRESHOLD,
            )
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

# TODO Test IndexService
class IndexService:
    def __init__(
        self,
        ethereum_client: EthereumClient,
        eth_reorg_blocks: int,
        eth_l2_network: bool,
        alert_out_of_sync_events_threshold: float,
    ):
        self.ethereum_client = ethereum_client
        self.eth_reorg_blocks = eth_reorg_blocks
        self.eth_l2_network = eth_l2_network
        self.alert_out_of_sync_events_threshold = alert_out_of_sync_events_threshold

    def block_get_or_create_from_block_hash(self, block_hash: int):
        try:
            return EthereumBlock.objects.get(block_hash=block_hash)
        except EthereumBlock.DoesNotExist:
            current_block_number = (
                self.ethereum_client.current_block_number
            )  # For reorgs
            block = self.ethereum_client.get_block(block_hash)
            confirmed = (
                current_block_number - block["number"]
            ) >= self.eth_reorg_blocks
            return EthereumBlock.objects.get_or_create_from_block(
                block, confirmed=confirmed
            )

    def get_erc20_721_current_indexing_block_number(self) -> int:
        return IndexingStatusDb.objects.get_erc20_721_indexing_status().block_number

    def get_indexing_status(self) -> IndexingStatus:
        current_block_number = self.ethereum_client.current_block_number
        erc20_block_number = self.get_erc20_721_current_indexing_block_number()

        master_copies_block_number = SafeMasterCopy.objects.relevant().aggregate(
            min_master_copies_block_number=Min("tx_block_number")
        )["min_master_copies_block_number"]
        if master_copies_block_number is None:  # Still nothing indexed
            master_copies_block_number = current_block_number

        erc20_synced = (
            current_block_number - erc20_block_number <= self.eth_reorg_blocks
        )
        master_copies_synced = (
            current_block_number - master_copies_block_number <= self.eth_reorg_blocks
        )

        return IndexingStatus(
            current_block_number=current_block_number,
            erc20_block_number=erc20_block_number,
            erc20_synced=erc20_synced,
            master_copies_block_number=master_copies_block_number,
            master_copies_synced=master_copies_synced,
            synced=erc20_synced and master_copies_synced,
        )

    def get_erc20_indexing_status(self) -> ERC20IndexingStatus:
        current_block_number = self.ethereum_client.current_block_number
        erc20_block_number = self.get_erc20_721_current_indexing_block_number()
        synced = (current_block_number - erc20_block_number) <= self.eth_reorg_blocks

        return ERC20IndexingStatus(
            current_block_number=current_block_number,
            erc20_block_number=erc20_block_number,
            erc20_synced=synced,
        )

    def is_service_synced(self) -> bool:
        """
        :return: `True` if master copies and ERC20/721 are synced, `False` otherwise
        """

        # Use number of reorg blocks to consider as not synced
        reference_block_number = (
            self.ethereum_client.current_block_number - self.eth_reorg_blocks
        )
        synced: bool = True
        for safe_master_copy in SafeMasterCopy.objects.relevant().filter(
            tx_block_number__lt=reference_block_number
        ):
            logger.error("Master Copy %s is out of sync", safe_master_copy.address)
            synced = False

        if self.get_erc20_721_current_indexing_block_number() < reference_block_number:
            logger.error("Safe Contracts have ERC20/721 out of sync")
            synced = False

        return synced

    def tx_create_or_update_from_tx_hash(self, tx_hash: str) -> "EthereumTx":
        try:
            ethereum_tx = EthereumTx.objects.get(tx_hash=tx_hash)
            # For txs stored before being mined
            if ethereum_tx.block is None:
                tx_receipt = self.ethereum_client.get_transaction_receipt(tx_hash)
                ethereum_block = self.block_get_or_create_from_block_hash(
                    tx_receipt["blockHash"]
                )
                ethereum_tx.update_with_block_and_receipt(ethereum_block, tx_receipt)
            return ethereum_tx
        except EthereumTx.DoesNotExist:
            tx_receipt = self.ethereum_client.get_transaction_receipt(tx_hash)
            ethereum_block = self.block_get_or_create_from_block_hash(
                tx_receipt["blockHash"]
            )
            tx = self.ethereum_client.get_transaction(tx_hash)
            return EthereumTx.objects.create_from_tx_dict(
                tx, tx_receipt=tx_receipt, ethereum_block=ethereum_block
            )

    def txs_create_or_update_from_tx_hashes(
        self, tx_hashes: Collection[Union[str, bytes]]
    ) -> List["EthereumTx"]:
        # Search first in database
        ethereum_txs_dict = OrderedDict.fromkeys(
            [HexBytes(tx_hash).hex() for tx_hash in tx_hashes]
        )
        db_ethereum_txs = EthereumTx.objects.filter(tx_hash__in=tx_hashes).exclude(
            block=None
        )
        for db_ethereum_tx in db_ethereum_txs:
            ethereum_txs_dict[db_ethereum_tx.tx_hash] = db_ethereum_tx

        # Retrieve from the node the txs missing from database
        tx_hashes_not_in_db = [
            tx_hash
            for tx_hash, ethereum_tx in ethereum_txs_dict.items()
            if not ethereum_tx
        ]
        if not tx_hashes_not_in_db:
            return list(ethereum_txs_dict.values())

        # Get receipts for hashes not in db
        tx_receipts = []
        for tx_hash, tx_receipt in zip(
            tx_hashes_not_in_db,
            self.ethereum_client.get_transaction_receipts(tx_hashes_not_in_db),
        ):
            tx_receipt = tx_receipt or self.ethereum_client.get_transaction_receipt(
                tx_hash
            )  # Retry fetching if failed
            if not tx_receipt:
                raise TransactionNotFoundException(
                    f"Cannot find tx-receipt with tx-hash={HexBytes(tx_hash).hex()}"
                )

            if tx_receipt.get("blockHash") is None:
                raise TransactionWithoutBlockException(
                    f"Cannot find blockHash for tx-receipt with "
                    f"tx-hash={HexBytes(tx_hash).hex()}"
                )

            tx_receipts.append(tx_receipt)

        # Get transactions for hashes not in db
        fetched_txs = self.ethereum_client.get_transactions(tx_hashes_not_in_db)
        block_hashes = set()
        txs = []
        for tx_hash, tx in zip(tx_hashes_not_in_db, fetched_txs):
            tx = tx or self.ethereum_client.get_transaction(
                tx_hash
            )  # Retry fetching if failed
            if not tx:
                raise TransactionNotFoundException(
                    f"Cannot find tx with tx-hash={HexBytes(tx_hash).hex()}"
                )

            if tx.get("blockHash") is None:
                raise TransactionWithoutBlockException(
                    f"Cannot find blockHash for tx with "
                    f"tx-hash={HexBytes(tx_hash).hex()}"
                )

            block_hashes.add(tx["blockHash"].hex())
            txs.append(tx)

        blocks = self.ethereum_client.get_blocks(block_hashes)
        block_dict = {}
        for block_hash, block in zip(block_hashes, blocks):
            block = block or self.ethereum_client.get_block(
                block_hash
            )  # Retry fetching if failed
            if not block:
                raise BlockNotFoundException(
                    f"Block with hash={block_hash} was not found"
                )
            assert block_hash == block["hash"].hex()
            block_dict[block["hash"]] = block

        # Create new transactions or update them if they have no receipt
        current_block_number = self.ethereum_client.current_block_number
        for tx, tx_receipt in zip(txs, tx_receipts):
            block = block_dict[tx["blockHash"]]
            confirmed = (
                current_block_number - block["number"]
            ) >= self.eth_reorg_blocks
            ethereum_block: EthereumBlock = (
                EthereumBlock.objects.get_or_create_from_block(
                    block, confirmed=confirmed
                )
            )
            try:
                with transaction.atomic():
                    ethereum_tx = EthereumTx.objects.create_from_tx_dict(
                        tx, tx_receipt=tx_receipt, ethereum_block=ethereum_block
                    )
                ethereum_txs_dict[HexBytes(ethereum_tx.tx_hash).hex()] = ethereum_tx
            except IntegrityError:  # Tx exists
                ethereum_tx = EthereumTx.objects.get(tx_hash=tx["hash"])
                # For txs stored before being mined
                ethereum_tx.update_with_block_and_receipt(ethereum_block, tx_receipt)
                ethereum_txs_dict[ethereum_tx.tx_hash] = ethereum_tx
        return list(ethereum_txs_dict.values())

    @transaction.atomic
    def _reprocess(self, addresses: List[str]):
        """
        Trigger processing of traces again. If addresses is empty, everything is reprocessed

        :param addresses:
        :return:
        """
        queryset = MultisigConfirmation.objects.filter(signature=None)
        if not addresses:
            logger.info("Remove onchain confirmations")
            queryset.delete()

        logger.info("Remove transactions automatically indexed")
        queryset = MultisigTransaction.objects.exclude(ethereum_tx=None).filter(
            Q(origin__exact={})
        )
        if addresses:
            queryset = queryset.filter(safe__in=addresses)
        queryset.delete()

        logger.info("Remove module transactions")
        queryset = ModuleTransaction.objects.all()
        if addresses:
            queryset = queryset.filter(safe__in=addresses)
        queryset.delete()

        logger.info("Remove Safe statuses")

        queryset = SafeStatus.objects.all()
        if addresses:
            queryset = queryset.filter(address__in=addresses)
        queryset.delete()

        logger.info("Mark all internal txs decoded as not processed")
        queryset = InternalTxDecoded.objects.all()
        if addresses:
            queryset = queryset.filter(internal_tx___from__in=addresses)
        queryset.update(processed=False)

    def reprocess_addresses(self, addresses: List[str]):
        """
        Given a list of safe addresses it will delete all `SafeStatus`, conflicting `MultisigTxs` and will mark
        every `InternalTxDecoded` not processed to be processed again

        :param addresses: List of checksummed addresses or queryset
        :return: Number of `SafeStatus` deleted
        """
        if not addresses:
            return None

        return self._reprocess(addresses)

    def reprocess_all(self):
        return self._reprocess(None)

    def _reindex(
        self,
        indexer: "EthereumIndexer",  # noqa F821
        from_block_number: int,
        to_block_number: Optional[int] = None,
        block_process_limit: int = 100,
        addresses: Optional[ChecksumAddress] = None,
    ) -> int:
        """
        :param provider:
        :param from_block_number:
        :param to_block_number:
        :param block_process_limit:
        :param addresses:
        :return: Number of reindexed elements
        """
        assert (not to_block_number) or to_block_number > from_block_number

        ignore_addresses_on_log_filter = (
            indexer.IGNORE_ADDRESSES_ON_LOG_FILTER
            if hasattr(indexer, "IGNORE_ADDRESSES_ON_LOG_FILTER")
            else None
        )

        if addresses:
            indexer.IGNORE_ADDRESSES_ON_LOG_FILTER = (
                False  # Just process addresses provided
            )
        else:
            addresses = list(
                indexer.database_queryset.values_list("address", flat=True)
            )

        element_number: int = 0
        if not addresses:
            logger.warning("No addresses to process")
        else:
            logger.info("Start reindexing addresses %s", addresses)
            current_block_number = self.ethereum_client.current_block_number
            stop_block_number = (
                min(current_block_number, to_block_number)
                if to_block_number
                else current_block_number
            )
            for block_number in range(
                from_block_number, stop_block_number, block_process_limit
            ):
                elements = indexer.find_relevant_elements(
                    addresses,
                    block_number,
                    min(block_number + block_process_limit - 1, stop_block_number),
                )
                indexer.process_elements(elements)
                logger.info(
                    "Current block number %d, found %d traces/events",
                    block_number,
                    len(elements),
                )
                element_number += len(elements)

            logger.info("End reindexing addresses %s", addresses)

        # We changed attributes on the indexer, so better restore it
        indexer.IGNORE_ADDRESSES_ON_LOG_FILTER = ignore_addresses_on_log_filter
        return element_number

    def reindex_master_copies(
        self,
        from_block_number: int,
        to_block_number: Optional[int] = None,
        block_process_limit: int = 100,
        addresses: Optional[ChecksumAddress] = None,
    ) -> int:
        """
        Reindexes master copies in parallel with the current running indexer, so service will have no missing txs
        while reindexing

        :param from_block_number: Block number to start indexing from
        :param to_block_number: Block number to stop indexing on
        :param block_process_limit: Number of blocks to process each time
        :param addresses: Master Copy or Safes(for L2 event processing) addresses. If not provided,
            all master copies will be used
        """

        # TODO Refactor EthereumIndexer to fix circular imports
        from ..indexers import InternalTxIndexerProvider, SafeEventsIndexerProvider

        indexer = (
            SafeEventsIndexerProvider
            if self.eth_l2_network
            else InternalTxIndexerProvider
        )()

        return self._reindex(
            indexer,
            from_block_number,
            to_block_number=to_block_number,
            block_process_limit=block_process_limit,
            addresses=addresses,
        )

    def reindex_erc20_events(
        self,
        from_block_number: int,
        to_block_number: Optional[int] = None,
        block_process_limit: int = 100,
        addresses: Optional[ChecksumAddress] = None,
    ) -> int:
        """
        Reindexes erc20/721 events parallel with the current running indexer, so service will have no missing
        events while reindexing

        :param from_block_number: Block number to start indexing from
        :param to_block_number: Block number to stop indexing on
        :param block_process_limit: Number of blocks to process each time
        :param addresses: Safe addresses. If not provided, all Safe addresses will be used
        """
        assert (not to_block_number) or to_block_number > from_block_number

        from ..indexers import Erc20EventsIndexerProvider

        indexer = Erc20EventsIndexerProvider()
        return self._reindex(
            indexer,
            from_block_number,
            to_block_number=to_block_number,
            block_process_limit=block_process_limit,
            addresses=addresses,
        )

'''
'''--- safe_transaction_service/history/services/reorg_service.py ---
import logging
from typing import Dict, Optional

from django.db import models, transaction

from hexbytes import HexBytes

from gnosis.eth import EthereumClient, EthereumClientProvider

from ..models import EthereumBlock, IndexingStatus, ProxyFactory, SafeMasterCopy

logger = logging.getLogger(__name__)

class ReorgServiceProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            from django.conf import settings

            cls.instance = ReorgService(
                EthereumClientProvider(), settings.ETH_REORG_BLOCKS
            )
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

# TODO Test ReorgService
class ReorgService:
    def __init__(
        self,
        ethereum_client: EthereumClient,
        eth_reorg_blocks: int,
        eth_reorg_rewind_blocks: Optional[int] = 250,
    ):
        """
        :param ethereum_client:
        :param eth_reorg_blocks: Minimum number of blocks to consider a block confirmed and safe to rely on. In Mainnet
            10 blocks is considered safe
        :param eth_reorg_rewind_blocks: Number of blocks to rewind indexing when a reorg is found
        """
        self.ethereum_client = ethereum_client
        self.eth_reorg_blocks = eth_reorg_blocks  #
        self.eth_reorg_rewind_blocks = eth_reorg_rewind_blocks
        # Dictionary with Django model and attribute for reorgs
        self.reorg_models: Dict[models.Model, str] = {
            ProxyFactory: "tx_block_number",
            # TODO Refactor this to accept a function
            # IndexingStatus: "block_number",
            SafeMasterCopy: "tx_block_number",
        }

    def check_reorgs(self) -> Optional[int]:
        """
        :return: Number of oldest block with reorg detected. `None` if not reorg found
        """
        current_block_number = self.ethereum_client.current_block_number
        to_block = current_block_number - self.eth_reorg_blocks
        for database_block in (
            EthereumBlock.objects.not_confirmed(to_block_number=to_block)
            .only("number", "block_hash", "confirmed")
            .order_by("number")
        ):
            blockchain_block = self.ethereum_client.get_block(
                database_block.number, full_transactions=False
            )
            blockchain_next_block = self.ethereum_client.get_block(
                database_block.number + 1, full_transactions=False
            )
            if (
                HexBytes(blockchain_block["hash"])
                == HexBytes(blockchain_next_block["parentHash"])
                == HexBytes(database_block.block_hash)
            ):
                database_block.set_confirmed()
            else:
                logger.warning("Reorg found for block-number=%d", database_block.number)
                return database_block.number

    def reset_all_to_block(self, block_number: int) -> int:
        """
        Reset database fields to a block to start reindexing from that block. It's useful when you want to trigger
        a indexation for txs that are not appearing on database but you don't want to delete anything

        :param block_number:
        :return: Number of updated models
        """
        updated = 0
        for model, field in self.reorg_models.items():
            updated += model.objects.filter(**{field + "__gt": block_number}).update(
                **{field: block_number}
            )
        if IndexingStatus.objects.set_erc20_721_indexing_status(block_number):
            updated += 1

        return updated

    @transaction.atomic
    def recover_from_reorg(self, first_reorg_block_number: int) -> int:
        """
        Reset database fields to a block to start reindexing from that block and remove blocks greater or equal
        than `first_reorg_block_number`

        :param first_reorg_block_number:
        :return: Return number of elements updated
        """
        safe_reorg_block_number = max(
            first_reorg_block_number - self.eth_reorg_rewind_blocks, 0
        )

        updated = 0
        for model, field in self.reorg_models.items():
            updated += model.objects.filter(
                **{field + "__gte": first_reorg_block_number}
            ).update(**{field: safe_reorg_block_number})

        EthereumBlock.objects.filter(number__gte=first_reorg_block_number).delete()
        logger.warning(
            "Reorg of block-number=%d fixed, %d elements updated",
            first_reorg_block_number,
            updated,
        )
        return updated

'''
'''--- safe_transaction_service/history/services/safe_service.py ---
import logging
from dataclasses import dataclass, replace
from datetime import datetime
from typing import Optional, Tuple, Union

from eth_typing import ChecksumAddress
from web3 import Web3

from gnosis.eth import EthereumClient
from gnosis.eth.contracts import get_cpk_factory_contract, get_proxy_factory_contract
from gnosis.safe import Safe
from gnosis.safe.exceptions import CannotRetrieveSafeInfoException
from gnosis.safe.safe import SafeInfo

from ..exceptions import NodeConnectionException
from ..models import InternalTx, SafeLastStatus, SafeMasterCopy

logger = logging.getLogger(__name__)

class SafeServiceException(Exception):
    pass

class CannotGetSafeInfoFromBlockchain(SafeServiceException):
    pass

class CannotGetSafeInfoFromDB(SafeServiceException):
    pass

EthereumAddress = str

@dataclass
class SafeCreationInfo:
    created: datetime
    creator: EthereumAddress
    factory_address: EthereumAddress
    master_copy: Optional[EthereumAddress]
    setup_data: Optional[bytes]
    transaction_hash: str

class SafeServiceProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            from django.conf import settings

            tracing_enabled = bool(settings.ETHEREUM_TRACING_NODE_URL)
            node_url = (
                settings.ETHEREUM_TRACING_NODE_URL
                if tracing_enabled
                else settings.ETHEREUM_NODE_URL
            )
            cls.instance = SafeService(EthereumClient(node_url), tracing_enabled)
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class SafeService:
    def __init__(self, ethereum_client: EthereumClient, tracing_enabled: bool):
        self.ethereum_client = ethereum_client
        self.tracing_enabled = tracing_enabled
        dummy_w3 = Web3()  # Not needed, just used to decode contracts
        self.proxy_factory_contract = get_proxy_factory_contract(dummy_w3)
        self.cpk_proxy_factory_contract = get_cpk_factory_contract(dummy_w3)

    def get_safe_creation_info(self, safe_address: str) -> Optional[SafeCreationInfo]:
        try:
            creation_internal_tx = (
                InternalTx.objects.filter(
                    ethereum_tx__status=1  # Ignore Internal Transactions for failed Transactions
                )
                .select_related("ethereum_tx__block")
                .get(contract_address=safe_address)
            )
            creation_ethereum_tx = creation_internal_tx.ethereum_tx

            created_time = creation_ethereum_tx.block.timestamp

            parent_internal_tx = self._get_parent_internal_tx(creation_internal_tx)

            creator = (parent_internal_tx or creation_ethereum_tx)._from
            proxy_factory = creation_internal_tx._from

            master_copy: Optional[str] = None
            setup_data: Optional[bytes] = None
            data = (
                bytes(parent_internal_tx.data)
                if parent_internal_tx
                else bytes(creation_ethereum_tx.data)
            )
            result = self._decode_proxy_factory(data) or self._decode_cpk_proxy_factory(
                data
            )
            if result:
                master_copy, setup_data = result
            if not (master_copy and setup_data):
                if setup_internal_tx := self._get_next_internal_tx(
                    creation_internal_tx
                ):
                    master_copy = setup_internal_tx.to
                    setup_data = setup_internal_tx.data
        except InternalTx.DoesNotExist:
            return None
        except IOError as exc:
            raise NodeConnectionException from exc

        return SafeCreationInfo(
            created_time,
            creator,
            proxy_factory,
            master_copy,
            setup_data,
            creation_internal_tx.ethereum_tx_id,
        )

    def get_safe_info(self, safe_address: ChecksumAddress) -> SafeInfo:
        """
        :param safe_address:
        :return: SafeInfo for the provided `safe_address`. First tries database, if not
            found or if `nonce=0` it will try blockchain
        :raises: CannotGetSafeInfoFromBlockchain
        """
        try:
            safe_info = self.get_safe_info_from_db(safe_address)
            if safe_info.nonce == 0:
                # This works for:
                # - Not indexed Safes
                # - Not L2 Safes on L2 networks
                raise CannotGetSafeInfoFromDB
            return safe_info
        except CannotGetSafeInfoFromDB:
            return self.get_safe_info_from_blockchain(safe_address)

    def get_safe_info_from_blockchain(self, safe_address: ChecksumAddress) -> SafeInfo:
        """
        :param safe_address:
        :return: SafeInfo from blockchain
        """
        try:
            safe = Safe(safe_address, self.ethereum_client)
            safe_info = safe.retrieve_all_info()
            # Return same master copy information than the db method
            return replace(
                safe_info,
                version=SafeMasterCopy.objects.get_version_for_address(
                    safe_info.master_copy
                ),
            )
        except IOError as exc:
            raise NodeConnectionException from exc
        except CannotRetrieveSafeInfoException as exc:
            raise CannotGetSafeInfoFromBlockchain(safe_address) from exc

    def get_safe_info_from_db(self, safe_address: ChecksumAddress) -> SafeInfo:
        try:
            return SafeLastStatus.objects.get_or_generate(safe_address).get_safe_info()
        except SafeLastStatus.DoesNotExist as exc:
            raise CannotGetSafeInfoFromDB(safe_address) from exc

    def _decode_proxy_factory(
        self, data: Union[bytes, str]
    ) -> Optional[Tuple[str, bytes]]:
        try:
            _, data_decoded = self.proxy_factory_contract.decode_function_input(data)
            master_copy = (
                data_decoded.get("masterCopy")
                or data_decoded.get("_mastercopy")
                or data_decoded.get("_singleton")
                or data_decoded.get("singleton")
            )
            setup_data = data_decoded.get("data") or data_decoded.get("initializer")
            if master_copy and setup_data is not None:
                return master_copy, setup_data

            logger.error(
                "Problem decoding proxy factory, data_decoded=%s", data_decoded
            )
            return None
        except ValueError:
            return None

    def _decode_cpk_proxy_factory(
        self, data: Union[bytes, str]
    ) -> Optional[Tuple[str, bytes]]:
        try:
            _, data_decoded = self.cpk_proxy_factory_contract.decode_function_input(
                data
            )
            master_copy = data_decoded.get("masterCopy")
            setup_data = data_decoded.get("data")
            return master_copy, setup_data
        except ValueError:
            return None

    def _get_next_internal_tx(self, internal_tx: InternalTx) -> Optional[InternalTx]:
        if child_trace := internal_tx.get_child(0):
            return child_trace
        if not self.tracing_enabled:
            return None
        try:
            next_traces = self.ethereum_client.parity.get_next_traces(
                internal_tx.ethereum_tx_id,
                internal_tx.trace_address_as_list,
                remove_calls=True,
            )
            return next_traces and InternalTx.objects.build_from_trace(
                next_traces[0], internal_tx.ethereum_tx
            )
        except ValueError:
            return None

    def _get_parent_internal_tx(self, internal_tx: InternalTx) -> InternalTx:
        if parent_trace := internal_tx.get_parent():
            return parent_trace
        if not self.tracing_enabled:
            return None
        try:
            previous_trace = self.ethereum_client.parity.get_previous_trace(
                internal_tx.ethereum_tx_id,
                internal_tx.trace_address_as_list,
                skip_delegate_calls=True,
            )
            return previous_trace and InternalTx.objects.build_from_trace(
                previous_trace, internal_tx.ethereum_tx
            )
        except ValueError:
            return None

'''
'''--- safe_transaction_service/history/services/transaction_service.py ---
import copyreg
import logging
import pickle
from collections import defaultdict
from datetime import timedelta
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union

from django.db.models import Case, Exists, F, OuterRef, QuerySet, Subquery, Value, When
from django.utils import timezone

from redis import Redis

from gnosis.eth import EthereumClient, EthereumClientProvider
from gnosis.eth.django.models import Uint256Field

from safe_transaction_service.tokens.models import Token
from safe_transaction_service.utils.redis import get_redis

from ..models import (
    ERC20Transfer,
    ERC721Transfer,
    EthereumTx,
    EthereumTxCallType,
    InternalTx,
    ModuleTransaction,
    MultisigTransaction,
    TransferDict,
)
from ..serializers import (
    EthereumTxWithTransfersResponseSerializer,
    SafeModuleTransactionWithTransfersResponseSerializer,
    SafeMultisigTransactionWithTransfersResponseSerializer,
)

logger = logging.getLogger(__name__)

class TransactionServiceException(Exception):
    pass

class TransactionServiceProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = TransactionService(EthereumClientProvider(), get_redis())
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class TransactionService:
    def __init__(self, ethereum_client: EthereumClient, redis: Redis):
        self.ethereum_client = ethereum_client
        self.redis = redis
        # Encode memoryview for redis
        copyreg.pickle(memoryview, lambda val: (memoryview, (bytes(val),)))

    #  Cache methods ---------------------------------
    def get_cache_key(self, safe_address: str, tx_hash: str):
        return f"tx-service:{safe_address}:{tx_hash}"

    def get_txs_from_cache(
        self, safe_address: str, hashes_to_search: Sequence[str]
    ) -> List[Union[EthereumTx, MultisigTransaction, ModuleTransaction]]:
        keys_to_search = [
            self.get_cache_key(safe_address, hash_to_search)
            for hash_to_search in hashes_to_search
        ]
        return [
            pickle.loads(data) if data else None
            for data in self.redis.mget(keys_to_search)
        ]

    def store_txs_in_cache(
        self,
        safe_address: str,
        hashes_with_txs: Tuple[
            str, Union[EthereumTx, MultisigTransaction, ModuleTransaction]
        ],
    ):
        """
        Store executed transactions older than 10 minutes, using `ethereum_tx_hash` as key (for
        MultisigTransaction it will be `SafeTxHash`) and expire then in one hour

        :param safe_address:
        :param hashes_with_txs:
        """
        # Just store executed transactions older than 10 minutes
        to_store = {
            self.get_cache_key(safe_address, tx_hash): pickle.dumps(tx)
            for tx_hash, tx in hashes_with_txs
            if tx.execution_date
            and (tx.execution_date + timedelta(minutes=10)) < timezone.now()
        }
        if to_store:
            pipe = self.redis.pipeline()
            pipe.mset(to_store)
            for key in to_store.keys():
                pipe.expire(key, 60 * 60)  # Expire in one hour
            pipe.execute()

    # End of cache methods ----------------------------

    def get_all_tx_hashes(
        self,
        safe_address: str,
        executed: bool = False,
        queued: bool = True,
        trusted: bool = True,
    ) -> QuerySet:
        """
        Build a queryset with hashes for every tx for a Safe for paginated filtering. In the case of
        Multisig Transactions, as some of them are not mined, we use the SafeTxHash
        Criteria for building this list:
          - Return only multisig txs with `nonce < current Safe Nonce`
          - The endpoint should only show incoming transactions that have been mined
          - The transactions should be sorted by execution date. If an outgoing transaction doesn't have an execution
          date the execution date of the transaction with the same nonce that has been executed should be taken.
          - Incoming and outgoing transfers or Eth/tokens must be under a multisig/module tx if triggered by one.
          Otherwise they should have their own entry in the list using a EthereumTx

        :param safe_address:
        :param executed: By default `False`, all transactions are returned. With `True`, just txs executed are returned.
        :param queued: By default `True`, all transactions are returned. With `False`, just txs with
        `nonce < current Safe Nonce` are returned.
        :param trusted: By default `True`, just txs that are trusted are returned (with at least one confirmation,
        sent by a delegate or indexed). With `False` all txs are returned
        :return: List with tx hashes sorted by date (newest first)
        """

        # If tx is not mined, get the execution date of a tx mined with the same nonce
        case = Case(
            When(
                ethereum_tx__block=None,
                then=MultisigTransaction.objects.filter(
                    safe=OuterRef("safe"), nonce=OuterRef("nonce")
                )
                .exclude(ethereum_tx__block=None)
                .values("ethereum_tx__block__timestamp"),
            ),
            default=F("ethereum_tx__block__timestamp"),
        )
        multisig_safe_tx_ids = (
            MultisigTransaction.objects.filter(safe=safe_address)
            .annotate(
                execution_date=case,
                block=F("ethereum_tx__block_id"),
                safe_nonce=F("nonce"),
            )
            .values(
                "safe_tx_hash",  # Tricky, we will merge SafeTx hashes with EthereumTx hashes
                "execution_date",
                "created",
                "block",
                "safe_nonce",
            )
            .order_by("-execution_date")
        )
        # Block is needed to get stable ordering

        if not queued:  # Filter out txs with nonce >= Safe nonce
            last_nonce_query = (
                MultisigTransaction.objects.filter(safe=safe_address)
                .executed()
                .order_by("-nonce")
                .values("nonce")
            )
            multisig_safe_tx_ids = multisig_safe_tx_ids.filter(
                nonce__lte=Subquery(last_nonce_query[:1])
            )

        if trusted:  # Just show trusted transactions
            multisig_safe_tx_ids = multisig_safe_tx_ids.trusted()

        if executed:
            multisig_safe_tx_ids = multisig_safe_tx_ids.executed()

        # Get module txs
        module_tx_ids = (
            ModuleTransaction.objects.filter(safe=safe_address)
            .annotate(
                execution_date=F("internal_tx__timestamp"),
                block=F("internal_tx__block_number"),
                safe_nonce=Value(0, output_field=Uint256Field()),
            )
            .values(
                "internal_tx__ethereum_tx_id",
                "execution_date",
                "created",
                "block",
                "safe_nonce",
            )
            .distinct()
            .order_by("-execution_date")
        )

        multisig_hashes = MultisigTransaction.objects.filter(
            safe=safe_address, ethereum_tx_id=OuterRef("ethereum_tx_id")
        )
        module_hashes = ModuleTransaction.objects.filter(
            safe=safe_address, internal_tx__ethereum_tx_id=OuterRef("ethereum_tx_id")
        )

        # Get incoming/outgoing tokens not included on Multisig or Module txs.
        # Outgoing tokens can be triggered by another user after the Safe calls `approve`, that's why it will not
        # always appear as a MultisigTransaction
        erc20_tx_ids = (
            ERC20Transfer.objects.to_or_from(safe_address)
            .exclude(Exists(multisig_hashes))
            .exclude(Exists(module_hashes))
            .annotate(
                execution_date=F("timestamp"),
                created=F("timestamp"),
                block=F("block_number"),
                safe_nonce=Value(0, output_field=Uint256Field()),
            )
            .values(
                "ethereum_tx_id", "execution_date", "created", "block", "safe_nonce"
            )
            .distinct()
            .order_by("-execution_date")
        )

        erc721_tx_ids = (
            ERC721Transfer.objects.to_or_from(safe_address)
            .exclude(Exists(multisig_hashes))
            .exclude(Exists(module_hashes))
            .annotate(
                execution_date=F("timestamp"),
                created=F("timestamp"),
                block=F("block_number"),
                safe_nonce=Value(0, output_field=Uint256Field()),
            )
            .values(
                "ethereum_tx_id", "execution_date", "created", "block", "safe_nonce"
            )
            .distinct()
            .order_by("-execution_date")
        )

        # Get incoming ether txs not included on Multisig or Module txs
        internal_tx_ids = (
            InternalTx.objects.filter(
                call_type=EthereumTxCallType.CALL.value,
                value__gt=0,
                to=safe_address,
            )
            .exclude(Exists(multisig_hashes))
            .exclude(Exists(module_hashes))
            .annotate(
                execution_date=F("timestamp"),
                created=F("timestamp"),
                block=F("block_number"),
                safe_nonce=Value(0, output_field=Uint256Field()),
            )
            .values(
                "ethereum_tx_id", "execution_date", "created", "block", "safe_nonce"
            )
            .distinct()
            .order_by("-execution_date")
        )

        # Tricky, we merge SafeTx hashes with EthereumTx hashes
        queryset = (
            multisig_safe_tx_ids.union(erc20_tx_ids, all=True)
            .union(erc721_tx_ids, all=True)
            .union(internal_tx_ids, all=True)
            .union(module_tx_ids, all=True)
            .order_by("-execution_date", "-safe_nonce", "block", "-created")
        )
        # Order by block because `block_number < NULL`, so txs mined will have preference,
        # and `created` to get always the same ordering with not executed transactions, as they will share
        # the same `execution_date` that the mined tx
        return queryset

    def get_all_txs_from_hashes(
        self, safe_address: str, hashes_to_search: Sequence[str]
    ) -> List[Union[EthereumTx, MultisigTransaction, ModuleTransaction]]:
        """
        Now that we know how to paginate, we retrieve the real transactions

        :param safe_address:
        :param hashes_to_search:
        :return:
        """
        cached_txs = {
            hash_to_search: cached_tx
            for hash_to_search, cached_tx in zip(
                hashes_to_search,
                self.get_txs_from_cache(safe_address, hashes_to_search),
            )
            if cached_tx
        }
        hashes_not_cached = [
            hash_to_search
            for hash_to_search in hashes_to_search
            if hash_to_search not in cached_txs
        ]
        multisig_txs = {
            multisig_tx.safe_tx_hash: multisig_tx
            for multisig_tx in MultisigTransaction.objects.filter(
                safe=safe_address, safe_tx_hash__in=hashes_not_cached
            )
            .with_confirmations_required()
            .prefetch_related("confirmations")
            .select_related("ethereum_tx__block")
            .order_by("-nonce", "-created")
        }

        module_txs = {
            module_tx.internal_tx.ethereum_tx_id: module_tx
            for module_tx in ModuleTransaction.objects.filter(
                safe=safe_address, internal_tx__ethereum_tx__in=hashes_not_cached
            ).select_related("internal_tx")
        }

        plain_ethereum_txs = {
            ethereum_tx.tx_hash: ethereum_tx
            for ethereum_tx in EthereumTx.objects.filter(
                tx_hash__in=hashes_not_cached
            ).select_related("block")
        }

        # We also need the in/out transfers for the MultisigTxs
        all_hashes = hashes_not_cached + [
            multisig_tx.ethereum_tx_id for multisig_tx in multisig_txs.values()
        ]

        erc20_queryset = (
            ERC20Transfer.objects.to_or_from(safe_address)
            .token_txs()
            .filter(ethereum_tx__in=all_hashes)
        )
        erc721_queryset = (
            ERC721Transfer.objects.to_or_from(safe_address)
            .token_txs()
            .filter(ethereum_tx__in=all_hashes)
        )
        ether_queryset = InternalTx.objects.ether_txs_for_address(safe_address).filter(
            ethereum_tx__in=all_hashes
        )

        # Build dict of transfers for optimizing access
        transfer_dict = defaultdict(list)
        transfers: List[TransferDict] = InternalTx.objects.union_ether_and_token_txs(
            erc20_queryset, erc721_queryset, ether_queryset
        )
        for transfer in transfers:
            transfer_dict[transfer["transaction_hash"]].append(transfer)

        # Add available information about the token on database for the transfers
        tokens = {
            token.address: token
            for token in Token.objects.filter(
                address__in={
                    transfer["token_address"]
                    for transfer in transfers
                    if transfer["token_address"]
                }
            )
        }
        for transfer in transfers:
            transfer["token"] = tokens.get(transfer["token_address"])

        # Build the list
        def get_the_transaction(
            transaction_id: str,
        ) -> Optional[Union[MultisigTransaction, ModuleTransaction, EthereumTx]]:
            if result := cached_txs.get(transaction_id):
                return result

            multisig_tx: MultisigTransaction
            module_tx: ModuleTransaction
            plain_ethereum_tx: EthereumTx
            result: Optional[Union[MultisigTransaction, ModuleTransaction, EthereumTx]]

            if result := multisig_txs.get(transaction_id):
                # Populate transfers
                result.transfers = transfer_dict[result.ethereum_tx_id]
                return result

            if result := module_txs.get(transaction_id):
                result.transfers = transfer_dict[result.internal_tx.ethereum_tx_id]
                return result

            if result := plain_ethereum_txs.get(transaction_id):
                # If no Multisig or Module tx found, fallback to simple tx
                result.transfers = transfer_dict[result.tx_hash]
                return result

            # This cannot happen if logic is ok
            if not result:
                raise ValueError(
                    "Tx not found, problem merging all transactions together"
                )

        hash_with_txs = [
            (hash_to_search, get_the_transaction(hash_to_search))
            for hash_to_search in hashes_to_search
        ]
        self.store_txs_in_cache(safe_address, hash_with_txs)
        return list(
            dict.fromkeys(tx for _, tx in hash_with_txs)
        )  # Sorted already by execution_date

    def serialize_all_txs(
        self, models: List[Union[EthereumTx, MultisigTransaction, ModuleTransaction]]
    ) -> List[Dict[str, Any]]:
        results = []
        for model in models:
            model_type = type(model)
            if model_type == EthereumTx:
                serializer = EthereumTxWithTransfersResponseSerializer
            elif model_type == ModuleTransaction:
                serializer = SafeModuleTransactionWithTransfersResponseSerializer
            elif model_type == MultisigTransaction:
                serializer = SafeMultisigTransactionWithTransfersResponseSerializer
            else:
                raise ValueError(f"Type={model_type} not expected, cannot serialize")
            serialized = serializer(model)
            # serialized.is_valid(raise_exception=True)
            results.append(serialized.data)
        return results

'''
'''--- safe_transaction_service/history/services/webhooks.py ---
import json
from datetime import timedelta
from typing import Any, Dict, List, Type, Union

from django.db.models import Model
from django.utils import timezone

from hexbytes import HexBytes

from safe_transaction_service.history.models import (
    ERC20Transfer,
    ERC721Transfer,
    InternalTx,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    SafeContract,
    TokenTransfer,
    WebHookType,
)
from safe_transaction_service.utils.ethereum import get_ethereum_network

def build_webhook_payload(
    sender: Type[Model],
    instance: Union[
        TokenTransfer, InternalTx, MultisigConfirmation, MultisigTransaction
    ],
) -> List[Dict[str, Any]]:
    """
    :param sender: Sender type
    :param instance: Sender instance
    :return: A list of webhooks generated from the instance provided
    """
    payloads: List[Dict[str, Any]] = []
    if sender == MultisigConfirmation and instance.multisig_transaction_id:
        payloads = [
            {
                "address": instance.multisig_transaction.safe,  # This could make a db call
                "type": WebHookType.NEW_CONFIRMATION.name,
                "owner": instance.owner,
                "safeTxHash": HexBytes(
                    instance.multisig_transaction.safe_tx_hash
                ).hex(),
            }
        ]
    elif sender == MultisigTransaction:
        payload = {
            "address": instance.safe,
            #  'type': None,  It will be assigned later
            "safeTxHash": HexBytes(instance.safe_tx_hash).hex(),
        }
        if instance.executed:
            payload["type"] = WebHookType.EXECUTED_MULTISIG_TRANSACTION.name
            payload["failed"] = json.dumps(
                instance.failed
            )  # Firebase only accepts strings
            payload["txHash"] = HexBytes(instance.ethereum_tx_id).hex()
        else:
            payload["type"] = WebHookType.PENDING_MULTISIG_TRANSACTION.name
        payloads = [payload]
    elif sender == InternalTx and instance.is_ether_transfer:  # INCOMING_ETHER
        incoming_payload = {
            "address": instance.to,
            "type": WebHookType.INCOMING_ETHER.name,
            "txHash": HexBytes(instance.ethereum_tx_id).hex(),
            "value": str(instance.value),
        }
        outgoing_payload = dict(incoming_payload)
        outgoing_payload["type"] = WebHookType.OUTGOING_ETHER.name
        outgoing_payload["address"] = instance._from
        payloads = [incoming_payload, outgoing_payload]
    elif sender in (ERC20Transfer, ERC721Transfer):
        # INCOMING_TOKEN / OUTGOING_TOKEN
        incoming_payload = {
            "address": instance.to,
            "type": WebHookType.INCOMING_TOKEN.name,
            "tokenAddress": instance.address,
            "txHash": HexBytes(instance.ethereum_tx_id).hex(),
        }
        if isinstance(instance, ERC20Transfer):
            incoming_payload["value"] = str(instance.value)
        else:
            incoming_payload["tokenId"] = str(instance.token_id)
        outgoing_payload = dict(incoming_payload)
        outgoing_payload["type"] = WebHookType.OUTGOING_TOKEN.name
        outgoing_payload["address"] = instance._from
        payloads = [incoming_payload, outgoing_payload]
    elif sender == SafeContract:  # Safe created
        payloads = [
            {
                "address": instance.address,
                "type": WebHookType.SAFE_CREATED.name,
                "txHash": HexBytes(instance.ethereum_tx_id).hex(),
                "blockNumber": instance.created_block_number,
            }
        ]
    elif sender == ModuleTransaction:
        payloads = [
            {
                "address": instance.safe,
                "type": WebHookType.MODULE_TRANSACTION.name,
                "module": instance.module,
                "txHash": HexBytes(instance.internal_tx.ethereum_tx_id).hex(),
            }
        ]

    # Add chainId to every payload
    for payload in payloads:
        payload["chainId"] = str(get_ethereum_network().value)

    return payloads

def is_relevant_notification(
    sender: Type[Model],
    instance: Union[
        TokenTransfer, InternalTx, MultisigConfirmation, MultisigTransaction
    ],
    created: bool,
    minutes: int = 60,
) -> bool:
    """
    For `MultisigTransaction`, webhook is valid if the instance was modified in the last `minutes` minutes.
    For the other instances, webhook is valid if the instance was created in the last `minutes` minutes.
    This time restriction is important to prevent sending duplicate transactions when reindexing.

    :param sender:
    :param instance:
    :param created:
    :param minutes: Minutes to allow a old notification
    :return: `True` if webhook is valid, `False` otherwise
    """
    if (
        sender == MultisigTransaction
    ):  # Different logic, as `MultisigTransaction` can change from Pending to Executed
        if instance.modified + timedelta(minutes=minutes) < timezone.now():
            return False
    elif not created:
        return False
    elif instance.created + timedelta(minutes=minutes) < timezone.now():
        return False
    return True

'''
'''--- safe_transaction_service/history/signals.py ---
from logging import getLogger
from typing import Type, Union

from django.db.models import Model
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils import timezone

from safe_transaction_service.notifications.tasks import send_notification_task

from .models import (
    ERC20Transfer,
    ERC721Transfer,
    InternalTx,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    SafeContract,
    SafeLastStatus,
    SafeMasterCopy,
    SafeStatus,
    TokenTransfer,
)
from .services.webhooks import build_webhook_payload, is_relevant_notification
from .tasks import send_webhook_task

logger = getLogger(__name__)

@receiver(
    post_save,
    sender=MultisigConfirmation,
    dispatch_uid="multisig_confirmation.bind_confirmation",
)
@receiver(
    post_save,
    sender=MultisigTransaction,
    dispatch_uid="multisig_transaction.bind_confirmation",
)
def bind_confirmation(
    sender: Type[Model],
    instance: Union[MultisigConfirmation, MultisigTransaction],
    created: bool,
    **kwargs,
) -> None:
    """
    When a `MultisigConfirmation` is saved, it tries to bind it to an existing `MultisigTransaction`, and the opposite.

    :param sender: Could be MultisigConfirmation or MultisigTransaction
    :param instance: Instance of MultisigConfirmation or `MultisigTransaction`
    :param created: `True` if model has just been created, `False` otherwise
    :param kwargs:
    :return:
    """
    if not created:
        return None

    if sender == MultisigTransaction:
        updated = (
            MultisigConfirmation.objects.without_transaction()
            .filter(multisig_transaction_hash=instance.safe_tx_hash)
            .update(multisig_transaction=instance)
        )
        if updated:
            # Update modified on MultisigTransaction if at least one confirmation is added. Tx will now be trusted
            instance.modified = timezone.now()
            instance.trusted = True
            instance.save(update_fields=["modified", "trusted"])
    elif sender == MultisigConfirmation:
        if instance.multisig_transaction_id:
            # Update modified on MultisigTransaction if one confirmation is added. Tx will now be trusted
            MultisigTransaction.objects.filter(
                safe_tx_hash=instance.multisig_transaction_hash
            ).update(modified=instance.created, trusted=True)
        else:
            try:
                if instance.multisig_transaction_hash:
                    multisig_transaction = MultisigTransaction.objects.get(
                        safe_tx_hash=instance.multisig_transaction_hash
                    )
                    multisig_transaction.modified = instance.created
                    multisig_transaction.trusted = True
                    multisig_transaction.save(update_fields=["modified", "trusted"])

                    instance.multisig_transaction = multisig_transaction
                    instance.save(update_fields=["multisig_transaction"])
            except MultisigTransaction.DoesNotExist:
                pass

@receiver(
    post_save,
    sender=SafeMasterCopy,
    dispatch_uid="safe_master_copy.clear_version_cache",
)
def safe_master_copy_clear_cache(
    sender: Type[Model],
    instance: Union[MultisigConfirmation, MultisigTransaction],
    created: bool,
    **kwargs,
) -> None:
    """
    Clear SafeMasterCopy cache if something is modified

    :param sender:
    :param instance:
    :param created:
    :param kwargs:
    :return:
    """
    SafeMasterCopy.objects.get_version_for_address.cache_clear()

@receiver(
    post_save,
    sender=ModuleTransaction,
    dispatch_uid="module_transaction.process_webhook",
)
@receiver(
    post_save,
    sender=MultisigConfirmation,
    dispatch_uid="multisig_confirmation.process_webhook",
)
@receiver(
    post_save,
    sender=MultisigTransaction,
    dispatch_uid="multisig_transaction.process_webhook",
)
@receiver(
    post_save, sender=ERC20Transfer, dispatch_uid="erc20_transfer.process_webhook"
)
@receiver(
    post_save, sender=ERC721Transfer, dispatch_uid="erc721_transfer.process_webhook"
)
@receiver(post_save, sender=InternalTx, dispatch_uid="internal_tx.process_webhook")
@receiver(post_save, sender=SafeContract, dispatch_uid="safe_contract.process_webhook")
def process_webhook(
    sender: Type[Model],
    instance: Union[
        TokenTransfer,
        InternalTx,
        MultisigConfirmation,
        MultisigTransaction,
        SafeContract,
    ],
    created: bool,
    **kwargs,
) -> None:
    logger.debug("Start building payloads for created=%s object=%s", created, instance)
    payloads = build_webhook_payload(sender, instance)
    logger.debug(
        "End building payloads %s for created=%s object=%s", payloads, created, instance
    )
    for payload in payloads:
        if address := payload.get("address"):
            if is_relevant_notification(sender, instance, created):
                logger.debug(
                    "Triggering send_webhook and send_notification tasks for created=%s object=%s",
                    created,
                    instance,
                )
                send_webhook_task.apply_async(
                    args=(address, payload), priority=2  # Almost lowest priority
                )  # Almost the lowest priority
                send_notification_task.apply_async(
                    args=(address, payload),
                    countdown=5,
                    priority=2,  # Almost lowest priority
                )
            else:
                logger.debug(
                    "Notification will not be sent for created=%s object=%s",
                    created,
                    instance,
                )

@receiver(
    post_save,
    sender=SafeLastStatus,
    dispatch_uid="safe_last_status.add_to_historical_table",
)
def add_to_historical_table(
    sender: Type[Model],
    instance: SafeLastStatus,
    created: bool,
    **kwargs,
) -> SafeStatus:
    """
    Add every `SafeLastStatus` entry to `SafeStatus` historical table

    :param sender:
    :param instance:
    :param created:
    :param kwargs:
    :return: SafeStatus
    """
    logger.debug(
        "Storing created=%s object=%s on `SafeStatus` table",
        created,
        instance,
    )
    safe_status = SafeStatus.from_status_instance(instance)
    safe_status.save()
    return safe_status

'''
'''--- safe_transaction_service/history/tasks.py ---
import contextlib
import dataclasses
import json
import random
from functools import cache
from typing import Any, Dict, Optional
from urllib.parse import urlparse

import requests
from celery import app
from celery.utils.log import get_task_logger
from eth_typing import ChecksumAddress
from redis.exceptions import LockError

from safe_transaction_service.utils.redis import get_redis
from safe_transaction_service.utils.utils import close_gevent_db_connection_decorator

from ..utils.tasks import LOCK_TIMEOUT, SOFT_TIMEOUT, only_one_running_task
from .indexers import (
    Erc20EventsIndexerProvider,
    FindRelevantElementsException,
    InternalTxIndexerProvider,
    ProxyFactoryIndexerProvider,
    SafeEventsIndexerProvider,
)
from .indexers.tx_processor import SafeTxProcessor, SafeTxProcessorProvider
from .models import (
    EthereumBlock,
    InternalTxDecoded,
    SafeLastStatus,
    SafeStatus,
    WebHook,
    WebHookType,
)
from .services import (
    CollectiblesServiceProvider,
    IndexingException,
    IndexService,
    IndexServiceProvider,
    ReorgService,
    ReorgServiceProvider,
)
from .services.collectibles_service import (
    Collectible,
    CollectibleWithMetadata,
    MetadataRetrievalExceptionTimeout,
)

logger = get_task_logger(__name__)

@app.shared_task(bind=True, soft_time_limit=SOFT_TIMEOUT, time_limit=LOCK_TIMEOUT)
def check_reorgs_task(self) -> Optional[int]:
    """
    :return: Number of oldest block with reorg detected. `None` if not reorg found
    """
    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            logger.info("Start checking of reorgs")
            reorg_service: ReorgService = ReorgServiceProvider()
            first_reorg_block_number = reorg_service.check_reorgs()
            if first_reorg_block_number:
                logger.warning(
                    "Reorg found for block-number=%d", first_reorg_block_number
                )
                # Stopping running tasks is not possible with gevent
                reorg_service.recover_from_reorg(first_reorg_block_number)
                return first_reorg_block_number

@app.shared_task(soft_time_limit=SOFT_TIMEOUT, time_limit=LOCK_TIMEOUT)
def check_sync_status_task() -> bool:
    """
    Check indexing status of the service
    """
    if not (is_service_synced := IndexServiceProvider().is_service_synced()):
        logger.error("Service is out of sync")

    return is_service_synced

@app.shared_task(
    bind=True,
    soft_time_limit=SOFT_TIMEOUT,
    time_limit=LOCK_TIMEOUT,
    autoretry_for=(IndexingException, IOError),
    default_retry_delay=15,
    retry_kwargs={"max_retries": 3},
)
def index_erc20_events_task(self) -> Optional[int]:
    """
    Find and process ERC20/721 events for monitored addresses

    :return: Number of addresses processed
    """
    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            logger.info("Start indexing of erc20/721 events")
            number_events = Erc20EventsIndexerProvider().start()
            logger.info(
                "Indexing of erc20/721 events task processed %d events", number_events
            )
            return number_events

@app.shared_task
@close_gevent_db_connection_decorator
def index_erc20_events_out_of_sync_task(
    block_process_limit: Optional[int] = None,
    block_process_limit_max: Optional[int] = None,
    addresses: Optional[ChecksumAddress] = None,
    number_of_addresses: Optional[int] = 100,
) -> Optional[int]:
    """
    Find and process ERC20/721 events for monitored addresses out of sync (really behind)

    :return: Number of addresses processed
    """
    erc20_events_indexer = Erc20EventsIndexerProvider()
    if block_process_limit:
        erc20_events_indexer.block_process_limit = block_process_limit
    if block_process_limit_max:
        erc20_events_indexer.block_process_limit_max = block_process_limit_max

    current_block_number = erc20_events_indexer.ethereum_client.current_block_number
    addresses = addresses or [
        x.address
        for x in erc20_events_indexer.get_almost_updated_addresses(
            current_block_number
        )[:number_of_addresses]
    ]

    if not addresses:
        logger.info("No addresses to process")
    else:
        logger.info(
            "Start indexing of erc20/721 events for out of sync addresses %s",
            addresses,
        )
        updated = False
        number_events_processed = 0
        while not updated:
            try:
                events_processed, _, updated = erc20_events_indexer.process_addresses(
                    addresses, current_block_number
                )
                number_events_processed += len(events_processed)
            except FindRelevantElementsException:
                pass

        logger.info(
            "Indexing of erc20/721 events for out of sync addresses task processed %d events",
            number_events_processed,
        )
        return number_events_processed

@app.shared_task(
    bind=True,
    soft_time_limit=SOFT_TIMEOUT,
    time_limit=LOCK_TIMEOUT,
    autoretry_for=(IndexingException, IOError),
    default_retry_delay=15,
    retry_kwargs={"max_retries": 3},
)
def index_internal_txs_task(self) -> Optional[int]:
    """
    Find and process internal txs for monitored addresses
    :return: Number of addresses processed
    """

    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            logger.info("Start indexing of internal txs")
            number_traces = InternalTxIndexerProvider().start()
            logger.info("Find internal txs task processed %d traces", number_traces)
            if number_traces:
                logger.info("Calling task to process decoded traces")
                process_decoded_internal_txs_task.delay()
            return number_traces

@app.shared_task(
    bind=True,
    soft_time_limit=SOFT_TIMEOUT,
    time_limit=LOCK_TIMEOUT,
    autoretry_for=(IndexingException, IOError),
    default_retry_delay=15,
    retry_kwargs={"max_retries": 3},
)
def index_new_proxies_task(self) -> Optional[int]:
    """
    :return: Number of proxies created
    """
    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            logger.info("Start indexing of new proxies")
            number_proxies = ProxyFactoryIndexerProvider().start()
            logger.info("Proxy indexing found %d proxies", number_proxies)
            return number_proxies

@app.shared_task(
    bind=True,
    soft_time_limit=SOFT_TIMEOUT,
    time_limit=LOCK_TIMEOUT,
    autoretry_for=(IndexingException, IOError),
    default_retry_delay=15,
    retry_kwargs={"max_retries": 3},
)
def index_safe_events_task(self) -> Optional[int]:
    """
    Find and process for monitored addresses
    :return: Number of addresses processed
    """

    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            logger.info("Start indexing of Safe events")
            number = SafeEventsIndexerProvider().start()
            logger.info("Find Safe events processed %d events", number)
            if number:
                logger.info("Calling task to process decoded traces")
                process_decoded_internal_txs_task.delay()
            return number

@app.shared_task(bind=True, soft_time_limit=SOFT_TIMEOUT, time_limit=LOCK_TIMEOUT)
def process_decoded_internal_txs_task(self) -> Optional[int]:
    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            count = 0
            for (
                safe_to_process
            ) in InternalTxDecoded.objects.safes_pending_to_be_processed().iterator():
                count += 1
                process_decoded_internal_txs_for_safe_task.delay(
                    safe_to_process, reindex_master_copies=False
                )

            if not count:
                logger.info("No Safes to process")
            else:
                logger.info("%d Safes to process", count)

@app.shared_task(bind=True, soft_time_limit=SOFT_TIMEOUT, time_limit=LOCK_TIMEOUT)
def reindex_last_hours_task(self, hours: int = 2) -> Optional[int]:
    """
    Reindexes last hours for master copies to prevent indexing issues
    """
    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            if ethereum_block := EthereumBlock.objects.oldest_than(
                seconds=60 * 60 * hours
            ).first():
                from_block_number = ethereum_block.number
                to_block_number = (
                    EthereumBlock.objects.order_by("-timestamp").first().number
                )
                assert to_block_number >= from_block_number
                if to_block_number != from_block_number:
                    logger.info(
                        "Reindexing master copies for last %d hours, from-block=%d to-block=%d",
                        hours,
                        from_block_number,
                        to_block_number,
                    )
                    reindex_master_copies_task.delay(from_block_number, to_block_number)
                    logger.info(
                        "Reindexing erc20/721 events for last %d hours, from-block=%d to-block=%d",
                        hours,
                        from_block_number,
                        to_block_number,
                    )
                    reindex_erc20_events_task.delay(from_block_number, to_block_number)

@app.shared_task(bind=True, soft_time_limit=SOFT_TIMEOUT, time_limit=LOCK_TIMEOUT)
def reindex_master_copies_task(
    self, from_block_number: int, to_block_number: int
) -> None:
    """
    Reindexes master copies
    """
    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            index_service = IndexServiceProvider()
            logger.info(
                "Reindexing master copies from-block=%d to-block=%d",
                from_block_number,
                to_block_number,
            )
            index_service.reindex_master_copies(
                from_block_number=from_block_number,
                to_block_number=to_block_number,
            )

@app.shared_task(bind=True, soft_time_limit=SOFT_TIMEOUT, time_limit=LOCK_TIMEOUT)
def reindex_erc20_events_task(
    self, from_block_number: int, to_block_number: int
) -> None:
    """
    Reindexes master copies
    """
    with contextlib.suppress(LockError):
        with only_one_running_task(self):
            index_service = IndexServiceProvider()
            logger.info(
                "Reindexing erc20/721 events from-block=%d to-block=%d",
                from_block_number,
                to_block_number,
            )
            index_service.reindex_erc20_events(
                from_block_number=from_block_number,
                to_block_number=to_block_number,
            )

@app.shared_task(bind=True, soft_time_limit=SOFT_TIMEOUT, time_limit=LOCK_TIMEOUT)
def process_decoded_internal_txs_for_safe_task(
    self, safe_address: ChecksumAddress, reindex_master_copies: bool = True
) -> Optional[int]:
    """
    Process decoded internal txs for one Safe. Processing decoded transactions is very slow and this way multiple
    Safes can be processed at the same time

    :param safe_address:
    :param reindex_master_copies: Trigger auto reindexing if a problem is found
    :return:
    """
    with contextlib.suppress(LockError):
        with only_one_running_task(self, lock_name_suffix=safe_address):
            logger.info(
                "Start processing decoded internal txs for safe %s", safe_address
            )
            tx_processor: SafeTxProcessor = SafeTxProcessorProvider()
            index_service: IndexService = IndexServiceProvider()

            # Check if something is wrong during indexing
            try:
                safe_last_status = SafeLastStatus.objects.get_or_generate(
                    address=safe_address
                )
            except SafeLastStatus.DoesNotExist:
                safe_last_status = None

            if safe_last_status and safe_last_status.is_corrupted():
                try:
                    # Find first corrupted safe status
                    previous_safe_status: Optional[SafeStatus] = None
                    for safe_status in SafeStatus.objects.filter(
                        address=safe_address
                    ).sorted_reverse_by_mined():
                        if safe_status.is_corrupted():
                            message = (
                                f"Safe-address={safe_address} A problem was found in SafeStatus "
                                f"with nonce={safe_status.nonce} "
                                f"on internal-tx-id={safe_status.internal_tx_id} "
                                f"tx-hash={safe_status.internal_tx.ethereum_tx_id} "
                            )
                            logger.error(message)
                            logger.info(
                                "Safe-address=%s Processing traces again",
                                safe_address,
                            )
                            if reindex_master_copies and previous_safe_status:
                                block_number = previous_safe_status.block_number
                                to_block_number = safe_last_status.block_number
                                logger.info(
                                    "Safe-address=%s Last known not corrupted SafeStatus with nonce=%d on block=%d , "
                                    "reindexing until block=%d",
                                    safe_address,
                                    previous_safe_status.nonce,
                                    block_number,
                                    to_block_number,
                                )
                                reindex_master_copies_task.delay(
                                    block_number, to_block_number
                                )
                            logger.info(
                                "Safe-address=%s Processing traces again after reindexing",
                                safe_address,
                            )
                            raise ValueError(message)
                        previous_safe_status = safe_status
                finally:
                    tx_processor.clear_cache(safe_address)
                    index_service.reprocess_addresses([safe_address])

            # Check if a new decoded tx appeared before other already processed (due to a reindex)
            if InternalTxDecoded.objects.out_of_order_for_safe(safe_address):
                tx_processor.clear_cache(safe_address)
                index_service.reprocess_addresses([safe_address])

            # Use iterator for memory issues
            internal_txs_decoded = InternalTxDecoded.objects.pending_for_safe(
                safe_address
            ).iterator()
            number_processed = len(
                tx_processor.process_decoded_transactions(internal_txs_decoded)
            )
            logger.info("Processed %d decoded transactions", number_processed)
            if number_processed:
                logger.info(
                    "%d decoded internal txs successfully processed for safe %s",
                    number_processed,
                    safe_address,
                )
                return number_processed

@cache
def get_webhook_http_session(
    webhook_url: str, authorization: Optional[str]
) -> requests.Session:
    logger.debug("Getting http session for url=%s", webhook_url)
    session = requests.Session()
    if authorization:
        session.headers.update({"Authorization": authorization})
    adapter = requests.adapters.HTTPAdapter(
        pool_connections=1,  # Doing all the connections to the same url
        pool_maxsize=500,  # Number of concurrent connections
        pool_block=False,
    )
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

@app.shared_task(
    autoretry_for=(IOError,), default_retry_delay=15, retry_kwargs={"max_retries": 3}
)
@close_gevent_db_connection_decorator
def send_webhook_task(address: Optional[str], payload: Dict[str, Any]) -> int:
    if not (address and payload):
        return 0

    webhooks = WebHook.objects.matching_for_address(address)
    if not webhooks:
        logger.debug("There is no webhook configured for address=%s", address)
        return 0

    sent_requests = 0
    webhook_type = WebHookType[payload["type"]]
    for webhook in webhooks:
        if not webhook.is_valid_for_webhook_type(webhook_type):
            logger.debug(
                "There is no webhook configured for webhook_type=%s",
                webhook_type.name,
            )
            continue

        full_url = webhook.url
        parsed_url = urlparse(full_url)
        base_url = (
            f"{parsed_url.scheme}://{parsed_url.netloc}"  # Remove url path for logging
        )
        if webhook.address:
            logger.info(
                "Sending webhook for address=%s base-url=%s and payload=%s",
                address,
                base_url,
                payload,
            )
        else:  # Generic WebHook
            logger.info(
                "Sending webhook for base-url=%s and payload=%s", base_url, payload
            )

        r = get_webhook_http_session(full_url, webhook.authorization).post(
            full_url, json=payload, timeout=5
        )
        if r.ok:
            logger.info(
                "Webhook for base-url=%s and payload=%s was sent successfully",
                base_url,
                payload,
            )
        else:
            logger.warning(
                "Webhook failed with status-code=%d posting to url=%s with content=%s",
                r.status_code,
                base_url,
                r.content,
            )

        sent_requests += 1
    return sent_requests

@app.shared_task(
    soft_time_limit=SOFT_TIMEOUT,
    time_limit=LOCK_TIMEOUT,
    max_retries=4,
)
def retry_get_metadata_task(
    address: ChecksumAddress, token_id: int
) -> Optional[CollectibleWithMetadata]:
    """
    Retry to get metadata from an uri that during the first try returned a timeout error.

    :param address: collectible address
    :param token_id: collectible id
    """

    collectibles_service = CollectiblesServiceProvider()
    redis_key = collectibles_service.get_metadata_cache_key(address, token_id)
    redis = get_redis()

    # The collectible is shared with the task using Redis.
    # This prevents having the collectible serialized on Redis and also on RabbitMQ.
    if not (binary_collectible_with_metadata_cached := redis.get(redis_key)):
        # If the collectible doesn't exist means that the cache was removed and should wait for first try from the view.
        return None

    collectible_with_metadata_cached = json.loads(
        binary_collectible_with_metadata_cached
    )

    collectible = Collectible(
        collectible_with_metadata_cached["token_name"],
        collectible_with_metadata_cached["token_symbol"],
        collectible_with_metadata_cached["logo_uri"],
        collectible_with_metadata_cached["address"],
        collectible_with_metadata_cached["id"],
        collectible_with_metadata_cached["uri"],
    )

    # Maybe other task already retrieved the metadata
    cached_metadata = collectible_with_metadata_cached["metadata"]
    try:
        metadata = (
            cached_metadata
            if cached_metadata
            else collectibles_service.get_metadata(collectible)
        )
        collectible_with_metadata = CollectibleWithMetadata(
            collectible.token_name,
            collectible.token_symbol,
            collectible.logo_uri,
            collectible.address,
            collectible.id,
            collectible.uri,
            metadata,
        )
        redis.set(
            redis_key,
            json.dumps(dataclasses.asdict(collectible_with_metadata)),
            collectibles_service.COLLECTIBLE_EXPIRATION,
        )
    except MetadataRetrievalExceptionTimeout:
        # Random avoid to run all tasks at the same time
        if (
            retry_get_metadata_task.request.retries
            < retry_get_metadata_task.max_retries
        ):
            retry_get_metadata_task.retry(
                countdown=int(
                    random.uniform(55, 65) * retry_get_metadata_task.request.retries
                )
            )
        else:
            logger.debug(
                "Timeout when getting metadata from %s after %i retries ",
                collectible.uri,
                retry_get_metadata_task.request.retries,
            )
        return None
    return collectible_with_metadata

'''
'''--- safe_transaction_service/history/tests/__init__.py ---

'''
'''--- safe_transaction_service/history/tests/clients/__init__.py ---

'''
'''--- safe_transaction_service/history/tests/clients/test_ens_client.py ---
from unittest import mock

from django.test import TestCase

from eth_utils import keccak
from requests import Session

from gnosis.eth.ethereum_client import EthereumNetwork

from ...clients import EnsClient

class TestEnsClient(TestCase):
    def test_domain_hash_to_hex_str(self):
        domain_hash_bytes = keccak(text="gnosis")
        domain_hash_int = int.from_bytes(domain_hash_bytes, byteorder="big")

        result = EnsClient.domain_hash_to_hex_str(domain_hash_bytes)
        self.assertEqual(result, EnsClient.domain_hash_to_hex_str(domain_hash_int))
        self.assertEqual(len(result), 66)

        self.assertEqual(len(EnsClient.domain_hash_to_hex_str(b"")), 66)
        self.assertEqual(len(EnsClient.domain_hash_to_hex_str(None)), 66)
        self.assertEqual(len(EnsClient.domain_hash_to_hex_str(2)), 66)

    def test_query_by_account(self):
        ens_client = EnsClient(EthereumNetwork.RINKEBY.value)  # Mainnet
        if not ens_client.is_available():
            self.skipTest("ENS Rinkeby Client is not available")

        self.assertEqual(
            ens_client.query_by_account("0x4323E6b155BCf0b25f8c4C0B37dA808e3550b521"),
            {
                "registrations": [
                    {
                        "expiryDate": "2257309961",
                        "domain": {
                            "labelName": "vivarox",
                            "labelhash": "0x3dad4bca5efcde980e9e7f3a9484749505648542b06c5f4f8b2dbdb767f67ba8",
                            "name": "vivarox.eth",
                            "isMigrated": True,
                            "parent": {"name": "eth"},
                        },
                    },
                    {
                        "expiryDate": "2257310351",
                        "domain": {
                            "labelName": "satoshinakamoto",
                            "labelhash": "0x595165e57d0d5a26f71f2f387c9e8208831fa957a18aad079218ce42a530bc6e",
                            "name": "satoshinakamoto.eth",
                            "isMigrated": True,
                            "parent": {"name": "eth"},
                        },
                    },
                    {
                        "expiryDate": "2320424525",
                        "domain": {
                            "labelName": "vitalik",
                            "labelhash": "0xaf2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc",
                            "name": "vitalik.eth",
                            "isMigrated": True,
                            "parent": {"name": "eth"},
                        },
                    },
                ]
            },
        )

    def test_query_by_domain_hash(self):
        ens_client = EnsClient(EthereumNetwork.MAINNET.value)  # Mainnet
        if not ens_client.is_available():
            self.skipTest("ENS Mainnet Client is not available")

        # Query for gnosis domain
        domain_hash = keccak(text="gnosis")
        self.assertEqual("gnosis", ens_client.query_by_domain_hash(domain_hash))

        domain_hash_2 = keccak(
            text="notverycommon-domain-name-made-up-by-me-with-forbidden-word-Ã±"
        )
        self.assertIsNone(ens_client.query_by_domain_hash(domain_hash_2))

    def test_is_available(self):
        for ethereum_network in (
            EthereumNetwork.ROPSTEN,
            EthereumNetwork.RINKEBY,
            EthereumNetwork.GOERLI,
            EthereumNetwork.MAINNET,
        ):
            with self.subTest(ethereum_network=ethereum_network):
                ens_client = EnsClient(ethereum_network)
                self.assertTrue(ens_client.is_available())
                with mock.patch.object(Session, "get", side_effect=IOError()):
                    self.assertFalse(ens_client.is_available())

'''
'''--- safe_transaction_service/history/tests/factories.py ---
from typing import Any, Dict

from django.utils import timezone

import factory
from eth_account import Account
from factory.django import DjangoModelFactory
from factory.fuzzy import FuzzyInteger
from hexbytes import HexBytes
from web3 import Web3

from gnosis.eth.constants import NULL_ADDRESS
from gnosis.safe.safe_signature import SafeSignatureType

from ..models import (
    ERC20Transfer,
    ERC721Transfer,
    EthereumBlock,
    EthereumTx,
    EthereumTxCallType,
    InternalTx,
    InternalTxDecoded,
    InternalTxType,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    ProxyFactory,
    SafeContract,
    SafeContractDelegate,
    SafeLastStatus,
    SafeMasterCopy,
    SafeStatus,
    TokenTransfer,
    WebHook,
)

class EthereumBlockFactory(DjangoModelFactory):
    class Meta:
        model = EthereumBlock

    number = factory.Sequence(lambda n: n + 1)
    gas_limit = factory.fuzzy.FuzzyInteger(100000000, 200000000)
    gas_used = factory.fuzzy.FuzzyInteger(100000, 500000)
    timestamp = factory.LazyFunction(timezone.now)
    block_hash = factory.Sequence(lambda n: Web3.keccak(text=f"block-{n}").hex())
    parent_hash = factory.Sequence(lambda n: Web3.keccak(text=f"block{n - 1}").hex())

class EthereumTxFactory(DjangoModelFactory):
    class Meta:
        model = EthereumTx

    block = factory.SubFactory(EthereumBlockFactory)
    tx_hash = factory.Sequence(
        lambda n: Web3.keccak(text=f"ethereum_tx_hash-{n}").hex()
    )
    _from = factory.LazyFunction(lambda: Account.create().address)
    gas = factory.fuzzy.FuzzyInteger(1000, 5000)
    gas_price = factory.fuzzy.FuzzyInteger(1, 100)
    max_fee_per_gas = None
    max_priority_fee_per_gas = None
    data = factory.Sequence(lambda n: HexBytes("%x" % (n + 1000)))
    nonce = factory.Sequence(lambda n: n)
    to = factory.LazyFunction(lambda: Account.create().address)
    value = factory.fuzzy.FuzzyInteger(0, 1000)
    logs = factory.LazyFunction(lambda: [])
    type = 0

class TokenTransfer(DjangoModelFactory):
    ethereum_tx = factory.SubFactory(EthereumTxFactory)
    timestamp = factory.SelfAttribute("ethereum_tx.block.timestamp")
    block_number = factory.SelfAttribute("ethereum_tx.block.number")
    log_index = factory.Sequence(lambda n: n)
    address = factory.LazyFunction(lambda: Account.create().address)
    _from = factory.LazyFunction(lambda: Account.create().address)
    to = factory.LazyFunction(lambda: Account.create().address)

    class Meta:
        model = TokenTransfer
        abstract = True

class ERC20TransferFactory(TokenTransfer):
    value = factory.fuzzy.FuzzyInteger(0, 1000)

    class Meta:
        model = ERC20Transfer

class ERC721TransferFactory(TokenTransfer):
    token_id = factory.fuzzy.FuzzyInteger(0, 1000)

    class Meta:
        model = ERC721Transfer

class InternalTxFactory(DjangoModelFactory):
    class Meta:
        model = InternalTx

    ethereum_tx = factory.SubFactory(EthereumTxFactory)
    timestamp = factory.SelfAttribute("ethereum_tx.block.timestamp")
    block_number = factory.SelfAttribute("ethereum_tx.block.number")
    _from = factory.LazyFunction(lambda: Account.create().address)
    gas = factory.fuzzy.FuzzyInteger(1000, 5000)
    data = factory.Sequence(lambda n: HexBytes("%x" % (n + 1000)))
    to = factory.LazyFunction(lambda: Account.create().address)
    value = factory.fuzzy.FuzzyInteger(0, 1000)
    gas_used = factory.fuzzy.FuzzyInteger(1000, 5000)
    contract_address = None
    code = None
    output = None
    refund_address = NULL_ADDRESS
    tx_type = InternalTxType.CALL.value
    call_type = EthereumTxCallType.CALL.value
    trace_address = factory.Sequence(str)
    error = None

class InternalTxDecodedFactory(DjangoModelFactory):
    class Meta:
        model = InternalTxDecoded

    class Params:
        fallback_handler = "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44"
        hash_to_approve = (
            "0x8aca9664752dbae36135fd0956c956fc4a370feeac67485b49bcd4b99608ae41"
        )
        master_copy = "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F"
        module = "0x32E2301B40f8CBE0da4683A60cfB6d3544afec8F"
        old_owner = "0x32E2301B40f8CBE0da4683A60cfB6d3544afec8F"
        owner = "0xbee99d1d38A3FBc03F3EB9339F2E119Ae8E513bA"
        threshold = 1
        transaction = {
            "to": "0xe5738C4cF66f7d288Ef4fe3CaBd678FfB39CFF8A",
            "data": "0x",
            "value": 2345000000000000,
            "baseGas": 0,
            "gasPrice": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "operation": 0,
            "safeTxGas": 0,
            "signatures": "0x0000000000000000000000002d8d6cafa6b8b7eed96c3711734d24df40c121e70000000000000"
            "00000000000000000000000000000000000000000000000000001",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
        }
        module_transaction = {
            "to": "0x14Eac0051a9DcD04D1AaCfDc3606397F3d3ab94C",
            "data": "0xe318b52b000000000000",
            "value": 0,
            "operation": 0,
        }

    internal_tx = factory.SubFactory(InternalTxFactory)
    function_name = factory.fuzzy.FuzzyText(prefix="safe-", suffix="fn")
    processed = False

    @factory.lazy_attribute
    def arguments(self) -> Dict[str, Any]:
        if self.function_name == "addOwnerWithThreshold":
            return {"owner": self.owner, "_threshold": self.threshold}
        elif self.function_name == "approveHash":
            return {"hashToApprove": self.hash_to_approve}
        elif self.function_name == "changeMasterCopy":
            return {"_masterCopy": self.master_copy}
        elif self.function_name == "changeThreshold":
            return {"_threshold": self.threshold}
        elif self.function_name == "disableModule":
            return {
                "module": self.module,
                "prevModule": "0x0000000000000000000000000000000000000001",
            }
        elif self.function_name == "enableModule":
            return {"module": self.module}
        elif self.function_name == "execTransactionFromModule":
            return self.module_transaction
        elif self.function_name == "execTransaction":
            return self.transaction
        elif self.function_name == "removeOwner":
            return {
                "owner": self.old_owner,
                "prevOwner": "0x0000000000000000000000000000000000000001",
                "_threshold": self.threshold,
            }
        elif self.function_name == "setFallbackHandler":
            return {"handler": self.fallback_handler}
        elif self.function_name == "setup":
            return {
                "to": "0x0000000000000000000000000000000000000000",
                "data": "0x",
                "_owners": [self.owner],
                "payment": 0,
                "_threshold": self.threshold,
                "paymentToken": "0x0000000000000000000000000000000000000000",
                "fallbackHandler": self.fallback_handler,
                "paymentReceiver": "0x0000000000000000000000000000000000000000",
            }
        elif self.function_name == "swapOwner":
            return {
                "newOwner": self.owner,
                "oldOwner": self.old_owner,
                "prevOwner": "0x0000000000000000000000000000000000000001",
            }
        else:
            return {}

class ModuleTransactionFactory(DjangoModelFactory):
    class Meta:
        model = ModuleTransaction

    internal_tx = factory.SubFactory(InternalTxFactory)
    safe = factory.LazyFunction(lambda: Account.create().address)
    module = factory.LazyFunction(lambda: Account.create().address)
    to = factory.LazyFunction(lambda: Account.create().address)
    value = FuzzyInteger(low=0, high=10)
    data = factory.Sequence(lambda n: Web3.keccak(text=f"module-tx-{n}"))
    operation = FuzzyInteger(low=0, high=1)
    failed = False

class MultisigTransactionFactory(DjangoModelFactory):
    class Meta:
        model = MultisigTransaction

    safe_tx_hash = factory.Sequence(
        lambda n: Web3.keccak(text=f"multisig-tx-{n}").hex()
    )
    safe = factory.LazyFunction(lambda: Account.create().address)
    ethereum_tx = factory.SubFactory(EthereumTxFactory)
    to = factory.LazyFunction(lambda: Account.create().address)
    value = FuzzyInteger(low=0, high=10)
    data = b""
    operation = 0
    safe_tx_gas = FuzzyInteger(low=400000, high=500000)
    base_gas = FuzzyInteger(low=200000, high=300000)
    gas_price = FuzzyInteger(low=1, high=10)
    gas_token = NULL_ADDRESS
    refund_receiver = NULL_ADDRESS
    signatures = b""
    nonce = factory.Sequence(lambda n: n)
    failed = False
    origin = factory.Faker("name")
    trusted = False

class MultisigConfirmationFactory(DjangoModelFactory):
    class Meta:
        model = MultisigConfirmation

    ethereum_tx = factory.SubFactory(EthereumTxFactory)
    multisig_transaction = factory.SubFactory(MultisigTransactionFactory)
    multisig_transaction_hash = factory.Sequence(
        lambda n: Web3.keccak(text=f"multisig-confirmation-tx-{n}").hex()
    )
    owner = factory.LazyFunction(lambda: Account.create().address)
    signature = None
    signature_type = SafeSignatureType.APPROVED_HASH.value

class SafeContractFactory(DjangoModelFactory):
    class Meta:
        model = SafeContract

    address = factory.LazyFunction(lambda: Account.create().address)
    ethereum_tx = factory.SubFactory(EthereumTxFactory)

class SafeContractDelegateFactory(DjangoModelFactory):
    class Meta:
        model = SafeContractDelegate

    safe_contract = factory.SubFactory(SafeContractFactory)
    delegate = factory.LazyFunction(lambda: Account.create().address)
    delegator = factory.LazyFunction(lambda: Account.create().address)
    label = factory.Faker("name")
    read = True
    write = True

class MonitoredAddressFactory(DjangoModelFactory):
    address = factory.LazyFunction(lambda: Account.create().address)
    initial_block_number = factory.LazyFunction(lambda: 0)
    tx_block_number = factory.LazyFunction(lambda: 0)

class ProxyFactoryFactory(MonitoredAddressFactory):
    class Meta:
        model = ProxyFactory

class SafeMasterCopyFactory(MonitoredAddressFactory):
    version = factory.Sequence(lambda n: f"1.0.{n}")
    deployer = factory.Faker("company")
    l2 = False

    class Meta:
        model = SafeMasterCopy

class SafeLastStatusFactory(DjangoModelFactory):
    class Meta:
        model = SafeLastStatus

    internal_tx = factory.SubFactory(InternalTxFactory)
    address = factory.LazyFunction(lambda: Account.create().address)
    owners = factory.LazyFunction(lambda: [Account.create().address for _ in range(4)])
    threshold = FuzzyInteger(low=1, high=2)
    nonce = factory.Sequence(lambda n: n)
    master_copy = factory.LazyFunction(lambda: Account.create().address)
    fallback_handler = NULL_ADDRESS
    guard = NULL_ADDRESS
    enabled_modules = []

class SafeStatusFactory(SafeLastStatusFactory):
    class Meta:
        model = SafeStatus

class WebHookFactory(DjangoModelFactory):
    class Meta:
        model = WebHook

    address = factory.LazyFunction(lambda: Account.create().address)
    url = factory.Sequence(lambda n: f"http://localhost/test/{n}")
    # Configurable webhook types to listen to
    new_confirmation = True
    pending_multisig_transaction = True
    new_executed_multisig_transaction = True
    new_incoming_transaction = True
    authorization = None

'''
'''--- safe_transaction_service/history/tests/mocks/__init__.py ---

'''
'''--- safe_transaction_service/history/tests/mocks/mocks_ethereum_tx.py ---
from hexbytes import HexBytes

type_0_tx = {
    "tx": {
        "blockHash": HexBytes(
            "0x062b97322d353ee94bea68bf2b131420f399e8dcca74e235fe4ef730f7111691"
        ),
        "blockNumber": 9030821,
        "chainId": "0x4",
        "condition": None,
        "creates": None,
        "from": "0x8305aBB71A2354C98433a82F108Df73820CE3133",
        "gas": 3000000,
        "gasPrice": 1000000000,
        "hash": HexBytes(
            "0xc2f804ef639b534b7cd30bf3062d71baa324233cfdf2f42e62a090aea1606ae2"
        ),
        "input": "0xa9059cbb0000000000000000000000009bc7d0c2850184c5f75f5e3a9e9dec7491f0103a00000000000000000000000000000000000000000000152d02c7e14af6800000",
        "nonce": 1776,
        "publicKey": HexBytes(
            "0xb7fe8abd703add5b75ca3c726980f2fadeb19d3fed6156f4815e00c7bbbe4481d52eeda616f93bcf460406580cb8b5ab0d32a2675b5c4a98f28cc9e1dc921d84"
        ),
        "r": HexBytes(
            "0x9e52b424ed922806e0f73fe835bf22df8caa7c3bcbe23dd6a329899a6c938ca2"
        ),
        "raw": HexBytes(
            "0xf8ab8206f0843b9aca00832dc6c094c666d239cbda32aa7ebca894b6dc598ddb88128580b844a9059cbb0000000000000000000000009bc7d0c2850184c5f75f5e3a9e9dec7491f0103a00000000000000000000000000000000000000000000152d02c7e14af68000002ca09e52b424ed922806e0f73fe835bf22df8caa7c3bcbe23dd6a329899a6c938ca2a0785f6cfd004e1cb617004d9f1357e76f55ff4ecfa24476712784be1d9e297b09"
        ),
        "s": HexBytes(
            "0x785f6cfd004e1cb617004d9f1357e76f55ff4ecfa24476712784be1d9e297b09"
        ),
        "standardV": 1,
        "to": "0xC666d239cbda32AA7ebCA894B6dC598dDb881285",
        "transactionIndex": 30,
        "type": "0x0",
        "v": 44,
        "value": 0,
    },
    "receipt": {
        "blockHash": HexBytes(
            "0x062b97322d353ee94bea68bf2b131420f399e8dcca74e235fe4ef730f7111691"
        ),
        "blockNumber": 9030821,
        "contractAddress": None,
        "cumulativeGasUsed": 10058813,
        "effectiveGasPrice": 1000000000,
        "from": "0x8305aBB71A2354C98433a82F108Df73820CE3133",
        "gasUsed": 34573,
        "logs": [
            {
                "address": "0xC666d239cbda32AA7ebCA894B6dC598dDb881285",
                "blockHash": HexBytes(
                    "0x062b97322d353ee94bea68bf2b131420f399e8dcca74e235fe4ef730f7111691"
                ),
                "blockNumber": 9030821,
                "data": "0x00000000000000000000000000000000000000000000152d02c7e14af6800000",
                "logIndex": 85,
                "removed": False,
                "topics": [
                    HexBytes(
                        "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
                    ),
                    HexBytes(
                        "0x0000000000000000000000008305abb71a2354c98433a82f108df73820ce3133"
                    ),
                    HexBytes(
                        "0x0000000000000000000000009bc7d0c2850184c5f75f5e3a9e9dec7491f0103a"
                    ),
                ],
                "transactionHash": HexBytes(
                    "0xc2f804ef639b534b7cd30bf3062d71baa324233cfdf2f42e62a090aea1606ae2"
                ),
                "transactionIndex": 30,
                "transactionLogIndex": "0x0",
                "type": "mined",
            }
        ],
        "logsBloom": HexBytes(
            "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000010000000000000000000000008010000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000010000000000000000000000000000000000000000008000000008000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000002000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000004000000000000"
        ),
        "status": 1,
        "to": "0xC666d239cbda32AA7ebCA894B6dC598dDb881285",
        "transactionHash": HexBytes(
            "0xc2f804ef639b534b7cd30bf3062d71baa324233cfdf2f42e62a090aea1606ae2"
        ),
        "transactionIndex": 30,
        "type": "0x0",
    },
}

type_2_tx = {
    "tx": {
        "accessList": [],
        "blockHash": HexBytes(
            "0x0113567d08f0fd2f5aef6593aa9055d6fb67af0f2bd63667c6fa06cbbf440b1a"
        ),
        "blockNumber": 10530755,
        "chainId": "0x4",
        "condition": None,
        "creates": None,
        "from": "0xa7a82DD06901F29aB14AF63faF3358AD101724A8",
        "gas": 60000,
        "gasPrice": 2500000022,
        "hash": HexBytes(
            "0x02d70902fed45c6e3dc602d6df9ef19596f3ff7255a6bd261a62b474c95ef232"
        ),
        "input": "0x",
        "maxFeePerGas": 2500000042,
        "maxPriorityFeePerGas": 2500000000,
        "nonce": 4523150,
        "publicKey": HexBytes(
            "0x873c2c1b9852ac9b0de12bafa88cadee81bb9ee549248ba3b250ce0153e277a6233242d2fdc02"
            "eff09c5399f71f25a4c4476517b95124cd0aaad67d3be11fe91"
        ),
        "r": HexBytes(
            "0x0c03fe496f4bf8cfc4ced71044955213d0f3d076460ea45803f219fc89deb424"
        ),
        "raw": HexBytes(
            "0x02f875048345048e849502f900849502f92a82ea6094a417ef0c2ec3d820fbb3d9b6bebc39d35"
            "361584988016345785d8a000080c080a00c03fe496f4bf8cfc4ced71044955213d0f3d076460ea4"
            "5803f219fc89deb424a055604f66eb0800546dcdd38933de856acc2f6ff423ab39bedaa7f2cb968"
            "ea252"
        ),
        "s": HexBytes(
            "0x55604f66eb0800546dcdd38933de856acc2f6ff423ab39bedaa7f2cb968ea252"
        ),
        "to": "0xa417eF0c2ec3D820fbb3d9B6BeBc39d353615849",
        "transactionIndex": 15,
        "type": "0x2",
        "v": 0,
        "value": 100000000000000000,
    },
    "receipt": {
        "blockHash": HexBytes(
            "0x0113567d08f0fd2f5aef6593aa9055d6fb67af0f2bd63667c6fa06cbbf440b1a"
        ),
        "blockNumber": 10530755,
        "contractAddress": None,
        "cumulativeGasUsed": 977116,
        "effectiveGasPrice": 2500000022,
        "from": "0xa7a82DD06901F29aB14AF63faF3358AD101724A8",
        "gasUsed": 21000,
        "logs": [],
        "logsBloom": HexBytes(
            "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ),
        "status": 1,
        "to": "0xa417eF0c2ec3D820fbb3d9B6BeBc39d353615849",
        "transactionHash": HexBytes(
            "0x02d70902fed45c6e3dc602d6df9ef19596f3ff7255a6bd261a62b474c95ef232"
        ),
        "transactionIndex": 15,
        "type": "0x2",
    },
}

'''
'''--- safe_transaction_service/history/tests/mocks/mocks_internal_tx_indexer.py ---
from hexbytes import HexBytes

# Only thing important for the trace filter are the `transactionHash` that will use to call `trace_transaction`
trace_filter_result = [
    {
        "action": {
            "from": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
            "gas": 470747,
            "value": 0,
            "init": HexBytes(
                "0x608060405234801561001057600080fd5b506040516101e73803806101e78339818101604052602081101561003357600080fd5b8101908080519060200190929190505050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156100ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260248152602001806101c36024913960400191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505060aa806101196000396000f3fe608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032496e76616c6964206d617374657220636f707920616464726573732070726f766964656400000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f"
            ),
        },
        "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
        "blockNumber": 6045252,
        "result": {
            "gasUsed": 55109,
            "code": HexBytes(
                "0x608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032"
            ),
            "address": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        },
        "subtraces": 0,
        "traceAddress": [0],
        "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
        "transactionPosition": 0,
        "type": "create",
    },
    {
        "action": {
            "from": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
            "gas": 415719,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xb63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000198c09f30dba1494c741c510400cfe93b82875130000000000000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        },
        "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
        "blockNumber": 6045252,
        "result": {"gasUsed": 150098, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [1],
        "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
        "transactionPosition": 0,
        "type": "call",
    },
    {
        "action": {
            "from": "0x198C09f30dBa1494C741c510400cFE93B8287513",
            "gas": 13077,
            "value": 133700000000000000,
            "callType": "call",
            "input": HexBytes("0x"),
            "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        },
        "blockHash": "0x08df561efd3d242263d8a117e32c1beb08454c87df0a287cf93fa39f0675cf04",
        "blockNumber": 6045275,
        "result": {"gasUsed": 1718, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [],
        "transactionHash": "0xf554b52dcb336b83bf31e7e2e7aa94853a456f01a139a6b7dec71329460dfb61",
        "transactionPosition": 2,
        "type": "call",
    },
]

# trace_blocks 6067026 on Rinkeby
trace_blocks_result = [
    [
        {
            "action": {
                "from": "0xC17E0AeB794Ccf893D77222fbeAe37a4dDf64d7F",
                "gas": 47976,
                "value": 0,
                "callType": "call",
                "input": HexBytes(
                    "0xf5a9f12cbb8d311f2f225bb9d521f5721fcc4d5e7359fd5bac24df62ff62585ffd2441d5ac7923460b1545af06a1a387bb9d87fbb104be9f7feb92d18afae1e7"
                ),
                "to": "0xC17E0AeB794Ccf893D77222fbeAe37a4dDf64d7F",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 0, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [],
            "transactionHash": "0xf65e0ed93640a6405614c6ed6aa3afbe344b01bbb0d75c8d5683eb2317bc24ff",
            "transactionPosition": 0,
            "type": "call",
        },
        {
            "action": {
                "from": "0x15b1A87B648384033fDca1B7656cB534b91ffe56",
                "gas": 4564288,
                "value": 0,
                "init": HexBytes(
                    "0x60806040523480156200001157600080fd5b50604051620014fb380380620014fb83398101604090815281516020808401518385015160608601516080870151336000908152808652968720869055600586905592870180519597909692959181019493019287918791879187916200007e916002918601906200013f565b506003805460ff191660ff84161790558051620000a39060049060208401906200013f565b505060068054600160a060020a0319163317905550508251620000cf91506007906020850190620001c4565b50600090505b6007548110156200013357600160086000600784815481101515620000f657fe5b600091825260208083209190910154600160a060020a031683528201929092526040019020805460ff1916911515919091179055600101620000d5565b50505050505062000271565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106200018257805160ff1916838001178555620001b2565b82800160010185558215620001b2579182015b82811115620001b257825182559160200191906001019062000195565b50620001c09291506200022a565b5090565b8280548282559060005260206000209081019282156200021c579160200282015b828111156200021c5782518254600160a060020a031916600160a060020a03909116178255602090920191600190910190620001e5565b50620001c09291506200024a565b6200024791905b80821115620001c0576000815560010162000231565b90565b6200024791905b80821115620001c0578054600160a060020a031916815560010162000251565b61127a80620002816000396000f3006080604052600436106100fb5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306e48538811461010057806306fdde0314610165578063095ea7b3146101ef57806318160ddd1461022757806323b872dd1461024e578063313ce5671461027857806342966c68146102a3578063449a52f8146102bd57806370a08231146102e15780638da5cb5b14610302578063959b8c3f1461033357806395d89b4114610354578063a0712d6814610369578063a9059cbb14610381578063bcb378fa146103a5578063d95b6371146103c9578063dd62ed3e146103f0578063fad8b32a14610417575b600080fd5b34801561010c57600080fd5b50610115610438565b60408051602080825283518183015283519192839290830191858101910280838360005b83811015610151578181015183820152602001610139565b505050509050019250505060405180910390f35b34801561017157600080fd5b5061017a61049a565b6040805160208082528351818301528351919283929083019185019080838360005b838110156101b457818101518382015260200161019c565b50505050905090810190601f1680156101e15780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156101fb57600080fd5b50610213600160a060020a0360043516602435610525565b604080519115158252519081900360200190f35b34801561023357600080fd5b5061023c610638565b60408051918252519081900360200190f35b34801561025a57600080fd5b50610213600160a060020a036004358116906024351660443561063e565b34801561028457600080fd5b5061028d61083d565b6040805160ff9092168252519081900360200190f35b3480156102af57600080fd5b506102bb600435610846565b005b3480156102c957600080fd5b506102bb600160a060020a0360043516602435610854565b3480156102ed57600080fd5b5061023c600160a060020a03600435166108eb565b34801561030e57600080fd5b50610317610906565b60408051600160a060020a039092168252519081900360200190f35b34801561033f57600080fd5b506102bb600160a060020a0360043516610915565b34801561036057600080fd5b5061017a610a55565b34801561037557600080fd5b506102bb600435610ab0565b34801561038d57600080fd5b50610213600160a060020a0360043516602435610b43565b3480156103b157600080fd5b506102bb600160a060020a0360043516602435610d73565b3480156103d557600080fd5b50610213600160a060020a0360043581169060243516610dde565b3480156103fc57600080fd5b5061023c600160a060020a0360043581169060243516610e80565b34801561042357600080fd5b506102bb600160a060020a0360043516610eab565b6060600780548060200260200160405190810160405280929190818152602001828054801561049057602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311610472575b5050505050905090565b6002805460408051602060018416156101000260001901909316849004601f8101849004840282018401909252818152929183018282801561051d5780601f106104f25761010080835404028352916020019161051d565b820191906000526020600020905b81548152906001019060200180831161050057829003601f168201915b505050505081565b60008115806105555750336000908152600160209081526040808320600160a060020a0387168452909152902054155b15156105d1576040805160e560020a62461bcd02815260206004820152602660248201527f596f752061726520616c726561647920617070726f766520746f20275f73706560448201527f6e646572272e0000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b336000818152600160209081526040808320600160a060020a03881680855290835292819020869055805186815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a350600192915050565b60055481565b600160a060020a0383166000908152602081905260408120548211156106ae576040805160e560020a62461bcd02815260206004820152601060248201527f4e6f7420656e6f7567682066756e647300000000000000000000000000000000604482015290519081900360640190fd5b6106b83385610dde565b151561079257600160a060020a0384166000908152600160209081526040808320338452909152902054821115610739576040805160e560020a62461bcd02815260206004820152601860248201527f4e6f7420656e6f75676820617070726f76652066756e64730000000000000000604482015290519081900360640190fd5b600160a060020a038416600090815260016020908152604080832033845290915290205461076d908363ffffffff610feb16565b600160a060020a03851660009081526001602090815260408083203384529091529020555b600160a060020a0384166000908152602081905260409020546107bb908363ffffffff610feb16565b600160a060020a0380861660009081526020819052604080822093909355908516815220546107f0908363ffffffff610ffd16565b600160a060020a0380851660008181526020818152604091829020949094558051868152905191939288169260008051602061122f83398151915292918290030190a35060019392505050565b60035460ff1681565b610851333383611010565b50565b600654600160a060020a031633146108dc576040805160e560020a62461bcd02815260206004820152602160248201527f4f6e6c79206f776e65722063616e2063616c6c20746869732066756e6374696f60448201527f6e00000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6108e7338383611157565b5050565b600160a060020a031660009081526020819052604090205490565b600654600160a060020a031681565b600160a060020a03811633141561099c576040805160e560020a62461bcd02815260206004820152602860248201527f43616e6e6f7420617574686f72697a6520796f757273656c6620617320616e2060448201527f6f70657261746f72000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a03811660009081526008602052604090205460ff16156109ed57600160a060020a03811660009081526009602090815260408083203384529091529020805460ff19169055610a1c565b600160a060020a0381166000908152600a602090815260408083203384529091529020805460ff191660011790555b6040513390600160a060020a038316907ff4caeb2d6ca8932a215a353d0703c326ec2d81fc68170f320eb2ab49e9df61f990600090a350565b6004805460408051602060026001851615610100026000190190941693909304601f8101849004840282018401909252818152929183018282801561051d5780601f106104f25761010080835404028352916020019161051d565b600654600160a060020a03163314610b38576040805160e560020a62461bcd02815260206004820152602160248201527f4f6e6c79206f776e65722063616e2063616c6c20746869732066756e6374696f60448201527f6e00000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b610851333383611157565b3360009081526020819052604081205481908190841115610bae576040805160e560020a62461bcd02815260206004820152601060248201527f4e6f7420656e6f7567682066756e647300000000000000000000000000000000604482015290519081900360640190fd5b33600090815260208190526040902054853b9250610bd2908563ffffffff610feb16565b3360009081526020819052604080822092909255600160a060020a03871681522054610c04908563ffffffff610ffd16565b600160a060020a038616600090815260208190526040812091909155821115610d3a5750604080517f3b66d02b0000000000000000000000000000000000000000000000000000000081523360048201526024810185905290518591600160a060020a03831691633b66d02b916044808201926020929091908290030181600087803b158015610c9357600080fd5b505af1158015610ca7573d6000803e3d6000fd5b505050506040513d6020811015610cbd57600080fd5b50511515610d3a576040805160e560020a62461bcd028152602060048201526024808201527f436f6e7472616374285f746f29206973206e6f7420737570706f72742065726360448201527f3232332e00000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b604080518581529051600160a060020a03871691339160008051602061122f8339815191529181900360200190a3506001949350505050565b610d7d3383610dde565b1515610dd3576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420616e206f70657261746f720000000000000000000000000000000000604482015290519081900360640190fd5b6108e7338383611010565b600081600160a060020a031683600160a060020a03161480610e255750600160a060020a038084166000908152600a602090815260408083209386168352929052205460ff165b80610e795750600160a060020a03831660009081526008602052604090205460ff168015610e795750600160a060020a0380841660009081526009602090815260408083209386168352929052205460ff16155b9392505050565b600160a060020a03918216600090815260016020908152604080832093909416825291909152205490565b600160a060020a038116331415610f32576040805160e560020a62461bcd02815260206004820152602560248201527f43616e6e6f74207265766f6b6520796f757273656c6620617320616e206f706560448201527f7261746f72000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a03811660009081526008602052604090205460ff1615610f8657600160a060020a03811660009081526009602090815260408083203384529091529020805460ff19166001179055610fb2565b600160a060020a0381166000908152600a602090815260408083203384529091529020805460ff191690555b6040513390600160a060020a038316907f50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa190600090a350565b600082821115610ff757fe5b50900390565b8181018281101561100a57fe5b92915050565b600160a060020a038216600090815260208190526040902054811115611080576040805160e560020a62461bcd02815260206004820152601060248201527f4e6f7420656e6f7567682066756e647300000000000000000000000000000000604482015290519081900360640190fd5b600160a060020a0382166000908152602081905260409020546110a9908263ffffffff610feb16565b600160a060020a0383166000908152602081905260409020556005546110d5908263ffffffff610feb16565b600555604080518281529051600091600160a060020a0385169160008051602061122f8339815191529181900360200190a381600160a060020a031683600160a060020a03167f6ab368f832c266c8eb942b84fbcaa20aedc24a699d2a05fae2568028733b1d09836040518082815260200191505060405180910390a3505050565b600160a060020a038216600090815260208190526040902054611180908263ffffffff610ffd16565b600160a060020a0383166000908152602081905260409020556005546111ac908263ffffffff610ffd16565b600555604080518281529051600160a060020a0384169160009160008051602061122f8339815191529181900360200190a381600160a060020a031683600160a060020a03167f9d228d69b5fdb8d273a2336f8fb8612d039631024ea9bf09c424a9503aa078f0836040518082815260200191505060405180910390a35050505600ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa165627a7a72305820586457ea2e4b7f945fb718570f57c91efd6b4bef7cfae9d10016e81c95ae6d4b0029000000000000000000000000000000000013426172c74d822b878fe80000000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000004444630390000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044446303900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000015b1a87b648384033fdca1b7656cb534b91ffe56"
                ),
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {
                "gasUsed": 1137795,
                "code": HexBytes(
                    "0x6080604052600436106100fb5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306e48538811461010057806306fdde0314610165578063095ea7b3146101ef57806318160ddd1461022757806323b872dd1461024e578063313ce5671461027857806342966c68146102a3578063449a52f8146102bd57806370a08231146102e15780638da5cb5b14610302578063959b8c3f1461033357806395d89b4114610354578063a0712d6814610369578063a9059cbb14610381578063bcb378fa146103a5578063d95b6371146103c9578063dd62ed3e146103f0578063fad8b32a14610417575b600080fd5b34801561010c57600080fd5b50610115610438565b60408051602080825283518183015283519192839290830191858101910280838360005b83811015610151578181015183820152602001610139565b505050509050019250505060405180910390f35b34801561017157600080fd5b5061017a61049a565b6040805160208082528351818301528351919283929083019185019080838360005b838110156101b457818101518382015260200161019c565b50505050905090810190601f1680156101e15780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156101fb57600080fd5b50610213600160a060020a0360043516602435610525565b604080519115158252519081900360200190f35b34801561023357600080fd5b5061023c610638565b60408051918252519081900360200190f35b34801561025a57600080fd5b50610213600160a060020a036004358116906024351660443561063e565b34801561028457600080fd5b5061028d61083d565b6040805160ff9092168252519081900360200190f35b3480156102af57600080fd5b506102bb600435610846565b005b3480156102c957600080fd5b506102bb600160a060020a0360043516602435610854565b3480156102ed57600080fd5b5061023c600160a060020a03600435166108eb565b34801561030e57600080fd5b50610317610906565b60408051600160a060020a039092168252519081900360200190f35b34801561033f57600080fd5b506102bb600160a060020a0360043516610915565b34801561036057600080fd5b5061017a610a55565b34801561037557600080fd5b506102bb600435610ab0565b34801561038d57600080fd5b50610213600160a060020a0360043516602435610b43565b3480156103b157600080fd5b506102bb600160a060020a0360043516602435610d73565b3480156103d557600080fd5b50610213600160a060020a0360043581169060243516610dde565b3480156103fc57600080fd5b5061023c600160a060020a0360043581169060243516610e80565b34801561042357600080fd5b506102bb600160a060020a0360043516610eab565b6060600780548060200260200160405190810160405280929190818152602001828054801561049057602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311610472575b5050505050905090565b6002805460408051602060018416156101000260001901909316849004601f8101849004840282018401909252818152929183018282801561051d5780601f106104f25761010080835404028352916020019161051d565b820191906000526020600020905b81548152906001019060200180831161050057829003601f168201915b505050505081565b60008115806105555750336000908152600160209081526040808320600160a060020a0387168452909152902054155b15156105d1576040805160e560020a62461bcd02815260206004820152602660248201527f596f752061726520616c726561647920617070726f766520746f20275f73706560448201527f6e646572272e0000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b336000818152600160209081526040808320600160a060020a03881680855290835292819020869055805186815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a350600192915050565b60055481565b600160a060020a0383166000908152602081905260408120548211156106ae576040805160e560020a62461bcd02815260206004820152601060248201527f4e6f7420656e6f7567682066756e647300000000000000000000000000000000604482015290519081900360640190fd5b6106b83385610dde565b151561079257600160a060020a0384166000908152600160209081526040808320338452909152902054821115610739576040805160e560020a62461bcd02815260206004820152601860248201527f4e6f7420656e6f75676820617070726f76652066756e64730000000000000000604482015290519081900360640190fd5b600160a060020a038416600090815260016020908152604080832033845290915290205461076d908363ffffffff610feb16565b600160a060020a03851660009081526001602090815260408083203384529091529020555b600160a060020a0384166000908152602081905260409020546107bb908363ffffffff610feb16565b600160a060020a0380861660009081526020819052604080822093909355908516815220546107f0908363ffffffff610ffd16565b600160a060020a0380851660008181526020818152604091829020949094558051868152905191939288169260008051602061122f83398151915292918290030190a35060019392505050565b60035460ff1681565b610851333383611010565b50565b600654600160a060020a031633146108dc576040805160e560020a62461bcd02815260206004820152602160248201527f4f6e6c79206f776e65722063616e2063616c6c20746869732066756e6374696f60448201527f6e00000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6108e7338383611157565b5050565b600160a060020a031660009081526020819052604090205490565b600654600160a060020a031681565b600160a060020a03811633141561099c576040805160e560020a62461bcd02815260206004820152602860248201527f43616e6e6f7420617574686f72697a6520796f757273656c6620617320616e2060448201527f6f70657261746f72000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a03811660009081526008602052604090205460ff16156109ed57600160a060020a03811660009081526009602090815260408083203384529091529020805460ff19169055610a1c565b600160a060020a0381166000908152600a602090815260408083203384529091529020805460ff191660011790555b6040513390600160a060020a038316907ff4caeb2d6ca8932a215a353d0703c326ec2d81fc68170f320eb2ab49e9df61f990600090a350565b6004805460408051602060026001851615610100026000190190941693909304601f8101849004840282018401909252818152929183018282801561051d5780601f106104f25761010080835404028352916020019161051d565b600654600160a060020a03163314610b38576040805160e560020a62461bcd02815260206004820152602160248201527f4f6e6c79206f776e65722063616e2063616c6c20746869732066756e6374696f60448201527f6e00000000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b610851333383611157565b3360009081526020819052604081205481908190841115610bae576040805160e560020a62461bcd02815260206004820152601060248201527f4e6f7420656e6f7567682066756e647300000000000000000000000000000000604482015290519081900360640190fd5b33600090815260208190526040902054853b9250610bd2908563ffffffff610feb16565b3360009081526020819052604080822092909255600160a060020a03871681522054610c04908563ffffffff610ffd16565b600160a060020a038616600090815260208190526040812091909155821115610d3a5750604080517f3b66d02b0000000000000000000000000000000000000000000000000000000081523360048201526024810185905290518591600160a060020a03831691633b66d02b916044808201926020929091908290030181600087803b158015610c9357600080fd5b505af1158015610ca7573d6000803e3d6000fd5b505050506040513d6020811015610cbd57600080fd5b50511515610d3a576040805160e560020a62461bcd028152602060048201526024808201527f436f6e7472616374285f746f29206973206e6f7420737570706f72742065726360448201527f3232332e00000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b604080518581529051600160a060020a03871691339160008051602061122f8339815191529181900360200190a3506001949350505050565b610d7d3383610dde565b1515610dd3576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420616e206f70657261746f720000000000000000000000000000000000604482015290519081900360640190fd5b6108e7338383611010565b600081600160a060020a031683600160a060020a03161480610e255750600160a060020a038084166000908152600a602090815260408083209386168352929052205460ff165b80610e795750600160a060020a03831660009081526008602052604090205460ff168015610e795750600160a060020a0380841660009081526009602090815260408083209386168352929052205460ff16155b9392505050565b600160a060020a03918216600090815260016020908152604080832093909416825291909152205490565b600160a060020a038116331415610f32576040805160e560020a62461bcd02815260206004820152602560248201527f43616e6e6f74207265766f6b6520796f757273656c6620617320616e206f706560448201527f7261746f72000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600160a060020a03811660009081526008602052604090205460ff1615610f8657600160a060020a03811660009081526009602090815260408083203384529091529020805460ff19166001179055610fb2565b600160a060020a0381166000908152600a602090815260408083203384529091529020805460ff191690555b6040513390600160a060020a038316907f50546e66e5f44d728365dc3908c63bc5cfeeab470722c1677e3073a6ac294aa190600090a350565b600082821115610ff757fe5b50900390565b8181018281101561100a57fe5b92915050565b600160a060020a038216600090815260208190526040902054811115611080576040805160e560020a62461bcd02815260206004820152601060248201527f4e6f7420656e6f7567682066756e647300000000000000000000000000000000604482015290519081900360640190fd5b600160a060020a0382166000908152602081905260409020546110a9908263ffffffff610feb16565b600160a060020a0383166000908152602081905260409020556005546110d5908263ffffffff610feb16565b600555604080518281529051600091600160a060020a0385169160008051602061122f8339815191529181900360200190a381600160a060020a031683600160a060020a03167f6ab368f832c266c8eb942b84fbcaa20aedc24a699d2a05fae2568028733b1d09836040518082815260200191505060405180910390a3505050565b600160a060020a038216600090815260208190526040902054611180908263ffffffff610ffd16565b600160a060020a0383166000908152602081905260409020556005546111ac908263ffffffff610ffd16565b600555604080518281529051600160a060020a0384169160009160008051602061122f8339815191529181900360200190a381600160a060020a031683600160a060020a03167f9d228d69b5fdb8d273a2336f8fb8612d039631024ea9bf09c424a9503aa078f0836040518082815260200191505060405180910390a35050505600ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa165627a7a72305820586457ea2e4b7f945fb718570f57c91efd6b4bef7cfae9d10016e81c95ae6d4b0029"
                ),
                "address": "0x0b20e3003c5EE86409a136bEF3891b83d0BB752F",
            },
            "subtraces": 0,
            "traceAddress": [],
            "transactionHash": "0x51418f51ce8ea8763a928a165040622dc82dcf5c73ace3aa2894d61d37a27db6",
            "transactionPosition": 1,
            "type": "create",
        },
        {
            "action": {
                "from": "0xD071B5fCc5476872aB68177BA861ee492296c4Cc",
                "gas": 59527,
                "value": 0,
                "callType": "call",
                "input": HexBytes(
                    "0xc34eaddd000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001040325d3fe000000000000000000000000274489d23600216508b71157f012ed560bc2ebc50000000000000000000000000000000000000000000000000000000000003fffe4bcee55b5b054804fc5395238a96c71647ccbbc7e7b6bb139e79a58cd293bfa00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000041ca6185f8890d78339b9f2e2a3ff128612cb933ce8201e6f4903d9d30c06e90d077cb76cdb7051c811b2dbc9a56e96a6f2dc6290c0f49d75d7c4f5d3eaf3982021c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                ),
                "to": "0xb0F3eAddc0A382B898CF6A03E971aCe9E3830D94",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 58736, "output": HexBytes("0x")},
            "subtraces": 1,
            "traceAddress": [],
            "transactionHash": "0xefb8b297bf871854ecc5f186af967d28afe4376259268817e79a603abefafe6b",
            "transactionPosition": 2,
            "type": "call",
        },
        {
            "action": {
                "from": "0xb0F3eAddc0A382B898CF6A03E971aCe9E3830D94",
                "gas": 55533,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0x0325d3fe000000000000000000000000274489d23600216508b71157f012ed560bc2ebc50000000000000000000000000000000000000000000000000000000000003fffe4bcee55b5b054804fc5395238a96c71647ccbbc7e7b6bb139e79a58cd293bfa00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000041ca6185f8890d78339b9f2e2a3ff128612cb933ce8201e6f4903d9d30c06e90d077cb76cdb7051c811b2dbc9a56e96a6f2dc6290c0f49d75d7c4f5d3eaf3982021c00000000000000000000000000000000000000000000000000000000000000"
                ),
                "to": "0x15e5a50b4b348941ffA6bC214dF6d383Cf4b4944",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 55533, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0],
            "transactionHash": "0xefb8b297bf871854ecc5f186af967d28afe4376259268817e79a603abefafe6b",
            "transactionPosition": 2,
            "type": "call",
        },
        {
            "action": {
                "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
                "gas": 976392,
                "value": 0,
                "callType": "call",
                "input": HexBytes(
                    "0x6a761202000000000000000000000000e5738c4cf66f7d288ef4fe3cabd678ffb39cff8a000000000000000000000000000000000000000000000000000854c3dbff900000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000410000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000"
                ),
                "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {
                "gasUsed": 40133,
                "output": HexBytes(
                    "0x0000000000000000000000000000000000000000000000000000000000000001"
                ),
            },
            "subtraces": 1,
            "traceAddress": [],
            "transactionHash": "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b",
            "transactionPosition": 3,
            "type": "call",
        },
        {
            "action": {
                "from": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
                "gas": 959492,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0x6a761202000000000000000000000000e5738c4cf66f7d288ef4fe3cabd678ffb39cff8a000000000000000000000000000000000000000000000000000854c3dbff900000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000410000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000"
                ),
                "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {
                "gasUsed": 38418,
                "output": HexBytes(
                    "0x0000000000000000000000000000000000000000000000000000000000000001"
                ),
            },
            "subtraces": 1,
            "traceAddress": [0],
            "transactionHash": "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b",
            "transactionPosition": 3,
            "type": "call",
        },
        {
            "action": {
                "from": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
                "gas": 910006,
                "value": 2345000000000000,
                "callType": "call",
                "input": HexBytes("0x"),
                "to": "0xe5738C4cF66f7d288Ef4fe3CaBd678FfB39CFF8A",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 1636, "output": HexBytes("0x")},
            "subtraces": 1,
            "traceAddress": [0, 0],
            "transactionHash": "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b",
            "transactionPosition": 3,
            "type": "call",
        },
        {
            "action": {
                "from": "0xe5738C4cF66f7d288Ef4fe3CaBd678FfB39CFF8A",
                "gas": 894258,
                "value": 2345000000000000,
                "callType": "delegatecall",
                "input": HexBytes("0x"),
                "to": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 40, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0, 0, 0],
            "transactionHash": "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b",
            "transactionPosition": 3,
            "type": "call",
        },
        {
            "action": {
                "from": "0x3233afA02644CCd048587F8ba6e99b3C00A34DcC",
                "gas": 1477996,
                "value": 0,
                "callType": "call",
                "input": HexBytes(
                    "0x68c180d50000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000369e800000000000000000000000000000000000000000000000000000000000000133135363130393031383434383332343731353900000000000000000000000000"
                ),
                "to": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 949489, "output": HexBytes("0x")},
            "subtraces": 1,
            "traceAddress": [],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
                "gas": 1452723,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0x68c180d50000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000369e800000000000000000000000000000000000000000000000000000000000000133135363130393031383434383332343731353900000000000000000000000000"
                ),
                "to": "0x265215c116122869b33962F73CeBE2275c933572",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 947224, "output": HexBytes("0x")},
            "subtraces": 1,
            "traceAddress": [0],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
                "gas": 1427867,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0xa098b5b400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000369e800000000000000000000000000000000000000000000000000000000000000133135363130393031383434383332343731353900000000000000000000000000"
                ),
                "to": "0x42BDd8667c52BB4F09AA443ED4864c1911e9D90A",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 944984, "output": HexBytes("0x")},
            "subtraces": 6,
            "traceAddress": [0, 0],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
                "gas": 1321823,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0xc7bb46ad0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000724d1b69a7ba352f11d73fdbdeb7ff869cb22e19000000000000000000000000e0d7bae200f0994b11423e8be8f386060bbdd8080000000000000000000000000000000000000000000000004563918244f40000"
                ),
                "to": "0x229f5b5A2cFF8C152a888ebE1c2F1eB82546A517",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 97879, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0, 0, 0],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
                "gas": 1222776,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0xc7bb46ad0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000724d1b69a7ba352f11d73fdbdeb7ff869cb22e190000000000000000000000005d4ed2cc2c46f4144ec45c39c5af9b69c7cda8e80000000000000000000000000000000000000000000000004563918244f40000"
                ),
                "to": "0x229f5b5A2cFF8C152a888ebE1c2F1eB82546A517",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 71122, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0, 0, 1],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
                "gas": 1150068,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0xc7bb46ad0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000724d1b69a7ba352f11d73fdbdeb7ff869cb22e19000000000000000000000000230570cd052f40e14c14a81038c6f3aa685d712b0000000000000000000000000000000000000000000000004563918244f40000"
                ),
                "to": "0x229f5b5A2cFF8C152a888ebE1c2F1eB82546A517",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 71122, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0, 0, 2],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
                "gas": 1077361,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0xc7bb46ad0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000724d1b69a7ba352f11d73fdbdeb7ff869cb22e19000000000000000000000000cdd8fa31af8475574b8909f135d510579a8087d30000000000000000000000000000000000000000000000004563918244f40000"
                ),
                "to": "0x229f5b5A2cFF8C152a888ebE1c2F1eB82546A517",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 71122, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0, 0, 3],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
                "gas": 1004653,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0xc7bb46ad0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000724d1b69a7ba352f11d73fdbdeb7ff869cb22e190000000000000000000000003233afa02644ccd048587f8ba6e99b3c00a34dcc0000000000000000000000000000000000000000000000004563918244f40000"
                ),
                "to": "0x229f5b5A2cFF8C152a888ebE1c2F1eB82546A517",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 71122, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0, 0, 4],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0x724D1B69a7Ba352F11D73fDBdEB7fF869cB22E19",
                "gas": 921067,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0xc7bb46ad0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000724d1b69a7ba352f11d73fdbdeb7ff869cb22e19000000000000000000000000e010ac6e0248790e08f42d5f697160dedf97e02400000000000000000000000000000000000000000000000022b1c8c1227a0000"
                ),
                "to": "0x229f5b5A2cFF8C152a888ebE1c2F1eB82546A517",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {"gasUsed": 71122, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0, 0, 5],
            "transactionHash": "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d",
            "transactionPosition": 4,
            "type": "call",
        },
        {
            "action": {
                "from": "0xe09d493Ef62fBd4BD16956e418c27Caee4E52626",
                "gas": 478368,
                "value": 0,
                "callType": "call",
                "input": HexBytes(
                    "0xa9059cbb000000000000000000000000b10a61daa9a87ffcbb444417dd69a3933c617bd60000000000000000000000000000000000000000000000000f67831e74af0000"
                ),
                "to": "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {
                "gasUsed": 15437,
                "output": HexBytes(
                    "0x0000000000000000000000000000000000000000000000000000000000000001"
                ),
            },
            "subtraces": 0,
            "traceAddress": [],
            "transactionHash": "0xc61d773aaa48301c71fc00bb51d554a939b3b9d4c70aab137624661234f82cb0",
            "transactionPosition": 5,
            "type": "call",
        },
    ]
]

trace_blocks_filtered_0x5aC2_result = [
    [
        {
            "action": {
                "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
                "gas": 976392,
                "value": 0,
                "callType": "call",
                "input": HexBytes(
                    "0x6a761202000000000000000000000000e5738c4cf66f7d288ef4fe3cabd678ffb39cff8a000000000000000000000000000000000000000000000000000854c3dbff900000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000410000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000"
                ),
                "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
            },
            "blockHash": "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283",
            "blockNumber": 6067026,
            "result": {
                "gasUsed": 40133,
                "output": HexBytes(
                    "0x0000000000000000000000000000000000000000000000000000000000000001"
                ),
            },
            "subtraces": 1,
            "traceAddress": [],
            "transactionHash": "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b",
            "transactionPosition": 3,
            "type": "call",
        }
    ]
]

# trace_transactions for 0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea
# and 0xf554b52dcb336b83bf31e7e2e7aa94853a456f01a139a6b7dec71329460dfb61 on Rinkeby
trace_transactions_result = [
    [
        {
            "action": {
                "from": "0x198C09f30dBa1494C741c510400cFE93B8287513",
                "gas": 511126,
                "value": 0,
                "callType": "call",
                "input": HexBytes(
                    "0x61b69abd00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000164b63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000198c09f30dba1494c741c510400cfe93b8287513000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                ),
                "to": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
            },
            "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
            "blockNumber": 6045252,
            "result": {
                "gasUsed": 240081,
                "output": HexBytes(
                    "0x000000000000000000000000673fd582fed2cd8201d58552b912f0d1daa37bb2"
                ),
            },
            "subtraces": 2,
            "traceAddress": [],
            "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
            "transactionPosition": 0,
            "type": "call",
        },
        {
            "action": {
                "from": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
                "gas": 470747,
                "value": 0,
                "init": HexBytes(
                    "0x608060405234801561001057600080fd5b506040516101e73803806101e78339818101604052602081101561003357600080fd5b8101908080519060200190929190505050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156100ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260248152602001806101c36024913960400191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505060aa806101196000396000f3fe608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032496e76616c6964206d617374657220636f707920616464726573732070726f766964656400000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f"
                ),
            },
            "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
            "blockNumber": 6045252,
            "result": {
                "gasUsed": 55109,
                "code": HexBytes(
                    "0x608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032"
                ),
                "address": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
            },
            "subtraces": 0,
            "traceAddress": [0],
            "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
            "transactionPosition": 0,
            "type": "create",
        },
        {
            "action": {
                "from": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
                "gas": 415719,
                "value": 0,
                "callType": "call",
                "input": HexBytes(
                    "0xb63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000198c09f30dba1494c741c510400cfe93b82875130000000000000000000000000000000000000000000000000000000000000000"
                ),
                "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
            },
            "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
            "blockNumber": 6045252,
            "result": {"gasUsed": 150098, "output": HexBytes("0x")},
            "subtraces": 1,
            "traceAddress": [1],
            "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
            "transactionPosition": 0,
            "type": "call",
        },
        {
            "action": {
                "from": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
                "gas": 407604,
                "value": 0,
                "callType": "delegatecall",
                "input": HexBytes(
                    "0xb63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000198c09f30dba1494c741c510400cfe93b82875130000000000000000000000000000000000000000000000000000000000000000"
                ),
                "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
            },
            "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
            "blockNumber": 6045252,
            "result": {"gasUsed": 148410, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [1, 0],
            "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
            "transactionPosition": 0,
            "type": "call",
        },
    ],
    [
        {
            "action": {
                "from": "0x198C09f30dBa1494C741c510400cFE93B8287513",
                "gas": 13077,
                "value": 133700000000000000,
                "callType": "call",
                "input": HexBytes("0x"),
                "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
            },
            "blockHash": "0x08df561efd3d242263d8a117e32c1beb08454c87df0a287cf93fa39f0675cf04",
            "blockNumber": 6045275,
            "result": {"gasUsed": 1718, "output": HexBytes("0x")},
            "subtraces": 1,
            "traceAddress": [],
            "transactionHash": "0xf554b52dcb336b83bf31e7e2e7aa94853a456f01a139a6b7dec71329460dfb61",
            "transactionPosition": 2,
            "type": "call",
        },
        {
            "action": {
                "from": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
                "gas": 11315,
                "value": 133700000000000000,
                "callType": "delegatecall",
                "input": HexBytes("0x"),
                "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
            },
            "blockHash": "0x08df561efd3d242263d8a117e32c1beb08454c87df0a287cf93fa39f0675cf04",
            "blockNumber": 6045275,
            "result": {"gasUsed": 93, "output": HexBytes("0x")},
            "subtraces": 0,
            "traceAddress": [0],
            "transactionHash": "0xf554b52dcb336b83bf31e7e2e7aa94853a456f01a139a6b7dec71329460dfb61",
            "transactionPosition": 2,
            "type": "call",
        },
    ],
]

block_child = {
    "author": "0x0000000000000000000000000000000000000000",
    "difficulty": 1,
    "gasLimit": 9990236,
    "gasUsed": 765379,
    "hash": HexBytes(
        "0x08df561efd3d242263d8a117e32c1beb08454c87df0a287cf93fa39f0675cf04"
    ),
    "logsBloom": HexBytes(
        "0x04000000000000400100000002000000004000012000000000000000002000000000000000001010010000000002000010000000024080404000000000800040000000000000400000000008000000200001010000140000182020000000200000000000420000000000000001000c00000200010000000000000010200600000008000400000000000100000000200200100000020000041000000024000200000000000020008000400200000402000000010000800000000080800000401100000002000800000000000000000000010000004005880000000820400020100040100000040000000000200080000000000008000000000000000000000000"
    ),
    "miner": "0x0000000000000000000000000000000000000000",
    "mixHash": HexBytes(
        "0x0000000000000000000000000000000000000000000000000000000000000000"
    ),
    "nonce": HexBytes("0x0000000000000000"),
    "number": 6045275,
    "parentHash": HexBytes(
        "0xe00ebe27186dd315897fe23f102c3828515a98285f9e3a41400d2845154d78a2"
    ),
    "receiptsRoot": HexBytes(
        "0x4f0734766b89d2d2a154b7962fb12a04123b109ea2cb989ccf5bdbd8b2fe3c42"
    ),
    "sealFields": [
        "0xa00000000000000000000000000000000000000000000000000000000000000000",
        "0x880000000000000000",
    ],
    "sha3Uncles": HexBytes(
        "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
    ),
    "size": 4531,
    "stateRoot": HexBytes(
        "0x0a9f60138855264a50b53602a0aa4fca8452646efbed02065eaab27e2ced32b0"
    ),
    "timestamp": 1582819812,
    "totalDifficulty": 10863879,
    "transactions": [
        HexBytes("0xe73443debf4eeb4b413f633697aa5849432bbec970bf403618927e364637716f"),
        HexBytes("0x8be7e3281d9a03257a8c4bedf21a098fc03f6d3cec6e4acdcae565060704872d"),
        HexBytes("0xf554b52dcb336b83bf31e7e2e7aa94853a456f01a139a6b7dec71329460dfb61"),
        HexBytes("0xd740c97fc8c2b8f36113a2e7e048f11111b20ab7127bd807b40c87dc2959df00"),
        HexBytes("0x8da111d5bc99f11d304acfbe1fa9b35d55308281be7ac9ade9151477f91055d6"),
        HexBytes("0x4473cba16b542064484bd0759b7cc567e8a9a78ea25d2ad310b807057a7c297c"),
        HexBytes("0x95780dc747a0d5760995bd5a6d6dfcc569c258560b1a409c5a7c0297b7947095"),
        HexBytes("0xc8f5165706e97df8b87cab3fbbb9df3308ea738763601627d95b4684eaad4644"),
        HexBytes("0xa213f9b612aa5b7ff62dc80fa409f039873fb2d4c9195614fea19b76b13ce6ed"),
        HexBytes("0x2a5fea77c890060b897ef6a50b0470b414a32789fd85346e510e65ab1ebf255f"),
    ],
    "transactionsRoot": HexBytes(
        "0xfb2ac6665384a718b8f77679fe415861436bf509acbddc7c38c1192e96432836"
    ),
    "uncles": [],
}

block_parent = {
    "author": "0x0000000000000000000000000000000000000000",
    "difficulty": 1,
    "proofOfAuthorityData": HexBytes(
        "0xd88301090c846765746888676f312e31332e38856c696e7578000000000000005f130b1ee6f353c659a48aa6bb3d94af0b335d4d8c8c5c5c68ef0c4dcdc5b49b2a0ccd8ed3d115460d53aaa5abcf514c26ccbcdf46cfb82e40f27c288ebf60ac01"
    ),
    "gasLimit": 9999991,
    "gasUsed": 606488,
    "hash": HexBytes(
        "0x3687ab83c99cbe562e3ea07abe2bfb56f082428794635bbd02161b0e2fbaaf8f"
    ),
    "logsBloom": HexBytes(
        "0x0000000000000008000000000000000100c000010000000000000000002000000000008004005000010000000000000008000000004080000000000000000080000008000000000000000008000000000001000000140000180000000000000000000000400000000000000000000400000200010000000002000010200000000000000000400000000100002000200000000000000000000000000000000004000000000000008000400200000402000000010040000000000000000000001100000002000000000000000000000000010000004081001000020800400000100000004000040000000000000020000000000008000000001000000000000000"
    ),
    "miner": "0x0000000000000000000000000000000000000000",
    "number": 6045276,
    "parentHash": HexBytes(
        "0x08df561efd3d242263d8a117e32c1beb08454c87df0a287cf93fa39f0675cf04"
    ),
    "receiptsRoot": HexBytes(
        "0x006f73b73923c2e57aae42edd7fc53a88f7645be3bd5d37c06d77dbf5391e070"
    ),
    "sealFields": [
        "0xa00000000000000000000000000000000000000000000000000000000000000000",
        "0x880000000000000000",
    ],
    "sha3Uncles": HexBytes(
        "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
    ),
    "size": 3652,
    "stateRoot": HexBytes(
        "0x697ae117f2a4b6a7057201a394ccd28b0bd37fcdaf4bd1dc7c1b182fcd1f4124"
    ),
    "timestamp": 1582819827,
    "totalDifficulty": 10863880,
    "transactions": [
        HexBytes("0xe42fb519034e4aebd184d8a12e059e3b036c29eff550fb4751ef053876a8dfa4"),
        HexBytes("0xbd7d0b56cf43c10c89a50b14c53b896fef7edfb3924c0722899b3b647ed1d4d6"),
        HexBytes("0x2e9a1b22a96792fcda0f272b7a8608ff436dc54bc5534c5f7a18884c145e98dd"),
        HexBytes("0xebd17b04093ad424c499521d68925688a36731620a5363950d7667729b2fa0f3"),
        HexBytes("0x6ca6c1a48498afd01907c2949c35c9330a8b8ad9b896bf98e586402860a2df45"),
        HexBytes("0x2fe4a6800823519b1103237b9bc7125ba429345ada58bfed4719fe11e553086d"),
        HexBytes("0xc858fbda92cc53ad7dde47ce1414b53679df59fb51c7ddccda1faef381e21cf8"),
    ],
    "transactionsRoot": HexBytes(
        "0xc7e733bd4a133a6bcce45e6d58a82a8556326c17be5bf1ed6f9e852145d8a064"
    ),
    "uncles": [],
}

block_result = [
    block_child,
    {
        "author": "0x0000000000000000000000000000000000000000",
        "difficulty": 1,
        "gasLimit": 10003834,
        "gasUsed": 2405566,
        "hash": HexBytes(
            "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283"
        ),
        "logsBloom": HexBytes(
            "0x0000000040004008000001000000000300000002100800000000000004100000000000010400000000000000000000000800000000008100000000200004008000000000000000002000000800000040000000080004020080010000000000002020004402000000001000000000080000000100000000000200001000000000000000000010000010000000a000000000000000000000000000000001000000000000000000000000000000000004400000000000000000000000000000000000000003000800000000000400000001000000000180000000020800000060000000004021000000000801010000000008000000000010024000000000000002"
        ),
        "miner": "0x0000000000000000000000000000000000000000",
        "mixHash": HexBytes(
            "0x0000000000000000000000000000000000000000000000000000000000000000"
        ),
        "nonce": HexBytes("0x0000000000000000"),
        "number": 6067026,
        "parentHash": HexBytes(
            "0xb7fa22be4fdc62780e022b8c66d38f4af39208cdeaa7da132cf0bc2576436b21"
        ),
        "receiptsRoot": HexBytes(
            "0x66a8961fcc5d2130298eb6caa061bee57f5582c357392e4a03803923e7c81128"
        ),
        "sealFields": [
            "0xa00000000000000000000000000000000000000000000000000000000000000000",
            "0x880000000000000000",
        ],
        "sha3Uncles": HexBytes(
            "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
        ),
        "size": 8093,
        "stateRoot": HexBytes(
            "0xf4a52396ef0a1e5f1b35d1e21cb5313e0e51b183871da70ced7da5025fc645b4"
        ),
        "timestamp": 1583146255,
        "totalDifficulty": 10893697,
        "transactions": [
            HexBytes(
                "0xf65e0ed93640a6405614c6ed6aa3afbe344b01bbb0d75c8d5683eb2317bc24ff"
            ),
            HexBytes(
                "0x51418f51ce8ea8763a928a165040622dc82dcf5c73ace3aa2894d61d37a27db6"
            ),
            HexBytes(
                "0xefb8b297bf871854ecc5f186af967d28afe4376259268817e79a603abefafe6b"
            ),
            HexBytes(
                "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b"
            ),
            HexBytes(
                "0x34d153cd5d0a9bbda4a6bf135ed8b1372cf224765579d986edd1a7f9c9633f1d"
            ),
            HexBytes(
                "0xc61d773aaa48301c71fc00bb51d554a939b3b9d4c70aab137624661234f82cb0"
            ),
        ],
        "transactionsRoot": HexBytes(
            "0xec62da89ece444f7d908f92ed3f449e6609bf4750a267447aacd819e44a53a2b"
        ),
        "uncles": [],
    },
    {
        "author": "0x0000000000000000000000000000000000000000",
        "difficulty": 2,
        "gasLimit": 10000000,
        "gasUsed": 518179,
        "hash": HexBytes(
            "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923"
        ),
        "logsBloom": HexBytes(
            "0x0001000000000008000400000000000100000000000000000000000000000000000000000400000000100000001000000800000000000008000000000020008000000000000000000000000800000000000000010000000000000000000000000000000000000000000000000200000400000000000000800200001000000000000000000000000000000000200000000000100000000004000000000c000000000000000020000000002000000600000000000000000200000000000000000000000002000000000000000000000000000100000080080080000000000000002000004000000000000000200000004000000000000000000000000000800000"
        ),
        "miner": "0x0000000000000000000000000000000000000000",
        "mixHash": HexBytes(
            "0x0000000000000000000000000000000000000000000000000000000000000000"
        ),
        "nonce": HexBytes("0x0000000000000000"),
        "number": 6045252,
        "parentHash": HexBytes(
            "0x4f303258046f61f34fdc2498df3bc941c7d5c289f35fbd7db1301a17d573d303"
        ),
        "receiptsRoot": HexBytes(
            "0x9a1b95b8483f5ffc3fc1fbf8616594ad89a17275f86728410e84b2601a035ae1"
        ),
        "sealFields": [
            "0xa00000000000000000000000000000000000000000000000000000000000000000",
            "0x880000000000000000",
        ],
        "sha3Uncles": HexBytes(
            "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
        ),
        "size": 2440,
        "stateRoot": HexBytes(
            "0x516e1d580931160fed498af46951958cf35f5bf82f140696ec33b8e707b5a2bd"
        ),
        "timestamp": 1582819467,
        "totalDifficulty": 10863846,
        "transactions": [
            HexBytes(
                "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea"
            ),
            HexBytes(
                "0xd020b3807f87a0ca7392209b09c822281ab6abb28fe81718aa14afea28ed5962"
            ),
            HexBytes(
                "0xf67735eb33bf983b5585541fa69078cbbf31e7f8bdc5544e9b3d04405348744e"
            ),
            HexBytes(
                "0x59b87e5d93185a7d5c79771cf380342d2ccac60bd8aaa7ec5081dc633111e328"
            ),
            HexBytes(
                "0x6f576357733618b328e14518d3bf2940427fbd74945ed1abcce0b6147fb631e7"
            ),
            HexBytes(
                "0x0af66669ae391e3762d7993b039962c4105594387be0c9e0ca0d8ba0ef44f7e0"
            ),
        ],
        "transactionsRoot": HexBytes(
            "0x1284b972b8e1ead0533c425d2ece1640dcceafb72366aa2f997681fd7171d12d"
        ),
        "uncles": [],
    },
]

transactions_result = [
    {
        "blockHash": HexBytes(
            "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923"
        ),
        "blockNumber": 6045252,
        "chainId": "0x4",
        "condition": None,
        "creates": None,
        "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
        "gas": 534974,
        "gasPrice": 4000000000,
        "hash": HexBytes(
            "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea"
        ),
        "input": "0x61b69abd00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000164b63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf4400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "nonce": 383,
        "publicKey": HexBytes(
            "0x5848c6556133fcb815b2b5f7dc7ef966c84997c00970176980962f00b107448bfc0b2d2270d758259526afb906f27485d9be235f842a205067a857b9935e6633"
        ),
        "r": HexBytes(
            "0xb851af4de5e696451bf8c4351e24ea6f6a14ccb980115867b525885b4f7ef445"
        ),
        "raw": HexBytes(
            "0xf9024c82017f84ee6b2800830829be9476e2cfc1f5fa8f6a5b3fc4c8f4788f0116861f9b80b901e461b69abd00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000164b63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf4400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002ca0b851af4de5e696451bf8c4351e24ea6f6a14ccb980115867b525885b4f7ef445a07c06da6780e24fa74788f4c90bf023107df4353c70ba42e52a1fd2b10e743e87"
        ),
        "s": HexBytes(
            "0x7c06da6780e24fa74788f4c90bf023107df4353c70ba42e52a1fd2b10e743e87"
        ),
        "standardV": 1,
        "to": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "transactionIndex": 0,
        "v": 44,
        "value": 0,
    },
    {
        "blockHash": HexBytes(
            "0x08df561efd3d242263d8a117e32c1beb08454c87df0a287cf93fa39f0675cf04"
        ),
        "blockNumber": 6045275,
        "chainId": "0x4",
        "condition": None,
        "creates": None,
        "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
        "gas": 34077,
        "gasPrice": 5000000000,
        "hash": HexBytes(
            "0xf554b52dcb336b83bf31e7e2e7aa94853a456f01a139a6b7dec71329460dfb61"
        ),
        "input": "0x",
        "nonce": 384,
        "publicKey": HexBytes(
            "0x5848c6556133fcb815b2b5f7dc7ef966c84997c00970176980962f00b107448bfc0b2d2270d758259526afb906f27485d9be235f842a205067a857b9935e6633"
        ),
        "r": HexBytes(
            "0xbf9deafa678debae1daaa568ff90fbd7ca92ac299b7dc7288036636bd30ea7fd"
        ),
        "raw": HexBytes(
            "0xf86e82018085012a05f20082851d94673fd582fed2cd8201d58552b912f0d1daa37bb28801daff710e784000802ba0bf9deafa678debae1daaa568ff90fbd7ca92ac299b7dc7288036636bd30ea7fda07fb6477909024dc65bd202596154cb0e6df5e59e6a5bcfda24d933f83c6a7a03"
        ),
        "s": HexBytes(
            "0x7fb6477909024dc65bd202596154cb0e6df5e59e6a5bcfda24d933f83c6a7a03"
        ),
        "standardV": 0,
        "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        "transactionIndex": 2,
        "v": 43,
        "value": 133700000000000000,
    },
    {
        "blockHash": HexBytes(
            "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283"
        ),
        "blockNumber": 6067026,
        "chainId": "0x4",
        "condition": None,
        "creates": None,
        "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
        "gas": 1000000,
        "gasPrice": 1000000000,
        "hash": HexBytes(
            "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b"
        ),
        "input": "0x6a761202000000000000000000000000e5738c4cf66f7d288ef4fe3cabd678ffb39cff8a000000000000000000000000000000000000000000000000000854c3dbff900000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000410000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000",
        "nonce": 385,
        "publicKey": HexBytes(
            "0x5848c6556133fcb815b2b5f7dc7ef966c84997c00970176980962f00b107448bfc0b2d2270d758259526afb906f27485d9be235f842a205067a857b9935e6633"
        ),
        "r": HexBytes(
            "0x31ae56587fb376fdfdd9fd303e86bc78cd4248575b7e9262518a46c983a4bfb4"
        ),
        "raw": HexBytes(
            "0xf9024c820181843b9aca00830f424094673fd582fed2cd8201d58552b912f0d1daa37bb280b901e46a761202000000000000000000000000e5738c4cf66f7d288ef4fe3cabd678ffb39cff8a000000000000000000000000000000000000000000000000000854c3dbff900000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000410000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002ca031ae56587fb376fdfdd9fd303e86bc78cd4248575b7e9262518a46c983a4bfb4a01218c330d8ecea4494521a61b532951f7aa77ac95607eda6d5f6ec846c0c5a76"
        ),
        "s": HexBytes(
            "0x1218c330d8ecea4494521a61b532951f7aa77ac95607eda6d5f6ec846c0c5a76"
        ),
        "standardV": 1,
        "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        "transactionIndex": 3,
        "v": 44,
        "value": 0,
    },
]

transaction_receipts_result = [
    {
        "blockHash": HexBytes(
            "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923"
        ),
        "blockNumber": 6045252,
        "contractAddress": None,
        "cumulativeGasUsed": 263929,
        "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
        "gasUsed": 263929,
        "logs": [
            {
                "address": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
                "blockHash": HexBytes(
                    "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923"
                ),
                "blockNumber": 6045252,
                "data": "0x000000000000000000000000673fd582fed2cd8201d58552b912f0d1daa37bb2",
                "logIndex": 0,
                "removed": False,
                "topics": [
                    HexBytes(
                        "0xa38789425dbeee0239e16ff2d2567e31720127fbc6430758c1a4efc6aef29f80"
                    )
                ],
                "transactionHash": HexBytes(
                    "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea"
                ),
                "transactionIndex": 0,
                "transactionLogIndex": "0x0",
                "type": "mined",
            }
        ],
        "logsBloom": HexBytes(
            "0x00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000004000000000000000000000000000000000"
        ),
        "status": 1,
        "to": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "transactionHash": HexBytes(
            "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea"
        ),
        "transactionIndex": 0,
    },
    {
        "blockHash": HexBytes(
            "0x08df561efd3d242263d8a117e32c1beb08454c87df0a287cf93fa39f0675cf04"
        ),
        "blockNumber": 6045275,
        "contractAddress": None,
        "cumulativeGasUsed": 95430,
        "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
        "gasUsed": 22718,
        "logs": [],
        "logsBloom": HexBytes(
            "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ),
        "status": 1,
        "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        "transactionHash": HexBytes(
            "0xf554b52dcb336b83bf31e7e2e7aa94853a456f01a139a6b7dec71329460dfb61"
        ),
        "transactionIndex": 2,
    },
    {
        "blockHash": HexBytes(
            "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283"
        ),
        "blockNumber": 6067026,
        "contractAddress": None,
        "cumulativeGasUsed": 1442004,
        "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
        "gasUsed": 63741,
        "logs": [
            {
                "address": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
                "blockHash": HexBytes(
                    "0x842df51860be4dc03bbd1a08812f13db00bfe70cdaa0f68b3b29facb1a5bf283"
                ),
                "blockNumber": 6067026,
                "data": "0x2c33121a2f432d6cec593c2d756bd8d69a4833eb55ae993428cf50c748a1ab4d0000000000000000000000000000000000000000000000000000000000000000",
                "logIndex": 1,
                "removed": False,
                "topics": [
                    HexBytes(
                        "0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e"
                    )
                ],
                "transactionHash": HexBytes(
                    "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b"
                ),
                "transactionIndex": 3,
                "transactionLogIndex": "0x0",
                "type": "mined",
            }
        ],
        "logsBloom": HexBytes(
            "0x00000000400000000000000000000000000000001000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ),
        "status": 1,
        "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        "transactionHash": HexBytes(
            "0x304fa041d09c6d61295d479e4d0d0ac93f957c048feaf61e18d8322ec379fd3b"
        ),
        "transactionIndex": 3,
    },
]

'''
'''--- safe_transaction_service/history/tests/mocks/traces.py ---
from hexbytes import HexBytes

from gnosis.eth.tests.mocks.mock_internal_txs import creation_internal_txs  # noqa

create_trace = {
    "action": {
        "from": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "gas": 470747,
        "value": 0,
        "init": HexBytes(
            "0x608060405234801561001057600080fd5b506040516101e73803806101e78339818101604052602081101561003357600080fd5b8101908080519060200190929190505050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156100ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260248152602001806101c36024913960400191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505060aa806101196000396000f3fe608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032496e76616c6964206d617374657220636f707920616464726573732070726f766964656400000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f"
        ),
    },
    "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
    "blockNumber": 6045252,
    "result": {
        "gasUsed": 55109,
        "code": HexBytes(
            "0x608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032"
        ),
        "address": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
    },
    "subtraces": 0,
    "traceAddress": [],
    "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
    "transactionPosition": 0,
    "type": "create",
}

call_trace = {
    "action": {
        "from": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        "gas": 415719,
        "value": 0,
        "callType": "call",
        "input": HexBytes(
            "0xb63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000198c09f30dba1494c741c510400cfe93b82875130000000000000000000000000000000000000000000000000000000000000000"
        ),
        "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
    },
    "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
    "blockNumber": 6045252,
    "result": {"gasUsed": 150098, "output": HexBytes("0x")},
    "subtraces": 1,
    "traceAddress": [0],
    "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
    "transactionPosition": 0,
    "type": "call",
}

rinkeby_traces = [
    {
        "action": {
            "from": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e",
            "gas": 511126,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x61b69abd00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000164b63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf4400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
        },
        "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
        "blockNumber": 6045252,
        "result": {
            "gasUsed": 240081,
            "output": HexBytes(
                "0x000000000000000000000000673fd582fed2cd8201d58552b912f0d1daa37bb2"
            ),
        },
        "subtraces": 2,
        "traceAddress": [],
        "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
        "transactionPosition": 0,
        "type": "call",
    },
    {
        "action": {
            "from": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
            "gas": 470747,
            "value": 0,
            "init": HexBytes(
                "0x608060405234801561001057600080fd5b506040516101e73803806101e78339818101604052602081101561003357600080fd5b8101908080519060200190929190505050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156100ca576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260248152602001806101c36024913960400191505060405180910390fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505060aa806101196000396000f3fe608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032496e76616c6964206d617374657220636f707920616464726573732070726f766964656400000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f"
            ),
        },
        "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
        "blockNumber": 6045252,
        "result": {
            "gasUsed": 55109,
            "code": HexBytes(
                "0x608060405273ffffffffffffffffffffffffffffffffffffffff600054167fa619486e0000000000000000000000000000000000000000000000000000000060003514156050578060005260206000f35b3660008037600080366000845af43d6000803e60008114156070573d6000fd5b3d6000f3fea265627a7a72315820d8a00dc4fe6bf675a9d7416fc2d00bb3433362aa8186b750f76c4027269667ff64736f6c634300050e0032"
            ),
            "address": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        },
        "subtraces": 0,
        "traceAddress": [0],
        "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
        "transactionPosition": 0,
        "type": "create",
    },
    {
        "action": {
            "from": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
            "gas": 415719,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xb63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf4400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e0000000000000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
        },
        "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
        "blockNumber": 6045252,
        "result": {"gasUsed": 150098, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [1],
        "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
        "transactionPosition": 0,
        "type": "call",
    },
    {
        "action": {
            "from": "0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2",
            "gas": 407604,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0xb63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf4400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000005ac255889882acd3da2aa939679e3f3d4cea221e0000000000000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        },
        "blockHash": "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
        "blockNumber": 6045252,
        "result": {"gasUsed": 148410, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [1, 0],
        "transactionHash": "0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea",
        "transactionPosition": 0,
        "type": "call",
    },
]

module_traces = [
    {
        "action": {
            "from": "0x32cA2c42e3CA59f5785711dc81Ae92ea99FB763e",
            "gas": 7978200,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x1068361f0000000000000000000000000411cd48bb8f5a29eb2e5917df40521b70902ff6000000000000000000000000beb32aa1b171acf79951c4e96e0312f85e1e8ad6"
            ),
            "to": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 878006, "output": HexBytes("0x")},
        "subtraces": 8,
        "traceAddress": [],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
            "gas": 7847083,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x95a2251f0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f"
            ),
            "to": "0x03967E5b71577ba3498E1a87E425139B22B3c085",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 369851, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x03967E5b71577ba3498E1a87E425139B22B3c085",
            "gas": 7722909,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x95a2251f0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f"
            ),
            "to": "0xe657230ee18aAFAD1fcdBAE1eefFa90e07b46dc5",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 368220, "output": HexBytes("0x")},
        "subtraces": 5,
        "traceAddress": [0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x03967E5b71577ba3498E1a87E425139B22B3c085",
            "gas": 7599629,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x2f54bf6e000000000000000000000000713d07e8f9f7d1d6fa486dfc152e419b9dfd954e"
            ),
            "to": "0x1f8eaD1e6e10e6856d68be2217EDDC71D8b4eC87",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 2991,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x1f8eaD1e6e10e6856d68be2217EDDC71D8b4eC87",
            "gas": 7479321,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x2f54bf6e000000000000000000000000713d07e8f9f7d1d6fa486dfc152e419b9dfd954e"
            ),
            "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1357,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x03967E5b71577ba3498E1a87E425139B22B3c085",
            "gas": 7592242,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a082310000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87"
            ),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 7326,
            "output": HexBytes(
                "0x00000000000000000000000000000000000000000000000000012c64767da069"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7471272,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x0933c1ed0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002470a082310000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec8700000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 4210,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000012c64767da069"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 1, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7352083,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x70a082310000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87"
            ),
            "to": "0xbB8bE4772fAA655C255309afc3c5207aA7b896Fd",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1253,
            "output": HexBytes(
                "0x00000000000000000000000000000000000000000000000000012c64767da069"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 1, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x03967E5b71577ba3498E1a87E425139B22B3c085",
            "gas": 7581011,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x468721a70000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024db006a7500000000000000000000000000000000000000000000000000012c64767da06900000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x1f8eaD1e6e10e6856d68be2217EDDC71D8b4eC87",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 304707,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 2],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x1f8eaD1e6e10e6856d68be2217EDDC71D8b4eC87",
            "gas": 7460962,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x468721a70000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024db006a7500000000000000000000000000000000000000000000000000012c64767da06900000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 303040,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 2, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x1f8eaD1e6e10e6856d68be2217EDDC71D8b4eC87",
            "gas": 7341831,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xdb006a7500000000000000000000000000000000000000000000000000012c64767da069"
            ),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 299095,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 2, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7224785,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0xdb006a7500000000000000000000000000000000000000000000000000012c64767da069"
            ),
            "to": "0xbB8bE4772fAA655C255309afc3c5207aA7b896Fd",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 296414,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 13,
        "traceAddress": [0, 0, 2, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7102747,
            "value": 0,
            "callType": "call",
            "input": HexBytes("0x9f678cca"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 33074,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 2, 0, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
            "gas": 6976128,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xf24e23eb000000000000000000000000a950524441892a31ebddf91d3ceefa04bf454466000000000000000000000000197e90f9fad81970ba7976f33cbd77088e5d7cf70000000000000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 12764, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7067461,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x0bebac860000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643"
            ),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1215,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000c3135bd08061bcc1424a7a"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7064662,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes("0xc92aecc4"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1093,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 2],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7059396,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x15f24053000000000000000000000000000000000000000000c696b0665921cd67e40da4000000000000000000000000000000000000000002a67c2fb2ae20bc971bd3d4000000000000000000000000000000000000000000007c61301c409f4eace0c4"
            ),
            "to": "0xfeD941d39905B23D6FAf02C8301d40bD4834E27F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 3881,
            "output": HexBytes(
                "0x00000000000000000000000000000000000000000000000000000004492f33e2"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 3],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7021182,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x0bebac860000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643"
            ),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1215,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000c3135bd08061bcc1424a7a"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 4],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7018384,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes("0xc92aecc4"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1093,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 5],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 7010175,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xeabe7d910000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec8700000000000000000000000000000000000000000000000000012c64767da069"
            ),
            "to": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 63041,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 2, 0, 0, 0, 6],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6898850,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0xeabe7d910000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec8700000000000000000000000000000000000000000000000000012c64767da069"
            ),
            "to": "0x7b5e3521a049C8fF88e6349f33044c6Cc33c113c",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 61051,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 4,
        "traceAddress": [0, 0, 2, 0, 0, 0, 6, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6785170,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes("0x18160ddd"),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1044,
            "output": HexBytes(
                "0x00000000000000000000000000000000000000000000000047258ec1eb814b75"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 6, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6766457,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a082310000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87"
            ),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 7326,
            "output": HexBytes(
                "0x00000000000000000000000000000000000000000000000000012c64767da069"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 2, 0, 0, 0, 6, 0, 1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6658390,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x0933c1ed0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002470a082310000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec8700000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 4210,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000012c64767da069"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 2, 0, 0, 0, 6, 0, 1, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6551902,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x70a082310000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87"
            ),
            "to": "0xbB8bE4772fAA655C255309afc3c5207aA7b896Fd",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1253,
            "output": HexBytes(
                "0x00000000000000000000000000000000000000000000000000012c64767da069"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 6, 0, 1, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6756065,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a082310000000000000000000000003d9819210a31b4961b30ef54be2aed79b9c9cd3b"
            ),
            "to": "0xc00e94Cb662C3520282E6f5717214004A7f26888",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1488,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000000d0c7e14bee79dde12f6"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 6, 0, 2],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6752929,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xa9059cbb0000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec870000000000000000000000000000000000000000000000000076b3dd96692b80"
            ),
            "to": "0xc00e94Cb662C3520282E6f5717214004A7f26888",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 19090,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 6, 0, 3],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6942647,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x0bebac860000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643"
            ),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1215,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000c3135bd08061bcc1424a7a"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 7],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6939848,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes("0xc92aecc4"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1093,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 8],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6935366,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes("0xc92aecc4"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1093,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 9],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6932482,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x7f8661a1000000000000000000000000000000000000000000000e339e52688f4d37943b"
            ),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 37936, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [0, 0, 2, 0, 0, 0, 10],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
            "gas": 6808782,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xbb35783b000000000000000000000000197e90f9fad81970ba7976f33cbd77088e5d7cf70000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e364300000000000000000000002eb6de2349f20528301144cfa5cd11aea1b2e9ed19"
            ),
            "to": "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 17943, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 10, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6893535,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xef693bed0000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x9759A6Ac90977b93B58547b4A71c78317f391A28",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 54301, "output": HexBytes("0x")},
        "subtraces": 2,
        "traceAddress": [0, 0, 2, 0, 0, 0, 11],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x9759A6Ac90977b93B58547b4A71c78317f391A28",
            "gas": 6782168,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xbb35783b0000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000009759a6ac90977b93b58547b4a71c78317f391a2800000000000000000000002eb6de2349f20528300fea91f45de97c1238000000"
            ),
            "to": "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 13743, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 11, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x9759A6Ac90977b93B58547b4A71c78317f391A28",
            "gas": 6766249,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x40c10f190000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 30045, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 11, 1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6824198,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x51dff9890000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000012c64767da069"
            ),
            "to": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 2359, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [0, 0, 2, 0, 0, 0, 12],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6715783,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x51dff9890000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000012c64767da069"
            ),
            "to": "0x7b5e3521a049C8fF88e6349f33044c6Cc33c113c",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 446, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [0, 0, 2, 0, 0, 0, 12, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x03967E5b71577ba3498E1a87E425139B22B3c085",
            "gas": 7278548,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a082310000000000000000000000001f8ead1e6e10e6856d68be2217eddc71d8b4ec87"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1302,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 3],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x03967E5b71577ba3498E1a87E425139B22B3c085",
            "gas": 7274059,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x468721a70000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000713d07e8f9f7d1d6fa486dfc152e419b9dfd954e000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x1f8eaD1e6e10e6856d68be2217EDDC71D8b4eC87",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 31798,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 4],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x1f8eaD1e6e10e6856d68be2217EDDC71D8b4eC87",
            "gas": 7158800,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x468721a70000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000713d07e8f9f7d1d6fa486dfc152e419b9dfd954e000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 30125,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [0, 0, 4, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x1f8eaD1e6e10e6856d68be2217EDDC71D8b4eC87",
            "gas": 7044384,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xa9059cbb000000000000000000000000713d07e8f9f7d1d6fa486dfc152e419b9dfd954e000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 26174,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [0, 0, 4, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
            "gas": 7479805,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a08231000000000000000000000000713d07e8f9f7d1d6fa486dfc152e419b9dfd954e"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1302,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
        },
        "subtraces": 0,
        "traceAddress": [1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
            "gas": 7476893,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xa9059cbb0000000000000000000000000411cd48bb8f5a29eb2e5917df40521b70902ff6000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 26174,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [2],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
            "gas": 7447843,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a08231000000000000000000000000713d07e8f9f7d1d6fa486dfc152e419b9dfd954e"
            ),
            "to": "0xF81beb4d26F4517Bd413184f700Fb3D8c138d274",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1241,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000"
            ),
        },
        "subtraces": 0,
        "traceAddress": [3],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
            "gas": 7444993,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xa9059cbb0000000000000000000000000411cd48bb8f5a29eb2e5917df40521b70902ff60000000000000000000000000000000000000000000000000de0b6b3a7640000"
            ),
            "to": "0xF81beb4d26F4517Bd413184f700Fb3D8c138d274",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 29691,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [4],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
            "gas": 7413315,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xb3ab15fb0000000000000000000000000411cd48bb8f5a29eb2e5917df40521b70902ff6"
            ),
            "to": "0xF81beb4d26F4517Bd413184f700Fb3D8c138d274",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 9192, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [5],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
            "gas": 7402698,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xf46d1982000000000000000000000000beb32aa1b171acf79951c4e96e0312f85e1e8ad60000000000000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x0411CD48Bb8F5a29EB2E5917Df40521b70902FF6",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 403530, "output": HexBytes("0x")},
        "subtraces": 3,
        "traceAddress": [6],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x0411CD48Bb8F5a29EB2E5917Df40521b70902FF6",
            "gas": 7261947,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x095ea7b3000000000000000000000000beb32aa1b171acf79951c4e96e0312f85e1e8ad6ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 22414,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x0411CD48Bb8F5a29EB2E5917Df40521b70902FF6",
            "gas": 7236667,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a082310000000000000000000000000411cd48bb8f5a29eb2e5917df40521b70902ff6"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1302,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x0411CD48Bb8F5a29EB2E5917Df40521b70902FF6",
            "gas": 7233755,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x47e7ef240000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0xbEb32Aa1B171Acf79951c4E96E0312F85E1E8Ad6",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 348011, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [6, 2],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0xbEb32Aa1B171Acf79951c4E96E0312F85E1E8Ad6",
            "gas": 7119161,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x47e7ef240000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x43C28c50abF19D448E3E8286583799c128f2cC38",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 346377, "output": HexBytes("0x")},
        "subtraces": 4,
        "traceAddress": [6, 2, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0xbEb32Aa1B171Acf79951c4E96E0312F85E1E8Ad6",
            "gas": 7005138,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x2f54bf6e0000000000000000000000000411cd48bb8f5a29eb2e5917df40521b70902ff6"
            ),
            "to": "0x6Ea7a9EE186552559Ceeca4F98167ae2D29148B6",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 2991,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x6Ea7a9EE186552559Ceeca4F98167ae2D29148B6",
            "gas": 6894119,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x2f54bf6e0000000000000000000000000411cd48bb8f5a29eb2e5917df40521b70902ff6"
            ),
            "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1357,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0xbEb32Aa1B171Acf79951c4E96E0312F85E1E8Ad6",
            "gas": 6998516,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x23b872dd0000000000000000000000000411cd48bb8f5a29eb2e5917df40521b70902ff60000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b6000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 27218,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0xbEb32Aa1B171Acf79951c4E96E0312F85E1E8Ad6",
            "gas": 6967485,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x468721a70000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x6Ea7a9EE186552559Ceeca4F98167ae2D29148B6",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 28038,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 2],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x6Ea7a9EE186552559Ceeca4F98167ae2D29148B6",
            "gas": 6857016,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x468721a70000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 26365,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 2, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x6Ea7a9EE186552559Ceeca4F98167ae2D29148B6",
            "gas": 6747315,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x095ea7b30000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 22414,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 2, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0xbEb32Aa1B171Acf79951c4E96E0312F85E1E8Ad6",
            "gas": 6935748,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x468721a70000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024a0712d68000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x6Ea7a9EE186552559Ceeca4F98167ae2D29148B6",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 270176,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x6Ea7a9EE186552559Ceeca4F98167ae2D29148B6",
            "gas": 6825781,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x468721a70000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024a0712d68000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 268509,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x6Ea7a9EE186552559Ceeca4F98167ae2D29148B6",
            "gas": 6716574,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xa0712d68000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 264564,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6609254,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0xa0712d68000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0xbB8bE4772fAA655C255309afc3c5207aA7b896Fd",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 261838,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 16,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6496824,
            "value": 0,
            "callType": "call",
            "input": HexBytes("0x9f678cca"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 27669,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
            "gas": 6384993,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xf24e23eb000000000000000000000000a950524441892a31ebddf91d3ceefa04bf454466000000000000000000000000197e90f9fad81970ba7976f33cbd77088e5d7cf70000000000000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 12764, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6466858,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x0bebac860000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643"
            ),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1215,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000c30528322df92d740ab63f"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6464059,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes("0xc92aecc4"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1093,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 2],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6458793,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x15f24053000000000000000000000000000000000000000000c6883b4f3b84a3e4bb7770000000000000000000000000000000000000000002a67c3710824510a165c528000000000000000000000000000000000000000000007c618e66dc09e8ca2cd5"
            ),
            "to": "0xfeD941d39905B23D6FAf02C8301d40bD4834E27F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 3881,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000449414fd1"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 3],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6438260,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x4ef4c3e10000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b6000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 42498,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 4],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6335881,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x4ef4c3e10000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b6000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x7b5e3521a049C8fF88e6349f33044c6Cc33c113c",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 40518,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 4, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6208839,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a082310000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b6"
            ),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 7326,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 4, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6109485,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x0933c1ed0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002470a082310000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b600000000000000000000000000000000000000000000000000000000"
            ),
            "to": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 4210,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 4, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6011574,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x70a082310000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b6"
            ),
            "to": "0xbB8bE4772fAA655C255309afc3c5207aA7b896Fd",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1253,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000000"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6392940,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0xdd62ed3e0000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b60000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1377,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 5],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6389943,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a082310000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b6"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1302,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 6],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6385243,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x0bebac860000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643"
            ),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1215,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000c30528322df92d740ab63f"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 7],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6382445,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes("0xc92aecc4"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1093,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 8],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6375095,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x23b872dd0000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b60000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 30275,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 9],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6340455,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x70a082310000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1302,
            "output": HexBytes(
                "0x000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 10],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6337544,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x3b4da69f0000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x9759A6Ac90977b93B58547b4A71c78317f391A28",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 26936, "output": HexBytes("0x")},
        "subtraces": 2,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 11],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x9759A6Ac90977b93B58547b4A71c78317f391A28",
            "gas": 6235716,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xbb35783b0000000000000000000000009759a6ac90977b93b58547b4a71c78317f391a280000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e364300000000000000000000002eb6de2349f20528300fea91f45de97c1238000000"
            ),
            "to": "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 9543, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 11, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x9759A6Ac90977b93B58547b4A71c78317f391A28",
            "gas": 6223932,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x9dc29fac0000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643000000000000000000000000000000000000000000000e75171d9d2983289633"
            ),
            "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 7746, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 11, 1],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6309464,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes(
                "0x6c25b3460000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643"
            ),
            "to": "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1236,
            "output": HexBytes(
                "0x00000000000000000000002eb6de2349f20528301464be242dca461ce1baabfa"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 12],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6306654,
            "value": 0,
            "callType": "staticcall",
            "input": HexBytes("0xc92aecc4"),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {
            "gasUsed": 1093,
            "output": HexBytes(
                "0x0000000000000000000000000000000000000000034a13ac9ed2cf6900e592bb"
            ),
        },
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 13],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6303962,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x049878f3000000000000000000000000000000000000000000000e339e52688f4d37943b"
            ),
            "to": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 21915, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 14],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7",
            "gas": 6197584,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xbb35783b0000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643000000000000000000000000197e90f9fad81970ba7976f33cbd77088e5d7cf700000000000000000000002eb6de2349f20528301144cfa5cd11aea1b2e9ed19"
            ),
            "to": "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 9543, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 14, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
            "gas": 6252318,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0x41c728b90000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b6000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000012c64767da068"
            ),
            "to": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 2316, "output": HexBytes("0x")},
        "subtraces": 1,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 15],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
            "gas": 6152838,
            "value": 0,
            "callType": "delegatecall",
            "input": HexBytes(
                "0x41c728b90000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e36430000000000000000000000006ea7a9ee186552559ceeca4f98167ae2d29148b6000000000000000000000000000000000000000000000e75171d9d298328963300000000000000000000000000000000000000000000000000012c64767da068"
            ),
            "to": "0x7b5e3521a049C8fF88e6349f33044c6Cc33c113c",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 403, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [6, 2, 0, 3, 0, 0, 0, 15, 0],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
    {
        "action": {
            "from": "0x713D07E8F9F7D1D6FA486dFc152E419b9DfD954e",
            "gas": 7003102,
            "value": 0,
            "callType": "call",
            "input": HexBytes(
                "0xb3ab15fb00000000000000000000000032ca2c42e3ca59f5785711dc81ae92ea99fb763e"
            ),
            "to": "0x0411CD48Bb8F5a29EB2E5917Df40521b70902FF6",
        },
        "blockHash": "0xb7a05f742a05f324256950f8e871587fbb1d866f60cffbfde2f07f7170544b96",
        "blockNumber": 10913066,
        "result": {"gasUsed": 8156, "output": HexBytes("0x")},
        "subtraces": 0,
        "traceAddress": [7],
        "transactionHash": "0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        "transactionPosition": 15,
        "type": "call",
    },
]

'''
'''--- safe_transaction_service/history/tests/test_balance_service.py ---
from typing import Optional
from unittest import mock
from unittest.mock import MagicMock

from django.test import TestCase
from django.utils import timezone

from eth_account import Account
from eth_typing import ChecksumAddress

from gnosis.eth.tests.ethereum_test_case import EthereumTestCaseMixin
from gnosis.eth.tests.utils import deploy_erc20

from safe_transaction_service.tokens.models import Token
from safe_transaction_service.tokens.services.price_service import PriceService
from safe_transaction_service.tokens.tests.factories import TokenFactory

from ..services import BalanceServiceProvider
from ..services.balance_service import BalanceWithFiat
from .factories import ERC20TransferFactory, SafeContractFactory

class TestBalanceService(EthereumTestCaseMixin, TestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.balance_service = BalanceServiceProvider()

    def test_get_token_info(self):
        balance_service = self.balance_service
        token_address = Account.create().address
        self.assertIsNone(balance_service.get_token_info(token_address))

        token_db = TokenFactory(address=token_address)
        self.assertIsNone(balance_service.get_token_info(token_address))  # It's cached

        balance_service.cache_token_info = {}  # Empty cache
        token_info = balance_service.get_token_info(token_address)  # It's cached
        self.assertEqual(token_info.address, token_address)
        self.assertEqual(token_info.name, token_db.name)
        self.assertEqual(token_info.symbol, token_db.symbol)
        self.assertEqual(token_info.decimals, token_db.decimals)

    @mock.patch.object(
        PriceService, "get_token_eth_value", return_value=0.4, autospec=True
    )
    @mock.patch.object(
        PriceService, "get_native_coin_usd_price", return_value=123.4, autospec=True
    )
    @mock.patch.object(timezone, "now", return_value=timezone.now())
    def test_get_usd_balances(
        self,
        timezone_now_mock: MagicMock,
        get_native_coin_usd_price_mock: MagicMock,
        get_token_eth_value_mock: MagicMock,
    ):
        balance_service = self.balance_service

        safe_address = Account.create().address
        SafeContractFactory(address=safe_address)
        value = 7
        self.send_ether(safe_address, 7)

        balances = balance_service.get_usd_balances(safe_address)
        self.assertEqual(len(balances), 1)
        self.assertIsNone(balances[0].token_address)
        self.assertEqual(balances[0].balance, value)

        tokens_value = int(12 * 1e18)
        erc20 = deploy_erc20(self.w3, "Eurodollar", "EUD", safe_address, tokens_value)
        balances = balance_service.get_usd_balances(safe_address)
        self.assertEqual(len(balances), 1)

        ERC20TransferFactory(address=erc20.address, to=safe_address)
        balances = balance_service.get_usd_balances(safe_address)
        token_info = balance_service.get_token_info(erc20.address)
        self.assertCountEqual(
            balances,
            [
                BalanceWithFiat(
                    None, None, value, 1.0, timezone_now_mock.return_value, 0.0, 123.4
                ),
                BalanceWithFiat(
                    erc20.address,
                    token_info,
                    tokens_value,
                    0.4,
                    timezone_now_mock.return_value,
                    round(123.4 * 0.4 * (tokens_value / 1e18), 4),
                    round(123.4 * 0.4, 4),
                ),
            ],
        )

        balances = balance_service.get_usd_balances(safe_address, only_trusted=True)
        self.assertCountEqual(
            balances,
            [
                BalanceWithFiat(
                    None, None, value, 1.0, timezone_now_mock.return_value, 0.0, 123.4
                ),
            ],
        )

        Token.objects.filter(address=erc20.address).update(trusted=True, spam=False)
        balances = balance_service.get_usd_balances(safe_address, only_trusted=True)
        self.assertCountEqual(
            balances,
            [
                BalanceWithFiat(
                    None, None, value, 1.0, timezone_now_mock.return_value, 0.0, 123.4
                ),
                BalanceWithFiat(
                    erc20.address,
                    token_info,
                    tokens_value,
                    0.4,
                    timezone_now_mock.return_value,
                    round(123.4 * 0.4 * (tokens_value / 1e18), 4),
                    round(123.4 * 0.4, 4),
                ),
            ],
        )

        # Test sorting
        erc20_2 = deploy_erc20(self.w3, "Peseta", "PTA", safe_address, tokens_value)
        token_info_2 = balance_service.get_token_info(erc20_2.address)
        erc20_3 = deploy_erc20(
            self.w3, "Double Dollars", "DD", safe_address, tokens_value
        )
        token_info_3 = balance_service.get_token_info(erc20_3.address)

        ERC20TransferFactory(address=erc20_2.address, to=safe_address)
        ERC20TransferFactory(address=erc20_3.address, to=safe_address)
        balances = balance_service.get_usd_balances(safe_address)
        token_info = balance_service.get_token_info(erc20.address)
        self.assertCountEqual(
            balances,
            [
                BalanceWithFiat(
                    None, None, value, 1.0, timezone_now_mock.return_value, 0.0, 123.4
                ),
                BalanceWithFiat(
                    erc20_3.address,
                    token_info_3,
                    tokens_value,
                    0.4,
                    timezone_now_mock.return_value,
                    round(123.4 * 0.4 * (tokens_value / 1e18), 4),
                    round(123.4 * 0.4, 4),
                ),
                BalanceWithFiat(
                    erc20.address,
                    token_info,
                    tokens_value,
                    0.4,
                    timezone_now_mock.return_value,
                    round(123.4 * 0.4 * (tokens_value / 1e18), 4),
                    round(123.4 * 0.4, 4),
                ),
                BalanceWithFiat(
                    erc20_2.address,
                    token_info_2,
                    tokens_value,
                    0.4,
                    timezone_now_mock.return_value,
                    round(123.4 * 0.4 * (tokens_value / 1e18), 4),
                    round(123.4 * 0.4, 4),
                ),
            ],
        )

    @mock.patch.object(
        PriceService, "get_token_eth_value", return_value=0.4, autospec=True
    )
    @mock.patch.object(
        PriceService, "get_native_coin_usd_price", return_value=123.4, autospec=True
    )
    @mock.patch.object(timezone, "now", return_value=timezone.now())
    def test_get_usd_balances_copy_price(
        self,
        timezone_now_mock: MagicMock,
        get_native_coin_usd_price_mock: MagicMock,
        get_token_eth_value_mock: MagicMock,
    ):
        balance_service = self.balance_service
        safe_address = SafeContractFactory().address
        random_address = Account.create().address

        balances = balance_service.get_usd_balances(safe_address)
        self.assertEqual(len(balances), 1)
        self.assertIsNone(balances[0].token_address)
        self.assertEqual(balances[0].balance, 0)

        tokens_value = int(12 * 1e18)
        erc20 = deploy_erc20(
            self.w3, "Galactic Credit Standard", "GCS", safe_address, tokens_value
        )
        ERC20TransferFactory(address=erc20.address, to=safe_address)

        def get_token_eth_value(
            self, token_address: ChecksumAddress
        ) -> Optional[float]:
            if token_address == erc20.address:
                return 0.4
            elif token_address == random_address:
                return 0.1

        get_token_eth_value_mock.side_effect = get_token_eth_value
        for expected_token_eth_value in (0.4, 0.1):
            with self.subTest(expected_token_eth_value=expected_token_eth_value):
                balances = balance_service.get_usd_balances(safe_address)
                self.assertEqual(len(balances), 2)
                self.assertCountEqual(
                    balances,
                    [
                        BalanceWithFiat(
                            None,
                            None,
                            0,
                            1.0,
                            timezone_now_mock.return_value,
                            0.0,
                            123.4,
                        ),
                        BalanceWithFiat(
                            erc20.address,
                            balance_service.get_token_info(erc20.address),
                            tokens_value,
                            expected_token_eth_value,
                            timezone_now_mock.return_value,
                            round(
                                123.4
                                * expected_token_eth_value
                                * (tokens_value / 1e18),
                                4,
                            ),
                            round(123.4 * expected_token_eth_value, 4),
                        ),
                    ],
                )
                token = Token.objects.get(address=erc20.address)
                token.copy_price = random_address
                token.save(update_fields=["copy_price"])
                balance_service.cache_token_info.clear()

    def test_filter_addresses(self):
        balance_service = self.balance_service
        db_not_trusted_addresses = [
            TokenFactory(trusted=False, spam=False).address for _ in range(3)
        ]
        db_trusted_addresses = [TokenFactory(trusted=True).address for _ in range(2)]
        db_spam_address = TokenFactory(trusted=False, spam=True).address
        db_invalid_address = TokenFactory(
            decimals=None
        ).address  # This should not be shown
        db_events_bugged_erc20_address = TokenFactory(
            events_bugged=True
        ).address  # This should be shown always
        db_events_bugged_not_erc20 = TokenFactory(
            decimals=None, events_bugged=True
        ).address  # This should not be shown
        not_in_db_address = Account.create().address

        addresses = (
            db_not_trusted_addresses
            + db_trusted_addresses
            + [db_invalid_address]
            + [not_in_db_address]
            + [db_spam_address]
        )

        expected_address = (
            db_not_trusted_addresses
            + db_trusted_addresses
            + [not_in_db_address]
            + [db_spam_address]
            + [db_events_bugged_erc20_address]
        )

        self.assertCountEqual(
            balance_service._filter_addresses(addresses, False, False), expected_address
        )

        expected_address = db_trusted_addresses
        self.assertCountEqual(
            balance_service._filter_addresses(addresses, True, False), expected_address
        )

        Token.objects.filter(address=db_events_bugged_erc20_address).update(
            trusted=True
        )
        expected_address = db_trusted_addresses + [db_events_bugged_erc20_address]
        self.assertCountEqual(
            balance_service._filter_addresses(addresses, True, False), expected_address
        )

        expected_address = (
            db_not_trusted_addresses
            + db_trusted_addresses
            + [db_events_bugged_erc20_address]
        )
        self.assertCountEqual(
            balance_service._filter_addresses(addresses, False, True), expected_address
        )

'''
'''--- safe_transaction_service/history/tests/test_collectibles_service.py ---
from typing import List, Optional, Sequence, Tuple
from unittest import mock
from unittest.mock import MagicMock

from django.conf import settings
from django.test import TestCase

from eth_account import Account

from gnosis.eth import EthereumClient
from gnosis.eth.ethereum_client import (
    Erc721Info,
    Erc721Manager,
    EthereumClientProvider,
    InvalidERC721Info,
)
from gnosis.eth.tests.ethereum_test_case import EthereumTestCaseMixin

from safe_transaction_service.tokens.constants import ENS_CONTRACTS_WITH_TLD
from safe_transaction_service.tokens.models import Token
from safe_transaction_service.tokens.tests.factories import TokenFactory
from safe_transaction_service.utils.redis import get_redis

from ..services import CollectiblesService
from ..services.collectibles_service import (
    Collectible,
    CollectiblesServiceProvider,
    CollectibleWithMetadata,
    Erc721InfoWithLogo,
    MetadataRetrievalException,
    ipfs_to_http,
)
from .factories import ERC721TransferFactory
from .utils import just_test_if_mainnet_node

class TestCollectiblesService(EthereumTestCaseMixin, TestCase):
    def test_ipfs_to_http(self):
        regular_url = "http://testing-url/path/?arguments"
        self.assertEqual(ipfs_to_http(regular_url), regular_url)
        ipfs_url = "ipfs://testing-url/path/?arguments"
        result = ipfs_to_http(ipfs_url)
        self.assertTrue(result.startswith("http"))
        self.assertIn("ipfs/testing-url/path/?arguments", result)

        ipfs_with_path_url = "ipfs://ipfs/testing-url/path/?arguments"
        result = ipfs_to_http(ipfs_with_path_url)
        self.assertTrue(result.startswith("http"))
        self.assertNotIn("ipfs/ipfs", result)
        self.assertIn("ipfs/testing-url/path/?arguments", result)

    def test_get_collectibles(self):
        mainnet_node = just_test_if_mainnet_node()
        try:
            ethereum_client = EthereumClient(mainnet_node)
            EthereumClientProvider.instance = ethereum_client
            collectibles_service = CollectiblesService(ethereum_client, get_redis())

            # Caches empty
            self.assertFalse(collectibles_service.cache_token_info)

            safe_address = "0xfF501B324DC6d78dC9F983f140B9211c3EdB4dc7"
            ens_address = "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85"
            ens_logo_uri = "/media/tokens/logos/ENS.png"
            ens_token_id = 93288724337340885726942883352789513739931149355867373088241393067029827792979
            dappcon_2020_address = "0x202d2f33449Bf46d6d32Ae7644aDA130876461a4"
            dappcon_token_id = 13
            dappcon_logo_uri = Token(
                address=dappcon_2020_address, name="", symbol=""
            ).get_full_logo_uri()
            self.assertEqual(
                collectibles_service.get_collectibles(safe_address), ([], 0)
            )

            erc721_addresses = [
                (dappcon_2020_address, dappcon_token_id),
                (ens_address, ens_token_id),  # ENS
            ]

            for erc721_address, token_id in erc721_addresses:
                ERC721TransferFactory(
                    to=safe_address, address=erc721_address, token_id=token_id
                )

            expected = [
                Collectible(
                    token_name="Ethereum Name Service",
                    token_symbol="ENS",
                    logo_uri=ens_logo_uri,
                    address=ens_address,
                    id=ens_token_id,
                    uri=None,
                ),
                Collectible(
                    token_name="DappCon2020",
                    token_symbol="D20",
                    logo_uri=dappcon_logo_uri,
                    address=dappcon_2020_address,
                    id=dappcon_token_id,
                    uri="https://us-central1-thing-1d2be.cloudfunctions.net/getThing?thingId=Q1c8y3PwYomxjW25sW3l",
                ),
            ]
            collectibles, _ = collectibles_service.get_collectibles(safe_address)
            self.assertEqual(len(collectibles), len(expected))
            self.assertCountEqual(collectibles, expected)

            expected = [
                CollectibleWithMetadata(
                    token_name="Ethereum Name Service",
                    token_symbol="ENS",
                    logo_uri=ens_logo_uri,
                    address=ens_address,
                    id=93288724337340885726942883352789513739931149355867373088241393067029827792979,
                    uri=None,
                    metadata={
                        "name": "safe-multisig.eth",
                        "description": ".eth ENS Domain",
                        "image": settings.TOKENS_ENS_IMAGE_URL,
                    },
                ),
                CollectibleWithMetadata(
                    token_name="DappCon2020",
                    token_symbol="D20",
                    logo_uri=dappcon_logo_uri,
                    address=dappcon_2020_address,
                    id=13,
                    uri="https://us-central1-thing-1d2be.cloudfunctions.net/getThing?thingId=Q1c8y3PwYomxjW25sW3l",
                    metadata={
                        "minted": "Minted on Mintbase.io",
                        "image": "https://firebasestorage.googleapis.com/v0/b/thing-1d2be.appspot.com/o/token%2Fasset-1581932081565?alt=media&token=57b47904-1782-40e0-ab6d-4f8ca82e6884",
                        "name": "Earlybird Ticket",
                        "forSale": False,
                        "minter": "",
                        "external_url": "https://mintbase.io/my-market/0x202d2f33449bf46d6d32ae7644ada130876461a4",
                        "fiatPrice": "$278.66",
                        "tags": [],
                        "mintedOn": {"_seconds": 1581932237, "_nanoseconds": 580000000},
                        "amountToMint": 10,
                        "contractAddress": "0x202d2f33449bf46d6d32ae7644ada130876461a4",
                        "type": "ERC721",
                        "attributes": [
                            {
                                "display_type": "date",
                                "value": 1599516000,
                                "trait_type": "Start Date",
                            },
                            {
                                "display_type": "date",
                                "value": 1599688800,
                                "trait_type": "End Date",
                            },
                            {
                                "value": "HolzmarktstraÃŸe 33, 10243 Berlin, Germany",
                                "trait_type": "location",
                            },
                            {
                                "value": "ChIJhz8mADlOqEcR2lw7-iNCoDM",
                                "trait_type": "place_id",
                            },
                            {"value": "https://dappcon.io/", "trait_type": "website"},
                        ],
                        "price": "1.1",
                        "description": "This NFT ticket gives you full access to the 3-day conference. \nDate: 8 - 10 September *** Location: HolzmarktstraÃŸe 33 I 10243 Berlin",
                        "numAvailable": 0,
                    },
                ),
            ]
            collectibles_with_metadata = (
                collectibles_service.get_collectibles_with_metadata(safe_address)
            )
            self.assertCountEqual(collectibles_with_metadata, expected)

            # Set ens trusted
            Token.objects.filter(address=ens_address).update(trusted=True)
            collectibles_with_metadata = (
                collectibles_service.get_collectibles_with_metadata(
                    safe_address, only_trusted=True
                )
            )
            self.assertCountEqual(collectibles_with_metadata, expected[:1])

            # Set ens spam
            Token.objects.filter(address=ens_address).update(trusted=False, spam=True)
            collectibles_with_metadata = (
                collectibles_service.get_collectibles_with_metadata(
                    safe_address, exclude_spam=True
                )
            )
            self.assertCountEqual(collectibles_with_metadata, expected[1:])

            # Caches not empty
            self.assertTrue(collectibles_service.cache_token_info)
        finally:
            del EthereumClientProvider.instance

    @mock.patch.object(CollectiblesService, "get_metadata", autospec=True)
    @mock.patch.object(CollectiblesService, "get_collectibles", autospec=True)
    def test_get_collectibles_with_metadata(
        self, get_collectibles_mock: MagicMock, get_metadata_mock: MagicMock
    ):
        collectibles_service = CollectiblesServiceProvider()
        get_metadata_mock.return_value = "not-a-dictionary"
        collectible = Collectible(
            "GoldenSun",
            "Djinn",
            "http://random-address.org/logo.png",
            Account.create().address,
            28,
            "http://random-address.org/info-28.json",
        )
        get_collectibles_mock.return_value = [collectible], 0
        safe_address = Account.create().address

        expected = [
            CollectibleWithMetadata(
                collectible.token_name,
                collectible.token_symbol,
                collectible.logo_uri,
                collectible.address,
                collectible.id,
                collectible.uri,
                {},
            )
        ]
        self.assertListEqual(
            collectibles_service.get_collectibles_with_metadata(safe_address),
            expected,
        )
        get_metadata_mock.return_value = {}
        self.assertListEqual(
            collectibles_service.get_collectibles_with_metadata(safe_address),
            expected,
        )

        get_metadata_mock.side_effect = MetadataRetrievalException
        self.assertListEqual(
            collectibles_service.get_collectibles_with_metadata(safe_address),
            expected,
        )
        get_metadata_mock.side_effect = None

        metadata = {
            "name": "Gust",
            "description": "Jupiter Djinni",
            "image": "http://random-address.org/logo-28.png",
        }
        get_metadata_mock.return_value = metadata
        # collectible cached by address + id
        collectible.id += 1
        get_collectibles_mock.return_value = [collectible], 0
        collectible_with_metadata = CollectibleWithMetadata(
            collectible.token_name,
            collectible.token_symbol,
            collectible.logo_uri,
            collectible.address,
            collectible.id,
            collectible.uri,
            metadata,
        )
        self.assertEqual(collectible_with_metadata.name, "Gust")
        self.assertEqual(collectible_with_metadata.description, "Jupiter Djinni")
        self.assertEqual(
            collectible_with_metadata.image_uri, "http://random-address.org/logo-28.png"
        )
        expected = [collectible_with_metadata]

        self.assertListEqual(
            collectibles_service.get_collectibles_with_metadata(safe_address),
            expected,
        )

    @mock.patch.object(Erc721Manager, "get_info", autospec=True)
    def test_get_token_info(self, get_info_mock: MagicMock):
        collectibles_service = CollectiblesServiceProvider()
        random_address = Account.create().address

        # No DB, no blockchain source
        get_info_mock.side_effect = InvalidERC721Info
        self.assertFalse(collectibles_service.cache_token_info)
        self.assertIsNone(collectibles_service.get_token_info(random_address))
        self.assertTrue(
            collectibles_service.cache_token_info
        )  # Cache works for not found tokens too

        # Add DB source
        token = TokenFactory()
        self.assertEqual(
            collectibles_service.get_token_info(token.address),
            Erc721InfoWithLogo.from_token(token),
        )

        # Just Blockchain source
        random_address = Account.create().address
        self.assertEqual(Token.objects.count(), 1)
        get_info_mock.side_effect = None
        get_info_mock.return_value = Erc721Info("Uxio Collectible Card", "UCC")
        token_info = collectibles_service.get_token_info(random_address)
        self.assertIsInstance(token_info, Erc721InfoWithLogo)
        self.assertEqual(token_info.name, get_info_mock.return_value.name)
        self.assertEqual(token_info.symbol, get_info_mock.return_value.symbol)
        self.assertEqual(Token.objects.count(), 2)

        # Test switch name-symbol when symbol is way longer than name
        random_address = Account.create().address
        get_info_mock.return_value = Erc721Info(
            "POAP", "The Proof of Attendance Protocol"
        )
        token_info = collectibles_service.get_token_info(random_address)
        self.assertIsInstance(token_info, Erc721InfoWithLogo)
        self.assertEqual(token_info.symbol, get_info_mock.return_value.name)
        self.assertEqual(token_info.name, get_info_mock.return_value.symbol)
        self.assertEqual(Token.objects.count(), 3)
        self.assertEqual(
            len(collectibles_service.cache_token_info), 4
        )  # Cache works for not found tokens too

        # Test ENS (hardcoded)
        get_info_mock.return_value = None
        ens_token_address = list(ENS_CONTRACTS_WITH_TLD.keys())[0]
        token_info = collectibles_service.get_token_info(ens_token_address)
        self.assertIsNotNone(token_info)
        ens_logo_uri = "/media/tokens/logos/ENS.png"
        self.assertEqual(token_info.logo_uri, ens_logo_uri)
        self.assertEqual(Token.objects.count(), 4)
        self.assertEqual(
            Token.objects.get(address=ens_token_address).logo.url, ens_logo_uri
        )

    @mock.patch.object(Erc721Manager, "get_token_uris", autospec=True)
    def test_get_token_uris(self, get_token_uris_mock: MagicMock):
        redis = get_redis()
        redis.flushall()
        token_uris = [
            "http://testing.com/12",
            None,
            "",
        ]  # '' will be parsed as None by the service
        expected_token_uris = ["http://testing.com/12", None, None]
        get_token_uris_mock.return_value = token_uris
        addresses_with_token_ids = [(Account.create().address, i) for i in range(3)]
        collectibles_service = CollectiblesServiceProvider()
        self.assertEqual(
            collectibles_service.get_token_uris(addresses_with_token_ids),
            expected_token_uris,
        )

        # Test redis cache
        redis_keys = redis.keys("token-uri:*")
        self.assertEqual(len(redis_keys), 3)

        # Test redis cache working
        self.assertEqual(
            collectibles_service.get_token_uris(addresses_with_token_ids),
            expected_token_uris,
        )

    @mock.patch.object(Erc721Manager, "get_token_uris", autospec=True)
    def test_get_token_uris_value_error(self, get_token_uris_mock: MagicMock):
        """
        Test node error when retrieving the uris
        """

        def get_token_uris_fn(
            self, token_addresses_with_token_ids: Sequence[Tuple[str, int]]
        ) -> List[Optional[str]]:
            if (
                "0x9807559b75D5fcCEcf1bbe074FD0890EdDC1bf79",
                8,
            ) in token_addresses_with_token_ids:
                raise ValueError
            else:
                return [
                    f"https://random-url/{token_id}.json"
                    for _, token_id in token_addresses_with_token_ids
                ]

        # Random addresses
        addresses_with_token_ids = [
            ("0xaa2475C106A01eA6972dBC9d6b975cD122b06b80", 4),
            ("0x9807559b75D5fcCEcf1bbe074FD0890EdDC1bf79", 8),
            ("0xD7E7f8F69dbaEe520182386099364046d1e1B80c", 15),
        ]
        get_token_uris_mock.side_effect = get_token_uris_fn
        collectibles_service = CollectiblesServiceProvider()

        self.assertEqual(
            collectibles_service.get_token_uris(addresses_with_token_ids),
            [
                "https://random-url/4.json",
                None,
                "https://random-url/15.json",
            ],
        )

    def test_retrieve_metadata_from_uri(self):
        collectibles_service = CollectiblesServiceProvider()
        # Test ipfs
        ipfs_address = "ipfs://ipfs/Qmc4ZMDNMu5bguGohtGQGx5DQexitnNvf5Rb7Yzbja47bo"
        expected_object = {
            "description": "Flamingo DAO Initial Token",
            "name": "Flamingo DAO",
            "image": "https://ipfs.io/ipfs/QmXKU5RBTrGaYn5M1iWQaeKuCKV34g417YDGN5Yh7Uxk4i",
        }

        self.assertEqual(
            collectibles_service._retrieve_metadata_from_uri(ipfs_address),
            expected_object,
        )

'''
'''--- safe_transaction_service/history/tests/test_commands.py ---
import os.path
import tempfile
from io import StringIO
from unittest import mock
from unittest.mock import MagicMock, PropertyMock

from django.core.management import CommandError, call_command
from django.test import TestCase

from django_celery_beat.models import PeriodicTask

from gnosis.eth.ethereum_client import EthereumClient, EthereumNetwork

from ..indexers import Erc20EventsIndexer, InternalTxIndexer, SafeEventsIndexer
from ..models import ProxyFactory, SafeMasterCopy
from ..services import IndexServiceProvider
from ..tasks import logger as task_logger
from .factories import (
    MultisigTransactionFactory,
    SafeContractFactory,
    SafeMasterCopyFactory,
)

class TestCommands(TestCase):
    @mock.patch.object(EthereumClient, "get_network", autospec=True)
    def _test_setup_service(
        self,
        ethereum_network: EthereumNetwork,
        ethereum_client_get_network_mock: MagicMock,
    ):
        command = "setup_service"
        ethereum_client_get_network_mock.return_value = ethereum_network
        buf = StringIO()
        self.assertEqual(SafeMasterCopy.objects.count(), 0)
        self.assertEqual(ProxyFactory.objects.count(), 0)
        self.assertEqual(PeriodicTask.objects.count(), 0)

        call_command(command, stdout=buf)
        self.assertIn(
            f"Setting up {ethereum_network.name} safe addresses", buf.getvalue()
        )
        self.assertIn(
            f"Setting up {ethereum_network.name} proxy factory addresses",
            buf.getvalue(),
        )
        self.assertIn("Created Periodic Task", buf.getvalue())
        self.assertNotIn("was already created", buf.getvalue())
        self.assertGreater(SafeMasterCopy.objects.count(), 0)
        self.assertGreater(ProxyFactory.objects.count(), 0)
        self.assertGreater(PeriodicTask.objects.count(), 0)

        # Check last master copy was created
        last_master_copy_address = "0x6851D6fDFAfD08c0295C392436245E5bc78B0185"
        last_master_copy = SafeMasterCopy.objects.get(address=last_master_copy_address)
        self.assertGreater(last_master_copy.initial_block_number, 0)
        self.assertGreater(last_master_copy.tx_block_number, 0)

        # Check last proxy factory was created
        last_proxy_factory_address = "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B"
        last_proxy_factory = ProxyFactory.objects.get(
            address=last_proxy_factory_address
        )
        self.assertGreater(last_proxy_factory.initial_block_number, 0)
        self.assertGreater(last_proxy_factory.tx_block_number, 0)

        buf = StringIO()
        call_command(command, stdout=buf)
        self.assertIn(
            f"Setting up {ethereum_network.name} safe addresses", buf.getvalue()
        )
        self.assertIn(
            f"Setting up {ethereum_network.name} proxy factory addresses",
            buf.getvalue(),
        )
        self.assertIn("Removing old tasks", buf.getvalue())
        self.assertIn("Old tasks were removed", buf.getvalue())
        self.assertIn("Created Periodic Task", buf.getvalue())

    def test_add_webhook(self):
        command = "add_webhook"

        with self.assertRaisesMessage(
            CommandError, "the following arguments are required: --url"
        ):
            call_command(command)

        buf = StringIO()
        call_command(command, "--url=http://docker-url", stdout=buf)
        self.assertIn("Created webhook for", buf.getvalue())

        buf = StringIO()
        call_command(command, "--url=https://test-url.com", stdout=buf)
        self.assertIn("Created webhook for", buf.getvalue())

    def test_index_erc20(self):
        command = "index_erc20"
        buf = StringIO()
        with self.assertLogs(logger=task_logger) as cm:
            call_command(command, stdout=buf)
            self.assertIn("No addresses to process", cm.output[0])

        buf = StringIO()
        call_command(command, "--block-process-limit=10", stdout=buf)
        self.assertIn("Setting block-process-limit to 10", buf.getvalue())

        buf = StringIO()
        call_command(
            command,
            "--block-process-limit=10",
            "--block-process-limit-max=15",
            stdout=buf,
        )
        self.assertIn("Setting block-process-limit to 10", buf.getvalue())
        self.assertIn("Setting block-process-limit-max to 15", buf.getvalue())

        with self.assertLogs(logger=task_logger) as cm:
            safe_contract = SafeContractFactory()
            buf = StringIO()
            call_command(command, stdout=buf)
            self.assertIn(
                f"Start indexing of erc20/721 events for out of sync addresses {[safe_contract.address]}",
                cm.output[0],
            )
            self.assertIn(
                "Indexing of erc20/721 events for out of sync addresses task processed 0 events",
                cm.output[1],
            )

        with self.assertLogs(logger=task_logger) as cm:
            safe_contract_2 = SafeContractFactory()
            buf = StringIO()
            call_command(command, f"--addresses={safe_contract_2.address}", stdout=buf)
            self.assertIn(
                f"Start indexing of erc20/721 events for out of sync addresses {[safe_contract_2.address]}",
                cm.output[0],
            )
            self.assertIn(
                "Indexing of erc20/721 events for out of sync addresses task processed 0 events",
                cm.output[1],
            )

        # Test sync task call
        with self.assertLogs(logger=task_logger) as cm:
            safe_contract_2 = SafeContractFactory()
            buf = StringIO()
            call_command(
                command, f"--addresses={safe_contract_2.address}", "--sync", stdout=buf
            )
            self.assertIn(
                f"Start indexing of erc20/721 events for out of sync addresses {[safe_contract_2.address]}",
                cm.output[0],
            )
            self.assertIn(
                "Indexing of erc20/721 events for out of sync addresses task processed 0 events",
                cm.output[1],
            )

    @mock.patch.object(
        EthereumClient, "current_block_number", new_callable=PropertyMock
    )
    def test_reindex_master_copies(self, current_block_number_mock: PropertyMock):
        logger_name = "safe_transaction_service.history.services.index_service"
        current_block_number_mock.return_value = 1000
        command = "reindex_master_copies"

        with self.assertRaisesMessage(
            CommandError, "the following arguments are required: --from-block-number"
        ):
            call_command(command)

        buf = StringIO()
        with self.assertLogs(logger_name, level="WARNING") as cm:
            call_command(
                command,
                "--block-process-limit=11",
                "--from-block-number=76",
                stdout=buf,
            )
            self.assertIn("Setting block-process-limit to 11", buf.getvalue())
            self.assertIn("Setting from-block-number to 76", buf.getvalue())
            self.assertIn("No addresses to process", cm.output[0])

        safe_master_copy = SafeMasterCopyFactory(l2=False)
        buf = StringIO()
        with self.assertLogs(logger_name, level="INFO") as cm:
            with mock.patch.object(
                InternalTxIndexer, "find_relevant_elements", return_value=[]
            ) as find_relevant_elements_mock:
                IndexServiceProvider.del_singleton()
                from_block_number = 100
                block_process_limit = 500
                call_command(
                    command,
                    f"--block-process-limit={block_process_limit}",
                    f"--from-block-number={from_block_number}",
                    stdout=buf,
                )
                self.assertIn(
                    f"Start reindexing addresses {[safe_master_copy.address]}",
                    cm.output[0],
                )
                self.assertIn("found 0 traces/events", cm.output[1])
                self.assertIn(
                    f"End reindexing addresses {[safe_master_copy.address]}",
                    cm.output[3],
                )
                find_relevant_elements_mock.assert_any_call(
                    [safe_master_copy.address],
                    from_block_number,
                    from_block_number + block_process_limit - 1,
                )
                find_relevant_elements_mock.assert_any_call(
                    [safe_master_copy.address],
                    from_block_number + block_process_limit,
                    current_block_number_mock.return_value,
                )
                self.assertEqual(find_relevant_elements_mock.call_count, 2)

        with self.settings(ETH_L2_NETWORK=True):
            IndexServiceProvider.del_singleton()
            buf = StringIO()
            with self.assertLogs(logger_name, level="WARNING") as cm:
                call_command(command, "--from-block-number=71", stdout=buf)
            self.assertIn("No addresses to process", cm.output[0])

            with self.assertLogs(logger_name, level="INFO") as cm:
                with mock.patch.object(
                    SafeEventsIndexer, "find_relevant_elements", return_value=[]
                ) as find_relevant_elements_mock:
                    safe_l2_master_copy = SafeMasterCopyFactory(l2=True)
                    buf = StringIO()
                    from_block_number = 200
                    block_process_limit = 500
                    call_command(
                        command,
                        f"--block-process-limit={block_process_limit}",
                        f"--from-block-number={from_block_number}",
                        stdout=buf,
                    )
                    self.assertIn(
                        f"Start reindexing addresses {[safe_l2_master_copy.address]}",
                        cm.output[0],
                    )
                    self.assertIn("found 0 traces/events", cm.output[1])
                    self.assertIn(
                        f"End reindexing addresses {[safe_l2_master_copy.address]}",
                        cm.output[3],
                    )
                    find_relevant_elements_mock.assert_any_call(
                        [safe_l2_master_copy.address],
                        from_block_number,
                        from_block_number + block_process_limit - 1,
                    )
                    find_relevant_elements_mock.assert_any_call(
                        [safe_l2_master_copy.address],
                        from_block_number + block_process_limit,
                        current_block_number_mock.return_value,
                    )
                    self.assertEqual(find_relevant_elements_mock.call_count, 2)
        IndexServiceProvider.del_singleton()

    @mock.patch.object(
        EthereumClient, "current_block_number", new_callable=PropertyMock
    )
    def test_reindex_erc20_events(self, current_block_number_mock: PropertyMock):
        logger_name = "safe_transaction_service.history.services.index_service"
        current_block_number_mock.return_value = 1000
        command = "reindex_erc20"

        with self.assertRaisesMessage(
            CommandError, "the following arguments are required: --from-block-number"
        ):
            call_command(command)

        buf = StringIO()
        with self.assertLogs(logger_name, level="WARNING") as cm:
            call_command(
                command,
                "--block-process-limit=11",
                "--from-block-number=76",
                stdout=buf,
            )
            self.assertIn("Setting block-process-limit to 11", buf.getvalue())
            self.assertIn("Setting from-block-number to 76", buf.getvalue())
            self.assertIn("No addresses to process", cm.output[0])

        safe_contract = SafeContractFactory()
        buf = StringIO()
        with self.assertLogs(logger_name, level="INFO") as cm:
            with mock.patch.object(
                Erc20EventsIndexer, "find_relevant_elements", return_value=[]
            ) as find_relevant_elements_mock:
                IndexServiceProvider.del_singleton()
                from_block_number = 100
                block_process_limit = 500
                call_command(
                    command,
                    f"--block-process-limit={block_process_limit}",
                    f"--from-block-number={from_block_number}",
                    stdout=buf,
                )
                self.assertIn(
                    f"Start reindexing addresses {[safe_contract.address]}",
                    cm.output[0],
                )
                self.assertIn("found 0 traces/events", cm.output[1])
                self.assertIn(
                    f"End reindexing addresses {[safe_contract.address]}",
                    cm.output[3],
                )
                find_relevant_elements_mock.assert_any_call(
                    [safe_contract.address],
                    from_block_number,
                    from_block_number + block_process_limit - 1,
                )
                find_relevant_elements_mock.assert_any_call(
                    [safe_contract.address],
                    from_block_number + block_process_limit,
                    current_block_number_mock.return_value,
                )
                self.assertEqual(find_relevant_elements_mock.call_count, 2)
        IndexServiceProvider.del_singleton()

    def test_setup_service_mainnet(self):
        self._test_setup_service(EthereumNetwork.MAINNET)

        # Check last master copy was created
        last_master_copy_address = "0x6851D6fDFAfD08c0295C392436245E5bc78B0185"
        last_master_copy_initial_block = 10329734
        last_master_copy = SafeMasterCopy.objects.get(address=last_master_copy_address)
        self.assertEqual(
            last_master_copy.initial_block_number, last_master_copy_initial_block
        )
        self.assertEqual(
            last_master_copy.tx_block_number, last_master_copy_initial_block
        )

        # Check last proxy factory was created
        last_proxy_factory_address = "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B"
        last_proxy_factory_initial_block = 9084508
        last_proxy_factory = ProxyFactory.objects.get(
            address=last_proxy_factory_address
        )
        self.assertEqual(
            last_proxy_factory.initial_block_number, last_proxy_factory_initial_block
        )
        self.assertEqual(
            last_proxy_factory.tx_block_number, last_proxy_factory_initial_block
        )

        self.assertEqual(SafeMasterCopy.objects.count(), 8)
        self.assertEqual(SafeMasterCopy.objects.l2().count(), 1)
        self.assertEqual(ProxyFactory.objects.count(), 4)

    def test_setup_service_rinkeby(self):
        self._test_setup_service(EthereumNetwork.RINKEBY)

    def test_setup_service_goerli(self):
        self._test_setup_service(EthereumNetwork.GOERLI)

    def test_setup_service_kovan(self):
        self._test_setup_service(EthereumNetwork.KOVAN)

    @mock.patch.object(EthereumClient, "get_network", autospec=True)
    def test_setup_service_not_valid_network(
        self, ethereum_client_get_network_mock: MagicMock
    ):
        command = "setup_service"
        for return_value in (EthereumNetwork.ROPSTEN, EthereumNetwork.UNKNOWN):
            ethereum_client_get_network_mock.return_value = return_value
            buf = StringIO()
            call_command(command, stdout=buf)
            self.assertIn("Cannot detect a valid ethereum-network", buf.getvalue())

    def test_export_multisig_tx_data(self):
        with tempfile.TemporaryDirectory() as tmpdirname:
            command = "export_multisig_tx_data"
            arguments = "--file-name=" + os.path.join(tmpdirname, "result.csv")
            buf = StringIO()
            call_command(command, arguments, stdout=buf)
            self.assertIn("Start exporting of 0", buf.getvalue())

            MultisigTransactionFactory(origin="something")
            MultisigTransactionFactory(
                origin="another-something", ethereum_tx=None
            )  # Will not be exported
            MultisigTransactionFactory(origin={})  # Will not be exported
            buf = StringIO()
            call_command(command, arguments, stdout=buf)
            self.assertIn("Start exporting of 1", buf.getvalue())

'''
'''--- safe_transaction_service/history/tests/test_delegate_signature_helper.py ---
from django.test import TestCase

from eth_account import Account
from eth_account.messages import defunct_hash_message

from ..helpers import DelegateSignatureHelper

class TestDelegateSignatureHelper(TestCase):
    def test_delegate_signature_helper(self):
        address = Account.create().address

        elements = {
            DelegateSignatureHelper.calculate_hash(address),
            DelegateSignatureHelper.calculate_hash(address, eth_sign=True),
            DelegateSignatureHelper.calculate_hash(address, previous_totp=True),
            DelegateSignatureHelper.calculate_hash(
                address, eth_sign=True, previous_totp=True
            ),
        }
        self.assertEqual(len(elements), 4)  # Not repeated elements

    def test_delegate_eth_sign(self):
        totp = DelegateSignatureHelper.calculate_totp()
        address = Account.create().address
        message = address + str(totp)
        Account.sign_message
        signable_hash = defunct_hash_message(text=message)

        self.assertEqual(
            signable_hash,
            DelegateSignatureHelper.calculate_hash(address, eth_sign=True),
        )

'''
'''--- safe_transaction_service/history/tests/test_erc20_events_indexer.py ---
import copy
from unittest import mock

from django.test import TestCase

from gnosis.eth.tests.ethereum_test_case import EthereumTestCaseMixin

from ..indexers import Erc20EventsIndexer, Erc20EventsIndexerProvider
from ..models import ERC20Transfer, EthereumTx, IndexingStatus
from .factories import SafeContractFactory

class TestErc20EventsIndexer(EthereumTestCaseMixin, TestCase):
    def test_erc20_events_indexer(self):
        erc20_events_indexer = Erc20EventsIndexerProvider()
        erc20_events_indexer.confirmations = 0
        self.assertEqual(erc20_events_indexer.start(), 0)

        account = self.ethereum_test_account
        amount = 10
        erc20_contract = self.deploy_example_erc20(amount, account.address)

        safe_contract = SafeContractFactory()
        IndexingStatus.objects.set_erc20_721_indexing_status(0)
        tx_hash = self.ethereum_client.erc20.send_tokens(
            safe_contract.address, amount, erc20_contract.address, account.key
        )

        self.assertFalse(EthereumTx.objects.filter(tx_hash=tx_hash).exists())
        self.assertFalse(
            ERC20Transfer.objects.tokens_used_by_address(safe_contract.address)
        )

        self.assertEqual(erc20_events_indexer.start(), 1)

        # Erc20/721 last indexed block number is stored on IndexingStatus
        self.assertGreater(
            IndexingStatus.objects.get_erc20_721_indexing_status().block_number, 0
        )

        self.assertEqual(
            IndexingStatus.objects.get_erc20_721_indexing_status().block_number,
            self.ethereum_client.current_block_number
            - erc20_events_indexer.confirmations,
        )
        self.assertTrue(EthereumTx.objects.filter(tx_hash=tx_hash).exists())
        self.assertTrue(
            ERC20Transfer.objects.tokens_used_by_address(safe_contract.address)
        )

        self.assertEqual(
            ERC20Transfer.objects.to_or_from(safe_contract.address).count(), 1
        )

        # Test _process_decoded_element
        block_number = self.ethereum_client.get_transaction(tx_hash)["blockNumber"]
        event = self.ethereum_client.erc20.get_total_transfer_history(
            from_block=block_number, to_block=block_number
        )[0]
        self.assertIn("value", event["args"])

        original_event = copy.deepcopy(event)
        event["args"]["unknown"] = event["args"].pop("value")

        self.assertEqual(
            erc20_events_indexer._process_decoded_element(event), original_event
        )

        # Test ERC721
        event = self.ethereum_client.erc20.get_total_transfer_history(
            from_block=block_number, to_block=block_number
        )[0]
        with mock.patch.object(
            Erc20EventsIndexer, "_is_erc20", autospec=True, return_value=False
        ):
            # Convert event to erc721
            event["args"]["tokenId"] = event["args"].pop("value")
            original_event = copy.deepcopy(event)
            event["args"]["unknown"] = event["args"].pop("tokenId")

            self.assertEqual(
                erc20_events_indexer._process_decoded_element(event), original_event
            )

        event = self.ethereum_client.erc20.get_total_transfer_history(
            from_block=block_number, to_block=block_number
        )[0]
        with mock.patch.object(
            Erc20EventsIndexer, "_is_erc20", autospec=True, return_value=True
        ):
            # Convert event to erc721
            original_event = copy.deepcopy(event)
            event["args"]["tokenId"] = event["args"].pop("value")

            # ERC721 event will be converted to ERC20
            self.assertEqual(
                erc20_events_indexer._process_decoded_element(event), original_event
            )

'''
'''--- safe_transaction_service/history/tests/test_index_service.py ---
from unittest import mock
from unittest.mock import PropertyMock

from django.test import TestCase

from eth_account import Account
from web3 import Web3

from gnosis.eth import EthereumClient
from gnosis.eth.tests.ethereum_test_case import EthereumTestCaseMixin

from ..models import EthereumTx, IndexingStatus, MultisigTransaction, SafeStatus
from ..services.index_service import (
    IndexService,
    IndexServiceProvider,
    TransactionNotFoundException,
)
from .factories import (
    EthereumTxFactory,
    MultisigTransactionFactory,
    SafeMasterCopyFactory,
    SafeStatusFactory,
)

class TestIndexService(EthereumTestCaseMixin, TestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.index_service = IndexServiceProvider()

    @classmethod
    def tearDownClass(cls):
        super().tearDownClass()
        IndexServiceProvider.del_singleton()

    def test_create_or_update_from_tx_hashes_existing(self):
        index_service: IndexService = self.index_service
        self.assertListEqual(index_service.txs_create_or_update_from_tx_hashes([]), [])
        tx_hashes = [
            "0x52fcb05f2ad209d53d84b0a9a7ce6474ab415db88bc364c088758d70c8b5b0ef"
        ]
        with self.assertRaisesMessage(TransactionNotFoundException, tx_hashes[0]):
            index_service.txs_create_or_update_from_tx_hashes(tx_hashes)

        # Test with database txs. Use block_number > current_block_number to prevent storing blocks with wrong
        # hashes that will be indexed by next tests
        current_block_number = self.ethereum_client.current_block_number
        ethereum_txs = [
            EthereumTxFactory(block__number=current_block_number + 100 + i)
            for i in range(4)
        ]
        tx_hashes = [ethereum_tx.tx_hash for ethereum_tx in ethereum_txs]
        db_txs = index_service.txs_create_or_update_from_tx_hashes(tx_hashes)
        self.assertEqual(len(db_txs), len(tx_hashes))
        for db_tx in db_txs:
            self.assertIsNotNone(db_tx)

        # Test with real txs
        value = 6
        real_tx_hashes = [
            self.send_ether(Account.create().address, value) for _ in range(2)
        ]
        ethereum_txs = index_service.txs_create_or_update_from_tx_hashes(real_tx_hashes)
        self.assertEqual(len(ethereum_txs), len(ethereum_txs))
        for ethereum_tx in ethereum_txs:
            self.assertEqual(ethereum_tx.value, value)

        # Remove blocks and try again
        EthereumTx.objects.filter(tx_hash__in=real_tx_hashes).update(block=None)
        ethereum_txs = index_service.txs_create_or_update_from_tx_hashes(real_tx_hashes)
        for ethereum_tx in ethereum_txs:
            self.assertIsNotNone(ethereum_tx.block)

        # Test mixed
        tx_hashes = tx_hashes + real_tx_hashes
        mixed_txs = index_service.txs_create_or_update_from_tx_hashes(tx_hashes)
        self.assertEqual(len(mixed_txs), len(tx_hashes))
        for mixed_tx in mixed_txs:
            self.assertIsNotNone(mixed_tx)

        # Test block hash changes
        ethereum_tx = ethereum_txs[0]
        ethereum_tx.block.block_hash = Web3.keccak(text="aloha")
        ethereum_tx.block.save(update_fields=["block_hash"])
        tx_hash = ethereum_tx.tx_hash

        # Uses database
        index_service.txs_create_or_update_from_tx_hashes([tx_hash])
        ethereum_tx.delete()

    @mock.patch.object(
        EthereumClient, "current_block_number", new_callable=PropertyMock
    )
    def test_is_service_synced(self, current_block_number_mock: PropertyMock):
        IndexingStatus.objects.set_erc20_721_indexing_status(500)
        current_block_number_mock.return_value = 500
        self.assertTrue(self.index_service.is_service_synced())
        reorg_blocks = self.index_service.eth_reorg_blocks

        safe_master_copy = SafeMasterCopyFactory(
            tx_block_number=current_block_number_mock.return_value - reorg_blocks - 1
        )
        self.assertFalse(self.index_service.is_service_synced())
        safe_master_copy.tx_block_number = safe_master_copy.tx_block_number + 1
        safe_master_copy.save(update_fields=["tx_block_number"])
        self.assertTrue(self.index_service.is_service_synced())

        IndexingStatus.objects.set_erc20_721_indexing_status(
            current_block_number_mock.return_value - reorg_blocks - 1
        )
        self.assertFalse(self.index_service.is_service_synced())
        IndexingStatus.objects.set_erc20_721_indexing_status(
            current_block_number_mock.return_value - reorg_blocks
        )
        self.assertTrue(self.index_service.is_service_synced())

    def test_reprocess_addresses(self):
        index_service: IndexService = self.index_service
        self.assertIsNone(index_service.reprocess_addresses([]))

        safe_status = SafeStatusFactory()
        MultisigTransactionFactory()  # It shouldn't be deleted (safe not matching)
        MultisigTransactionFactory(
            safe=safe_status.address, origin={}
        )  # It should be deleted
        MultisigTransactionFactory(
            safe=safe_status.address, ethereum_tx=None
        )  # It shouldn't be deleted
        MultisigTransactionFactory(
            safe=safe_status.address, origin="Something"
        )  # It shouldn't be deleted
        self.assertEqual(MultisigTransaction.objects.count(), 4)
        self.assertIsNone(index_service.reprocess_addresses([safe_status.address]))
        self.assertEqual(SafeStatus.objects.count(), 0)
        self.assertEqual(MultisigTransaction.objects.count(), 3)

    def test_reprocess_all(self):
        index_service: IndexService = self.index_service
        for _ in range(5):
            safe_status = SafeStatusFactory()
            MultisigTransactionFactory(safe=safe_status.address, origin={})

        MultisigTransactionFactory(ethereum_tx=None)  # It shouldn't be deleted
        MultisigTransactionFactory(origin="Something")  # It shouldn't be deleted

        self.assertEqual(MultisigTransaction.objects.count(), 7)
        self.assertIsNone(index_service.reprocess_all())
        self.assertEqual(SafeStatus.objects.count(), 0)
        self.assertEqual(MultisigTransaction.objects.count(), 2)

'''
'''--- safe_transaction_service/history/tests/test_internal_tx_indexer.py ---
import itertools
from collections import OrderedDict
from unittest import mock
from unittest.mock import MagicMock, PropertyMock

from django.test import TestCase

from eth_typing import HexStr

from gnosis.eth import EthereumClient
from gnosis.eth.ethereum_client import ParityManager

from ..indexers import InternalTxIndexer, InternalTxIndexerProvider
from ..indexers.internal_tx_indexer import InternalTxIndexerWithTraceBlock
from ..indexers.tx_processor import SafeTxProcessorProvider
from ..models import (
    EthereumBlock,
    EthereumTx,
    IndexingStatus,
    InternalTx,
    InternalTxDecoded,
    SafeContract,
    SafeLastStatus,
    SafeMasterCopy,
    SafeStatus,
)
from .factories import SafeMasterCopyFactory
from .mocks.mocks_internal_tx_indexer import (
    block_result,
    trace_blocks_filtered_0x5aC2_result,
    trace_blocks_result,
    trace_filter_result,
    trace_transactions_result,
    transaction_receipts_result,
    transactions_result,
)

class TestInternalTxIndexer(TestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.internal_tx_indexer = InternalTxIndexerProvider()
        cls.internal_tx_indexer.blocks_to_reindex_again = 0

    @classmethod
    def tearDownClass(cls):
        super().tearDownClass()
        InternalTxIndexerProvider.del_singleton()

    def test_internal_tx_indexer_provider(self):
        internal_tx_indexer = InternalTxIndexerProvider()
        self.assertIsInstance(internal_tx_indexer, InternalTxIndexer)
        self.assertNotIsInstance(internal_tx_indexer, InternalTxIndexerWithTraceBlock)
        InternalTxIndexerProvider.del_singleton()
        with self.settings(ETH_INTERNAL_NO_FILTER=True):
            internal_tx_indexer = InternalTxIndexerProvider()
            self.assertIsInstance(
                internal_tx_indexer,
                (InternalTxIndexer, InternalTxIndexerWithTraceBlock),
            )

    def return_sorted_blocks(self, hashes: HexStr):
        block_dict = {block["hash"].hex(): block for block in block_result}
        return [block_dict[provided_hash] for provided_hash in hashes]

    @mock.patch.object(
        ParityManager, "trace_blocks", autospec=True, return_value=trace_blocks_result
    )
    @mock.patch.object(
        ParityManager, "trace_filter", autospec=True, return_value=trace_filter_result
    )
    @mock.patch.object(
        ParityManager,
        "trace_transactions",
        autospec=True,
        return_value=trace_transactions_result,
    )
    @mock.patch.object(
        EthereumClient, "get_blocks", autospec=True, side_effect=return_sorted_blocks
    )
    @mock.patch.object(
        EthereumClient,
        "get_transaction_receipts",
        autospec=True,
        return_value=transaction_receipts_result,
    )
    @mock.patch.object(
        EthereumClient,
        "get_transactions",
        autospec=True,
        return_value=transactions_result,
    )
    @mock.patch.object(
        EthereumClient,
        "current_block_number",
        new_callable=PropertyMock,
        return_value=2000,
    )
    def _test_internal_tx_indexer(
        self,
        current_block_number_mock: MagicMock,
        transactions_mock: MagicMock,
        transaction_receipts_mock: MagicMock,
        blocks_mock: MagicMock,
        trace_transactions_mock: MagicMock,
        trace_filter_mock: MagicMock,
        trace_block_mock: MagicMock,
    ):
        current_block_number = current_block_number_mock.return_value

        internal_tx_indexer = self.internal_tx_indexer
        self.assertEqual(
            internal_tx_indexer.ethereum_client.current_block_number,
            current_block_number,
        )
        self.assertIsNone(current_block_number_mock.assert_called_with())

        internal_tx_indexer.start()  # No SafeMasterCopy to index

        safe_master_copy: SafeMasterCopy = SafeMasterCopyFactory(
            address="0x5aC255889882aCd3da2aA939679E3f3d4cea221e"
        )
        self.assertEqual(safe_master_copy.tx_block_number, 0)
        internal_tx_indexer.start()

        self.assertEqual(EthereumTx.objects.count(), len(transactions_result))
        self.assertEqual(EthereumBlock.objects.count(), len(block_result))
        # Just store useful traces 2 decoded + 1 contract creation + 2 ether transfers
        self.assertEqual(InternalTx.objects.count(), 5)
        self.assertEqual(InternalTxDecoded.objects.count(), 2)
        create_internal_tx = InternalTx.objects.get(
            contract_address="0x673Fd582FED2CD8201d58552B912F0D1DaA37bB2"
        )
        self.assertFalse(create_internal_tx.is_call)
        self.assertFalse(create_internal_tx.is_delegate_call)
        self.assertTrue(create_internal_tx.is_create)

        ethereum_tx = EthereumTx.objects.get(
            tx_hash="0x18f8eb25336203d4e561229c08a3a0ef88db1dd9767b641301d9ea3121dfeaea"
        )
        self.assertEqual(ethereum_tx.block.number, 6045252)
        self.assertEqual(
            ethereum_tx.block.block_hash,
            "0x39ba45ad930dece3aec537c8c5cd615daf7ee39a2513475e7680ec226e90b923",
        )
        self.assertEqual(len(ethereum_tx.logs), 1)

        ethereum_tx = EthereumTx.objects.get(
            tx_hash="0xf554b52dcb336b83bf31e7e2e7aa94853a456f01a139a6b7dec71329460dfb61"
        )
        self.assertEqual(ethereum_tx.block.number, 6045275)
        self.assertEqual(
            ethereum_tx.block.block_hash,
            "0x08df561efd3d242263d8a117e32c1beb08454c87df0a287cf93fa39f0675cf04",
        )
        self.assertEqual(ethereum_tx.logs, [])

        trace_filter_mock.assert_called_once_with(
            internal_tx_indexer.ethereum_client.parity,
            from_block=1,
            to_block=current_block_number - internal_tx_indexer.number_trace_blocks,
            to_address=[safe_master_copy.address],
        )
        trace_block_mock.assert_called_with(
            internal_tx_indexer.ethereum_client.parity,
            list(
                range(
                    current_block_number - internal_tx_indexer.number_trace_blocks,
                    current_block_number + 1 - internal_tx_indexer.confirmations,
                )
            ),
        )

    def test_internal_tx_indexer(self):
        self._test_internal_tx_indexer()

    @mock.patch.object(
        ParityManager,
        "trace_blocks",
        autospec=True,
        return_value=trace_blocks_filtered_0x5aC2_result,
    )
    @mock.patch.object(
        ParityManager, "trace_filter", autospec=True, return_value=trace_filter_result
    )
    @mock.patch.object(
        EthereumClient,
        "current_block_number",
        new_callable=PropertyMock,
        return_value=2000,
    )
    def test_find_relevant_elements(
        self,
        current_block_number_mock: MagicMock,
        trace_filter_mock: MagicMock,
        trace_block_mock: MagicMock,
    ):
        current_block_number = current_block_number_mock.return_value
        internal_tx_indexer = self.internal_tx_indexer
        addresses = ["0x5aC255889882aCd3da2aA939679E3f3d4cea221e"]
        trace_filter_transactions = OrderedDict(
            (trace["transactionHash"], []) for trace in trace_filter_mock.return_value
        )
        trace_block_transactions = OrderedDict(
            (
                (k, list(v))
                for k, v in itertools.groupby(
                    itertools.chain(*trace_block_mock.return_value),
                    lambda x: x["transactionHash"],
                )
            )
        )

        # Just trace filter
        elements = internal_tx_indexer.find_relevant_elements(
            addresses, 1, current_block_number - 50
        )
        self.assertEqual(trace_filter_transactions, elements)
        trace_filter_mock.assert_called_once_with(
            internal_tx_indexer.ethereum_client.parity,
            from_block=1,
            to_block=current_block_number - 50,
            to_address=addresses,
        )
        trace_block_mock.assert_not_called()
        trace_filter_mock.reset_mock()

        # Mixed trace_block and trace_filter
        elements = internal_tx_indexer.find_relevant_elements(
            addresses, current_block_number - 50, current_block_number
        )
        self.assertEqual(trace_filter_transactions | trace_block_transactions, elements)
        trace_filter_mock.assert_called_once_with(
            internal_tx_indexer.ethereum_client.parity,
            from_block=current_block_number - 50,
            to_block=current_block_number - internal_tx_indexer.number_trace_blocks,
            to_address=addresses,
        )

        trace_block_mock.assert_called_with(
            internal_tx_indexer.ethereum_client.parity,
            list(
                range(
                    current_block_number - internal_tx_indexer.number_trace_blocks,
                    current_block_number + 1,
                )
            ),
        )

        trace_filter_mock.reset_mock()
        trace_block_mock.reset_mock()

        # Just trace block
        elements = internal_tx_indexer.find_relevant_elements(
            addresses, current_block_number - 3, current_block_number
        )
        self.assertEqual(trace_block_transactions, elements)
        trace_filter_mock.assert_not_called()

        trace_block_mock.assert_called_with(
            internal_tx_indexer.ethereum_client.parity,
            list(range(current_block_number - 3, current_block_number + 1)),
        )

    def test_tx_processor_using_internal_tx_indexer(self):
        self._test_internal_tx_indexer()
        tx_processor = SafeTxProcessorProvider()
        self.assertEqual(InternalTxDecoded.objects.count(), 2)  # Setup and execute tx
        internal_txs_decoded = InternalTxDecoded.objects.pending_for_safes()
        self.assertEqual(len(internal_txs_decoded), 2)
        number_processed = tx_processor.process_decoded_transactions(
            internal_txs_decoded
        )  # Index using `setup` trace
        self.assertEqual(len(number_processed), 2)  # Setup and execute trace
        self.assertEqual(SafeContract.objects.count(), 1)
        self.assertEqual(SafeStatus.objects.count(), 2)

        safe_status = SafeStatus.objects.first()
        self.assertEqual(len(safe_status.owners), 1)
        self.assertEqual(safe_status.nonce, 0)
        self.assertEqual(safe_status.threshold, 1)

        # Try to decode again without new traces, nothing should be decoded
        internal_txs_decoded = InternalTxDecoded.objects.pending_for_safes()
        self.assertEqual(
            len(internal_txs_decoded), 0
        )  # Safe indexed, execute tx can be decoded now
        number_processed = tx_processor.process_decoded_transactions(
            internal_txs_decoded
        )
        self.assertEqual(len(number_processed), 0)  # Setup trace
        safe_status = SafeStatus.objects.get(nonce=1)
        self.assertEqual(len(safe_status.owners), 1)
        self.assertEqual(safe_status.threshold, 1)

        safe_last_status = SafeLastStatus.objects.get()
        self.assertEqual(
            safe_last_status, SafeLastStatus.from_status_instance(safe_status)
        )

    def test_tx_processor_using_internal_tx_indexer_with_existing_safe(self):
        self._test_internal_tx_indexer()
        tx_processor = SafeTxProcessorProvider()
        tx_processor.process_decoded_transactions(
            InternalTxDecoded.objects.pending_for_safes()
        )
        self.assertEqual(
            IndexingStatus.objects.get_erc20_721_indexing_status().block_number, 0
        )

        SafeStatus.objects.all().delete()
        InternalTxDecoded.objects.update(processed=False)
        internal_txs_decoded = InternalTxDecoded.objects.pending_for_safes()
        self.assertEqual(internal_txs_decoded.count(), 2)
        self.assertEqual(internal_txs_decoded[0].function_name, "setup")
        results = tx_processor.process_decoded_transactions(internal_txs_decoded)
        self.assertEqual(results, [True, True])

'''
'''--- safe_transaction_service/history/tests/test_migrations.py ---
import json

from django.test import TestCase
from django.utils import timezone

from django_test_migrations.migrator import Migrator
from eth_account import Account
from web3 import Web3

class TestMigrations(TestCase):
    def setUp(self) -> None:
        self.migrator = Migrator(database="default")

    def build_ethereum_tx(self, ethereum_block_class, ethereum_tx_class):
        """
        Factory boy does not work with migrations

        :param ethereum_block_class:
        :param ethereum_tx_class:
        :return: Instance of EthereumTx
        """
        ethereum_block = ethereum_block_class.objects.create(
            number=1,
            gas_limit=2,
            gas_used=2,
            timestamp=timezone.now(),
            block_hash=Web3.keccak(b"34"),
            parent_hash=Web3.keccak(b"12"),
        )

        return ethereum_tx_class.objects.create(
            block=ethereum_block,
            tx_hash=Web3.keccak(b"tx-hash"),
            gas=23000,
            gas_price=1,
            nonce=0,
            value=0,
        )

    def test_migration_forward_0068(self):
        old_state = self.migrator.apply_initial_migration(
            ("history", "0067_auto_20220705_1545")
        )
        MultisigTransactionOld = old_state.apps.get_model(
            "history", "MultisigTransaction"
        )
        origins = [
            "{ {TestString",
            '{"url":"https://example.com", "name":"app"}',
            "",
            None,
        ]
        for origin in origins:
            MultisigTransactionOld.objects.create(
                safe_tx_hash=Web3.keccak(text=f"multisig-tx-{origin}").hex(),
                safe=Account.create().address,
                value=0,
                operation=0,
                safe_tx_gas=0,
                base_gas=0,
                gas_price=0,
                nonce=0,
                origin=origin,
            )

        new_state = self.migrator.apply_tested_migration(
            ("history", "0068_alter_multisigtransaction_origin"),
        )
        MultisigTransactionNew = new_state.apps.get_model(
            "history", "Multisigtransaction"
        )

        # String should keep string
        hash = Web3.keccak(text=f"multisig-tx-{origins[0]}").hex()
        self.assertEqual(MultisigTransactionNew.objects.get(pk=hash).origin, origins[0])

        # String json should be converted to json
        hash = Web3.keccak(text=f"multisig-tx-{origins[1]}").hex()
        self.assertEqual(
            MultisigTransactionNew.objects.get(pk=hash).origin, json.loads(origins[1])
        )

        # Empty string should be empty object
        hash = Web3.keccak(text=f"multisig-tx-{origins[2]}").hex()
        self.assertEqual(MultisigTransactionNew.objects.get(pk=hash).origin, {})

        # None should be empty object
        hash = Web3.keccak(text=f"multisig-tx-{origins[2]}").hex()
        self.assertEqual(MultisigTransactionNew.objects.get(pk=hash).origin, {})

    def test_migration_backward_0068(self):
        new_state = self.migrator.apply_initial_migration(
            ("history", "0068_alter_multisigtransaction_origin")
        )
        MultisigTransactionNew = new_state.apps.get_model(
            "history", "MultisigTransaction"
        )
        origins = ["{ TestString", {"url": "https://example.com", "name": "app"}, {}]
        for origin in origins:
            MultisigTransactionNew.objects.create(
                safe_tx_hash=Web3.keccak(text=f"multisig-tx-{origin}").hex(),
                safe=Account.create().address,
                value=0,
                operation=0,
                safe_tx_gas=0,
                base_gas=0,
                gas_price=0,
                nonce=0,
                origin=origin,
            )

        old_state = self.migrator.apply_tested_migration(
            ("history", "0067_auto_20220705_1545"),
        )
        MultisigTransactionOld = old_state.apps.get_model(
            "history", "Multisigtransaction"
        )

        # String should keep string
        hash = Web3.keccak(text=f"multisig-tx-{origins[0]}").hex()
        self.assertEqual(MultisigTransactionOld.objects.get(pk=hash).origin, origins[0])

        # Json should be converted to a string json
        hash = Web3.keccak(text=f"multisig-tx-{origins[1]}").hex()
        self.assertEqual(
            MultisigTransactionOld.objects.get(pk=hash).origin, json.dumps(origins[1])
        )

        # Empty object should be None
        hash = Web3.keccak(text=f"multisig-tx-{origins[2]}").hex()
        self.assertEqual(MultisigTransactionOld.objects.get(pk=hash).origin, None)

    def test_migration_forward_0069(self):
        old_state = self.migrator.apply_initial_migration(
            ("history", "0068_alter_multisigtransaction_origin")
        )

        EthereumBlock = old_state.apps.get_model("history", "EthereumBlock")
        EthereumTx = old_state.apps.get_model("history", "EthereumTx")
        ethereum_tx = self.build_ethereum_tx(EthereumBlock, EthereumTx)
        SafeContract = old_state.apps.get_model("history", "SafeContract")
        SafeContract.objects.create(
            address=Account.create().address,
            erc20_block_number=8,
            ethereum_tx=ethereum_tx,
        )
        SafeContract.objects.create(
            address=Account.create().address,
            erc20_block_number=4,
            ethereum_tx=ethereum_tx,
        )
        SafeContract.objects.create(
            address=Account.create().address,
            erc20_block_number=15,
            ethereum_tx=ethereum_tx,
        )
        new_state = self.migrator.apply_tested_migration(
            ("history", "0069_indexingstatus_and_more"),
        )
        IndexingStatus = new_state.apps.get_model("history", "IndexingStatus")
        self.assertEqual(IndexingStatus.objects.get().block_number, 4)

    def test_migration_forward_0069_using_master_copies(self):
        old_state = self.migrator.apply_initial_migration(
            ("history", "0068_alter_multisigtransaction_origin")
        )

        SafeMasterCopy = old_state.apps.get_model("history", "SafeMasterCopy")
        SafeMasterCopy.objects.create(
            address=Account.create().address,
            initial_block_number=15,
            tx_block_number=23,
            l2=False,
        )
        SafeMasterCopy.objects.create(
            address=Account.create().address,
            initial_block_number=16,
            tx_block_number=42,
            l2=True,
        )

        new_state = self.migrator.apply_tested_migration(
            ("history", "0069_indexingstatus_and_more"),
        )
        IndexingStatus = new_state.apps.get_model("history", "IndexingStatus")
        self.assertEqual(IndexingStatus.objects.get().block_number, 15)

    def test_migration_backward_0069(self):
        new_state = self.migrator.apply_initial_migration(
            ("history", "0069_indexingstatus_and_more"),
        )
        IndexingStatus = new_state.apps.get_model("history", "IndexingStatus")
        self.assertEqual(IndexingStatus.objects.get().block_number, 0)
        IndexingStatus.objects.update(block_number=4)

        EthereumBlock = new_state.apps.get_model("history", "EthereumBlock")
        EthereumTx = new_state.apps.get_model("history", "EthereumTx")
        SafeContract = new_state.apps.get_model("history", "SafeContract")
        ethereum_tx = self.build_ethereum_tx(EthereumBlock, EthereumTx)
        SafeContract.objects.create(
            address=Account.create().address, ethereum_tx=ethereum_tx
        )
        SafeContract.objects.create(
            address=Account.create().address, ethereum_tx=ethereum_tx
        )
        SafeContract.objects.create(
            address=Account.create().address, ethereum_tx=ethereum_tx
        )

        old_state = self.migrator.apply_tested_migration(
            ("history", "0068_alter_multisigtransaction_origin")
        )
        SafeContract = old_state.apps.get_model("history", "SafeContract")
        self.assertEqual(SafeContract.objects.filter(erc20_block_number=4).count(), 3)

    def test_migration_backward_0069_db_empty(self):
        new_state = self.migrator.apply_initial_migration(
            ("history", "0069_indexingstatus_and_more"),
        )
        IndexingStatus = new_state.apps.get_model("history", "IndexingStatus")
        self.assertEqual(IndexingStatus.objects.get().block_number, 0)
        IndexingStatus.objects.all().delete()

        EthereumBlock = new_state.apps.get_model("history", "EthereumBlock")
        EthereumTx = new_state.apps.get_model("history", "EthereumTx")
        SafeContract = new_state.apps.get_model("history", "SafeContract")
        ethereum_tx = self.build_ethereum_tx(EthereumBlock, EthereumTx)
        SafeContract.objects.create(
            address=Account.create().address, ethereum_tx=ethereum_tx
        )
        SafeContract.objects.create(
            address=Account.create().address, ethereum_tx=ethereum_tx
        )
        SafeContract.objects.create(
            address=Account.create().address, ethereum_tx=ethereum_tx
        )

        old_state = self.migrator.apply_tested_migration(
            ("history", "0068_alter_multisigtransaction_origin")
        )
        SafeContract = old_state.apps.get_model("history", "SafeContract")
        self.assertEqual(SafeContract.objects.filter(erc20_block_number=0).count(), 3)

'''
'''--- safe_transaction_service/history/tests/test_models.py ---
import logging
from datetime import timedelta
from unittest import mock

from django.core.exceptions import ValidationError
from django.db import IntegrityError
from django.db.models import QuerySet
from django.test import TestCase
from django.utils import timezone

from eth_account import Account
from web3 import Web3

from gnosis.safe.safe_signature import SafeSignatureType

from safe_transaction_service.contracts.models import ContractQuerySet
from safe_transaction_service.contracts.tests.factories import ContractFactory

from ...tokens.tests.factories import TokenFactory
from ..models import (
    ERC20Transfer,
    ERC721Transfer,
    EthereumBlock,
    EthereumBlockManager,
    EthereumTx,
    EthereumTxCallType,
    InternalTx,
    InternalTxDecoded,
    MultisigConfirmation,
    MultisigTransaction,
    SafeContractDelegate,
    SafeLastStatus,
    SafeMasterCopy,
    SafeStatus,
    WebHook,
)
from .factories import (
    ERC20TransferFactory,
    ERC721TransferFactory,
    EthereumBlockFactory,
    EthereumTxFactory,
    InternalTxDecodedFactory,
    InternalTxFactory,
    MultisigConfirmationFactory,
    MultisigTransactionFactory,
    SafeContractDelegateFactory,
    SafeContractFactory,
    SafeLastStatusFactory,
    SafeMasterCopyFactory,
    SafeStatusFactory,
    WebHookFactory,
)
from .mocks.mocks_ethereum_tx import type_0_tx, type_2_tx
from .mocks.mocks_internal_tx_indexer import block_result

logger = logging.getLogger(__name__)

class TestModelSignals(TestCase):
    def test_bind_confirmations(self):
        safe_tx_hash = Web3.keccak(text="prueba")
        ethereum_tx = EthereumTxFactory()
        MultisigConfirmation.objects.create(
            ethereum_tx=ethereum_tx,
            multisig_transaction_hash=safe_tx_hash,
            owner=Account.create().address,
            signature_type=SafeSignatureType.EOA.value,
        )
        multisig_tx, _ = MultisigTransaction.objects.get_or_create(
            safe_tx_hash=safe_tx_hash,
            safe=Account.create().address,
            ethereum_tx=None,
            to=Account.create().address,
            value=0,
            data=None,
            operation=0,
            safe_tx_gas=100000,
            base_gas=20000,
            gas_price=1,
            gas_token=None,
            refund_receiver=None,
            signatures=None,
            nonce=0,
        )
        self.assertEqual(multisig_tx.confirmations.count(), 1)

    def test_bind_confirmations_reverse(self):
        safe_tx_hash = Web3.keccak(text="prueba")
        ethereum_tx = EthereumTxFactory()
        multisig_tx, _ = MultisigTransaction.objects.get_or_create(
            safe_tx_hash=safe_tx_hash,
            safe=Account.create().address,
            ethereum_tx=None,
            to=Account.create().address,
            value=0,
            data=None,
            operation=0,
            safe_tx_gas=100000,
            base_gas=20000,
            gas_price=1,
            gas_token=None,
            refund_receiver=None,
            signatures=None,
            nonce=0,
        )
        self.assertEqual(multisig_tx.confirmations.count(), 0)

        MultisigConfirmation.objects.create(
            ethereum_tx=ethereum_tx,
            multisig_transaction_hash=safe_tx_hash,
            owner=Account.create().address,
            signature_type=SafeSignatureType.EOA.value,
        )
        self.assertEqual(multisig_tx.confirmations.count(), 1)

class TestModelMixins(TestCase):
    def test_bulk_create_from_generator(self):
        self.assertEqual(
            InternalTx.objects.bulk_create_from_generator(
                (x for x in range(0)), ignore_conflicts=True
            ),
            0,
        )
        number = 5
        internal_txs = (InternalTxFactory() for _ in range(number))
        self.assertEqual(
            InternalTx.objects.bulk_create_from_generator(
                internal_txs, ignore_conflicts=True
            ),
            number,
        )
        internal_txs = [InternalTxFactory() for _ in range(number)]
        InternalTx.objects.all().delete()
        another_generator = (x for x in internal_txs)
        self.assertEqual(
            InternalTx.objects.bulk_create_from_generator(
                another_generator, batch_size=2
            ),
            number,
        )

class TestMultisigTransaction(TestCase):
    def test_data_should_be_decoded(self):
        try:
            ContractQuerySet.cache_trusted_addresses_for_delegate_call.clear()
            multisig_transaction = MultisigTransactionFactory(
                signatures=None, operation=0
            )
            self.assertTrue(multisig_transaction.data_should_be_decoded())

            multisig_transaction = MultisigTransactionFactory(
                signatures=None, operation=1
            )
            self.assertFalse(multisig_transaction.data_should_be_decoded())

            ContractFactory(
                address=multisig_transaction.to, trusted_for_delegate_call=True
            )
            # Cache is used, so it will still be false
            self.assertFalse(multisig_transaction.data_should_be_decoded())

            # Empty cache
            ContractQuerySet.cache_trusted_addresses_for_delegate_call.clear()
            self.assertTrue(multisig_transaction.data_should_be_decoded())
        finally:
            ContractQuerySet.cache_trusted_addresses_for_delegate_call.clear()

    def test_multisig_transaction_owners(self):
        multisig_transaction = MultisigTransactionFactory(signatures=None)
        self.assertEqual(multisig_transaction.owners, [])

        account = Account.create()
        multisig_transaction.signatures = account.signHash(
            multisig_transaction.safe_tx_hash
        )["signature"]
        multisig_transaction.save()
        self.assertEqual(multisig_transaction.owners, [account.address])

    def test_multisend(self):
        self.assertEqual(MultisigTransaction.objects.multisend().count(), 0)
        MultisigTransactionFactory()

        MultisigTransactionFactory(to="0x998739BFdAAdde7C933B942a68053933098f9EDa")
        self.assertEqual(MultisigTransaction.objects.multisend().count(), 1)

        MultisigTransactionFactory(to="0x40A2aCCbd92BCA938b02010E17A5b8929b49130D")
        self.assertEqual(MultisigTransaction.objects.multisend().count(), 2)

    def test_queued(self):
        safe_address = Account.create().address
        queryset = MultisigTransaction.objects.queued(safe_address)
        self.assertEqual(queryset.count(), 0)
        MultisigTransactionFactory(safe=safe_address, nonce=0, ethereum_tx=None)
        self.assertEqual(queryset.all().count(), 1)
        MultisigTransactionFactory(safe=safe_address, nonce=0)
        self.assertEqual(queryset.all().count(), 0)
        MultisigTransactionFactory(safe=safe_address, nonce=1, ethereum_tx=None)
        self.assertEqual(queryset.all().count(), 1)
        MultisigTransactionFactory(safe=safe_address, nonce=2, ethereum_tx=None)
        self.assertEqual(queryset.all().count(), 2)
        MultisigTransactionFactory(nonce=10)  # Other Safe, it must not affect
        self.assertEqual(queryset.all().count(), 2)
        MultisigTransactionFactory(safe=safe_address, nonce=10)  # Last executed tx
        self.assertEqual(queryset.all().count(), 0)
        MultisigTransactionFactory(
            safe=safe_address, nonce=7, ethereum_tx=None
        )  # Not queued (7 < 10)
        MultisigTransactionFactory(
            safe=safe_address, nonce=22, ethereum_tx=None
        )  # Queued (22 > 10)
        MultisigTransactionFactory(
            safe=safe_address, nonce=22, ethereum_tx=None
        )  # Queued (22 > 10)
        MultisigTransactionFactory(
            safe=safe_address, nonce=57, ethereum_tx=None
        )  # Queued (22 > 10)
        self.assertEqual(queryset.all().count(), 3)
        MultisigTransactionFactory(
            safe=safe_address, nonce=22
        )  # only nonce=57 will be queued
        self.assertEqual(queryset.all().count(), 1)

class TestSafeMasterCopy(TestCase):
    def test_safe_master_copy_sorting(self):
        SafeMasterCopy.objects.create(
            address=Account.create().address, initial_block_number=3, tx_block_number=5
        )

        SafeMasterCopy.objects.create(
            address=Account.create().address, initial_block_number=2, tx_block_number=1
        )

        SafeMasterCopy.objects.create(
            address=Account.create().address, initial_block_number=6, tx_block_number=3
        )

        initial_block_numbers = [
            safe_master_copy.initial_block_number
            for safe_master_copy in SafeMasterCopy.objects.all()
        ]

        self.assertEqual(initial_block_numbers, [2, 6, 3])

    def test_get_version_for_address(self):
        random_address = Account.create().address
        self.assertIsNone(
            SafeMasterCopy.objects.get_version_for_address(random_address)
        )

        safe_master_copy = SafeMasterCopyFactory(address=random_address)
        self.assertTrue(safe_master_copy.version)
        self.assertEqual(
            SafeMasterCopy.objects.get_version_for_address(random_address),
            safe_master_copy.version,
        )

    def test_master_copy_relevant(self):
        SafeMasterCopyFactory(l2=True)
        SafeMasterCopyFactory(l2=False)
        SafeMasterCopyFactory(l2=False)

        with self.settings(ETH_L2_NETWORK=True):
            self.assertEqual(SafeMasterCopy.objects.relevant().count(), 1)
            self.assertEqual(SafeMasterCopy.objects.relevant().get().l2, True)

        with self.settings(ETH_L2_NETWORK=False):
            self.assertEqual(SafeMasterCopy.objects.relevant().count(), 3)

    def test_validate_version(self):
        safe_master_copy = SafeMasterCopyFactory()
        safe_master_copy.version = ""
        with self.assertRaisesMessage(ValidationError, "cannot be blank"):
            safe_master_copy.full_clean()

        safe_master_copy.version = "not_a_version"
        with self.assertRaisesMessage(ValidationError, "is not a valid version"):
            safe_master_copy.full_clean()

        safe_master_copy.version = "2.0.1"
        self.assertIsNone(safe_master_copy.full_clean())

class TestEthereumTx(TestCase):
    def test_create_from_tx_dict(self):
        for tx_mock in (type_0_tx, type_2_tx):
            with self.subTest(tx_mock=tx_mock):
                tx_dict = tx_mock["tx"]
                ethereum_tx = EthereumTx.objects.create_from_tx_dict(tx_dict)
                self.assertEqual(ethereum_tx.type, int(tx_dict["type"], 0))
                self.assertEqual(ethereum_tx.gas_price, tx_dict["gasPrice"])
                self.assertEqual(
                    ethereum_tx.max_fee_per_gas, tx_dict.get("maxFeePerGas")
                )
                self.assertEqual(
                    ethereum_tx.max_priority_fee_per_gas,
                    tx_dict.get("maxPriorityFeePerGas"),
                )
                self.assertIsNone(ethereum_tx.gas_used)
                self.assertIsNone(ethereum_tx.status)
                self.assertIsNone(ethereum_tx.transaction_index)

                tx_receipt = tx_mock["receipt"]
                ethereum_tx.delete()
                ethereum_tx = EthereumTx.objects.create_from_tx_dict(
                    tx_dict, tx_receipt=tx_receipt
                )
                self.assertEqual(ethereum_tx.gas_price, tx_receipt["effectiveGasPrice"])
                self.assertEqual(
                    ethereum_tx.max_fee_per_gas, tx_dict.get("maxFeePerGas")
                )
                self.assertEqual(
                    ethereum_tx.max_priority_fee_per_gas,
                    tx_dict.get("maxPriorityFeePerGas"),
                )
                self.assertEqual(ethereum_tx.gas_used, tx_receipt["gasUsed"])
                self.assertEqual(ethereum_tx.status, tx_receipt["status"])
                self.assertEqual(
                    ethereum_tx.transaction_index, tx_receipt["transactionIndex"]
                )

class TestTokenTransfer(TestCase):
    def test_transfer_to_erc721(self):
        erc20_transfer = ERC20TransferFactory()
        self.assertEqual(ERC721Transfer.objects.count(), 0)
        erc20_transfer.to_erc721_transfer().save()
        self.assertEqual(ERC721Transfer.objects.count(), 1)
        erc721_transfer = ERC721Transfer.objects.get()
        self.assertEqual(erc721_transfer.ethereum_tx_id, erc20_transfer.ethereum_tx_id)
        self.assertEqual(erc721_transfer.address, erc20_transfer.address)
        self.assertEqual(erc721_transfer.log_index, erc20_transfer.log_index)
        self.assertEqual(erc721_transfer.to, erc20_transfer.to)
        self.assertEqual(erc721_transfer.token_id, erc20_transfer.value)

    def test_transfer_to_erc20(self):
        erc721_transfer = ERC721TransferFactory()
        self.assertEqual(ERC20Transfer.objects.count(), 0)
        erc721_transfer.to_erc20_transfer().save()
        self.assertEqual(ERC20Transfer.objects.count(), 1)
        erc20_transfer = ERC721Transfer.objects.get()
        self.assertEqual(erc721_transfer.ethereum_tx_id, erc20_transfer.ethereum_tx_id)
        self.assertEqual(erc721_transfer.address, erc20_transfer.address)
        self.assertEqual(erc721_transfer.log_index, erc20_transfer.log_index)
        self.assertEqual(erc721_transfer.to, erc20_transfer.to)
        self.assertEqual(erc721_transfer.token_id, erc20_transfer.value)

    def test_erc20_events(self):
        safe_address = Account.create().address
        e1 = ERC20TransferFactory(to=safe_address)
        e2 = ERC20TransferFactory(_from=safe_address)
        ERC20TransferFactory()  # This event should not appear
        self.assertEqual(ERC20Transfer.objects.to_or_from(safe_address).count(), 2)

        self.assertSetEqual(
            ERC20Transfer.objects.tokens_used_by_address(safe_address),
            {e1.address, e2.address},
        )

    def test_erc721_events(self):
        safe_address = Account.create().address
        e1 = ERC721TransferFactory(to=safe_address)
        e2 = ERC721TransferFactory(_from=safe_address)
        ERC721TransferFactory()  # This event should not appear
        self.assertEqual(ERC721Transfer.objects.to_or_from(safe_address).count(), 2)

        self.assertSetEqual(
            ERC721Transfer.objects.tokens_used_by_address(safe_address),
            {e1.address, e2.address},
        )

    def test_incoming_tokens(self):
        address = Account.create().address
        self.assertFalse(InternalTx.objects.token_incoming_txs_for_address(address))
        ERC20TransferFactory(to=address)
        self.assertEqual(
            InternalTx.objects.token_incoming_txs_for_address(address).count(), 1
        )
        ERC721TransferFactory(to=address)
        self.assertEqual(
            InternalTx.objects.token_incoming_txs_for_address(address).count(), 2
        )
        incoming_token_0 = InternalTx.objects.token_incoming_txs_for_address(address)[
            0
        ]  # Erc721 token
        incoming_token_1 = InternalTx.objects.token_incoming_txs_for_address(address)[
            1
        ]  # Erc20 token
        self.assertIsNone(incoming_token_0["_value"])
        self.assertIsNotNone(incoming_token_0["_token_id"])
        self.assertIsNone(incoming_token_1["_token_id"])
        self.assertIsNotNone(incoming_token_1["_value"])

    def test_erc721_owned_by(self):
        random_address = Account.create().address
        self.assertEqual(
            ERC721Transfer.objects.erc721_owned_by(address=random_address), []
        )
        erc721_transfer = ERC721TransferFactory(to=random_address)
        ERC721TransferFactory(
            _from=random_address, token_id=6
        )  # Not appearing as owner it's not the receiver
        ERC721TransferFactory(
            to=Account.create().address
        )  # Not appearing as it's not the owner
        ERC20TransferFactory(to=random_address)  # Not appearing as it's not an erc721
        self.assertEqual(
            len(ERC721Transfer.objects.erc721_owned_by(address=random_address)), 1
        )
        ERC721TransferFactory(
            _from=random_address,
            address=erc721_transfer.address,
            token_id=erc721_transfer.token_id,
        )  # Send the token out
        self.assertEqual(
            len(ERC721Transfer.objects.erc721_owned_by(address=random_address)), 0
        )

        # Send the token to oneself. Should only appear once
        ERC721TransferFactory(to=random_address, token_id=6)
        ERC721TransferFactory(_from=random_address, to=random_address, token_id=6)
        self.assertEqual(
            len(ERC721Transfer.objects.erc721_owned_by(address=random_address)), 1
        )

    def test_erc721_owned_by_trusted_spam(self):
        random_address = Account.create().address
        self.assertEqual(
            ERC721Transfer.objects.erc721_owned_by(address=random_address), []
        )
        erc721_transfer = ERC721TransferFactory(to=random_address)
        erc721_transfer_2 = ERC721TransferFactory(to=random_address)
        token = TokenFactory(address=erc721_transfer.address, spam=True)
        self.assertEqual(
            len(ERC721Transfer.objects.erc721_owned_by(address=random_address)), 2
        )
        self.assertEqual(
            len(
                ERC721Transfer.objects.erc721_owned_by(
                    address=random_address, exclude_spam=True
                )
            ),
            1,
        )

        self.assertEqual(
            len(
                ERC721Transfer.objects.erc721_owned_by(
                    address=random_address, only_trusted=True
                )
            ),
            0,
        )
        token.trusted = True
        token.spam = False
        token.save(update_fields=["trusted", "spam"])
        self.assertEqual(
            len(
                ERC721Transfer.objects.erc721_owned_by(
                    address=random_address, only_trusted=True
                )
            ),
            1,
        )

class TestInternalTx(TestCase):
    def test_ether_and_token_txs(self):
        ethereum_address = Account.create().address
        txs = InternalTx.objects.ether_and_token_txs(ethereum_address)
        self.assertFalse(txs)

        ether_value = 5
        internal_tx = InternalTxFactory(to=ethereum_address, value=ether_value)
        InternalTxFactory(value=ether_value)  # Create tx with a random address too
        txs = InternalTx.objects.ether_and_token_txs(ethereum_address)
        self.assertEqual(txs.count(), 1)
        internal_tx = InternalTxFactory(_from=ethereum_address, value=ether_value)
        self.assertEqual(txs.count(), 2)

        token_value = 10
        ERC20TransferFactory(to=ethereum_address, value=token_value)
        ERC20TransferFactory(value=token_value)  # Create tx with a random address too
        txs = InternalTx.objects.ether_and_token_txs(ethereum_address)
        self.assertEqual(txs.count(), 3)
        ERC20TransferFactory(_from=ethereum_address, value=token_value)
        self.assertEqual(txs.count(), 4)

        for i, tx in enumerate(txs):
            if tx["token_address"]:
                self.assertEqual(tx["_value"], token_value)
            else:
                self.assertEqual(tx["_value"], ether_value)
        self.assertEqual(i, 3)

        self.assertEqual(InternalTx.objects.ether_txs().count(), 3)
        self.assertEqual(InternalTx.objects.token_txs().count(), 3)

    def test_ether_and_token_incoming_txs(self):
        ethereum_address = Account.create().address
        incoming_txs = InternalTx.objects.ether_and_token_incoming_txs(ethereum_address)
        self.assertFalse(incoming_txs)

        ether_value = 5
        internal_tx = InternalTxFactory(to=ethereum_address, value=ether_value)
        InternalTxFactory(value=ether_value)  # Create tx with a random address too
        incoming_txs = InternalTx.objects.ether_and_token_incoming_txs(ethereum_address)
        self.assertEqual(incoming_txs.count(), 1)

        token_value = 10
        ERC20TransferFactory(to=ethereum_address, value=token_value)
        ERC20TransferFactory(value=token_value)  # Create tx with a random address too
        incoming_txs = InternalTx.objects.ether_and_token_incoming_txs(ethereum_address)
        self.assertEqual(incoming_txs.count(), 2)

        # Make internal_tx more recent than ERC20Transfer
        block = EthereumBlockFactory()
        internal_tx.block_number = block.number
        internal_tx.timestamp = block.timestamp
        internal_tx.save(update_fields=["block_number", "timestamp"])

        internal_tx.ethereum_tx.block = (
            block  # As factory has a sequence, it will always be the last
        )
        internal_tx.ethereum_tx.save(update_fields=["block"])

        incoming_tx = InternalTx.objects.ether_and_token_incoming_txs(
            ethereum_address
        ).first()
        self.assertEqual(incoming_tx["_value"], ether_value)
        self.assertIsNone(incoming_tx["token_address"])

    def test_internal_tx_can_be_decoded(self):
        trace_address = "0,0,20,0"
        internal_tx = InternalTxFactory(
            call_type=EthereumTxCallType.DELEGATE_CALL.value,
            trace_address=trace_address,
            error=None,
            data=b"123",
            ethereum_tx__status=1,
        )
        self.assertTrue(internal_tx.can_be_decoded)

        internal_tx.ethereum_tx.status = 0
        self.assertFalse(internal_tx.can_be_decoded)

    def test_internal_txs_can_be_decoded(self):
        InternalTxFactory(call_type=EthereumTxCallType.CALL.value)
        self.assertEqual(InternalTx.objects.can_be_decoded().count(), 0)

        internal_tx = InternalTxFactory(
            call_type=EthereumTxCallType.DELEGATE_CALL.value,
            error=None,
            data=b"123",
            ethereum_tx__status=1,
        )
        self.assertEqual(InternalTx.objects.can_be_decoded().count(), 1)

        InternalTxFactory(
            call_type=EthereumTxCallType.DELEGATE_CALL.value,
            error=None,
            data=None,
            ethereum_tx__status=1,
        )
        self.assertEqual(InternalTx.objects.can_be_decoded().count(), 1)

        InternalTxFactory(
            call_type=EthereumTxCallType.DELEGATE_CALL.value,
            error="aloha",
            data=b"123",
            ethereum_tx__status=1,
        )
        self.assertEqual(InternalTx.objects.can_be_decoded().count(), 1)

        InternalTxFactory(
            call_type=EthereumTxCallType.DELEGATE_CALL.value,
            error="aloha",
            data=b"123",
            ethereum_tx__status=0,
        )
        self.assertEqual(InternalTx.objects.can_be_decoded().count(), 1)

        InternalTxDecoded.objects.create(
            function_name="alo", arguments={}, internal_tx=internal_tx
        )
        self.assertEqual(InternalTx.objects.can_be_decoded().count(), 0)

    def test_internal_txs_bulk(self):
        """
        This is the same for every bulk_insert
        """
        internal_txs = [InternalTxFactory() for _ in range(5)]
        for internal_tx in internal_txs:
            internal_tx.pk = None

        # If bulk inserted with `ignore_conflicts` pk will not be populated
        InternalTx.objects.all().delete()
        InternalTx.objects.bulk_create(internal_txs, ignore_conflicts=True)
        for internal_tx in internal_txs:
            self.assertIsNone(internal_tx.pk)
        InternalTx.objects.all().delete()
        InternalTx.objects.bulk_create(internal_txs[:3])
        with self.assertRaises(IntegrityError):
            InternalTx.objects.bulk_create(
                internal_txs
            )  # Cannot bulk create again first 2 transactions

    def test_get_parent_child(self):
        i = InternalTxFactory(trace_address="0")
        self.assertIsNone(i.get_parent())
        i_2 = InternalTxFactory(trace_address="0,0")
        self.assertIsNone(
            i_2.get_parent()
        )  # They must belong to the same ethereum transaction
        self.assertIsNone(
            i.get_child(0)
        )  # They must belong to the same ethereum transaction
        i_2.ethereum_tx = i.ethereum_tx
        i_2.save()

        self.assertEqual(i_2.get_parent(), i)
        self.assertEqual(i.get_child(0), i_2)
        self.assertIsNone(i.get_child(1))
        self.assertIsNone(i_2.get_child(0))

class TestInternalTxDecoded(TestCase):
    def test_order_by_processing_queue(self):
        self.assertQuerysetEqual(
            InternalTxDecoded.objects.order_by_processing_queue(), []
        )
        ethereum_tx = EthereumTxFactory()
        # `trace_address` is not used for ordering anymore
        internal_tx_decoded_0 = InternalTxDecodedFactory(
            internal_tx__trace_address="0", internal_tx__ethereum_tx=ethereum_tx
        )
        internal_tx_decoded_1 = InternalTxDecodedFactory(
            internal_tx__trace_address="2", internal_tx__ethereum_tx=ethereum_tx
        )
        internal_tx_decoded_15 = InternalTxDecodedFactory(
            internal_tx__trace_address="15", internal_tx__ethereum_tx=ethereum_tx
        )

        self.assertQuerysetEqual(
            InternalTxDecoded.objects.order_by_processing_queue(),
            [internal_tx_decoded_0, internal_tx_decoded_1, internal_tx_decoded_15],
        )

        internal_tx_decoded_15.function_name = "setup"
        internal_tx_decoded_15.save()
        self.assertQuerysetEqual(
            InternalTxDecoded.objects.order_by_processing_queue(),
            [internal_tx_decoded_15, internal_tx_decoded_0, internal_tx_decoded_1],
        )

    def test_safes_pending_to_be_processed(self):
        self.assertCountEqual(
            InternalTxDecoded.objects.safes_pending_to_be_processed(), []
        )

        safe_address_1 = SafeContractFactory().address
        internal_tx_decoded_1 = InternalTxDecodedFactory(
            internal_tx___from=safe_address_1
        )
        InternalTxDecodedFactory(internal_tx___from=safe_address_1)
        results = InternalTxDecoded.objects.safes_pending_to_be_processed()
        self.assertIsInstance(results, QuerySet)
        self.assertCountEqual(results, [safe_address_1])

        safe_address_2 = SafeContractFactory().address
        internal_tx_decoded_2 = InternalTxDecodedFactory(
            internal_tx___from=safe_address_2
        )
        self.assertCountEqual(
            InternalTxDecoded.objects.safes_pending_to_be_processed(),
            [safe_address_1, safe_address_2],
        )

        # Safes with all processed internal txs decoded are not returned
        internal_tx_decoded_1.set_processed()
        internal_tx_decoded_2.set_processed()
        self.assertCountEqual(
            InternalTxDecoded.objects.safes_pending_to_be_processed(), [safe_address_1]
        )

    def test_out_of_order_for_safe(self):
        random_safe = Account.create().address
        self.assertFalse(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))

        i = InternalTxDecodedFactory(
            internal_tx___from=random_safe,
            internal_tx__block_number=10,
            processed=False,
        )
        self.assertFalse(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))

        i.set_processed()
        self.assertFalse(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))

        InternalTxDecodedFactory(
            internal_tx___from=random_safe,
            internal_tx__block_number=11,
            processed=False,
        )
        self.assertFalse(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))

        InternalTxDecodedFactory(
            internal_tx___from=random_safe, internal_tx__block_number=9, processed=False
        )
        self.assertTrue(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))
        i.processed = False
        i.save(update_fields=["processed"])

        self.assertFalse(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))

        InternalTxDecodedFactory(
            internal_tx___from=random_safe, internal_tx__block_number=8, processed=True
        )
        self.assertFalse(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))

        InternalTxDecodedFactory(
            internal_tx___from=random_safe, internal_tx__block_number=9, processed=True
        )
        self.assertFalse(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))

        InternalTxDecodedFactory(
            internal_tx___from=random_safe, internal_tx__block_number=10, processed=True
        )
        self.assertTrue(InternalTxDecoded.objects.out_of_order_for_safe(random_safe))

class TestLastSafeStatus(TestCase):
    def test_insert(self):
        self.assertEqual(SafeStatus.objects.count(), 0)
        self.assertEqual(SafeLastStatus.objects.count(), 0)
        SafeLastStatusFactory()
        self.assertEqual(SafeStatus.objects.count(), 1)
        self.assertEqual(SafeLastStatus.objects.count(), 1)

    def test_update_or_create_from_safe_status(self):
        safe_status = SafeStatusFactory(nonce=0)
        self.assertEqual(SafeStatus.objects.count(), 1)
        self.assertEqual(SafeLastStatus.objects.count(), 0)

        safe_last_status = SafeLastStatus.objects.update_or_create_from_safe_status(
            safe_status
        )
        self.assertEqual(SafeStatus.objects.count(), 1)
        self.assertEqual(SafeLastStatus.objects.count(), 1)

        self.assertEqual(safe_status.internal_tx, safe_last_status.internal_tx)
        self.assertEqual(safe_status.address, safe_last_status.address)
        self.assertEqual(safe_status.owners, safe_last_status.owners)
        self.assertEqual(safe_status.threshold, safe_last_status.threshold)
        self.assertEqual(safe_status.nonce, safe_last_status.nonce)
        self.assertEqual(safe_status.master_copy, safe_last_status.master_copy)
        self.assertEqual(
            safe_status.fallback_handler, safe_last_status.fallback_handler
        )
        self.assertEqual(safe_status.guard, safe_last_status.guard)
        self.assertEqual(safe_status.enabled_modules, safe_last_status.enabled_modules)

        # Update SafeLastStatus
        safe_last_status.internal_tx = InternalTxFactory()
        safe_last_status.nonce = 1
        safe_last_status.save()
        self.assertEqual(SafeStatus.objects.count(), 2)
        self.assertEqual(SafeLastStatus.objects.count(), 1)

    def test_address_for_module(self):
        module_address = Account.create().address
        address = Account.create().address
        address_2 = Account.create().address
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_module(module_address), []
        )
        safe_last_status = SafeLastStatusFactory(
            address=address, nonce=0, enabled_modules=[module_address]
        )
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_module(module_address), [address]
        )
        safe_last_status.delete()
        safe_last_status = SafeLastStatusFactory(address=address, nonce=1)
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_module(module_address), []
        )
        safe_last_status.delete()
        safe_last_status = SafeLastStatusFactory(
            address=address, nonce=2, enabled_modules=[module_address]
        )
        safe_last_status_2 = SafeLastStatusFactory(
            address=address_2, nonce=0, enabled_modules=[module_address]
        )
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_module(module_address),
            [address, address_2],
        )
        # Remove the module from one of the Safes
        new_module = Account.create().address
        safe_last_status.delete()
        safe_last_status = SafeLastStatusFactory(
            address=address, nonce=3, enabled_modules=[new_module]
        )
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_module(module_address), [address_2]
        )

        # Add new module for the other Safe
        safe_last_status_2.delete()
        safe_last_status_2 = SafeLastStatusFactory(
            address=address_2, nonce=1, enabled_modules=[module_address, new_module]
        )
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_module(module_address), [address_2]
        )

        # Remove the module from the other Safe
        safe_last_status_2.delete()
        SafeLastStatusFactory(address=address_2, nonce=2, enabled_modules=[new_module])
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_module(module_address), []
        )

    def test_addresses_for_owner(self):
        owner_address = Account.create().address
        address = Account.create().address
        address_2 = Account.create().address
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_owner(owner_address), []
        )
        safe_last_status = SafeLastStatusFactory(
            address=address, nonce=0, owners=[owner_address]
        )
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_owner(owner_address), [address]
        )
        safe_last_status.delete()
        safe_last_status = SafeLastStatusFactory(address=address, nonce=1)
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_owner(owner_address), []
        )
        safe_last_status.delete()
        safe_last_status = SafeLastStatusFactory(
            address=address, nonce=2, owners=[owner_address]
        )
        safe_last_status_2 = SafeLastStatusFactory(
            address=address_2, nonce=0, owners=[owner_address]
        )
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_owner(owner_address),
            [address, address_2],
        )
        # Remove the owner from one of the Safes
        new_owner = Account.create().address
        safe_last_status.delete()
        safe_last_status = SafeLastStatusFactory(
            address=address, nonce=3, owners=[new_owner]
        )
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_owner(owner_address), [address_2]
        )

        # Add new owner for the other Safe
        safe_last_status_2.delete()
        safe_last_status_2 = SafeLastStatusFactory(
            address=address_2, nonce=1, owners=[owner_address, new_owner]
        )
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_owner(owner_address), [address_2]
        )

        # Remove the owner from the other Safe
        safe_last_status_2.delete()
        SafeLastStatusFactory(address=address_2, nonce=2, owners=[new_owner])
        self.assertCountEqual(
            SafeLastStatus.objects.addresses_for_owner(owner_address), []
        )

class TestSafeLastStatus(TestCase):
    def test_get_or_generate(self):
        address = Account.create().address
        with self.assertRaises(SafeLastStatus.DoesNotExist):
            SafeLastStatus.objects.get_or_generate(address)

        SafeStatusFactory(address=address, nonce=0)
        SafeStatusFactory(address=address, nonce=5)
        self.assertEqual(SafeLastStatus.objects.count(), 0)
        # SafeLastStatus should be created from latest SafeStatus
        self.assertEqual(SafeLastStatus.objects.get_or_generate(address).nonce, 5)
        self.assertEqual(SafeLastStatus.objects.count(), 1)

        # SafeLastStatus was already created and will not be increased
        SafeStatusFactory(address=address, nonce=7)
        self.assertEqual(SafeLastStatus.objects.get_or_generate(address).nonce, 5)

        SafeLastStatus.objects.all().delete()
        SafeLastStatusFactory(address=address, nonce=17)
        self.assertEqual(SafeLastStatus.objects.get_or_generate(address).nonce, 17)

class TestSafeStatus(TestCase):
    def test_safe_status_is_corrupted(self):
        address = Account.create().address
        safe_status = SafeStatusFactory(nonce=0, address=address)
        self.assertFalse(safe_status.is_corrupted())
        safe_status_2 = SafeStatusFactory(nonce=1, address=address)
        self.assertFalse(safe_status_2.is_corrupted())
        safe_status_3 = SafeStatusFactory(nonce=2, address=address)
        self.assertEqual(SafeStatus.objects.count(), 3)
        safe_status_2.delete()
        self.assertEqual(SafeStatus.objects.count(), 2)
        # First SafeStatus is ok, as it has no previous SafeStatus missing
        self.assertFalse(safe_status.is_corrupted())
        self.assertTrue(safe_status_3.is_corrupted())

        SafeStatus.objects.all().delete()
        SafeStatusFactory(nonce=0, address=address)
        SafeStatusFactory(nonce=1, address=address)
        SafeStatusFactory(nonce=1, address=address)
        another_safe_status = SafeStatusFactory(nonce=2, address=address)
        self.assertFalse(another_safe_status.is_corrupted())

    def test_safe_status_last_for_address(self):
        address = Account.create().address
        SafeStatusFactory(address=address, nonce=1)
        SafeStatusFactory(address=address, nonce=0)
        SafeStatusFactory(address=address, nonce=2)
        self.assertEqual(SafeStatus.objects.last_for_address(address).nonce, 2)
        self.assertIsNone(SafeStatus.objects.last_for_address(Account.create().address))

    def test_safe_status_previous(self):
        safe_status_5 = SafeStatusFactory(nonce=5)
        safe_status_7 = SafeStatusFactory(nonce=7)
        self.assertIsNone(safe_status_5.previous())
        self.assertIsNone(safe_status_7.previous())  # Not the same address
        safe_status_5.address = safe_status_7.address
        safe_status_5.save()
        self.assertEqual(safe_status_7.previous(), safe_status_5)

        safe_status_2 = SafeStatusFactory(nonce=2, address=safe_status_5.address)
        self.assertIsNone(safe_status_2.previous())
        self.assertEqual(safe_status_5.previous(), safe_status_2)

class TestSafeContract(TestCase):
    def test_get_delegates_for_safe(self):
        random_safe = Account.create().address
        self.assertEqual(
            SafeContractDelegate.objects.get_delegates_for_safe(random_safe), set()
        )

        safe_contract_delegate = SafeContractDelegateFactory()
        safe_contract_delegate_2 = SafeContractDelegateFactory(
            safe_contract=safe_contract_delegate.safe_contract
        )
        safe_contract_delegate_another_safe = SafeContractDelegateFactory()
        safe_address = safe_contract_delegate.safe_contract.address
        self.assertCountEqual(
            SafeContractDelegate.objects.get_delegates_for_safe(safe_address),
            [safe_contract_delegate.delegate, safe_contract_delegate_2.delegate],
        )

        another_safe_address = safe_contract_delegate_another_safe.safe_contract.address
        self.assertCountEqual(
            SafeContractDelegate.objects.get_delegates_for_safe(another_safe_address),
            [safe_contract_delegate_another_safe.delegate],
        )

    def test_get_delegates_for_safe_and_owners(self):
        self.assertEqual(
            SafeContractDelegate.objects.get_delegates_for_safe_and_owners(
                Account.create().address, []
            ),
            set(),
        )

        owner = Account.create().address
        self.assertEqual(
            SafeContractDelegate.objects.get_delegates_for_safe_and_owners(
                Account.create().address, [owner]
            ),
            set(),
        )

        safe_contract_delegate = SafeContractDelegateFactory(
            delegator=owner, safe_contract=None
        )
        self.assertEqual(
            SafeContractDelegate.objects.get_delegates_for_safe_and_owners(
                Account.create().address, [owner]
            ),
            {safe_contract_delegate.delegate},
        )

        owner_2 = Account.create().address
        safe_contract_delegate_2 = SafeContractDelegateFactory(delegator=owner_2)
        self.assertEqual(
            SafeContractDelegate.objects.get_delegates_for_safe_and_owners(
                safe_contract_delegate_2.safe_contract_id, [owner_2]
            ),
            {safe_contract_delegate_2.delegate},
        )

        self.assertEqual(
            SafeContractDelegate.objects.get_delegates_for_safe_and_owners(
                Account.create().address, [owner_2]
            ),
            set(),
        )

class TestMultisigConfirmations(TestCase):
    def test_remove_unused_confirmations(self):
        safe_address = Account.create().address
        owner_address = Account.create().address
        multisig_confirmation = MultisigConfirmationFactory(
            owner=owner_address,
            multisig_transaction__nonce=0,
            multisig_transaction__ethereum_tx=None,
            multisig_transaction__safe=safe_address,
        )
        self.assertEqual(
            MultisigConfirmation.objects.remove_unused_confirmations(
                safe_address, 0, owner_address
            ),
            1,
        )
        self.assertEqual(MultisigConfirmation.objects.count(), 0)

        # With an executed multisig transaction it shouldn't delete the confirmation
        multisig_confirmation = MultisigConfirmationFactory(
            owner=owner_address,
            multisig_transaction__nonce=0,
            multisig_transaction__safe=safe_address,
        )
        self.assertEqual(
            MultisigConfirmation.objects.remove_unused_confirmations(
                safe_address, 0, owner_address
            ),
            0,
        )
        self.assertEqual(MultisigConfirmation.objects.all().delete()[0], 1)

        # More testing
        multisig_confirmation = MultisigConfirmationFactory(
            owner=owner_address,
            multisig_transaction__nonce=0,
            multisig_transaction__safe=safe_address,
        )
        multisig_confirmation = MultisigConfirmationFactory(
            owner=owner_address,
            multisig_transaction__nonce=0,
            multisig_transaction__ethereum_tx=None,
            multisig_transaction__safe=safe_address,
        )
        multisig_confirmation = MultisigConfirmationFactory(
            owner=owner_address,
            multisig_transaction__nonce=1,
            multisig_transaction__ethereum_tx=None,
            multisig_transaction__safe=safe_address,
        )
        multisig_confirmation = MultisigConfirmationFactory(
            owner=owner_address,
            multisig_transaction__nonce=1,
            multisig_transaction__ethereum_tx=None,
            multisig_transaction__safe=safe_address,
        )
        multisig_confirmation = MultisigConfirmationFactory(
            owner=owner_address,
            multisig_transaction__nonce=1,
            multisig_transaction__ethereum_tx=None,
            multisig_transaction__safe=safe_address,
        )
        self.assertEqual(
            MultisigConfirmation.objects.remove_unused_confirmations(
                safe_address, 1, owner_address
            ),
            3,
        )
        self.assertEqual(MultisigConfirmation.objects.all().delete()[0], 2)

class TestEthereumBlock(TestCase):
    def test_get_or_create_from_block(self):
        mock_block = block_result[0]
        self.assertEqual(EthereumBlock.objects.count(), 0)
        db_block = EthereumBlock.objects.get_or_create_from_block(mock_block)
        db_block.set_confirmed()
        self.assertEqual(db_block.confirmed, True)
        self.assertEqual(EthereumBlock.objects.count(), 1)
        with mock.patch.object(
            EthereumBlockManager, "create_from_block"
        ) as create_from_block_mock:
            # Block already exists
            EthereumBlock.objects.get_or_create_from_block(mock_block)
            create_from_block_mock.assert_not_called()

        # Test block with different block-hash but same block number
        mock_block_2 = dict(mock_block)
        mock_block_2["hash"] = Web3.keccak(text="another-hash")
        self.assertNotEqual(mock_block["hash"], mock_block_2["hash"])
        with self.assertRaises(IntegrityError):
            EthereumBlock.objects.get_or_create_from_block(mock_block_2)
            self.assertEqual(EthereumBlock.objects.count(), 1)
            db_block.refresh_from_db()
            self.assertEqual(db_block.confirmed, False)

    def test_set_confirmed_not_confirmed(self):
        ethereum_block = EthereumBlockFactory(confirmed=False)
        ethereum_block.set_confirmed()
        ethereum_block.refresh_from_db()
        self.assertTrue(ethereum_block.confirmed)
        # Check idempotent
        ethereum_block.set_confirmed()
        ethereum_block.refresh_from_db()
        self.assertTrue(ethereum_block.confirmed)

        ethereum_block.set_not_confirmed()
        ethereum_block.refresh_from_db()
        self.assertFalse(ethereum_block.confirmed)

    def test_oldest_than(self):
        now = timezone.now()
        one_hour_ago = now - timedelta(hours=1)
        one_day_ago = now - timedelta(days=1)
        one_week_ago = now - timedelta(weeks=1)

        ethereum_block_0 = EthereumBlockFactory(timestamp=one_week_ago)
        ethereum_block_1 = EthereumBlockFactory(timestamp=one_day_ago)
        ethereum_block_2 = EthereumBlockFactory(timestamp=one_hour_ago)
        ethereum_block_3 = EthereumBlockFactory(timestamp=now)

        self.assertEqual(EthereumBlock.objects.oldest_than(0).first(), ethereum_block_3)
        self.assertEqual(EthereumBlock.objects.oldest_than(2).first(), ethereum_block_2)
        self.assertEqual(
            EthereumBlock.objects.oldest_than(60 * 60 + 1).first(), ethereum_block_1
        )
        self.assertEqual(
            EthereumBlock.objects.oldest_than(60 * 60 + 5).first(), ethereum_block_1
        )
        self.assertEqual(
            EthereumBlock.objects.oldest_than(60 * 60 + 5).first(), ethereum_block_1
        )
        self.assertEqual(
            EthereumBlock.objects.oldest_than(60 * 60 * 24 + 1).first(),
            ethereum_block_0,
        )
        self.assertIsNone(
            EthereumBlock.objects.oldest_than(60 * 60 * 24 * 7 + 1).first(), None
        )

class TestMultisigTransactions(TestCase):
    def test_last_nonce(self):
        safe_address = Account.create().address
        self.assertIsNone(MultisigTransaction.objects.last_nonce(safe_address))
        MultisigTransactionFactory(safe=safe_address, nonce=0)
        self.assertEqual(MultisigTransaction.objects.last_nonce(safe_address), 0)

        MultisigTransactionFactory(safe=safe_address, nonce=25)
        self.assertEqual(MultisigTransaction.objects.last_nonce(safe_address), 25)

        MultisigTransactionFactory(safe=safe_address, nonce=13)
        self.assertEqual(MultisigTransaction.objects.last_nonce(safe_address), 25)

    def test_safes_with_number_of_transactions_executed(self):
        self.assertEqual(
            MultisigTransaction.objects.safes_with_number_of_transactions_executed().count(),
            0,
        )
        safe_address_1 = Account.create().address
        safe_address_2 = Account.create().address
        safe_address_3 = Account.create().address
        MultisigTransactionFactory(safe=safe_address_1)
        MultisigTransactionFactory(safe=safe_address_1)
        safes_with_number_of_transactions = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed()
        )
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed()
        )
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0], {"safe": safe_address_1, "transactions": 2})
        MultisigTransactionFactory(safe=safe_address_1)
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed()
        )
        self.assertEqual(result[0], {"safe": safe_address_1, "transactions": 3})
        MultisigTransactionFactory(safe=safe_address_2)
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed()
        )
        self.assertEqual(
            list(result),
            [
                {"safe": safe_address_1, "transactions": 3},
                {"safe": safe_address_2, "transactions": 1},
            ],
        )
        [MultisigTransactionFactory(safe=safe_address_3) for _ in range(4)]
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed()
        )
        self.assertEqual(
            list(result),
            [
                {"safe": safe_address_3, "transactions": 4},
                {"safe": safe_address_1, "transactions": 3},
                {"safe": safe_address_2, "transactions": 1},
            ],
        )

    def test_safes_with_number_of_transactions_executed_and_master_copy(self):
        self.assertEqual(
            MultisigTransaction.objects.safes_with_number_of_transactions_executed_and_master_copy().count(),
            0,
        )
        safe_address_1 = Account.create().address
        safe_address_2 = Account.create().address
        safe_address_3 = Account.create().address
        MultisigTransactionFactory(safe=safe_address_1)
        MultisigTransactionFactory(safe=safe_address_1)
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed_and_master_copy()
        )
        self.assertEqual(len(result), 1)
        self.assertEqual(
            result[0], {"safe": safe_address_1, "transactions": 2, "master_copy": None}
        )
        MultisigTransactionFactory(safe=safe_address_2)
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed_and_master_copy()
        )
        self.assertEqual(
            list(result),
            [
                {"safe": safe_address_1, "transactions": 2, "master_copy": None},
                {"safe": safe_address_2, "transactions": 1, "master_copy": None},
            ],
        )

        safe_status_1 = SafeStatusFactory(address=safe_address_1)
        self.assertIsNotNone(safe_status_1.master_copy)
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed_and_master_copy()
        )
        self.assertEqual(
            list(result),
            [
                {
                    "safe": safe_address_1,
                    "transactions": 2,
                    "master_copy": safe_status_1.master_copy,
                },
                {"safe": safe_address_2, "transactions": 1, "master_copy": None},
            ],
        )

        safe_status_2 = SafeStatusFactory(address=safe_address_2)
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed_and_master_copy()
        )
        self.assertEqual(
            list(result),
            [
                {
                    "safe": safe_address_1,
                    "transactions": 2,
                    "master_copy": safe_status_1.master_copy,
                },
                {
                    "safe": safe_address_2,
                    "transactions": 1,
                    "master_copy": safe_status_2.master_copy,
                },
            ],
        )

        [MultisigTransactionFactory(safe=safe_address_3) for _ in range(4)]
        result = (
            MultisigTransaction.objects.safes_with_number_of_transactions_executed_and_master_copy()
        )
        self.assertEqual(
            list(result),
            [
                {"safe": safe_address_3, "transactions": 4, "master_copy": None},
                {
                    "safe": safe_address_1,
                    "transactions": 2,
                    "master_copy": safe_status_1.master_copy,
                },
                {
                    "safe": safe_address_2,
                    "transactions": 1,
                    "master_copy": safe_status_2.master_copy,
                },
            ],
        )

    def test_not_indexed_metadata_contract_addresses(self):
        # Transaction must be trusted
        MultisigTransactionFactory(data=b"12")
        self.assertFalse(
            MultisigTransaction.objects.not_indexed_metadata_contract_addresses()
        )

        MultisigTransactionFactory(trusted=True, data=None)
        self.assertFalse(
            MultisigTransaction.objects.not_indexed_metadata_contract_addresses()
        )
        multisig_transaction = MultisigTransactionFactory(trusted=True, data=b"12")
        MultisigTransactionFactory(
            trusted=True, data=b"12", to=multisig_transaction.to
        )  # Check distinct
        self.assertCountEqual(
            MultisigTransaction.objects.not_indexed_metadata_contract_addresses(),
            [multisig_transaction.to],
        )
        ContractFactory(address=multisig_transaction.to)
        self.assertFalse(
            MultisigTransaction.objects.not_indexed_metadata_contract_addresses()
        )

    def test_with_confirmations_required(self):
        # This should never be picked
        SafeStatusFactory(nonce=0, threshold=4)

        multisig_transaction = MultisigTransactionFactory()
        self.assertIsNone(
            MultisigTransaction.objects.with_confirmations_required()
            .first()
            .confirmations_required
        )

        # SafeStatus not matching the EthereumTx
        safe_status = SafeStatusFactory(nonce=1, threshold=8)
        self.assertIsNone(
            MultisigTransaction.objects.with_confirmations_required()
            .first()
            .confirmations_required
        )

        safe_status.internal_tx.ethereum_tx = multisig_transaction.ethereum_tx
        safe_status.internal_tx.save(update_fields=["ethereum_tx"])

        self.assertEqual(
            MultisigTransaction.objects.with_confirmations_required()
            .first()
            .confirmations_required,
            8,
        )

        # It will not be picked, as EthereumTx is not matching
        SafeStatusFactory(nonce=2, threshold=15)
        self.assertEqual(
            MultisigTransaction.objects.with_confirmations_required()
            .first()
            .confirmations_required,
            8,
        )

        # As EthereumTx is empty, the latest safe status will be used if available
        multisig_transaction.ethereum_tx = None
        multisig_transaction.save(update_fields=["ethereum_tx"])
        self.assertIsNone(
            MultisigTransaction.objects.with_confirmations_required()
            .first()
            .confirmations_required
        )

        # Not matching address should not return anything
        SafeLastStatusFactory(nonce=2, threshold=16)
        self.assertIsNone(
            MultisigTransaction.objects.with_confirmations_required()
            .first()
            .confirmations_required
        )

        SafeLastStatusFactory(address=multisig_transaction.safe, nonce=2, threshold=15)
        self.assertEqual(
            MultisigTransaction.objects.with_confirmations_required()
            .first()
            .confirmations_required,
            15,
        )

    def test_with_confirmations(self):
        multisig_transaction = MultisigTransactionFactory()
        self.assertEqual(MultisigTransaction.objects.with_confirmations().count(), 0)
        MultisigConfirmationFactory(multisig_transaction=multisig_transaction)
        self.assertEqual(MultisigTransaction.objects.with_confirmations().count(), 1)
        self.assertEqual(MultisigTransaction.objects.count(), 1)

    def test_without_confirmations(self):
        multisig_transaction = MultisigTransactionFactory()
        self.assertEqual(MultisigTransaction.objects.without_confirmations().count(), 1)
        MultisigConfirmationFactory(multisig_transaction=multisig_transaction)
        self.assertEqual(MultisigTransaction.objects.without_confirmations().count(), 0)
        self.assertEqual(MultisigTransaction.objects.count(), 1)

    def test_last_valid_transaction(self):
        safe_address = Account.create().address
        self.assertIsNone(
            MultisigTransaction.objects.last_valid_transaction(safe_address)
        )
        multisig_transaction = MultisigTransactionFactory(safe=safe_address, nonce=0)
        self.assertIsNone(
            MultisigTransaction.objects.last_valid_transaction(safe_address)
        )
        multisig_confirmation = MultisigConfirmationFactory(
            multisig_transaction=multisig_transaction,
            signature_type=SafeSignatureType.EOA.value,
        )
        self.assertIsNone(
            MultisigTransaction.objects.last_valid_transaction(safe_address)
        )
        SafeStatusFactory(address=safe_address, owners=[multisig_confirmation.owner])
        self.assertEqual(
            MultisigTransaction.objects.last_valid_transaction(safe_address),
            multisig_transaction,
        )

        multisig_transaction_2 = MultisigTransactionFactory(safe=safe_address, nonce=2)
        multisig_confirmation_2 = MultisigConfirmationFactory(
            multisig_transaction=multisig_transaction_2,
            signature_type=SafeSignatureType.EOA.value,
            owner=multisig_confirmation.owner,
        )
        self.assertEqual(
            MultisigTransaction.objects.last_valid_transaction(safe_address),
            multisig_transaction_2,
        )

class TestWebHook(TestCase):
    def test_matching_for_address(self):
        addresses = [Account.create().address for _ in range(3)]
        webhook_0 = WebHookFactory(address=addresses[0])
        webhook_1 = WebHookFactory(address=addresses[1])

        self.assertCountEqual(
            WebHook.objects.matching_for_address(addresses[0]), [webhook_0]
        )
        self.assertCountEqual(
            WebHook.objects.matching_for_address(addresses[1]), [webhook_1]
        )

        webhook_2 = WebHookFactory(address=None)
        self.assertCountEqual(
            WebHook.objects.matching_for_address(addresses[0]), [webhook_0, webhook_2]
        )
        self.assertCountEqual(
            WebHook.objects.matching_for_address(addresses[1]), [webhook_1, webhook_2]
        )
        self.assertCountEqual(
            WebHook.objects.matching_for_address(addresses[2]), [webhook_2]
        )

    def test_optional_auth(self):
        web_hook = WebHookFactory.create(authorization=None)

        web_hook.full_clean()

    def test_invalid_urls(self) -> None:
        param_list = [
            "foo://bar",
            "foo",
            "://",
        ]
        for invalid_url in param_list:
            with self.subTest(msg=f"{invalid_url} is not a valid url"):
                with self.assertRaises(ValidationError):
                    web_hook = WebHookFactory.create(url=invalid_url)
                    web_hook.full_clean()

            with self.subTest(msg=f"{invalid_url} is not a valid url"):
                with self.assertRaises(ValidationError):
                    web_hook = WebHookFactory.create(url=invalid_url)
                    web_hook.full_clean()

    def test_valid_urls(self) -> None:
        param_list = [
            "http://tx-service",
            "https://tx-service",
            "https://tx-service:8000",
            "https://safe-transaction.mainnet.gnosis.io",
            "http://mainnet-safe-transaction-web.safe.svc.cluster.local",
        ]
        for valid_url in param_list:
            with self.subTest(msg=f"Valid url {valid_url} should not throw"):
                web_hook = WebHookFactory.create(url=valid_url)
                web_hook.full_clean()

            with self.subTest(msg=f"Valid url {valid_url} should not throw"):
                web_hook = WebHookFactory.create(url=valid_url)
                web_hook.full_clean()

'''
'''--- safe_transaction_service/history/tests/test_proxy_factory_indexer.py ---
from django.test import TestCase

from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from ..indexers import ProxyFactoryIndexerProvider
from ..models import SafeContract
from .factories import ProxyFactoryFactory

class TestProxyFactoryIndexer(SafeTestCaseMixin, TestCase):
    def test_proxy_factory_indexer(self):
        proxy_factory_indexer = ProxyFactoryIndexerProvider()
        proxy_factory_indexer.confirmations = 0
        self.assertEqual(proxy_factory_indexer.start(), 0)

        ProxyFactoryFactory(address=self.proxy_factory.address)
        ethereum_tx_sent = self.proxy_factory.deploy_proxy_contract(
            self.ethereum_test_account, self.safe_contract_address
        )
        safe_contract_address = ethereum_tx_sent.contract_address
        self.w3.eth.wait_for_transaction_receipt(ethereum_tx_sent.tx_hash)
        self.assertEqual(proxy_factory_indexer.start(), 1)
        self.assertEqual(SafeContract.objects.count(), 1)
        self.assertTrue(SafeContract.objects.get(address=safe_contract_address))

'''
'''--- safe_transaction_service/history/tests/test_reorg_service.py ---
from unittest import mock
from unittest.mock import MagicMock, PropertyMock

from django.test import TestCase

from gnosis.eth import EthereumClient

from ..models import (
    EthereumBlock,
    EthereumTx,
    IndexingStatus,
    ProxyFactory,
    SafeMasterCopy,
)
from ..services import ReorgServiceProvider
from .factories import (
    EthereumBlockFactory,
    EthereumTxFactory,
    ProxyFactoryFactory,
    SafeMasterCopyFactory,
)
from .mocks.mocks_internal_tx_indexer import block_child, block_parent

class TestReorgService(TestCase):
    @mock.patch.object(EthereumClient, "get_block")
    @mock.patch.object(
        EthereumClient, "current_block_number", new_callable=PropertyMock
    )
    def test_check_reorgs(
        self, current_block_number_mock: PropertyMock, get_block_mock: MagicMock
    ):
        reorg_service = ReorgServiceProvider()

        block = block_child
        block_number = block["number"]

        def get_block_fn(number: int, full_transactions=False):
            if number == block_number:
                return block_child

            if number == block_number + 1:
                return block_parent

        get_block_mock.side_effect = get_block_fn
        current_block_number = block_number + 100
        current_block_number_mock.return_value = current_block_number

        ethereum_block: EthereumBlock = EthereumBlockFactory(
            number=block_number, confirmed=False
        )
        self.assertEqual(reorg_service.check_reorgs(), block_number)

        ethereum_block.block_hash = block["hash"]
        ethereum_block.save(update_fields=["block_hash"])
        self.assertIsNone(reorg_service.check_reorgs())
        ethereum_block.refresh_from_db()
        self.assertTrue(ethereum_block.confirmed)

    def test_reset_all_to_block(self):
        reorg_service = ReorgServiceProvider()

        elements = 3
        for i in range(elements):
            ProxyFactoryFactory(tx_block_number=100 * i)
            SafeMasterCopyFactory(tx_block_number=300 * i)

        block_number = 5
        reorg_service.reset_all_to_block(block_number)

        # All elements but 1 will be reset (with `tx_block_number=0` and `erc20_block_number=0`)
        self.assertEqual(
            IndexingStatus.objects.get_erc20_721_indexing_status().block_number,
            block_number,
        )
        self.assertEqual(
            ProxyFactory.objects.filter(tx_block_number=block_number).count(),
            elements - 1,
        )
        self.assertEqual(
            SafeMasterCopy.objects.filter(tx_block_number=block_number).count(),
            elements - 1,
        )

    def test_recover_from_reorg(self):
        reorg_service = ReorgServiceProvider()

        reorg_block = 2000  # Test a reorg in block 2000
        ethereum_blocks = [
            EthereumBlockFactory(number=reorg_block + i)
            for i in range(-1000, 1001, 500)
        ]
        ethereum_txs = [
            EthereumTxFactory(block=ethereum_block)
            for ethereum_block in ethereum_blocks
        ]
        safe_ethereum_tx = ethereum_txs[0]  # This tx will not be touched by the reorg

        self.assertEqual(EthereumTx.objects.count(), len(ethereum_blocks))

        proxy_factory = ProxyFactoryFactory(tx_block_number=reorg_block)
        indexing_status = IndexingStatus.objects.get_erc20_721_indexing_status()
        indexing_status.block_number = reorg_block - 500
        indexing_status.save(update_fields=["block_number"])
        safe_master_copy = SafeMasterCopyFactory(tx_block_number=reorg_block + 500)

        reorg_service.recover_from_reorg(reorg_block)

        # Check that blocks and ethereum txs were deleted
        self.assertEqual(EthereumBlock.objects.count(), 2)
        self.assertEqual(
            EthereumBlock.objects.filter(number__gte=reorg_block).count(), 0
        )
        self.assertEqual(EthereumTx.objects.count(), 2)

        # Check that indexer rewound needed blocks
        proxy_factory.refresh_from_db()
        self.assertEqual(
            proxy_factory.tx_block_number,
            reorg_block - reorg_service.eth_reorg_rewind_blocks,
        )
        indexing_status.refresh_from_db()
        self.assertEqual(indexing_status.block_number, reorg_block - 500)
        safe_master_copy.refresh_from_db()
        self.assertEqual(
            safe_master_copy.tx_block_number,
            reorg_block - reorg_service.eth_reorg_rewind_blocks,
        )

'''
'''--- safe_transaction_service/history/tests/test_safe_events_indexer.py ---
from django.test import TestCase

from eth_account import Account
from hexbytes import HexBytes
from web3.datastructures import AttributeDict
from web3.types import LogReceipt

from gnosis.eth.constants import NULL_ADDRESS, SENTINEL_ADDRESS
from gnosis.eth.contracts import get_safe_V1_3_0_contract
from gnosis.safe import Safe
from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from ..indexers import SafeEventsIndexer, SafeEventsIndexerProvider
from ..indexers.tx_processor import SafeTxProcessor
from ..models import (
    EthereumTxCallType,
    InternalTx,
    InternalTxDecoded,
    InternalTxType,
    MultisigConfirmation,
    MultisigTransaction,
    SafeLastStatus,
    SafeStatus,
)
from .factories import SafeMasterCopyFactory

class TestSafeEventsIndexer(SafeTestCaseMixin, TestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.safe_events_indexer = SafeEventsIndexer(
            cls.ethereum_client, confirmations=0, blocks_to_reindex_again=0
        )
        cls.safe_tx_processor = SafeTxProcessor(cls.ethereum_client)

    def test_safe_events_indexer_provider(self):
        safe_events_indexer = SafeEventsIndexerProvider()
        self.assertEqual(safe_events_indexer.confirmations, 0)
        self.assertGreater(safe_events_indexer.blocks_to_reindex_again, 0)
        self.assertIsNotNone(SafeEventsIndexerProvider.instance)
        SafeEventsIndexerProvider.del_singleton()
        self.assertIsNone(getattr(SafeEventsIndexerProvider, "instance", None))

    def test_invalid_event(self):
        """
        AddedOwner event broke indexer on BSC. Same signature, but different number of indexed attributes
        """

        valid_event: LogReceipt = AttributeDict(
            {
                "address": "0x384f55D8BD4046461433A56bb87fe4aA615C0cc8",
                "blockHash": HexBytes(
                    "0x551a6e5ca972c453873898be696980d7ff65d27a6f80ddffab17591144c99e01"
                ),
                "blockNumber": 9205844,
                "data": "0x000000000000000000000000a1350318b2907ee0f6c8918eddc778a0b633e774",
                "logIndex": 0,
                "removed": False,
                "topics": [
                    HexBytes(
                        "0x9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea26"
                    )
                ],
                "transactionHash": HexBytes(
                    "0x7e4b2bb0ac5129552908e9c8433ea1746f76616188e8c3597a6bdce88d0b474c"
                ),
                "transactionIndex": 0,
                "transactionLogIndex": "0x0",
                "type": "mined",
            }
        )

        dangling_event: LogReceipt = AttributeDict(
            {
                "address": "0x1E44C806f1AfD4f420C10c8088f4e0388F066E7A",
                "topics": [
                    HexBytes(
                        "0x9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea26"
                    ),
                    HexBytes(
                        "0x00000000000000000000000020212521370dd2dde0b0e3ac25b65eb3e859d303"
                    ),
                ],
                "data": "0x",
                "blockNumber": 10129293,
                "transactionHash": HexBytes(
                    "0xc19ef099702fb9f7d7962925428683eff534e009210ef2cf23135f43962c192a"
                ),
                "transactionIndex": 89,
                "blockHash": HexBytes(
                    "0x6b41eac9177a1606e1a853adf3f3da018fcf476f7d217acb69b7d130bdfaf2c9"
                ),
                "logIndex": 290,
                "removed": False,
            }
        )

        # Dangling event topic is "supported"
        self.assertIn(
            dangling_event["topics"][0].hex(), self.safe_events_indexer.events_to_listen
        )

        # Dangling event cannot be decoded
        self.assertEqual(self.safe_events_indexer.decode_elements([dangling_event]), [])

        # Valid event is supported
        self.assertIn(
            valid_event["topics"][0].hex(), self.safe_events_indexer.events_to_listen
        )

        # Dangling event cannot be decoded
        expected_event = AttributeDict(
            {
                "args": AttributeDict(
                    {"owner": "0xa1350318b2907ee0f6c8918edDC778A0b633e774"}
                ),
                "event": "AddedOwner",
                "logIndex": 0,
                "transactionIndex": 0,
                "transactionHash": HexBytes(
                    "0x7e4b2bb0ac5129552908e9c8433ea1746f76616188e8c3597a6bdce88d0b474c"
                ),
                "address": "0x384f55D8BD4046461433A56bb87fe4aA615C0cc8",
                "blockHash": HexBytes(
                    "0x551a6e5ca972c453873898be696980d7ff65d27a6f80ddffab17591144c99e01"
                ),
                "blockNumber": 9205844,
            }
        )
        self.assertEqual(
            self.safe_events_indexer.decode_elements([valid_event]), [expected_event]
        )

    def test_safe_events_indexer(self):
        owner_account_1 = self.ethereum_test_account
        owners = [owner_account_1.address]
        threshold = 1
        to = NULL_ADDRESS
        data = b""
        fallback_handler = NULL_ADDRESS
        payment_token = NULL_ADDRESS
        payment = 0
        payment_receiver = NULL_ADDRESS
        initializer = HexBytes(
            self.safe_contract.functions.setup(
                owners,
                threshold,
                to,
                data,
                fallback_handler,
                payment_token,
                payment,
                payment_receiver,
            ).build_transaction({"gas": 1, "gasPrice": 1})["data"]
        )
        initial_block_number = self.ethereum_client.current_block_number
        safe_l2_master_copy = SafeMasterCopyFactory(
            address=self.safe_contract.address,
            initial_block_number=initial_block_number,
            tx_block_number=initial_block_number,
            version="1.3.0",
            l2=True,
        )
        ethereum_tx_sent = self.proxy_factory.deploy_proxy_contract(
            self.ethereum_test_account,
            self.safe_contract.address,
            initializer=initializer,
        )
        safe_address = ethereum_tx_sent.contract_address
        safe = Safe(safe_address, self.ethereum_client)
        safe_contract = get_safe_V1_3_0_contract(self.w3, safe_address)
        self.assertEqual(safe_contract.functions.VERSION().call(), "1.3.0")

        self.assertEqual(InternalTx.objects.count(), 0)
        self.assertEqual(InternalTxDecoded.objects.count(), 0)
        self.assertEqual(self.safe_events_indexer.start(), 2)
        self.assertEqual(InternalTxDecoded.objects.count(), 1)
        self.assertEqual(InternalTx.objects.count(), 2)  # Proxy factory and setup
        create_internal_tx = InternalTx.objects.filter(
            contract_address=safe_address
        ).get()
        setup_internal_tx = InternalTx.objects.filter(contract_address=None).get()

        self.assertEqual(create_internal_tx.trace_address, "1")
        self.assertEqual(create_internal_tx.tx_type, InternalTxType.CREATE.value)
        self.assertIsNone(create_internal_tx.call_type)
        self.assertTrue(create_internal_tx.is_relevant)

        self.assertEqual(setup_internal_tx.trace_address, "1,0")

        txs_decoded_queryset = InternalTxDecoded.objects.pending_for_safes()
        self.assertEqual(SafeStatus.objects.count(), 0)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        self.assertEqual(SafeStatus.objects.count(), 1)
        safe_status = SafeStatus.objects.get()
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.master_copy, self.safe_contract.address)
        self.assertEqual(safe_status.owners, owners)
        self.assertEqual(safe_status.threshold, threshold)
        self.assertEqual(safe_status.nonce, 0)
        self.assertEqual(safe_status.enabled_modules, [])
        self.assertIsNone(safe_status.guard)
        self.assertEqual(MultisigTransaction.objects.count(), 0)
        self.assertEqual(MultisigConfirmation.objects.count(), 0)

        # Add an owner but don't update the threshold (nonce: 0) --------------------------------------------------
        owner_account_2 = Account.create()
        data = HexBytes(
            self.safe_contract.functions.addOwnerWithThreshold(
                owner_account_2.address, 1
            ).build_transaction({"gas": 1, "gasPrice": 1})["data"]
        )

        multisig_tx = safe.build_multisig_tx(safe_address, 0, data)
        multisig_tx.sign(owner_account_1.key)
        multisig_tx.execute(self.ethereum_test_account.key)
        # Process events: SafeMultiSigTransaction, AddedOwner, ExecutionSuccess
        self.assertEqual(self.safe_events_indexer.start(), 3)
        self.assertEqual(InternalTx.objects.count(), 5)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Add one SafeStatus increasing the nonce and another one adding the owner
        self.assertEqual(SafeStatus.objects.count(), 3)
        safe_status = SafeStatus.objects.last_for_address(
            safe_address
        )  # Processed execTransaction and addOwner
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(
            safe_status.owners, [owner_account_2.address, owner_account_1.address]
        )
        self.assertEqual(safe_status.nonce, 1)

        safe_status = SafeStatus.objects.sorted_by_mined()[
            1
        ]  # Just processed execTransaction
        self.assertEqual(safe_status.owners, [owner_account_1.address])
        self.assertEqual(safe_status.nonce, 1)

        self.assertEqual(MultisigTransaction.objects.count(), 1)
        self.assertEqual(
            MultisigTransaction.objects.get().safe_tx_hash,
            multisig_tx.safe_tx_hash.hex(),
        )
        self.assertEqual(MultisigConfirmation.objects.count(), 1)

        # Change threshold (nonce: 1) ------------------------------------------------------------------------------
        data = HexBytes(
            self.safe_contract.functions.changeThreshold(2).build_transaction(
                {"gas": 1, "gasPrice": 1}
            )["data"]
        )

        multisig_tx = safe.build_multisig_tx(safe_address, 0, data)
        multisig_tx.sign(owner_account_1.key)
        multisig_tx.execute(self.ethereum_test_account.key)
        # Process events: SafeMultiSigTransaction, ChangedThreshold, ExecutionSuccess
        self.assertEqual(self.safe_events_indexer.start(), 3)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Add one SafeStatus increasing the nonce and another one changing the threshold
        self.assertEqual(SafeStatus.objects.count(), 5)
        safe_status = SafeStatus.objects.last_for_address(
            safe_address
        )  # Processed execTransaction and changeThreshold
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.nonce, 2)
        self.assertEqual(safe_status.threshold, 2)

        safe_status = SafeStatus.objects.sorted_by_mined()[
            1
        ]  # Just processed execTransaction
        self.assertEqual(safe_status.nonce, 2)
        self.assertEqual(safe_status.threshold, 1)

        self.assertEqual(MultisigTransaction.objects.count(), 2)
        self.assertEqual(
            MultisigTransaction.objects.order_by("-nonce")[0].safe_tx_hash,
            multisig_tx.safe_tx_hash.hex(),
        )
        self.assertEqual(MultisigConfirmation.objects.count(), 2)

        # Remove an owner and change threshold back to 1 (nonce: 2) --------------------------------------------------
        data = HexBytes(
            self.safe_contract.functions.removeOwner(
                SENTINEL_ADDRESS, owner_account_2.address, 1
            ).build_transaction({"gas": 1, "gasPrice": 1})["data"]
        )

        multisig_tx = safe.build_multisig_tx(safe_address, 0, data)
        multisig_tx.sign(owner_account_1.key)
        multisig_tx.sign(owner_account_2.key)
        multisig_tx.execute(self.ethereum_test_account.key)
        # Process events: SafeMultiSigTransaction, RemovedOwner, ChangedThreshold, ExecutionSuccess
        self.assertEqual(self.safe_events_indexer.start(), 4)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Add one SafeStatus increasing the nonce and another one removing the owner
        self.assertEqual(SafeStatus.objects.count(), 8)
        safe_status = SafeStatus.objects.last_for_address(
            safe_address
        )  # Processed execTransaction, removeOwner and changeThreshold
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.nonce, 3)
        self.assertEqual(safe_status.threshold, 1)
        self.assertEqual(safe_status.owners, [owner_account_1.address])

        safe_status = SafeStatus.objects.sorted_by_mined()[
            1
        ]  # Processed execTransaction and removeOwner
        self.assertEqual(safe_status.nonce, 3)
        self.assertEqual(safe_status.threshold, 2)
        self.assertEqual(safe_status.owners, [owner_account_1.address])

        safe_status = SafeStatus.objects.sorted_by_mined()[
            2
        ]  # Just processed execTransaction
        self.assertEqual(safe_status.nonce, 3)
        self.assertEqual(safe_status.threshold, 2)
        self.assertCountEqual(
            safe_status.owners, [owner_account_1.address, owner_account_2.address]
        )

        self.assertEqual(MultisigTransaction.objects.count(), 3)
        self.assertEqual(
            MultisigTransaction.objects.order_by("-nonce")[0].safe_tx_hash,
            multisig_tx.safe_tx_hash.hex(),
        )
        self.assertEqual(MultisigConfirmation.objects.count(), 4)

        # Enable module (nonce: 3) ---------------------------------------------------------------------
        module_address = Account.create().address
        data = HexBytes(
            self.safe_contract.functions.enableModule(module_address).build_transaction(
                {"gas": 1, "gasPrice": 1}
            )["data"]
        )

        multisig_tx = safe.build_multisig_tx(safe_address, 0, data)
        multisig_tx.sign(owner_account_1.key)
        multisig_tx.execute(self.ethereum_test_account.key)
        # Process events: SafeMultiSigTransaction, EnabledModule, ExecutionSuccess
        self.assertEqual(self.safe_events_indexer.start(), 3)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Add one SafeStatus increasing the nonce and another one enabling the module
        self.assertEqual(SafeStatus.objects.count(), 10)
        safe_status = SafeStatus.objects.last_for_address(
            safe_address
        )  # Processed execTransaction and enableModule
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.enabled_modules, [module_address])
        self.assertEqual(safe_status.nonce, 4)

        safe_status = SafeStatus.objects.sorted_by_mined()[
            1
        ]  # Just processed execTransaction
        self.assertEqual(safe_status.enabled_modules, [])
        self.assertEqual(safe_status.nonce, 4)

        self.assertEqual(MultisigTransaction.objects.count(), 4)
        self.assertEqual(
            MultisigTransaction.objects.order_by("-nonce")[0].safe_tx_hash,
            multisig_tx.safe_tx_hash.hex(),
        )
        self.assertEqual(MultisigConfirmation.objects.count(), 5)

        # Check SafeReceived (ether received) on Safe -----------------------------------------------------------------
        value = 1256
        self.ethereum_client.get_transaction_receipt(
            self.send_ether(safe_address, value)
        )
        # Process events: SafeReceived
        self.assertEqual(self.safe_events_indexer.start(), 1)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Check there's an ether transaction
        internal_tx_queryset = InternalTx.objects.filter(
            value=value,
            tx_type=InternalTxType.CALL.value,
            call_type=EthereumTxCallType.CALL.value,
        )
        self.assertTrue(internal_tx_queryset.exists())
        self.assertTrue(internal_tx_queryset.get().is_ether_transfer)

        # Set fallback handler (nonce: 4) --------------------------------------------------------------------------
        new_fallback_handler = Account.create().address
        data = HexBytes(
            self.safe_contract.functions.setFallbackHandler(
                new_fallback_handler
            ).build_transaction({"gas": 1, "gasPrice": 1})["data"]
        )

        multisig_tx = safe.build_multisig_tx(safe_address, 0, data)
        multisig_tx.sign(owner_account_1.key)
        multisig_tx.execute(self.ethereum_test_account.key)
        # Process events: SafeMultiSigTransaction, ChangedFallbackHandler, ExecutionSuccess
        self.assertEqual(self.safe_events_indexer.start(), 3)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Add one SafeStatus increasing the nonce and another one changing the fallback handler
        self.assertEqual(SafeStatus.objects.count(), 12)
        safe_status = SafeStatus.objects.last_for_address(
            safe_address
        )  # Processed execTransaction and setFallbackHandler
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.fallback_handler, new_fallback_handler)
        self.assertEqual(safe_status.enabled_modules, [module_address])
        self.assertEqual(safe_status.nonce, 5)

        safe_status = SafeStatus.objects.sorted_by_mined()[
            1
        ]  # Just processed execTransaction
        self.assertEqual(safe_status.fallback_handler, fallback_handler)
        self.assertEqual(safe_status.enabled_modules, [module_address])
        self.assertEqual(safe_status.nonce, 5)

        self.assertEqual(MultisigTransaction.objects.count(), 5)
        self.assertEqual(
            MultisigTransaction.objects.order_by("-nonce")[0].safe_tx_hash,
            multisig_tx.safe_tx_hash.hex(),
        )
        self.assertEqual(MultisigConfirmation.objects.count(), 6)

        # Disable Module (nonce: 5) ----------------------------------------------------------------------------------
        data = HexBytes(
            self.safe_contract.functions.disableModule(
                SENTINEL_ADDRESS, module_address
            ).build_transaction({"gas": 1, "gasPrice": 1})["data"]
        )

        multisig_tx = safe.build_multisig_tx(safe_address, 0, data)
        multisig_tx.sign(owner_account_1.key)
        multisig_tx.execute(self.ethereum_test_account.key)
        # Process events: SafeMultiSigTransaction, DisabledModule, ExecutionSuccess
        self.assertEqual(self.safe_events_indexer.start(), 3)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Add one SafeStatus increasing the nonce and another one disabling the module
        self.assertEqual(SafeStatus.objects.count(), 14)
        safe_status = SafeStatus.objects.last_for_address(
            safe_address
        )  # Processed execTransaction and disableModule
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.nonce, 6)
        self.assertEqual(safe_status.enabled_modules, [])

        safe_status = SafeStatus.objects.sorted_by_mined()[
            1
        ]  # Just processed execTransaction
        self.assertEqual(safe_status.nonce, 6)
        self.assertEqual(safe_status.enabled_modules, [module_address])

        self.assertEqual(MultisigTransaction.objects.count(), 6)
        self.assertEqual(
            MultisigTransaction.objects.order_by("-nonce")[0].safe_tx_hash,
            multisig_tx.safe_tx_hash.hex(),
        )
        self.assertEqual(MultisigConfirmation.objects.count(), 7)

        # ApproveHash (no nonce) ------------------------------------------------------------------------------------
        random_hash = self.w3.keccak(text="Get schwifty")
        tx = safe.contract.functions.approveHash(random_hash).build_transaction(
            {
                "from": owner_account_1.address,
                "nonce": self.ethereum_client.get_nonce_for_account(
                    owner_account_1.address
                ),
            }
        )
        tx = owner_account_1.sign_transaction(tx)
        self.w3.eth.send_raw_transaction(tx["rawTransaction"])
        # Process events: ApproveHash
        self.assertEqual(self.safe_events_indexer.start(), 1)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # No SafeStatus was added
        self.assertEqual(SafeStatus.objects.count(), 14)
        # Check a MultisigConfirmation was created
        self.assertTrue(
            MultisigConfirmation.objects.filter(
                multisig_transaction_hash=random_hash.hex()
            ).exists()
        )
        self.assertEqual(
            MultisigTransaction.objects.count(), 6
        )  # No MultisigTransaction was created
        self.assertEqual(
            MultisigConfirmation.objects.count(), 8
        )  # A MultisigConfirmation was created

        # Send ether (nonce: 6) ----------------------------------------------------------------------------------
        data = b""
        value = 122
        to = Account.create().address
        multisig_tx = safe.build_multisig_tx(to, value, data)
        multisig_tx.sign(owner_account_1.key)
        multisig_tx.execute(self.ethereum_test_account.key)
        # Process events: SafeMultiSigTransaction, ExecutionSuccess
        self.assertEqual(self.safe_events_indexer.start(), 2)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Add one SafeStatus increasing the nonce
        self.assertEqual(SafeStatus.objects.count(), 15)
        safe_status = SafeStatus.objects.last_for_address(
            safe_address
        )  # Processed execTransaction
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.nonce, 7)
        self.assertTrue(
            InternalTx.objects.filter(value=value, to=to).get().is_ether_transfer
        )

        self.assertEqual(MultisigTransaction.objects.count(), 7)
        self.assertEqual(
            MultisigTransaction.objects.order_by("-nonce")[0].safe_tx_hash,
            multisig_tx.safe_tx_hash.hex(),
        )
        self.assertEqual(MultisigConfirmation.objects.count(), 9)

        # Set guard (nonce: 7) INVALIDATES SAFE, as no more transactions can be done ---------------------------------
        guard_address = Account.create().address
        data = HexBytes(
            self.safe_contract.functions.setGuard(guard_address).build_transaction(
                {"gas": 1, "gasPrice": 1}
            )["data"]
        )

        multisig_tx = safe.build_multisig_tx(safe_address, 0, data)
        multisig_tx.sign(owner_account_1.key)
        multisig_tx.execute(self.ethereum_test_account.key)
        # Process events: SafeMultiSigTransaction, ChangedGuard, ExecutionSuccess
        self.assertEqual(self.safe_events_indexer.start(), 3)
        self.safe_tx_processor.process_decoded_transactions(txs_decoded_queryset.all())
        # Add one SafeStatus increasing the nonce and another one changing the guard
        self.assertEqual(SafeStatus.objects.count(), 17)
        safe_status = SafeStatus.objects.last_for_address(
            safe_address
        )  # Processed execTransaction and setGuard
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.nonce, 8)
        self.assertEqual(safe_status.guard, guard_address)

        safe_status = SafeStatus.objects.sorted_by_mined()[
            1
        ]  # Just processed execTransaction
        self.assertEqual(safe_status.nonce, 8)
        self.assertIsNone(safe_status.guard)

        # Check master copy did not change during the execution
        self.assertEqual(
            SafeStatus.objects.last_for_address(safe_address).master_copy,
            self.safe_contract.address,
        )

        self.assertEqual(
            MultisigTransaction.objects.order_by("-nonce")[0].safe_tx_hash,
            multisig_tx.safe_tx_hash.hex(),
        )
        expected_multisig_transactions = 8
        expected_multisig_confirmations = 10
        expected_safe_statuses = 17
        expected_internal_txs = 29
        expected_internal_txs_decoded = 18
        self.assertEqual(
            MultisigTransaction.objects.count(), expected_multisig_transactions
        )
        self.assertEqual(
            MultisigConfirmation.objects.count(), expected_multisig_confirmations
        )
        self.assertEqual(SafeStatus.objects.count(), expected_safe_statuses)
        self.assertEqual(InternalTx.objects.count(), expected_internal_txs)
        self.assertEqual(
            InternalTxDecoded.objects.count(), expected_internal_txs_decoded
        )

        # Event processing should be idempotent, so no changes must be done if everything is processed again
        self.assertTrue(self.safe_events_indexer._is_setup_indexed(safe_address))
        safe_l2_master_copy.tx_block_number = initial_block_number
        safe_l2_master_copy.save(update_fields=["tx_block_number"])
        self.assertEqual(
            self.safe_events_indexer.start(), 0
        )  # No new events are processed when reindexing
        InternalTxDecoded.objects.update(processed=False)
        SafeStatus.objects.all().delete()
        self.assertEqual(
            len(
                self.safe_tx_processor.process_decoded_transactions(
                    txs_decoded_queryset.all()
                )
            ),
            expected_internal_txs_decoded,
        )
        self.assertEqual(
            MultisigTransaction.objects.count(), expected_multisig_transactions
        )
        self.assertEqual(
            MultisigConfirmation.objects.count(), expected_multisig_confirmations
        )
        self.assertEqual(SafeStatus.objects.count(), expected_safe_statuses)
        self.assertEqual(InternalTx.objects.count(), expected_internal_txs)
        self.assertEqual(
            InternalTxDecoded.objects.count(), expected_internal_txs_decoded
        )

'''
'''--- safe_transaction_service/history/tests/test_safe_service.py ---
from unittest import mock
from unittest.mock import MagicMock

from django.test import TestCase

from eth_account import Account

from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.ethereum_client import ParityManager
from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from ..models import SafeMasterCopy
from ..services.safe_service import (
    CannotGetSafeInfoFromBlockchain,
    CannotGetSafeInfoFromDB,
    SafeCreationInfo,
    SafeInfo,
    SafeServiceProvider,
)
from .factories import InternalTxFactory, SafeLastStatusFactory, SafeMasterCopyFactory
from .mocks.traces import create_trace, creation_internal_txs

class TestSafeService(SafeTestCaseMixin, TestCase):
    def setUp(self) -> None:
        self.safe_service = SafeServiceProvider()

    def test_get_safe_creation_info_with_tracing(self):
        """
        Traces are not stored on DB, so they must be recovered from the node
        """
        random_address = Account.create().address
        self.assertIsNone(self.safe_service.get_safe_creation_info(random_address))

        InternalTxFactory(contract_address=random_address, ethereum_tx__status=0)
        self.assertIsNone(self.safe_service.get_safe_creation_info(random_address))

        with mock.patch.object(
            ParityManager,
            "trace_transaction",
            autospec=True,
            return_value=[create_trace],
        ):
            InternalTxFactory(
                contract_address=random_address,
                ethereum_tx__status=1,
                trace_address="0",
            )
            safe_creation_info = self.safe_service.get_safe_creation_info(
                random_address
            )
            self.assertIsInstance(safe_creation_info, SafeCreationInfo)

    def test_get_safe_creation_info_without_tracing(self):
        """
        Tracing is not used, so traces must be fetched from DB if possible. L2 indexer "emulates" creation traces
        :return:
        """
        random_address = Account.create().address
        self.assertIsNone(self.safe_service.get_safe_creation_info(random_address))

        creation_trace = InternalTxFactory(
            contract_address=random_address, ethereum_tx__status=1, trace_address="0"
        )
        safe_creation = self.safe_service.get_safe_creation_info(random_address)
        self.assertEqual(safe_creation.creator, creation_trace.ethereum_tx._from)
        self.assertEqual(safe_creation.factory_address, creation_trace._from)
        self.assertIsNone(safe_creation.master_copy)
        self.assertIsNone(safe_creation.setup_data)

        setup_trace = InternalTxFactory(
            ethereum_tx=creation_trace.ethereum_tx,
            ethereum_tx__status=1,
            trace_address="0,0",
            data=b"1234",
        )
        safe_creation = self.safe_service.get_safe_creation_info(random_address)
        self.assertEqual(safe_creation.creator, creation_trace.ethereum_tx._from)
        self.assertEqual(safe_creation.factory_address, creation_trace._from)
        self.assertEqual(safe_creation.master_copy, setup_trace.to)
        self.assertEqual(bytes(safe_creation.setup_data), b"1234")

    @mock.patch.object(
        ParityManager, "trace_transaction", return_value=creation_internal_txs
    )
    def test_get_safe_creation_info_with_next_trace(
        self, trace_transaction_mock: MagicMock
    ):
        random_address = Account.create().address
        InternalTxFactory(
            contract_address=random_address, ethereum_tx__status=1, trace_address=""
        )
        safe_creation_info = self.safe_service.get_safe_creation_info(random_address)
        self.assertIsInstance(safe_creation_info, SafeCreationInfo)
        self.assertEqual(
            safe_creation_info.master_copy, "0x8942595A2dC5181Df0465AF0D7be08c8f23C93af"
        )
        self.assertTrue(safe_creation_info.setup_data)
        trace_transaction_mock.return_value = []
        safe_creation_info = self.safe_service.get_safe_creation_info(random_address)
        self.assertIsNone(safe_creation_info.master_copy)
        self.assertIsNone(safe_creation_info.setup_data)

    def test_get_safe_info_from_blockchain(self):
        SafeMasterCopy.objects.get_version_for_address.cache_clear()
        safe_address = Account.create().address
        with self.assertRaises(CannotGetSafeInfoFromBlockchain):
            self.safe_service.get_safe_info_from_blockchain(safe_address)

        safe = self.deploy_test_safe()
        safe_info = self.safe_service.get_safe_info_from_blockchain(safe.address)
        self.assertIsInstance(safe_info, SafeInfo)
        self.assertEqual(safe_info.address, safe.address)
        self.assertEqual(safe_info.owners, safe.retrieve_owners())
        self.assertEqual(safe_info.threshold, safe.retrieve_threshold())
        self.assertEqual(
            safe_info.fallback_handler, self.compatibility_fallback_handler.address
        )
        self.assertEqual(safe_info.guard, NULL_ADDRESS)
        self.assertEqual(safe_info.version, None)  # No SafeMasterCopy

        version = "4.8.15162342"
        SafeMasterCopyFactory(address=safe_info.master_copy, version=version)

        safe_info = self.safe_service.get_safe_info_from_blockchain(safe.address)
        self.assertEqual(safe_info.version, version)
        SafeMasterCopy.objects.get_version_for_address.cache_clear()

    def test_get_safe_info_from_db(self):
        safe_address = Account.create().address
        with self.assertRaises(CannotGetSafeInfoFromDB):
            self.safe_service.get_safe_info_from_db(safe_address)

        safe_last_status = SafeLastStatusFactory(address=safe_address, guard=None)
        self.assertIsNone(safe_last_status.guard)

        safe_info = self.safe_service.get_safe_info_from_db(safe_address)
        self.assertIsInstance(safe_info, SafeInfo)
        self.assertEqual(safe_info.guard, NULL_ADDRESS)
        self.assertEqual(safe_info.version, None)

'''
'''--- safe_transaction_service/history/tests/test_signals.py ---
from datetime import timedelta
from unittest import mock

from django.db.models.signals import post_save
from django.test import TestCase

import factory

from gnosis.eth import EthereumNetwork

from safe_transaction_service.notifications.tasks import send_notification_task

from ..models import (
    ERC20Transfer,
    InternalTx,
    MultisigConfirmation,
    MultisigTransaction,
    WebHookType,
)
from ..signals import build_webhook_payload, is_relevant_notification, process_webhook
from ..tasks import send_webhook_task
from .factories import (
    ERC20TransferFactory,
    InternalTxFactory,
    MultisigConfirmationFactory,
    MultisigTransactionFactory,
)

class TestSignals(TestCase):
    @factory.django.mute_signals(post_save)
    def test_build_webhook_payload(self):
        self.assertEqual(
            [
                payload["type"]
                for payload in build_webhook_payload(
                    ERC20Transfer, ERC20TransferFactory()
                )
            ],
            [WebHookType.INCOMING_TOKEN.name, WebHookType.OUTGOING_TOKEN.name],
        )
        self.assertEqual(
            [
                payload["type"]
                for payload in build_webhook_payload(InternalTx, InternalTxFactory())
            ],
            [WebHookType.INCOMING_ETHER.name, WebHookType.OUTGOING_ETHER.name],
        )
        self.assertEqual(
            [
                payload["chainId"]
                for payload in build_webhook_payload(
                    ERC20Transfer, ERC20TransferFactory()
                )
            ],
            [str(EthereumNetwork.GANACHE.value), str(EthereumNetwork.GANACHE.value)],
        )

        payload = build_webhook_payload(
            MultisigConfirmation, MultisigConfirmationFactory()
        )[0]
        self.assertEqual(payload["type"], WebHookType.NEW_CONFIRMATION.name)
        self.assertEqual(payload["chainId"], str(EthereumNetwork.GANACHE.value))

        payload = build_webhook_payload(
            MultisigTransaction, MultisigTransactionFactory()
        )[0]
        self.assertEqual(
            payload["type"], WebHookType.EXECUTED_MULTISIG_TRANSACTION.name
        )
        self.assertEqual(payload["chainId"], str(EthereumNetwork.GANACHE.value))

        payload = build_webhook_payload(
            MultisigTransaction, MultisigTransactionFactory(ethereum_tx=None)
        )[0]
        self.assertEqual(payload["type"], WebHookType.PENDING_MULTISIG_TRANSACTION.name)
        self.assertEqual(payload["chainId"], str(EthereumNetwork.GANACHE.value))

    @factory.django.mute_signals(post_save)
    def test_process_webhook(self):
        multisig_confirmation = MultisigConfirmationFactory()
        with mock.patch.object(send_webhook_task, "apply_async") as webhook_task_mock:
            with mock.patch.object(
                send_notification_task, "apply_async"
            ) as send_notification_task_mock:
                process_webhook(MultisigConfirmation, multisig_confirmation, True)
                webhook_task_mock.assert_called()
                send_notification_task_mock.assert_called()

        multisig_confirmation.created -= timedelta(minutes=75)
        with mock.patch.object(send_webhook_task, "apply_async") as webhook_task_mock:
            with mock.patch.object(
                send_notification_task, "apply_async"
            ) as send_notification_task_mock:
                process_webhook(MultisigConfirmation, multisig_confirmation, True)
                webhook_task_mock.assert_not_called()
                send_notification_task_mock.assert_not_called()

    @factory.django.mute_signals(post_save)
    def test_is_relevant_notification(self):
        multisig_confirmation = MultisigConfirmationFactory()
        self.assertFalse(
            is_relevant_notification(
                multisig_confirmation.__class__, multisig_confirmation, created=False
            )
        )
        self.assertTrue(
            is_relevant_notification(
                multisig_confirmation.__class__, multisig_confirmation, created=True
            )
        )
        multisig_confirmation.created -= timedelta(minutes=75)
        self.assertFalse(
            is_relevant_notification(
                multisig_confirmation.__class__, multisig_confirmation, created=True
            )
        )

        multisig_tx = MultisigTransactionFactory()
        self.assertTrue(
            is_relevant_notification(multisig_tx.__class__, multisig_tx, created=False)
        )
        multisig_tx.created -= timedelta(minutes=75)
        self.assertTrue(
            is_relevant_notification(multisig_tx.__class__, multisig_tx, created=False)
        )
        multisig_tx.modified -= timedelta(minutes=75)
        self.assertFalse(
            is_relevant_notification(multisig_tx.__class__, multisig_tx, created=False)
        )

'''
'''--- safe_transaction_service/history/tests/test_tasks.py ---
import dataclasses
import json
import logging
from datetime import timedelta
from unittest.mock import MagicMock, patch

from django.test import TestCase
from django.utils import timezone

import requests
from eth_account import Account

from gnosis.eth import EthereumClient, EthereumNetwork

from ...utils.redis import get_redis
from ..models import SafeContract, SafeLastStatus, SafeStatus
from ..services import CollectiblesService, CollectiblesServiceProvider, IndexService
from ..services.collectibles_service import CollectibleWithMetadata
from ..tasks import (
    check_reorgs_task,
    check_sync_status_task,
    get_webhook_http_session,
    index_erc20_events_out_of_sync_task,
    index_erc20_events_task,
    index_internal_txs_task,
    index_new_proxies_task,
    index_safe_events_task,
)
from ..tasks import logger as task_logger
from ..tasks import (
    process_decoded_internal_txs_for_safe_task,
    process_decoded_internal_txs_task,
    reindex_last_hours_task,
    retry_get_metadata_task,
)
from .factories import (
    ERC20TransferFactory,
    EthereumBlockFactory,
    InternalTxDecodedFactory,
    InternalTxFactory,
    SafeContractFactory,
    SafeStatusFactory,
    WebHookFactory,
)

logger = logging.getLogger(__name__)

class TestTasks(TestCase):
    def test_check_reorgs_task(self):
        self.assertIsNone(check_reorgs_task.delay().result, 0)

    def test_check_sync_status_task(self):
        self.assertFalse(check_sync_status_task.delay().result)

    def test_index_erc20_events_task(self):
        self.assertEqual(index_erc20_events_task.delay().result, 0)

    def test_index_erc20_events_out_of_sync_task(self):
        with self.assertLogs(logger=task_logger) as cm:
            index_erc20_events_out_of_sync_task.delay()
            self.assertIn("No addresses to process", cm.output[0])

        with self.assertLogs(logger=task_logger) as cm:
            safe_contract = SafeContractFactory()
            index_erc20_events_out_of_sync_task.delay()
            self.assertIn(
                f"Start indexing of erc20/721 events for out of sync addresses {[safe_contract.address]}",
                cm.output[0],
            )
            self.assertIn(
                "Indexing of erc20/721 events for out of sync addresses task processed 0 events",
                cm.output[1],
            )

    def test_index_internal_txs_task(self):
        self.assertEqual(index_internal_txs_task.delay().result, 0)

    def test_index_new_proxies_task(self):
        self.assertEqual(index_new_proxies_task.delay().result, 0)

    def test_index_safe_events_task(self):
        self.assertEqual(index_safe_events_task.delay().result, 0)

    @patch.object(IndexService, "reindex_erc20_events")
    @patch.object(IndexService, "reindex_master_copies")
    def test_reindex_last_hours_task(
        self, reindex_master_copies_mock: MagicMock, reindex_erc20_events: MagicMock
    ):
        now = timezone.now()
        one_hour_ago = now - timedelta(hours=1)
        one_day_ago = now - timedelta(days=1)
        one_week_ago = now - timedelta(weeks=1)

        reindex_last_hours_task()
        reindex_master_copies_mock.assert_not_called()

        ethereum_block_0 = EthereumBlockFactory(timestamp=one_week_ago)
        ethereum_block_1 = EthereumBlockFactory(timestamp=one_day_ago)
        ethereum_block_2 = EthereumBlockFactory(timestamp=one_hour_ago)
        ethereum_block_3 = EthereumBlockFactory(timestamp=now)

        reindex_last_hours_task()
        reindex_master_copies_mock.assert_called_once_with(
            from_block_number=ethereum_block_1.number,
            to_block_number=ethereum_block_3.number,
        )
        reindex_erc20_events.assert_called_once_with(
            from_block_number=ethereum_block_1.number,
            to_block_number=ethereum_block_3.number,
        )

    @patch.object(EthereumClient, "get_network", return_value=EthereumNetwork.GANACHE)
    @patch.object(requests.Session, "post")
    def test_send_webhook_task(self, mock_post: MagicMock, get_network_mock: MagicMock):
        ERC20TransferFactory()

        with self.assertRaises(AssertionError):
            mock_post.assert_called()

        to = Account.create().address
        WebHookFactory(address="")
        WebHookFactory(address=Account.create().address)
        WebHookFactory(address=to)
        InternalTxFactory(to=to)
        # 3 webhooks: INCOMING_ETHER for Webhook with `to`, and then `INCOMING_ETHER` and `OUTGOING_ETHER`
        # for the WebHook without address set
        self.assertEqual(mock_post.call_count, 3)

    def test_get_webhook_http_session(self):
        session = get_webhook_http_session("http://random-url", None)
        self.assertNotIn("Authorization", session.headers)

        secret_token = "IDDQD"
        session = get_webhook_http_session("http://random-url", secret_token)
        self.assertEqual(session.headers["Authorization"], secret_token)

    def test_process_decoded_internal_txs_task(self):
        owner = Account.create().address
        safe_address = Account.create().address
        fallback_handler = Account.create().address
        master_copy = Account.create().address
        threshold = 1
        InternalTxDecodedFactory(
            function_name="setup",
            owner=owner,
            threshold=threshold,
            fallback_handler=fallback_handler,
            internal_tx__to=master_copy,
            internal_tx___from=safe_address,
        )
        process_decoded_internal_txs_task.delay()
        self.assertTrue(SafeContract.objects.get(address=safe_address))
        safe_status = SafeStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status.enabled_modules, [])
        self.assertEqual(safe_status.fallback_handler, fallback_handler)
        self.assertEqual(safe_status.master_copy, master_copy)
        self.assertEqual(safe_status.owners, [owner])
        self.assertEqual(safe_status.threshold, threshold)

    def test_process_decoded_internal_txs_for_safe_task(self):
        # Test corrupted SafeStatus
        safe_status_0 = SafeStatusFactory(nonce=0)
        safe_address = safe_status_0.address
        safe_status_2 = SafeStatusFactory(nonce=2, address=safe_address)
        safe_status_5 = SafeStatusFactory(nonce=5, address=safe_address)
        SafeLastStatus.objects.update_or_create_from_safe_status(safe_status_5)
        with patch.object(IndexService, "reindex_master_copies") as reindex_mock:
            with patch.object(IndexService, "reprocess_addresses") as reprocess_mock:
                with self.assertLogs(logger=task_logger) as cm:
                    process_decoded_internal_txs_for_safe_task.delay(safe_address)
                    reprocess_mock.assert_called_with([safe_address])
                    reindex_mock.assert_called_with(
                        from_block_number=safe_status_0.block_number,
                        to_block_number=safe_status_5.block_number,
                    )
                    self.assertIn(
                        f"Safe-address={safe_address} A problem was found in SafeStatus "
                        f"with nonce=2 on internal-tx-id={safe_status_2.internal_tx_id}",
                        cm.output[1],
                    )
                    self.assertIn(
                        f"Safe-address={safe_address} Processing traces again",
                        cm.output[2],
                    )
                    self.assertIn(
                        f"Safe-address={safe_address} Last known not corrupted SafeStatus with nonce=0 on "
                        f"block={safe_status_0.internal_tx.ethereum_tx.block_id} , "
                        f"reindexing until block={safe_status_5.block_number}",
                        cm.output[3],
                    )
                    self.assertIn(
                        f"Reindexing master copies from-block={safe_status_0.internal_tx.ethereum_tx.block_id} "
                        f"to-block={safe_status_5.block_number}",
                        cm.output[4],
                    )
                    self.assertIn(
                        f"Safe-address={safe_address} Processing traces again after reindexing",
                        cm.output[5],
                    )

    @patch.object(CollectiblesService, "get_metadata", autospec=True, return_value={})
    def test_retry_get_metadata_task(self, get_metadata_mock: MagicMock):
        redis = get_redis()
        collectibles_service = CollectiblesServiceProvider()

        collectible_address = Account.create().address
        collectible_id = 16
        metadata_cache_key = collectibles_service.get_metadata_cache_key(
            collectible_address, collectible_id
        )

        metadata = {
            "name": "Octopus",
            "description": "Atlantic Octopus",
            "image": "http://random-address.org/logo-28.png",
        }

        # Check metadata cannot be retrieved
        get_metadata_mock.assert_not_called()
        self.assertEqual(
            retry_get_metadata_task(collectible_address, collectible_id), None
        )
        # Collectible needs to be cached so metadata can be fetched
        get_metadata_mock.assert_not_called()

        get_metadata_mock.return_value = metadata
        expected = CollectibleWithMetadata(
            "Octopus",
            "OCT",
            "http://random-address.org/logo.png",
            collectible_address,
            collectible_id,
            "http://random-address.org/info-28.json",
            metadata,
        )
        redis.set(
            metadata_cache_key,
            json.dumps(dataclasses.asdict(expected)),
            ex=300,
        )

        self.assertEqual(
            retry_get_metadata_task(collectible_address, collectible_id), expected
        )
        # As metadata was set, task is not requesting it
        get_metadata_mock.assert_not_called()

        collectible_without_metadata = CollectibleWithMetadata(
            "Octopus",
            "OCT",
            "http://random-address.org/logo.png",
            collectible_address,
            collectible_id,
            "http://random-address.org/info-28.json",
            {},
        )
        redis.set(
            metadata_cache_key,
            json.dumps(dataclasses.asdict(collectible_without_metadata)),
            ex=300,
        )

        self.assertEqual(
            retry_get_metadata_task(collectible_address, collectible_id), expected
        )
        # As metadata was not set, task requested it
        get_metadata_mock.assert_called_once()

        self.assertEqual(
            json.loads(redis.get(metadata_cache_key)), dataclasses.asdict(expected)
        )
        redis.delete(metadata_cache_key)

'''
'''--- safe_transaction_service/history/tests/test_transaction_service.py ---
from datetime import timedelta

from django.test import TestCase
from django.utils import timezone

from eth_account import Account

from ..models import EthereumTx, ModuleTransaction, MultisigTransaction
from ..services.transaction_service import (
    TransactionService,
    TransactionServiceProvider,
)
from .factories import (
    ERC20TransferFactory,
    InternalTxFactory,
    ModuleTransactionFactory,
    MultisigTransactionFactory,
)

class TestTransactionService(TestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.transaction_service: TransactionService = TransactionServiceProvider()
        cls.transaction_service.redis.flushall()

    def tearDown(self):
        super().tearDown()
        self.transaction_service.redis.flushall()

    def test_get_all_tx_hashes(self):
        transaction_service: TransactionService = self.transaction_service
        safe_address = Account.create().address
        self.assertFalse(transaction_service.get_all_tx_hashes(safe_address))

        # Factories create the models using current datetime, so as the txs are returned sorted they should be
        # in the reverse order that they were created
        multisig_transaction = MultisigTransactionFactory(safe=safe_address)
        multisig_transaction_not_mined = MultisigTransactionFactory(
            safe=safe_address, nonce=multisig_transaction.nonce, ethereum_tx=None
        )
        module_transaction = ModuleTransactionFactory(safe=safe_address)
        internal_tx_in = InternalTxFactory(to=safe_address, value=4)
        internal_tx_out = InternalTxFactory(
            _from=safe_address, value=5
        )  # Should not appear
        erc20_transfer_in = ERC20TransferFactory(to=safe_address)
        erc20_transfer_out = ERC20TransferFactory(
            _from=safe_address
        )  # Should not appear
        another_multisig_transaction = MultisigTransactionFactory(safe=safe_address)
        another_safe_multisig_transaction = (
            MultisigTransactionFactory()
        )  # Should not appear, it's for another Safe

        # Should not appear unless queued=True, nonce > last mined transaction
        higher_nonce_safe_multisig_transaction = MultisigTransactionFactory(
            safe=safe_address, ethereum_tx=None
        )
        higher_nonce_safe_multisig_transaction_2 = MultisigTransactionFactory(
            safe=safe_address, ethereum_tx=None
        )

        # As there is no multisig tx trusted, just module txs and transfers are returned
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=False, trusted=True
            ).count(),
            4,
        )

        # We change a queued tx, a change was not expected unless we set queued=True
        higher_nonce_safe_multisig_transaction.trusted = True
        higher_nonce_safe_multisig_transaction.save()
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=False, trusted=True
            ).count(),
            4,
        )
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=True, trusted=True
            ).count(),
            5,
        )

        queryset = transaction_service.get_all_tx_hashes(
            safe_address, queued=True, trusted=False
        )
        self.assertEqual(queryset.count(), 9)

        queryset = transaction_service.get_all_tx_hashes(
            safe_address, queued=False, trusted=False
        )
        self.assertEqual(queryset.count(), 7)

        every_execution_date = [element["execution_date"] for element in queryset]
        expected_times = [
            another_multisig_transaction.ethereum_tx.block.timestamp,
            erc20_transfer_out.ethereum_tx.block.timestamp,
            erc20_transfer_in.ethereum_tx.block.timestamp,
            internal_tx_in.ethereum_tx.block.timestamp,
            module_transaction.internal_tx.ethereum_tx.block.timestamp,
            multisig_transaction.ethereum_tx.block.timestamp,
            multisig_transaction.ethereum_tx.block.timestamp,  # Should take timestamp from tx with same nonce and mined
        ]
        self.assertEqual(every_execution_date, expected_times)

        all_tx_hashes = [element["safe_tx_hash"] for element in queryset]
        expected_hashes = [
            another_multisig_transaction.safe_tx_hash,
            erc20_transfer_out.ethereum_tx_id,
            erc20_transfer_in.ethereum_tx_id,
            internal_tx_in.ethereum_tx_id,
            module_transaction.internal_tx.ethereum_tx_id,
            multisig_transaction.safe_tx_hash,  # First the mined tx
            multisig_transaction_not_mined.safe_tx_hash,
        ]
        self.assertEqual(all_tx_hashes, expected_hashes)

        queryset = transaction_service.get_all_tx_hashes(
            safe_address, trusted=True, queued=False
        )
        self.assertEqual(queryset.count(), 4)

    def test_get_all_tx_hashes_executed(self):
        transaction_service: TransactionService = self.transaction_service
        safe_address = Account.create().address

        # No mined
        MultisigTransactionFactory(safe=safe_address, ethereum_tx=None)
        MultisigTransactionFactory(safe=safe_address, ethereum_tx=None)
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=False, trusted=False
            ).count(),
            0,
        )
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=True, trusted=False
            ).count(),
            2,
        )
        # Mine tx with higher nonce, all should appear
        MultisigTransactionFactory(safe=safe_address)
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=False, trusted=False
            ).count(),
            3,
        )

        # Only one is executed
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, executed=True, queued=False, trusted=False
            ).count(),
            1,
        )

    def test_get_all_tx_hashes_queued(self):
        transaction_service: TransactionService = self.transaction_service
        safe_address = Account.create().address

        # No mined tx, so nothing is returned
        MultisigTransactionFactory(safe=safe_address, ethereum_tx=None)
        MultisigTransactionFactory(safe=safe_address, ethereum_tx=None)
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=False, trusted=False
            ).count(),
            0,
        )
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=True, trusted=False
            ).count(),
            2,
        )

        # Mine tx with higher nonce, all should appear
        MultisigTransactionFactory(safe=safe_address)
        self.assertEqual(
            transaction_service.get_all_tx_hashes(
                safe_address, queued=False, trusted=False
            ).count(),
            3,
        )

    def test_get_all_tx_nonce_sorting(self):
        transaction_service: TransactionService = self.transaction_service
        safe_address = Account.create().address
        # Test edge case of 2 multisig transactions inside the same ethereum transaction
        m_1 = MultisigTransactionFactory(safe=safe_address, trusted=True, nonce=1)
        MultisigTransactionFactory(
            safe=safe_address, trusted=True, ethereum_tx=m_1.ethereum_tx, nonce=0
        )

        # Test sorting
        queryset = transaction_service.get_all_tx_hashes(safe_address)
        tx_hashes = [q["safe_tx_hash"] for q in queryset]
        transactions = transaction_service.get_all_txs_from_hashes(
            safe_address, tx_hashes
        )
        self.assertEqual(transactions[0].nonce, 1)
        self.assertEqual(transactions[1].nonce, 0)

    def test_get_all_txs_from_hashes(self):
        transaction_service: TransactionService = self.transaction_service
        safe_address = Account.create().address
        self.assertFalse(transaction_service.get_all_tx_hashes(safe_address))

        # Factories create the models using current datetime, so as the txs are returned sorted they should be
        # in the reverse order that they were created
        multisig_transaction = MultisigTransactionFactory(
            safe=safe_address,
            ethereum_tx__block__timestamp=timezone.now() - timedelta(days=1),
        )
        module_transaction = ModuleTransactionFactory(safe=safe_address)
        internal_tx_in = InternalTxFactory(to=safe_address, value=4)
        internal_tx_out = InternalTxFactory(_from=safe_address, value=5)
        erc20_transfer_in = ERC20TransferFactory(to=safe_address)
        erc20_transfer_out = ERC20TransferFactory(
            _from=safe_address
        )  # Should not appear
        another_multisig_transaction = MultisigTransactionFactory(safe=safe_address)
        another_safe_multisig_transaction = (
            MultisigTransactionFactory()
        )  # Should not appear, it's for another Safe

        queryset = transaction_service.get_all_tx_hashes(
            safe_address, queued=False, trusted=False
        )
        all_tx_hashes = [q["safe_tx_hash"] for q in queryset]

        self.assertEqual(len(self.transaction_service.redis.keys("*")), 0)
        all_txs = transaction_service.get_all_txs_from_hashes(
            safe_address, all_tx_hashes
        )
        self.assertEqual(len(self.transaction_service.redis.keys("*")), 1)
        all_txs = transaction_service.get_all_txs_from_hashes(
            safe_address, all_tx_hashes
        )  # Force caching
        self.assertEqual(len(self.transaction_service.redis.keys("*")), 1)
        self.assertEqual(len(all_txs), 6)
        tx_types = [
            MultisigTransaction,
            EthereumTx,
            EthereumTx,
            EthereumTx,
            ModuleTransaction,
            MultisigTransaction,
        ]
        numbers_of_transfers = [0, 1, 1, 1, 0, 0]
        for tx, tx_type, number_of_transfers in zip(
            all_txs, tx_types, numbers_of_transfers
        ):
            self.assertEqual(type(tx), tx_type)
            self.assertEqual(len(tx.transfers), number_of_transfers)
            for transfer in tx.transfers:
                self.assertIsNone(transfer["token"])

        # Insert 2 transfers for the MultisigTx and one for the ModuleTx
        internal_tx_out_2 = InternalTxFactory(
            _from=safe_address,
            value=5,
            ethereum_tx=another_multisig_transaction.ethereum_tx,
        )
        erc20_transfer_in_2 = ERC20TransferFactory(
            to=safe_address, ethereum_tx=another_multisig_transaction.ethereum_tx
        )
        internal_tx_in_2 = InternalTxFactory(
            to=safe_address,
            value=4,
            ethereum_tx=module_transaction.internal_tx.ethereum_tx,
        )

        queryset_2 = transaction_service.get_all_tx_hashes(
            safe_address, queued=False, trusted=False
        )
        all_tx_hashes_2 = [q["safe_tx_hash"] for q in queryset_2]

        all_txs_2 = transaction_service.get_all_txs_from_hashes(
            safe_address, all_tx_hashes_2
        )
        self.assertEqual(len(all_txs_2), 6)
        tx_types = [
            MultisigTransaction,
            EthereumTx,
            EthereumTx,
            EthereumTx,
            ModuleTransaction,
            MultisigTransaction,
        ]
        numbers_of_transfers = [0 + 2, 1, 1, 1, 0 + 1, 0]
        for tx, tx_type, number_of_transfers in zip(
            all_txs_2, tx_types, numbers_of_transfers
        ):
            self.assertEqual(type(tx), tx_type)
            self.assertEqual(len(tx.transfers), number_of_transfers)
            for transfer in tx.transfers:
                self.assertIsNone(transfer["token"])

        all_txs_serialized = transaction_service.serialize_all_txs(all_txs_2)
        self.assertEqual(len(all_txs_serialized), len(all_txs_2))
        for tx_serialized in all_txs_serialized:
            self.assertTrue(isinstance(tx_serialized, dict))

'''
'''--- safe_transaction_service/history/tests/test_tx_processor.py ---
import logging
from unittest import mock

from django.test import TestCase

from eth_account import Account
from eth_utils import keccak
from web3 import Web3

from gnosis.eth.ethereum_client import ParityManager
from gnosis.safe.safe_signature import SafeSignatureType

from safe_transaction_service.safe_messages.models import SafeMessageConfirmation
from safe_transaction_service.safe_messages.tests.factories import (
    SafeMessageConfirmationFactory,
)

from ..indexers.tx_processor import SafeTxProcessor, SafeTxProcessorProvider
from ..models import (
    InternalTxDecoded,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    SafeContract,
    SafeLastStatus,
    SafeStatus,
)
from .factories import (
    EthereumTxFactory,
    InternalTxDecodedFactory,
    MultisigConfirmationFactory,
    MultisigTransactionFactory,
    SafeLastStatusFactory,
    SafeMasterCopyFactory,
)
from .mocks.traces import call_trace, module_traces, rinkeby_traces

logger = logging.getLogger(__name__)

class TestSafeTxProcessor(TestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.tx_processor: SafeTxProcessor = SafeTxProcessorProvider()

    @classmethod
    def tearDownClass(cls):
        super().tearDownClass()
        SafeTxProcessorProvider.del_singleton()

    def test_tx_processor_with_factory(self):
        tx_processor = self.tx_processor
        owner = Account.create().address
        safe_address = Account.create().address
        fallback_handler = Account.create().address
        master_copy = Account.create().address
        threshold = 1
        tx_processor.process_decoded_transaction(
            InternalTxDecodedFactory(
                function_name="setup",
                owner=owner,
                threshold=threshold,
                fallback_handler=fallback_handler,
                internal_tx__to=master_copy,
                internal_tx___from=safe_address,
            )
        )
        self.assertTrue(SafeContract.objects.get(address=safe_address))
        safe_status = SafeStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status.enabled_modules, [])
        self.assertEqual(safe_status.fallback_handler, fallback_handler)
        self.assertEqual(safe_status.master_copy, master_copy)
        self.assertEqual(safe_status.owners, [owner])
        self.assertEqual(safe_status.threshold, threshold)

        # execTransaction should be calling addOwnerWithThreshold, so we process it together
        threshold = 2
        new_owner = Account.create().address
        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="addOwnerWithThreshold",
                    owner=new_owner,
                    threshold=threshold,
                    internal_tx___from=safe_address,
                ),
            ]
        )

        self.assertEqual(SafeStatus.objects.count(), 3)
        safe_status = SafeStatus.objects.last_for_address(safe_address)
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.owners, [new_owner, owner])
        self.assertEqual(safe_status.nonce, 1)
        self.assertEqual(safe_status.threshold, threshold)

        another_owner = Account.create().address
        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="swapOwner",
                    old_owner=owner,
                    owner=another_owner,
                    internal_tx___from=safe_address,
                ),
            ]
        )
        self.assertEqual(SafeStatus.objects.count(), 5)
        safe_status = SafeStatus.objects.last_for_address(safe_address)
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.owners, [new_owner, another_owner])
        self.assertEqual(safe_status.nonce, 2)
        self.assertEqual(safe_status.threshold, threshold)

        threshold = 1
        # Check deleting the owner did delete this pending confirmation for both signature and transaction
        # It will insert a transaction we will remove after we check the confirmation was deleted
        unused_multisig_confirmation = MultisigConfirmationFactory(
            owner=another_owner,
            multisig_transaction__ethereum_tx=None,
            multisig_transaction__nonce=safe_status.nonce + 1,
            multisig_transaction__safe=safe_address,
        )
        # This will be deleted
        unused_message_confirmation = SafeMessageConfirmationFactory(
            owner=another_owner
        )
        # This won't be deleted
        unused_message_confirmation_2 = SafeMessageConfirmationFactory(
            safe_message=unused_message_confirmation.safe_message
        )
        self.assertEqual(SafeMessageConfirmation.objects.count(), 2)
        number_confirmations = MultisigConfirmation.objects.count()
        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="removeOwner",
                    old_owner=another_owner,
                    threshold=threshold,
                    internal_tx___from=safe_address,
                ),
            ]
        )
        # At least 1 confirmation is always added by `execTransaction` and 1 should be removed
        self.assertEqual(
            MultisigConfirmation.objects.count(), number_confirmations + 1 - 1
        )
        unused_multisig_confirmation.multisig_transaction.delete()  # Remove this transaction inserted manually
        self.assertEqual(SafeMessageConfirmation.objects.count(), 1)
        self.assertTrue(
            SafeMessageConfirmation.objects.filter(
                owner=unused_message_confirmation_2.owner
            ).exists()
        )
        self.assertEqual(SafeStatus.objects.count(), 7)
        safe_status = SafeStatus.objects.last_for_address(safe_address)
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.owners, [new_owner])
        self.assertEqual(safe_status.nonce, 3)
        self.assertEqual(safe_status.threshold, threshold)

        fallback_handler = Account.create().address
        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="setFallbackHandler",
                    fallback_handler=fallback_handler,
                    internal_tx___from=safe_address,
                ),
            ]
        )
        self.assertEqual(SafeStatus.objects.count(), 9)
        safe_status = SafeStatus.objects.last_for_address(safe_address)
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.fallback_handler, fallback_handler)
        self.assertEqual(safe_status.nonce, 4)

        master_copy = Account.create().address
        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="changeMasterCopy",
                    master_copy=master_copy,
                    internal_tx___from=safe_address,
                ),
            ]
        )
        safe_status = SafeStatus.objects.last_for_address(safe_address)
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.master_copy, master_copy)
        self.assertEqual(safe_status.nonce, 5)
        self.assertEqual(safe_status.enabled_modules, [])

        module = Account.create().address
        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="enableModule",
                    module=module,
                    internal_tx___from=safe_address,
                ),
            ]
        )
        safe_status = SafeStatus.objects.last_for_address(safe_address)
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.enabled_modules, [module])
        self.assertEqual(safe_status.nonce, 6)

        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="disableModule",
                    module=module,
                    internal_tx___from=safe_address,
                ),
            ]
        )
        safe_status = SafeStatus.objects.last_for_address(safe_address)
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.enabled_modules, [])
        self.assertEqual(safe_status.nonce, 7)

        with mock.patch.object(
            ParityManager,
            "trace_transaction",
            autospec=True,
            return_value=rinkeby_traces,
        ):
            # call_trace has [] as a trace address and module txs need to get the grandfather tx, so [0,0] must
            # be used
            module_internal_tx_decoded = InternalTxDecodedFactory(
                function_name="execTransactionFromModule",
                internal_tx___from=safe_address,
                internal_tx__trace_address="0,0",
            )
            tx_processor.process_decoded_transactions(
                [
                    module_internal_tx_decoded,
                ]
            )
        safe_status = SafeStatus.objects.last_for_address(safe_address)
        safe_last_status = SafeLastStatus.objects.get(address=safe_address)
        self.assertEqual(safe_status, SafeStatus.from_status_instance(safe_last_status))
        self.assertEqual(safe_status.nonce, 7)  # Nonce not incrementing
        self.assertEqual(ModuleTransaction.objects.count(), 1)

        self.assertEqual(MultisigTransaction.objects.count(), 7)
        self.assertEqual(
            MultisigTransaction.objects.count(),
            InternalTxDecoded.objects.filter(function_name="execTransaction").count(),
        )
        for multisig_transaction in MultisigTransaction.objects.all():
            self.assertTrue(multisig_transaction.trusted)

        # Test ApproveHash. For that we need the `previous_trace` to get the owner
        hash_to_approve = keccak(text="HariSeldon").hex()
        owner_approving = Account.create().address
        approve_hash_decoded_tx = InternalTxDecodedFactory(
            function_name="approveHash",
            hash_to_approve=hash_to_approve,
            internal_tx___from=safe_address,
            internal_tx__trace_address="0,1,0",
        )
        approve_hash_previous_call_trace = dict(call_trace)
        approve_hash_previous_call_trace["action"]["from"] = owner_approving
        approve_hash_previous_call_trace["traceAddress"] = [0, 1]
        # Not needed
        # approve_hash_call_trace['transactionHash'] = approve_hash_decoded_tx.internal_tx.ethereum_tx_id
        with mock.patch.object(
            ParityManager,
            "trace_transaction",
            autospec=True,
            return_value=[approve_hash_previous_call_trace],
        ):
            tx_processor.process_decoded_transactions(
                [
                    InternalTxDecodedFactory(
                        function_name="execTransaction", internal_tx___from=safe_address
                    ),
                    approve_hash_decoded_tx,
                ]
            )
            safe_status = SafeStatus.objects.last_for_address(safe_address)
            safe_last_status = SafeLastStatus.objects.get(address=safe_address)
            self.assertEqual(
                safe_status, SafeStatus.from_status_instance(safe_last_status)
            )
            self.assertEqual(safe_status.nonce, 8)
            multisig_confirmation = MultisigConfirmation.objects.get(
                multisig_transaction_hash=hash_to_approve
            )
            self.assertEqual(
                multisig_confirmation.signature_type,
                SafeSignatureType.APPROVED_HASH.value,
            )

    def test_tx_processor_failed(self):
        tx_processor = self.tx_processor
        # Event for Safes < 1.1.1
        logs = [
            {
                "data": "0x0034bff0dedc4c75f43df64a179ff26d56b99fa742fcfaeeee51e2da4e279b67",
                "topics": [
                    "0xabfd711ecdd15ae3a6b3ad16ff2e9d81aec026a39d16725ee164be4fbf857a7c"
                ],
            }
        ]
        ethereum_tx = EthereumTxFactory(logs=logs)
        self.assertTrue(tx_processor.is_failed(ethereum_tx, logs[0]["data"]))
        self.assertFalse(
            tx_processor.is_failed(ethereum_tx, Web3.keccak(text="hola").hex())
        )

        # Event for Safes >= 1.1.1
        safe_tx_hash = (
            "0x4c15b21b9c3b57aebba3c274bf0a437950bd0eea46bc7a7b2df892f91f720311"
        )
        logs = [
            {
                "data": "0x4c15b21b9c3b57aebba3c274bf0a437950bd0eea46bc7a7b2df892f91f720311"
                "0000000000000000000000000000000000000000000000000000000000000000",
                "topics": [
                    "0x23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23"
                ],
            }
        ]
        ethereum_tx = EthereumTxFactory(logs=logs)
        self.assertTrue(tx_processor.is_failed(ethereum_tx, safe_tx_hash))
        self.assertFalse(
            tx_processor.is_failed(ethereum_tx, Web3.keccak(text="hola").hex())
        )

    def test_tx_is_version_breaking_signatures(self):
        tx_processor = self.tx_processor
        self.assertTrue(tx_processor.is_version_breaking_signatures("0.0.1", "1.1.1"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("0.0.1", "1.3.0"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("0.0.1", "1.4.0"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.0.0", "1.3.0"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.1.1", "1.3.0"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.2.0", "1.3.0"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.2.1", "1.4.0"))
        self.assertFalse(tx_processor.is_version_breaking_signatures("1.0.0", "1.2.2"))
        self.assertFalse(tx_processor.is_version_breaking_signatures("1.1.0", "1.2.0"))
        self.assertFalse(tx_processor.is_version_breaking_signatures("0.0.1", "0.9.0"))

        # Reversed
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.1.1", "0.0.1"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.3.0", "0.0.1"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.3.0", "0.0.1"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.3.0", "1.0.0"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.3.0", "1.1.1"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.3.0", "1.2.0"))
        self.assertTrue(tx_processor.is_version_breaking_signatures("1.4.0", "1.2.1"))
        self.assertFalse(tx_processor.is_version_breaking_signatures("1.2.2", "1.0.0"))
        self.assertFalse(tx_processor.is_version_breaking_signatures("1.2.0", "1.1.0"))
        self.assertFalse(tx_processor.is_version_breaking_signatures("0.9.0", "0.0.1"))

    def test_tx_processor_change_master_copy(self):
        tx_processor = self.tx_processor
        owner = Account.create().address
        safe_address = Account.create().address
        fallback_handler = Account.create().address
        threshold = 1
        safe_1_1_0_master_copy = SafeMasterCopyFactory(version="1.1.0")
        safe_1_2_0_master_copy = SafeMasterCopyFactory(version="1.2.0")
        safe_1_3_0_master_copy = SafeMasterCopyFactory(version="1.3.0")
        tx_processor.process_decoded_transaction(
            InternalTxDecodedFactory(
                function_name="setup",
                owner=owner,
                threshold=threshold,
                fallback_handler=fallback_handler,
                internal_tx__to=safe_1_1_0_master_copy.address,
                internal_tx___from=safe_address,
            )
        )
        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="changeMasterCopy",
                    master_copy=safe_1_2_0_master_copy.address,
                    internal_tx___from=safe_address,
                ),
            ]
        )
        self.assertEqual(MultisigTransaction.objects.get().nonce, 0)
        MultisigTransactionFactory(
            safe=safe_address, nonce=1, ethereum_tx=None
        )  # This will not be deleted as execTransaction will insert a tx with nonce=1
        MultisigTransactionFactory(
            safe=safe_address, nonce=2, ethereum_tx=None
        )  # This will be deleted when migrating to the 1.3.0 master copy
        self.assertEqual(
            MultisigTransaction.objects.filter(safe=safe_address, nonce=2).count(), 1
        )
        self.assertEqual(MultisigTransaction.objects.count(), 3)
        tx_processor.process_decoded_transactions(
            [
                InternalTxDecodedFactory(
                    function_name="execTransaction", internal_tx___from=safe_address
                ),
                InternalTxDecodedFactory(
                    function_name="changeMasterCopy",
                    master_copy=safe_1_3_0_master_copy.address,
                    internal_tx___from=safe_address,
                ),
            ]
        )

        self.assertEqual(
            MultisigTransaction.objects.filter(safe=safe_address, nonce=1).count(), 2
        )
        self.assertEqual(
            MultisigTransaction.objects.filter(safe=safe_address, nonce=2).count(), 0
        )  # It was deleted
        self.assertEqual(MultisigTransaction.objects.count(), 3)

    def test_process_module_tx(self):
        safe_tx_processor = self.tx_processor
        safe_last_status = SafeLastStatusFactory()
        module_internal_tx_decoded = InternalTxDecodedFactory(
            function_name="execTransactionFromModule",
            internal_tx___from=safe_last_status.address,
            internal_tx__to="0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
            internal_tx__trace_address="0,0,0,4",
            internal_tx__ethereum_tx__tx_hash="0x59f20a56a94ad4ee934468eb26b9148151289c97fefece779e05d98befd156f0",
        )

        self.assertEqual(ModuleTransaction.objects.count(), 0)
        with self.assertRaises(ValueError):  # trace_transaction not supported
            safe_tx_processor.process_decoded_transaction(module_internal_tx_decoded)
            self.assertEqual(ModuleTransaction.objects.count(), 0)

        with mock.patch.object(
            ParityManager,
            "trace_transaction",
            autospec=True,
            return_value=module_traces,
        ):
            safe_tx_processor.process_decoded_transaction(module_internal_tx_decoded)
            self.assertEqual(ModuleTransaction.objects.count(), 1)
            module_tx = ModuleTransaction.objects.get()
            self.assertEqual(
                "0x" + bytes(module_tx.data).hex(),
                module_internal_tx_decoded.arguments["data"],
            )
            self.assertEqual(
                module_tx.module, "0x03967E5b71577ba3498E1a87E425139B22B3c085"
            )
            self.assertEqual(
                module_tx.operation, module_internal_tx_decoded.arguments["operation"]
            )
            self.assertEqual(module_tx.to, module_internal_tx_decoded.arguments["to"])
            self.assertEqual(
                module_tx.value, module_internal_tx_decoded.arguments["value"]
            )

    def test_store_new_safe_status(self):
        # Create a new SafeLastStatus
        safe_last_status = SafeLastStatusFactory(nonce=0)
        safe_address = safe_last_status.address
        safe_last_status_db = SafeLastStatus.objects.get()
        self.assertEqual(safe_last_status_db.address, safe_address)
        self.assertEqual(safe_last_status_db.nonce, 0)

        # Increase nonce and store it
        safe_last_status.nonce = 5
        self.tx_processor.store_new_safe_status(
            safe_last_status, safe_last_status.internal_tx
        )
        safe_last_status_db = SafeLastStatus.objects.get()
        self.assertEqual(safe_last_status_db.address, safe_address)
        self.assertEqual(safe_last_status_db.nonce, 5)

        # Use the factory to create a new SafeLastStatus
        new_safe_last_status = SafeLastStatusFactory(nonce=1)
        # Remove it, as we want to use it to replace our previous SafeLastStatus
        new_safe_last_status.delete()
        self.assertNotEqual(new_safe_last_status.address, safe_address)
        new_safe_last_status.address = safe_address

        self.tx_processor.store_new_safe_status(
            new_safe_last_status, new_safe_last_status.internal_tx
        )
        safe_last_status_db = SafeLastStatus.objects.get()
        self.assertEqual(safe_last_status_db.address, safe_address)
        self.assertEqual(safe_last_status_db.nonce, 1)

'''
'''--- safe_transaction_service/history/tests/test_views.py ---
import json
import logging
from dataclasses import asdict
from unittest import mock
from unittest.mock import MagicMock, PropertyMock

from django.contrib.auth import get_user_model
from django.contrib.auth.models import Permission
from django.urls import reverse
from django.utils import timezone

from eth_account import Account
from hexbytes import HexBytes
from requests import ReadTimeout
from rest_framework import status
from rest_framework.test import APIRequestFactory, APITestCase, force_authenticate
from web3 import Web3

from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.ethereum_client import EthereumClient, ParityManager
from gnosis.eth.utils import fast_is_checksum_address
from gnosis.safe import CannotEstimateGas, Safe, SafeOperation
from gnosis.safe.safe_signature import SafeSignature, SafeSignatureType
from gnosis.safe.signatures import signature_to_bytes
from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from safe_transaction_service.contracts.models import ContractQuerySet
from safe_transaction_service.contracts.tests.factories import ContractFactory
from safe_transaction_service.contracts.tx_decoder import DbTxDecoder
from safe_transaction_service.tokens.models import Token
from safe_transaction_service.tokens.services.price_service import PriceService
from safe_transaction_service.tokens.tests.factories import TokenFactory

from ..helpers import DelegateSignatureHelper
from ..models import (
    IndexingStatus,
    MultisigConfirmation,
    MultisigTransaction,
    SafeContractDelegate,
    SafeMasterCopy,
)
from ..serializers import TransferType
from ..services import BalanceService, CollectiblesService
from ..services.balance_service import Erc20InfoWithLogo
from ..services.collectibles_service import CollectibleWithMetadata
from ..views import SafeMultisigTransactionListView
from .factories import (
    ERC20TransferFactory,
    ERC721TransferFactory,
    EthereumTxFactory,
    InternalTxFactory,
    ModuleTransactionFactory,
    MultisigConfirmationFactory,
    MultisigTransactionFactory,
    SafeContractDelegateFactory,
    SafeContractFactory,
    SafeLastStatusFactory,
    SafeMasterCopyFactory,
    SafeStatusFactory,
)
from .mocks.traces import call_trace

logger = logging.getLogger(__name__)

class TestViews(SafeTestCaseMixin, APITestCase):
    def test_about_view(self):
        url = reverse("v1:history:about")
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_about_ethereum_rpc_url(self):
        for url_name in (
            "v1:history:about-ethereum-rpc",
            "v1:history:about-ethereum-tracing-rpc",
        ):
            with self.subTest(url_name=url_name):
                url = reverse(url_name)
                response = self.client.get(url, format="json")
                self.assertEqual(response.status_code, status.HTTP_200_OK)
                self.assertIn("EthereumJS TestRPC", response.data["version"])
                self.assertGreaterEqual(response.data["block_number"], 0)
                self.assertEqual(response.data["chain_id"], 1337)
                self.assertEqual(response.data["chain"], "GANACHE")
                self.assertEqual(response.data["syncing"], False)

    @mock.patch.object(
        EthereumClient,
        "current_block_number",
        new_callable=PropertyMock,
        return_value=2000,
    )
    def test_erc20_indexing_view(self, current_block_number_mock: PropertyMock):
        IndexingStatus.objects.set_erc20_721_indexing_status(2_000)
        url = reverse("v1:history:erc20-indexing")
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2_000)
        self.assertEqual(response.data["erc20_block_number"], 2_000)
        self.assertEqual(response.data["erc20_synced"], True)

        IndexingStatus.objects.set_erc20_721_indexing_status(10)
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2_000)
        self.assertEqual(response.data["erc20_block_number"], 10)
        self.assertEqual(response.data["erc20_synced"], False)

    @mock.patch.object(
        EthereumClient,
        "current_block_number",
        new_callable=PropertyMock,
        return_value=2_000,
    )
    def test_indexing_view(self, current_block_number_mock: PropertyMock):
        IndexingStatus.objects.set_erc20_721_indexing_status(2_000)
        url = reverse("v1:history:indexing")
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2_000)
        self.assertEqual(response.data["erc20_block_number"], 2_000)
        self.assertEqual(response.data["erc20_synced"], True)
        self.assertEqual(response.data["master_copies_block_number"], 2_000)
        self.assertEqual(response.data["master_copies_synced"], True)
        self.assertEqual(response.data["synced"], True)

        IndexingStatus.objects.set_erc20_721_indexing_status(500)
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2000)
        self.assertEqual(response.data["erc20_block_number"], 500)
        self.assertEqual(response.data["erc20_synced"], False)
        self.assertEqual(response.data["master_copies_block_number"], 2000)
        self.assertEqual(response.data["master_copies_synced"], True)
        self.assertEqual(response.data["synced"], False)

        safe_master_copy = SafeMasterCopyFactory(tx_block_number=1999)
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2000)
        self.assertEqual(response.data["erc20_block_number"], 500)
        self.assertEqual(response.data["erc20_synced"], False)
        self.assertEqual(response.data["master_copies_block_number"], 1999)
        self.assertEqual(response.data["master_copies_synced"], True)
        self.assertEqual(response.data["synced"], False)

        safe_master_copy.tx_block_number = 600
        safe_master_copy.save(update_fields=["tx_block_number"])
        response = self.client.get(url, format="json")
        self.assertEqual(response.data["current_block_number"], 2000)
        self.assertEqual(response.data["erc20_block_number"], 500)
        self.assertEqual(response.data["erc20_synced"], False)
        self.assertEqual(response.data["master_copies_block_number"], 600)
        self.assertEqual(response.data["master_copies_synced"], False)
        self.assertEqual(response.data["synced"], False)

        IndexingStatus.objects.set_erc20_721_indexing_status(10)
        SafeMasterCopyFactory(tx_block_number=9)
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2000)
        self.assertEqual(response.data["erc20_block_number"], 10)
        self.assertEqual(response.data["erc20_synced"], False)
        self.assertEqual(response.data["master_copies_block_number"], 9)
        self.assertEqual(response.data["master_copies_synced"], False)
        self.assertEqual(response.data["synced"], False)

        SafeMasterCopyFactory(tx_block_number=11)
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2000)
        self.assertEqual(response.data["erc20_block_number"], 10)
        self.assertEqual(response.data["erc20_synced"], False)
        self.assertEqual(response.data["master_copies_block_number"], 9)
        self.assertEqual(response.data["master_copies_synced"], False)
        self.assertEqual(response.data["synced"], False)

        IndexingStatus.objects.set_erc20_721_indexing_status(1_999)
        SafeMasterCopy.objects.update(tx_block_number=1999)
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2000)
        self.assertEqual(response.data["erc20_block_number"], 1999)
        self.assertEqual(response.data["erc20_synced"], True)
        self.assertEqual(response.data["master_copies_block_number"], 1999)
        self.assertEqual(response.data["master_copies_synced"], True)
        self.assertEqual(response.data["synced"], True)

        SafeMasterCopyFactory(tx_block_number=48)
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["current_block_number"], 2000)
        self.assertEqual(response.data["erc20_block_number"], 1999)
        self.assertEqual(response.data["erc20_synced"], True)
        self.assertEqual(response.data["master_copies_block_number"], 48)
        self.assertEqual(response.data["master_copies_synced"], False)
        self.assertEqual(response.data["synced"], False)

    def test_all_transactions_view(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)
        self.assertEqual(response.data["results"], [])

        # Factories create the models using current datetime, so as the txs are returned sorted they should be
        # in the reverse order that they were created
        multisig_transaction = MultisigTransactionFactory(safe=safe_address)
        module_transaction = ModuleTransactionFactory(safe=safe_address)
        internal_tx_in = InternalTxFactory(to=safe_address, value=4)
        internal_tx_out = InternalTxFactory(
            _from=safe_address, value=5
        )  # Should not appear
        erc20_transfer_in = ERC20TransferFactory(to=safe_address)
        erc20_transfer_out = ERC20TransferFactory(_from=safe_address)
        another_multisig_transaction = MultisigTransactionFactory(safe=safe_address)
        another_safe_multisig_transaction = (
            MultisigTransactionFactory()
        )  # Should not appear, it's for another Safe

        # Should not appear unless queued=True, nonce > last mined transaction
        higher_nonce_safe_multisig_transaction = MultisigTransactionFactory(
            safe=safe_address, ethereum_tx=None
        )
        higher_nonce_safe_multisig_transaction_2 = MultisigTransactionFactory(
            safe=safe_address, ethereum_tx=None
        )

        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=False&trusted=True"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 4)

        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=True&trusted=True"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 4)

        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=True&trusted=False"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 8)

        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=False&trusted=False"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 6)
        self.assertEqual(len(response.data["results"]), 6)
        transfers_not_empty = [
            False,  # Multisig transaction, no transfer
            True,  # Erc transfer out
            True,  # Erc transfer in
            True,  # internal tx in
            False,  # Module transaction
            False,  # Multisig transaction
        ]
        for transfer_not_empty, transaction in zip(
            transfers_not_empty, response.data["results"]
        ):
            self.assertEqual(bool(transaction["transfers"]), transfer_not_empty)
            self.assertTrue(transaction["tx_type"])

        # Test pagination
        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?limit=3&queued=False&trusted=False"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 6)
        self.assertEqual(len(response.data["results"]), 3)

        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?limit=4&offset=4&queued=False&trusted=False"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 6)
        self.assertEqual(len(response.data["results"]), 2)

        # Add transfer out for the module transaction and transfer in for the multisig transaction
        erc20_transfer_out = ERC20TransferFactory(
            _from=safe_address, ethereum_tx=module_transaction.internal_tx.ethereum_tx
        )
        # Add token info for that transfer
        token = TokenFactory(address=erc20_transfer_out.address)
        internal_tx_in = InternalTxFactory(
            to=safe_address, value=8, ethereum_tx=multisig_transaction.ethereum_tx
        )
        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=False&trusted=False"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 6)
        self.assertEqual(len(response.data["results"]), 6)
        self.assertEqual(
            response.data["results"][4]["transfers"][0]["token_info"],
            {
                "type": "ERC20",
                "address": token.address,
                "name": token.name,
                "symbol": token.symbol,
                "decimals": token.decimals,
                "logo_uri": token.get_full_logo_uri(),
            },
        )
        transfers_not_empty = [
            False,  # Multisig transaction, no transfer
            True,  # Erc transfer out
            True,  # Erc transfer in
            True,  # internal tx in
            True,  # Module transaction
            True,  # Multisig transaction
        ]
        for transfer_not_empty, transaction in zip(
            transfers_not_empty, response.data["results"]
        ):
            self.assertEqual(bool(transaction["transfers"]), transfer_not_empty)

    def test_all_transactions_executed(self):
        safe_address = Account.create().address

        # No mined
        MultisigTransactionFactory(safe=safe_address, ethereum_tx=None)
        MultisigTransactionFactory(safe=safe_address, ethereum_tx=None)
        # Mine tx with higher nonce, all should appear
        MultisigTransactionFactory(safe=safe_address)

        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?executed=False&queued=True&trusted=False"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 3)

        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?executed=True&queued=True&trusted=False"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)

    def test_all_transactions_wrong_transfer_type_view(self):
        # No token in database, so we must trust the event
        safe_address = Account.create().address
        erc20_transfer_out = ERC20TransferFactory(
            _from=safe_address
        )  # ERC20 event (with `value`)
        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=False&trusted=True"
        )
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(
            response.data["results"][0]["transfers"][0]["type"],
            TransferType.ERC20_TRANSFER.name,
        )
        self.assertIsNone(response.data["results"][0]["transfers"][0]["token_id"])
        self.assertIsNotNone(response.data["results"][0]["transfers"][0]["value"])

        # Result should be the same, as we are adding an ERC20 token
        token = TokenFactory(address=erc20_transfer_out.address, decimals=18)
        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=False&trusted=True"
        )
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(
            response.data["results"][0]["transfers"][0]["type"],
            TransferType.ERC20_TRANSFER.name,
        )
        self.assertIsNone(response.data["results"][0]["transfers"][0]["token_id"])
        self.assertIsNotNone(response.data["results"][0]["transfers"][0]["value"])

        # Result should change if we set the token as an ERC721
        token.decimals = None
        token.save(update_fields=["decimals"])
        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=False&trusted=True"
        )
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(
            response.data["results"][0]["transfers"][0]["type"],
            TransferType.ERC721_TRANSFER.name,
        )
        # TokenId and Value must be swapped now
        self.assertIsNone(response.data["results"][0]["transfers"][0]["value"])
        self.assertIsNotNone(response.data["results"][0]["transfers"][0]["token_id"])

        # It should work with value=0
        safe_address = Account.create().address
        erc20_transfer_out = ERC20TransferFactory(
            _from=safe_address, value=0
        )  # ERC20 event (with `value`)
        token = TokenFactory(address=erc20_transfer_out.address, decimals=18)
        response = self.client.get(
            reverse("v1:history:all-transactions", args=(safe_address,))
            + "?queued=False&trusted=True"
        )
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(
            response.data["results"][0]["transfers"][0]["type"],
            TransferType.ERC20_TRANSFER.name,
        )
        self.assertIsNone(response.data["results"][0]["transfers"][0]["token_id"])
        self.assertEqual(response.data["results"][0]["transfers"][0]["value"], "0")

    def test_get_module_transactions(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:module-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        module_transaction = ModuleTransactionFactory(safe=safe_address)
        response = self.client.get(
            reverse("v1:history:module-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(response.data["results"][0]["safe"], module_transaction.safe)
        self.assertEqual(
            response.data["results"][0]["module"], module_transaction.module
        )
        self.assertEqual(
            response.data["results"][0]["is_successful"], not module_transaction.failed
        )

        # Add another ModuleTransaction to check filters
        ModuleTransactionFactory(safe=safe_address)

        url = (
            reverse("v1:history:module-transactions", args=(safe_address,))
            + f"?transaction_hash={module_transaction.internal_tx.ethereum_tx_id}"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)

        url = (
            reverse("v1:history:module-transactions", args=(safe_address,))
            + "?transaction_hash=0x2345"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        url = (
            reverse("v1:history:module-transactions", args=(safe_address,))
            + f"?block_number={module_transaction.internal_tx.ethereum_tx.block_id}"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)

    def test_get_multisig_confirmation(self):
        random_safe_tx_hash = Web3.keccak(text="enxebre").hex()
        response = self.client.get(
            reverse(
                "v1:history:multisig-transaction-confirmations",
                args=(random_safe_tx_hash,),
            ),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        multisig_confirmation_1 = MultisigConfirmationFactory()
        MultisigConfirmationFactory(
            multisig_transaction=multisig_confirmation_1.multisig_transaction
        )
        safe_tx_hash = multisig_confirmation_1.multisig_transaction_id
        response = self.client.get(
            reverse(
                "v1:history:multisig-transaction-confirmations", args=(safe_tx_hash,)
            ),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 2)

    def test_post_multisig_confirmation(self):
        random_safe_tx_hash = Web3.keccak(text="enxebre").hex()
        data = {
            "signature": Account.create()
            .signHash(random_safe_tx_hash)["signature"]
            .hex()  # Not valid signature
        }
        response = self.client.post(
            reverse(
                "v1:history:multisig-transaction-confirmations",
                args=(random_safe_tx_hash,),
            ),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertIn("was not found", response.data["detail"])

        owner_account_1 = Account.create()
        owner_account_2 = Account.create()
        safe = self.deploy_test_safe(
            owners=[owner_account_1.address, owner_account_2.address]
        )
        safe_address = safe.address
        multisig_transaction = MultisigTransactionFactory(
            safe=safe_address, trusted=False
        )
        safe_tx_hash = multisig_transaction.safe_tx_hash
        response = self.client.post(
            reverse(
                "v1:history:multisig-transaction-confirmations", args=(safe_tx_hash,)
            ),
            format="json",
            data={},
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        random_account = Account.create()
        data = {
            "signature": random_account.signHash(safe_tx_hash)[
                "signature"
            ].hex()  # Not valid signature
        }
        # Transaction was executed, confirmations cannot be added
        response = self.client.post(
            reverse(
                "v1:history:multisig-transaction-confirmations", args=(safe_tx_hash,)
            ),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn(
            f"Transaction with safe-tx-hash={safe_tx_hash} was already executed",
            response.data["signature"][0],
        )

        # Mark transaction as not executed, signature is still not valid
        multisig_transaction.ethereum_tx = None
        multisig_transaction.save(update_fields=["ethereum_tx"])
        response = self.client.post(
            reverse(
                "v1:history:multisig-transaction-confirmations", args=(safe_tx_hash,)
            ),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn(
            f"Signer={random_account.address} is not an owner",
            response.data["signature"][0],
        )

        data = {"signature": owner_account_1.signHash(safe_tx_hash)["signature"].hex()}
        self.assertEqual(MultisigConfirmation.objects.count(), 0)
        response = self.client.post(
            reverse(
                "v1:history:multisig-transaction-confirmations", args=(safe_tx_hash,)
            ),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(MultisigConfirmation.objects.count(), 1)
        modified = multisig_transaction.modified
        multisig_transaction.refresh_from_db()
        self.assertTrue(multisig_transaction.trusted)
        self.assertGreater(
            multisig_transaction.modified, modified
        )  # Modified should be updated

        # Add multiple signatures
        data = {
            "signature": (
                owner_account_1.signHash(safe_tx_hash)["signature"]
                + owner_account_2.signHash(safe_tx_hash)["signature"]
            ).hex()
        }
        self.assertEqual(MultisigConfirmation.objects.count(), 1)
        response = self.client.post(
            reverse(
                "v1:history:multisig-transaction-confirmations", args=(safe_tx_hash,)
            ),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(MultisigConfirmation.objects.count(), 2)

    def test_get_multisig_transaction(self):
        safe_tx_hash = Web3.keccak(text="gnosis").hex()
        response = self.client.get(
            reverse("v1:history:multisig-transaction", args=(safe_tx_hash,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        add_owner_with_threshold_data = HexBytes(
            "0x0d582f130000000000000000000000001b9a0da11a5cace4e7035993cbb2e4"
            "b1b3b164cf000000000000000000000000000000000000000000000000000000"
            "0000000001"
        )
        multisig_tx = MultisigTransactionFactory(data=add_owner_with_threshold_data)
        safe_tx_hash = multisig_tx.safe_tx_hash
        response = self.client.get(
            reverse("v1:history:multisig-transaction", args=(safe_tx_hash,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["confirmations"]), 0)
        self.assertTrue(fast_is_checksum_address(response.data["executor"]))
        self.assertEqual(
            response.data["transaction_hash"], multisig_tx.ethereum_tx.tx_hash
        )
        self.assertEqual(response.data["origin"], multisig_tx.origin)
        self.assertFalse(response.data["trusted"])
        self.assertIsNone(response.data["max_fee_per_gas"])
        self.assertIsNone(response.data["max_priority_fee_per_gas"])
        self.assertEqual(
            response.data["data_decoded"],
            {
                "method": "addOwnerWithThreshold",
                "parameters": [
                    {
                        "name": "owner",
                        "type": "address",
                        "value": "0x1b9a0DA11a5caCE4e703599" "3Cbb2E4B1B3b164Cf",
                    },
                    {"name": "_threshold", "type": "uint256", "value": "1"},
                ],
            },
        )
        # Test camelCase
        self.assertEqual(
            response.json()["transactionHash"], multisig_tx.ethereum_tx.tx_hash
        )

    def test_get_multisig_transactions(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        multisig_tx = MultisigTransactionFactory(safe=safe_address)
        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(response.data["count_unique_nonce"], 1)
        self.assertEqual(len(response.data["results"]), 1)
        self.assertEqual(len(response.data["results"][0]["confirmations"]), 0)
        self.assertTrue(
            fast_is_checksum_address(response.data["results"][0]["executor"])
        )
        self.assertEqual(
            response.data["results"][0]["transaction_hash"],
            multisig_tx.ethereum_tx.tx_hash,
        )
        # Test camelCase
        self.assertEqual(
            response.json()["results"][0]["transactionHash"],
            multisig_tx.ethereum_tx.tx_hash,
        )
        # Check Etag header
        self.assertTrue(response["Etag"])

        MultisigConfirmationFactory(multisig_transaction=multisig_tx)
        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)
        self.assertEqual(len(response.data["results"][0]["confirmations"]), 1)

        MultisigTransactionFactory(safe=safe_address, nonce=multisig_tx.nonce)
        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 2)
        self.assertEqual(response.data["count_unique_nonce"], 1)

    @mock.patch.object(
        DbTxDecoder, "get_data_decoded", return_value={"param1": "value"}
    )
    def test_get_multisig_transactions_not_decoded(
        self, get_data_decoded_mock: MagicMock
    ):
        try:
            ContractQuerySet.cache_trusted_addresses_for_delegate_call.clear()
            multisig_transaction = MultisigTransactionFactory(
                operation=SafeOperation.CALL.value, data=b"abcd"
            )
            safe_address = multisig_transaction.safe
            response = self.client.get(
                reverse("v1:history:multisig-transactions", args=(safe_address,)),
                format="json",
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertEqual(
                response.data["results"][0]["data_decoded"], {"param1": "value"}
            )

            multisig_transaction.operation = SafeOperation.DELEGATE_CALL.value
            multisig_transaction.save()
            response = self.client.get(
                reverse("v1:history:multisig-transactions", args=(safe_address,)),
                format="json",
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertIsNone(response.data["results"][0]["data_decoded"])

            ContractQuerySet.cache_trusted_addresses_for_delegate_call.clear()
            ContractFactory(
                address=multisig_transaction.to, trusted_for_delegate_call=True
            )
            response = self.client.get(
                reverse("v1:history:multisig-transactions", args=(safe_address,)),
                format="json",
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertEqual(
                response.data["results"][0]["data_decoded"], {"param1": "value"}
            )
        finally:
            ContractQuerySet.cache_trusted_addresses_for_delegate_call.clear()

    def test_get_multisig_transactions_filters(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        multisig_transaction = MultisigTransactionFactory(
            safe=safe_address, nonce=0, ethereum_tx=None
        )
        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,))
            + "?nonce=0",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,))
            + "?to=0x2a",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(
            response.data["to"][0], "Enter a valid checksummed Ethereum Address."
        )

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,))
            + f"?to={multisig_transaction.to}",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,))
            + "?nonce=1",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,))
            + "?executed=true",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,))
            + "?executed=false",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,))
            + "?has_confirmations=True",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 0)

        MultisigConfirmationFactory(multisig_transaction=multisig_transaction)
        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,))
            + "?has_confirmations=True",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)

    def test_post_multisig_transactions_null_signature(self):
        safe_owner_1 = Account.create()
        safe = self.deploy_test_safe(owners=[safe_owner_1.address])
        safe_address = safe.address
        safe = Safe(safe_address, self.ethereum_client)

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        to = Account.create().address
        data = {
            "to": to,
            "value": 100000000000000000,
            "data": None,
            "operation": 0,
            "nonce": 0,
            "safeTxGas": 0,
            "baseGas": 0,
            "gasPrice": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            # "contractTransactionHash": "0x1c2c77b29086701ccdda7836c399112a9b715c6a153f6c8f75c84da4297f60d3",
            "sender": safe_owner_1.address,
            "signature": None,
        }
        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        data["contractTransactionHash"] = safe_tx.safe_tx_hash.hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        multisig_transaction_db = MultisigTransaction.objects.first()
        self.assertFalse(multisig_transaction_db.trusted)

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)
        self.assertIsNone(response.data["results"][0]["executor"])
        self.assertEqual(len(response.data["results"][0]["confirmations"]), 0)

    def test_post_multisig_transactions(self):
        safe_owner_1 = Account.create()
        safe = self.deploy_test_safe(owners=[safe_owner_1.address])
        safe_address = safe.address

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        to = Account.create().address
        data = {
            "to": to,
            "value": 100000000000000000,
            "data": None,
            "operation": 0,
            "nonce": 0,
            "safeTxGas": 0,
            "baseGas": 0,
            "gasPrice": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            # "contractTransactionHash": "0x1c2c77b29086701ccdda7836c399112a9b715c6a153f6c8f75c84da4297f60d3",
            "sender": safe_owner_1.address,
        }
        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        data["contractTransactionHash"] = safe_tx.safe_tx_hash.hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        multisig_transaction_db = MultisigTransaction.objects.first()
        self.assertFalse(multisig_transaction_db.trusted)

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)
        self.assertIsNone(response.data["results"][0]["executor"])
        self.assertEqual(len(response.data["results"][0]["confirmations"]), 0)

        # Test confirmation with signature
        data["signature"] = safe_owner_1.signHash(safe_tx.safe_tx_hash)[
            "signature"
        ].hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        modified = multisig_transaction_db.modified
        multisig_transaction_db.refresh_from_db()
        self.assertTrue(multisig_transaction_db.trusted)  # Now it should be trusted
        self.assertGreater(
            multisig_transaction_db.modified, modified
        )  # Modified should be updated

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data["results"]), 1)
        self.assertEqual(len(response.data["results"][0]["confirmations"]), 1)
        self.assertEqual(
            response.data["results"][0]["confirmations"][0]["signature"],
            data["signature"],
        )
        self.assertTrue(response.data["results"][0]["trusted"])

        # Sign with a different user that sender
        random_user_account = Account.create()
        data["signature"] = random_user_account.signHash(safe_tx.safe_tx_hash)[
            "signature"
        ].hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertIn(
            f"Signer={random_user_account.address} is not an owner",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        # Use random user as sender (not owner)
        del data["signature"]
        data["sender"] = random_user_account.address
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertIn(
            f"Sender={random_user_account.address} is not an owner",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

    def test_post_multisig_transaction_with_trusted_user(self):
        safe_owner_1 = Account.create()
        safe = self.deploy_test_safe(owners=[safe_owner_1.address])
        safe_address = safe.address
        data = {
            "to": Account.create().address,
            "value": 100000000000000000,
            "data": None,
            "operation": 0,
            "nonce": 0,
            "safeTxGas": 0,
            "baseGas": 0,
            "gasPrice": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            # "contractTransactionHash": "0x1c2c77b29086701ccdda7836c399112a9b715c6a153f6c8f75c84da4297f60d3",
            "sender": safe_owner_1.address,
        }
        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        data["contractTransactionHash"] = safe_tx.safe_tx_hash.hex()

        factory = APIRequestFactory()
        request = factory.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        response = SafeMultisigTransactionListView.as_view()(request, safe_address)
        response.render()
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        multisig_transaction_db = MultisigTransaction.objects.first()
        self.assertFalse(multisig_transaction_db.trusted)

        # Create user
        user = get_user_model().objects.create(
            username="batman", password="very-private"
        )
        request = factory.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        force_authenticate(request, user=user)
        response = SafeMultisigTransactionListView.as_view()(request, safe_address)
        response.render()
        multisig_transaction_db = MultisigTransaction.objects.first()
        self.assertFalse(multisig_transaction_db.trusted)

        # Assign permissions to user
        permission = Permission.objects.get(codename="create_trusted")
        user.user_permissions.add(permission)
        request = factory.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        user = get_user_model().objects.get()  # Flush permissions cache
        force_authenticate(request, user=user)
        response = SafeMultisigTransactionListView.as_view()(request, safe_address)
        response.render()
        multisig_transaction_db = MultisigTransaction.objects.first()
        self.assertTrue(multisig_transaction_db.trusted)

    def test_post_multisig_transaction_executed(self):
        safe_owner_1 = Account.create()
        safe = self.deploy_test_safe(owners=[safe_owner_1.address])
        safe_address = safe.address

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        to = Account.create().address
        data = {
            "to": to,
            "value": 100000000000000000,
            "data": None,
            "operation": 0,
            "nonce": 0,
            "safeTxGas": 0,
            "baseGas": 0,
            "gasPrice": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            # "contractTransactionHash": "0x1c2c77b29086701ccdda7836c399112a9b715c6a153f6c8f75c84da4297f60d3",
            "sender": safe_owner_1.address,
        }
        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        data["contractTransactionHash"] = safe_tx.safe_tx_hash.hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

        multisig_transaction = MultisigTransaction.objects.first()
        multisig_transaction.ethereum_tx = EthereumTxFactory()
        multisig_transaction.save(update_fields=["ethereum_tx"])
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)
        self.assertIn(
            f'Tx with safe-tx-hash={data["contractTransactionHash"]} '
            f"for safe={safe.address} was already executed in "
            f"tx-hash={multisig_transaction.ethereum_tx_id}",
            response.data["non_field_errors"],
        )

        # Check another tx with same nonce
        data["to"] = Account.create().address
        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        data["contractTransactionHash"] = safe_tx.safe_tx_hash.hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)
        self.assertIn(
            f"Tx with nonce={safe_tx.safe_nonce} for safe={safe.address} "
            f"already executed in tx-hash={multisig_transaction.ethereum_tx_id}",
            response.data["non_field_errors"],
        )

        # Successfully insert tx with nonce=1
        data["nonce"] = 1
        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        data["contractTransactionHash"] = safe_tx.safe_tx_hash.hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_post_multisig_transactions_with_origin(self):
        safe_owner_1 = Account.create()
        safe = self.deploy_test_safe(owners=[safe_owner_1.address])
        safe_address = safe.address

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        origin_max_len = 200  # Origin field limit
        to = Account.create().address
        data = {
            "to": to,
            "value": 100000000000000000,
            "data": None,
            "operation": 0,
            "nonce": 0,
            "safeTxGas": 0,
            "baseGas": 0,
            "gasPrice": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            # "contractTransactionHash": "0x1c2c77b29086701ccdda7836c399112a9b715c6a153f6c8f75c84da4297f60d3",
            "sender": safe_owner_1.address,
            "origin": "A" * (origin_max_len + 1),
        }

        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        data["contractTransactionHash"] = safe_tx.safe_tx_hash.hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)
        data["origin"] = "A" * origin_max_len
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        multisig_tx_db = MultisigTransaction.objects.get(
            safe_tx_hash=safe_tx.safe_tx_hash
        )
        self.assertEqual(multisig_tx_db.origin, data["origin"])
        data["origin"] = '{"url": "test", "name":"test"}'
        data["nonce"] = 1
        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        data["contractTransactionHash"] = safe_tx.safe_tx_hash.hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        multisig_tx_db = MultisigTransaction.objects.get(
            safe_tx_hash=safe_tx.safe_tx_hash
        )
        self.assertEqual(multisig_tx_db.origin, json.loads(data["origin"]))

    def test_post_multisig_transactions_with_multiple_signatures(self):
        safe_owners = [Account.create() for _ in range(4)]
        safe_owner_addresses = [s.address for s in safe_owners]
        safe = self.deploy_test_safe(owners=safe_owner_addresses, threshold=3)
        safe_address = safe.address

        response = self.client.get(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        to = Account.create().address
        data = {
            "to": to,
            "value": 100000000000000000,
            "data": None,
            "operation": 0,
            "nonce": 0,
            "safeTxGas": 0,
            "baseGas": 0,
            "gasPrice": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            # "contractTransactionHash": "0x1c2c77b29086701ccdda7836c399112a9b715c6a153f6c8f75c84da4297f60d3",
            "sender": safe_owners[0].address,
            "origin": "Testing origin field",
        }

        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        safe_tx_hash = safe_tx.safe_tx_hash
        data["contractTransactionHash"] = safe_tx_hash.hex()
        data["signature"] = b"".join(
            [
                safe_owner.signHash(safe_tx_hash)["signature"]
                for safe_owner in safe_owners
            ]
        ).hex()
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        multisig_tx_db = MultisigTransaction.objects.get(
            safe_tx_hash=safe_tx.safe_tx_hash
        )
        self.assertEqual(multisig_tx_db.origin, data["origin"])

        multisig_confirmations = MultisigConfirmation.objects.filter(
            multisig_transaction_hash=safe_tx_hash
        )
        self.assertEqual(len(multisig_confirmations), len(safe_owners))
        for multisig_confirmation in multisig_confirmations:
            safe_signatures = SafeSignature.parse_signature(
                multisig_confirmation.signature, safe_tx_hash
            )
            self.assertEqual(len(safe_signatures), 1)
            safe_signature = safe_signatures[0]
            self.assertEqual(safe_signature.signature_type, SafeSignatureType.EOA)
            self.assertIn(safe_signature.owner, safe_owner_addresses)
            safe_owner_addresses.remove(safe_signature.owner)

    def test_post_multisig_transactions_with_delegate(self):
        safe_owners = [Account.create() for _ in range(4)]
        safe_owner_addresses = [s.address for s in safe_owners]
        safe_delegate = Account.create()
        safe = self.deploy_test_safe(owners=safe_owner_addresses, threshold=3)
        safe_address = safe.address

        self.assertEqual(MultisigTransaction.objects.count(), 0)

        to = Account.create().address
        data = {
            "to": to,
            "value": 100000000000000000,
            "data": None,
            "operation": 0,
            "nonce": 0,
            "safeTxGas": 0,
            "baseGas": 0,
            "gasPrice": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            # "contractTransactionHash": "0x1c2c77b29086701ccdda7836c399112a9b715c6a153f6c8f75c84da4297f60d3",
            "sender": safe_owners[0].address,
            "origin": "Testing origin field",
        }

        safe_tx = safe.build_multisig_tx(
            data["to"],
            data["value"],
            data["data"],
            data["operation"],
            data["safeTxGas"],
            data["baseGas"],
            data["gasPrice"],
            data["gasToken"],
            data["refundReceiver"],
            safe_nonce=data["nonce"],
        )
        safe_tx_hash = safe_tx.safe_tx_hash
        data["contractTransactionHash"] = safe_tx_hash.hex()
        data["signature"] = safe_delegate.signHash(safe_tx_hash)["signature"].hex()

        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)
        self.assertIn(
            f"Signer={safe_delegate.address} is not an owner or delegate",
            response.data["non_field_errors"][0],
        )

        data["sender"] = safe_delegate.address
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)
        self.assertIn(
            f"Sender={safe_delegate.address} is not an owner or delegate",
            response.data["non_field_errors"][0],
        )

        # Add delegate
        SafeContractDelegateFactory(
            safe_contract__address=safe_address,
            delegate=safe_delegate.address,
            delegator=safe_owners[0].address,
        )
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(MultisigTransaction.objects.count(), 1)
        self.assertEqual(MultisigConfirmation.objects.count(), 0)
        self.assertTrue(MultisigTransaction.objects.first().trusted)

        data["signature"] = data["signature"] + data["signature"][2:]
        response = self.client.post(
            reverse("v1:history:multisig-transactions", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)
        self.assertIn(
            "Just one signature is expected if using delegates",
            response.data["non_field_errors"][0],
        )

    def test_safe_balances_view(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:safe-balances", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        SafeContractFactory(address=safe_address)
        value = 7
        self.send_ether(safe_address, 7)
        response = self.client.get(
            reverse("v1:history:safe-balances", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertIsNone(response.data[0]["token_address"])
        self.assertEqual(response.data[0]["balance"], str(value))

        tokens_value = 12
        erc20 = self.deploy_example_erc20(tokens_value, safe_address)
        response = self.client.get(
            reverse("v1:history:safe-balances", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)

        self.assertEqual(Token.objects.count(), 0)
        ERC20TransferFactory(address=erc20.address, to=safe_address)
        response = self.client.get(
            reverse("v1:history:safe-balances", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(Token.objects.count(), 1)
        self.assertCountEqual(
            response.json(),
            [
                {"tokenAddress": None, "balance": str(value), "token": None},
                {
                    "tokenAddress": erc20.address,
                    "balance": str(tokens_value),
                    "token": {
                        "name": erc20.functions.name().call(),
                        "symbol": erc20.functions.symbol().call(),
                        "decimals": erc20.functions.decimals().call(),
                        "logoUri": Token.objects.first().get_full_logo_uri(),
                    },
                },
            ],
        )

        response = self.client.get(
            reverse("v1:history:safe-balances", args=(safe_address,)) + "?trusted=True",
            format="json",
        )
        self.assertCountEqual(
            response.json(),
            [{"tokenAddress": None, "balance": str(value), "token": None}],
        )
        Token.objects.all().update(trusted=True)

        response = self.client.get(
            reverse("v1:history:safe-balances", args=(safe_address,)) + "?trusted=True",
            format="json",
        )
        self.assertCountEqual(
            response.json(),
            [
                {"tokenAddress": None, "balance": str(value), "token": None},
                {
                    "tokenAddress": erc20.address,
                    "balance": str(tokens_value),
                    "token": {
                        "name": erc20.functions.name().call(),
                        "symbol": erc20.functions.symbol().call(),
                        "decimals": erc20.functions.decimals().call(),
                        "logoUri": Token.objects.first().get_full_logo_uri(),
                    },
                },
            ],
        )

    @mock.patch.object(BalanceService, "get_token_info", autospec=True)
    @mock.patch.object(
        PriceService, "get_token_eth_value", return_value=0.4, autospec=True
    )
    @mock.patch.object(
        PriceService, "get_native_coin_usd_price", return_value=123.4, autospec=True
    )
    @mock.patch.object(timezone, "now", return_value=timezone.now())
    def test_safe_balances_usd_view(
        self,
        timezone_now_mock: MagicMock,
        get_native_coin_usd_price_mock: MagicMock,
        get_token_eth_value_mock: MagicMock,
        get_token_info_mock: MagicMock,
    ):
        timestamp_str = timezone_now_mock.return_value.isoformat().replace(
            "+00:00", "Z"
        )
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:safe-balances-usd", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        SafeContractFactory(address=safe_address)
        value = 7
        self.send_ether(safe_address, 7)
        response = self.client.get(
            reverse("v1:history:safe-balances-usd", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertIsNone(response.data[0]["token_address"])
        self.assertEqual(response.data[0]["balance"], str(value))
        self.assertEqual(response.data[0]["eth_value"], "1.0")

        tokens_value = int(12 * 1e18)
        erc20 = self.deploy_example_erc20(tokens_value, safe_address)
        response = self.client.get(
            reverse("v1:history:safe-balances-usd", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)

        erc20_info = Erc20InfoWithLogo(
            erc20.address, "UXIO", "UXI", 18, None, "http://logo_uri.es"
        )
        get_token_info_mock.return_value = erc20_info

        ERC20TransferFactory(address=erc20.address, to=safe_address)
        response = self.client.get(
            reverse("v1:history:safe-balances-usd", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        token_dict = asdict(erc20_info)
        del token_dict["address"]
        del token_dict["copy_price"]
        self.assertCountEqual(
            response.data,
            [
                {
                    "token_address": None,
                    "token": None,
                    "balance": str(value),
                    "eth_value": "1.0",
                    "timestamp": timestamp_str,
                    "fiat_balance": "0.0",
                    "fiat_conversion": "123.4",
                    "fiat_code": "USD",
                },  # 7 wei is rounded to 0.0
                {
                    "token_address": erc20.address,
                    "token": token_dict,
                    "balance": str(tokens_value),
                    "eth_value": "0.4",
                    "timestamp": timestamp_str,
                    "fiat_balance": str(round(123.4 * 0.4 * (tokens_value / 1e18), 4)),
                    "fiat_conversion": str(round(123.4 * 0.4, 4)),
                    "fiat_code": "USD",
                },
            ],
        )

    # Test without pagination
    def test_safe_collectibles(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:safe-collectibles", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        SafeContractFactory(address=safe_address)
        response = self.client.get(
            reverse("v1:history:safe-collectibles", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0)

        with mock.patch.object(
            CollectiblesService, "get_collectibles_with_metadata", autospec=True
        ) as function:
            token_name = "TokenName"
            token_symbol = "SYMBOL"
            token_address = Account.create().address
            logo_uri = f"http://token.org/{token_address}.png"
            token_id = 54
            token_uri = f"http://token.org/token-id/{token_id}"
            image = "http://token.org/token-id/1/image"
            name = "Test token name"
            description = "Test token description"
            function.return_value = [
                CollectibleWithMetadata(
                    token_name,
                    token_symbol,
                    logo_uri,
                    token_address,
                    token_id,
                    token_uri,
                    {"image": image, "name": name, "description": description},
                )
            ]
            response = self.client.get(
                reverse("v1:history:safe-collectibles", args=(safe_address,)),
                format="json",
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertEqual(
                response.data,
                [
                    {
                        "address": token_address,
                        "token_name": token_name,
                        "token_symbol": token_symbol,
                        "logo_uri": logo_uri,
                        "id": str(token_id),
                        "uri": token_uri,
                        "name": name,
                        "description": description,
                        "image_uri": image,
                        "metadata": {
                            "image": image,
                            "name": name,
                            "description": description,
                        },
                    }
                ],
            )

    def test_get_safe_delegate_list(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:safe-delegates", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        safe_contract_delegate = SafeContractDelegateFactory()
        safe_address = safe_contract_delegate.safe_contract_id
        response = self.client.get(
            reverse("v1:history:safe-delegates", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        self.assertEqual(response.data["count"], 1)
        result = response.data["results"][0]
        self.assertEqual(result["delegate"], safe_contract_delegate.delegate)
        self.assertEqual(result["delegator"], safe_contract_delegate.delegator)
        self.assertEqual(result["label"], safe_contract_delegate.label)

        safe_contract_delegate = SafeContractDelegateFactory(
            safe_contract=safe_contract_delegate.safe_contract
        )
        response = self.client.get(
            reverse("v1:history:safe-delegates", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 2)

        # A different non related Safe should not increase the number
        SafeContractDelegateFactory()
        response = self.client.get(
            reverse("v1:history:safe-delegates", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 2)

    def test_delete_safe_delegate_list(self):
        endpoint = "v1:history:safe-delegates"

        owner_account = Account.create()
        safe_address = self.deploy_test_safe(owners=[owner_account.address]).address
        safe_contract = SafeContractFactory(address=safe_address)
        response = self.client.delete(
            reverse(endpoint, args=(safe_address,)), format="json"
        )
        self.assertEqual(
            response.status_code, status.HTTP_400_BAD_REQUEST
        )  # Data is missing

        data = {
            "signature": "0x" + "1" * 130,
        }
        not_existing_safe = Account.create().address
        response = self.client.delete(
            reverse(endpoint, args=(not_existing_safe,)), format="json", data=data
        )
        self.assertIn(
            f"Safe={not_existing_safe} does not exist",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        hash_to_sign = DelegateSignatureHelper.calculate_hash(
            safe_address, eth_sign=True
        )
        data["signature"] = owner_account.signHash(hash_to_sign)["signature"].hex()
        SafeContractDelegateFactory(safe_contract=safe_contract)
        SafeContractDelegateFactory(safe_contract=safe_contract)
        SafeContractDelegateFactory(safe_contract=SafeContractFactory())
        self.assertEqual(SafeContractDelegate.objects.count(), 3)
        response = self.client.delete(
            reverse(endpoint, args=(safe_address,)), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(SafeContractDelegate.objects.count(), 1)

        # Sign random address instead of the Safe address
        hash_to_sign = DelegateSignatureHelper.calculate_hash(
            Account.create().address, eth_sign=True
        )
        data["signature"] = owner_account.signHash(hash_to_sign)["signature"].hex()
        response = self.client.delete(
            reverse(endpoint, args=(safe_address,)), format="json", data=data
        )
        self.assertIn(
            "Signing owner is not an owner of the Safe",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_post_safe_delegate(self):
        safe_address = Account.create().address
        delegate_address = Account.create().address
        label = "Saul Goodman"
        response = self.client.post(
            reverse("v1:history:safe-delegates", args=(safe_address,)), format="json"
        )
        self.assertEqual(
            response.status_code, status.HTTP_400_BAD_REQUEST
        )  # Data is missing

        data = {
            "delegate": delegate_address,
            "label": label,
            "signature": "0x" + "1" * 130,
        }

        owner_account = Account.create()
        safe_address = self.deploy_test_safe(owners=[owner_account.address]).address
        response = self.client.post(
            reverse("v1:history:safe-delegates", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertIn(
            f"Safe={safe_address} does not exist", response.data["non_field_errors"][0]
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        safe_contract = SafeContractFactory(address=safe_address)
        response = self.client.post(
            reverse("v1:history:safe-delegates", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertIn(
            "Signing owner is not an owner of the Safe",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        self.assertEqual(SafeContractDelegate.objects.count(), 0)
        hash_to_sign = DelegateSignatureHelper.calculate_hash(delegate_address)
        data["signature"] = owner_account.signHash(hash_to_sign)["signature"].hex()
        response = self.client.post(
            reverse("v1:history:safe-delegates", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(SafeContractDelegate.objects.count(), 1)
        safe_contract_delegate = SafeContractDelegate.objects.first()
        self.assertEqual(safe_contract_delegate.delegate, delegate_address)
        self.assertEqual(safe_contract_delegate.delegator, owner_account.address)
        self.assertEqual(safe_contract_delegate.label, label)

        label = "Jimmy McGill"
        data["label"] = label
        response = self.client.post(
            reverse("v1:history:safe-delegates", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(SafeContractDelegate.objects.count(), 1)
        safe_contract_delegate.refresh_from_db()
        self.assertEqual(safe_contract_delegate.label, label)

        another_label = "Kim Wexler"
        another_delegate_address = Account.create().address
        data = {
            "delegate": another_delegate_address,
            "label": another_label,
            "signature": owner_account.signHash(
                DelegateSignatureHelper.calculate_hash(
                    another_delegate_address, eth_sign=True
                )
            )["signature"].hex(),
        }
        response = self.client.post(
            reverse("v1:history:safe-delegates", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

        # Test not internal server error on contract signature
        signature = signature_to_bytes(
            0, int(owner_account.address, 16), 65
        ) + HexBytes("0" * 65)
        data["signature"] = signature.hex()
        response = self.client.post(
            reverse("v1:history:safe-delegates", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        response = self.client.get(
            reverse("v1:history:safe-delegates", args=(safe_address,)), format="json"
        )
        self.assertCountEqual(
            response.data["results"],
            [
                {
                    "delegate": delegate_address,
                    "delegator": owner_account.address,
                    "label": label,
                    "safe": safe_address,
                },
                {
                    "delegate": another_delegate_address,
                    "delegator": owner_account.address,
                    "label": another_label,
                    "safe": safe_address,
                },
            ],
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(SafeContractDelegate.objects.count(), 2)
        self.assertCountEqual(
            SafeContractDelegate.objects.get_delegates_for_safe(safe_address),
            [delegate_address, another_delegate_address],
        )

    def test_delegates_post(self):
        url = reverse("v1:history:delegates")
        safe_address = Account.create().address
        delegate = Account.create()
        delegator = Account.create()
        label = "Saul Goodman"
        data = {
            "delegate": delegate.address,
            "delegator": delegator.address,
            "label": label,
            "signature": "0x" + "1" * 130,
        }
        response = self.client.post(url, format="json", data=data)
        self.assertIn(
            "Signature does not match provided delegator",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        data["safe"] = safe_address
        response = self.client.post(url, format="json", data=data)
        self.assertIn(
            f"Safe={safe_address} does not exist", response.data["non_field_errors"][0]
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        SafeContractFactory(address=safe_address)
        with mock.patch(
            "safe_transaction_service.history.serializers.get_safe_owners",
            return_value=[Account.create().address],
        ) as get_safe_owners_mock:
            response = self.client.post(url, format="json", data=data)
            self.assertIn(
                f"Provided delegator={delegator.address} is not an owner of Safe={safe_address}",
                response.data["non_field_errors"][0],
            )
            self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

            get_safe_owners_mock.return_value = [delegator.address]
            response = self.client.post(url, format="json", data=data)
            self.assertIn(
                f"Signature does not match provided delegator={delegator.address}",
                response.data["non_field_errors"][0],
            )
            self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

            # Create delegate
            self.assertEqual(SafeContractDelegate.objects.count(), 0)
            hash_to_sign = DelegateSignatureHelper.calculate_hash(delegate.address)
            data["signature"] = delegator.signHash(hash_to_sign)["signature"].hex()
            response = self.client.post(url, format="json", data=data)
            self.assertEqual(response.status_code, status.HTTP_201_CREATED)
            safe_contract_delegate = SafeContractDelegate.objects.get()
            self.assertEqual(safe_contract_delegate.delegate, delegate.address)
            self.assertEqual(safe_contract_delegate.delegator, delegator.address)
            self.assertEqual(safe_contract_delegate.label, label)
            self.assertEqual(safe_contract_delegate.safe_contract_id, safe_address)

            # Update label
            label = "Jimmy McGill"
            data["label"] = label
            response = self.client.post(url, format="json", data=data)
            self.assertEqual(response.status_code, status.HTTP_201_CREATED)
            self.assertEqual(SafeContractDelegate.objects.count(), 1)
            safe_contract_delegate = SafeContractDelegate.objects.get()
            self.assertEqual(safe_contract_delegate.label, label)

        # Create delegate without a Safe
        another_label = "Kim Wexler"
        data = {
            "label": another_label,
            "delegate": delegate.address,
            "delegator": delegator.address,
            "safe": None,
            "signature": delegator.signHash(
                DelegateSignatureHelper.calculate_hash(delegate.address, eth_sign=True)
            )["signature"].hex(),
        }
        response = self.client.post(url, format="json", data=data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(SafeContractDelegate.objects.count(), 2)

        # Test not internal server error on contract signature
        signature = signature_to_bytes(0, int(delegator.address, 16), 65) + HexBytes(
            "0" * 65
        )
        data["signature"] = signature.hex()
        response = self.client.post(url, format="json", data=data)
        self.assertIn(
            f"Signature of type=CONTRACT_SIGNATURE for delegator={delegator.address} is not valid",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        self.assertEqual(SafeContractDelegate.objects.count(), 2)
        self.assertCountEqual(
            SafeContractDelegate.objects.get_delegates_for_safe(safe_address),
            [delegate.address],
        )

    def test_delegates_get(self):
        url = reverse("v1:history:delegates")
        response = self.client.get(url, format="json")
        self.assertEqual(response.data[0], "At least one query param must be provided")
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        delegator = Account.create().address

        # Add 2 delegates for the same Safe and delegator and another for a different Safe
        safe_contract_delegate_1 = SafeContractDelegateFactory(delegator=delegator)
        safe_contract = safe_contract_delegate_1.safe_contract
        safe_contract_delegate_2 = SafeContractDelegateFactory(
            safe_contract=safe_contract, delegator=delegator
        )
        safe_contract_delegate_3 = SafeContractDelegateFactory(
            delegate=safe_contract_delegate_1.delegate
        )

        expected = [
            {
                "delegate": safe_contract_delegate_1.delegate,
                "delegator": safe_contract_delegate_1.delegator,
                "label": safe_contract_delegate_1.label,
                "safe": safe_contract.address,
            },
            {
                "delegate": safe_contract_delegate_2.delegate,
                "delegator": safe_contract_delegate_2.delegator,
                "label": safe_contract_delegate_2.label,
                "safe": safe_contract.address,
            },
        ]
        response = self.client.get(
            url + f"?safe={safe_contract.address}", format="json"
        )
        self.assertCountEqual(response.data["results"], expected)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        response = self.client.get(url + f"?delegator={delegator}", format="json")
        self.assertCountEqual(response.data["results"], expected)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        expected = [
            {
                "delegate": safe_contract_delegate_1.delegate,
                "delegator": safe_contract_delegate_1.delegator,
                "label": safe_contract_delegate_1.label,
                "safe": safe_contract.address,
            },
            {
                "delegate": safe_contract_delegate_3.delegate,
                "delegator": safe_contract_delegate_3.delegator,
                "label": safe_contract_delegate_3.label,
                "safe": safe_contract_delegate_3.safe_contract_id,
            },
        ]
        response = self.client.get(
            url + f"?delegate={safe_contract_delegate_1.delegate}", format="json"
        )
        self.assertCountEqual(response.data["results"], expected)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_delegate_delete(self):
        url_name = "v1:history:delegate"
        delegate = Account.create()
        delegator = Account.create()
        hash_to_sign = DelegateSignatureHelper.calculate_hash(delegate.address)
        # Test delete using delegate signature and then delegator signature
        for signer in (delegate, delegator):
            with self.subTest(signer=signer):
                SafeContractDelegateFactory(
                    delegate=delegate.address, delegator=delegator.address
                )  # Expected to be deleted
                SafeContractDelegateFactory(
                    safe_contract=None,
                    delegate=delegate.address,
                    delegator=delegator.address,
                )  # Expected to be deleted
                SafeContractDelegateFactory(
                    delegate=delegate.address,  # random delegator, should not be deleted
                )
                data = {
                    "signature": signer.signHash(hash_to_sign)["signature"].hex(),
                    "delegator": delegator.address,
                }
                self.assertEqual(SafeContractDelegate.objects.count(), 3)
                response = self.client.delete(
                    reverse(url_name, args=(delegate.address,)),
                    format="json",
                    data=data,
                )
                self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
                self.assertEqual(SafeContractDelegate.objects.count(), 1)
                response = self.client.delete(
                    reverse(url_name, args=(delegate.address,)),
                    format="json",
                    data=data,
                )
                self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
                SafeContractDelegate.objects.all().delete()

        # Try an invalid signer
        SafeContractDelegateFactory(
            delegate=delegate.address, delegator=delegator.address
        )
        signer = Account.create()
        data = {
            "signature": signer.signHash(hash_to_sign)["signature"].hex(),
            "delegator": delegator.address,
        }
        self.assertEqual(SafeContractDelegate.objects.count(), 1)
        response = self.client.delete(
            reverse(url_name, args=(delegate.address,)), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn(
            "Signature does not match provided delegate",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(SafeContractDelegate.objects.count(), 1)

    def test_delete_safe_delegate(self):
        safe_address = Account.create().address
        delegate_address = Account.create().address
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
        )
        self.assertEqual(
            response.status_code, status.HTTP_400_BAD_REQUEST
        )  # Data is missing

        data = {
            "delegate": Account.create().address,
            "signature": "0x" + "1" * 130,
        }
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
            data=data,
        )
        self.assertEqual(
            {
                "code": 2,
                "message": "Delegate address in body should match the one in the url",
                "arguments": [data["delegate"], delegate_address],
            },
            response.data,
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        del data["delegate"]
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
            data=data,
        )
        self.assertIn(
            f"Safe={safe_address} does not exist", response.data["non_field_errors"][0]
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        owner_account = Account.create()
        safe_address = self.deploy_test_safe(owners=[owner_account.address]).address
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
            data=data,
        )
        self.assertIn(
            f"Safe={safe_address} does not exist", response.data["non_field_errors"][0]
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        safe_contract = SafeContractFactory(address=safe_address)
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
            data=data,
        )
        self.assertIn(
            "Signing owner is not an owner of the Safe",
            response.data["non_field_errors"][0],
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        # Test eth_sign first
        hash_to_sign = DelegateSignatureHelper.calculate_hash(
            delegate_address, eth_sign=True
        )
        data["signature"] = owner_account.signHash(hash_to_sign)["signature"].hex()
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertIn("Not found", response.data["detail"])

        # Test previous otp
        hash_to_sign = DelegateSignatureHelper.calculate_hash(
            delegate_address, previous_totp=True
        )
        data["signature"] = owner_account.signHash(hash_to_sign)["signature"].hex()
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertIn("Not found", response.data["detail"])

        hash_to_sign = DelegateSignatureHelper.calculate_hash(delegate_address)
        data["signature"] = owner_account.signHash(hash_to_sign)["signature"].hex()
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertIn("Not found", response.data["detail"])

        SafeContractDelegateFactory(
            safe_contract=safe_contract, delegate=delegate_address
        )
        SafeContractDelegateFactory(
            safe_contract=safe_contract, delegate=Account.create().address
        )
        self.assertEqual(SafeContractDelegate.objects.count(), 2)
        response = self.client.delete(
            reverse("v1:history:safe-delegate", args=(safe_address, delegate_address)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(SafeContractDelegate.objects.count(), 1)

        # Check if a delegate can delete itself
        SafeContractDelegate.objects.all().delete()
        delegate_account = Account().create()
        SafeContractDelegateFactory(
            safe_contract=safe_contract, delegate=delegate_account.address
        )
        hash_to_sign = DelegateSignatureHelper.calculate_hash(delegate_account.address)
        data["signature"] = delegate_account.signHash(hash_to_sign)["signature"].hex()
        response = self.client.delete(
            reverse(
                "v1:history:safe-delegate",
                args=(safe_address, delegate_account.address),
            ),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(SafeContractDelegate.objects.count(), 0)

    def test_incoming_transfers_view(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:incoming-transfers", args=(safe_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)
        self.assertEqual(len(response.data["results"]), 0)

        value = 2
        InternalTxFactory(to=safe_address, value=0)
        internal_tx = InternalTxFactory(to=safe_address, value=value)
        InternalTxFactory(to=Account.create().address, value=value)
        response = self.client.get(
            reverse("v1:history:incoming-transfers", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(response.data["results"][0]["value"], str(value))
        # Check Etag header
        self.assertTrue(response["Etag"])

        # Test filters
        block_number = internal_tx.ethereum_tx.block_id
        url = (
            reverse("v1:history:incoming-transfers", args=(safe_address,))
            + f"?block_number__gt={block_number}"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        # Add from tx. Result should be the same
        InternalTxFactory(_from=safe_address, value=value)
        response = self.client.get(
            reverse("v1:history:incoming-transfers", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(response.data["results"][0]["value"], str(value))

        url = (
            reverse("v1:history:incoming-transfers", args=(safe_address,))
            + f"?block_number__gt={block_number - 1}"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        token_value = 6
        ethereum_erc_20_event = ERC20TransferFactory(to=safe_address, value=token_value)
        token = TokenFactory(address=ethereum_erc_20_event.address)
        response = self.client.get(
            reverse("v1:history:incoming-transfers", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 2)
        self.assertEqual(
            response.json()["results"],
            [
                {
                    "type": TransferType.ERC20_TRANSFER.name,
                    "executionDate": ethereum_erc_20_event.ethereum_tx.block.timestamp.isoformat().replace(
                        "+00:00", "Z"
                    ),
                    "transactionHash": ethereum_erc_20_event.ethereum_tx_id,
                    "blockNumber": ethereum_erc_20_event.ethereum_tx.block_id,
                    "to": safe_address,
                    "value": str(token_value),
                    "tokenId": None,
                    "tokenAddress": ethereum_erc_20_event.address,
                    "from": ethereum_erc_20_event._from,
                    "tokenInfo": {
                        "type": "ERC20",
                        "address": token.address,
                        "name": token.name,
                        "symbol": token.symbol,
                        "decimals": token.decimals,
                        "logoUri": token.get_full_logo_uri(),
                    },
                },
                {
                    "type": TransferType.ETHER_TRANSFER.name,
                    "executionDate": internal_tx.ethereum_tx.block.timestamp.isoformat().replace(
                        "+00:00", "Z"
                    ),
                    "transactionHash": internal_tx.ethereum_tx_id,
                    "blockNumber": internal_tx.ethereum_tx.block_id,
                    "to": safe_address,
                    "value": str(value),
                    "tokenId": None,
                    "tokenAddress": None,
                    "from": internal_tx._from,
                    "tokenInfo": None,
                },
            ],
        )

        token_id = 17
        ethereum_erc_721_event = ERC721TransferFactory(
            to=safe_address, token_id=token_id
        )
        response = self.client.get(
            reverse("v1:history:incoming-transfers", args=(safe_address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 3)
        self.assertEqual(
            response.json()["results"],
            [
                {
                    "type": TransferType.ERC721_TRANSFER.name,
                    "executionDate": ethereum_erc_721_event.ethereum_tx.block.timestamp.isoformat().replace(
                        "+00:00", "Z"
                    ),
                    "transactionHash": ethereum_erc_721_event.ethereum_tx_id,
                    "blockNumber": ethereum_erc_721_event.ethereum_tx.block_id,
                    "to": safe_address,
                    "value": None,
                    "tokenId": str(token_id),
                    "tokenAddress": ethereum_erc_721_event.address,
                    "from": ethereum_erc_721_event._from,
                    "tokenInfo": None,
                },
                {
                    "type": TransferType.ERC20_TRANSFER.name,
                    "executionDate": ethereum_erc_20_event.ethereum_tx.block.timestamp.isoformat().replace(
                        "+00:00", "Z"
                    ),
                    "transactionHash": ethereum_erc_20_event.ethereum_tx_id,
                    "blockNumber": ethereum_erc_20_event.ethereum_tx.block_id,
                    "to": safe_address,
                    "value": str(token_value),
                    "tokenId": None,
                    "tokenAddress": ethereum_erc_20_event.address,
                    "from": ethereum_erc_20_event._from,
                    "tokenInfo": {
                        "type": "ERC20",
                        "address": token.address,
                        "name": token.name,
                        "symbol": token.symbol,
                        "decimals": token.decimals,
                        "logoUri": token.get_full_logo_uri(),
                    },
                },
                {
                    "type": TransferType.ETHER_TRANSFER.name,
                    "executionDate": internal_tx.ethereum_tx.block.timestamp.isoformat().replace(
                        "+00:00", "Z"
                    ),
                    "transactionHash": internal_tx.ethereum_tx_id,
                    "blockNumber": internal_tx.ethereum_tx.block_id,
                    "to": safe_address,
                    "value": str(value),
                    "tokenId": None,
                    "tokenAddress": None,
                    "from": internal_tx._from,
                    "tokenInfo": None,
                },
            ],
        )

    def test_transfers_view(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)
        self.assertEqual(len(response.data["results"]), 0)

        value = 2
        InternalTxFactory(to=safe_address, value=0)
        internal_tx = InternalTxFactory(to=safe_address, value=value)
        InternalTxFactory(to=Account.create().address, value=value)
        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(response.data["results"][0]["value"], str(value))
        # Check Etag header
        self.assertTrue(response["Etag"])

        # Test filters
        block_number = internal_tx.ethereum_tx.block_id
        url = (
            reverse("v1:history:transfers", args=(safe_address,))
            + f"?block_number__gt={block_number}"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)

        url = (
            reverse("v1:history:transfers", args=(safe_address,))
            + f"?block_number__gt={block_number - 1}"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)

        url = (
            reverse("v1:history:transfers", args=(safe_address,))
            + f"?transaction_hash={internal_tx.ethereum_tx_id}"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)

        url = (
            reverse("v1:history:transfers", args=(safe_address,))
            + "?transaction_hash=0x2345"
        )
        response = self.client.get(url, format="json")
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        # Add from tx
        internal_tx_2 = InternalTxFactory(_from=safe_address, value=value)
        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 2)
        self.assertEqual(response.data["results"][0]["value"], str(value))
        self.assertEqual(response.data["results"][1]["value"], str(value))

        token_value = 6
        ethereum_erc_20_event = ERC20TransferFactory(to=safe_address, value=token_value)
        ethereum_erc_20_event_2 = ERC20TransferFactory(
            _from=safe_address, value=token_value
        )
        token = TokenFactory(address=ethereum_erc_20_event.address)
        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 4)
        expected_results = [
            {
                "type": TransferType.ERC20_TRANSFER.name,
                "executionDate": ethereum_erc_20_event_2.ethereum_tx.block.timestamp.isoformat().replace(
                    "+00:00", "Z"
                ),
                "blockNumber": ethereum_erc_20_event_2.ethereum_tx.block_id,
                "transactionHash": ethereum_erc_20_event_2.ethereum_tx_id,
                "to": ethereum_erc_20_event_2.to,
                "value": str(token_value),
                "tokenId": None,
                "tokenAddress": ethereum_erc_20_event_2.address,
                "from": safe_address,
                "tokenInfo": None,
            },
            {
                "type": TransferType.ERC20_TRANSFER.name,
                "executionDate": ethereum_erc_20_event.ethereum_tx.block.timestamp.isoformat().replace(
                    "+00:00", "Z"
                ),
                "blockNumber": ethereum_erc_20_event.ethereum_tx.block_id,
                "transactionHash": ethereum_erc_20_event.ethereum_tx_id,
                "to": safe_address,
                "value": str(token_value),
                "tokenId": None,
                "tokenAddress": ethereum_erc_20_event.address,
                "from": ethereum_erc_20_event._from,
                "tokenInfo": {
                    "type": "ERC20",
                    "address": token.address,
                    "name": token.name,
                    "symbol": token.symbol,
                    "decimals": token.decimals,
                    "logoUri": token.get_full_logo_uri(),
                },
            },
            {
                "type": TransferType.ETHER_TRANSFER.name,
                "executionDate": internal_tx_2.ethereum_tx.block.timestamp.isoformat().replace(
                    "+00:00", "Z"
                ),
                "blockNumber": internal_tx_2.ethereum_tx.block_id,
                "transactionHash": internal_tx_2.ethereum_tx_id,
                "to": internal_tx_2.to,
                "value": str(value),
                "tokenId": None,
                "tokenAddress": None,
                "from": safe_address,
                "tokenInfo": None,
            },
            {
                "type": TransferType.ETHER_TRANSFER.name,
                "executionDate": internal_tx.ethereum_tx.block.timestamp.isoformat().replace(
                    "+00:00", "Z"
                ),
                "blockNumber": internal_tx.ethereum_tx.block_id,
                "transactionHash": internal_tx.ethereum_tx_id,
                "to": safe_address,
                "value": str(value),
                "tokenId": None,
                "tokenAddress": None,
                "from": internal_tx._from,
                "tokenInfo": None,
            },
        ]
        self.assertEqual(response.json()["results"], expected_results)

        token_id = 17
        ethereum_erc_721_event = ERC721TransferFactory(
            to=safe_address, token_id=token_id
        )
        ethereum_erc_721_event_2 = ERC721TransferFactory(
            _from=safe_address, token_id=token_id
        )
        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 6)
        expected_results = [
            {
                "type": TransferType.ERC721_TRANSFER.name,
                "executionDate": ethereum_erc_721_event_2.ethereum_tx.block.timestamp.isoformat().replace(
                    "+00:00", "Z"
                ),
                "transactionHash": ethereum_erc_721_event_2.ethereum_tx_id,
                "blockNumber": ethereum_erc_721_event_2.ethereum_tx.block_id,
                "to": ethereum_erc_721_event_2.to,
                "value": None,
                "tokenId": str(token_id),
                "tokenAddress": ethereum_erc_721_event_2.address,
                "from": safe_address,
                "tokenInfo": None,
            },
            {
                "type": TransferType.ERC721_TRANSFER.name,
                "executionDate": ethereum_erc_721_event.ethereum_tx.block.timestamp.isoformat().replace(
                    "+00:00", "Z"
                ),
                "transactionHash": ethereum_erc_721_event.ethereum_tx_id,
                "blockNumber": ethereum_erc_721_event.ethereum_tx.block_id,
                "to": safe_address,
                "value": None,
                "tokenId": str(token_id),
                "tokenAddress": ethereum_erc_721_event.address,
                "from": ethereum_erc_721_event._from,
                "tokenInfo": None,
            },
        ] + expected_results
        self.assertEqual(response.json()["results"], expected_results)

        # Test ether, erc20 and erc721 filters
        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)) + "?erc20=true",
            format="json",
        )
        self.assertGreater(len(response.data["results"]), 0)
        for result in response.data["results"]:
            self.assertEqual(result["type"], TransferType.ERC20_TRANSFER.name)

        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)) + "?erc20=false",
            format="json",
        )
        self.assertGreater(len(response.data["results"]), 0)
        for result in response.data["results"]:
            self.assertNotEqual(result["type"], TransferType.ERC20_TRANSFER.name)

        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)) + "?erc721=true",
            format="json",
        )
        self.assertGreater(len(response.data["results"]), 0)
        for result in response.data["results"]:
            self.assertEqual(result["type"], TransferType.ERC721_TRANSFER.name)

        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)) + "?erc721=false",
            format="json",
        )
        self.assertGreater(len(response.data["results"]), 0)
        for result in response.data["results"]:
            self.assertNotEqual(result["type"], TransferType.ERC721_TRANSFER.name)

        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)) + "?ether=true",
            format="json",
        )
        self.assertGreater(len(response.data["results"]), 0)
        for result in response.data["results"]:
            self.assertEqual(result["type"], TransferType.ETHER_TRANSFER.name)

        response = self.client.get(
            reverse("v1:history:transfers", args=(safe_address,)) + "?ether=false",
            format="json",
        )
        self.assertGreater(len(response.data["results"]), 0)
        for result in response.data["results"]:
            self.assertNotEqual(result["type"], TransferType.ETHER_TRANSFER.name)

    def test_safe_creation_view(self):
        invalid_address = "0x2A"
        response = self.client.get(
            reverse("v1:history:safe-creation", args=(invalid_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        owner_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:safe-creation", args=(owner_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        with mock.patch.object(
            ParityManager, "trace_transaction", autospec=True, return_value=[]
        ):
            # Insert create contract internal tx
            internal_tx = InternalTxFactory(
                contract_address=owner_address,
                trace_address="0,0",
                ethereum_tx__status=1,
            )
            response = self.client.get(
                reverse("v1:history:safe-creation", args=(owner_address,)),
                format="json",
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            created_iso = internal_tx.ethereum_tx.block.timestamp.isoformat().replace(
                "+00:00", "Z"
            )
            expected = {
                "created": created_iso,
                "creator": internal_tx.ethereum_tx._from,
                "factory_address": internal_tx._from,
                "master_copy": None,
                "setup_data": None,
                "data_decoded": None,
                "transaction_hash": internal_tx.ethereum_tx_id,
            }
            self.assertEqual(response.data, expected)

        # Next children internal_tx should not alter the result
        another_trace = dict(call_trace)
        another_trace["traceAddress"] = [0, 0, 0]
        with mock.patch.object(
            ParityManager,
            "trace_transaction",
            autospec=True,
            return_value=[another_trace],
        ):
            response = self.client.get(
                reverse("v1:history:safe-creation", args=(owner_address,)),
                format="json",
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertEqual(response.data, expected)

        another_trace_2 = dict(call_trace)
        another_trace_2["traceAddress"] = [0]
        with mock.patch.object(
            ParityManager,
            "trace_transaction",
            autospec=True,
            return_value=[another_trace, another_trace_2],
        ):
            # `another_trace_2` should change the `creator` and `master_copy` and `setup_data` should appear
            # Taken from rinkeby
            create_test_data = {
                "master_copy": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
                "setup_data": "0xa97ab18a00000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000006e45d69a383ceca3d54688e833bd0e1388747e6b00000000000000000000000061a0c717d18232711bc788f19c9cd56a43cc88720000000000000000000000007724b234c9099c205f03b458944942bceba134080000000000000000000000000000000000000000000000000000000000000000",
                "data": "0x61b69abd000000000000000000000000b6029ea3b2c51d09a50b53ca8012feeb05bda35a00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000184a97ab18a00000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000006e45d69a383ceca3d54688e833bd0e1388747e6b00000000000000000000000061a0c717d18232711bc788f19c9cd56a43cc88720000000000000000000000007724b234c9099c205f03b458944942bceba13408000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            }
            data_decoded_1 = {
                "method": "setup",
                "parameters": [
                    {
                        "name": "_owners",
                        "type": "address[]",
                        "value": [
                            "0x6E45d69a383CECa3d54688e833Bd0e1388747e6B",
                            "0x61a0c717d18232711bC788F19C9Cd56a43cc8872",
                            "0x7724b234c9099C205F03b458944942bcEBA13408",
                        ],
                    },
                    {"name": "_threshold", "type": "uint256", "value": "1"},
                    {
                        "name": "to",
                        "type": "address",
                        "value": "0x0000000000000000000000000000000000000000",
                    },
                    {"name": "data", "type": "bytes", "value": "0x"},
                    {
                        "name": "paymentToken",
                        "type": "address",
                        "value": "0x0000000000000000000000000000000000000000",
                    },
                    {"name": "payment", "type": "uint256", "value": "0"},
                    {
                        "name": "paymentReceiver",
                        "type": "address",
                        "value": "0x0000000000000000000000000000000000000000",
                    },
                ],
            }

            create_test_data_2 = {
                "master_copy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
                "setup_data": "0xb63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000180000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ac9b6dd409ff10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000085c26101f353f38e45c72d414b44972831f07be3000000000000000000000000235518798770d7336c5c4908dd1019457fea43a10000000000000000000000007f63c25665ea7e85500eaeb806e552e651b07b9d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                "data": "0x1688f0b900000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000002cecc9e861200000000000000000000000000000000000000000000000000000000000001c4b63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000180000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ac9b6dd409ff10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000085c26101f353f38e45c72d414b44972831f07be3000000000000000000000000235518798770d7336c5c4908dd1019457fea43a10000000000000000000000007f63c25665ea7e85500eaeb806e552e651b07b9d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            }
            data_decoded_2 = {
                "method": "setup",
                "parameters": [
                    {
                        "name": "_owners",
                        "type": "address[]",
                        "value": [
                            "0x85C26101f353f38E45c72d414b44972831f07BE3",
                            "0x235518798770D7336c5c4908dd1019457FEa43a1",
                            "0x7F63c25665EA7e85500eAEB806E552e651B07b9d",
                        ],
                    },
                    {"name": "_threshold", "type": "uint256", "value": "1"},
                    {
                        "name": "to",
                        "type": "address",
                        "value": "0x0000000000000000000000000000000000000000",
                    },
                    {"name": "data", "type": "bytes", "value": "0x"},
                    {
                        "name": "fallbackHandler",
                        "type": "address",
                        "value": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
                    },
                    {
                        "name": "paymentToken",
                        "type": "address",
                        "value": "0x0000000000000000000000000000000000000000",
                    },
                    {"name": "payment", "type": "uint256", "value": "3036537000337393"},
                    {
                        "name": "paymentReceiver",
                        "type": "address",
                        "value": "0x0000000000000000000000000000000000000000",
                    },
                ],
            }

            create_cpk_test_data = {
                "master_copy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
                "setup_data": "0x5714713d000000000000000000000000ff54516a7bc1c1ea952a688e72d5b93a80620074",
                "data": "0x460868ca00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5fcfe33a586323e7325be6aa6ecd8b4600d232a9037e83c8ece69413b777dabe6500000000000000000000000040a930851bd2e590bd5a5c981b436de25742e9800000000000000000000000005ef44de4b98f2bce0e29c344e7b2fb8f0282a0cf000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000245714713d000000000000000000000000ff54516a7bc1c1ea952a688e72d5b93a8062007400000000000000000000000000000000000000000000000000000000",
            }
            data_decoded_cpk = None

            for test_data, data_decoded in [
                (create_test_data, data_decoded_1),
                (create_test_data_2, data_decoded_2),
                (create_cpk_test_data, data_decoded_cpk),
            ]:
                another_trace_2["action"]["input"] = HexBytes(test_data["data"])
                response = self.client.get(
                    reverse("v1:history:safe-creation", args=(owner_address,)),
                    format="json",
                )
                self.assertEqual(response.status_code, status.HTTP_200_OK)
                created_iso = (
                    internal_tx.ethereum_tx.block.timestamp.isoformat().replace(
                        "+00:00", "Z"
                    )
                )
                self.assertEqual(
                    response.data,
                    {
                        "created": created_iso,
                        "creator": another_trace_2["action"]["from"],
                        "transaction_hash": internal_tx.ethereum_tx_id,
                        "factory_address": internal_tx._from,
                        "master_copy": test_data["master_copy"],
                        "setup_data": test_data["setup_data"],
                        "data_decoded": data_decoded,
                    },
                )

    def test_safe_info_view(self):
        invalid_address = "0x2A"
        response = self.client.get(
            reverse("v1:history:safe-info", args=(invalid_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:safe-info", args=(safe_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        SafeContractFactory(address=safe_address)
        response = self.client.get(
            reverse("v1:history:safe-info", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)
        self.assertEqual(
            response.data,
            {
                "code": 50,
                "message": "Cannot get Safe info from blockchain",
                "arguments": [safe_address],
            },
        )

        safe_last_status = SafeLastStatusFactory(address=safe_address, nonce=0)
        # For nonce=0, try to get info from blockchain
        response = self.client.get(
            reverse("v1:history:safe-info", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)
        self.assertEqual(
            response.data,
            {
                "code": 50,
                "message": "Cannot get Safe info from blockchain",
                "arguments": [safe_address],
            },
        )

        # Test blockchain Safe
        blockchain_safe = self.deploy_test_safe()
        response = self.client.get(
            reverse("v1:history:safe-info", args=(blockchain_safe.address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        SafeContractFactory(address=blockchain_safe.address)
        SafeMasterCopyFactory(
            address=blockchain_safe.retrieve_master_copy_address(), version="1.25.0"
        )
        response = self.client.get(
            reverse("v1:history:safe-info", args=(blockchain_safe.address,)),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        self.assertEqual(
            response.data,
            {
                "address": blockchain_safe.address,
                "nonce": 0,
                "threshold": blockchain_safe.retrieve_threshold(),
                "owners": blockchain_safe.retrieve_owners(),
                "master_copy": blockchain_safe.retrieve_master_copy_address(),
                "modules": [],
                "fallback_handler": blockchain_safe.retrieve_fallback_handler(),
                "guard": NULL_ADDRESS,
                "version": "1.25.0",
            },
        )

        # Uncomment if this method is used again on `SafeInfoView`
        """
        with mock.patch.object(SafeService, "get_safe_info") as get_safe_info_mock:
            safe_info_mock = SafeInfo(
                safe_address,
                Account.create().address,
                Account.create().address,
                Account.create().address,
                [Account.create().address],
                5,
                [Account.create().address, Account.create().address],
                1,
                "1.3.0",
            )
            get_safe_info_mock.return_value = safe_info_mock
            response = self.client.get(
                reverse("v1:history:safe-info", args=(safe_address,)), format="json"
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertDictEqual(
                response.data,
                {
                    "address": safe_address,
                    "nonce": safe_info_mock.nonce,
                    "threshold": safe_info_mock.threshold,
                    "owners": safe_info_mock.owners,
                    "master_copy": safe_info_mock.master_copy,
                    "modules": safe_info_mock.modules,
                    "fallback_handler": safe_info_mock.fallback_handler,
                    "guard": safe_info_mock.guard,
                    "version": "1.3.0",
                },
            )

        safe_last_status.nonce = 1
        safe_last_status.save(update_fields=["nonce"])
        response = self.client.get(
            reverse("v1:history:safe-info", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertDictEqual(
            response.data,
            {
                "address": safe_address,
                "nonce": safe_last_status.nonce,
                "threshold": safe_last_status.threshold,
                "owners": safe_last_status.owners,
                "master_copy": safe_last_status.master_copy,
                "modules": safe_last_status.enabled_modules,
                "fallback_handler": safe_last_status.fallback_handler,
                "guard": safe_last_status.guard,
                "version": None,
            },
        )

        SafeMasterCopyFactory(address=safe_last_status.master_copy, version="1.3.0")
        response = self.client.get(
            reverse("v1:history:safe-info", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertDictEqual(
            response.data,
            {
                "address": safe_address,
                "nonce": safe_last_status.nonce,
                "threshold": safe_last_status.threshold,
                "owners": safe_last_status.owners,
                "master_copy": safe_last_status.master_copy,
                "modules": safe_last_status.enabled_modules,
                "fallback_handler": safe_last_status.fallback_handler,
                "guard": NULL_ADDRESS,
                "version": "1.3.0",
            },
        )
        """
        SafeMasterCopy.objects.get_version_for_address.cache_clear()

    def test_master_copies_view(self):
        response = self.client.get(reverse("v1:history:master-copies"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data, [])

        deployed_block_number = 2
        last_indexed_block_number = 5
        safe_master_copy = SafeMasterCopyFactory(
            initial_block_number=deployed_block_number,
            tx_block_number=last_indexed_block_number,
        )
        response = self.client.get(reverse("v1:history:master-copies"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected_master_copy = [
            {
                "address": safe_master_copy.address,
                "version": safe_master_copy.version,
                "deployer": safe_master_copy.deployer,
                "deployed_block_number": deployed_block_number,
                "last_indexed_block_number": last_indexed_block_number,
                "l2": False,
            }
        ]
        self.assertCountEqual(response.data, expected_master_copy)

        safe_master_copy = SafeMasterCopyFactory(l2=True)
        response = self.client.get(reverse("v1:history:master-copies"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected_l2_master_copy = [
            {
                "address": safe_master_copy.address,
                "version": safe_master_copy.version,
                "deployer": safe_master_copy.deployer,
                "deployed_block_number": 0,
                "last_indexed_block_number": 0,
                "l2": True,
            }
        ]

        self.assertCountEqual(
            response.data, expected_master_copy + expected_l2_master_copy
        )

        with self.settings(ETH_L2_NETWORK=True):
            response = self.client.get(reverse("v1:history:master-copies"))
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertCountEqual(response.data, expected_l2_master_copy)

    def test_modules_view(self):
        invalid_address = "0x2A"
        response = self.client.get(
            reverse("v1:history:modules", args=(invalid_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        module_address = Account.create().address
        response = self.client.get(
            reverse("v1:history:modules", args=(module_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["safes"], [])

        safe_last_status = SafeLastStatusFactory(enabled_modules=[module_address])
        response = self.client.get(
            reverse("v1:history:modules", args=(module_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["safes"], [safe_last_status.address])

        safe_status_2 = SafeLastStatusFactory(enabled_modules=[module_address])
        SafeStatusFactory()  # Test that other SafeStatus don't appear
        response = self.client.get(
            reverse("v1:history:modules", args=(module_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertCountEqual(
            response.data["safes"], [safe_last_status.address, safe_status_2.address]
        )

    def test_owners_view(self):
        invalid_address = "0x2A"
        response = self.client.get(
            reverse("v1:history:owners", args=(invalid_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        owner_address = Account.create().address
        response = self.client.get(reverse("v1:history:owners", args=(owner_address,)))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["safes"], [])

        safe_last_status = SafeLastStatusFactory(owners=[owner_address])
        response = self.client.get(
            reverse("v1:history:owners", args=(owner_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["safes"], [safe_last_status.address])

        safe_status_2 = SafeLastStatusFactory(owners=[owner_address])
        SafeStatusFactory()  # Test that other SafeStatus don't appear
        response = self.client.get(
            reverse("v1:history:owners", args=(owner_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertCountEqual(
            response.data["safes"], [safe_last_status.address, safe_status_2.address]
        )

    def test_data_decoder_view(self):
        response = self.client.post(
            reverse("v1:history:data-decoder"), format="json", data={"data": "0x12"}
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        response = self.client.post(
            reverse("v1:history:data-decoder"),
            format="json",
            data={"data": "0x12121212"},
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        add_owner_with_threshold_data = HexBytes(
            "0x0d582f130000000000000000000000001b9a0da11a5cace4e7035993cbb2e4"
            "b1b3b164cf000000000000000000000000000000000000000000000000000000"
            "0000000001"
        )
        response = self.client.post(
            reverse("v1:history:data-decoder"),
            format="json",
            data={"data": add_owner_with_threshold_data.hex()},
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    @mock.patch.object(Safe, "estimate_tx_gas", return_value=52000, autospec=True)
    def test_estimate_multisig_tx_view(self, estimate_tx_gas_mock: MagicMock):
        safe_address = Account.create().address
        to = Account.create().address
        data = {
            "to": to,
            "value": 100000000000000000,
            "data": None,
            "operation": 0,
        }
        response = self.client.post(
            reverse("v1:history:multisig-transaction-estimate", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        SafeContractFactory(address=safe_address)
        response = self.client.post(
            reverse("v1:history:multisig-transaction-estimate", args=(safe_address,)),
            format="json",
            data={},
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        response = self.client.post(
            reverse("v1:history:multisig-transaction-estimate", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.data, {"safe_tx_gas": str(estimate_tx_gas_mock.return_value)}
        )

        estimate_tx_gas_mock.side_effect = CannotEstimateGas
        response = self.client.post(
            reverse("v1:history:multisig-transaction-estimate", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        estimate_tx_gas_mock.side_effect = ReadTimeout
        response = self.client.post(
            reverse("v1:history:multisig-transaction-estimate", args=(safe_address,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_503_SERVICE_UNAVAILABLE)

'''
'''--- safe_transaction_service/history/tests/test_views_v2.py ---
from django.urls import reverse

from eth_account import Account
from rest_framework import status
from rest_framework.test import APITestCase

from gnosis.eth.constants import NULL_ADDRESS
from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from .factories import ERC721TransferFactory, SafeContractFactory

class TestViewsV2(SafeTestCaseMixin, APITestCase):
    def test_safe_collectibles_paginated(self):
        safe_address = Account.create().address

        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        SafeContractFactory(address=safe_address)
        token_address = Account.create().address

        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)
        self.assertEqual(response.data["results"], [])

        # Insert ERC721 on DB
        erc721_list = [
            ERC721TransferFactory(
                address=token_address, token_id=token_id, to=safe_address
            )
            for token_id in range(1, 12)
        ]

        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,)) + "?limit=20",
            format="json",
        )

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 11)
        self.assertEqual(len(response.data["results"]), 10)  # Max limit is 10

        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=5&offset=0",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 11)
        self.assertEqual(len(response.data["results"]), 5)
        next = (
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=5&offset=5"
        )
        self.assertIn(next, response.data["next"])
        self.assertEqual(response.data["previous"], None)
        for result, erc721 in zip(response.data["results"], erc721_list[0:5]):
            self.assertEqual(result["address"], erc721.address)
            self.assertEqual(int(result["id"]), erc721.token_id)

        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=5&offset=5",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 11)
        self.assertEqual(len(response.data["results"]), 5)
        next = (
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=5&offset=10"
        )
        previous = (
            reverse("v2:history:safe-collectibles", args=(safe_address,)) + "?limit=5"
        )
        self.assertIn(next, response.data["next"])
        self.assertIn(previous, response.data["previous"])
        for result, erc721 in zip(response.data["results"], erc721_list[5:10]):
            self.assertEqual(result["address"], erc721.address)
            self.assertEqual(int(result["id"]), erc721.token_id)

        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=5&offset=10",
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 11)
        self.assertEqual(len(response.data["results"]), 1)
        previous = (
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=5&offset=5"
        )
        self.assertEqual(response.data["next"], None)
        self.assertIn(previous, response.data["previous"])
        for result, erc721 in zip(response.data["results"], erc721_list[10:]):
            self.assertEqual(result["address"], erc721.address)
            self.assertEqual(int(result["id"]), erc721.token_id)

        # Check results are sorted
        # Null address should be first, FF... address should be last
        erc721_null = ERC721TransferFactory(
            address=NULL_ADDRESS, token_id=0, to=safe_address
        )
        erc721_full = ERC721TransferFactory(
            address="0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
            token_id=5,
            to=safe_address,
        )
        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=1&offset=0",
            format="json",
        )
        self.assertEqual(response.data["results"][0]["address"], erc721_null.address)
        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=1&offset=12",
            format="json",
        )
        self.assertEqual(response.data["results"][0]["address"], erc721_full.address)

        # Check if results are sorted by address and token_id
        erc721_full_previous = ERC721TransferFactory(
            address="0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
            token_id=1,
            to=safe_address,
        )
        response = self.client.get(
            reverse("v2:history:safe-collectibles", args=(safe_address,))
            + "?limit=2&offset=12",
            format="json",
        )
        self.assertEqual(
            response.data["results"][0]["address"], erc721_full_previous.address
        )
        self.assertEqual(
            int(response.data["results"][0]["id"]), erc721_full_previous.token_id
        )
        self.assertEqual(response.data["results"][1]["address"], erc721_full.address)
        self.assertEqual(int(response.data["results"][1]["id"]), erc721_full.token_id)

'''
'''--- safe_transaction_service/history/tests/utils.py ---
import os

import pytest
import requests

def just_test_if_mainnet_node() -> str:
    mainnet_node_url = os.environ.get("ETHEREUM_MAINNET_NODE")
    if hasattr(just_test_if_mainnet_node, "checked"):  # Just check node first time
        return mainnet_node_url

    if not mainnet_node_url:
        pytest.skip(
            "Mainnet node not defined, cannot test oracles", allow_module_level=True
        )
    else:
        try:
            if not requests.post(
                mainnet_node_url,
                timeout=5,
                json={
                    "jsonrpc": "2.0",
                    "method": "eth_blockNumber",
                    "params": [],
                    "id": 1,
                },
            ).ok:
                pytest.skip("Cannot connect to mainnet node", allow_module_level=True)
        except IOError:
            pytest.skip(
                "Problem connecting to the mainnet node", allow_module_level=True
            )
    just_test_if_mainnet_node.checked = True
    return mainnet_node_url

'''
'''--- safe_transaction_service/history/urls.py ---
from django.urls import path

from . import views

app_name = "history"

urlpatterns = [
    path("about/", views.AboutView.as_view(), name="about"),
    path(
        "about/ethereum-rpc/",
        views.AboutEthereumRPCView.as_view(),
        name="about-ethereum-rpc",
    ),
    path(
        "about/ethereum-tracing-rpc/",
        views.AboutEthereumTracingRPCView.as_view(),
        name="about-ethereum-tracing-rpc",
    ),
    path(
        "about/master-copies/", views.MasterCopiesView.as_view(), name="master-copies"
    ),
    path(
        "about/erc20-indexing/",
        views.ERC20IndexingView.as_view(),
        name="erc20-indexing",
    ),
    path(
        "about/indexing/",
        views.IndexingView.as_view(),
        name="indexing",
    ),
    path("data-decoder/", views.DataDecoderView.as_view(), name="data-decoder"),
    path("delegates/", views.DelegateListView.as_view(), name="delegates"),
    path(
        "delegates/<str:delegate_address>/",
        views.DelegateDeleteView.as_view(),
        name="delegate",
    ),
    path("safes/<str:address>/", views.SafeInfoView.as_view(), name="safe-info"),
    path(
        "safes/<str:address>/transactions/",
        views.SafeMultisigTransactionDeprecatedListView.as_view(),
        name="multisig-transactions-alias",
    ),
    path(
        "safes/<str:address>/multisig-transactions/",
        views.SafeMultisigTransactionListView.as_view(),
        name="multisig-transactions",
    ),
    path(
        "safes/<str:address>/multisig-transactions/estimations/",
        views.SafeMultisigTransactionEstimateView.as_view(),
        name="multisig-transaction-estimate",
    ),
    path(
        "safes/<str:address>/all-transactions/",
        views.AllTransactionsListView.as_view(),
        name="all-transactions",
    ),
    path(
        "safes/<str:address>/incoming-transfers/",
        views.SafeIncomingTransferListView.as_view(),
        name="incoming-transfers",
    ),
    path(
        "safes/<str:address>/transfers/",
        views.SafeTransferListView.as_view(),
        name="transfers",
    ),
    path(
        "safes/<str:address>/module-transactions/",
        views.SafeModuleTransactionListView.as_view(),
        name="module-transactions",
    ),
    path(
        "safes/<str:address>/creation/",
        views.SafeCreationView.as_view(),
        name="safe-creation",
    ),
    path(
        "safes/<str:address>/balances/",
        views.SafeBalanceView.as_view(),
        name="safe-balances",
    ),
    path(
        "safes/<str:address>/balances/usd/",
        views.SafeBalanceUsdView.as_view(),
        name="safe-balances-usd",
    ),
    path(
        "safes/<str:address>/collectibles/",
        views.SafeCollectiblesView.as_view(),
        name="safe-collectibles",
    ),
    path(
        "safes/<str:address>/delegates/",
        views.SafeDelegateListView.as_view(),
        name="safe-delegates",
    ),
    path(
        "safes/<str:address>/delegates/<str:delegate_address>/",
        views.SafeDelegateDestroyView.as_view(),
        name="safe-delegate",
    ),
    path(
        "multisig-transactions/<str:safe_tx_hash>/",
        views.SafeMultisigTransactionDetailView.as_view(),
        name="multisig-transaction",
    ),
    path(
        "multisig-transactions/<str:safe_tx_hash>/confirmations/",
        views.SafeMultisigConfirmationsView.as_view(),
        name="multisig-transaction-confirmations",
    ),
    path("modules/<str:address>/safes/", views.ModulesView.as_view(), name="modules"),
    path("owners/<str:address>/safes/", views.OwnersView.as_view(), name="owners"),
    path(
        "transactions/<str:safe_tx_hash>/",
        views.SafeMultisigTransactionDeprecatedDetailView.as_view(),
        name="multisig-transaction-alias",
    ),
]

'''
'''--- safe_transaction_service/history/urls_v2.py ---
from django.urls import path

from . import views_v2

app_name = "history"

urlpatterns = [
    path(
        "safes/<str:address>/collectibles/",
        views_v2.SafeCollectiblesView.as_view(),
        name="safe-collectibles",
    ),
]

'''
'''--- safe_transaction_service/history/utils.py ---
from typing import Any, Dict, Optional, Union

from django import forms
from django.core import exceptions
from django.utils.translation import gettext as _

from hexbytes import HexBytes

class HexField(forms.CharField):
    # TODO Move this to safe-eth-py
    default_error_messages = {
        "invalid": _("Enter a valid hexadecimal."),
    }

    def to_python(self, value: Union[str, bytes, memoryview]) -> HexBytes:
        if isinstance(value, bytes):
            return value
        if isinstance(value, memoryview):
            return HexBytes(bytes(value))
        if value in self.empty_values:
            return None

        value = str(value)
        if self.strip:
            try:
                value = HexBytes(value.strip())
            except (TypeError, ValueError) as exc:
                raise exceptions.ValidationError(
                    self.error_messages["invalid"],
                    code="invalid",
                ) from exc
        return value

    def prepare_value(self, value: memoryview) -> str:
        return "0x" + bytes(value).hex() if value else ""

def clean_receipt_log(receipt_log: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """
    Clean receipt log and make them JSON compliant

    :param receipt_log:
    :return:
    """
    parsed_log = {
        "address": receipt_log["address"],
        "data": receipt_log["data"],
        "topics": [topic.hex() for topic in receipt_log["topics"]],
    }
    return parsed_log

'''
'''--- safe_transaction_service/history/views.py ---
import hashlib
import logging
from typing import Any, Dict, Tuple

from django.conf import settings
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page

import django_filters
from drf_yasg import openapi
from drf_yasg.utils import swagger_auto_schema
from rest_framework import status
from rest_framework.filters import OrderingFilter
from rest_framework.generics import (
    DestroyAPIView,
    GenericAPIView,
    ListAPIView,
    ListCreateAPIView,
    RetrieveAPIView,
    get_object_or_404,
)
from rest_framework.renderers import JSONRenderer
from rest_framework.response import Response
from rest_framework.views import APIView

from gnosis.eth import EthereumClient, EthereumClientProvider
from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.utils import fast_is_checksum_address
from gnosis.safe import CannotEstimateGas

from safe_transaction_service import __version__
from safe_transaction_service.tokens.models import Token
from safe_transaction_service.utils.utils import parse_boolean_query_param

from . import filters, pagination, serializers
from .models import (
    ERC20Transfer,
    ERC721Transfer,
    InternalTx,
    ModuleTransaction,
    MultisigConfirmation,
    MultisigTransaction,
    SafeContract,
    SafeContractDelegate,
    SafeLastStatus,
    SafeMasterCopy,
    TransferDict,
)
from .serializers import get_data_decoded_from_data
from .services import (
    BalanceServiceProvider,
    IndexServiceProvider,
    SafeServiceProvider,
    TransactionServiceProvider,
)
from .services.collectibles_service import CollectiblesServiceProvider
from .services.safe_service import CannotGetSafeInfoFromBlockchain

logger = logging.getLogger(__name__)

class AboutView(APIView):
    """
    Returns information and configuration of the service
    """

    renderer_classes = (JSONRenderer,)

    @method_decorator(cache_page(60 * 60))  # 1 hour
    def get(self, request, format=None):
        content = {
            "name": "Safe Transaction Service",
            "version": __version__,
            "api_version": request.version,
            "secure": request.is_secure(),
            "host": request.get_host(),
            "headers": [x for x in request.META.keys() if "FORWARD" in x],
            "settings": {
                "AWS_CONFIGURED": settings.AWS_CONFIGURED,
                "AWS_S3_BUCKET_NAME": settings.AWS_S3_BUCKET_NAME,
                "AWS_S3_PUBLIC_URL": settings.AWS_S3_PUBLIC_URL,
                "ETHEREUM_NODE_URL": settings.ETHEREUM_NODE_URL,
                "ETHEREUM_TRACING_NODE_URL": settings.ETHEREUM_TRACING_NODE_URL,
                "ETH_EVENTS_BLOCK_PROCESS_LIMIT": settings.ETH_EVENTS_BLOCK_PROCESS_LIMIT,
                "ETH_EVENTS_BLOCK_PROCESS_LIMIT_MAX": settings.ETH_EVENTS_BLOCK_PROCESS_LIMIT_MAX,
                "ETH_EVENTS_QUERY_CHUNK_SIZE": settings.ETH_EVENTS_QUERY_CHUNK_SIZE,
                "ETH_EVENTS_UPDATED_BLOCK_BEHIND": settings.ETH_EVENTS_UPDATED_BLOCK_BEHIND,
                "ETH_INTERNAL_NO_FILTER": settings.ETH_INTERNAL_NO_FILTER,
                "ETH_INTERNAL_TRACE_TXS_BATCH_SIZE": settings.ETH_INTERNAL_TRACE_TXS_BATCH_SIZE,
                "ETH_INTERNAL_TXS_BLOCK_PROCESS_LIMIT": settings.ETH_INTERNAL_TXS_BLOCK_PROCESS_LIMIT,
                "ETH_L2_NETWORK": settings.ETH_L2_NETWORK,
                "ETH_REORG_BLOCKS": settings.ETH_REORG_BLOCKS,
                "NOTIFICATIONS_FIREBASE_CREDENTIALS_PATH": settings.NOTIFICATIONS_FIREBASE_CREDENTIALS_PATH,
                "SSO_ENABLED": settings.SSO_ENABLED,
                "TOKENS_LOGO_BASE_URI": settings.TOKENS_LOGO_BASE_URI,
                "TOKENS_LOGO_EXTENSION": settings.TOKENS_LOGO_EXTENSION,
            },
        }
        return Response(content)

class AboutEthereumRPCView(APIView):
    """
    Returns information about ethereum RPC the service is using
    """

    renderer_classes = (JSONRenderer,)

    def _get_info(self, ethereum_client: EthereumClient) -> Dict[str, Any]:
        try:
            client_version = ethereum_client.w3.clientVersion
        except (IOError, ValueError):
            client_version = "Error getting client version"

        try:
            syncing = ethereum_client.w3.eth.syncing
        except (IOError, ValueError):
            syncing = "Error getting syncing status"

        ethereum_network = ethereum_client.get_network()
        return {
            "version": client_version,
            "block_number": ethereum_client.current_block_number,
            "chain_id": ethereum_network.value,
            "chain": ethereum_network.name,
            "syncing": syncing,
        }

    @method_decorator(cache_page(15))  # 15 seconds
    def get(self, request, format=None):
        """
        Get information about the Ethereum RPC node used by the service
        """
        ethereum_client = EthereumClientProvider()
        return Response(self._get_info(ethereum_client))

class AboutEthereumTracingRPCView(AboutEthereumRPCView):
    @method_decorator(cache_page(15))  # 15 seconds
    def get(self, request, format=None):
        """
        Get information about the Ethereum Tracing RPC node used by the service (if any configured)
        """
        if not settings.ETHEREUM_TRACING_NODE_URL:
            return Response(status=status.HTTP_404_NOT_FOUND)
        else:
            ethereum_client = EthereumClient(settings.ETHEREUM_TRACING_NODE_URL)
            return Response(self._get_info(ethereum_client))

class ERC20IndexingView(GenericAPIView):
    serializer_class = serializers.ERC20IndexingStatusSerializer
    pagination_class = None  # Don't show limit/offset in swagger

    @method_decorator(cache_page(15))  # 15 seconds
    def get(self, request):
        """
        Get current indexing status for ERC20/721 events
        """
        index_service = IndexServiceProvider()

        serializer = self.get_serializer(index_service.get_erc20_indexing_status())
        return Response(status=status.HTTP_200_OK, data=serializer.data)

class IndexingView(GenericAPIView):
    serializer_class = serializers.IndexingStatusSerializer
    pagination_class = None  # Don't show limit/offset in swagger

    @method_decorator(cache_page(15))  # 15 seconds
    def get(self, request):
        """
        Get current indexing status for ERC20/721 events
        """
        index_service = IndexServiceProvider()

        serializer = self.get_serializer(index_service.get_indexing_status())
        return Response(status=status.HTTP_200_OK, data=serializer.data)

class MasterCopiesView(ListAPIView):
    serializer_class = serializers.MasterCopyResponseSerializer
    pagination_class = None

    def get_queryset(self):
        return SafeMasterCopy.objects.relevant()

class AllTransactionsListView(ListAPIView):
    filter_backends = (
        django_filters.rest_framework.DjangoFilterBackend,
        OrderingFilter,
    )
    ordering_fields = ["execution_date", "safe_nonce", "block", "created"]
    pagination_class = pagination.SmallPagination
    serializer_class = (
        serializers.AllTransactionsSchemaSerializer
    )  # Just for docs, not used

    _schema_executed_param = openapi.Parameter(
        "executed",
        openapi.IN_QUERY,
        type=openapi.TYPE_BOOLEAN,
        default=False,
        description="If `True` only executed transactions are returned",
    )
    _schema_queued_param = openapi.Parameter(
        "queued",
        openapi.IN_QUERY,
        type=openapi.TYPE_BOOLEAN,
        default=True,
        description="If `True` transactions with `nonce >= Safe current nonce` "
        "are also returned",
    )
    _schema_trusted_param = openapi.Parameter(
        "trusted",
        openapi.IN_QUERY,
        type=openapi.TYPE_BOOLEAN,
        default=True,
        description="If `True` just trusted transactions are shown (indexed, "
        "added by a delegate or with at least one confirmation)",
    )
    _schema_200_response = openapi.Response(
        "A list with every element with the structure of one of these transaction"
        "types",
        serializers.AllTransactionsSchemaSerializer,
    )

    def get_parameters(self) -> Tuple[bool, bool, bool]:
        """
        Parse query parameters:
        - queued: Default, True. If `queued=True` transactions with `nonce >= Safe current nonce` are also shown
        - trusted: Default, True. If `trusted=True` just trusted transactions are shown (indexed, added by a delegate
        or with at least one confirmation)
        :return: Tuple with queued, trusted
        """
        executed = parse_boolean_query_param(
            self.request.query_params.get("executed", False)
        )
        queued = parse_boolean_query_param(
            self.request.query_params.get("queued", True)
        )
        trusted = parse_boolean_query_param(
            self.request.query_params.get("trusted", True)
        )
        return executed, queued, trusted

    def list(self, request, *args, **kwargs):
        transaction_service = TransactionServiceProvider()
        safe = self.kwargs["address"]
        executed, queued, trusted = self.get_parameters()
        queryset = self.filter_queryset(
            transaction_service.get_all_tx_hashes(
                safe, executed=executed, queued=queued, trusted=trusted
            )
        )
        page = self.paginate_queryset(queryset)

        if not page:
            return self.get_paginated_response([])

        all_tx_hashes = [element["safe_tx_hash"] for element in page]
        all_txs = transaction_service.get_all_txs_from_hashes(safe, all_tx_hashes)
        all_txs_serialized = transaction_service.serialize_all_txs(all_txs)
        return self.get_paginated_response(all_txs_serialized)

    @swagger_auto_schema(
        responses={
            200: _schema_200_response,
            422: "code = 1: Checksum address validation failed",
        },
        manual_parameters=[
            _schema_executed_param,
            _schema_queued_param,
            _schema_trusted_param,
        ],
    )
    def get(self, request, *args, **kwargs):
        """
        Returns a paginated list of transactions for a Safe. The list has different structures depending on the
        transaction type:
        - Multisig Transactions for a Safe. `tx_type=MULTISIG_TRANSACTION`. If the query parameter `queued=False` is
        set only the transactions with `safe nonce < current Safe nonce` will be displayed. By default, only the
        `trusted` transactions will be displayed (transactions indexed, with at least one confirmation or proposed
        by a delegate). If you need that behaviour to be disabled set the query parameter `trusted=False`
        - Module Transactions for a Safe. `tx_type=MODULE_TRANSACTION`
        - Incoming Transfers of Ether/ERC20 Tokens/ERC721 Tokens. `tx_type=ETHEREUM_TRANSACTION`
        Ordering_fields: ["execution_date", "safe_nonce", "block", "created"] eg: `created` or `-created`
        """
        address = kwargs["address"]
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        response = super().get(request, *args, **kwargs)
        response.setdefault(
            "ETag",
            "W/" + hashlib.md5(str(response.data["results"]).encode()).hexdigest(),
        )
        return response

class SafeModuleTransactionListView(ListAPIView):
    filter_backends = (
        django_filters.rest_framework.DjangoFilterBackend,
        OrderingFilter,
    )
    filterset_class = filters.ModuleTransactionFilter
    ordering_fields = ["created"]
    pagination_class = pagination.DefaultPagination
    serializer_class = serializers.SafeModuleTransactionResponseSerializer

    def get_queryset(self):
        return (
            ModuleTransaction.objects.filter(safe=self.kwargs["address"])
            .select_related("internal_tx__ethereum_tx__block")
            .order_by("-created")
        )

    @swagger_auto_schema(
        responses={400: "Invalid data", 422: "Invalid ethereum address"}
    )
    def get(self, request, address, format=None):
        """
        Returns the module transaction of a Safe
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        return super().get(request, address)

class SafeMultisigConfirmationsView(ListCreateAPIView):
    pagination_class = pagination.DefaultPagination

    def get_queryset(self):
        return MultisigConfirmation.objects.filter(
            multisig_transaction_id=self.kwargs["safe_tx_hash"]
        )

    def get_serializer_context(self):
        context = super().get_serializer_context()
        context["safe_tx_hash"] = self.kwargs.get("safe_tx_hash")
        return context

    def get_serializer_class(self):
        if self.request.method == "GET":
            return serializers.SafeMultisigConfirmationResponseSerializer
        elif self.request.method == "POST":
            return serializers.SafeMultisigConfirmationSerializer

    @swagger_auto_schema(responses={400: "Invalid data"})
    def get(self, request, *args, **kwargs):
        """
        Get the list of confirmations for a multisig transaction
        """
        return super().get(request, *args, **kwargs)

    @swagger_auto_schema(
        responses={201: "Created", 400: "Malformed data", 422: "Error processing data"}
    )
    def post(self, request, *args, **kwargs):
        """
        Add a confirmation for a transaction. More than one signature can be used. This endpoint does not support
        the use of delegates to make a transaction trusted.
        """
        return super().post(request, *args, **kwargs)

class SafeMultisigTransactionDetailView(RetrieveAPIView):
    serializer_class = serializers.SafeMultisigTransactionResponseSerializer
    lookup_field = "safe_tx_hash"
    lookup_url_kwarg = "safe_tx_hash"

    def get_queryset(self):
        return (
            MultisigTransaction.objects.with_confirmations_required()
            .prefetch_related("confirmations")
            .select_related("ethereum_tx__block")
        )

class SafeMultisigTransactionDeprecatedDetailView(SafeMultisigTransactionDetailView):
    @swagger_auto_schema(
        deprecated=True,
        operation_description="Use `multisig-transactions` instead of `transactions`",
        responses={200: "Ok", 404: "Not found"},
    )
    def get(self, *args, **kwargs):
        return super().get(*args, **kwargs)

class SafeMultisigTransactionListView(ListAPIView):
    filter_backends = (
        django_filters.rest_framework.DjangoFilterBackend,
        OrderingFilter,
    )
    filterset_class = filters.MultisigTransactionFilter
    ordering_fields = ["nonce", "created", "modified"]
    pagination_class = pagination.DefaultPagination

    def get_queryset(self):
        return (
            MultisigTransaction.objects.filter(safe=self.kwargs["address"])
            .with_confirmations_required()
            .prefetch_related("confirmations")
            .select_related("ethereum_tx__block")
            .order_by("-nonce", "-created")
        )

    def get_unique_nonce(self, address: str):
        return (
            MultisigTransaction.objects.filter(safe=address).distinct("nonce").count()
        )

    def get_serializer_class(self):
        """
        Proxy returning a serializer class according to the request's verb.
        """
        if self.request.method == "GET":
            return serializers.SafeMultisigTransactionResponseSerializer
        elif self.request.method == "POST":
            return serializers.SafeMultisigTransactionSerializer

    @swagger_auto_schema(
        responses={400: "Invalid data", 422: "Invalid ethereum address"}
    )
    def get(self, request, *args, **kwargs):
        """
        Returns the history of a multisig tx (safe)
        """
        address = kwargs["address"]
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        response = super().get(request, *args, **kwargs)
        response.data["count_unique_nonce"] = self.get_unique_nonce(address)
        return response

    @swagger_auto_schema(
        responses={
            201: "Created or signature updated",
            400: "Invalid data",
            422: "Invalid ethereum address/User is not an owner/Invalid safeTxHash/"
            "Invalid signature/Nonce already executed/Sender is not an owner",
        }
    )
    def post(self, request, address, format=None):
        """
        Creates a Multisig Transaction with its confirmations and retrieves all the information related.
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        request.data["safe"] = address
        serializer = self.get_serializer(data=request.data)

        if not serializer.is_valid():
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY, data=serializer.errors
            )
        else:
            serializer.save()
            return Response(status=status.HTTP_201_CREATED)

class SafeMultisigTransactionDeprecatedListView(SafeMultisigTransactionListView):
    @swagger_auto_schema(
        deprecated=True,
        operation_description="Use `multisig-transactions` instead of `transactions`",
    )
    def get(self, *args, **kwargs):
        return super().get(*args, **kwargs)

    @swagger_auto_schema(
        deprecated=True,
        operation_description="Use `multisig-transactions` instead of `transactions`",
    )
    def post(self, *args, **kwargs):
        return super().post(*args, **kwargs)

def swagger_safe_balance_schema(serializer_class, deprecated: bool = False):
    _schema_token_trusted_param = openapi.Parameter(
        "trusted",
        openapi.IN_QUERY,
        type=openapi.TYPE_BOOLEAN,
        default=False,
        description="If `True` just trusted tokens will be returned",
    )
    _schema_token_exclude_spam_param = openapi.Parameter(
        "exclude_spam",
        openapi.IN_QUERY,
        type=openapi.TYPE_BOOLEAN,
        default=False,
        description="If `True` spam tokens will not be returned",
    )
    return swagger_auto_schema(
        responses={
            200: serializer_class(many=True),
            404: "Safe not found",
            422: "Safe address checksum not valid",
        },
        manual_parameters=[
            _schema_token_trusted_param,
            _schema_token_exclude_spam_param,
        ],
        deprecated=deprecated,
    )

class SafeBalanceView(GenericAPIView):
    serializer_class = serializers.SafeBalanceResponseSerializer
    pagination_class = None  # Don't show limit/offset in swagger

    def get_parameters(self) -> Tuple[bool, bool]:
        """
        Parse query parameters:
        :return: Tuple with only_trusted, exclude_spam
        """
        only_trusted = parse_boolean_query_param(
            self.request.query_params.get("trusted", False)
        )
        exclude_spam = parse_boolean_query_param(
            self.request.query_params.get("exclude_spam", False)
        )
        return only_trusted, exclude_spam

    def get_result(self, *args, **kwargs):
        return BalanceServiceProvider().get_balances(*args, **kwargs)

    @swagger_safe_balance_schema(serializer_class)
    def get(self, request, address):
        """
        Get balance for Ether and ERC20 tokens
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )
        else:
            try:
                SafeContract.objects.get(address=address)
            except SafeContract.DoesNotExist:
                return Response(status=status.HTTP_404_NOT_FOUND)

            only_trusted, exclude_spam = self.get_parameters()
            safe_balances = self.get_result(
                address, only_trusted=only_trusted, exclude_spam=exclude_spam
            )
            serializer = self.get_serializer(safe_balances, many=True)
            return Response(status=status.HTTP_200_OK, data=serializer.data)

class SafeBalanceUsdView(SafeBalanceView):
    serializer_class = serializers.SafeBalanceUsdResponseSerializer

    def get_result(self, *args, **kwargs):
        return BalanceServiceProvider().get_usd_balances(*args, **kwargs)

    @swagger_safe_balance_schema(serializer_class)
    def get(self, *args, **kwargs):
        """
        Get balance for Ether and ERC20 tokens with USD fiat conversion
        """
        return super().get(*args, **kwargs)

class SafeCollectiblesView(SafeBalanceView):
    serializer_class = serializers.SafeCollectibleResponseSerializer

    def get_result(self, *args, **kwargs):
        return CollectiblesServiceProvider().get_collectibles_with_metadata(
            *args, **kwargs
        )

    @swagger_safe_balance_schema(serializer_class, deprecated=True)
    def get(self, *args, **kwargs):
        """
        Get collectibles (ERC721 tokens) and information about them. Limited to 50 collectibles due to
        performance issues, endpoint will be deprecated soon, please migrate to v2 endpoint.
        """
        return super().get(*args, **kwargs)

class SafeDelegateListView(ListCreateAPIView):
    pagination_class = pagination.DefaultPagination

    def get_queryset(self):
        return SafeContractDelegate.objects.filter(
            safe_contract_id=self.kwargs["address"]
        )

    def get_serializer_class(self):
        if self.request.method == "GET":
            return serializers.SafeDelegateResponseSerializer
        elif self.request.method == "POST":
            return serializers.SafeDelegateSerializer
        elif self.request.method == "DELETE":
            return serializers.SafeDelegateDeleteSerializer

    @swagger_auto_schema(
        deprecated=True,
        operation_description="Use /delegates endpoint",
        responses={400: "Invalid data", 422: "Invalid Ethereum address"},
    )
    def get(self, request, address, **kwargs):
        """
        Get the list of delegates for a Safe address
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        return super().get(request, address, **kwargs)

    @swagger_auto_schema(
        deprecated=True,
        operation_description="Use /delegates endpoint",
        responses={
            202: "Accepted",
            400: "Malformed data",
            422: "Invalid Ethereum address/Error processing data",
        },
    )
    def post(self, request, address, **kwargs):
        """
        Create a delegate for a Safe address with a custom label. Calls with same delegate but different label or
        signer will update the label or delegator if different.
        For the signature we are using TOTP with `T0=0` and `Tx=3600`. TOTP is calculated by taking the
        Unix UTC epoch time (no milliseconds) and dividing by 3600 (natural division, no decimals)
        For signature this hash need to be signed: keccak(checksummed address + str(int(current_epoch // 3600)))
        For example:
             - We want to add the delegate `0x132512f995866CcE1b0092384A6118EDaF4508Ff` and `epoch=1586779140`.
             - `TOTP = epoch // 3600 = 1586779140 // 3600 = 440771`
             - The hash to sign by a Safe owner would be `keccak("0x132512f995866CcE1b0092384A6118EDaF4508Ff440771")`
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        request.data["safe"] = address
        return super().post(request, address, **kwargs)

    @swagger_auto_schema(
        operation_id="safes_delegates_delete_all",
        deprecated=True,
        operation_description="Use /delegates endpoint",
        responses={
            204: "Deleted",
            400: "Malformed data",
            422: "Invalid Ethereum address/Error processing data",
        },
    )
    def delete(self, request, address, *args, **kwargs):
        """
        Delete all delegates for a Safe. Signature is built the same way that for adding a delegate using the Safe
        address as the delegate.

        Check `POST /delegates/`
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )
        request.data["safe"] = address
        request.data["delegate"] = address
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        SafeContractDelegate.objects.filter(safe_contract_id=address).delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

class SafeDelegateDestroyView(DestroyAPIView):
    serializer_class = serializers.SafeDelegateDeleteSerializer

    def get_object(self):
        return get_object_or_404(
            SafeContractDelegate,
            safe_contract_id=self.kwargs["address"],
            delegate=self.kwargs["delegate_address"],
        )

    @swagger_auto_schema(
        request_body=serializer_class(),
        responses={
            204: "Deleted",
            400: "Malformed data",
            404: "Delegate not found",
            422: "Invalid Ethereum address/Error processing data",
        },
    )
    def delete(self, request, address, delegate_address, *args, **kwargs):
        """
        Delete a delegate for a Safe. Signature is built the same way that for adding a delegate.
        Check `POST /delegates/`
        """
        if not fast_is_checksum_address(address) or not fast_is_checksum_address(
            delegate_address
        ):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address, delegate_address],
                },
            )

        body_delegate = request.data.get("delegate", delegate_address)
        if (
            body_delegate != delegate_address
        ):  # Check delegate in body matches the one in url
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 2,
                    "message": "Delegate address in body should match the one in the url",
                    "arguments": [body_delegate, delegate_address],
                },
            )

        request.data["safe"] = address
        request.data["delegate"] = delegate_address
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        return super().delete(request, address, delegate_address, *args, **kwargs)

class DelegateListView(ListCreateAPIView):
    filter_backends = (django_filters.rest_framework.DjangoFilterBackend,)
    filterset_class = filters.DelegateListFilter
    pagination_class = pagination.DefaultPagination
    queryset = SafeContractDelegate.objects.all()

    def get_serializer_class(self):
        if self.request.method == "GET":
            return serializers.SafeDelegateResponseSerializer
        elif self.request.method == "POST":
            return serializers.DelegateSerializer

    @swagger_auto_schema(responses={400: "Invalid data"})
    def get(self, request, **kwargs):
        """
        Get list of delegates
        """
        return super().get(request, **kwargs)

    @swagger_auto_schema(responses={202: "Accepted", 400: "Malformed data"})
    def post(self, request, **kwargs):
        """
        Create a delegate for a Safe address with a custom label. Calls with same delegate but different label or
        signer will update the label or delegator if different.
        For the signature we are using TOTP with `T0=0` and `Tx=3600`. TOTP is calculated by taking the
        Unix UTC epoch time (no milliseconds) and dividing by 3600 (natural division, no decimals)
        For signature this hash need to be signed: keccak(checksummed address + str(int(current_epoch // 3600)))
        For example:
             - We want to add the delegate `0x132512f995866CcE1b0092384A6118EDaF4508Ff` and `epoch=1586779140`.
             - `TOTP = epoch // 3600 = 1586779140 // 3600 = 440771`
             - The hash to sign by a Safe owner would be `keccak("0x132512f995866CcE1b0092384A6118EDaF4508Ff440771")`
        """
        return super().post(request, **kwargs)

class DelegateDeleteView(GenericAPIView):
    serializer_class = serializers.DelegateDeleteSerializer

    @swagger_auto_schema(
        request_body=serializer_class(),
        responses={
            204: "Deleted",
            400: "Malformed data",
            404: "Delegate not found",
            422: "Invalid Ethereum address/Error processing data",
        },
    )
    def delete(self, request, delegate_address, *args, **kwargs):
        """
        Delete every pair delegate/delegator found. Signature is built the same way as for adding a delegate,
        but in this case the signer can be either the `delegator` (owner) or the `delegate` itself.
        Check `POST /delegates/`
        """
        if not fast_is_checksum_address(delegate_address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [delegate_address],
                },
            )

        request.data["delegate"] = delegate_address
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        deleted, _ = SafeContractDelegate.objects.filter(
            delegate=serializer.validated_data["delegate"],
            delegator=serializer.validated_data["delegator"],
        ).delete()
        if deleted:
            return Response(status=status.HTTP_204_NO_CONTENT)
        else:
            return Response(status=status.HTTP_404_NOT_FOUND)

class SafeTransferListView(ListAPIView):
    filter_backends = (django_filters.rest_framework.DjangoFilterBackend,)
    filterset_class = filters.TransferListFilter
    serializer_class = serializers.TransferWithTokenInfoResponseSerializer
    pagination_class = pagination.DefaultPagination

    def add_tokens_to_transfers(self, transfers: TransferDict) -> TransferDict:
        tokens = {
            token.address: token
            for token in Token.objects.filter(
                address__in={
                    transfer["token_address"]
                    for transfer in transfers
                    if transfer["token_address"]
                }
            )
        }
        for transfer in transfers:
            transfer["token"] = tokens.get(transfer["token_address"])
        return transfers

    def get_transfers(self, address: str):
        erc20_queryset = self.filter_queryset(
            ERC20Transfer.objects.to_or_from(address).token_txs()
        )
        erc721_queryset = self.filter_queryset(
            ERC721Transfer.objects.to_or_from(address).token_txs()
        )
        ether_queryset = self.filter_queryset(
            InternalTx.objects.ether_txs_for_address(address)
        )
        return InternalTx.objects.union_ether_and_token_txs(
            erc20_queryset, erc721_queryset, ether_queryset
        )

    def get_queryset(self):
        address = self.kwargs["address"]
        return self.get_transfers(address)

    def list(self, request, *args, **kwargs):
        # Queryset must be already filtered, as we cannot filter a union
        # queryset = self.filter_queryset(self.get_queryset())

        queryset = self.get_queryset()
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(
                self.add_tokens_to_transfers(page), many=True
            )
            return self.get_paginated_response(serializer.data)
        else:
            serializer = self.get_serializer(
                self.add_tokens_to_transfers(queryset), many=True
            )
            return Response(serializer.data)

    @swagger_auto_schema(
        responses={
            200: serializers.TransferWithTokenInfoResponseSerializer(many=True),
            422: "Safe address checksum not valid",
        }
    )
    def get(self, request, address, format=None):
        """
        Returns ether/tokens transfers for a Safe
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        return super().get(request, address)

class SafeIncomingTransferListView(SafeTransferListView):
    @swagger_auto_schema(
        responses={
            200: serializers.TransferWithTokenInfoResponseSerializer(many=True),
            422: "Safe address checksum not valid",
        }
    )
    def get(self, *args, **kwargs):
        """
        Returns incoming ether/tokens transfers for a Safe
        """
        return super().get(*args, **kwargs)

    def get_transfers(self, address: str):
        erc20_queryset = self.filter_queryset(
            ERC20Transfer.objects.incoming(address).token_txs()
        )
        erc721_queryset = self.filter_queryset(
            ERC721Transfer.objects.incoming(address).token_txs()
        )
        ether_queryset = self.filter_queryset(
            InternalTx.objects.ether_incoming_txs_for_address(address)
        )
        return InternalTx.objects.union_ether_and_token_txs(
            erc20_queryset, erc721_queryset, ether_queryset
        )

class SafeCreationView(GenericAPIView):
    serializer_class = serializers.SafeCreationInfoResponseSerializer
    pagination_class = None  # Don't show limit/offset in swagger

    @swagger_auto_schema(
        responses={
            200: serializer_class(),
            404: "Safe creation not found",
            422: "Owner address checksum not valid",
            503: "Problem connecting to Ethereum network",
        }
    )
    @method_decorator(cache_page(60 * 60))  # 1 hour
    def get(self, request, address, *args, **kwargs):
        """
        Get status of the safe
        """

        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        safe_creation_info = SafeServiceProvider().get_safe_creation_info(address)
        if not safe_creation_info:
            return Response(status=status.HTTP_404_NOT_FOUND)

        serializer = self.get_serializer(safe_creation_info)
        return Response(status=status.HTTP_200_OK, data=serializer.data)

class SafeInfoView(GenericAPIView):
    serializer_class = serializers.SafeInfoResponseSerializer
    pagination_class = None  # Don't show limit/offset in swagger

    @swagger_auto_schema(
        responses={
            200: serializer_class(),
            404: "Safe not found",
            422: "code = 1: Checksum address validation failed\ncode = 50: Cannot get Safe info",
        }
    )
    def get(self, request, address, *args, **kwargs):
        """
        Get status of the safe
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        if not SafeContract.objects.filter(address=address).exists():
            return Response(status=status.HTTP_404_NOT_FOUND)

        try:
            # safe_info = SafeServiceProvider().get_safe_info(address)
            safe_info = SafeServiceProvider().get_safe_info_from_blockchain(address)
            serializer = self.get_serializer(safe_info)
            return Response(status=status.HTTP_200_OK, data=serializer.data)
        except CannotGetSafeInfoFromBlockchain:
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 50,
                    "message": "Cannot get Safe info from blockchain",
                    "arguments": [address],
                },
            )

class ModulesView(GenericAPIView):
    serializer_class = serializers.ModulesResponseSerializer
    pagination_class = None  # Don't show limit/offset in swagger

    @swagger_auto_schema(
        responses={
            200: serializers.ModulesResponseSerializer(),
            422: "Module address checksum not valid",
        }
    )
    @method_decorator(cache_page(15))  # 15 seconds
    def get(self, request, address, *args, **kwargs):
        """
        Return Safes where the module address provided is enabled
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        safes_for_module = SafeLastStatus.objects.addresses_for_module(address)
        serializer = self.get_serializer(data={"safes": safes_for_module})
        assert serializer.is_valid()
        return Response(status=status.HTTP_200_OK, data=serializer.data)

class OwnersView(GenericAPIView):
    serializer_class = serializers.OwnerResponseSerializer
    pagination_class = None  # Don't show limit/offset in swagger

    @swagger_auto_schema(
        responses={
            200: serializers.OwnerResponseSerializer(),
            422: "Owner address checksum not valid",
        }
    )
    @method_decorator(cache_page(15))  # 15 seconds
    def get(self, request, address, *args, **kwargs):
        """
        Return Safes where the address provided is an owner
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        safes_for_owner = SafeLastStatus.objects.addresses_for_owner(address)
        serializer = self.get_serializer(data={"safes": safes_for_owner})
        assert serializer.is_valid()
        return Response(status=status.HTTP_200_OK, data=serializer.data)

class DataDecoderView(GenericAPIView):
    serializer_class = serializers.DataDecoderSerializer

    @swagger_auto_schema(
        responses={
            200: "Decoded data",
            404: "Cannot find function selector to decode data",
            422: "Invalid data",
        }
    )
    def post(self, request, format=None):
        """
        Returns decoded information using tx service internal ABI information given the tx
        data as a `0x` prefixed hexadecimal string.
        If address of the receiving contract is provided decoded data will be more accurate,
        as in case of ABI collision service will know which ABI to use.
        """

        serializer = self.get_serializer(data=request.data)

        if not serializer.is_valid():
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY, data=serializer.errors
            )
        else:
            data_decoded = get_data_decoded_from_data(
                serializer.data["data"], address=serializer.data["to"]
            )
            if data_decoded:
                return Response(status=status.HTTP_200_OK, data=data_decoded)
            else:
                return Response(status=status.HTTP_404_NOT_FOUND, data=data_decoded)

class SafeMultisigTransactionEstimateView(GenericAPIView):
    serializer_class = serializers.SafeMultisigTransactionEstimateSerializer
    response_serializer = serializers.SafeMultisigTransactionEstimateResponseSerializer

    def get_serializer_context(self):
        context = super().get_serializer_context()
        if getattr(self, "swagger_fake_view", False):
            # Just for schema generation metadata
            context["safe_address"] = NULL_ADDRESS
        else:
            context["safe_address"] = self.kwargs["address"]
        return context

    @swagger_auto_schema(
        responses={
            200: response_serializer,
            400: "Data not valid",
            404: "Safe not found",
            422: "Tx not valid",
        }
    )
    def post(self, request, address, *args, **kwargs):
        """
        Estimates `safeTxGas` for a Safe Multisig Transaction.
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        if not SafeContract.objects.filter(address=address).exists():
            return Response(status=status.HTTP_404_NOT_FOUND)

        serializer = self.get_serializer(data=request.data)
        if serializer.is_valid():
            try:
                response_serializer = self.response_serializer(data=serializer.save())
                response_serializer.is_valid(raise_exception=True)
                return Response(
                    status=status.HTTP_200_OK, data=response_serializer.data
                )
            except CannotEstimateGas as exc:
                logger.warning(
                    "Cannot estimate gas for safe=%s data=%s",
                    address,
                    serializer.validated_data,
                )
                return Response(
                    status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                    data={
                        "code": 30,
                        "message": "Gas estimation failed",
                        "arguments": [str(exc)],
                    },
                )
        else:
            return Response(status=status.HTTP_400_BAD_REQUEST, data=serializer.errors)

'''
'''--- safe_transaction_service/history/views_v2.py ---
import logging

from rest_framework import status
from rest_framework.generics import GenericAPIView
from rest_framework.response import Response

from gnosis.eth.utils import fast_is_checksum_address

from safe_transaction_service.utils.utils import parse_boolean_query_param

from . import pagination, serializers
from .models import SafeContract
from .services.collectibles_service import CollectiblesServiceProvider
from .views import swagger_safe_balance_schema

logger = logging.getLogger(__name__)

class SafeCollectiblesView(GenericAPIView):
    serializer_class = serializers.SafeCollectibleResponseSerializer

    @swagger_safe_balance_schema(serializer_class)
    def get(self, request, address):
        """
        Get collectibles (ERC721 tokens) and information about them
        """
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )

        try:
            SafeContract.objects.get(address=address)
        except SafeContract.DoesNotExist:
            return Response(status=status.HTTP_404_NOT_FOUND)

        only_trusted = parse_boolean_query_param(
            self.request.query_params.get("trusted", False)
        )
        exclude_spam = parse_boolean_query_param(
            self.request.query_params.get("exclude_spam", False)
        )

        paginator = pagination.ListPagination(self.request)
        limit = paginator.limit
        offset = paginator.offset
        (
            safe_collectibles,
            count,
        ) = CollectiblesServiceProvider().get_collectibles_with_metadata_paginated(
            address, only_trusted, exclude_spam, limit, offset
        )
        paginator.set_count(count)
        serializer = self.get_serializer(safe_collectibles, many=True)
        return paginator.get_paginated_response(serializer.data)

'''
'''--- safe_transaction_service/notifications/__init__.py ---

'''
'''--- safe_transaction_service/notifications/admin.py ---
from typing import List

from django.contrib import admin

from gnosis.eth.django.admin import BinarySearchAdmin

from .models import FirebaseDevice, FirebaseDeviceOwner

@admin.register(FirebaseDevice)
class FirebaseDeviceAdmin(BinarySearchAdmin):
    list_display = (
        "uuid",
        "cloud_messaging_token",
        "device_type",
        "version",
        "safe_addresses",
    )
    list_filter = ("device_type", "version", "bundle")
    ordering = ["uuid"]
    raw_id_fields = ("safes",)
    readonly_fields = ("owners",)
    search_fields = ["uuid", "cloud_messaging_token", "=safes__address"]

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.prefetch_related("safes")

    def owners(self, obj: FirebaseDevice) -> List[str]:
        return list(obj.owners.values_list("owner", flat=True))

    def safe_addresses(self, obj: FirebaseDevice) -> List[str]:
        return list(obj.safes.values_list("address", flat=True))

@admin.register(FirebaseDeviceOwner)
class FirebaseDeviceOwnerAdmin(BinarySearchAdmin):
    list_display = ("firebase_device_id", "owner")
    ordering = ["firebase_device_id"]
    search_fields = ["firebase_device_id", "=owner"]

'''
'''--- safe_transaction_service/notifications/apps.py ---
from django.apps import AppConfig

class NotificationsConfig(AppConfig):
    name = "safe_transaction_service.notifications"
    verbose_name = "Notifications for Safe Transaction Service"

'''
'''--- safe_transaction_service/notifications/clients/__init__.py ---

'''
'''--- safe_transaction_service/notifications/clients/firebase_client.py ---
from abc import ABC, abstractmethod
from logging import getLogger
from typing import Any, Dict, List, Sequence, Tuple

from django.conf import settings

from firebase_admin import App, credentials, initialize_app, messaging
from firebase_admin.messaging import BatchResponse, SendResponse, UnregisteredError

logger = getLogger(__name__)

def get_firebase_client() -> "MessagingClient":
    """
    Don't use singleton due to gevent. Google Services is keeping the same socket opened. When creating multiple
    instances they need to have a different name, we use an incremental index for that

    :return: New instance of a configured MessagingClient
    """
    if hasattr(settings, "NOTIFICATIONS_FIREBASE_AUTH_CREDENTIALS"):
        if not hasattr(get_firebase_client, "created_count"):
            get_firebase_client.created_count = 0
        get_firebase_client.created_count += 1
        created_count = get_firebase_client.created_count
        return FirebaseClient(
            settings.NOTIFICATIONS_FIREBASE_AUTH_CREDENTIALS,
            app_name=f"[SAFE-{created_count}]",
        )
    logger.warning("Using mocked messaging client")
    return MockedClient()

class FirebaseClientPool:
    """
    Context manager to get a free FirebaseClient from the pool or create a new one and it to the pool if all the
    instances are taken. Very useful for gevent, as socket cannot be shared between multiple green threads.
    Use:
    ```
    with FirebaseClientPool() as firebase_client:
        firebase_client...
    ```
    """

    firebase_client_pool = []

    def __init__(self):
        self.instance: FirebaseClient

    def __enter__(self):
        if self.firebase_client_pool:
            # If there are elements on the pool, take them
            self.instance = self.firebase_client_pool.pop()
        else:
            # If not, get a new client
            self.instance = get_firebase_client()
        return self.instance

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.firebase_client_pool.append(self.instance)

class MessagingClient(ABC):
    @abstractmethod
    def send_message(
        self, tokens: Sequence[str], data: Dict[str, any]
    ) -> Tuple[int, int, Sequence[str]]:
        raise NotImplementedError

class FirebaseClient(MessagingClient):
    """
    Wrapper Client for Firebase Cloud Messaging Service
    """

    def __init__(self, credentials_dict: Dict[str, Any], app_name: str = "[DEFAULT]"):
        self._credentials = credentials_dict
        self._authenticate(app_name)
        self.app: App

    def _authenticate(self, app_name: str):
        self._certificate = credentials.Certificate(self._credentials)
        self.app = initialize_app(self._certificate, name=app_name)

    @property
    def auth_provider(self):
        return self._certificate

    def _build_android_config(self, title_loc_key: str = ""):
        return messaging.AndroidConfig(
            # priority='high',
            # ttl=6*60*60,  # 6 hours
            # notification=messaging.AndroidNotification(
            # title_loc_key=title_loc_key
            # )
        )

    def _build_apns_config(self, title_loc_key: str = ""):
        """
        Data for the Apple Push Notification Service
        see https://firebase.google.com/docs/reference/admin/python/firebase_admin.messaging

        :param title_loc_key:
        :return:
        """

        return messaging.APNSConfig(
            # headers={
            #    'apns-priority': '10'
            # },
            payload=messaging.APNSPayload(
                aps=messaging.Aps(
                    alert=messaging.ApsAlert(
                        # This is a localized key that iOS will search in
                        # the safe iOS app to show as a default title
                        title="New Activity",
                        body="New Activity with your Safe",
                        #    title_loc_key=title_loc_key,
                    ),
                    # Means the content of the notification will be
                    # modified by the safe app.
                    # Depending on the 'type' custom field,
                    # 'alert.title' and 'alert.body' above will be
                    # different
                    mutable_content=True,
                    badge=1,
                    sound="default",
                ),
            ),
        )

    def verify_token(self, token: str) -> bool:
        """
        Check if a token is valid on firebase for the project. Only way to do it is simulating a message send

        :param token: Firebase client token
        :return: True if valid, False otherwise
        """
        try:
            message = messaging.Message(data={}, token=token)
            messaging.send(message, dry_run=True, app=self.app)
            return True
        except UnregisteredError:
            return False

    def send_message(
        self, tokens: Sequence[str], data: Dict[str, any]
    ) -> Tuple[int, int, Sequence[str]]:
        """
        Send multicast message using firebase cloud messaging service

        :param tokens: Firebase token of recipient
        :param data: Dictionary with the notification data
        :return: Success count, failure count, invalid tokens
        """
        logger.debug("Sending data=%s with tokens=%s", data, tokens)
        message = messaging.MulticastMessage(
            android=self._build_android_config(),
            apns=self._build_apns_config(),
            data=data,
            tokens=tokens,
        )
        batch_response: BatchResponse = messaging.send_multicast(message, app=self.app)
        responses: List[SendResponse] = batch_response.responses
        # Check if there are invalid tokens
        invalid_tokens = [
            token
            for token, response in zip(tokens, responses)
            if not response.success
            and isinstance(response.exception, messaging.UnregisteredError)
        ]
        return (
            batch_response.success_count,
            batch_response.failure_count,
            invalid_tokens,
        )

class MockedClient(MessagingClient):
    @property
    def auth_provider(self):
        return None

    @property
    def app(self):
        return None

    def verify_token(self, token: str) -> bool:
        return bool(token)

    def send_message(
        self, tokens: Sequence[str], data: Dict[str, any]
    ) -> Tuple[int, int, Sequence[str]]:
        logger.warning(
            "MockedClient: Not sending message with data=%s and tokens=%s", data, tokens
        )
        return len(tokens), 0, []

'''
'''--- safe_transaction_service/notifications/migrations/0001_initial.py ---
# Generated by Django 3.0.8 on 2020-08-03 12:20
import uuid

from django.db import migrations, models

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("history", "0021_moduletransaction_failed"),
    ]

    operations = [
        migrations.CreateModel(
            name="FirebaseDevice",
            fields=[
                (
                    "uuid",
                    models.UUIDField(
                        default=uuid.uuid4,
                        editable=False,
                        primary_key=True,
                        serialize=False,
                    ),
                ),
                (
                    "cloud_messaging_token",
                    models.CharField(max_length=200, unique=True),
                ),
                ("build_number", models.PositiveIntegerField(default=0)),
                ("bundle", models.CharField(default="", max_length=100)),
                (
                    "device_type",
                    models.PositiveSmallIntegerField(
                        choices=[(0, "ANDROID"), (1, "IOS"), (2, "WEB")]
                    ),
                ),
                ("version", models.CharField(default="", max_length=50)),
                (
                    "safes",
                    models.ManyToManyField(
                        related_name="firebase_devices", to="history.SafeContract"
                    ),
                ),
            ],
            options={
                "verbose_name": "Firebase Device",
                "verbose_name_plural": "Firebase Devices",
            },
        ),
    ]

'''
'''--- safe_transaction_service/notifications/migrations/0002_auto_20200806_1534.py ---
# Generated by Django 3.0.8 on 2020-08-06 15:34

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("notifications", "0001_initial"),
    ]

    operations = [
        migrations.AlterField(
            model_name="firebasedevice",
            name="cloud_messaging_token",
            field=models.CharField(max_length=200, null=True, unique=True),
        ),
    ]

'''
'''--- safe_transaction_service/notifications/migrations/0003_firebasedeviceowner.py ---
# Generated by Django 3.1.3 on 2020-12-02 17:14

import django.db.models.deletion
from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("notifications", "0002_auto_20200806_1534"),
    ]

    operations = [
        migrations.CreateModel(
            name="FirebaseDeviceOwner",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("owner", gnosis.eth.django.models.EthereumAddressField(db_index=True)),
                (
                    "firebase_device",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="owners",
                        to="notifications.firebasedevice",
                    ),
                ),
            ],
            options={
                "verbose_name": "Firebase Device Owner",
                "verbose_name_plural": "Firebase Device Owners",
                "unique_together": {("firebase_device", "owner")},
            },
        ),
    ]

'''
'''--- safe_transaction_service/notifications/migrations/0004_alter_firebasedeviceowner_id.py ---
# Generated by Django 3.2.4 on 2021-06-07 10:07

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("notifications", "0003_firebasedeviceowner"),
    ]

    operations = [
        migrations.AlterField(
            model_name="firebasedeviceowner",
            name="id",
            field=models.BigAutoField(
                auto_created=True, primary_key=True, serialize=False, verbose_name="ID"
            ),
        ),
    ]

'''
'''--- safe_transaction_service/notifications/migrations/0005_ethereum_address_field_v2.py ---
# Generated by Django 3.2.9 on 2021-12-01 15:43

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("notifications", "0004_alter_firebasedeviceowner_id"),
    ]

    operations = [
        migrations.RunSQL(
            """
            DROP INDEX IF EXISTS
                notifications_firebasede_safecontract_id_acb5c418_like,
                notifications_firebasedeviceowner_owner_025b0ed6_like;

            ALTER TABLE "notifications_firebasedeviceowner" ALTER COLUMN "owner" TYPE bytea USING DECODE(SUBSTRING("owner", 3), 'hex');
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        migrations.AlterField(
            model_name="firebasedeviceowner",
            name="owner",
            field=gnosis.eth.django.models.EthereumAddressV2Field(db_index=True),
        ),
    ]

'''
'''--- safe_transaction_service/notifications/migrations/__init__.py ---

'''
'''--- safe_transaction_service/notifications/models.py ---
import uuid
from enum import Enum
from typing import List, Sequence

from django.db import models

from gnosis.eth.django.models import EthereumAddressV2Field

from safe_transaction_service.history.models import SafeContract

class DeviceTypeEnum(Enum):
    ANDROID = 0
    IOS = 1
    WEB = 2

class FirebaseDevice(models.Model):
    uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    safes = models.ManyToManyField(SafeContract, related_name="firebase_devices")
    cloud_messaging_token = models.CharField(
        null=True, unique=True, max_length=200
    )  # Token length should be 163
    build_number = models.PositiveIntegerField(default=0)  # e.g. 1644
    bundle = models.CharField(max_length=100, default="")
    device_type = models.PositiveSmallIntegerField(
        choices=[(tag.value, tag.name) for tag in DeviceTypeEnum]
    )
    version = models.CharField(max_length=50, default="")  # e.g 1.0.0

    class Meta:
        verbose_name = "Firebase Device"
        verbose_name_plural = "Firebase Devices"

    def __str__(self):
        token = (
            self.cloud_messaging_token[:10]
            if self.cloud_messaging_token
            else "No Token"
        )
        device_name = DeviceTypeEnum(self.device_type).name
        return f"{device_name} {self.version} - {token}..."

class FirebaseDeviceOwnerManager(models.Manager):
    def get_devices_for_safe_and_owners(
        self, safe_address, owners: Sequence[str]
    ) -> List[str]:
        """
        :param safe_address:
        :param owners:
        :return: List of cloud messaging tokens for owners (unique and not empty) linked to a Safe. If owner is not
        linked to the Safe it will not be returned.
        """
        return list(
            self.filter(firebase_device__safes__address=safe_address, owner__in=owners)
            .exclude(firebase_device__cloud_messaging_token=None)
            .values_list("firebase_device__cloud_messaging_token", flat=True)
            .distinct()
        )

class FirebaseDeviceOwner(models.Model):
    objects = FirebaseDeviceOwnerManager()
    firebase_device = models.ForeignKey(
        FirebaseDevice, on_delete=models.CASCADE, related_name="owners"
    )
    owner = EthereumAddressV2Field(db_index=True)

    class Meta:
        verbose_name = "Firebase Device Owner"
        verbose_name_plural = "Firebase Device Owners"
        unique_together = (("firebase_device", "owner"),)

    def __str__(self):
        return f"{self.owner} for device {self.firebase_device_id}"

'''
'''--- safe_transaction_service/notifications/serializers.py ---
import time
from typing import Any, Dict, Sequence, Set
from uuid import uuid4

from django.db import IntegrityError, transaction

from eth_typing import ChecksumAddress
from packaging import version as semantic_version
from rest_framework import serializers
from rest_framework.exceptions import ValidationError

from gnosis.eth.django.serializers import EthereumAddressField, HexadecimalField
from gnosis.safe.safe_signature import SafeSignature, SafeSignatureType

from safe_transaction_service.history.models import SafeContract, SafeContractDelegate
from safe_transaction_service.utils.serializers import get_safe_owners

from .models import DeviceTypeEnum, FirebaseDevice, FirebaseDeviceOwner
from .utils import calculate_device_registration_hash

class FirebaseDeviceSerializer(serializers.Serializer):
    uuid = serializers.UUIDField(default=uuid4)  # TODO Make it required
    safes = serializers.ListField(allow_empty=False, child=EthereumAddressField())
    cloud_messaging_token = serializers.CharField(min_length=100, max_length=200)
    build_number = serializers.IntegerField(min_value=0)  # e.g. 1644
    bundle = serializers.CharField(min_length=1, max_length=100)
    device_type = serializers.ChoiceField(
        choices=[element.name for element in DeviceTypeEnum]
    )
    version = serializers.CharField(min_length=1, max_length=100)  # e.g. 1.0.0-beta
    timestamp = serializers.IntegerField(required=False)  # TODO Make it required
    signatures = serializers.ListField(
        required=False,
        child=HexadecimalField(
            required=False, min_length=65, max_length=65
        ),  # Signatures must be 65 bytes
    )

    def validate_safes(
        self, safes: Sequence[ChecksumAddress]
    ) -> Sequence[ChecksumAddress]:
        if SafeContract.objects.filter(address__in=safes).count() != len(safes):
            raise serializers.ValidationError(
                "At least one Safe provided was not found or is duplicated"
            )
        return safes

    def validate_timestamp(self, timestamp: int) -> int:
        """
        Validate if timestamp is not on a range within 5 minutes
        :param timestamp:
        :return:
        """
        if timestamp is not None:
            minutes_allowed = 5
            current_epoch = int(time.time())
            time_delta = abs(current_epoch - timestamp)
            if time_delta > (60 * minutes_allowed):  # Timestamp older than 5 minutes
                raise ValidationError(
                    f"Provided timestamp is not in a range within {minutes_allowed} minutes"
                )
        return timestamp

    def validate_version(self, value: str) -> str:
        try:
            semantic_version.Version(value)
        except semantic_version.InvalidVersion:
            raise serializers.ValidationError("Semantic version was expected")
        return value

    def get_valid_owners(
        self, safe_addresses: Sequence[ChecksumAddress]
    ) -> Set[ChecksumAddress]:
        """
        Return safe owners and delegates

        :param safe_addresses:
        :return:
        """
        valid_owners = set()
        for safe_address in safe_addresses:
            owners = get_safe_owners(safe_address)
            delegates = SafeContractDelegate.objects.get_delegates_for_safe_and_owners(
                safe_address, owners
            )
            valid_owners = valid_owners.union(owners, delegates)

        return valid_owners

    def validate(self, attrs: Dict[str, Any]):
        attrs = super().validate(attrs)
        signature_owners = []
        owners_without_safe = []
        signatures = attrs.get("signatures") or []
        safe_addresses = attrs["safes"]
        if signatures:
            valid_owners = self.get_valid_owners(safe_addresses)
            for signature in signatures:
                hash_to_sign = calculate_device_registration_hash(
                    attrs["timestamp"],
                    attrs["uuid"],
                    attrs["cloud_messaging_token"],
                    attrs["safes"],
                )
                parsed_signatures = SafeSignature.parse_signature(
                    signature, hash_to_sign
                )
                if not parsed_signatures:
                    raise ValidationError("Signature cannot be parsed")
                for safe_signature in parsed_signatures:
                    if (
                        safe_signature.signature_type != SafeSignatureType.EOA
                        or not safe_signature.is_valid()
                    ):
                        raise ValidationError(
                            "An externally owned account signature was expected"
                        )
                    owner = safe_signature.owner
                    if owner in (signature_owners + owners_without_safe):
                        raise ValidationError(
                            f"Signature for owner={owner} is duplicated"
                        )

                    if owner not in valid_owners:
                        owners_without_safe.append(owner)
                        # raise ValidationError(f'Owner={owner} is not an owner of any of the safes={data["safes"]}. '
                        #                       f'Expected hash to sign {hash_to_sign.hex()}')
                    else:
                        signature_owners.append(owner)
            if len(signatures) > len(signature_owners + owners_without_safe):
                raise ValidationError(
                    "Number of signatures is less than the number of owners detected"
                )

        attrs["owners_registered"] = signature_owners
        attrs["owners_not_registered"] = owners_without_safe
        return attrs

    @transaction.atomic
    def save(self, **kwargs):
        try:
            uuid = self.validated_data["uuid"]
            firebase_device, _ = FirebaseDevice.objects.update_or_create(
                uuid=uuid,
                defaults={
                    "cloud_messaging_token": self.validated_data[
                        "cloud_messaging_token"
                    ],
                    "build_number": self.validated_data["build_number"],
                    "bundle": self.validated_data["bundle"],
                    "device_type": DeviceTypeEnum[
                        self.validated_data["device_type"]
                    ].value,
                    "version": self.validated_data["version"],
                },
            )
        except IntegrityError:
            raise serializers.ValidationError(
                "Cloud messaging token is linked to another device"
            )

        # Remove every owner registered for the device and add the provided ones
        firebase_device.owners.all().delete()
        for owner in self.validated_data["owners_registered"]:
            try:
                FirebaseDeviceOwner.objects.create(
                    firebase_device=firebase_device, owner=owner
                )
            except IntegrityError:
                raise serializers.ValidationError(
                    f"Owner {owner} already created for firebase_device"
                )

        # Remove every Safe registered for the device and add the provided ones
        firebase_device.safes.clear()
        safe_contracts = SafeContract.objects.filter(
            address__in=self.validated_data["safes"]
        )
        firebase_device.safes.add(*safe_contracts)
        return firebase_device

class FirebaseDeviceSerializerWithOwnersResponseSerializer(FirebaseDeviceSerializer):
    owners_registered = serializers.ListField(
        allow_empty=True, child=EthereumAddressField()
    )
    owners_not_registered = serializers.ListField(
        allow_empty=True, child=EthereumAddressField()
    )

'''
'''--- safe_transaction_service/notifications/tasks.py ---
import pickle
from typing import Any, Dict, Optional, Tuple

from celery import app
from celery.utils.log import get_task_logger

from safe_transaction_service.history.models import (
    MultisigConfirmation,
    MultisigTransaction,
    SafeContractDelegate,
    SafeLastStatus,
    WebHookType,
)
from safe_transaction_service.utils.ethereum import get_ethereum_network
from safe_transaction_service.utils.redis import get_redis
from safe_transaction_service.utils.utils import close_gevent_db_connection_decorator

from .clients.firebase_client import FirebaseClientPool
from .models import FirebaseDevice, FirebaseDeviceOwner

logger = get_task_logger(__name__)

class DuplicateNotification:
    def __init__(self, address: Optional[str], payload: Dict[str, Any]):
        self.redis = get_redis()
        self.address = address
        self.payload = payload
        self.redis_payload = self._get_redis_payload(address, payload)

    def _get_redis_payload(self, address: Optional[str], payload: Dict[str, Any]):
        return f"notifications:{address}:".encode() + pickle.dumps(payload)

    def is_duplicated(self) -> bool:
        """
        :return: True if payload was already notified, False otherwise
        """
        return bool(self.redis.get(self.redis_payload))

    def set_duplicated(self) -> bool:
        """
        Stores notification with an expiration time of 5 minutes
        :return:
        """
        return self.redis.set(self.redis_payload, 1, ex=5 * 60)

def filter_notification(payload: Dict[str, Any]) -> bool:
    """
    :param payload: Notification payload
    :return: `True` if payload is valid, `False` otherwise
    """
    payload_type = payload.get("type", "")
    if not payload_type:
        # Don't send notifications for empty payload (it shouldn't happen)
        return False
    elif payload_type == WebHookType.PENDING_MULTISIG_TRANSACTION.name:
        # Don't send notifications for pending multisig transactions
        return False
    elif payload_type == WebHookType.NEW_CONFIRMATION.name:
        # If MultisigTransaction is executed don't notify about a new confirmation
        # try:
        #     return not MultisigTransaction.objects.get(safe_tx_hash=payload.get('safeTxHash')).executed
        # except MultisigTransaction.DoesNotExist:
        #    pass

        # All confirmations are disabled for now
        return False
    elif payload_type in (
        WebHookType.OUTGOING_ETHER.name,
        WebHookType.OUTGOING_TOKEN.name,
    ):
        return False
    elif payload_type in (
        WebHookType.INCOMING_ETHER.name,
        WebHookType.INCOMING_TOKEN.name,
    ):
        # Only send ETH/token pushes when they weren't triggered by a tx from some account other than the Safe.
        # If Safe triggers a transaction to transfer Ether/Tokens into itself, 2 notifications will be generated, and
        # that's not desired
        return not MultisigTransaction.objects.filter(
            ethereum_tx=payload["txHash"], safe=payload["address"]
        ).exists()

    return True

def is_pending_multisig_transaction(payload: Dict[str, Any]) -> bool:
    return payload.get("type", "") == WebHookType.PENDING_MULTISIG_TRANSACTION.name

@app.shared_task()
@close_gevent_db_connection_decorator
def send_notification_task(
    address: Optional[str], payload: Dict[str, Any]
) -> Tuple[int, int]:
    """
    :param address:
    :param payload:
    :return: Tuple with the number of successful and failed notifications sent
    """
    if not (address and payload):  # Both must be present
        return 0, 0

    tokens = list(
        FirebaseDevice.objects.filter(safes__address=address)
        .exclude(cloud_messaging_token=None)
        .values_list("cloud_messaging_token", flat=True)
    )  # TODO Use cache

    if is_pending_multisig_transaction(payload):
        send_notification_owner_task.delay(address, payload["safeTxHash"])

    if not (tokens and filter_notification(payload)):
        return 0, 0

    # Make sure notification has not been sent before
    duplicate_notification = DuplicateNotification(address, payload)
    if duplicate_notification.is_duplicated():
        logger.info(
            "Duplicated notification about Safe=%s with payload=%s to tokens=%s",
            address,
            payload,
            tokens,
        )
        return 0, 0

    duplicate_notification.set_duplicated()

    with FirebaseClientPool() as firebase_client:
        logger.info(
            "Sending notification about Safe=%s with payload=%s to tokens=%s",
            address,
            payload,
            tokens,
        )
        success_count, failure_count, invalid_tokens = firebase_client.send_message(
            tokens, payload
        )
        if invalid_tokens:
            logger.info(
                "Removing invalid tokens for safe=%s. Tokens=%s",
                address,
                invalid_tokens,
            )
            FirebaseDevice.objects.filter(
                cloud_messaging_token__in=invalid_tokens
            ).update(cloud_messaging_token=None)

    return success_count, failure_count

@app.shared_task()
@close_gevent_db_connection_decorator
def send_notification_owner_task(address: str, safe_tx_hash: str) -> Tuple[int, int]:
    """
    Send a confirmation request to an owner

    :param address: Safe address
    :param safe_tx_hash: Hash of the safe tx
    :return: Tuple with the number of successful and failed notifications sent
    """
    assert safe_tx_hash, "Safe tx hash was not provided"

    try:
        safe_last_status = SafeLastStatus.objects.get_or_generate(address)
    except SafeLastStatus.DoesNotExist:
        logger.info("Cannot find threshold information for safe=%s", address)
        return 0, 0

    if safe_last_status.threshold == 1:
        logger.info(
            "No need to send confirmation notification for safe=%s with threshold=1",
            address,
        )
        return 0, 0

    confirmed_owners = MultisigConfirmation.objects.filter(
        multisig_transaction_id=safe_tx_hash
    ).values_list("owner", flat=True)

    if safe_last_status.threshold <= len(confirmed_owners):
        # No need for more confirmations
        logger.info(
            "Multisig transaction with safe-tx-hash=%s for safe=%s does not require more confirmations",
            safe_tx_hash,
            address,
        )
        return 0, 0

    # Get cloud messaging token for missing owners
    owners_to_notify = set(safe_last_status.owners) - set(confirmed_owners)
    if not owners_to_notify:
        return 0, 0

    # Delegates must be notified too
    delegates = SafeContractDelegate.objects.get_delegates_for_safe_and_owners(
        address, owners_to_notify
    )
    users_to_notify = delegates | owners_to_notify

    tokens = FirebaseDeviceOwner.objects.get_devices_for_safe_and_owners(
        address, users_to_notify
    )

    if not tokens:
        logger.info(
            "No cloud messaging tokens found for owners %s or delegates %s to sign safe-tx-hash=%s for safe=%s",
            owners_to_notify,
            delegates,
            safe_tx_hash,
            address,
        )
        return 0, 0

    payload = {
        "type": WebHookType.CONFIRMATION_REQUEST.name,
        "address": address,
        "safeTxHash": safe_tx_hash,
        "chainId": str(get_ethereum_network().value),
    }
    # Make sure notification has not been sent before
    duplicate_notification = DuplicateNotification(address, payload)
    if duplicate_notification.is_duplicated():
        logger.info(
            "Duplicated notification about Safe=%s with payload=%s to tokens=%s",
            address,
            payload,
            tokens,
        )
        return 0, 0

    duplicate_notification.set_duplicated()

    with FirebaseClientPool() as firebase_client:
        logger.info(
            "Sending notification about Safe=%s with payload=%s to tokens=%s",
            address,
            payload,
            tokens,
        )
        success_count, failure_count, invalid_tokens = firebase_client.send_message(
            tokens, payload
        )
        if invalid_tokens:
            logger.info(
                "Removing invalid tokens for owners of safe=%s. Tokens=%s",
                address,
                invalid_tokens,
            )
            FirebaseDevice.objects.filter(
                cloud_messaging_token__in=invalid_tokens
            ).update(cloud_messaging_token=None)

    return success_count, failure_count

'''
'''--- safe_transaction_service/notifications/tests/__init__.py ---

'''
'''--- safe_transaction_service/notifications/tests/factories.py ---
import uuid

import factory
from eth_account import Account
from factory.django import DjangoModelFactory

from ..models import FirebaseDevice, FirebaseDeviceOwner

class FirebaseDeviceFactory(DjangoModelFactory):
    class Meta:
        model = FirebaseDevice

    uuid = factory.LazyFunction(uuid.uuid4)
    cloud_messaging_token = factory.Faker("isbn13")
    build_number = factory.Sequence(lambda n: n)
    bundle = "company.package.app"
    device_type = 0
    version = factory.Sequence(lambda n: f"{n}.0.0")

    @factory.post_generation
    def safes(self, create, extracted, **kwargs):
        if not create:
            # Simple build, do nothing.
            return None

        if extracted:
            # A list of groups were passed in, use them
            for safe_contract in extracted:
                self.safes.add(safe_contract)

class FirebaseDeviceOwnerFactory(DjangoModelFactory):
    class Meta:
        model = FirebaseDeviceOwner

    firebase_device = factory.SubFactory(FirebaseDeviceFactory)
    owner = factory.LazyFunction(lambda: Account.create().address)

'''
'''--- safe_transaction_service/notifications/tests/test_firebase_client.py ---
from unittest import mock

from django.test import TestCase

from firebase_admin import messaging
from firebase_admin.messaging import BatchResponse, SendResponse, UnregisteredError

from ..clients.firebase_client import FirebaseClient, FirebaseClientPool, MockedClient

class TestFirebaseClient(TestCase):
    def test_mocked_client(self):
        mocked_client = MockedClient()
        self.assertIsNone(mocked_client.auth_provider)
        self.assertIsNone(mocked_client.app)
        self.assertFalse(mocked_client.verify_token(""))
        self.assertTrue(mocked_client.verify_token("ab"))

    @mock.patch.object(
        FirebaseClient, "_authenticate", autospec=True, return_value=None
    )
    def test_firebase_client(self, initialize_app_mock):
        try:
            with self.settings(NOTIFICATIONS_FIREBASE_AUTH_CREDENTIALS="ab"):
                with FirebaseClientPool() as firebase_client:
                    firebase_client.app = None
                    self.assertNotIsInstance(firebase_client, MockedClient)
                    self.assertIsInstance(
                        firebase_client._build_android_config(), messaging.AndroidConfig
                    )
                    self.assertIsInstance(
                        firebase_client._build_apns_config(), messaging.APNSConfig
                    )
                    with mock.patch(
                        "firebase_admin.messaging.send", return_value=True
                    ) as send_mock:
                        self.assertTrue(firebase_client.verify_token("xy"))
                        send_mock.side_effect = UnregisteredError(
                            "Token not registered"
                        )
                        self.assertFalse(firebase_client.verify_token("xy"))

                    responses = [
                        SendResponse({"name": "id-1"}, None),
                        SendResponse(
                            {"name": "id-2"}, UnregisteredError("Token not registered")
                        ),
                    ]
                    batch_response = BatchResponse(responses)
                    with mock.patch(
                        "firebase_admin.messaging.send_multicast",
                        return_value=batch_response,
                    ):
                        (
                            success_count,
                            failure_count,
                            invalid_tokens,
                        ) = firebase_client.send_message(
                            ["token-1", "token-2"], {"tx-hash": "0x-random-hash"}
                        )
                        self.assertEqual(success_count, 1)
                        self.assertEqual(failure_count, 1)
                        self.assertEqual(invalid_tokens, ["token-2"])
        finally:
            FirebaseClientPool.firebase_client_pool.clear()

'''
'''--- safe_transaction_service/notifications/tests/test_models.py ---
from django.test import TestCase

from eth_account import Account

from safe_transaction_service.history.tests.factories import SafeContractFactory

from ..models import FirebaseDeviceOwner
from .factories import FirebaseDeviceOwnerFactory

class TestFirebaseDeviceOwner(TestCase):
    def test_get_devices_for_safe_and_owners(self):
        safe_contract = SafeContractFactory()
        self.assertEqual(
            FirebaseDeviceOwner.objects.get_devices_for_safe_and_owners(
                safe_contract.address, []
            ),
            [],
        )
        self.assertEqual(
            FirebaseDeviceOwner.objects.get_devices_for_safe_and_owners(
                safe_contract.address, [Account.create().address]
            ),
            [],
        )

        firebase_device_owner = FirebaseDeviceOwnerFactory.create(
            firebase_device__safes=(safe_contract,)
        )
        firebase_device_owner_2 = FirebaseDeviceOwnerFactory(
            firebase_device=firebase_device_owner.firebase_device
        )

        self.assertEqual(
            FirebaseDeviceOwner.objects.get_devices_for_safe_and_owners(
                Account.create().address, []
            ),
            [],
        )
        self.assertEqual(
            FirebaseDeviceOwner.objects.get_devices_for_safe_and_owners(
                safe_contract.address,
                [firebase_device_owner.owner, firebase_device_owner_2.owner],
            ),
            [firebase_device_owner.firebase_device.cloud_messaging_token],
        )

        safe_contract_2 = SafeContractFactory()
        firebase_device_owner_3 = FirebaseDeviceOwnerFactory.create(
            firebase_device__safes=(safe_contract_2,)
        )
        self.assertEqual(
            FirebaseDeviceOwner.objects.get_devices_for_safe_and_owners(
                safe_contract.address,
                [
                    firebase_device_owner.owner,
                    firebase_device_owner_2.owner,
                    firebase_device_owner_3.owner,
                ],
            ),
            [firebase_device_owner.firebase_device.cloud_messaging_token],
        )
        self.assertEqual(
            FirebaseDeviceOwner.objects.get_devices_for_safe_and_owners(
                safe_contract_2.address,
                [
                    firebase_device_owner.owner,
                    firebase_device_owner_2.owner,
                    firebase_device_owner_3.owner,
                ],
            ),
            [firebase_device_owner_3.firebase_device.cloud_messaging_token],
        )

        firebase_device_owner_3.firebase_device.safes.add(safe_contract)
        self.assertCountEqual(
            FirebaseDeviceOwner.objects.get_devices_for_safe_and_owners(
                safe_contract.address,
                [
                    firebase_device_owner.owner,
                    firebase_device_owner_2.owner,
                    firebase_device_owner_3.owner,
                ],
            ),
            [
                firebase_device_owner.firebase_device.cloud_messaging_token,
                firebase_device_owner_3.firebase_device.cloud_messaging_token,
            ],
        )

'''
'''--- safe_transaction_service/notifications/tests/test_tasks.py ---
from unittest import mock

from django.test import TestCase

from eth_account import Account
from web3 import Web3

from safe_transaction_service.history.models import (
    EthereumTxCallType,
    InternalTx,
    InternalTxType,
    MultisigConfirmation,
    MultisigTransaction,
    WebHookType,
)
from safe_transaction_service.history.signals import build_webhook_payload
from safe_transaction_service.history.tests.factories import (
    InternalTxFactory,
    MultisigConfirmationFactory,
    MultisigTransactionFactory,
    SafeContractDelegateFactory,
    SafeContractFactory,
    SafeLastStatusFactory,
)

from ..tasks import (
    DuplicateNotification,
    filter_notification,
    send_notification_owner_task,
    send_notification_task,
)
from .factories import FirebaseDeviceOwnerFactory

class TestViews(TestCase):
    def test_duplicate_notification_manager(self):
        address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
        payload = {
            "address": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            "type": "INCOMING_TOKEN",
            "tokenAddress": "0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88",
            "txHash": "0xd8cf5db08e4f3d43660975c8be02a079139a69c42c0ccdd157618aec9bb91b28",
            "value": "50000000000000",
        }
        duplicate_notification = DuplicateNotification(address, payload)
        self.assertFalse(duplicate_notification.is_duplicated())
        self.assertFalse(duplicate_notification.is_duplicated())
        duplicate_notification.set_duplicated()
        self.assertTrue(duplicate_notification.is_duplicated())
        duplicate_notification_2 = DuplicateNotification(
            address, {"type": "Different_payload"}
        )
        self.assertFalse(duplicate_notification_2.is_duplicated())
        duplicate_notification_3 = DuplicateNotification(
            Account.create().address, payload
        )
        self.assertFalse(duplicate_notification_3.is_duplicated())

    def test_filter_notification(self):
        multisig_confirmation = MultisigConfirmationFactory()
        confirmation_notification = build_webhook_payload(
            MultisigConfirmation, multisig_confirmation
        )[0]
        # Confirmations for executed transaction should be filtered out
        self.assertFalse(filter_notification(confirmation_notification))
        multisig_confirmation.multisig_transaction.ethereum_tx.block = None
        multisig_confirmation.multisig_transaction.ethereum_tx.save()
        confirmation_notification = build_webhook_payload(
            MultisigConfirmation, multisig_confirmation
        )[0]
        # All confirmations are disabled for now
        # self.assertTrue(filter_notification(confirmation_notification))
        self.assertFalse(filter_notification(confirmation_notification))

        # Pending multisig transaction should be filtered out
        multisig_transaction = MultisigTransactionFactory()
        transaction_notification = build_webhook_payload(
            MultisigTransaction, multisig_transaction
        )[0]
        self.assertTrue(filter_notification(transaction_notification))

        multisig_transaction.ethereum_tx = None
        multisig_transaction.save()
        pending_transaction_notification = build_webhook_payload(
            MultisigTransaction, multisig_transaction
        )[0]
        self.assertNotEqual(multisig_transaction, pending_transaction_notification)
        self.assertFalse(filter_notification(pending_transaction_notification))

        # Incoming transaction to a Safe must be filtered out if it was triggered by that same Safe
        internal_tx = InternalTxFactory(
            value=5,
            tx_type=InternalTxType.CALL.value,
            call_type=EthereumTxCallType.CALL.value,
        )
        (
            incoming_internal_tx_payload,
            outgoing_internal_tx_payload,
        ) = build_webhook_payload(InternalTx, internal_tx)

        self.assertEqual(outgoing_internal_tx_payload["address"], internal_tx._from)
        self.assertFalse(filter_notification(outgoing_internal_tx_payload))

        self.assertEqual(incoming_internal_tx_payload["address"], internal_tx.to)
        self.assertTrue(filter_notification(incoming_internal_tx_payload))
        MultisigTransactionFactory(
            safe=internal_tx.to, ethereum_tx=internal_tx.ethereum_tx
        )
        self.assertFalse(filter_notification(incoming_internal_tx_payload))

    def test_send_notification_owner_task(self):
        from ..tasks import logger as task_logger

        safe_contract = SafeContractFactory()
        safe_address = safe_contract.address
        threshold = 2
        owners = [Account.create().address for _ in range(2)]
        safe_tx_hash = Web3.keccak(text="hola").hex()
        with self.assertLogs(logger=task_logger) as cm:
            self.assertEqual(
                send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
                (0, 0),
            )
            self.assertIn("Cannot find threshold information", cm.output[0])

        safe_status = SafeLastStatusFactory(
            address=safe_address, threshold=1, owners=owners
        )
        with self.assertLogs(logger=task_logger) as cm:
            self.assertEqual(
                send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
                (0, 0),
            )
            self.assertIn(
                "No need to send confirmation notification for ", cm.output[0]
            )

        safe_status.threshold = threshold
        safe_status.save(update_fields=["threshold"])
        with self.assertLogs(logger=task_logger) as cm:
            self.assertEqual(
                send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
                (0, 0),
            )
            self.assertIn("No cloud messaging tokens found", cm.output[0])

        firebase_device_owner_factories = [
            FirebaseDeviceOwnerFactory(owner=owner) for owner in owners
        ]
        # Notification is not sent to both owners as they are not related to the safe address
        self.assertEqual(
            send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
            (0, 0),
        )

        for firebase_device_owner in firebase_device_owner_factories:
            firebase_device_owner.firebase_device.safes.add(safe_contract)
        self.assertEqual(
            send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
            (2, 0),
        )

        # Duplicated notifications are not sent
        with self.assertLogs(logger=task_logger) as cm:
            self.assertEqual(
                send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
                (0, 0),
            )
            self.assertIn("Duplicated notification", cm.output[0])

        # Disable duplicated detection
        with mock.patch.object(
            DuplicateNotification, "is_duplicated", autospec=True, return_value=False
        ):
            self.assertEqual(
                send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
                (2, 0),
            )

            # Add one confirmation for that transaction and other random confirmation for other transaction
            # to check that they don't influence each other
            multisig_confirmation = MultisigConfirmationFactory(
                owner=owners[0], multisig_transaction__safe_tx_hash=safe_tx_hash
            )
            MultisigConfirmationFactory(
                owner=owners[1]
            )  # Not related multisig transaction

            # Just one transaction sent, as owners[0] already confirmed
            self.assertEqual(
                send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
                (1, 0),
            )

            # Reach the threshold with an unrelated owner
            MultisigConfirmationFactory(
                multisig_transaction=multisig_confirmation.multisig_transaction
            )
            with self.assertLogs(logger=task_logger) as cm:
                self.assertEqual(
                    send_notification_owner_task.delay(
                        safe_address, safe_tx_hash
                    ).result,
                    (0, 0),
                )
                self.assertIn("does not require more confirmations", cm.output[0])

    def test_send_notification_owner_delegate_task(self):
        safe_tx_hash = Web3.keccak(text="aloha").hex()
        safe_contract = SafeContractFactory()
        safe_address = safe_contract.address
        safe_status = SafeLastStatusFactory(address=safe_address, threshold=3)
        safe_contract_delegate = SafeContractDelegateFactory(
            safe_contract=safe_contract, delegator=safe_status.owners[0]
        )
        safe_contract_delegate_2 = SafeContractDelegateFactory(
            safe_contract=None, delegator=safe_status.owners[1]
        )
        safe_contract_delegate_random = SafeContractDelegateFactory(safe_contract=None)

        # No firebase device
        self.assertEqual(
            send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
            (0, 0),
        )

        FirebaseDeviceOwnerFactory(
            firebase_device__safes=[safe_contract],
            owner=safe_contract_delegate.delegate,
        )
        FirebaseDeviceOwnerFactory(
            firebase_device__safes=[safe_contract],
            owner=safe_contract_delegate_2.delegate,
        )
        FirebaseDeviceOwnerFactory(owner=safe_contract_delegate_random.delegate)

        self.assertEqual(
            send_notification_owner_task.delay(safe_address, safe_tx_hash).result,
            (2, 0),
        )

    def test_send_notification_owner_task_called(self):
        safe_address = Account.create().address
        safe_tx_hash = Web3.keccak(text="hola").hex()
        payload = {
            "address": safe_address,
            "type": WebHookType.PENDING_MULTISIG_TRANSACTION.name,
            "safeTxHash": safe_tx_hash,
        }

        with mock.patch(
            "safe_transaction_service.notifications.tasks.send_notification_owner_task.delay"
        ) as send_notification_owner_task_mock:
            send_notification_owner_task_mock.assert_not_called()
            send_notification_task.delay(safe_address, payload)
            send_notification_owner_task_mock.assert_called_with(
                safe_address, safe_tx_hash
            )

'''
'''--- safe_transaction_service/notifications/tests/test_views.py ---
import time
import uuid
from unittest import mock

from django.urls import reverse

from eth_account import Account
from rest_framework import status
from rest_framework.test import APITestCase

from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from safe_transaction_service.history.tests.factories import (
    SafeContractDelegateFactory,
    SafeContractFactory,
)
from safe_transaction_service.notifications.models import (
    FirebaseDevice,
    FirebaseDeviceOwner,
)

from ..utils import calculate_device_registration_hash
from .factories import FirebaseDeviceFactory, FirebaseDeviceOwnerFactory

class TestNotificationViews(SafeTestCaseMixin, APITestCase):
    def test_notifications_devices_create_view(self):
        response = self.client.post(reverse("v1:notifications:devices"))
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        safe_address = Account.create().address
        safe_contract = SafeContractFactory(address=safe_address)

        self.assertEqual(FirebaseDevice.objects.count(), 0)
        data = {
            "safes": [safe_address],
            "cloudMessagingToken": "A" * 163,
            "buildNumber": 0,
            "bundle": "company.package.app",
            "deviceType": "WEB",
            "version": "2.0.1",
        }
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(FirebaseDevice.objects.count(), 1)
        device_uuid = response.data["uuid"]
        self.assertTrue(uuid.UUID(device_uuid))

        # Same request should return a 400 because a new device with same push token cannot be created
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

        # Request with `uuid` should not create a new object
        data["uuid"] = device_uuid
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(FirebaseDevice.objects.count(), 1)

        # Changing the token and using the uuid will change the cloud messaging token
        data["cloudMessagingToken"] = "B" * 163
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(FirebaseDevice.objects.count(), 1)
        self.assertEqual(
            FirebaseDevice.objects.first().cloud_messaging_token,
            data["cloudMessagingToken"],
        )

        # Add the same FirebaseDevice to another Safe
        safe_contract_2 = SafeContractFactory()
        data["safes"].append(safe_contract_2.address)
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(safe_contract.firebase_devices.count(), 1)
        self.assertEqual(safe_contract_2.firebase_devices.count(), 1)
        self.assertEqual(FirebaseDevice.objects.count(), 1)
        self.assertEqual(FirebaseDevice.objects.first().safes.count(), 2)

        # Use not valid deviceType
        previous_device_type = data["deviceType"]
        data["deviceType"] = "RANGER-MORPHER"
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertIn("is not a valid choice", response.content.decode())
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(safe_contract.firebase_devices.count(), 1)
        data["deviceType"] = previous_device_type

        # Use not valid version
        previous_version = data["version"]
        data["version"] = "Megazord"
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertIn("Semantic version was expected", response.content.decode())
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(safe_contract.firebase_devices.count(), 1)
        data["version"] = previous_version

        # Remove one of the Safes
        data["safes"] = [safe_contract_2.address]
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(safe_contract.firebase_devices.count(), 0)
        self.assertEqual(safe_contract_2.firebase_devices.count(), 1)

    def test_notifications_devices_create_with_signatures_view(self):
        safe_address = Account.create().address
        safe_contract = SafeContractFactory(address=safe_address)
        owner_account = Account.create()
        owner_account_2 = Account.create()

        self.assertEqual(FirebaseDevice.objects.count(), 0)
        unique_id = uuid.uuid4()
        timestamp = int(time.time())
        cloud_messaging_token = "A" * 163
        safes = [safe_address]
        hash_to_sign = calculate_device_registration_hash(
            timestamp, unique_id, cloud_messaging_token, safes
        )
        signatures = [owner_account.signHash(hash_to_sign)["signature"].hex()]
        data = {
            "uuid": unique_id,
            "safes": [safe_address],
            "cloudMessagingToken": cloud_messaging_token,
            "buildNumber": 0,
            "bundle": "company.package.app",
            "deviceType": "WEB",
            "version": "2.0.1",
            "timestamp": timestamp,
            "signatures": signatures,
        }
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn(
            f"Could not get Safe {safe_address} owners from blockchain, check contract exists on network",
            response.data["non_field_errors"][0],
        )

        with mock.patch(
            "safe_transaction_service.notifications.serializers.get_safe_owners",
            return_value=[owner_account.address],
        ):
            response = self.client.post(
                reverse("v1:notifications:devices"), format="json", data=data
            )
            self.assertEqual(response.status_code, status.HTTP_201_CREATED)
            self.assertEqual(response.data["uuid"], str(unique_id))
            self.assertEqual(FirebaseDevice.objects.count(), 1)
            self.assertEqual(FirebaseDeviceOwner.objects.count(), 1)
            self.assertEqual(
                FirebaseDeviceOwner.objects.first().owner, owner_account.address
            )

            # Add another signature
            signatures.append(owner_account_2.signHash(hash_to_sign)["signature"].hex())
            response = self.client.post(
                reverse("v1:notifications:devices"), format="json", data=data
            )
            # self.assertIn('is not an owner of any of the safes', str(response.data['non_field_errors']))
            self.assertEqual(response.status_code, status.HTTP_201_CREATED)
            self.assertEqual(
                response.data["owners_registered"], [owner_account.address]
            )
            self.assertEqual(
                response.data["owners_not_registered"], [owner_account_2.address]
            )

        with mock.patch(
            "safe_transaction_service.notifications.serializers.get_safe_owners",
            return_value=[owner_account.address, owner_account_2.address],
        ):
            response = self.client.post(
                reverse("v1:notifications:devices"), format="json", data=data
            )
            self.assertEqual(response.status_code, status.HTTP_201_CREATED)
            self.assertEqual(
                response.data["owners_registered"],
                [owner_account.address, owner_account_2.address],
            )
            self.assertEqual(response.data["owners_not_registered"], [])
            self.assertEqual(FirebaseDevice.objects.count(), 1)
            self.assertCountEqual(
                FirebaseDeviceOwner.objects.values_list("owner", flat=True),
                [owner_account.address, owner_account_2.address],
            )

    def test_notifications_devices_create_with_delegates_signatures_view(self):
        delegate = Account.create()
        safe_contract_delegate = SafeContractDelegateFactory(delegate=delegate.address)
        safe_address = safe_contract_delegate.safe_contract.address

        self.assertEqual(FirebaseDevice.objects.count(), 0)
        unique_id = uuid.uuid4()
        timestamp = int(time.time())
        cloud_messaging_token = "A" * 163
        safes = [safe_address]
        hash_to_sign = calculate_device_registration_hash(
            timestamp, unique_id, cloud_messaging_token, safes
        )
        signatures = [delegate.signHash(hash_to_sign)["signature"].hex()]
        data = {
            "uuid": unique_id,
            "safes": [safe_address],
            "cloudMessagingToken": cloud_messaging_token,
            "buildNumber": 0,
            "bundle": "company.package.app",
            "deviceType": "WEB",
            "version": "2.0.1",
            "timestamp": timestamp,
            "signatures": signatures,
        }
        response = self.client.post(
            reverse("v1:notifications:devices"), format="json", data=data
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn(
            f"Could not get Safe {safe_address} owners from blockchain, check contract exists on network",
            response.data["non_field_errors"][0],
        )

        with mock.patch(
            "safe_transaction_service.notifications.serializers.get_safe_owners",
            return_value=[safe_contract_delegate.delegator],
        ):
            response = self.client.post(
                reverse("v1:notifications:devices"), format="json", data=data
            )
            self.assertEqual(response.status_code, status.HTTP_201_CREATED)
            self.assertEqual(response.data["owners_registered"], [delegate.address])
            self.assertEqual(response.data["owners_not_registered"], [])
            self.assertEqual(
                FirebaseDeviceOwner.objects.filter(owner=delegate.address).count(), 1
            )

    def test_notifications_devices_delete_view(self):
        safe_contract = SafeContractFactory()
        firebase_device = FirebaseDeviceFactory()
        firebase_device.safes.add(safe_contract)
        device_id = firebase_device.uuid
        FirebaseDeviceOwnerFactory(firebase_device=firebase_device)

        self.assertEqual(FirebaseDevice.objects.count(), 1)
        self.assertEqual(FirebaseDeviceOwner.objects.count(), 1)
        response = self.client.delete(
            reverse("v1:notifications:devices-delete", args=(device_id,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(FirebaseDevice.objects.count(), 0)
        self.assertEqual(FirebaseDeviceOwner.objects.count(), 0)

        # Try to delete again if not exists
        response = self.client.delete(
            reverse("v1:notifications:devices-delete", args=(device_id,)), format="json"
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

    def test_notifications_devices_safe_delete_view(self):
        safe_contract = SafeContractFactory()
        firebase_device = FirebaseDeviceFactory()
        firebase_device_owner = FirebaseDeviceOwnerFactory(
            firebase_device=firebase_device
        )
        not_related_firebase_device_owner = FirebaseDeviceOwnerFactory()
        firebase_device.safes.add(safe_contract)
        device_id = firebase_device.uuid

        # Test not existing `safe_contract`, even if `device_id` is correct
        random_safe_address = Account.create().address
        self.assertEqual(firebase_device.safes.count(), 1)
        self.assertEqual(FirebaseDeviceOwner.objects.count(), 2)
        response = self.client.delete(
            reverse(
                "v1:notifications:devices-safes-delete",
                args=(device_id, random_safe_address),
            ),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(firebase_device.safes.count(), 1)
        self.assertEqual(FirebaseDeviceOwner.objects.count(), 2)

        # Happy path
        response = self.client.delete(
            reverse(
                "v1:notifications:devices-safes-delete",
                args=(device_id, safe_contract.address),
            ),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(firebase_device.safes.count(), 0)
        self.assertEqual(FirebaseDeviceOwner.objects.count(), 1)
        self.assertEqual(
            FirebaseDeviceOwner.objects.get(), not_related_firebase_device_owner
        )

        # Try to delete again and get the same result even if the Safe is not linked
        response = self.client.delete(
            reverse(
                "v1:notifications:devices-safes-delete",
                args=(device_id, safe_contract.address),
            ),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(firebase_device.safes.count(), 0)
        self.assertEqual(FirebaseDeviceOwner.objects.count(), 1)

        # Remove not existing Safe should not trigger an error
        response = self.client.delete(
            reverse(
                "v1:notifications:devices-safes-delete",
                args=(device_id, Account.create().address),
            ),
            format="json",
        )
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(firebase_device.safes.count(), 0)
        self.assertEqual(FirebaseDeviceOwner.objects.count(), 1)

'''
'''--- safe_transaction_service/notifications/urls.py ---
from django.urls import path

from . import views

app_name = "notifications"

urlpatterns = [
    path("devices/", views.FirebaseDeviceCreateView.as_view(), name="devices"),
    path(
        "devices/<uuid:pk>/",
        views.FirebaseDeviceDeleteView.as_view(),
        name="devices-delete",
    ),
    path(
        "devices/<uuid:pk>/safes/<str:address>/",
        views.FirebaseDeviceSafeDeleteView.as_view(),
        name="devices-safes-delete",
    ),
]

'''
'''--- safe_transaction_service/notifications/utils.py ---
from typing import Sequence
from uuid import UUID

from hexbytes import HexBytes

from gnosis.eth.utils import fast_keccak

def calculate_device_registration_hash(
    timestamp: int,
    identifier: UUID,
    cloud_messaging_token: str,
    safes: Sequence[str],
    prefix: str = "gnosis-safe",
) -> HexBytes:
    safes_to_str = "".join(sorted(safes))
    str_to_sign = (
        f"{prefix}{timestamp}{identifier}{cloud_messaging_token}{safes_to_str}"
    )
    return fast_keccak(str_to_sign.encode())

'''
'''--- safe_transaction_service/notifications/views.py ---
import logging

from drf_yasg.utils import swagger_auto_schema
from rest_framework import status
from rest_framework.generics import CreateAPIView, DestroyAPIView
from rest_framework.response import Response

from safe_transaction_service.history.models import SafeContract

from . import serializers
from .models import FirebaseDevice
from .serializers import get_safe_owners

logger = logging.getLogger(__name__)

class FirebaseDeviceCreateView(CreateAPIView):
    """
    Creates a new FirebaseDevice. If uuid is not provided a new device will be created.
    If a uuid for an existing Safe is provided the FirebaseDevice will be updated with all the new data provided.
    Safes provided on the request are always added and never removed/replaced
    Signature must sign `keccack256('gnosis-safe{timestamp-epoch}{uuid}{cloud_messaging_token}{safes_sorted}':
        - `{timestamp-epoch}` must be an integer (no milliseconds)
        - `{safes_sorted}` must be checksummed safe addresses sorted and joined with no spaces
    """

    serializer_class = serializers.FirebaseDeviceSerializer
    response_serializer_class = (
        serializers.FirebaseDeviceSerializerWithOwnersResponseSerializer
    )

    @swagger_auto_schema(
        responses={200: response_serializer_class(), 400: "Invalid data"}
    )
    def post(self, request, *args, **kwargs):
        return super().post(request, *args, **kwargs)

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        response_serializer = self.response_serializer_class(
            data=serializer.validated_data
        )
        response_serializer.is_valid(raise_exception=True)
        headers = self.get_success_headers(response_serializer.data)
        return Response(
            response_serializer.data, status=status.HTTP_201_CREATED, headers=headers
        )

class FirebaseDeviceDeleteView(DestroyAPIView):
    """
    Remove a FirebaseDevice
    """

    queryset = FirebaseDevice.objects.all()

class FirebaseDeviceSafeDeleteView(DestroyAPIView):
    """
    Remove a Safe for a FirebaseDevice
    """

    queryset = FirebaseDevice.objects.all()

    def perform_destroy(self, firebase_device: FirebaseDevice):
        safe_address = self.kwargs["address"]
        try:
            safe_contract = SafeContract.objects.get(address=safe_address)
            firebase_device.safes.remove(safe_contract)
            current_owners = {
                owner
                for safe in firebase_device.safes.values_list("address", flat=True)
                for owner in get_safe_owners(safe)
            }
            # Remove owners not linked to any Safe
            firebase_device.owners.exclude(owner__in=current_owners).delete()
        except SafeContract.DoesNotExist:
            logger.info(
                "Cannot remove safe=%s for firebase_device with uuid=%s",
                safe_address,
                self.kwargs["pk"],
            )

'''
'''--- safe_transaction_service/safe_messages/__init__.py ---

'''
'''--- safe_transaction_service/safe_messages/admin.py ---
from django.contrib import admin

from gnosis.eth.django.admin import BinarySearchAdmin

from .models import SafeMessage, SafeMessageConfirmation

@admin.register(SafeMessage)
class SafeMessageAdmin(BinarySearchAdmin):
    date_hierarchy = "created"
    list_display = ("safe", "message_hash", "proposed_by", "message")
    ordering = ["-created"]
    readonly_fields = ("message_hash",)
    search_fields = ["safe", "message_hash", "proposed_by", "message"]

@admin.register(SafeMessageConfirmation)
class SafeMessageConfirmationAdmin(BinarySearchAdmin):
    date_hierarchy = "created"
    list_display = (
        "safe_message",
        "owner",
        "signature_type",
    )
    list_filter = ("signature_type",)
    list_select_related = ("safe_message",)
    ordering = ["-created"]
    search_fields = [
        "safe_message__safe",
        "owner",
        "safe_message__description",
    ]

'''
'''--- safe_transaction_service/safe_messages/apps.py ---
from django.apps import AppConfig

class SafeMessagesConfig(AppConfig):
    name = "safe_transaction_service.safe_messages"
    verbose_name = "Safe Messages app"

    def ready(self):
        from . import signals  # noqa

'''
'''--- safe_transaction_service/safe_messages/management/__init__.py ---

'''
'''--- safe_transaction_service/safe_messages/management/commands/__init__.py ---

'''
'''--- safe_transaction_service/safe_messages/migrations/0001_initial.py ---
# Generated by Django 4.1.3 on 2022-11-21 16:24

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models

import model_utils.fields

import gnosis.eth.django.models

class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="SafeMessage",
            fields=[
                (
                    "created",
                    model_utils.fields.AutoCreatedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="created",
                    ),
                ),
                (
                    "modified",
                    model_utils.fields.AutoLastModifiedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="modified",
                    ),
                ),
                (
                    "message_hash",
                    gnosis.eth.django.models.Keccak256Field(
                        primary_key=True, serialize=False
                    ),
                ),
                (
                    "safe",
                    gnosis.eth.django.models.EthereumAddressV2Field(db_index=True),
                ),
                ("message", models.JSONField()),
                ("proposed_by", gnosis.eth.django.models.EthereumAddressV2Field()),
                ("safe_app_id", models.PositiveIntegerField(blank=True, null=True)),
            ],
            options={
                "ordering": ["created"],
            },
        ),
        migrations.CreateModel(
            name="SafeMessageConfirmation",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "created",
                    model_utils.fields.AutoCreatedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="created",
                    ),
                ),
                (
                    "modified",
                    model_utils.fields.AutoLastModifiedField(
                        default=django.utils.timezone.now,
                        editable=False,
                        verbose_name="modified",
                    ),
                ),
                (
                    "owner",
                    gnosis.eth.django.models.EthereumAddressV2Field(db_index=True),
                ),
                ("signature", gnosis.eth.django.models.HexField(max_length=5000)),
                (
                    "signature_type",
                    models.PositiveSmallIntegerField(
                        choices=[
                            (0, "CONTRACT_SIGNATURE"),
                            (1, "APPROVED_HASH"),
                            (2, "EOA"),
                            (3, "ETH_SIGN"),
                        ],
                        db_index=True,
                    ),
                ),
                (
                    "safe_message",
                    models.ForeignKey(
                        default=None,
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="confirmations",
                        to="safe_messages.safemessage",
                    ),
                ),
            ],
            options={
                "ordering": ["created"],
                "unique_together": {("safe_message", "owner")},
            },
        ),
    ]

'''
'''--- safe_transaction_service/safe_messages/migrations/__init__.py ---

'''
'''--- safe_transaction_service/safe_messages/models.py ---
from logging import getLogger

from django.db import models
from django.db.models import JSONField

from hexbytes import HexBytes
from model_utils.models import TimeStampedModel

from gnosis.eth.django.models import EthereumAddressV2Field, HexField, Keccak256Field
from gnosis.safe.safe_signature import SafeSignatureType

logger = getLogger(__name__)

class SafeMessage(TimeStampedModel):
    """
    Safe Message (EIP-191 or EIP-712) to build an EIP-1271 signature from
    """

    # Message hash is tied to Safe domain, so it's guaranteed to be unique
    message_hash = Keccak256Field(primary_key=True)
    safe = EthereumAddressV2Field(db_index=True)
    message = JSONField()  # String if EIP191, object if EIP712
    proposed_by = EthereumAddressV2Field()  # Owner proposing the message
    safe_app_id = models.PositiveIntegerField(blank=True, null=True)

    class Meta:
        ordering = ["created"]

    def __str__(self):
        message_str = str(self.message)
        message_size = 15
        message = message_str[:message_size]
        if len(message_str) > message_size:
            message += "..."
        message_hash = (
            self.message_hash.hex()
            if isinstance(self.message_hash, bytes)
            else self.message_hash
        )
        return f"Safe Message {message_hash} - {message}"

    def build_signature(self) -> bytes:
        return b"".join(
            [
                HexBytes(signature)
                for _, signature in sorted(
                    self.confirmations.values_list("owner", "signature"),
                    key=lambda tup: tup[0].lower(),
                )
            ]
        )

class SafeMessageConfirmation(TimeStampedModel):
    """
    Owner signature for a Safe Message
    """

    safe_message = models.ForeignKey(
        SafeMessage,
        on_delete=models.CASCADE,
        null=True,
        default=None,
        related_name="confirmations",
    )
    owner = EthereumAddressV2Field(db_index=True)
    signature = HexField(max_length=5000)
    signature_type = models.PositiveSmallIntegerField(
        choices=[(tag.value, tag.name) for tag in SafeSignatureType], db_index=True
    )

    class Meta:
        unique_together = (("safe_message", "owner"),)
        ordering = ["created"]

    def __str__(self):
        return f"Safe Message Confirmation for owner {self.owner}"

'''
'''--- safe_transaction_service/safe_messages/pagination.py ---
from rest_framework.pagination import LimitOffsetPagination

class DefaultPagination(LimitOffsetPagination):
    max_limit = 200
    default_limit = 100

'''
'''--- safe_transaction_service/safe_messages/serializers.py ---
from typing import Any, Dict, Optional, Union

from eth_typing import HexStr
from hexbytes import HexBytes
from rest_framework import serializers
from rest_framework.exceptions import ValidationError

import gnosis.eth.django.serializers as eth_serializers
from gnosis.eth import EthereumClientProvider
from gnosis.eth.eip712 import eip712_encode_hash
from gnosis.safe.safe_signature import SafeSignature, SafeSignatureType

from safe_transaction_service.utils.serializers import get_safe_owners

from .models import SafeMessage, SafeMessageConfirmation
from .utils import get_safe_message_hash_for_message

# Request serializers
class SafeMessageSerializer(serializers.Serializer):
    message = serializers.JSONField()
    safe_app_id = serializers.IntegerField(allow_null=True, default=None)
    signature = eth_serializers.HexadecimalField(max_length=65)

    def validate_message(self, value: Union[str, Dict[str, Any]]):
        if isinstance(value, str):
            return value

        if isinstance(value, dict):
            try:
                eip712_encode_hash(value)
                return value
            except ValueError as exc:
                raise ValidationError(
                    f"Provided dictionary is not a valid EIP712 message {value}"
                ) from exc

        raise ValidationError(f"Provided value is not a valid message {value}")

    def validate(self, attrs):
        attrs = super().validate(attrs)
        message = attrs["message"]
        safe_address = self.context["safe_address"]
        signature = attrs["signature"]
        attrs["safe"] = safe_address
        safe_message_hash = get_safe_message_hash_for_message(safe_address, message)
        attrs["message_hash"] = safe_message_hash

        if SafeMessage.objects.filter(message_hash=safe_message_hash).exists():
            raise ValidationError(
                f"Message with hash {safe_message_hash.hex()} for safe {safe_address} already exists in DB"
            )

        safe_signatures = SafeSignature.parse_signature(signature, safe_message_hash)
        if len(safe_signatures) != 1:
            raise ValidationError(
                f"1 owner signature was expected, {len(safe_signatures)} received"
            )

        ethereum_client = EthereumClientProvider()
        for safe_signature in safe_signatures:
            if not safe_signature.is_valid(ethereum_client, safe_address):
                raise ValidationError(
                    f"Signature={safe_signature.signature.hex()} for owner={safe_signature.owner} is not valid"
                )

        owners = get_safe_owners(safe_address)
        proposed_by = safe_signatures[0].owner
        if proposed_by not in owners:
            raise ValidationError(f"{proposed_by} is not an owner of the Safe")

        attrs["proposed_by"] = proposed_by
        attrs["signature_type"] = safe_signatures[0].signature_type.value
        return attrs

    def create(self, validated_data):
        signature = validated_data.pop("signature")
        signature_type = validated_data.pop("signature_type")

        safe_message = SafeMessage.objects.create(**validated_data)
        SafeMessageConfirmation.objects.create(
            safe_message=safe_message,
            owner=validated_data["proposed_by"],
            signature=signature,
            signature_type=signature_type,
        )
        return safe_message

class SafeMessageSignatureSerializer(serializers.Serializer):
    signature = eth_serializers.HexadecimalField(max_length=65)

    def validate(self, attrs):
        attrs = super().validate(attrs)

        safe_message: SafeMessage = self.context["safe_message"]
        attrs["safe_message"] = safe_message
        signature: HexStr = attrs["signature"]
        safe_address = safe_message.safe
        safe_message_hash = safe_message.message_hash

        safe_signatures = SafeSignature.parse_signature(signature, safe_message_hash)
        if len(safe_signatures) != 1:
            raise ValidationError(
                f"1 owner signature was expected, {len(safe_signatures)} received"
            )

        ethereum_client = EthereumClientProvider()
        for safe_signature in safe_signatures:
            if not safe_signature.is_valid(ethereum_client, safe_address):
                raise ValidationError(
                    f"Signature={safe_signature.signature.hex()} for owner={safe_signature.owner} is not valid"
                )

        owner = safe_signatures[0].owner
        if SafeMessageConfirmation.objects.filter(
            safe_message=safe_message, owner=owner
        ).exists():
            raise ValidationError(f"Signature for owner {owner} already exists")

        owners = get_safe_owners(safe_address)
        if owner not in owners:
            raise ValidationError(f"{owner} is not an owner of the Safe")

        attrs["owner"] = owner
        attrs["signature_type"] = safe_signatures[0].signature_type.value
        return attrs

    def create(self, validated_data):
        safe_message_confirmation = SafeMessageConfirmation.objects.create(
            **validated_data
        )
        safe_message = validated_data["safe_message"]
        SafeMessage.objects.filter(pk=safe_message.pk).update(
            modified=safe_message_confirmation.modified
        )
        return safe_message_confirmation

# Reponse serializers
class SafeMessageConfirmationResponseSerializer(serializers.Serializer):
    created = serializers.DateTimeField()
    modified = serializers.DateTimeField()
    owner = eth_serializers.EthereumAddressField()
    signature = eth_serializers.HexadecimalField()
    signature_type = serializers.SerializerMethodField()

    def get_signature_type(self, obj: SafeMessageConfirmation) -> str:
        return SafeSignatureType(obj.signature_type).name

class SafeMessageResponseSerializer(serializers.Serializer):
    created = serializers.DateTimeField()
    modified = serializers.DateTimeField()
    safe = eth_serializers.EthereumAddressField()
    message_hash = eth_serializers.Sha3HashField()
    message = serializers.JSONField()
    proposed_by = eth_serializers.EthereumAddressField()
    safe_app_id = serializers.IntegerField()
    confirmations = serializers.SerializerMethodField()
    prepared_signature = serializers.SerializerMethodField()

    def get_confirmations(self, obj: SafeMessage) -> Dict[str, Any]:
        """
        Filters confirmations queryset

        :param obj: SafeMessage instance
        :return: Serialized queryset
        """
        return SafeMessageConfirmationResponseSerializer(
            obj.confirmations, many=True
        ).data

    def get_prepared_signature(self, obj: SafeMessage) -> Optional[str]:
        """
        Prepared signature sorted

        :param obj: SafeMessage instance
        :return: Serialized queryset
        """
        signature = HexBytes(obj.build_signature())
        return HexBytes(signature).hex() if signature else None

'''
'''--- safe_transaction_service/safe_messages/signals.py ---
import logging

logger = logging.getLogger(__name__)

'''
'''--- safe_transaction_service/safe_messages/tasks.py ---

'''
'''--- safe_transaction_service/safe_messages/tests/__init__.py ---

'''
'''--- safe_transaction_service/safe_messages/tests/factories.py ---
import factory
from eth_account import Account
from factory.django import DjangoModelFactory

from ..models import SafeMessage, SafeMessageConfirmation
from ..utils import get_safe_message_hash_for_message

class SafeMessageFactory(DjangoModelFactory):
    class Meta:
        model = SafeMessage

    safe = factory.LazyFunction(lambda: Account.create().address)
    message = factory.Sequence(lambda n: f"message-{n}")
    proposed_by = factory.LazyFunction(lambda: Account.create().address)
    safe_app_id = factory.Sequence(lambda n: n)

    @factory.lazy_attribute
    def message_hash(self):
        return get_safe_message_hash_for_message(self.safe, self.message).hex()

class SafeMessageConfirmationFactory(DjangoModelFactory):
    class Meta:
        model = SafeMessageConfirmation

    class Params:
        signing_owner = Account.create()

    safe_message = factory.SubFactory(SafeMessageFactory)
    owner = factory.LazyAttribute(lambda o: o.signing_owner.address)
    signature = factory.LazyAttribute(
        lambda o: o.signing_owner.signHash(o.safe_message.message_hash)[
            "signature"
        ].hex()
    )
    signature_type = 2

'''
'''--- safe_transaction_service/safe_messages/tests/mocks.py ---
def get_eip712_payload_mock():
    address = "0x8e12f01dae5fe7f1122dc42f2cb084f2f9e8aa03"
    types = {
        "EIP712Domain": [
            {"name": "name", "type": "string"},
            {"name": "version", "type": "string"},
            {"name": "chainId", "type": "uint256"},
            {"name": "verifyingContract", "type": "address"},
        ],
        "Mailbox": [
            {"name": "owner", "type": "address"},
            {"name": "messages", "type": "Message[]"},
        ],
        "Message": [
            {"name": "sender", "type": "address"},
            {"name": "subject", "type": "string"},
            {"name": "isSpam", "type": "bool"},
            {"name": "body", "type": "string"},
        ],
    }

    msgs = [
        {
            "sender": address,
            "subject": "Hello World",
            "body": "The sparrow flies at midnight.",
            "isSpam": False,
        },
        {
            "sender": address,
            "subject": "You may have already Won! :dumb-emoji:",
            "body": "Click here for sweepstakes!",
            "isSpam": True,
        },
    ]

    mailbox = {"owner": address, "messages": msgs}

    payload = {
        "types": types,
        "primaryType": "Mailbox",
        "domain": {
            "name": "MyDApp",
            "version": "3.0",
            "chainId": 41,
            "verifyingContract": address,
        },
        "message": mailbox,
    }

    return payload

'''
'''--- safe_transaction_service/safe_messages/tests/test_models.py ---
from django.test import TestCase

from eth_account import Account
from hexbytes import HexBytes

from ..utils import get_safe_message_hash_for_message
from .factories import SafeMessageConfirmationFactory, SafeMessageFactory
from .mocks import get_eip712_payload_mock

class TestSafeMessage(TestCase):
    def test_str(self):
        # Use same safe_address so hash is always the same
        safe_address = "0x20a3C95188E1c053800e54575A508baCe65761A7"
        for input, expected in [
            (
                "TestMessage",
                "Safe Message 0xb04a24aa07a51d1d8c3913e9493b3b1f88ed6a8a75430a9a8eda3ed3ce1897bc - TestMessage",
            ),
            (
                "TestMessageVeryLong",
                "Safe Message 0xe3db816540ce371e2703b8ec59bdd6fec32e0c6078f2e204a205fd6d81564f28 - TestMessageVery...",
            ),
            (
                get_eip712_payload_mock(),
                "Safe Message 0xa960d416fc18f98d50878ab11a1991b70c0da13ccc15f7ba0100aeb63f6a0c24 - {'types': {'EIP...",
            ),
        ]:
            with self.subTest(input=input):
                safe_message = SafeMessageFactory(safe=safe_address, message=input)
                self.assertEqual(str(safe_message), expected)

    def test_factory(self):
        # 0x63EB7d344c819caAC85bAa1C28cC4C2c08776495
        owner_1_account = Account.from_key(
            "0x4923c57f121449492c2be3c8355904b5286b2486be9d1ff0241e29650c5f589d"
        )
        # 0x3456cbF38287EE5CAa40492e4Abf6319496c2B84
        owner_2_account = Account.from_key(
            "0xfe4a966a3bc93ccad16e2eacb867ba14f06cdf9a9957e6f0fdef1619494471df"
        )

        safe_message_confirmation_1 = SafeMessageConfirmationFactory(
            signing_owner=owner_1_account
        )
        safe_message = safe_message_confirmation_1.safe_message
        message = safe_message.message
        message_hash = safe_message.message_hash
        self.assertEqual(
            message_hash,
            get_safe_message_hash_for_message(safe_message.safe, message).hex(),
        )
        recovered_owner = Account.recoverHash(
            safe_message.message_hash,
            signature=safe_message_confirmation_1.signature,
        )
        self.assertEqual(
            safe_message_confirmation_1.owner,
            recovered_owner,
            "0x63EB7d344c819caAC85bAa1C28cC4C2c08776495",
        )
        self.assertEqual(
            safe_message.build_signature(),
            HexBytes(safe_message_confirmation_1.signature),
        )

        # Check building of signatures sorted
        safe_message_confirmation_2 = SafeMessageConfirmationFactory(
            signing_owner=owner_2_account, safe_message=safe_message
        )
        recovered_owner = Account.recoverHash(
            safe_message.message_hash,
            signature=safe_message_confirmation_2.signature,
        )
        self.assertEqual(
            safe_message_confirmation_2.owner,
            recovered_owner,
            "0x3456cbF38287EE5CAa40492e4Abf6319496c2B84",
        )
        # Signatures must be sorted as owner_2 < owner1
        expected_signature = HexBytes(safe_message_confirmation_2.signature) + HexBytes(
            safe_message_confirmation_1.signature
        )
        self.assertEqual(safe_message.build_signature(), expected_signature)

'''
'''--- safe_transaction_service/safe_messages/tests/test_views.py ---
import datetime
import logging
from unittest import mock
from unittest.mock import MagicMock

from django.urls import reverse

from eth_account import Account
from eth_account.messages import defunct_hash_message
from rest_framework import status
from rest_framework.exceptions import ErrorDetail
from rest_framework.test import APITestCase

from gnosis.eth.eip712 import eip712_encode_hash
from gnosis.eth.tests.ethereum_test_case import EthereumTestCaseMixin
from gnosis.safe import Safe
from gnosis.safe.safe_signature import SafeSignatureEOA

from safe_transaction_service.safe_messages.models import (
    SafeMessage,
    SafeMessageConfirmation,
)
from safe_transaction_service.safe_messages.tests.factories import (
    SafeMessageConfirmationFactory,
    SafeMessageFactory,
)

from .mocks import get_eip712_payload_mock

logger = logging.getLogger(__name__)

def datetime_to_str(value: datetime.datetime) -> str:
    value = value.isoformat()
    if value.endswith("+00:00"):
        value = value[:-6] + "Z"
    return value

class TestMessageViews(EthereumTestCaseMixin, APITestCase):
    def test_safe_message_view(self):
        random_safe_message_hash = (
            "0x8aca9664752dbae36135fd0956c956fc4a370feeac67485b49bcd4b99608ae41"
        )
        response = self.client.get(
            reverse("v1:safe_messages:message", args=(random_safe_message_hash,))
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertEqual(response.json(), {"detail": "Not found."})

        safe_message = SafeMessageFactory()
        response = self.client.get(
            reverse("v1:safe_messages:message", args=(safe_message.message_hash,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.json(),
            {
                "created": datetime_to_str(safe_message.created),
                "modified": datetime_to_str(safe_message.modified),
                "safe": safe_message.safe,
                "messageHash": safe_message.message_hash,
                "message": safe_message.message,
                "proposedBy": safe_message.proposed_by,
                "safeAppId": safe_message.safe_app_id,
                "preparedSignature": None,
                "confirmations": [],
            },
        )

        # Add a confirmation
        safe_message_confirmation = SafeMessageConfirmationFactory(
            safe_message=safe_message
        )
        response = self.client.get(
            reverse("v1:safe_messages:message", args=(safe_message.message_hash,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.json(),
            {
                "created": datetime_to_str(safe_message.created),
                "modified": datetime_to_str(safe_message.modified),
                "safe": safe_message.safe,
                "messageHash": safe_message.message_hash,
                "message": safe_message.message,
                "proposedBy": safe_message.proposed_by,
                "safeAppId": safe_message.safe_app_id,
                "preparedSignature": safe_message_confirmation.signature,
                "confirmations": [
                    {
                        "created": datetime_to_str(safe_message_confirmation.created),
                        "modified": datetime_to_str(safe_message_confirmation.modified),
                        "owner": safe_message_confirmation.owner,
                        "signature": safe_message_confirmation.signature,
                        "signatureType": "EOA",
                    }
                ],
            },
        )

    def test_safe_message_not_camel_case_view(self):
        safe_message_confirmation = SafeMessageConfirmationFactory()
        safe_message = safe_message_confirmation.safe_message
        safe_message.message = {"test_not_camel": 2}
        safe_message.save(update_fields=["message"])

        # Response message should not be camelcased
        response = self.client.get(
            reverse("v1:safe_messages:message", args=(safe_message.message_hash,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.json(),
            {
                "created": datetime_to_str(safe_message.created),
                "modified": datetime_to_str(safe_message.modified),
                "safe": safe_message.safe,
                "messageHash": safe_message.message_hash,
                "message": safe_message.message,
                "proposedBy": safe_message.proposed_by,
                "safeAppId": safe_message.safe_app_id,
                "preparedSignature": safe_message_confirmation.signature,
                "confirmations": [
                    {
                        "created": datetime_to_str(safe_message_confirmation.created),
                        "modified": datetime_to_str(safe_message_confirmation.modified),
                        "owner": safe_message_confirmation.owner,
                        "signature": safe_message_confirmation.signature,
                        "signatureType": "EOA",
                    }
                ],
            },
        )

    @mock.patch(
        "safe_transaction_service.safe_messages.serializers.get_safe_owners",
    )
    def test_safe_messages_create_view(self, get_owners_mock: MagicMock):
        account = Account.create()
        safe_address = Account.create().address
        messages = ["Text to sign message", get_eip712_payload_mock()]
        description = "Testing EIP191 message signing"
        message_hashes = [
            defunct_hash_message(text=messages[0]),
            eip712_encode_hash(messages[1]),
        ]
        safe = Safe(safe_address, self.ethereum_client)
        safe_message_hashes = [
            safe.get_message_hash(message_hash) for message_hash in message_hashes
        ]
        signatures = [
            account.signHash(safe_message_hash)["signature"].hex()
            for safe_message_hash in safe_message_hashes
        ]

        sub_tests = ["create_eip191", "create_eip712"]

        for sub_test, message, message_hash, safe_message_hash, signature in zip(
            sub_tests, messages, message_hashes, safe_message_hashes, signatures
        ):
            SafeMessage.objects.all().delete()
            get_owners_mock.return_value = []
            with self.subTest(
                sub_test,
                message=message,
                message_hash=message_hash,
                safe_message_hash=safe_message_hash,
                signature=signature,
            ):
                data = {
                    "message": message,
                    "description": description,
                    "signature": signature,
                }
                response = self.client.post(
                    reverse("v1:safe_messages:safe-messages", args=(safe_address,)),
                    format="json",
                    data=data,
                )
                self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
                self.assertEqual(
                    response.data,
                    {
                        "non_field_errors": [
                            ErrorDetail(
                                string=f"{account.address} is not an owner of the Safe",
                                code="invalid",
                            )
                        ]
                    },
                )

                # Test not valid signature
                with mock.patch.object(
                    SafeSignatureEOA, "is_valid", return_value=False
                ):
                    response = self.client.post(
                        reverse("v1:safe_messages:safe-messages", args=(safe_address,)),
                        format="json",
                        data=data,
                    )
                    self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
                    self.assertEqual(
                        response.data,
                        {
                            "non_field_errors": [
                                ErrorDetail(
                                    string=f'Signature={data["signature"]} for owner={account.address} is not valid',
                                    code="invalid",
                                )
                            ]
                        },
                    )

                get_owners_mock.return_value = [account.address]
                response = self.client.post(
                    reverse("v1:safe_messages:safe-messages", args=(safe_address,)),
                    format="json",
                    data=data,
                )
                self.assertEqual(response.status_code, status.HTTP_201_CREATED)
                self.assertEqual(SafeMessage.objects.count(), 1)
                self.assertEqual(SafeMessageConfirmation.objects.count(), 1)

                response = self.client.post(
                    reverse("v1:safe_messages:safe-messages", args=(safe_address,)),
                    format="json",
                    data=data,
                )
                self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
                self.assertEqual(
                    response.data,
                    {
                        "non_field_errors": [
                            ErrorDetail(
                                string=f"Message with hash {safe_message_hash.hex()} for safe {safe_address} already exists in DB",
                                code="invalid",
                            )
                        ]
                    },
                )

    @mock.patch(
        "safe_transaction_service.safe_messages.serializers.get_safe_owners",
        return_value=[],
    )
    def test_safe_message_add_signature_view(self, get_owners_mock: MagicMock):
        # Test not existing message
        safe_message_hash = (
            "0x8aca9664752dbae36135fd0956c956fc4a370feeac67485b49bcd4b99608ae41"
        )
        data = {"signature": "0x12"}
        response = self.client.post(
            reverse("v1:safe_messages:signatures", args=(safe_message_hash,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)

        # Test invalid signature
        safe_message_confirmation = SafeMessageConfirmationFactory()
        safe_message = safe_message_confirmation.safe_message
        response = self.client.post(
            reverse("v1:safe_messages:signatures", args=(safe_message.message_hash,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(
            response.data,
            {
                "non_field_errors": [
                    ErrorDetail(
                        string="1 owner signature was expected, 0 received",
                        code="invalid",
                    )
                ]
            },
        )

        # Test same signature
        data["signature"] = safe_message_confirmation.signature
        response = self.client.post(
            reverse("v1:safe_messages:signatures", args=(safe_message.message_hash,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(
            response.data,
            {
                "non_field_errors": [
                    ErrorDetail(
                        string=f"Signature for owner {safe_message_confirmation.owner} already exists",
                        code="invalid",
                    )
                ]
            },
        )

        # Test not existing owner
        owner_account = Account.create()
        data["signature"] = owner_account.signHash(safe_message.message_hash)[
            "signature"
        ].hex()
        response = self.client.post(
            reverse("v1:safe_messages:signatures", args=(safe_message.message_hash,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(
            response.data,
            {
                "non_field_errors": [
                    ErrorDetail(
                        string=f"{owner_account.address} is not an owner of the Safe",
                        code="invalid",
                    )
                ]
            },
        )

        # Test valid owner
        get_owners_mock.return_value = [owner_account.address]
        response = self.client.post(
            reverse("v1:safe_messages:signatures", args=(safe_message.message_hash,)),
            format="json",
            data=data,
        )
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(SafeMessage.objects.count(), 1)
        self.assertEqual(SafeMessageConfirmation.objects.count(), 2)
        safe_message_confirmation = SafeMessageConfirmation.objects.get(
            safe_message__safe=safe_message.safe, owner=owner_account.address
        )

        # Check SafeMessage modified was updated with new signature
        safe_message_modified = safe_message.modified
        safe_message.refresh_from_db()
        self.assertGreater(safe_message.modified, safe_message_modified)
        self.assertEqual(safe_message_confirmation.modified, safe_message.modified)

    def test_safe_messages_list_view(self):
        safe_address = Account.create().address
        response = self.client.get(
            reverse("v1:safe_messages:safe-messages", args=(safe_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.json(), {"count": 0, "next": None, "previous": None, "results": []}
        )

        # Create a Safe message for a random Safe, it should not appear
        safe_message = SafeMessageFactory()
        response = self.client.get(
            reverse("v1:safe_messages:safe-messages", args=(safe_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.json(), {"count": 0, "next": None, "previous": None, "results": []}
        )

        response = self.client.get(
            reverse("v1:safe_messages:safe-messages", args=(safe_message.safe,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.json(),
            {
                "count": 1,
                "next": None,
                "previous": None,
                "results": [
                    {
                        "created": datetime_to_str(safe_message.created),
                        "modified": datetime_to_str(safe_message.modified),
                        "safe": safe_message.safe,
                        "messageHash": safe_message.message_hash,
                        "message": safe_message.message,
                        "proposedBy": safe_message.proposed_by,
                        "safeAppId": safe_message.safe_app_id,
                        "preparedSignature": None,
                        "confirmations": [],
                    }
                ],
            },
        )

        # Add a confirmation
        safe_message_confirmation = SafeMessageConfirmationFactory(
            safe_message=safe_message
        )
        response = self.client.get(
            reverse("v1:safe_messages:safe-messages", args=(safe_message.safe,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.json(),
            {
                "count": 1,
                "next": None,
                "previous": None,
                "results": [
                    {
                        "created": datetime_to_str(safe_message.created),
                        "modified": datetime_to_str(safe_message.modified),
                        "safe": safe_message.safe,
                        "messageHash": safe_message.message_hash,
                        "message": safe_message.message,
                        "proposedBy": safe_message.proposed_by,
                        "safeAppId": safe_message.safe_app_id,
                        "preparedSignature": safe_message_confirmation.signature,
                        "confirmations": [
                            {
                                "created": datetime_to_str(
                                    safe_message_confirmation.created
                                ),
                                "modified": datetime_to_str(
                                    safe_message_confirmation.modified
                                ),
                                "owner": safe_message_confirmation.owner,
                                "signature": safe_message_confirmation.signature,
                                "signatureType": "EOA",
                            }
                        ],
                    }
                ],
            },
        )

    def test_safe_messages_list_not_camel_case_view(self):
        safe_message_confirmation = SafeMessageConfirmationFactory()
        safe_message = safe_message_confirmation.safe_message
        safe_message.message = {"test_not_camel": 2}
        safe_message.save(update_fields=["message"])

        # Response message should not be camelcased
        response = self.client.get(
            reverse("v1:safe_messages:safe-messages", args=(safe_message.safe,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.json(),
            {
                "count": 1,
                "next": None,
                "previous": None,
                "results": [
                    {
                        "created": datetime_to_str(safe_message.created),
                        "modified": datetime_to_str(safe_message.modified),
                        "safe": safe_message.safe,
                        "messageHash": safe_message.message_hash,
                        "message": safe_message.message,
                        "proposedBy": safe_message.proposed_by,
                        "safeAppId": safe_message.safe_app_id,
                        "preparedSignature": safe_message_confirmation.signature,
                        "confirmations": [
                            {
                                "created": datetime_to_str(
                                    safe_message_confirmation.created
                                ),
                                "modified": datetime_to_str(
                                    safe_message_confirmation.modified
                                ),
                                "owner": safe_message_confirmation.owner,
                                "signature": safe_message_confirmation.signature,
                                "signatureType": "EOA",
                            }
                        ],
                    }
                ],
            },
        )

'''
'''--- safe_transaction_service/safe_messages/urls.py ---
from django.urls import include, path

from . import views

app_name = "safe_messages"

extra_patterns = [
    path("<str:message_hash>/", views.SafeMessageView.as_view(), name="message"),
    path(
        "<str:message_hash>/signatures/",
        views.SafeMessageSignatureView.as_view(),
        name="signatures",
    ),
]

urlpatterns = [
    path("messages/", include(extra_patterns)),
    path(
        "safes/<str:address>/messages/",
        views.SafeMessagesView.as_view(),
        name="safe-messages",
    ),
]

'''
'''--- safe_transaction_service/safe_messages/utils.py ---
from typing import Any, Dict

from eth_account.messages import defunct_hash_message
from eth_typing import ChecksumAddress, Hash32

from gnosis.eth import EthereumClientProvider
from gnosis.eth.eip712 import eip712_encode_hash
from gnosis.safe import Safe

def get_safe_message_hash_for_message(
    safe_address: ChecksumAddress, message: str | Dict[str, Any]
) -> Hash32:
    message_hash: Hash32 = (
        defunct_hash_message(text=message)
        if isinstance(message, str)
        else eip712_encode_hash(message)
    )
    safe = Safe(safe_address, EthereumClientProvider())
    return safe.get_message_hash(message_hash)

'''
'''--- safe_transaction_service/safe_messages/views.py ---
from django.shortcuts import get_object_or_404

import django_filters
from djangorestframework_camel_case.parser import CamelCaseJSONParser
from djangorestframework_camel_case.render import CamelCaseJSONRenderer
from drf_yasg.utils import swagger_auto_schema
from rest_framework import status
from rest_framework.filters import OrderingFilter
from rest_framework.generics import CreateAPIView, ListCreateAPIView, RetrieveAPIView
from rest_framework.response import Response

from gnosis.eth.utils import fast_is_checksum_address

from . import pagination, serializers
from .models import SafeMessage

class DisableCamelCaseForMessageParser(CamelCaseJSONParser):
    json_underscoreize = {"ignore_fields": ("message",)}

class DisableCamelCaseForMessageRenderer(CamelCaseJSONRenderer):
    json_underscoreize = {"ignore_fields": ("message",)}

class SafeMessageView(RetrieveAPIView):
    lookup_url_kwarg = "message_hash"
    queryset = SafeMessage.objects.prefetch_related("confirmations")
    serializer_class = serializers.SafeMessageResponseSerializer
    renderer_classes = (DisableCamelCaseForMessageRenderer,)

class SafeMessageSignatureView(CreateAPIView):
    serializer_class = serializers.SafeMessageSignatureSerializer

    def get_serializer_context(self):
        context = super().get_serializer_context()
        if getattr(self, "swagger_fake_view", False):
            return context

        context["safe_message"] = get_object_or_404(
            SafeMessage, pk=self.kwargs["message_hash"]
        )
        return context

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        return Response(status=status.HTTP_201_CREATED)

class SafeMessagesView(ListCreateAPIView):
    filter_backends = [
        django_filters.rest_framework.DjangoFilterBackend,
        OrderingFilter,
    ]
    ordering = ["-created"]
    ordering_fields = ["created", "modified"]
    pagination_class = pagination.DefaultPagination
    parser_classes = (DisableCamelCaseForMessageParser,)
    renderer_classes = (DisableCamelCaseForMessageRenderer,)

    def get_serializer_context(self):
        context = super().get_serializer_context()
        if getattr(self, "swagger_fake_view", False):
            return context

        context["safe_address"] = self.kwargs["address"]
        return context

    def get_serializer_class(self):
        if self.request.method == "GET":
            return serializers.SafeMessageResponseSerializer
        elif self.request.method == "POST":
            return serializers.SafeMessageSerializer

    def get(self, request, address, *args, **kwargs):
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )
        return super().get(request, address, *args, **kwargs)

    @swagger_auto_schema(
        request_body=serializers.SafeMessageSerializer,
        responses={201: serializers.SafeMessageResponseSerializer},
    )
    def post(self, request, address, *args, **kwargs):
        if not fast_is_checksum_address(address):
            return Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Checksum address validation failed",
                    "arguments": [address],
                },
            )
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        return Response(status=status.HTTP_201_CREATED)

    def get_queryset(self):
        safe = self.kwargs["address"]
        return SafeMessage.objects.filter(safe=safe).prefetch_related("confirmations")

'''
'''--- safe_transaction_service/static/safe/logo.svg ---
<?xml version="1.0" encoding="UTF-8"?><svg id="Layer_2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1000 1000"><defs><style>.cls-1{fill:none;}.cls-2{fill:url(#linear-gradient);}.cls-3{clip-path:url(#clippath);}.cls-4{fill:#121312;}</style><clipPath id="clippath"><circle class="cls-1" cx="500" cy="500" r="500"/></clipPath><linearGradient id="linear-gradient" x1="-14.94" y1="914.64" x2="1159.05" y2="-86.81" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#12ff80"/><stop offset=".13" stop-color="#15fd85"/><stop offset=".29" stop-color="#1ff896"/><stop offset=".49" stop-color="#30f1b2"/><stop offset=".69" stop-color="#48e7d9"/><stop offset=".87" stop-color="#5fddff"/></linearGradient></defs><g id="Layer_1-2"><g class="cls-3"><rect class="cls-2" x="-48" y="-81.5" width="1050" height="1153"/></g><g><path class="cls-4" d="M780.07,499.81h-68.31c-20.4,0-36.93,16.54-36.93,36.93v99.14c0,20.4-16.54,36.93-36.93,36.93H366.13c-20.4,0-36.93,16.54-36.93,36.93v68.31c0,20.4,16.54,36.93,36.93,36.93h287.5c20.4,0,36.71-16.54,36.71-36.93v-54.8c0-20.4,16.54-34.88,36.93-34.88h52.8c20.4,0,36.93-16.54,36.93-36.93v-115.14c0-20.4-16.54-36.5-36.93-36.5Z"/><path class="cls-4" d="M329.18,364.11c0-20.4,16.54-36.93,36.93-36.93h271.6c20.4,0,36.93-16.54,36.93-36.93v-68.31c0-20.4-16.54-36.93-36.93-36.93H350.37c-20.4,0-36.93,16.54-36.93,36.93v52.63c0,20.4-16.54,36.93-36.93,36.93h-52.57c-20.4,0-36.93,16.54-36.93,36.93v115.26c0,20.4,16.6,36.1,37,36.1h68.31c20.4,0,36.93-16.54,36.93-36.93l-.06-98.74Z"/><path class="cls-4" d="M469.85,428.01h65.62c21.38,0,38.74,17.36,38.74,38.74v65.62c0,21.38-17.36,38.74-38.74,38.74h-65.62c-21.38,0-38.74-17.36-38.74-38.74v-65.62c0-21.38,17.36-38.74,38.74-38.74Z"/></g></g></svg>
'''
'''--- safe_transaction_service/templates/drf-yasg/swagger-ui.html ---
{% extends "drf-yasg/swagger-ui.html" %}
{% load static %}

{% block favicon %}
    <link rel="icon" type="image/png" href="{% static 'safe/favicon.png' %}"/>
{% endblock %}

{% block main_styles %}
    <link rel="stylesheet" type="text/css" href="{% static 'drf-yasg/style.css' %}"/>
    <link rel="stylesheet" type="text/css" href="{% static 'drf-yasg/swagger-ui-dist/swagger-ui.css' %}">
    <style>
        .swagger-ui .topbar {background-color: black;}
        .swagger-ui .topbar .download-url-wrapper .download-url-button {background-color: #008c73;}
        .swagger-ui .topbar .download-url-wrapper input[type=text] {border: 2px solid #008c73;}

	.topbar-wrapper img[alt="Swagger UI"], .topbar-wrapper span {
	   visibility: collapse;
	}

	.topbar-wrapper .link:before {
	   content: url("{% static 'safe/logo.png' %}");
	}

    </style>
{% endblock %}

'''
'''--- safe_transaction_service/tokens/__init__.py ---

'''
'''--- safe_transaction_service/tokens/admin.py ---
from django.contrib import admin

from gnosis.eth.django.admin import BinarySearchAdmin

from safe_transaction_service.utils.admin import HasLogoFilterAdmin

from .models import Token

@admin.register(Token)
class TokenAdmin(BinarySearchAdmin):
    list_display = (
        "address",
        "trusted",
        "spam",
        "events_bugged",
        "name",
        "symbol",
        "decimals",
        "copy_price",
    )
    list_filter = ("trusted", "spam", "events_bugged", "decimals", HasLogoFilterAdmin)
    ordering = ("address",)
    search_fields = ["=address", "symbol", "name", "=copy_price"]

'''
'''--- safe_transaction_service/tokens/apps.py ---
from django.apps import AppConfig

class TokensConfig(AppConfig):
    name = "safe_transaction_service.tokens"
    verbose_name = "Tokens for Safe Transaction Service"

'''
'''--- safe_transaction_service/tokens/clients/__init__.py ---
# flake8: noqa F401
from .binance_client import BinanceClient
from .coingecko_client import CoingeckoClient
from .coinmarketcap_client import CoinMarketCapClient, CoinMarketCapToken
from .exceptions import CannotGetPrice
from .kleros_client import KlerosClient, KlerosToken
from .kraken_client import KrakenClient
from .kucoin_client import KucoinClient

'''
'''--- safe_transaction_service/tokens/clients/binance_client.py ---
import logging

import requests

from .exceptions import CannotGetPrice

logger = logging.getLogger(__name__)

class BinanceClient:  # pragma: no cover
    def __init__(self):
        self.http_session = requests.Session()

    def _get_price(self, symbol: str) -> float:
        url = f"https://api.binance.com/api/v3/avgPrice?symbol={symbol}"
        try:
            response = self.http_session.get(url, timeout=10)
            api_json = response.json()
            if not response.ok:
                logger.warning("Cannot get price from url=%s", url)
                raise CannotGetPrice(api_json.get("msg"))

            price = float(api_json["price"])
            if not price:
                raise CannotGetPrice(f"Price from url={url} is {price}")
            return price
        except (ValueError, IOError) as e:
            raise CannotGetPrice from e

    def get_ada_usd_price(self) -> float:
        return self._get_price("ADAUSDT")

    def get_aurora_usd_price(self):
        return self._get_price("NEARUSDT")

    def get_bnb_usd_price(self) -> float:
        return self._get_price("BNBUSDT")

    def get_eth_usd_price(self) -> float:
        """
        :return: current USD price for Ethereum
        :raises: CannotGetPrice
        """
        return self._get_price("ETHUSDT")

    def get_matic_usd_price(self) -> float:
        """
        :return: current USD price for MATIC
        :raises: CannotGetPrice
        """
        return self._get_price("MATICUSDT")

'''
'''--- safe_transaction_service/tokens/clients/coingecko_client.py ---
import logging
from functools import lru_cache
from typing import Any, Dict, Optional
from urllib.parse import urljoin

import requests
from eth_typing import ChecksumAddress

from gnosis.eth import EthereumNetwork

from safe_transaction_service.tokens.clients.exceptions import (
    CannotGetPrice,
    Coingecko404,
    CoingeckoRequestError,
)

logger = logging.getLogger(__name__)

class CoingeckoClient:
    base_url = "https://api.coingecko.com/"

    def __init__(self, network: Optional[EthereumNetwork] = None):
        self.http_session = requests.Session()
        if network == EthereumNetwork.ARBITRUM:
            self.asset_platform = "arbitrum-one"
        elif network == EthereumNetwork.AURORA:
            self.asset_platform = "aurora"
        elif network == EthereumNetwork.AVALANCHE:
            self.asset_platform = "avalanche"
        elif network == EthereumNetwork.BINANCE:
            self.asset_platform = "binance-smart-chain"
        elif network == EthereumNetwork.MATIC:
            self.asset_platform = "polygon-pos"
        elif network == EthereumNetwork.OPTIMISTIC:
            self.asset_platform = "optimistic-ethereum"
        elif network == EthereumNetwork.XDAI:
            self.asset_platform = "xdai"
        elif network == EthereumNetwork.FUSE_MAINNET:
            self.asset_platform = "fuse"
        elif network == EthereumNetwork.KCC_MAINNET:
            self.asset_platform = "kucoin-community-chain"
        elif network == EthereumNetwork.METIS:
            self.asset_platform = "metis-andromeda"
        else:
            self.asset_platform = "ethereum"

    @staticmethod
    def supports_network(network: EthereumNetwork):
        return network in (
            EthereumNetwork.ARBITRUM,
            EthereumNetwork.AURORA,
            EthereumNetwork.AVALANCHE,
            EthereumNetwork.BINANCE,
            EthereumNetwork.MAINNET,
            EthereumNetwork.MATIC,
            EthereumNetwork.OPTIMISTIC,
            EthereumNetwork.XDAI,
            EthereumNetwork.FUSE_MAINNET,
            EthereumNetwork.KCC_MAINNET,
            EthereumNetwork.METIS,
        )

    def _do_request(self, url: str) -> Dict[str, Any]:
        try:
            response = self.http_session.get(url, timeout=10)
            if not response.ok:
                if response.status_code == 404:
                    raise Coingecko404
                raise CoingeckoRequestError(url)
            return response.json()
        except (ValueError, IOError) as e:
            logger.warning("Problem fetching %s", url)
            raise CoingeckoRequestError from e

    def _get_price(self, url: str, name: str):
        try:
            result = self._do_request(url)

            # Result is returned with lowercased `name` (if querying by contract address, then `token_address`)
            price = result.get(name)
            if price and price.get("usd"):
                return price["usd"]
            else:
                raise CannotGetPrice(f"Price from url={url} is {price}")
        except CoingeckoRequestError as e:
            raise CannotGetPrice(
                f"Cannot get price from Coingecko for token={name}"
            ) from e

    def get_price(self, name: str) -> float:
        """
        :param name: coin name
        :return: usd price for token name, 0. if not found
        """
        name = name.lower()
        url = urljoin(
            self.base_url, f"/api/v3/simple/price?ids={name}&vs_currencies=usd"
        )
        return self._get_price(url, name)

    def get_token_price(self, token_address: ChecksumAddress) -> float:
        """
        :param token_address:
        :return: usd price for token address, 0. if not found
        """
        token_address = token_address.lower()
        url = urljoin(
            self.base_url,
            f"api/v3/simple/token_price/{self.asset_platform}?contract_addresses={token_address}&vs_currencies=usd",
        )
        return self._get_price(url, token_address)

    @lru_cache(maxsize=128)
    def get_token_info(
        self, token_address: ChecksumAddress
    ) -> Optional[Dict[str, Any]]:
        token_address = token_address.lower()
        url = urljoin(
            self.base_url,
            f"api/v3/coins/{self.asset_platform}/contract/{token_address}",
        )
        try:
            return self._do_request(url)
        except Coingecko404:
            return None

    def get_token_logo_url(self, token_address: ChecksumAddress) -> Optional[str]:
        token_info = self.get_token_info(token_address)
        if token_info:
            return token_info["image"]["large"]

    def get_ada_usd_price(self) -> float:
        return self.get_price("cardano")

    def get_avax_usd_price(self) -> float:
        return self.get_price("avalanche-2")

    def get_aoa_usd_price(self) -> float:
        return self.get_price("aurora")

    def get_bnb_usd_price(self) -> float:
        return self.get_price("binancecoin")

    def get_ewt_usd_price(self) -> float:
        return self.get_price("energy-web-token")

    def get_matic_usd_price(self) -> float:
        return self.get_price("matic-network")

    def get_gather_usd_price(self) -> float:
        return self.get_price("gather")

    def get_fuse_usd_price(self) -> float:
        return self.get_price("fuse-network-token")

    def get_kcs_usd_price(self) -> float:
        return self.get_price("kucoin-shares")

    def get_metis_usd_price(self) -> float:
        return self.get_price("metis-token")

'''
'''--- safe_transaction_service/tokens/clients/coinmarketcap_client.py ---
import logging
import os
from dataclasses import dataclass
from typing import Any, Dict, List
from urllib.parse import urljoin

import requests

from gnosis.eth.utils import fast_to_checksum_address

logger = logging.getLogger(__name__)

@dataclass
class CoinMarketCapToken:
    id: int  # CoinMarketCap id
    name: str
    symbol: str
    token_address: str  # For tokens
    logo_uri: str

class CoinMarketCapClient:
    base_url = "https://pro-api.coinmarketcap.com/"
    base_logo_uri = "https://s2.coinmarketcap.com/static/img/coins/200x200/"

    def __init__(self, api_token: str):
        self.api_token = api_token
        self.headers = {
            "Accepts": "application/json",
            "X-CMC_PRO_API_KEY": api_token,
        }
        self.http_session = requests.Session()

    def download_file(self, url: str, taget_folder: str, local_filename: str) -> str:
        if not os.path.exists(taget_folder):
            os.makedirs(taget_folder)
        with self.http_session.get(url, stream=True) as response:
            if not response.ok:
                logger.warning("Image not found for url %s", url)
                return None
            with open(os.path.join(taget_folder, local_filename), "wb") as f:
                for chunk in response.iter_content(chunk_size=1024):
                    if chunk:
                        f.write(chunk)
            return local_filename

    def get_map(self) -> List[Dict[str, Any]]:
        """
        [
            {'id': 1659,
             'name': 'Gnosis',
             'symbol': 'GNO',
             'slug': 'gnosis-gno',
             'is_active': 1,
             'rank': 137,
             'first_historical_data': '2017-05-01T20:09:54.000Z',
             'last_historical_data': '2020-06-15T09:24:12.000Z',
             'platform': {'id': 1027,
                          'name': 'Ethereum',
                          'symbol': 'ETH',
                          'slug': 'ethereum',
                          'token_address': '0x6810e776880c02933d47db1b9fc05908e5386b96'}
            }, ...
        ]
        :return:
        """
        relative_url = "v1/cryptocurrency/map"
        url = urljoin(self.base_url, relative_url)
        parameters = {
            # 'listing_status': 'active',
            # 'start': '1',
            "limit": "5000",
        }

        try:
            return (
                self.http_session.get(url, headers=self.headers, params=parameters)
                .json()
                .get("data", [])
            )
        except IOError:
            logger.warning("Problem getting tokens from coinmarketcap", exc_info=True)
            return []

    def get_ethereum_tokens(self) -> List[CoinMarketCapToken]:
        tokens = []
        for token in self.get_map():
            if (
                token
                and token["is_active"]
                and token["platform"]
                and token["platform"]["name"] == "Ethereum"
            ):
                try:
                    checksummed_address = fast_to_checksum_address(
                        token["platform"]["token_address"]
                    )
                    tokens.append(
                        CoinMarketCapToken(
                            token["id"],
                            token["name"],
                            token["symbol"],
                            checksummed_address,
                            urljoin(self.base_logo_uri, f'{token["id"]}.png'),
                        )
                    )
                except ValueError:
                    logger.warning(
                        "Invalid address %s for token %s with id %d",
                        token["platform"]["token_address"],
                        token["name"],
                        token["id"],
                    )

        return tokens

'''
'''--- safe_transaction_service/tokens/clients/exceptions.py ---
class CoingeckoRequestError(Exception):
    pass

class Coingecko404(CoingeckoRequestError):
    pass

class CannotGetPrice(CoingeckoRequestError):
    pass

'''
'''--- safe_transaction_service/tokens/clients/kleros_abi.py ---
kleros_abi = [
    {
        "constant": True,
        "inputs": [],
        "name": "challengePeriodDuration",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "governor",
        "outputs": [{"name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "arbitratorExtraData",
        "outputs": [{"name": "", "type": "bytes"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_beneficiary", "type": "address"},
            {"name": "_request", "type": "uint256"},
        ],
        "name": "amountWithdrawable",
        "outputs": [{"name": "total", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"name": "_sharedStakeMultiplier", "type": "uint256"}],
        "name": "changeSharedStakeMultiplier",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_beneficiary", "type": "address"},
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_cursor", "type": "uint256"},
            {"name": "_count", "type": "uint256"},
            {"name": "_roundCursor", "type": "uint256"},
            {"name": "_roundCount", "type": "uint256"},
        ],
        "name": "batchRequestWithdraw",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "loserStakeMultiplier",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "countByStatus",
        "outputs": [
            {"name": "absent", "type": "uint256"},
            {"name": "registered", "type": "uint256"},
            {"name": "registrationRequest", "type": "uint256"},
            {"name": "clearingRequest", "type": "uint256"},
            {"name": "challengedRegistrationRequest", "type": "uint256"},
            {"name": "challengedClearingRequest", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_side", "type": "uint8"},
        ],
        "name": "fundAppeal",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"name": "_tokenID", "type": "bytes32"}],
        "name": "getTokenInfo",
        "outputs": [
            {"name": "name", "type": "string"},
            {"name": "ticker", "type": "string"},
            {"name": "addr", "type": "address"},
            {"name": "symbolMultihash", "type": "string"},
            {"name": "status", "type": "uint8"},
            {"name": "numberOfRequests", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_disputeID", "type": "uint256"},
            {"name": "_ruling", "type": "uint256"},
        ],
        "name": "rule",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "challengerBaseDeposit",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"name": "_requesterBaseDeposit", "type": "uint256"}],
        "name": "changeRequesterBaseDeposit",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"name": "_cursor", "type": "bytes32"},
            {"name": "_count", "type": "uint256"},
            {"name": "_filter", "type": "bool[8]"},
            {"name": "_oldestFirst", "type": "bool"},
            {"name": "_tokenAddr", "type": "address"},
        ],
        "name": "queryTokens",
        "outputs": [
            {"name": "values", "type": "bytes32[]"},
            {"name": "hasMore", "type": "bool"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "sharedStakeMultiplier",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"name": "", "type": "address"}, {"name": "", "type": "uint256"}],
        "name": "arbitratorDisputeIDToTokenID",
        "outputs": [{"name": "", "type": "bytes32"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"name": "", "type": "uint256"}],
        "name": "tokensList",
        "outputs": [{"name": "", "type": "bytes32"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_request", "type": "uint256"},
            {"name": "_round", "type": "uint256"},
            {"name": "_contributor", "type": "address"},
        ],
        "name": "getContributions",
        "outputs": [{"name": "contributions", "type": "uint256[3]"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "arbitrator",
        "outputs": [{"name": "", "type": "address"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "metaEvidenceUpdates",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"name": "", "type": "address"}, {"name": "", "type": "uint256"}],
        "name": "addressToSubmissions",
        "outputs": [{"name": "", "type": "bytes32"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_beneficiary", "type": "address"},
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_request", "type": "uint256"},
            {"name": "_cursor", "type": "uint256"},
            {"name": "_count", "type": "uint256"},
        ],
        "name": "batchRoundWithdraw",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "winnerStakeMultiplier",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_evidence", "type": "string"},
        ],
        "name": "challengeRequest",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "requesterBaseDeposit",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"name": "", "type": "bytes32"}],
        "name": "tokens",
        "outputs": [
            {"name": "name", "type": "string"},
            {"name": "ticker", "type": "string"},
            {"name": "addr", "type": "address"},
            {"name": "symbolMultihash", "type": "string"},
            {"name": "status", "type": "uint8"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"name": "_loserStakeMultiplier", "type": "uint256"}],
        "name": "changeLoserStakeMultiplier",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_request", "type": "uint256"},
            {"name": "_round", "type": "uint256"},
        ],
        "name": "getRoundInfo",
        "outputs": [
            {"name": "appealed", "type": "bool"},
            {"name": "paidFees", "type": "uint256[3]"},
            {"name": "hasPaid", "type": "bool[3]"},
            {"name": "feeRewards", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "tokenCount",
        "outputs": [{"name": "count", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_name", "type": "string"},
            {"name": "_ticker", "type": "string"},
            {"name": "_addr", "type": "address"},
            {"name": "_symbolMultihash", "type": "string"},
        ],
        "name": "requestStatusChange",
        "outputs": [],
        "payable": True,
        "stateMutability": "payable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_beneficiary", "type": "address"},
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_request", "type": "uint256"},
            {"name": "_round", "type": "uint256"},
        ],
        "name": "withdrawFeesAndRewards",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"name": "_winnerStakeMultiplier", "type": "uint256"}],
        "name": "changeWinnerStakeMultiplier",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_arbitrator", "type": "address"},
            {"name": "_arbitratorExtraData", "type": "bytes"},
        ],
        "name": "changeArbitrator",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [{"name": "_tokenID", "type": "bytes32"}],
        "name": "isPermitted",
        "outputs": [{"name": "allowed", "type": "bool"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_request", "type": "uint256"},
        ],
        "name": "getRequestInfo",
        "outputs": [
            {"name": "disputed", "type": "bool"},
            {"name": "disputeID", "type": "uint256"},
            {"name": "submissionTime", "type": "uint256"},
            {"name": "resolved", "type": "bool"},
            {"name": "parties", "type": "address[3]"},
            {"name": "numberOfRounds", "type": "uint256"},
            {"name": "ruling", "type": "uint8"},
            {"name": "arbitrator", "type": "address"},
            {"name": "arbitratorExtraData", "type": "bytes"},
        ],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"name": "_challengePeriodDuration", "type": "uint256"}],
        "name": "changeTimeToChallenge",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "MULTIPLIER_DIVISOR",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": False,
        "stateMutability": "view",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_registrationMetaEvidence", "type": "string"},
            {"name": "_clearingMetaEvidence", "type": "string"},
        ],
        "name": "changeMetaEvidence",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"name": "_challengerBaseDeposit", "type": "uint256"}],
        "name": "changeChallengerBaseDeposit",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"name": "_governor", "type": "address"}],
        "name": "changeGovernor",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [{"name": "_tokenID", "type": "bytes32"}],
        "name": "executeRequest",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "constant": False,
        "inputs": [
            {"name": "_tokenID", "type": "bytes32"},
            {"name": "_evidence", "type": "string"},
        ],
        "name": "submitEvidence",
        "outputs": [],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"name": "_arbitrator", "type": "address"},
            {"name": "_arbitratorExtraData", "type": "bytes"},
            {"name": "_registrationMetaEvidence", "type": "string"},
            {"name": "_clearingMetaEvidence", "type": "string"},
            {"name": "_governor", "type": "address"},
            {"name": "_requesterBaseDeposit", "type": "uint256"},
            {"name": "_challengerBaseDeposit", "type": "uint256"},
            {"name": "_challengePeriodDuration", "type": "uint256"},
            {"name": "_sharedStakeMultiplier", "type": "uint256"},
            {"name": "_winnerStakeMultiplier", "type": "uint256"},
            {"name": "_loserStakeMultiplier", "type": "uint256"},
        ],
        "payable": False,
        "stateMutability": "nonpayable",
        "type": "constructor",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": False, "name": "_name", "type": "string"},
            {"indexed": False, "name": "_ticker", "type": "string"},
            {"indexed": False, "name": "_symbolMultihash", "type": "string"},
            {"indexed": True, "name": "_address", "type": "address"},
        ],
        "name": "TokenSubmitted",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "_tokenID", "type": "bytes32"},
            {"indexed": False, "name": "_registrationRequest", "type": "bool"},
        ],
        "name": "RequestSubmitted",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "_requester", "type": "address"},
            {"indexed": True, "name": "_challenger", "type": "address"},
            {"indexed": True, "name": "_tokenID", "type": "bytes32"},
            {"indexed": False, "name": "_status", "type": "uint8"},
            {"indexed": False, "name": "_disputed", "type": "bool"},
            {"indexed": False, "name": "_appealed", "type": "bool"},
        ],
        "name": "TokenStatusChange",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "_tokenID", "type": "bytes32"},
            {"indexed": True, "name": "_contributor", "type": "address"},
            {"indexed": True, "name": "_request", "type": "uint256"},
            {"indexed": False, "name": "_round", "type": "uint256"},
            {"indexed": False, "name": "_value", "type": "uint256"},
        ],
        "name": "RewardWithdrawal",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "_metaEvidenceID", "type": "uint256"},
            {"indexed": False, "name": "_evidence", "type": "string"},
        ],
        "name": "MetaEvidence",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "_arbitrator", "type": "address"},
            {"indexed": True, "name": "_disputeID", "type": "uint256"},
            {"indexed": False, "name": "_metaEvidenceID", "type": "uint256"},
            {"indexed": False, "name": "_evidenceGroupID", "type": "uint256"},
        ],
        "name": "Dispute",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "_arbitrator", "type": "address"},
            {"indexed": True, "name": "_evidenceGroupID", "type": "uint256"},
            {"indexed": True, "name": "_party", "type": "address"},
            {"indexed": False, "name": "_evidence", "type": "string"},
        ],
        "name": "Evidence",
        "type": "event",
    },
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "_arbitrator", "type": "address"},
            {"indexed": True, "name": "_disputeID", "type": "uint256"},
            {"indexed": False, "name": "_ruling", "type": "uint256"},
        ],
        "name": "Ruling",
        "type": "event",
    },
]

'''
'''--- safe_transaction_service/tokens/clients/kleros_client.py ---
from dataclasses import dataclass
from typing import List, Sequence

from gnosis.eth import EthereumClient
from gnosis.eth.constants import NULL_ADDRESS

from .kleros_abi import kleros_abi

@dataclass
class KlerosToken:
    name: str
    ticker: str
    address: str
    symbol_multihash: str
    status: int
    number_of_requests: int

class KlerosClient:
    """
    https://github.com/kleros/kleros-interaction/blob/master/contracts/standard/permission/ArbitrableTokenList.sol
    https://github.com/kleros/t2cr-badges-example/blob/master/docs/deep-dive.md
    """

    abi = kleros_abi
    mainnet_address = "0xEbcf3bcA271B26ae4B162Ba560e243055Af0E679"
    null_token_id = b"\x00" * 32  # Empty bytes32 for null tokens

    def __init__(self, ethereum_client: EthereumClient):
        self.ethereum_client = ethereum_client
        self.kleros_contract = ethereum_client.erc20.slow_w3.eth.contract(
            self.mainnet_address, abi=self.abi
        )

    def get_token_count(self) -> int:
        return self.kleros_contract.functions.tokenCount().call()

    def get_token_ids(self) -> Sequence[bytes]:
        """
        /** @dev Return the values of the tokens the query finds. This function is O(n), where n is the number
        of tokens. This could exceed the gas limit, therefore this function should only be used for interface
        display and not by other contracts.
             *  @param _cursor The ID of the token from which to start iterating. To start from either the oldest
             or newest item.
             *  @param _count The number of tokens to return.
             *  @param _filter The filter to use. Each element of the array in sequence means:
             *  - Include absent tokens in result.
             *  - Include registered tokens in result.
             *  - Include tokens with registration requests that are not disputed in result.
             *  - Include tokens with clearing requests that are not disputed in result.
             *  - Include disputed tokens with registration requests in result.
             *  - Include disputed tokens with clearing requests in result.
             *  - Include tokens submitted by the caller.
             *  - Include tokens challenged by the caller.
             *  @param _oldestFirst Whether to sort from oldest to the newest item.
             *  @param _tokenAddr A token address to filter submissions by address (optional).
             *  @return The values of the tokens found and whether there are more tokens for the current filter and sort.
             */
        """
        token_count = self.get_token_count()
        token_ids: List[bytes]
        has_more: bool
        token_ids, has_more = self.kleros_contract.functions.queryTokens(
            b"",
            token_count,
            [
                False,  # Include absent tokens in result.
                True,  # Include registered tokens in result.
                False,  # Include tokens with registration requests that are not disputed in result.
                False,  # Include tokens with clearing requests that are not disputed in result.
                False,  # Include disputed tokens with registration requests in result.
                False,  # Include disputed tokens with clearing requests in result.
                False,  # Include tokens submitted by the caller.
                False,  # Include tokens challenged by the caller.
            ],
            False,
            NULL_ADDRESS,
        ).call()
        return [token_id for token_id in token_ids if token_id != self.null_token_id]

    def get_token_info(self, token_ids: Sequence[bytes]) -> Sequence[KlerosToken]:
        queries = []
        for token_id in token_ids:
            queries.append(self.kleros_contract.functions.getTokenInfo(token_id))

        # name string, ticker string, addr address, symbolMultihash string, status uint8, numberOfRequests uint256
        token_infos = self.ethereum_client.batch_call(queries)
        return [KlerosToken(*token_info) for token_info in token_infos]

    def get_tokens_with_info(self) -> Sequence[KlerosToken]:
        return self.get_token_info(self.get_token_ids())

'''
'''--- safe_transaction_service/tokens/clients/kraken_client.py ---
import logging

import requests

from .exceptions import CannotGetPrice

logger = logging.getLogger(__name__)

class KrakenClient:
    def __init__(self):
        self.http_session = requests.Session()

    def _get_price(self, symbol: str) -> float:
        url = f"https://api.kraken.com/0/public/Ticker?pair={symbol}"
        try:
            response = self.http_session.get(url, timeout=10)
            api_json = response.json()
            error = api_json.get("error")
            if not response.ok or error:
                logger.warning("Cannot get price from url=%s", url)
                raise CannotGetPrice(str(api_json["error"]))

            result = api_json["result"]
            for new_ticker in result:
                price = float(result[new_ticker]["c"][0])
                if not price:
                    raise CannotGetPrice(f"Price from url={url} is {price}")
                return price
        except (ValueError, IOError) as e:
            raise CannotGetPrice from e

    def get_ada_usd_price(self) -> float:
        return self._get_price("ADAUSD")

    def get_avax_usd_price(self) -> float:
        """
        :return: current USD price for AVAX
        :raises: CannotGetPrice
        """
        return self._get_price("AVAXUSD")

    def get_dai_usd_price(self) -> float:
        """
        :return: current USD price for DAI
        :raises: CannotGetPrice
        """
        return self._get_price("DAIUSD")

    def get_eth_usd_price(self) -> float:
        """
        :return: current USD price for Ethereum
        :raises: CannotGetPrice
        """
        return self._get_price("ETHUSD")

    def get_matic_usd_price(self):
        """
        :return: current USD price for MATIC
        :raises: CannotGetPrice
        """
        return self._get_price("MATICUSD")

    def get_ewt_usd_price(self) -> float:
        """
        :return: current USD price for Energy Web Token
        :raises: CannotGetPrice
        """
        return self._get_price("EWTUSD")

    def get_algo_usd_price(self):
        """
        :return: current USD price for Algorand
        :raises: CannotGetPrice
        """
        return self._get_price("ALGOUSD")

'''
'''--- safe_transaction_service/tokens/clients/kucoin_client.py ---
import logging

import requests

from .exceptions import CannotGetPrice

logger = logging.getLogger(__name__)

class KucoinClient:
    def __init__(self):
        self.http_session = requests.Session()

    def _get_price(self, symbol: str):
        url = f"https://api.kucoin.com/api/v1/market/orderbook/level1?symbol={symbol}"

        try:
            response = self.http_session.get(url, timeout=10)
            result = response.json()
            return float(result["data"]["price"])
        except (ValueError, IOError) as e:
            logger.warning("Cannot get price from url=%s", url)
            raise CannotGetPrice from e

    def get_eth_usd_price(self) -> float:
        return self._get_price("ETH-USDT")

    def get_aurora_usd_price(self) -> float:
        return self._get_price("AURORA-USDT")

    def get_bnb_usd_price(self) -> float:
        return self._get_price("BNB-USDT")

    def get_ewt_usd_price(self) -> float:
        """
        :return: current USD price for Energy Web Token
        :raises: CannotGetPrice
        """
        return self._get_price("EWT-USDT")

    def get_cro_usd_price(self) -> float:
        """
        :return: current USD price for Cronos
        :raises: CannotGetPrice
        """
        return self._get_price("CRO-USDT")

    def get_kcs_usd_price(self) -> float:
        """
        :return: current USD price for KuCoin Token
        :raises: CannotGetPrice
        """
        return self._get_price("KCS-USDT")

    def get_matic_usd_price(self) -> float:
        return self._get_price("MATIC-USDT")

'''
'''--- safe_transaction_service/tokens/clients/zerion_client.py ---
from dataclasses import dataclass
from typing import List, Optional

from eth_typing import ChecksumAddress
from web3.exceptions import ContractLogicError

from gnosis.eth import EthereumClient
from gnosis.eth.constants import NULL_ADDRESS

@dataclass
class UniswapComponent:
    address: str
    tokenType: str  # `ERC20` by default
    rate: str  # price per full share (1e18)

@dataclass
class ZerionPoolMetadata:
    address: ChecksumAddress
    name: str
    symbol: str
    decimals: int

class ZerionTokenAdapterClient:
    """
    Client for Zerion Token Adapter
    https://github.com/zeriontech/defi-sdk
    """

    ABI = [
        {
            "inputs": [{"internalType": "address", "name": "token", "type": "address"}],
            "name": "getComponents",
            "outputs": [
                {
                    "components": [
                        {"internalType": "address", "name": "token", "type": "address"},
                        {
                            "internalType": "string",
                            "name": "tokenType",
                            "type": "string",
                        },
                        {"internalType": "uint256", "name": "rate", "type": "uint256"},
                    ],
                    "internalType": "struct Component[]",
                    "name": "",
                    "type": "tuple[]",
                }
            ],
            "stateMutability": "view",
            "type": "function",
        },
        {
            "inputs": [{"internalType": "address", "name": "token", "type": "address"}],
            "name": "getMetadata",
            "outputs": [
                {
                    "components": [
                        {"internalType": "address", "name": "token", "type": "address"},
                        {"internalType": "string", "name": "name", "type": "string"},
                        {"internalType": "string", "name": "symbol", "type": "string"},
                        {"internalType": "uint8", "name": "decimals", "type": "uint8"},
                    ],
                    "internalType": "struct TokenMetadata",
                    "name": "",
                    "type": "tuple",
                }
            ],
            "stateMutability": "view",
            "type": "function",
        },
    ]
    ADAPTER_ADDRESS: ChecksumAddress = ChecksumAddress(NULL_ADDRESS)

    def __init__(
        self,
        ethereum_client: EthereumClient,
        adapter_address: Optional[ChecksumAddress] = None,
    ):
        self.ethereum_client = ethereum_client
        self.adapter_address = (
            adapter_address if adapter_address else self.ADAPTER_ADDRESS
        )
        self.contract = ethereum_client.w3.eth.contract(
            self.adapter_address, abi=self.ABI
        )

    def get_components(
        self, token_address: ChecksumAddress
    ) -> Optional[List[UniswapComponent]]:
        try:
            return [
                UniswapComponent(*component)
                for component in self.contract.functions.getComponents(
                    token_address
                ).call()
            ]
        except ContractLogicError:
            return None

    def get_metadata(
        self, token_address: ChecksumAddress
    ) -> Optional[ZerionPoolMetadata]:
        try:
            return ZerionPoolMetadata(
                *self.contract.functions.getMetadata(token_address).call()
            )
        except ContractLogicError:
            return None

class ZerionUniswapV2TokenAdapterClient(ZerionTokenAdapterClient):
    ADAPTER_ADDRESS: ChecksumAddress = ChecksumAddress(
        "0x6C5D49157863f942A5E6115aaEAb7d6A67a852d3"
    )

class BalancerTokenAdapterClient(ZerionTokenAdapterClient):
    ADAPTER_ADDRESS: ChecksumAddress = ChecksumAddress(
        "0xb45c5AE417F70E4C52DFB784569Ce843a45FE8ca"
    )

'''
'''--- safe_transaction_service/tokens/constants.py ---
CRYPTO_KITTIES_CONTRACT_ADDRESSES = {
    "0x06012c8cf97BEaD5deAe237070F9587f8E7A266d",  # Mainnet
    "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",  # Rinkeby
}

ENS_CONTRACTS_WITH_TLD = {
    "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85": "eth",  # ENS .eth registrar (Every network)
}

'''
'''--- safe_transaction_service/tokens/filters.py ---
from django_filters import rest_framework as filters

from gnosis.eth.django.filters import EthereumAddressFilter
from gnosis.eth.django.models import EthereumAddressV2Field

from .models import Token

class TokenFilter(filters.FilterSet):
    class Meta:
        model = Token
        fields = {
            "name": ["exact"],
            "address": ["exact"],
            "symbol": ["exact"],
            "decimals": ["lt", "gt", "exact"],
        }
        filter_overrides = {
            EthereumAddressV2Field: {"filter_class": EthereumAddressFilter},
        }

'''
'''--- safe_transaction_service/tokens/management/__init__.py ---

'''
'''--- safe_transaction_service/tokens/management/commands/__init__.py ---

'''
'''--- safe_transaction_service/tokens/management/commands/add_token.py ---
from django.core.management.base import BaseCommand

from gnosis.eth import EthereumClientProvider
from gnosis.eth.ethereum_client import InvalidERC20Info
from gnosis.eth.utils import fast_to_checksum_address

from ...models import Token

class Command(BaseCommand):
    help = "Update list of tokens"

    def add_arguments(self, parser):
        # Positional arguments
        parser.add_argument(
            "tokens", nargs="+", help="Token/s address/es to add to the token list"
        )
        parser.add_argument(
            "--no-prompt",
            help="If set, add the tokens without prompt",
            action="store_true",
            default=False,
        )

    def handle(self, *args, **options):
        tokens = options["tokens"]
        no_prompt = options["no_prompt"]
        ethereum_client = EthereumClientProvider()

        for token_address in tokens:
            token_address = fast_to_checksum_address(token_address)
            try:
                token = Token.objects.get(address=token_address)
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Token {token.name} - {token.symbol} with address "
                        f"{token_address} already exists"
                    )
                )
                if not token.trusted:  # Mark token as trusted if it's not
                    token.set_trusted()
                    self.stdout.write(
                        self.style.SUCCESS(f"Marking token {token_address} as trusted")
                    )
                continue
            except Token.DoesNotExist:
                pass

            try:
                info = ethereum_client.erc20.get_info(token_address)
                decimals = info.decimals
            except InvalidERC20Info:  # Try with a ERC721
                info = ethereum_client.erc721.get_info(token_address)
                self.stdout.write(self.style.SUCCESS("Detected ERC721 token"))
                decimals = 0

            if no_prompt:
                response = "y"
            else:
                response = (
                    input(f"Do you want to create a token {info} (y/n) ")
                    .strip()
                    .lower()
                )
            if response == "y":
                Token.objects.create(
                    address=token_address,
                    name=info.name,
                    symbol=info.symbol,
                    decimals=decimals,
                    trusted=True,
                )
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Created token {info.name} on address {token_address}"
                    )
                )

'''
'''--- safe_transaction_service/tokens/management/commands/update_tokens_from_coinmarketcap.py ---
from django.core.management.base import BaseCommand

from gnosis.eth import EthereumClientProvider
from gnosis.eth.ethereum_client import InvalidERC20Info, InvalidERC721Info

from ...clients import CoinMarketCapClient
from ...models import Token

class Command(BaseCommand):
    help = "Update list of tokens"

    def add_arguments(self, parser):
        # Positional arguments
        parser.add_argument("api-key", help="Coinmarketcap API Key", type=str)
        parser.add_argument(
            "--download-folder", help="Download images to folder", type=str
        )
        parser.add_argument(
            "--store-db",
            help="Do changes on database",
            action="store_true",
            default=False,
        )

    def handle(self, *args, **options):
        api_key = options["api-key"]
        download_folder = options["download_folder"]
        store_db = options["store_db"]

        ethereum_client = EthereumClientProvider()
        coinmarketcap_client = CoinMarketCapClient(api_key)

        self.stdout.write(self.style.SUCCESS("Importing tokens from Coinmarketcap"))
        if not store_db:
            self.stdout.write(
                self.style.SUCCESS(
                    "Not modifying database. Set --store-db if you want so"
                )
            )

        for token in coinmarketcap_client.get_ethereum_tokens():
            if download_folder:
                coinmarketcap_client.download_file(
                    token.logo_uri, download_folder, f"{token.token_address}.png"
                )

            if not store_db:
                continue
            try:
                token_db = Token.objects.get(address=token.token_address)
                if not token_db.trusted:
                    token_db.set_trusted()
            except Token.DoesNotExist:
                try:
                    token_info = ethereum_client.erc20.get_info(token.token_address)
                    decimals = token_info.decimals
                except InvalidERC20Info:
                    try:
                        token_info = ethereum_client.erc721.get_info(
                            token.token_address
                        )
                        decimals = 0
                    except InvalidERC721Info:
                        self.stdout.write(
                            self.style.WARNING(
                                f"Cannot get token information for {token.name} at address {token.token_address}"
                            )
                        )
                        continue

                Token.objects.create(
                    address=token.token_address,
                    name=token_info.name,
                    symbol=token.symbol,
                    decimals=decimals,
                    trusted=True,
                )
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Inserted new token {token_info.name} at address {token.token_address}"
                    )
                )

'''
'''--- safe_transaction_service/tokens/migrations/0001_initial.py ---
# Generated by Django 3.0.7 on 2020-06-15 15:22

from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Token",
            fields=[
                (
                    "address",
                    gnosis.eth.django.models.EthereumAddressField(
                        primary_key=True, serialize=False
                    ),
                ),
                ("name", models.CharField(max_length=60)),
                ("symbol", models.CharField(max_length=60)),
                ("decimals", models.PositiveSmallIntegerField(db_index=True)),
                ("logo_uri", models.CharField(blank=True, default="", max_length=300)),
                ("trusted", models.BooleanField(default=False)),
            ],
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/0002_auto_20200903_1045.py ---
# Generated by Django 3.0.9 on 2020-09-03 10:45

from django.db import migrations, models

from eth_abi.exceptions import DecodingError
from web3.exceptions import BadFunctionCallOutput

from gnosis.eth import EthereumClientProvider

def fix_token_decimals(apps, schema_editor):
    Token = apps.get_model("tokens", "Token")
    ethereum_client = EthereumClientProvider()

    for token in Token.objects.filter(decimals=0):
        try:
            decimals = ethereum_client.erc20.get_decimals(token.address)
            if decimals != token.decimals:
                token.decimals = decimals
                token.save(update_fields=["decimals"])
        except (ValueError, BadFunctionCallOutput, DecodingError):
            token.decimals = None
            token.save(update_fields=["decimals"])

class Migration(migrations.Migration):

    dependencies = [
        ("tokens", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="token",
            name="spam",
            field=models.BooleanField(default=False),
        ),
        migrations.AlterField(
            model_name="token",
            name="decimals",
            field=models.PositiveSmallIntegerField(
                blank=True, db_index=True, null=True
            ),
        ),
        migrations.RunPython(
            fix_token_decimals, reverse_code=migrations.RunPython.noop
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/0003_auto_20201222_1053.py ---
# Generated by Django 3.1.4 on 2020-12-22 10:53

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("tokens", "0002_auto_20200903_1045"),
    ]

    operations = [
        migrations.AddField(
            model_name="token",
            name="events_bugged",
            field=models.BooleanField(default=False),
        ),
        migrations.AddIndex(
            model_name="token",
            index=models.Index(
                condition=models.Q(trusted=True),
                fields=["trusted"],
                name="token_trusted_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="token",
            index=models.Index(
                condition=models.Q(events_bugged=True),
                fields=["events_bugged"],
                name="token_events_bugged_idx",
            ),
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/0004_ethereum_address_field_v2_20211201_1512.py ---
# Generated by Django 3.2.9 on 2021-12-01 15:12

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("tokens", "0003_auto_20201222_1053"),
    ]

    operations = [
        migrations.RunSQL(
            """
            DROP INDEX IF EXISTS tokens_token_address_18ef94ca_like;
            ALTER TABLE "tokens_token" ALTER COLUMN "address" TYPE bytea USING DECODE(SUBSTRING("address", 3), 'hex');
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        migrations.AlterField(
            model_name="token",
            name="address",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                primary_key=True, serialize=False
            ),
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/0005_add_logo_file_20220201_1335.py ---
# Generated by Django 3.2.11 on 2022-02-01 13:35

from django.db import migrations, models

import safe_transaction_service.tokens.models

class Migration(migrations.Migration):

    dependencies = [
        ("tokens", "0004_ethereum_address_field_v2_20211201_1512"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="token",
            name="logo_uri",
        ),
        migrations.AddField(
            model_name="token",
            name="logo",
            field=models.ImageField(
                blank=True,
                default="",
                upload_to=safe_transaction_service.tokens.models.get_token_logo_path,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/0006_auto_20220214_1629.py ---
# Generated by Django 3.2.12 on 2022-02-14 16:29

from django.db import migrations, models

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("tokens", "0005_add_logo_file_20220201_1335"),
    ]

    operations = [
        migrations.AddField(
            model_name="token",
            name="copy_price",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                help_text="If provided, copy the price from the token", null=True
            ),
        ),
        migrations.AlterField(
            model_name="token",
            name="decimals",
            field=models.PositiveSmallIntegerField(
                blank=True,
                db_index=True,
                help_text="Number of decimals. For ERC721 tokens decimals must be `None`",
                null=True,
            ),
        ),
        migrations.AlterField(
            model_name="token",
            name="events_bugged",
            field=models.BooleanField(
                default=False,
                help_text="Set `True` if token does not send `Transfer` event sometimes (e.g. WETH on minting)",
            ),
        ),
        migrations.AlterField(
            model_name="token",
            name="spam",
            field=models.BooleanField(
                default=False, help_text="Spam and trusted cannot be both True"
            ),
        ),
        migrations.AlterField(
            model_name="token",
            name="trusted",
            field=models.BooleanField(
                default=False, help_text="Spam and trusted cannot be both True"
            ),
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/0007_alter_token_logo.py ---
# Generated by Django 3.2.12 on 2022-02-16 11:19

from django.db import migrations

import imagekit.models.fields

import safe_transaction_service.tokens.models

class Migration(migrations.Migration):

    dependencies = [
        ("tokens", "0006_auto_20220214_1629"),
    ]

    operations = [
        migrations.AlterField(
            model_name="token",
            name="logo",
            field=imagekit.models.fields.ProcessedImageField(
                blank=True,
                default="",
                upload_to=safe_transaction_service.tokens.models.get_token_logo_path,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/0008_alter_token_copy_price.py ---
# Generated by Django 4.0.2 on 2022-03-07 09:35

from django.db import migrations

import gnosis.eth.django.models

class Migration(migrations.Migration):

    dependencies = [
        ("tokens", "0007_alter_token_logo"),
    ]

    operations = [
        migrations.AlterField(
            model_name="token",
            name="copy_price",
            field=gnosis.eth.django.models.EthereumAddressV2Field(
                blank=True,
                help_text="If provided, copy the price from the token",
                null=True,
            ),
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/0009_token_token_spam_idx.py ---
# Generated by Django 3.2.13 on 2022-07-08 09:54

from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ("tokens", "0008_alter_token_copy_price"),
    ]

    operations = [
        migrations.AddIndex(
            model_name="token",
            index=models.Index(
                condition=models.Q(("spam", True)),
                fields=["spam"],
                name="token_spam_idx",
            ),
        ),
    ]

'''
'''--- safe_transaction_service/tokens/migrations/__init__.py ---

'''
'''--- safe_transaction_service/tokens/models.py ---
import logging
import os
from typing import List, Optional
from urllib.parse import urljoin

from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.files.storage import default_storage
from django.db import models
from django.db.models import Q

from botocore.exceptions import ClientError
from eth_abi.exceptions import DecodingError
from eth_typing import ChecksumAddress
from imagekit.models import ProcessedImageField
from pilkit.processors import Resize
from web3.exceptions import BadFunctionCallOutput

from gnosis.eth import EthereumClientProvider, InvalidERC20Info, InvalidERC721Info
from gnosis.eth.django.models import EthereumAddressV2Field

from .clients.zerion_client import (
    BalancerTokenAdapterClient,
    ZerionTokenAdapterClient,
    ZerionUniswapV2TokenAdapterClient,
)
from .constants import ENS_CONTRACTS_WITH_TLD

logger = logging.getLogger(__name__)

def get_token_logo_path(instance: "Token", filename):
    # file will be uploaded to MEDIA_ROOT/<address>
    _, extension = os.path.splitext(filename)
    return f"tokens/logos/{instance.address}{extension}"  # extension includes '.'

def get_file_storage():
    if settings.AWS_CONFIGURED:
        from django_s3_storage.storage import S3Storage

        return S3Storage()
    else:
        return default_storage

class PoolTokenManager(models.Manager):
    def fix_all_pool_tokens(self):
        return self.fix_uniswap_pool_tokens() + self.fix_balancer_pool_tokens()

    def _fix_pool_tokens(self, name: str, zerion_client: ZerionTokenAdapterClient):
        updated = 0
        for token in self.filter(name=name):
            if metadata := zerion_client.get_metadata(token.address):
                token.name = name + " " + metadata.name
                token.name = token.name[:60]
                token.save(update_fields=["name"])
                updated += 1
        return updated

    def fix_uniswap_pool_tokens(self) -> int:
        """
        All Uniswap V2 tokens have the same name: "Uniswap V2". This method will return better names
        :return: Number of pool tokens fixed
        """
        zerion_client = ZerionUniswapV2TokenAdapterClient(EthereumClientProvider())
        return self._fix_pool_tokens("Uniswap V2", zerion_client)

    def fix_balancer_pool_tokens(self) -> int:
        """
        All Uniswap V2 tokens have the same name: "Uniswap V2". This method will return better names
        :return: Number of pool tokens fixed
        """
        zerion_client = BalancerTokenAdapterClient(EthereumClientProvider())
        return self._fix_pool_tokens("Balancer Pool Token", zerion_client)

class TokenManager(models.Manager):
    def create(self, **kwargs):
        for field in ("name", "symbol"):
            kwargs[field] = kwargs[field][:60]
        return super().create(**kwargs)

    def create_from_blockchain(
        self, token_address: ChecksumAddress
    ) -> Optional["Token"]:
        ethereum_client = EthereumClientProvider()
        if token_address in ENS_CONTRACTS_WITH_TLD:  # Special case for ENS
            return self.create(
                address=token_address,
                name="Ethereum Name Service",
                symbol="ENS",
                logo="tokens/logos/ENS.png",
                decimals=None,
                trusted=True,
            )
        try:
            logger.debug(
                "Querying blockchain for info for erc20 token=%s", token_address
            )
            erc_info = ethereum_client.erc20.get_info(token_address)
            decimals = erc_info.decimals
        except InvalidERC20Info:
            logger.debug(
                "Erc20 token not found, querying blockchain for info for erc721 token=%s",
                token_address,
            )
            try:
                erc_info = ethereum_client.erc721.get_info(token_address)
                # Make sure ERC721 is not indexed as an ERC20 for a node misbehaving
                try:
                    decimals = ethereum_client.erc20.get_decimals(token_address)
                except (ValueError, DecodingError, BadFunctionCallOutput):
                    decimals = None
            except InvalidERC721Info:
                logger.debug(
                    "Cannot find anything on blockchain for token=%s", token_address
                )
                return None

        # Ignore tokens with empty name or symbol
        if not erc_info.name or not erc_info.symbol:
            logger.warning(
                "Token with address=%s has not name or symbol", token_address
            )
            return None

        name_and_symbol: List[str] = []
        for text in (erc_info.name, erc_info.symbol):
            if isinstance(text, str):
                text = text.encode()
            name_and_symbol.append(
                text.decode("utf-8", errors="replace").replace("\x00", "\uFFFD")
            )

        name, symbol = name_and_symbol
        # If symbol is way bigger than name (by 5 characters), swap them (e.g. POAP)
        if (len(name) - len(symbol)) < -5:
            name, symbol = symbol, name

        try:
            return self.create(
                address=token_address, name=name, symbol=symbol, decimals=decimals
            )
        except ValueError:
            logger.error(
                "Problem creating token with address=%s name=%s symbol=%s decimals=%s",
                token_address,
                name,
                symbol,
                decimals,
            )
            return None

    def fix_missing_logos(self) -> int:
        """
        Syncs tokens with empty logos with files that exist on S3 and match the address

        :return: Number of synced logos
        """
        synced_logos = 0
        for token in self.without_logo():
            filename = get_token_logo_path(token, f"{token.address}.png")
            token.logo.name = filename
            try:
                if token.logo.size:
                    synced_logos += 1
                    token.save(update_fields=["logo"])
                    logger.info("Found logo on url %s", token.logo.url)
            except (ClientError, FileNotFoundError):  # Depending on aws or filesystem
                logger.error("Error retrieving url %s", token.logo.url)
        return synced_logos

class TokenQuerySet(models.QuerySet):
    erc721_query = Q(decimals=None)
    erc20_query = ~erc721_query
    no_logo_query = Q(logo=None) | Q(logo="")

    def erc20(self):
        return self.filter(self.erc20_query)

    def erc721(self):
        return self.filter(self.erc721_query)

    def spam(self):
        return self.filter(spam=True)

    def not_spam(self):
        return self.filter(spam=False)

    def trusted(self):
        return self.filter(trusted=True)

    def with_logo(self):
        return self.exclude(self.no_logo_query)

    def without_logo(self):
        return self.filter(self.no_logo_query)

class Token(models.Model):
    objects = TokenManager.from_queryset(TokenQuerySet)()
    pool_tokens = PoolTokenManager()
    address = EthereumAddressV2Field(primary_key=True)
    name = models.CharField(max_length=60)
    symbol = models.CharField(max_length=60)
    decimals = models.PositiveSmallIntegerField(
        db_index=True,
        null=True,
        blank=True,
        help_text="Number of decimals. For ERC721 tokens decimals must be `None`",
    )
    logo = ProcessedImageField(
        blank=True,
        default="",
        upload_to=get_token_logo_path,
        storage=get_file_storage,
        format="PNG",
        processors=[Resize(256, 256, upscale=False)],
    )
    events_bugged = models.BooleanField(
        default=False,
        help_text="Set `True` if token does not send `Transfer` event sometimes (e.g. WETH on minting)",
    )
    spam = models.BooleanField(
        default=False, help_text="Spam and trusted cannot be both True"
    )
    trusted = models.BooleanField(
        default=False, help_text="Spam and trusted cannot be both True"
    )
    copy_price = EthereumAddressV2Field(
        null=True, blank=True, help_text="If provided, copy the price from the token"
    )

    class Meta:
        indexes = [
            models.Index(
                name="token_events_bugged_idx",
                fields=["events_bugged"],
                condition=Q(events_bugged=True),
            ),
            models.Index(
                name="token_spam_idx", fields=["spam"], condition=Q(spam=True)
            ),
            models.Index(
                name="token_trusted_idx", fields=["trusted"], condition=Q(trusted=True)
            ),
        ]

    def __str__(self):
        spam_text = "SPAM " if self.spam else ""
        if self.decimals is None:
            return f"{spam_text}ERC721 - {self.name} - {self.address}"
        else:
            return f"{spam_text}ERC20 - {self.name} - {self.address}"

    def clean(self):
        if self.trusted and self.spam:
            raise ValidationError("Spam and trusted cannot be both `True`")

    def is_erc20(self):
        return self.decimals is not None

    def is_erc721(self):
        return not self.is_erc20()

    def set_trusted(self) -> None:
        self.trusted = True
        return self.save(update_fields=["trusted"])

    def set_spam(self) -> None:
        self.spam = True
        return self.save(update_fields=["spam"])

    def get_full_logo_uri(self) -> str:
        if self.logo:
            return self.logo.url
        elif settings.AWS_S3_PUBLIC_URL:
            return urljoin(
                settings.AWS_S3_PUBLIC_URL,
                get_token_logo_path(
                    self, self.address + settings.TOKENS_LOGO_EXTENSION
                ),
            )
        else:
            # Old behaviour
            return urljoin(
                settings.TOKENS_LOGO_BASE_URI,
                get_token_logo_path(
                    self, self.address + settings.TOKENS_LOGO_EXTENSION
                ),
            )

    def get_price_address(self) -> ChecksumAddress:
        """
        :return: Address to use to retrieve the token price
        """
        return self.copy_price or self.address

'''
'''--- safe_transaction_service/tokens/serializers.py ---
from enum import Enum

from rest_framework import serializers

from gnosis.eth.django.serializers import EthereumAddressField

from .models import Token

class TokenTransferInfoType(Enum):
    UNKNOWN = -1
    ERC20 = 0
    ERC721 = 1

class TokenInfoResponseSerializer(serializers.Serializer):
    type = serializers.SerializerMethodField()
    address = EthereumAddressField()
    name = serializers.CharField()
    symbol = serializers.CharField()
    decimals = serializers.IntegerField()
    logo_uri = serializers.SerializerMethodField()

    def get_type(self, obj: Token) -> str:
        if obj.is_erc20():
            return TokenTransferInfoType.ERC20.name
        elif obj.is_erc721():
            return TokenTransferInfoType.ERC721.name
        else:
            return TokenTransferInfoType.UNKNOWN.name

    def get_logo_uri(self, obj: Token) -> str:
        return obj.get_full_logo_uri()

class TokenPriceResponseSerializer(serializers.Serializer):
    fiat_code = serializers.CharField()
    fiat_price = serializers.CharField()
    timestamp = serializers.DateTimeField()

'''
'''--- safe_transaction_service/tokens/services/__init__.py ---
# flake8: noqa F401
from .price_service import PriceService, PriceServiceProvider

'''
'''--- safe_transaction_service/tokens/services/price_service.py ---
import operator
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from functools import cached_property
from typing import Iterator, List, Optional, Sequence, Tuple

from django.utils import timezone

from cache_memoize import cache_memoize
from cachetools import TTLCache, cachedmethod
from celery.utils.log import get_task_logger
from eth_typing import ChecksumAddress
from redis import Redis

from gnosis.eth import EthereumClient, EthereumClientProvider
from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.ethereum_client import EthereumNetwork
from gnosis.eth.oracles import (
    AaveOracle,
    BalancerOracle,
    ComposedPriceOracle,
    CowswapOracle,
    CurveOracle,
    EnzymeOracle,
    KyberOracle,
    MooniswapOracle,
    OracleException,
    PoolTogetherOracle,
    PriceOracle,
    PricePoolOracle,
    SuperfluidOracle,
    SushiswapOracle,
    UnderlyingToken,
    UniswapV2Oracle,
    UniswapV3Oracle,
    YearnOracle,
)

from safe_transaction_service.utils.redis import get_redis

from ..clients import CannotGetPrice, CoingeckoClient, KrakenClient, KucoinClient
from ..tasks import EthValueWithTimestamp, calculate_token_eth_price_task

logger = get_task_logger(__name__)

class FiatCode(Enum):
    USD = 1
    EUR = 2

@dataclass
class FiatPriceWithTimestamp:
    fiat_price: float
    fiat_code: FiatCode
    timestamp: datetime

class PriceServiceProvider:
    def __new__(cls):
        if not hasattr(cls, "instance"):
            cls.instance = PriceService(EthereumClientProvider(), get_redis())
        return cls.instance

    @classmethod
    def del_singleton(cls):
        if hasattr(cls, "instance"):
            del cls.instance

class PriceService:
    def __init__(self, ethereum_client: EthereumClient, redis: Redis):
        self.ethereum_client = ethereum_client
        self.ethereum_network = self.ethereum_client.get_network()
        self.redis = redis
        self.coingecko_client = CoingeckoClient(self.ethereum_network)
        self.kraken_client = KrakenClient()
        self.kucoin_client = KucoinClient()
        self.cache_eth_price = TTLCache(
            maxsize=2048, ttl=60 * 30
        )  # 30 minutes of caching
        self.cache_token_eth_value = TTLCache(
            maxsize=2048, ttl=60 * 30
        )  # 30 minutes of caching
        self.cache_token_usd_value = TTLCache(
            maxsize=2048, ttl=60 * 30
        )  # 30 minutes of caching
        self.cache_underlying_token = TTLCache(
            maxsize=2048, ttl=60 * 30
        )  # 30 minutes of caching
        self.cache_token_info = {}

    @cached_property
    def enabled_price_oracles(self) -> Tuple[PriceOracle]:
        oracles = tuple(
            Oracle(self.ethereum_client)
            for Oracle in (
                UniswapV3Oracle,
                CowswapOracle,
                UniswapV2Oracle,
                SushiswapOracle,
                KyberOracle,
            )
            if Oracle.is_available(self.ethereum_client)
        )
        if oracles:
            if AaveOracle.is_available(self.ethereum_client):
                oracles += (AaveOracle(self.ethereum_client, oracles[0]),)
            if SuperfluidOracle.is_available(self.ethereum_client):
                oracles += (SuperfluidOracle(self.ethereum_client, oracles[0]),)

        return oracles

    @cached_property
    def enabled_price_pool_oracles(self) -> Tuple[PricePoolOracle]:
        if not self.enabled_price_oracles:
            return tuple()
        oracles = tuple(
            Oracle(self.ethereum_client, self.enabled_price_oracles[0])
            for Oracle in (
                BalancerOracle,
                MooniswapOracle,
            )
        )

        if UniswapV2Oracle.is_available(self.ethereum_client):
            # Uses a different constructor that others pool oracles
            oracles = (UniswapV2Oracle(self.ethereum_client),) + oracles
        return oracles

    @cached_property
    def enabled_composed_price_oracles(self) -> Tuple[ComposedPriceOracle]:
        return tuple(
            Oracle(self.ethereum_client)
            for Oracle in (CurveOracle, YearnOracle, PoolTogetherOracle, EnzymeOracle)
            if Oracle.is_available(self.ethereum_client)
        )

    def get_avalanche_usd_price(self) -> float:
        try:
            return self.kraken_client.get_avax_usd_price()
        except CannotGetPrice:
            return self.coingecko_client.get_avax_usd_price()

    def get_aurora_usd_price(self) -> float:
        try:
            return self.kucoin_client.get_aurora_usd_price()
        except CannotGetPrice:
            return self.coingecko_client.get_aoa_usd_price()

    def get_cardano_usd_price(self) -> float:
        try:
            return self.kraken_client.get_ada_usd_price()
        except CannotGetPrice:
            return self.coingecko_client.get_ada_usd_price()

    def get_algorand_usd_price(self) -> float:
        return self.kraken_client.get_algo_usd_price()

    def get_binance_usd_price(self) -> float:
        try:
            return self.kucoin_client.get_bnb_usd_price()
        except CannotGetPrice:
            return self.coingecko_client.get_bnb_usd_price()

    def get_ewt_usd_price(self) -> float:
        try:
            return self.kraken_client.get_ewt_usd_price()
        except CannotGetPrice:
            try:
                return self.kucoin_client.get_ewt_usd_price()
            except CannotGetPrice:
                return self.coingecko_client.get_ewt_usd_price()

    def get_matic_usd_price(self) -> float:
        try:
            return self.kraken_client.get_matic_usd_price()
        except CannotGetPrice:
            try:
                return self.kucoin_client.get_matic_usd_price()
            except CannotGetPrice:
                return self.coingecko_client.get_matic_usd_price()

    def get_cronos_usd_price(self) -> float:
        return self.kucoin_client.get_cro_usd_price()

    def get_kcs_usd_price(self) -> float:
        try:
            return self.kucoin_client.get_kcs_usd_price()
        except CannotGetPrice:
            return self.coingecko_client.get_kcs_usd_price()

    @cachedmethod(cache=operator.attrgetter("cache_eth_price"))
    @cache_memoize(60 * 30, prefix="balances-get_eth_usd_price")  # 30 minutes
    def get_native_coin_usd_price(self) -> float:
        """
        Get USD price for native coin. It depends on the ethereum network:
            - On mainnet, use ETH/USD
            - On xDAI, use DAI/USD.
            - On EWT/VOLTA, use EWT/USD

        :return: USD price for Ether
        """
        if self.ethereum_network == EthereumNetwork.XDAI:
            try:
                return self.kraken_client.get_dai_usd_price()
            except CannotGetPrice:
                return 1  # DAI/USD should be close to 1
        elif self.ethereum_network in (
            EthereumNetwork.ENERGY_WEB_CHAIN,
            EthereumNetwork.VOLTA,
        ):
            return self.get_ewt_usd_price()
        elif self.ethereum_network in (EthereumNetwork.MATIC, EthereumNetwork.MUMBAI):
            return self.get_matic_usd_price()
        elif self.ethereum_network == EthereumNetwork.BINANCE:
            return self.get_binance_usd_price()
        elif self.ethereum_network in (
            EthereumNetwork.GATHER_DEVNET,
            EthereumNetwork.GATHER_TESTNET,
            EthereumNetwork.GATHER_MAINNET,
        ):
            return self.coingecko_client.get_gather_usd_price()
        elif self.ethereum_network == EthereumNetwork.AVALANCHE:
            return self.get_avalanche_usd_price()
        elif self.ethereum_network in (
            EthereumNetwork.MILKOMEDA_C1_TESTNET,
            EthereumNetwork.MILKOMEDA_C1_MAINNET,
        ):
            return self.get_cardano_usd_price()
        elif self.ethereum_network in (
            EthereumNetwork.AURORA,
            EthereumNetwork.AURORA_BETANET,
            EthereumNetwork.ARBITRUM_TESTNET,
        ):
            return self.get_aurora_usd_price()
        elif self.ethereum_network in (
            EthereumNetwork.CRONOS_TESTNET,
            EthereumNetwork.CRONOS_MAINNET,
        ):
            return self.get_cronos_usd_price()
        elif self.ethereum_network in (
            EthereumNetwork.FUSE_MAINNET,
            EthereumNetwork.FUSE_SPARK,
        ):
            return self.coingecko_client.get_fuse_usd_price()
        elif self.ethereum_network in (
            EthereumNetwork.KCC_MAINNET,
            EthereumNetwork.KCC_TESTNET,
        ):
            return self.get_kcs_usd_price()
        elif self.ethereum_network in (
            EthereumNetwork.METIS,
            EthereumNetwork.METIS_TESTNET,
            EthereumNetwork.METIS_GOERLI_TESTNET,
        ):
            return self.coingecko_client.get_metis_usd_price()
        elif self.ethereum_network in (
            EthereumNetwork.MILKOMEDA_A1_TESTNET,
            EthereumNetwork.MILKOMEDA_A1_MAINNET,
        ):
            return self.get_algorand_usd_price()
        else:
            try:
                return self.kraken_client.get_eth_usd_price()
            except CannotGetPrice:
                return self.kucoin_client.get_eth_usd_price()

    @cachedmethod(cache=operator.attrgetter("cache_token_eth_value"))
    @cache_memoize(60 * 30, prefix="balances-get_token_eth_value")  # 30 minutes
    def get_token_eth_value(self, token_address: ChecksumAddress) -> float:
        """
        Uses multiple decentralized and centralized oracles to get token prices

        :param token_address:
        :return: Current ether value for a given `token_address`
        """
        if token_address in (
            "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",  # Used by some oracles
            NULL_ADDRESS,
        ):  # Ether
            return 1.0

        for oracle in self.enabled_price_oracles:
            try:
                return oracle.get_price(token_address)
            except OracleException:
                logger.info(
                    "Cannot get eth value for token-address=%s from %s",
                    token_address,
                    oracle.__class__.__name__,
                )

        # Try pool tokens
        for oracle in self.enabled_price_pool_oracles:
            try:
                return oracle.get_pool_token_price(token_address)
            except OracleException:
                logger.info(
                    "Cannot get eth value for token-address=%s from %s",
                    token_address,
                    oracle.__class__.__name__,
                )

        logger.warning("Cannot find eth value for token-address=%s", token_address)
        return 0.0

    @cachedmethod(cache=operator.attrgetter("cache_token_usd_value"))
    @cache_memoize(60 * 30, prefix="balances-get_token_usd_price")  # 30 minutes
    def get_token_usd_price(self, token_address: ChecksumAddress) -> float:
        """
        :param token_address:
        :return: usd value for a given `token_address` using Curve, if not use Coingecko as last resource
        """
        if self.coingecko_client.supports_network(EthereumNetwork.MAINNET):
            try:
                return self.coingecko_client.get_token_price(token_address)
            except CannotGetPrice:
                pass
        return 0.0

    @cachedmethod(cache=operator.attrgetter("cache_underlying_token"))
    @cache_memoize(60 * 30, prefix="balances-get_underlying_tokens")  # 30 minutes
    def get_underlying_tokens(
        self, token_address: ChecksumAddress
    ) -> Optional[List[UnderlyingToken]]:
        """
        :param token_address:
        :return: usd value for a given `token_address` using Curve, if not use Coingecko as last resource
        """
        for oracle in self.enabled_composed_price_oracles:
            try:
                return oracle.get_underlying_tokens(token_address)
            except OracleException:
                logger.info(
                    "Cannot get an underlying token for token-address=%s from %s",
                    token_address,
                    oracle.__class__.__name__,
                )

    def get_cached_token_eth_values(
        self, token_addresses: Sequence[ChecksumAddress]
    ) -> Iterator[EthValueWithTimestamp]:
        """
        Get token eth prices with timestamp of calculation if ready on cache. If not, schedule tasks to do
        the calculation so next time is available on cache and return `0.` and current datetime

        :param token_addresses:
        :return: eth prices with timestamp if ready on cache, `0.` and None otherwise
        """
        cache_keys = [
            f"price-service:{token_address}:eth-price"
            for token_address in token_addresses
        ]
        results = self.redis.mget(cache_keys)  # eth_value:epoch_timestamp
        for token_address, cache_key, result in zip(
            token_addresses, cache_keys, results
        ):
            if not token_address:  # Ether, this will not be used
                yield EthValueWithTimestamp(
                    1.0, timezone.now()
                )  # Even if not used, Ether value in ether is 1 :)
            elif result:
                yield EthValueWithTimestamp.from_string(result.decode())
            else:
                task_result = calculate_token_eth_price_task.delay(
                    token_address, cache_key
                )
                if task_result.ready():
                    yield task_result.get()
                else:
                    yield EthValueWithTimestamp(0.0, timezone.now())

    def get_cached_usd_values(
        self, token_addresses: Sequence[ChecksumAddress]
    ) -> Iterator[FiatPriceWithTimestamp]:
        """
        Get token usd prices with timestamp of calculation if ready on cache.

        :param token_addresses:
        :return: eth prices with timestamp if ready on cache, `0.` and None otherwise
        """
        try:
            eth_price = self.get_native_coin_usd_price()
        except CannotGetPrice:
            logger.warning("Cannot get network ether price", exc_info=True)
            eth_price = 0

        for token_eth_values_with_timestamp in self.get_cached_token_eth_values(
            token_addresses
        ):
            yield FiatPriceWithTimestamp(
                eth_price * token_eth_values_with_timestamp.eth_value,
                FiatCode.USD,
                token_eth_values_with_timestamp.timestamp,
            )

    def get_eth_price_from_oracles(self, token_address: ChecksumAddress) -> float:
        """
        Calculate eth_price from oracles
        :param token_address
        :return: Current token price
        """
        return (
            self.get_token_eth_value(token_address)
            or self.get_token_usd_price(token_address)
            / self.get_native_coin_usd_price()
        )

    def get_eth_price_from_composed_oracles(
        self, token_address: ChecksumAddress
    ) -> float:
        """
        Calculate eth_price from composed oracles
        :param token_address
        :return: Current token price
        """
        eth_price = 0
        if underlying_tokens := self.get_underlying_tokens(token_address):
            for underlying_token in underlying_tokens:
                # Find underlying token price and multiply by quantity
                address = underlying_token.address
                eth_price += (
                    self.get_eth_price_from_oracles(address) * underlying_token.quantity
                )

        return eth_price

'''
'''--- safe_transaction_service/tokens/signals.py ---
import logging
from typing import Type

from django.db.models import Model
from django.db.models.signals import post_save
from django.dispatch import receiver

from safe_transaction_service.history.services import (
    BalanceServiceProvider,
    CollectiblesServiceProvider,
)

from .models import Token
from .services import PriceServiceProvider

logger = logging.getLogger(__name__)

@receiver(post_save, sender=Token, dispatch_uid="tokens.clear_cache")
def clear_cache(sender: Type[Model], instance: Token, created: bool, **kwargs) -> None:
    """
    Clear local Token caches when a token is manually updated

    :param sender:
    :param instance:
    :param created:
    :param kwargs:
    :return:
    """

    if not created:
        balance_service = BalanceServiceProvider()
        balance_service.cache_token_info.clear()

        collectibles_service = CollectiblesServiceProvider()
        collectibles_service.cache_token_info.clear()

        price_service = PriceServiceProvider()
        price_service.cache_token_eth_value.clear()
        price_service.cache_token_info.clear()
        price_service.cache_token_usd_value.clear()
        price_service.cache_underlying_token.clear()

'''
'''--- safe_transaction_service/tokens/tasks.py ---
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from django.conf import settings
from django.utils import timezone

from celery import app
from celery.utils.log import get_task_logger
from eth_typing import ChecksumAddress

from gnosis.eth.ethereum_client import EthereumNetwork

from safe_transaction_service.utils.ethereum import get_ethereum_network
from safe_transaction_service.utils.redis import get_redis
from safe_transaction_service.utils.utils import close_gevent_db_connection_decorator

from .models import Token

logger = get_task_logger(__name__)

@dataclass
class EthValueWithTimestamp:
    """
    Contains ethereum value for a token and the timestamp on when it was calculated
    """

    eth_value: float
    timestamp: datetime

    @classmethod
    def from_string(cls, result: str):
        eth_value, epoch = result.split(":")
        epoch_timestamp = datetime.fromtimestamp(float(epoch), timezone.utc)
        return cls(float(eth_value), epoch_timestamp)

    def __str__(self):
        return f"{self.eth_value}:{self.timestamp.timestamp()}"

@app.shared_task()
@close_gevent_db_connection_decorator
def calculate_token_eth_price_task(
    token_address: ChecksumAddress, redis_key: str, force_recalculation: bool = False
) -> Optional[EthValueWithTimestamp]:
    """
    Do price calculation for token in an async way and store it with its timestamp on redis

    :param token_address: Token address
    :param redis_key: Redis key for token price
    :param force_recalculation: Force a new calculation even if an old one is on cache
    :return: token price (in ether) when calculated
    """
    from .services.price_service import PriceServiceProvider

    redis_expiration_time = 60 * 30  # Expire in 30 minutes
    redis = get_redis()
    now = timezone.now()
    current_timestamp = int(now.timestamp())
    key_was_set = redis.set(
        redis_key, f"0:{current_timestamp}", ex=60 * 15, nx=True
    )  # Expire in 15 minutes
    if key_was_set or force_recalculation:
        price_service = PriceServiceProvider()
        eth_price = price_service.get_eth_price_from_oracles(token_address)
        if not eth_price:
            eth_price = price_service.get_eth_price_from_composed_oracles(token_address)

        logger.debug("Calculated eth-price=%f for token=%s", eth_price, token_address)
        if not eth_price:
            logger.warning(
                "Cannot calculate eth price for token=%s - Trying to use previous price",
                token_address,
            )
            last_redis_value = redis.get(redis_key)
            if last_redis_value:
                logger.warning("Using previous eth price for token=%s", token_address)
                eth_price = EthValueWithTimestamp.from_string(
                    last_redis_value.decode()
                ).eth_value
            else:
                logger.warning("Cannot calculate eth price for token=%s", token_address)
                return EthValueWithTimestamp(eth_price, now)

        eth_value_with_timestamp = EthValueWithTimestamp(eth_price, now)
        redis.setex(redis_key, redis_expiration_time, str(eth_value_with_timestamp))
        if not getattr(settings, "CELERY_ALWAYS_EAGER", False):
            # Recalculate price before cache expires and prevents recursion checking Celery Eager property
            calculate_token_eth_price_task.apply_async(
                (token_address, redis_key),
                {"force_recalculation": True},
                countdown=redis_expiration_time - 300,
            )

        return EthValueWithTimestamp(eth_price, now)
    else:
        return EthValueWithTimestamp.from_string(redis.get(redis_key).decode())

@app.shared_task()
@close_gevent_db_connection_decorator
def fix_pool_tokens_task() -> Optional[int]:
    """
    Fix names for generic pool tokens, like Balancer or Uniswap

    :return: Number of pool token names updated
    """
    if get_ethereum_network() == EthereumNetwork.MAINNET:
        number = Token.pool_tokens.fix_all_pool_tokens()
        if number:
            logger.info("%d pool token names were fixed", number)
        return number

'''
'''--- safe_transaction_service/tokens/tests/__init__.py ---

'''
'''--- safe_transaction_service/tokens/tests/clients/__init__.py ---

'''
'''--- safe_transaction_service/tokens/tests/clients/test_clients.py ---
from unittest import mock

from django.test import TestCase

from requests import Session

from gnosis.eth.tests.utils import just_test_if_mainnet_node

from ...clients import CannotGetPrice, CoingeckoClient, KrakenClient, KucoinClient

class TestClients(TestCase):
    def test_get_bnb_usd_price(self) -> float:
        just_test_if_mainnet_node()
        kucoin_client = KucoinClient()
        coingecko_client = CoingeckoClient()

        price = kucoin_client.get_bnb_usd_price()
        self.assertIsInstance(price, float)
        self.assertGreater(price, 0)

        price = coingecko_client.get_bnb_usd_price()
        self.assertIsInstance(price, float)
        self.assertGreater(price, 0)

    def test_get_dai_usd_price_kraken(self) -> float:
        just_test_if_mainnet_node()
        kraken_client = KrakenClient()

        # Kraken is used
        price = kraken_client.get_dai_usd_price()
        self.assertIsInstance(price, float)
        self.assertGreater(price, 0)

    def test_get_eth_usd_price_kraken(self):
        just_test_if_mainnet_node()
        kraken_client = KrakenClient()

        # Kraken is used
        eth_usd_price = kraken_client.get_eth_usd_price()
        self.assertIsInstance(eth_usd_price, float)
        self.assertGreater(eth_usd_price, 0)

    def test_get_ewt_usd_price_kraken(self) -> float:
        just_test_if_mainnet_node()
        kraken_client = KrakenClient()

        # Kraken is used
        price = kraken_client.get_ewt_usd_price()
        self.assertIsInstance(price, float)
        self.assertGreater(price, 0)

    def test_get_eth_usd_price_kucoin(self):
        just_test_if_mainnet_node()
        kucoin_client = KucoinClient()

        eth_usd_price = kucoin_client.get_eth_usd_price()
        self.assertIsInstance(eth_usd_price, float)
        self.assertGreater(eth_usd_price, 0)

    def test_get_matic_usd_price(self) -> float:
        just_test_if_mainnet_node()

        for provider in [KucoinClient(), KrakenClient(), CoingeckoClient()]:
            with self.subTest(provider=provider):
                price = provider.get_matic_usd_price()
                self.assertIsInstance(price, float)
                self.assertGreater(price, 0)

    def test_get_ewt_usd_price_coingecko(self) -> float:
        just_test_if_mainnet_node()
        coingecko_client = CoingeckoClient()

        price = coingecko_client.get_ewt_usd_price()
        self.assertIsInstance(price, float)
        self.assertGreater(price, 0)

    def test_get_ewt_usd_price_kucoin(self) -> float:
        just_test_if_mainnet_node()
        kucoin_client = KucoinClient()

        price = kucoin_client.get_ewt_usd_price()
        self.assertIsInstance(price, float)
        self.assertGreater(price, 0)

        with mock.patch.object(Session, "get", side_effect=IOError("Connection Error")):
            with self.assertRaises(CannotGetPrice):
                kucoin_client.get_ewt_usd_price()

'''
'''--- safe_transaction_service/tokens/tests/clients/test_coingecko_client.py ---
from django.test import TestCase

from gnosis.eth import EthereumNetwork

from ...clients import CannotGetPrice
from ...clients.coingecko_client import CoingeckoClient

class TestCoingeckoClient(TestCase):
    GNO_TOKEN_ADDRESS = "0x6810e776880C02933D47DB1b9fc05908e5386b96"
    GNO_GNOSIS_CHAIN_ADDRESS = "0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb"

    def test_coingecko_client(self):
        self.assertTrue(CoingeckoClient.supports_network(EthereumNetwork.MAINNET))
        self.assertTrue(CoingeckoClient.supports_network(EthereumNetwork.BINANCE))
        self.assertTrue(CoingeckoClient.supports_network(EthereumNetwork.MATIC))
        self.assertTrue(CoingeckoClient.supports_network(EthereumNetwork.XDAI))

        # Test Mainnet
        coingecko_client = CoingeckoClient()
        non_existing_token_address = "0xda2f8b8386302C354a90DB670E40beA3563AF454"
        self.assertGreater(coingecko_client.get_token_price(self.GNO_TOKEN_ADDRESS), 0)
        with self.assertRaises(CannotGetPrice):
            coingecko_client.get_token_price(non_existing_token_address)

        # Test Binance
        bsc_coingecko_client = CoingeckoClient(EthereumNetwork.BINANCE)
        binance_peg_ethereum_address = "0x2170Ed0880ac9A755fd29B2688956BD959F933F8"
        self.assertGreater(
            bsc_coingecko_client.get_token_price(binance_peg_ethereum_address), 0
        )

        # Test Polygon
        polygon_coingecko_client = CoingeckoClient(EthereumNetwork.MATIC)
        bnb_pos_address = "0xb33EaAd8d922B1083446DC23f610c2567fB5180f"
        self.assertGreater(polygon_coingecko_client.get_token_price(bnb_pos_address), 0)

    def test_get_logo_url(self):
        # Test Mainnet
        coingecko_client = CoingeckoClient()
        self.assertIn(
            "http", coingecko_client.get_token_logo_url(self.GNO_TOKEN_ADDRESS)
        )
        self.assertIsNone(
            coingecko_client.get_token_logo_url(self.GNO_GNOSIS_CHAIN_ADDRESS)
        )

        # Test Gnosis Chain
        coingecko_client = CoingeckoClient(EthereumNetwork.XDAI)
        self.assertIn(
            "http", coingecko_client.get_token_logo_url(self.GNO_GNOSIS_CHAIN_ADDRESS)
        )

'''
'''--- safe_transaction_service/tokens/tests/clients/test_coinmarketcap_client.py ---
import os
import unittest

from django.test import TestCase

from gnosis.eth.utils import fast_is_checksum_address

from ...clients import CoinMarketCapClient

class TestCoinMarketCapClient(TestCase):
    def test_coinmarketcap_client(self):
        api_token = os.environ.get("COINMARKETCAP_API_TOKEN")
        if not api_token:
            unittest.skip(
                "`COINMARKETCAP_API_TOKEN` environment variable not set, skipping integration test"
            )
        else:
            coinmarketcap_client = CoinMarketCapClient(api_token)
            tokens = coinmarketcap_client.get_ethereum_tokens()
            self.assertGreater(len(tokens), 100)
            for token in tokens:
                self.assertTrue(fast_is_checksum_address(token.token_address))

'''
'''--- safe_transaction_service/tokens/tests/clients/test_kleros_client.py ---
from django.test import TestCase

from gnosis.eth import EthereumClient
from gnosis.eth.utils import fast_is_checksum_address

from safe_transaction_service.history.tests.utils import just_test_if_mainnet_node

from ...clients.kleros_client import KlerosClient

class TestKlerosClient(TestCase):
    def test_kleros_client(self):
        mainnet_node = just_test_if_mainnet_node()
        kleros_client = KlerosClient(EthereumClient(mainnet_node))

        token_ids = kleros_client.get_token_ids()
        self.assertGreater(len(token_ids), 100)

        kleros_tokens = kleros_client.get_token_info(token_ids[:5])
        self.assertEqual(len(kleros_tokens), 5)
        for kleros_token in kleros_tokens:
            self.assertTrue(fast_is_checksum_address(kleros_token.address))
            self.assertTrue(kleros_token.symbol_multihash.startswith("/ipfs/"))

'''
'''--- safe_transaction_service/tokens/tests/clients/test_zerion_client.py ---
from django.test import TestCase

from eth_account import Account

from gnosis.eth import EthereumClient

from safe_transaction_service.history.tests.utils import just_test_if_mainnet_node

from ...clients.zerion_client import (
    UniswapComponent,
    ZerionPoolMetadata,
    ZerionUniswapV2TokenAdapterClient,
)

class TestZerionClient(TestCase):
    def test_zerion_client(self):
        mainnet_node = just_test_if_mainnet_node()
        client = ZerionUniswapV2TokenAdapterClient(EthereumClient(mainnet_node))
        owl_pool_address = "0xBA6329EAe69707D6A0F273Bd082f4a0807A6B011"

        expected = [
            UniswapComponent(
                address="0x1A5F9352Af8aF974bFC03399e3767DF6370d82e4",
                tokenType="ERC20",
                rate=0,
            ),
            UniswapComponent(
                address="0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                tokenType="ERC20",
                rate=0,
            ),
        ]
        components = client.get_components(owl_pool_address)
        for component in components:
            self.assertGreaterEqual(component.rate, 0)
            component.rate = 0

        self.assertEqual(components, expected)

        metadata = client.get_metadata(owl_pool_address)
        expected = ZerionPoolMetadata(
            address="0xBA6329EAe69707D6A0F273Bd082f4a0807A6B011",
            name="OWL/USDC Pool",
            symbol="UNI-V2",
            decimals=18,
        )
        self.assertEqual(metadata, expected)

        random_address = Account.create().address
        self.assertIsNone(client.get_components(random_address))
        self.assertIsNone(client.get_metadata(random_address))

'''
'''--- safe_transaction_service/tokens/tests/factories.py ---
import factory
from eth_account import Account
from factory.django import DjangoModelFactory

from .. import models

class TokenFactory(DjangoModelFactory):
    class Meta:
        model = models.Token

    address = factory.LazyFunction(lambda: Account.create().address)
    name = factory.Faker("cryptocurrency_name")
    symbol = factory.Faker("cryptocurrency_code")
    decimals = 18
    logo = factory.django.ImageField(color="yellow")
    trusted = False
    spam = False
    copy_price = None

'''
'''--- safe_transaction_service/tokens/tests/test_admin.py ---
from django.contrib.admin import site
from django.contrib.auth.models import User
from django.test import RequestFactory, TestCase

from safe_transaction_service.tokens.admin import TokenAdmin
from safe_transaction_service.tokens.tests.factories import TokenFactory

from ..models import Token

class TestTokenAdmin(TestCase):
    request_factory = RequestFactory()

    @classmethod
    def setUpTestData(cls) -> None:
        cls.superuser = User.objects.create_superuser(
            "alfred", "alfred@example.com", "password"
        )
        cls.token1 = TokenFactory.create(logo=None)
        cls.token2 = TokenFactory.create()
        cls.token3 = TokenFactory.create()
        cls.tokens = {cls.token1, cls.token2, cls.token3}

    def setUp(self) -> None:
        self.token_admin = TokenAdmin(Token, site)
        return super().setUp()

    def test_unfiltered_lookup(self) -> None:
        request = self.request_factory.get("/")
        request.user = self.superuser

        changelist = self.token_admin.get_changelist_instance(request)

        # Queryset should contain all the tokens (no filter specified)
        self.assertEqual(set(changelist.get_queryset(request)), self.tokens)

    def test_has_logo_filter_lookup(self) -> None:
        request = self.request_factory.get("/", {"has_logo": "YES"})
        request.user = self.superuser

        changelist = self.token_admin.get_changelist_instance(request)

        # Queryset should contain tokens with logo (token2 and token3)
        self.assertEqual(
            set(changelist.get_queryset(request)), {self.token2, self.token3}
        )

    def test_has_no_logo_filter_lookup(self) -> None:
        request = self.request_factory.get("/", {"has_logo": "NO"})
        request.user = self.superuser

        changelist = self.token_admin.get_changelist_instance(request)

        # Queryset should contain tokens with no logo (token1)
        self.assertEqual(set(changelist.get_queryset(request)), {self.token1})

'''
'''--- safe_transaction_service/tokens/tests/test_commands.py ---
from io import StringIO
from unittest import mock
from unittest.mock import MagicMock

from django.core.management import call_command
from django.test import TestCase

from eth_account import Account

from gnosis.eth import EthereumClientProvider
from gnosis.eth.ethereum_client import Erc20Info, Erc20Manager
from gnosis.eth.tests.utils import deploy_example_erc20

from ..clients import CoinMarketCapClient, CoinMarketCapToken
from ..models import Token
from .factories import TokenFactory

coinmarketcap_client_mock = [
    CoinMarketCapToken(
        id=1659,
        name="Gnosis",
        symbol="GNO",
        token_address="0x6810e776880C02933D47DB1b9fc05908e5386b96",
        logo_uri="https://s2.coinmarketcap.com/static/img/coins/200x200/1659.png",
    ),
]

relay_token_client_mock = [
    {
        "address": "0x6810e776880C02933D47DB1b9fc05908e5386b96",
        "logoUri": "https://tokens-logo.localhost/0x6810e776880C02933D47DB1b9fc05908e5386b96.png",
        "default": False,
        "name": "Gnosis",
        "symbol": "GNO",
        "description": "Crowd Sourced Wisdom - The next generation blockchain network. Speculate on anything with an easy-to-use prediction market",
        "decimals": 18,
        "websiteUri": "https://gnosis.pm",
        "gas": False,
    },
    {
        "address": "0x1A5F9352Af8aF974bFC03399e3767DF6370d82e4",
        "logoUri": "https://tokens-logo.localhost/0x1A5F9352Af8aF974bFC03399e3767DF6370d82e4.png",
        "default": True,
        "name": "OWL Token",
        "symbol": "OWL",
        "description": "",
        "decimals": 18,
        "websiteUri": "https://owl.gnosis.io/",
        "gas": True,
    },
]

class TestCommands(TestCase):
    def test_add_token(self):
        command = "add_token"
        buf = StringIO()
        token = TokenFactory(trusted=False)
        self.assertFalse(token.trusted)

        call_command(command, token.address, stdout=buf)
        self.assertIn("already exists", buf.getvalue())
        token.refresh_from_db()
        self.assertTrue(token.trusted)

        ethereum_client = EthereumClientProvider()
        erc20 = deploy_example_erc20(ethereum_client.w3, 10, Account.create().address)
        call_command(command, erc20.address, "--no-prompt", stdout=buf)
        self.assertIn("Created token", buf.getvalue())
        self.assertTrue(Token.objects.get(address=erc20.address).trusted)

    @mock.patch.object(
        Erc20Manager,
        "get_info",
        autospec=True,
        return_value=Erc20Info("Gnosis", "GNO", 18),
    )
    @mock.patch.object(
        CoinMarketCapClient,
        "get_ethereum_tokens",
        autospec=True,
        return_value=coinmarketcap_client_mock,
    )
    def test_update_tokens_from_coinmarketcap(
        self,
        coinmarketcap_client_get_ethereum_tokens_mock: MagicMock,
        erc20_manager_get_info_mock: MagicMock,
    ):
        command = "update_tokens_from_coinmarketcap"
        buf = StringIO()

        self.assertEqual(Token.objects.count(), 0)
        call_command(command, "fake-api-key", stdout=buf)
        self.assertEqual(Token.objects.count(), 0)
        call_command(command, "fake-api-key", "--store-db", stdout=buf)
        self.assertEqual(Token.objects.count(), 1)
        self.assertTrue(Token.objects.first().trusted)
        Token.objects.update(trusted=False)

        call_command(command, "fake-api-key", "--store-db", stdout=buf)
        self.assertTrue(Token.objects.first().trusted)

'''
'''--- safe_transaction_service/tokens/tests/test_models.py ---
from unittest import mock
from unittest.mock import MagicMock

from django.core.exceptions import ValidationError
from django.test import TestCase

from eth_account import Account

from gnosis.eth.ethereum_client import Erc20Info, Erc20Manager

from ..clients.zerion_client import (
    BalancerTokenAdapterClient,
    ZerionPoolMetadata,
    ZerionUniswapV2TokenAdapterClient,
)
from ..models import Token, TokenManager
from ..models import logger as token_model_logger
from .factories import TokenFactory

class TestModels(TestCase):
    def test_token_querysets(self):
        erc721_token = TokenFactory(decimals=None)
        self.assertEqual(Token.objects.erc20().count(), 0)
        self.assertEqual(Token.objects.erc721().count(), 1)
        self.assertIn("ERC721", str(erc721_token))

        erc20_token = TokenFactory(decimals=0)
        self.assertEqual(Token.objects.erc20().count(), 1)
        self.assertEqual(Token.objects.erc721().count(), 1)
        self.assertIn("ERC20", str(erc20_token))

        TokenFactory(decimals=4)
        self.assertEqual(Token.objects.erc20().count(), 2)
        self.assertEqual(Token.objects.erc721().count(), 1)
        TokenFactory(decimals=None)
        self.assertEqual(Token.objects.erc20().count(), 2)
        self.assertEqual(Token.objects.erc721().count(), 2)

    def test_token_validation(self):
        t = TokenFactory()
        t.set_spam()
        t.trusted = True
        with self.assertRaises(ValidationError):
            t.clean()

    def test_token_get_full_logo_uri(self):
        t = TokenFactory(logo=None)
        self.assertIsNotNone(t.logo)  # <None ImageField>
        self.assertFalse(t.logo)
        self.assertEqual(
            t.get_full_logo_uri(),
            f"https://tokens-logo.localhost/tokens/logos/{t.address}.png",
        )

        assets_url = "https://assets.gnosis.io"
        with self.settings(AWS_S3_PUBLIC_URL=assets_url):
            self.assertEqual(
                t.get_full_logo_uri(), f"{assets_url}/tokens/logos/{t.address}.png"
            )

    def test_token_trusted_spam_queryset(self):
        spam_tokens = [TokenFactory(spam=True), TokenFactory(spam=True)]
        not_spam_tokens = [
            TokenFactory(spam=False, trusted=False),
            TokenFactory(spam=False, trusted=False),
        ]
        trusted_tokens = [TokenFactory(trusted=True)]

        self.assertCountEqual(Token.objects.spam(), spam_tokens)
        self.assertCountEqual(
            Token.objects.not_spam(), not_spam_tokens + trusted_tokens
        )
        self.assertCountEqual(Token.objects.trusted(), trusted_tokens)

        self.assertIn("SPAM", str(spam_tokens[0]))

    def test_token_create_truncate(self):
        max_length = 60
        long_name = "CHA" + "NA" * 30 + " BATMAN"
        self.assertGreater(len(long_name), max_length)
        truncated_name = long_name[:max_length]
        token = Token.objects.create(
            address=Account.create().address,
            name=long_name,
            symbol=long_name,
            decimals=18,
            trusted=True,
        )
        self.assertEqual(token.name, truncated_name)
        self.assertEqual(token.symbol, truncated_name)

    @mock.patch.object(
        ZerionUniswapV2TokenAdapterClient,
        "get_metadata",
        autospec=True,
        return_value=ZerionPoolMetadata(
            address="0xBA6329EAe69707D6A0F273Bd082f4a0807A6B011",
            name="OWL/USDC Pool",
            symbol="UNI-V2",
            decimals=18,
        ),
    )
    def test_fix_uniswap_pool_tokens(self, get_metadata_mock: MagicMock):
        self.assertEqual(Token.pool_tokens.fix_uniswap_pool_tokens(), 0)
        TokenFactory()
        self.assertEqual(Token.pool_tokens.fix_uniswap_pool_tokens(), 0)
        token = TokenFactory(name="Uniswap V2")
        self.assertEqual(Token.pool_tokens.fix_uniswap_pool_tokens(), 1)
        self.assertEqual(
            Token.pool_tokens.fix_all_pool_tokens(), 0
        )  # Repeating the command will not fix token again
        token.refresh_from_db()
        self.assertEqual(
            token.name, "Uniswap V2 " + get_metadata_mock.return_value.name
        )

    @mock.patch.object(
        BalancerTokenAdapterClient,
        "get_metadata",
        autospec=True,
        return_value=ZerionPoolMetadata(
            address="0x8b6e6E7B5b3801FEd2CaFD4b22b8A16c2F2Db21a",
            name="20% DAI + 80% WETH Pool",
            symbol="BPT",
            decimals=18,
        ),
    )
    def test_fix_balancer_pool_tokens(self, get_metadata_mock: MagicMock):
        self.assertEqual(Token.pool_tokens.fix_balancer_pool_tokens(), 0)
        TokenFactory()
        self.assertEqual(Token.pool_tokens.fix_balancer_pool_tokens(), 0)
        token = TokenFactory(name="Balancer Pool Token")
        self.assertEqual(Token.pool_tokens.fix_balancer_pool_tokens(), 1)
        self.assertEqual(
            Token.pool_tokens.fix_all_pool_tokens(), 0
        )  # Repeating the command will not fix token again
        token.refresh_from_db()
        self.assertEqual(
            token.name, "Balancer Pool Token " + get_metadata_mock.return_value.name
        )

    @mock.patch.object(
        Erc20Manager,
        "get_info",
        autospec=True,
        return_value=Erc20Info(
            name=b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
            symbol=b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
            decimals=18,
        ),
    )
    def test_create_from_blockchain_with_byte_data(self, get_info: MagicMock):
        Token.objects.create_from_blockchain(
            "0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413"
        )

        token = Token.objects.get(address="0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413")
        self.assertEqual(token.name, "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\x01")
        self.assertEqual(token.symbol, "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\x01")

    @mock.patch.object(
        Erc20Manager,
        "get_info",
        autospec=True,
        return_value=Erc20Info(
            name="Build\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            symbol="Build\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            decimals=0,
        ),
    )
    def test_create_from_blockchain_with_string_null_data(self, get_info: MagicMock):
        Token.objects.create_from_blockchain(
            "0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413"
        )

        token = Token.objects.get(address="0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413")
        self.assertEqual(token.name, "Buildï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½")
        self.assertEqual(token.symbol, "Buildï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½")

    @mock.patch.object(
        Erc20Manager,
        "get_info",
        autospec=True,
        return_value=Erc20Info(
            name="",
            symbol="SYMBOL",
            decimals=15,
        ),
    )
    def test_create_from_blockchain_with_empty_name(self, get_info: MagicMock):
        self.assertIsNone(
            Token.objects.create_from_blockchain(
                "0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413"
            )
        )

    @mock.patch.object(TokenManager, "create", side_effect=ValueError)
    @mock.patch.object(
        Erc20Manager,
        "get_info",
        autospec=True,
        return_value=Erc20Info(
            name="PESETA",
            symbol="PTA",
            decimals=18,
        ),
    )
    def test_create_from_blockchain_error(self, get_info: MagicMock, create: MagicMock):
        with self.assertLogs(token_model_logger, level="ERROR") as cm:
            self.assertIsNone(
                Token.objects.create_from_blockchain(
                    "0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413"
                )
            )
            self.assertIn(
                "Problem creating token with address=0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413 name=PESETA symbol=PTA decimals=18",
                cm.output[0],
            )

'''
'''--- safe_transaction_service/tokens/tests/test_price_service.py ---
from unittest import mock
from unittest.mock import MagicMock

from django.test import TestCase

from eth_account import Account

from gnosis.eth import EthereumClient, EthereumClientProvider, EthereumNetwork
from gnosis.eth.oracles import KyberOracle, OracleException, UnderlyingToken

from safe_transaction_service.history.tests.utils import just_test_if_mainnet_node
from safe_transaction_service.utils.redis import get_redis

from ..clients import CannotGetPrice, CoingeckoClient, KrakenClient, KucoinClient
from ..services.price_service import PriceService, PriceServiceProvider

class TestPriceService(TestCase):
    @classmethod
    def setUpClass(cls) -> None:
        cls.redis = get_redis()
        cls.ethereum_client = EthereumClientProvider()

    @classmethod
    def tearDownClass(cls) -> None:
        PriceServiceProvider.del_singleton()

    def setUp(self) -> None:
        self.price_service = PriceServiceProvider()

    def tearDown(self) -> None:
        PriceServiceProvider.del_singleton()

    @mock.patch.object(KrakenClient, "get_eth_usd_price", return_value=0.4)
    @mock.patch.object(KucoinClient, "get_eth_usd_price", return_value=0.5)
    def test_get_native_coin_usd_price(
        self, binance_mock: MagicMock, kraken_mock: MagicMock
    ):
        price_service = self.price_service
        eth_usd_price = price_service.get_native_coin_usd_price()
        self.assertEqual(eth_usd_price, kraken_mock.return_value)
        binance_mock.assert_not_called()

        kraken_mock.side_effect = CannotGetPrice

        # Cache is still working
        eth_usd_price = price_service.get_native_coin_usd_price()
        self.assertEqual(eth_usd_price, kraken_mock.return_value)

        # Remove cache and test binance is called
        price_service.cache_eth_price.clear()
        eth_usd_price = price_service.get_native_coin_usd_price()
        binance_mock.called_once()
        self.assertEqual(eth_usd_price, binance_mock.return_value)

        # Gnosis Chain
        price_service.ethereum_network = EthereumNetwork.XDAI
        with mock.patch.object(KrakenClient, "get_dai_usd_price", return_value=1.5):
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 1.5)

        with mock.patch.object(
            KrakenClient, "get_dai_usd_price", side_effect=CannotGetPrice
        ):
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 1)

        # POLYGON
        price_service.ethereum_network = EthereumNetwork.MATIC
        with mock.patch.object(KrakenClient, "get_matic_usd_price", return_value=0.7):
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 0.7)

        # EWT
        price_service.ethereum_network = EthereumNetwork.ENERGY_WEB_CHAIN
        with mock.patch.object(KrakenClient, "get_ewt_usd_price", return_value=0.9):
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 0.9)

        # BINANCE
        price_service.ethereum_network = EthereumNetwork.BINANCE
        with mock.patch.object(KucoinClient, "get_bnb_usd_price", return_value=1.2):
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 1.2)

        # Gather
        price_service.ethereum_network = EthereumNetwork.GATHER_MAINNET
        with mock.patch.object(
            CoingeckoClient, "get_gather_usd_price", return_value=1.7
        ):
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 1.7)

        # Avalanche
        price_service.ethereum_network = EthereumNetwork.AVALANCHE
        with mock.patch.object(KrakenClient, "get_avax_usd_price", return_value=6.5):
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 6.5)

        # Aurora
        price_service.ethereum_network = EthereumNetwork.AURORA
        with mock.patch.object(KucoinClient, "get_aurora_usd_price", return_value=1.3):
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 1.3)

        # Cronos
        with mock.patch.object(KucoinClient, "get_cro_usd_price", return_value=4.4):
            price_service.ethereum_network = EthereumNetwork.CRONOS_MAINNET
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 4.4)

        # KuCoin
        with mock.patch.object(KucoinClient, "get_kcs_usd_price", return_value=4.4):
            price_service.ethereum_network = EthereumNetwork.KCC_MAINNET
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 4.4)

        # Milkomeda Cardano
        with mock.patch.object(KrakenClient, "get_ada_usd_price", return_value=5.5):
            price_service.ethereum_network = EthereumNetwork.MILKOMEDA_C1_MAINNET
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_native_coin_usd_price(), 5.5)

        # Milkomeda Algorand
        with mock.patch.object(KrakenClient, "get_algo_usd_price", return_value=6.6):
            price_service.ethereum_network = EthereumNetwork.MILKOMEDA_A1_MAINNET
            price_service.cache_eth_price.clear()
            self.assertEqual(price_service.get_algorand_usd_price(), 6.6)

    @mock.patch.object(CoingeckoClient, "get_bnb_usd_price", return_value=3.0)
    @mock.patch.object(KucoinClient, "get_bnb_usd_price", return_value=5.0)
    def test_get_binance_usd_price(
        self,
        get_bnb_usd_price_binance_mock: MagicMock,
        get_bnb_usd_price_coingecko: MagicMock,
    ):
        price_service = self.price_service

        price = price_service.get_binance_usd_price()
        self.assertEqual(price, 5.0)

        get_bnb_usd_price_binance_mock.side_effect = CannotGetPrice
        price = price_service.get_binance_usd_price()
        self.assertEqual(price, 3.0)

    @mock.patch.object(CoingeckoClient, "get_ewt_usd_price", return_value=3.0)
    @mock.patch.object(KucoinClient, "get_ewt_usd_price", return_value=7.0)
    @mock.patch.object(KrakenClient, "get_ewt_usd_price", return_value=5.0)
    def test_get_ewt_usd_price(
        self,
        get_ewt_usd_price_kraken_mock: MagicMock,
        get_ewt_usd_price_kucoin_mock: MagicMock,
        get_ewt_usd_price_coingecko_mock: MagicMock,
    ):
        price_service = self.price_service

        price = price_service.get_ewt_usd_price()
        self.assertEqual(price, 5.0)

        get_ewt_usd_price_kraken_mock.side_effect = CannotGetPrice
        price = price_service.get_ewt_usd_price()
        self.assertEqual(price, 7.0)

        get_ewt_usd_price_kucoin_mock.side_effect = CannotGetPrice
        price = price_service.get_ewt_usd_price()
        self.assertEqual(price, 3.0)

    @mock.patch.object(CoingeckoClient, "get_matic_usd_price", return_value=3.0)
    @mock.patch.object(KucoinClient, "get_matic_usd_price", return_value=7.0)
    @mock.patch.object(KrakenClient, "get_matic_usd_price", return_value=5.0)
    def test_get_matic_usd_price(
        self,
        get_matic_usd_price_kraken_mock: MagicMock,
        get_matic_usd_price_binance_mock: MagicMock,
        get_matic_usd_price_coingecko_mock: MagicMock,
    ):
        price_service = self.price_service

        price = price_service.get_matic_usd_price()
        self.assertEqual(price, 5.0)

        get_matic_usd_price_kraken_mock.side_effect = CannotGetPrice
        price = price_service.get_matic_usd_price()
        self.assertEqual(price, 7.0)

        get_matic_usd_price_binance_mock.side_effect = CannotGetPrice
        price = price_service.get_matic_usd_price()
        self.assertEqual(price, 3.0)

    def test_token_eth_value(self):
        mainnet_node = just_test_if_mainnet_node()
        price_service = PriceService(EthereumClient(mainnet_node), self.redis)
        gno_token_address = "0x6810e776880C02933D47DB1b9fc05908e5386b96"
        token_eth_value = price_service.get_token_eth_value(gno_token_address)
        self.assertIsInstance(token_eth_value, float)
        self.assertGreater(token_eth_value, 0)

    def test_available_price_oracles(self):
        # Ganache should have no oracle enabled
        self.assertEqual(len(self.price_service.enabled_price_oracles), 0)
        self.assertEqual(len(self.price_service.enabled_price_pool_oracles), 0)
        self.assertEqual(len(self.price_service.enabled_composed_price_oracles), 0)

    def test_available_price_oracles_mainnet(self):
        # Mainnet should have every oracle enabled
        mainnet_node = just_test_if_mainnet_node()
        price_service = PriceService(EthereumClient(mainnet_node), self.redis)
        self.assertEqual(len(price_service.enabled_price_oracles), 6)
        self.assertEqual(len(price_service.enabled_price_pool_oracles), 3)
        self.assertEqual(len(price_service.enabled_composed_price_oracles), 4)

    @mock.patch.object(KyberOracle, "get_price", return_value=1.23, autospec=True)
    def test_token_eth_value_mocked(self, kyber_get_price_mock: MagicMock):
        price_service = self.price_service
        oracle_1 = mock.MagicMock()
        oracle_1.get_price.return_value = 1.23
        oracle_2 = mock.MagicMock()
        oracle_3 = mock.MagicMock()
        price_service.enabled_price_oracles = (oracle_1, oracle_2, oracle_3)
        self.assertEqual(len(price_service.enabled_price_oracles), 3)
        random_address = Account.create().address
        self.assertEqual(len(price_service.cache_token_eth_value), 0)

        self.assertEqual(price_service.get_token_eth_value(random_address), 1.23)
        self.assertEqual(price_service.cache_token_eth_value[(random_address,)], 1.23)

        # Make every oracle fail
        oracle_1.get_price.side_effect = OracleException
        oracle_2.get_price.side_effect = OracleException
        oracle_3.get_price.side_effect = OracleException

        # Check cache
        self.assertEqual(price_service.get_token_eth_value(random_address), 1.23)
        random_address_2 = Account.create().address
        self.assertEqual(price_service.get_token_eth_value(random_address_2), 0.0)
        self.assertEqual(price_service.cache_token_eth_value[(random_address,)], 1.23)
        self.assertEqual(price_service.cache_token_eth_value[(random_address_2,)], 0.0)

    @mock.patch.object(
        PriceService, "get_underlying_tokens", return_value=[], autospec=True
    )
    @mock.patch.object(
        PriceService, "get_token_eth_value", autospec=True, return_value=1.0
    )
    def test_eth_price_from_composed_oracles(
        self, get_token_eth_value_mock: MagicMock, price_service_mock: MagicMock
    ):
        price_service = self.price_service
        token_one = UnderlyingToken("0x48f07301E9E29c3C38a80ae8d9ae771F224f1054", 0.482)
        token_two = UnderlyingToken("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 0.376)
        token_three = UnderlyingToken("0xA0b86991c6218b36c1d19D4a2e9Eb0cE360", 0.142)
        price_service_mock.return_value = [token_one, token_two, token_three]
        curve_price = "0xe7ce624c00381b4b7abb03e633fb4acac4537dd6"
        eth_price = price_service.get_eth_price_from_composed_oracles(curve_price)
        self.assertEqual(eth_price, 1.0)

'''
'''--- safe_transaction_service/tokens/tests/test_tasks.py ---
import logging
from unittest import mock
from unittest.mock import MagicMock

from django.test import TestCase
from django.utils import timezone

from eth_account import Account

from gnosis.eth.ethereum_client import (
    EthereumClient,
    EthereumClientProvider,
    EthereumNetwork,
)

from ...history.tests.utils import just_test_if_mainnet_node
from ...utils.redis import get_redis
from ..services import PriceService, PriceServiceProvider
from ..tasks import (
    EthValueWithTimestamp,
    calculate_token_eth_price_task,
    fix_pool_tokens_task,
)

logger = logging.getLogger(__name__)

class TestTasks(TestCase):
    def setUp(self) -> None:
        PriceServiceProvider.del_singleton()
        get_redis().flushall()

    def tearDown(self) -> None:
        get_redis().flushall()

    @mock.patch(
        "safe_transaction_service.tokens.tasks.get_ethereum_network",
        return_value=EthereumNetwork.MAINNET,
    )
    def test_fix_pool_tokens_task(self, get_network_mock: MagicMock):
        self.assertEqual(fix_pool_tokens_task.delay().result, 0)

        get_network_mock.return_value = EthereumNetwork.RINKEBY
        self.assertIsNone(fix_pool_tokens_task.delay().result)

    @mock.patch.object(
        PriceService, "get_token_eth_value", autospec=True, return_value=4815
    )
    @mock.patch.object(timezone, "now", return_value=timezone.now())
    def test_calculate_token_eth_price_task(
        self, timezone_now_mock: MagicMock, get_token_eth_value_mock: MagicMock
    ):
        random_token_address = Account.create().address
        random_redis_key = Account.create().address
        expected = EthValueWithTimestamp(
            get_token_eth_value_mock.return_value, timezone_now_mock.return_value
        )
        self.assertEqual(
            calculate_token_eth_price_task.delay(
                random_token_address, random_redis_key
            ).result,
            expected,
        )

        # Check caching works even if we change the token_address
        another_token_address = Account.create().address
        self.assertEqual(
            calculate_token_eth_price_task.delay(
                another_token_address, random_redis_key
            ).result,
            expected,
        )

        with self.settings(CELERY_ALWAYS_EAGER=False):
            random_token_address = Account.create().address
            random_redis_key = Account.create().address
            calculate_token_eth_price_task.delay(random_token_address, random_redis_key)

    def test_calculate_token_eth_price_task_without_mock(self):
        mainnet_node_url = just_test_if_mainnet_node()
        EthereumClientProvider.instance = EthereumClient(mainnet_node_url)

        dai_address = "0x6B175474E89094C44Da98b954EedeAC495271d0F"
        random_redis_key = Account.create().address
        eth_value_with_timestamp = calculate_token_eth_price_task(
            dai_address, random_redis_key
        )
        self.assertGreater(eth_value_with_timestamp.eth_value, 0.0)

        pool_together_address = "0x334cBb5858417Aee161B53Ee0D5349cCF54514CF"
        random_redis_key = Account.create().address
        eth_value_with_timestamp = calculate_token_eth_price_task(
            pool_together_address, random_redis_key
        )
        self.assertGreater(eth_value_with_timestamp.eth_value, 0.0)

        random_token_address = Account.create().address
        random_redis_key = Account.create().address
        eth_value_with_timestamp = calculate_token_eth_price_task(
            random_token_address, random_redis_key
        )
        self.assertEqual(eth_value_with_timestamp.eth_value, 0.0)
        del EthereumClientProvider.instance

    @mock.patch.object(
        PriceService, "get_token_eth_value", autospec=True, return_value=4815
    )
    @mock.patch.object(
        PriceService, "get_token_usd_price", autospec=True, return_value=0.0
    )
    @mock.patch.object(timezone, "now", return_value=timezone.now())
    def test_return_last_valid_token_price(
        self,
        timezone_now_mock: MagicMock,
        get_token_usd_price: MagicMock,
        get_token_eth_value_mock: MagicMock,
    ):
        random_token_address = Account.create().address
        random_redis_key = Account.create().address
        expected = EthValueWithTimestamp(
            get_token_eth_value_mock.return_value, timezone_now_mock.return_value
        )
        self.assertEqual(
            calculate_token_eth_price_task.delay(
                random_token_address, random_redis_key
            ).result,
            expected,
        )

        get_token_eth_value_mock.return_value = 0.0

        self.assertEqual(
            calculate_token_eth_price_task.delay(
                random_token_address, random_redis_key, True
            ).result,
            expected,
        )

'''
'''--- safe_transaction_service/tokens/tests/test_views.py ---
import logging
from unittest import mock
from unittest.mock import MagicMock

from django.urls import reverse
from django.utils import timezone

from eth_account import Account
from rest_framework import status
from rest_framework.exceptions import ErrorDetail
from rest_framework.test import APITestCase

from gnosis.eth.ethereum_client import Erc20Manager, InvalidERC20Info
from gnosis.safe.tests.safe_test_case import SafeTestCaseMixin

from ..clients import CannotGetPrice
from ..models import Token
from ..services import PriceService
from ..services.price_service import FiatCode, FiatPriceWithTimestamp
from .factories import TokenFactory

logger = logging.getLogger(__name__)

class TestTokenViews(SafeTestCaseMixin, APITestCase):
    def test_token_view(self):
        invalid_address = "0x1234"
        response = self.client.get(reverse("v1:tokens:detail", args=(invalid_address,)))
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        random_address = Account.create().address
        response = self.client.get(reverse("v1:tokens:detail", args=(random_address,)))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertEqual(
            response.data,
            {"detail": ErrorDetail(string="Not found.", code="not_found")},
        )

        token = TokenFactory(address=random_address, decimals=18)  # ERC20
        response = self.client.get(reverse("v1:tokens:detail", args=(token.address,)))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.data,
            {
                "type": "ERC20",
                "address": token.address,
                "logo_uri": token.get_full_logo_uri(),
                "name": token.name,
                "symbol": token.symbol,
                "decimals": token.decimals,
            },
        )

        token = TokenFactory(decimals=None)  # ERC721
        response = self.client.get(reverse("v1:tokens:detail", args=(token.address,)))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(
            response.data,
            {
                "type": "ERC721",
                "address": token.address,
                "logo_uri": token.get_full_logo_uri(),
                "name": token.name,
                "symbol": token.symbol,
                "decimals": token.decimals,
            },
        )

    @mock.patch.object(Erc20Manager, "get_info", autospec=True)
    def test_token_view_missing(self, get_token_info_mock: MagicMock):
        get_token_info_mock.side_effect = InvalidERC20Info
        random_address = Account.create().address
        self.assertEqual(Token.objects.count(), 0)
        response = self.client.get(reverse("v1:tokens:detail", args=(random_address,)))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertEqual(Token.objects.count(), 0)

        response = self.client.get(reverse("v1:tokens:detail", args=(random_address,)))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertEqual(Token.objects.count(), 0)

    def test_tokens_view(self):
        response = self.client.get(reverse("v1:tokens:list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 0)
        self.assertEqual(response.data["results"], [])

        token = TokenFactory()
        response = self.client.get(reverse("v1:tokens:list"))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["count"], 1)
        self.assertEqual(
            response.data["results"],
            [
                {
                    "type": "ERC20",
                    "address": token.address,
                    "logo_uri": token.get_full_logo_uri(),
                    "name": token.name,
                    "symbol": token.symbol,
                    "decimals": token.decimals,
                }
            ],
        )

    def test_token_price_view(self):
        invalid_address = "0x1234"
        response = self.client.get(
            reverse("v1:tokens:price-usd", args=(invalid_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_422_UNPROCESSABLE_ENTITY)

        random_address = Account.create().address
        response = self.client.get(
            reverse("v1:tokens:price-usd", args=(random_address,))
        )
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertEqual(
            response.data,
            {"detail": ErrorDetail(string="Not found.", code="not_found")},
        )

        token = TokenFactory(address=random_address, decimals=18)  # ERC20
        response = self.client.get(
            reverse("v1:tokens:price-usd", args=(token.address,))
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["fiat_code"], "USD")
        self.assertEqual(response.data["fiat_price"], "0.0")
        self.assertTrue(response.data["timestamp"])

        fiat_price_with_timestamp = FiatPriceWithTimestamp(
            48.1516, FiatCode.USD, timezone.now()
        )
        with mock.patch.object(
            PriceService,
            "get_cached_usd_values",
            autospec=True,
            return_value=iter([fiat_price_with_timestamp]),
        ) as get_cached_usd_values_mock:
            response = self.client.get(
                reverse("v1:tokens:price-usd", args=(token.address,))
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertEqual(response.data["fiat_code"], "USD")
            self.assertEqual(
                response.data["fiat_price"], str(fiat_price_with_timestamp.fiat_price)
            )
            self.assertTrue(response.data["timestamp"])
            self.assertEqual(
                get_cached_usd_values_mock.call_args.args[1], [token.address]
            )

            # Test copy price address
            get_cached_usd_values_mock.return_value = iter([fiat_price_with_timestamp])
            token.copy_price = Account.create().address
            token.save(update_fields=["copy_price"])
            response = self.client.get(
                reverse("v1:tokens:price-usd", args=(token.address,))
            )
            self.assertEqual(response.status_code, status.HTTP_200_OK)
            self.assertEqual(response.data["fiat_code"], "USD")
            self.assertEqual(
                response.data["fiat_price"], str(fiat_price_with_timestamp.fiat_price)
            )
            self.assertTrue(response.data["timestamp"])
            self.assertEqual(
                get_cached_usd_values_mock.call_args.args[1], [token.copy_price]
            )

    @mock.patch.object(
        PriceService, "get_native_coin_usd_price", return_value=321.2, autospec=True
    )
    def test_token_price_view_address_0(
        self, get_native_coin_usd_price_mock: MagicMock
    ):
        token_address = "0x0000000000000000000000000000000000000000"

        response = self.client.get(
            reverse("v1:tokens:price-usd", args=(token_address,))
        )

        # Native token should be retrieved even if it is not part of the Token table
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["fiat_code"], "USD")
        self.assertEqual(response.data["fiat_price"], "321.2")
        self.assertTrue(response.data["timestamp"])

    @mock.patch.object(
        PriceService,
        "get_native_coin_usd_price",
        side_effect=CannotGetPrice(),
    )
    def test_token_price_view_error(self, get_native_coin_usd_price_mock: MagicMock):
        token_address = "0x0000000000000000000000000000000000000000"

        response = self.client.get(
            reverse("v1:tokens:price-usd", args=(token_address,))
        )

        self.assertEqual(response.status_code, status.HTTP_503_SERVICE_UNAVAILABLE)
        self.assertEqual(response.data["message"], "Price retrieval failed")
        self.assertEqual(response.data["arguments"], [token_address])

'''
'''--- safe_transaction_service/tokens/urls.py ---
from django.urls import path

from . import views

app_name = "tokens"

urlpatterns = [
    path("", views.TokensView.as_view(), name="list"),
    path("<str:address>/", views.TokenView.as_view(), name="detail"),
    path("<str:address>/prices/usd/", views.TokenPriceView.as_view(), name="price-usd"),
]

'''
'''--- safe_transaction_service/tokens/views.py ---
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page

import django_filters.rest_framework
from rest_framework import response, status
from rest_framework.filters import OrderingFilter, SearchFilter
from rest_framework.generics import ListAPIView, RetrieveAPIView
from rest_framework.response import Response

from gnosis.eth.constants import NULL_ADDRESS
from gnosis.eth.utils import fast_is_checksum_address

from . import filters, serializers
from .clients import CannotGetPrice
from .models import Token
from .services import PriceServiceProvider

class TokenView(RetrieveAPIView):
    serializer_class = serializers.TokenInfoResponseSerializer
    lookup_field = "address"
    queryset = Token.objects.all()

    @method_decorator(cache_page(60 * 60))  # Cache 1 hour, this does not change often
    def get(self, request, *args, **kwargs):
        address = self.kwargs["address"]
        if not fast_is_checksum_address(address):
            return response.Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Invalid ethereum address",
                    "arguments": [address],
                },
            )

        return super().get(request, *args, **kwargs)

class TokensView(ListAPIView):
    serializer_class = serializers.TokenInfoResponseSerializer
    filter_backends = (
        django_filters.rest_framework.DjangoFilterBackend,
        SearchFilter,
        OrderingFilter,
    )
    filterset_class = filters.TokenFilter
    search_fields = ("name", "symbol")
    ordering_fields = "__all__"
    ordering = ("name",)
    queryset = Token.objects.all()

    @method_decorator(cache_page(60 * 15))  # Cache 15 minutes
    def get(self, request, *args, **kwargs):
        return super().get(request, *args, **kwargs)

class TokenPriceView(RetrieveAPIView):
    serializer_class = serializers.TokenPriceResponseSerializer
    lookup_field = "address"
    queryset = Token.objects.all()

    @method_decorator(cache_page(60 * 10))  # Cache 10 minutes
    def get(self, request, *args, **kwargs):
        address = self.kwargs["address"]
        if not fast_is_checksum_address(address):
            return response.Response(
                status=status.HTTP_422_UNPROCESSABLE_ENTITY,
                data={
                    "code": 1,
                    "message": "Invalid ethereum address",
                    "arguments": [address],
                },
            )
        try:
            price_service = PriceServiceProvider()
            if address == NULL_ADDRESS:
                data = {
                    "fiat_code": "USD",
                    "fiat_price": str(price_service.get_native_coin_usd_price()),
                    "timestamp": timezone.now(),
                }
            else:
                token = self.get_object()  # Raises 404 if not found
                fiat_price_with_timestamp = next(
                    price_service.get_cached_usd_values([token.get_price_address()])
                )
                data = {
                    "fiat_code": fiat_price_with_timestamp.fiat_code.name,
                    "fiat_price": str(fiat_price_with_timestamp.fiat_price),
                    "timestamp": fiat_price_with_timestamp.timestamp,
                }
            serializer = self.get_serializer(data=data)
            assert serializer.is_valid()
            return Response(status=status.HTTP_200_OK, data=serializer.data)

        except CannotGetPrice:
            return Response(
                status=status.HTTP_503_SERVICE_UNAVAILABLE,
                data={
                    "code": 10,
                    "message": "Price retrieval failed",
                    "arguments": [address],
                },
            )

'''
'''--- safe_transaction_service/utils/__init__.py ---

'''
'''--- safe_transaction_service/utils/admin.py ---
from django.contrib import admin

class HasLogoFilterAdmin(admin.SimpleListFilter):
    title = "Has Logo"
    parameter_name = "has_logo"

    def lookups(self, request, model_admin):
        return (
            ("YES", "Yes"),
            ("NO", "No"),
        )

    def queryset(self, request, queryset):
        if self.value() == "NO":
            return queryset.without_logo()
        elif self.value() == "YES":
            return queryset.with_logo()
        else:
            return queryset

'''
'''--- safe_transaction_service/utils/auth.py ---
from django.conf import settings
from django.contrib.auth.backends import RemoteUserBackend
from django.contrib.auth.middleware import RemoteUserMiddleware

class CustomHeaderRemoteUserMiddleware(RemoteUserMiddleware):
    """
    Headers that buzfeed SSO sends
    X-Forwarded-Email: tanjiro.kamado@gnosis.pm
    X-Forwarded-For: 81.211.153.216, 81.13.44.29
    X-Forwarded-Groups: developers@gnosis.pm
    X-Forwarded-Host: safe-transaction.dev.gnosisdev.com
    X-Forwarded-Host: safe-transaction.dev.gnosisdev.com
    X-Forwarded-Port: 443
    X-Forwarded-Proto: https
    X-Forwarded-Scheme: https
    X-Forwarded-User: tanjiro.kamado
    """

    header = settings.SSO_USERNAME_HEADER

class CustomRemoteUserBackend(RemoteUserBackend):
    def configure_user(self, request, user):
        """
        Configure a user after creation and return the updated user.

        By default, return the user unmodified.
        """
        user = super().configure_user(request, user)
        if user.username in settings.SSO_ADMINS:
            user.is_superuser = True
            user.is_staff = True
            user.save()
        return user

'''
'''--- safe_transaction_service/utils/celery.py ---
from celery._state import get_current_task
from celery.app.log import TaskFormatter
from celery.utils.log import ColorFormatter

class PatchedCeleryFormatterOriginal(TaskFormatter):  # pragma: no cover
    """
    Patched to work as an standard logging formatter. Basic version
    """

    def __init__(self, fmt=None, datefmt=None, style="%"):
        super().__init__(fmt=fmt, use_color=True)

class PatchedCeleryFormatter(ColorFormatter):  # pragma: no cover
    def __init__(self, fmt=None, datefmt=None, style="%", use_color=False):
        super().__init__(fmt=fmt, use_color=use_color)

    def format(self, record):
        task = get_current_task()
        if task and task.request:
            # For gevent pool, task_id will be something like `7ab44cb4-aacf-444e-bc20-4cbaa2a7b082`. For logs
            # is better to get it short
            task_id = task.request.id[:8] if task.request.id else task.request.id
            # Task name usually has all the package, better cut the first part for logging
            task_name = task.name.split(".")[-1] if task.name else task.name

            record.__dict__.update(task_id=task_id, task_name=task_name)
        else:
            record.__dict__.setdefault("task_name", "???")
            record.__dict__.setdefault("task_id", "???")
        return super().format(record)

'''
'''--- safe_transaction_service/utils/ethereum.py ---
from functools import cache

from gnosis.eth import EthereumClientProvider, EthereumNetwork

@cache
def get_ethereum_network() -> EthereumNetwork:
    return EthereumClientProvider().get_network()

'''
'''--- safe_transaction_service/utils/loggers.py ---
import logging
import time

from django.http import HttpRequest

from gunicorn import glogging

def get_milliseconds_now():
    return int(time.time() * 1000)

class IgnoreCheckUrl(logging.Filter):
    def filter(self, record: logging.LogRecord) -> bool:
        message = record.getMessage()
        return not ("GET /check/" in message and "200" in message)

class IgnoreSucceededNone(logging.Filter):
    """
    Ignore Celery messages like:
    ```
        Task safe_transaction_service.history.tasks.index_internal_txs_task[89ad3c46-aeb3-48a1-bd6f-2f3684323ca8]
        succeeded in 1.0970600529108196s: None
    ```
    They are usually emitted when a redis lock is active
    """

    def filter(self, rec: logging.LogRecord):
        message = rec.getMessage()
        return not ("Task" in message and "succeeded" in message and "None" in message)

class CustomGunicornLogger(glogging.Logger):
    def setup(self, cfg):
        super().setup(cfg)

        # Add filters to Gunicorn logger
        logger = logging.getLogger("gunicorn.access")
        logger.addFilter(IgnoreCheckUrl())

class LoggingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        self.logger = logging.getLogger("LoggingMiddleware")

    def __call__(self, request: HttpRequest):
        milliseconds = get_milliseconds_now()
        response = self.get_response(request)
        if request.resolver_match:
            route = (
                request.resolver_match.route if request.resolver_match else request.path
            )
            delta = get_milliseconds_now() - milliseconds
            self.logger.info(
                "MT::%s::%s::%s::%d::%s",
                request.method,
                route,
                delta,
                response.status_code,
                request.path,
            )
        return response

'''
'''--- safe_transaction_service/utils/redis.py ---
from functools import cache

from django.conf import settings

from redis import Redis

@cache
def get_redis() -> Redis:
    return Redis.from_url(settings.REDIS_URL)

'''
'''--- safe_transaction_service/utils/serializers.py ---
from typing import List

from eth_typing import ChecksumAddress
from rest_framework.exceptions import ValidationError
from web3.exceptions import BadFunctionCallOutput

from gnosis.eth import EthereumClientProvider
from gnosis.safe import Safe

def get_safe_owners(safe_address: ChecksumAddress) -> List[ChecksumAddress]:
    """
    :param safe_address:
    :return: Current owners for a Safe
    :raises: ValidationError
    """
    ethereum_client = EthereumClientProvider()
    safe = Safe(safe_address, ethereum_client)
    try:
        return safe.retrieve_owners(block_identifier="latest")
    except BadFunctionCallOutput as e:
        raise ValidationError(
            f"Could not get Safe {safe_address} owners from blockchain, check contract exists on network "
            f"{ethereum_client.get_network().name}"
        ) from e
    except IOError:
        raise ValidationError(
            "Problem connecting to the ethereum node, please try again later"
        )

def get_safe_version(safe_address: ChecksumAddress) -> str:
    """

    :param safe_address:
    :return: Current version for a Safe
    :raises: ValidationError
    """
    ethereum_client = EthereumClientProvider()
    safe = Safe(safe_address, ethereum_client)
    try:
        return safe.retrieve_version()
    except BadFunctionCallOutput as e:
        raise ValidationError(
            f"Could not get Safe {safe_address} version from blockchain, check contract exists on network "
            f"{ethereum_client.get_network().name}"
        ) from e
    except IOError:
        raise ValidationError(
            "Problem connecting to the ethereum node, please try again later"
        )

'''
'''--- safe_transaction_service/utils/tasks.py ---
import contextlib
from typing import Optional, Set

import gevent
from celery.app.task import Task as CeleryTask
from celery.signals import celeryd_init, worker_shutting_down
from celery.utils.log import get_task_logger
from redis.exceptions import LockError

from .redis import get_redis
from .utils import close_gevent_db_connection

logger = get_task_logger(__name__)

LOCK_TIMEOUT = 60 * 15  # 15 minutes
SOFT_TIMEOUT = 60 * 10  # 10 minutes
ACTIVE_LOCKS: Set[str] = set()  # Active redis locks, release them when worker stops
WORKER_STOPPED = set()  # Worker status

@celeryd_init.connect
def configure_workers(sender=None, conf=None, **kwargs):
    def worker_patch_psycopg():
        """
        Patch postgresql to be friendly with gevent
        """
        try:
            from psycogreen.gevent import patch_psycopg

            logger.info("Patching Celery psycopg for gevent")
            patch_psycopg()
            logger.info("Patched Celery psycopg for gevent")
        except ImportError:
            pass

    worker_patch_psycopg()

@worker_shutting_down.connect
def worker_shutting_down_handler(sig, how, exitcode, **kwargs):
    logger.warning("Worker shutting down")
    gevent.spawn(shutdown_worker)  # If not raises a `BlockingSwitchOutError`

def shutdown_worker():
    WORKER_STOPPED.add(True)
    if ACTIVE_LOCKS:
        logger.warning("Force releasing of redis locks %s", ACTIVE_LOCKS)
        get_redis().delete(*ACTIVE_LOCKS)
        logger.warning("Released redis locks")
    else:
        logger.warning("No redis locks to release")

@contextlib.contextmanager
def only_one_running_task(
    task: CeleryTask,
    lock_name_suffix: Optional[str] = None,
    blocking_timeout: int = 1,
    lock_timeout: Optional[int] = LOCK_TIMEOUT,
    gevent: bool = True,
):
    """
    Ensures one running task at the same, using `task` name as a unique key

    :param task: CeleryTask
    :param lock_name_suffix: A suffix for the lock name, in the case that the same task can be run at the same time
    when it has different arguments
    :param blocking_timeout: Waiting blocking timeout, it should be as small as possible to the worker can release
    the task
    :param lock_timeout: How long the lock will be stored, in case worker is halted so key is not stored forever
    in Redis
    :param gevent: If `True`, `close_gevent_db_connection` will be called at the end
    :return: Instance of redis `Lock`
    :raises: LockError if lock cannot be acquired
    """
    if WORKER_STOPPED:
        raise LockError("Worker is stopping")
    redis = get_redis()
    lock_name = f"tasks:{task.name}"
    if lock_name_suffix:
        lock_name += f":{lock_name_suffix}"
    with redis.lock(
        lock_name, blocking_timeout=blocking_timeout, timeout=lock_timeout
    ) as lock:
        try:
            ACTIVE_LOCKS.add(lock_name)
            yield lock
            ACTIVE_LOCKS.remove(lock_name)
        finally:
            if gevent:
                # Needed for django-db-geventpool
                close_gevent_db_connection()

'''
'''--- safe_transaction_service/utils/tests/__init__.py ---

'''
'''--- safe_transaction_service/utils/tests/test_loggers.py ---
from logging import LogRecord

from django.test import TestCase

from ..loggers import IgnoreCheckUrl, IgnoreSucceededNone

class TestLoggers(TestCase):
    def test_ignore_check_url(self):
        name = "name"
        level = 1
        pathname = "/"
        lineno = 2
        ignore_check_url = IgnoreCheckUrl(name)
        check_log = LogRecord(
            name, level, pathname, lineno, "200 GET /check/", args=(), exc_info=()
        )
        other_log = LogRecord(
            name, level, pathname, lineno, "200 GET /not-check/", args=(), exc_info=()
        )
        self.assertFalse(ignore_check_url.filter(check_log))
        self.assertTrue(ignore_check_url.filter(other_log))

    def test_ignore_succeeded_none(self):
        name = "name"
        level = 1
        pathname = "/"
        lineno = 2
        ignore_check_url = IgnoreSucceededNone(name)
        task_log = LogRecord(
            name,
            level,
            pathname,
            lineno,
            "Task safe_transaction_service.history.tasks.index_internal_"
            "txs_task[89ad3c46-aeb3-48a1-bd6f-2f3684323ca8] succeeded in "
            "1.0970600529108196s: None",
            args=(),
            exc_info=(),
        )
        other_log = LogRecord(
            name, level, pathname, lineno, "Not a task log", args=(), exc_info=()
        )
        self.assertFalse(ignore_check_url.filter(task_log))
        self.assertTrue(ignore_check_url.filter(other_log))

'''
'''--- safe_transaction_service/utils/tests/test_tasks.py ---
from unittest import mock

from django.test import TestCase

from celery.app.task import Task as CeleryTask
from redis.exceptions import LockError

from ..tasks import (
    WORKER_STOPPED,
    configure_workers,
    only_one_running_task,
    worker_shutting_down_handler,
)

class TestTasks(TestCase):
    def test_configure_workers(self):
        configure_workers()

    def test_worker_shutting_down_handler(self):
        worker_shutting_down_handler(None, None, None)

    def test_only_one_running_task(self):
        celery_task = CeleryTask()
        celery_task.name = "Test Name"
        with only_one_running_task(celery_task):
            with self.assertRaises(LockError):
                with only_one_running_task(celery_task):
                    pass

        with mock.patch.dict(WORKER_STOPPED, {True: True}):
            with self.assertRaisesMessage(LockError, "Worker is stopping"):
                with only_one_running_task(celery_task):
                    pass

'''
'''--- safe_transaction_service/utils/utils.py ---
from functools import wraps
from itertools import islice
from typing import Any, Iterable, List, Union

from django.core.signals import request_finished
from django.db import connection

from gevent.monkey import saved

def chunks(elements: List[Any], n: int) -> Iterable[Any]:
    """
    :param elements: List
    :param n: Number of elements per chunk
    :return: Yield successive n-sized chunks from l
    """
    for i in range(0, len(elements), n):
        yield elements[i : i + n]

def chunks_iterable(iterable: Iterable[Any], n: int) -> Iterable[Iterable[Any]]:
    """
    Same as `chunks`, but for iterables

    :param iterable:
    :param n:
    :return:
    """
    it = iter(iterable)
    while True:
        chunk = tuple(islice(it, n))
        if not chunk:
            return None
        yield chunk

def running_on_gevent() -> bool:
    return "sys" in saved

def close_gevent_db_connection() -> None:
    """
    Clean gevent db connections. Check `atomic block` to prevent breaking the tests (Django `TestCase` wraps tests
    inside an atomic block that rollbacks at the end of the test)
    https://github.com/jneight/django-db-geventpool#using-orm-when-not-serving-requests
    """
    if not connection.in_atomic_block:
        request_finished.send(sender="greenlet")

def close_gevent_db_connection_decorator(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        finally:
            close_gevent_db_connection()

    return wrapper

def parse_boolean_query_param(value: Union[bool, str, int]) -> bool:
    return value in (True, "True", "true", "1", 1)

'''
'''--- scripts/autodeploy.sh ---
#!/bin/bash

set -ev

curl -s --output /dev/null --write-out "%{http_code}" \
    -H "Content-Type: application/json" \
    -X POST \
    -u "$AUTODEPLOY_TOKEN" \
    -d '{"push_data": {"tag": "'$TARGET_ENV'" }}' \
    $AUTODEPLOY_URL
'''
'''--- scripts/benchmark_keccak.py ---
import os

import sha3
from Crypto.Hash import keccak as crypto_keccak
from eth_hash.auto import keccak as eth_hash_keccak
from web3 import Web3

def eth_hash_benchmark():
    return eth_hash_keccak(os.urandom(32)).hex()

def web3_benchmark():
    return Web3.keccak(os.urandom(32)).hex()

def cryptodome_benchmark():
    k = crypto_keccak.new(data=os.urandom(32), digest_bits=256)
    return k.hexdigest()

def pysha3_benchmark():
    return sha3.keccak_256(os.urandom(32)).hexdigest()

if __name__ == "__main__":
    import timeit

    print(
        "eth_hash",
        timeit.timeit(
            "eth_hash_benchmark()",
            setup="from __main__ import eth_hash_benchmark",
            number=500000,
            globals=globals(),
        ),
    )
    print(
        "web3",
        timeit.timeit(
            "web3_benchmark()",
            setup="from __main__ import web3_benchmark",
            number=500000,
            globals=globals(),
        ),
    )
    print(
        "cryptodome",
        timeit.timeit(
            "cryptodome_benchmark()",
            setup="from __main__ import cryptodome_benchmark",
            number=500000,
            globals=globals(),
        ),
    )
    print(
        "pysha3",
        timeit.timeit(
            "pysha3_benchmark()",
            setup="from __main__ import pysha3_benchmark",
            number=500000,
            globals=globals(),
        ),
    )

'''
'''--- scripts/benchmark_node.py ---
import time
from contextlib import contextmanager

from gevent.pool import Pool

from gnosis.eth import EthereumClient

@contextmanager
def timing(function: str = ""):
    start = time.time()
    yield
    print(function, "Elapsed:", time.time() - start)

if __name__ == "__main__":
    from gevent import monkey

    monkey.patch_all()  # noqa
    pool = Pool(200)
    e = EthereumClient("http://localhost:8545")
    blocks_to_fetch = list(range(12773522 - 10000, 12773522))

    with timing("Batch get blocks"):
        e.get_blocks(blocks_to_fetch)

    # with timing('Secuential get blocks'):
    #     for block in blocks_to_fetch:
    #         e.get_block(block)

    with timing("Parallel get blocks"):
        jobs = [pool.spawn(e.get_block, block) for block in blocks_to_fetch]
        pool.join()

'''
'''--- scripts/deploy_docker.sh ---
#!/bin/bash

set -euo pipefail

export DOCKER_BUILDKIT=1

if [ "$1" = "develop" -o "$1" = "master" ]; then
    # If image does not exist, don't use cache
    docker pull safeglobal/$DOCKERHUB_PROJECT:$1 && \
    docker build -t $DOCKERHUB_PROJECT -f docker/web/Dockerfile . --cache-from safeglobal/$DOCKERHUB_PROJECT:$1 --build-arg BUILDKIT_INLINE_CACHE=1 || \
    docker build -t $DOCKERHUB_PROJECT -f docker/web/Dockerfile . --build-arg BUILDKIT_INLINE_CACHE=1
else
    # Building tag version from staging image (vX.X.X)
    docker pull safeglobal/$DOCKERHUB_PROJECT:staging && \
    docker build -t $DOCKERHUB_PROJECT -f docker/web/Dockerfile . --cache-from safeglobal/$DOCKERHUB_PROJECT:staging --build-arg BUILDKIT_INLINE_CACHE=1 || \
    docker build -t $DOCKERHUB_PROJECT -f docker/web/Dockerfile . --build-arg BUILDKIT_INLINE_CACHE=1
    # Only push latest on release
    case $1 in v*)
        docker tag $DOCKERHUB_PROJECT safeglobal/$DOCKERHUB_PROJECT:latest
        docker push safeglobal/$DOCKERHUB_PROJECT:latest
    esac
fi
docker tag $DOCKERHUB_PROJECT safeglobal/$DOCKERHUB_PROJECT:$1
docker push safeglobal/$DOCKERHUB_PROJECT:$1

'''