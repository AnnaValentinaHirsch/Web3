*GitHub Repository "GoalPanda/rust-contract-example"*

'''--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

'''
'''--- .github/ISSUE_TEMPLATE/feature_request.md ---
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

'''
'''--- CONTRIBUTING.md ---
# How to Contribute
## Report a  problem or suggestion
Go to our [issue tracker](https://github.com/emaitee/mylikita-rust-smart-contract/issues) and check if your problem/suggestion is already reported. If not, create a new issue with a descriptive title and detail your suggestion or steps to reproduce the problem.

If you are reporting a bug, please point the environment where you find it, if you can, please confirm if the bug happens in other environments and list it.

## Filter Issues
You can help answering issue questions; maturing or voting on feature suggestions; confirming bug reports and adding more information to then. You can help a lot locating the bug source and proposing test code to prevent regression bug.

## Contribute to the code
If you know how to code, we welcome you to send fixes and new features, but in order to be efficient we ask you to follow the following procedure:

- Fork this repo;
  By clicking on the fork button on [Github](https://github.com/emaitee/mylikita-rust-smart-contract)
- Clone your forked repo locally:
  `git clone [project URL]`
- Run `npm install` to install all dependencies
- Run `npm start` to start the app
- Code your changes (if you want to implement many features do each one in a separated branch)
- Write tests to ensure your feature works as expected and protect its behavior on future changes;
Test it! Ensure you don't crash this project in Node.js or Browser environments;
- Full test with npm test will also produce a coverage report.
- Push to your forked repo;
- Make your pull request.

For detail tutorial on how to contribute, [The beginner's guide to contributing to a GitHub project](https://akrabat.com/the-beginners-guide-to-contributing-to-a-github-project/)

'''
'''--- Cargo.toml ---
[package]
name = "mylikita"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = { version = "1.0", features = ["derive"] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- README.md ---
Mylikita Implements Blockchain Using The NEAR Protocol, patient consultation history was stored in NEAR Protocol, medical records are confidential that is why we use unique encryption algorithms before storing the data.

Let's get started on how we do it.

First, we creat function set_consultation,The function accept some parameters, parameters like consultation_notes,treatmentPlan,dressing_request,nursing_request we use unique encryption algorithms to encrypt the data.
Note: parameters like consultation_notes,treatmentPlan are required.

Once the function, "set_consultation" is called and appropriate parameters are passed, the function will store the record onto the blockchain.

Example: set_consultation({"payload": {
id: '.....',
patient_id: '1-7',
user_id: '5',
consultation_notes: '......',
treatment_plan: '....',
decision: 'out-patient',
dressing_request: '...',
nursing_request: '...',
nursing_request_status: 'pending',
facility_id: null,
created_at: '2022-10-05',
treatment_plan_status: 'pending',
treated_by: "..",
}})

Therefore, one's get_consultation function is call it would return

!['login page'](https://github.com/emaitee/mylikita-near-wallet-project/blob/main/img/image2.png)

Finally if you want to view the entire consultation record store then you can call get_consultation

!['login page'](https://github.com/emaitee/mylikita-near-wallet-project/blob/main/img/image1.png)

<details>
<summary>For more info</summary>
<p>https://mylikita.clinic/</p>
<p>https://mylikitahealth.medium.com/mylikita-receives-a-10-000-grant-from-the-near-foundation-3db18e928e15</p>
<p>https://mylikitahealth.medium.com/how-mylikita-implements-blockchain-using-the-near-protocol-a1a84bb06329</p>
</details>

# Contribute
If you know how to code, we welcome you to send fixes and new features, but in order to be efficient we ask you [to follow the following procedure](https://github.com/emaitee/mylikita-rust-smart-contract/blob/master/CONTRIBUTING.md).

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1665424847843-57494689300737
'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedMap};
use near_sdk::{env, near_bindgen, require, AccountId, PanicOnDefault};
use near_sdk::serde::{Serialize, Deserialize};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Consultations {
    consultations: UnorderedMap<String, Consultation>
}

#[near_bindgen]
impl Consultations {
    
    #[init]
    pub fn init() -> Self {
        Self {
            consultations: UnorderedMap::new(b"consultations".to_vec()),
        }
    }

 
    pub fn set_consultation(&mut self, payload: Payload) {
        require!(self.consultations.get(&payload.id).is_none(), format!("a consultation with {} already exists", payload.id));
        let consult = Consultation::from_payload(payload);
        self.consultations.insert(&consult.id, &consult);
    }

    pub fn get_consultation(self, id: &String) -> Option<Consultation> {
        self.consultations.get(id)
    }

  
    pub fn get_consultation_history(self) -> Vec<Consultation> {
        self.consultations.values_as_vector().to_vec()
    }
}

#[near_bindgen]
#[derive(Serialize, Deserialize, PanicOnDefault)]
pub struct Payload {
    id: String,
    patient_id: String,
    user_id: String,
    consultation_notes: String,
    treatment_plan: String,
    decision: String,
    dressing_request: String,
    nursing_request: String,
    nursing_request_status: String,
    facility_id: String,
    created_at: String,
    treatment_plan_status: String,
    treated_by: String,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, Serialize, PanicOnDefault)]
pub struct Consultation {
    id: String,
    patient_id: String,
    user_id: String,
    consultation_notes: String,
    treatment_plan: String,
    decision: String,
    dressing_request: String,
    nursing_request: String,
    nursing_request_status: String,
    facility_id: String,
    created_at: String,
    treatment_plan_status: String,
    treated_by: String,
    owner: AccountId,
}

impl Consultation {
    pub fn from_payload(payload: Payload) -> Self {
        Self {
            id: payload.id,
            patient_id: payload.patient_id,
            user_id: payload.user_id,
            consultation_notes: payload.consultation_notes,
            treatment_plan: payload.treatment_plan,
            decision: payload.decision,
            dressing_request: payload.dressing_request,
            nursing_request: payload.nursing_request,
            nursing_request_status: payload.nursing_request_status,
            facility_id: payload.facility_id,
            created_at: payload.created_at,
            treatment_plan_status: payload.treatment_plan_status,
            treated_by: payload.treated_by,
            owner: env::signer_account_id()
        }
    }

   
}

'''