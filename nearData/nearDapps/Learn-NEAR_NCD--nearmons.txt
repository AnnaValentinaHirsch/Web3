*GitHub Repository "Learn-NEAR/NCD--nearmons"*

'''--- README.md ---
# near-mons

This is an application that utilizes a smart contract that mints NFTs as ingame collectibles. 

Users can create new creatures by having two parent creatures fuse to form a child creature, which will inherit its parents' skills and attributes. This feature can lead to almost endless number of unique creature instances, with builds that would define the meta or are just for the memes.

This smart contract serves to keep the integrity of the owner's creatures and be applied to future applications, maybe like an online trading card game or role-playing game.

## Usage

### Getting started

1. clone this repo to a local folder
2. run `yarn`
3. run `yarn test`
4. run `near login` (yarn install near-cli)
5. run `./scripts/1.init.sh `
5. run `./scripts/2.run.sh `

## The file system

### Contracts and Unit Tests

```txt
assembly                        <-- contract
├── __tests__
│   ├── README.md
│   └── index.unit.spec.ts
└── index.ts
|__ model.ts
```

### Helper Scripts

```txt
scripts
├── 1.init.sh
├── 2.run.sh
└── README.md                     <-- instructions
```

Smart Contract API
=====================

model.ts
----------

   List of creature ids.

      export class CreatureIdList {
         constructor(public arrayOfIds: Array<string>) { }
      }

   Creature class that contains the creature's owner and metadata.

      export class Creature {
        owner: string;
        constructor(
          public sampleId: string,
          public instanceId: string,
          public name: string,
          public atk: string,
          public def: string,
          public spd: string,
          public skills: Array<string>,
          public element: string,
          public evolutionRank: string,
        ) {
          this.owner = context.sender;
        }
      }

   Creature class used to preview creatures in their original states.

      export class SampleCreature {
         public sampleId: string,
         public name: string;
         public atk: string;
         public def: string;
         public spd: string;
         public skills: Array<String>;
         public type: string;
         public evo: string;
      }

   A persistent map that links creature id to creature object.

      export const creaturesByInstanceId = new PersistentMap<string, Creature>('ci');

   A persistent map that links owner name to array of creature ids they own.
         
      export const creaturesByOwner = new PersistentMap<string, CreatureIdList>("co")

   A map of all sample creatures with their sample id as key.

      export const sampleCreaturesMap = new PersistentMap<string, SampleCreature>("cm")

   A map of all type combinations during procreation. Concatenate the two parents' types in alphabetical order into a string, then use this map to find the value of the child's type. If the parents share the same type, then the child will be of that type too.

      export const generationMap = new PersistentMap<string, string>("gm")

   A map of all evolution combinations during procreation. Concatenate the two parents' evolution ranks in numerical order into a string, then use this map to find the value of the child's evolution rank.

      export const offspringMap = new PersistentMap<string, string>("om")
   
index.ts
----------

   Initializes contract, as well as procreation and creature data.

      export function init(): void

   Return array list of creature objects owned by a user.

      export function getCreaturesByOwner(owner: string): Creature[]

   Function to let the user foresee what child creature they will get from the parent's procreation, along with their skills and attributes. From the user interface, after being viewed what child creature will result from both parents, the user can select which of the parents' skills the child will learn, and which of the child's skills it will forget.

      export function previewFutureChildCreature(creatureInstanceIdA: string, creatureInstanceIdB: string): SampleCreature
      
   Procreate a new creature using the parent's instance ids, user's chosen skills, and the SampleCreature of the future child creature.

      export function procreateCreature(parentInstanceIdA: string, parentInstanceIdB: string, newSkills: Array<string>, newCreatureSampleId: string): Creature
   
   Generate a new creature, this is primarily a helper function to procreateCreature(). In here, a new creature object is created, assigned a random ID, and set to an owner.

      function generateCreatureObject(
        instanceId: string,
        newCreature: SampleCreature,
        newSkills: Array<string>
      ): Creature

   Function to give two creatures to the owner, should only be called if the owner does not have creatures.

      export function giveCreaturesToOwner(creatureSampleId1: string, creatureSampleId2: string): Array<Creature>

   Get sample creature using sample Id.

      export function getSampleCreature(creatureSampleId: string): SampleCreature

   Get generation from generation map.

      export function getGeneration(combo: string): string

   Get offspring output from offspring map.

      export function getOffspring(combo: string): string

   Get the creature ids from the owner.

      function getCreatureIdsByOwner(owner: string): Array<string>

   Assign the creature ids to the owner.

      function setCreatureIdsByOwner(owner: string, id: string): void

   Delete the creature ids from the owner.

      function deleteCreatureIdsByOwner(owner: string, id: string): void

   Get creature object by id.

      export function getCreatureById(id: string): Creature

   Set creature object by id.

      function setCreatureById(id: string, creature: Creature): void

   Delete creature object by id.

      export function deleteCreatureById(id: string): void

   Random ID Generator.

      function generateRandomId(): String {
         const ID_DIGITS: u32 = 16;
         return base64.encode(math.randomBuffer(ID_DIGITS));
      }
'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "assembly/index.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
}
'''
'''--- assembly/__tests__/README.md ---
        [Describe]: Initialize contract

        [Success]: ✔ Sample creatures are available in map
        [Success]: ✔ Generation map is available
        [Success]: ✔ Offspring map is available

        [Describe]: Give owner 2 creatures

        [Success]: ✔ owner does not own any creatures
        [Success]: ✔ owner is given 2 creatures

        [Describe]: Test hardcoded getters

        [Success]: ✔ Test get and set CreatureIdList

        [Describe]: Can create creature

        [Success]: ✔ test generateCreatureObject()
        [Success]: ✔ test setCreatureByInstanceId() and setCreatureIdsByOwner() from          generateCreatureObject()

        [Describe]: Can preview and procreate creatures

        [Success]: ✔ Test Preview
        [Success]: ✔ Test Procreate
        [Success]: ✔ Test Preview and procreate

        [Describe]: Test getter functions

        [Success]: ✔ Get creature objects by owner
        [Success]: ✔ Get child creature preview
        [Success]: ✔ Get sample creature objects map
        [Success]: ✔ Get generation map
        [Success]: ✔ Get offspring map
        [Success]: ✔ Get creature by instance id

        [Describe]: Delete creature from owner

        [Success]: ✔ delete by instance id

        [File]: assembly/__tests__/main.unit.spec.ts
        [Groups]: 8 pass, 8 total
        [Result]: ✔ PASS
        [Snapshot]: 0 total, 0 added, 0 removed, 0 different
        [Summary]: 18 pass,  0 fail, 18 total
        [Time]: 1087.158ms

        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        [Result]: ✔ PASS
        [Files]: 1 total
        [Groups]: 8 count, 8 pass
        [Tests]: 18 pass, 0 fail, 18 total
'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__tests__/main.unit.spec.ts ---
import {
  init,
  getCreaturesByOwner,
  procreateCreature,
  previewFutureChildCreature,
  giveCreaturesToOwner,
  getSampleCreature,
  getGeneration,
  getOffspring,
  setCreatureByInstanceId,
  setCreatureIdsByOwner,
  getCreatureByInstanceId,
  deleteCreatureByInstanceId,
} from "../index";

import {
  CreatureIdList,
  Creature,
  SampleCreature,
  sampleCreaturesMap,
  generationMap,
  offspringMap,
  creaturesByOwner,
  creaturesByInstanceId
} from "../models"

import { storage, PersistentDeque, PersistentMap, PersistentVector, VMContext, VM, logging } from "near-sdk-as";

const owner = 'bob';

const tempCreature1: Creature = new Creature(
  'f0',
  '1',
  'sal',
  '10',
  '10',
  '10',
  ['fb'],
  'f',
  '0'
);

const tempCreature2: Creature = new Creature(
  'w0',
  '2',
  'tur',
  '10',
  '20',
  '10',
  ['ws', 'du'],
  'w',
  '0'
);

const tempSampleCreature1: SampleCreature = new SampleCreature(
  'f0',
  'sal',
  '10',
  '10',
  '10',
  ['fb'],
  'f',
  '0'
);

const tempSampleCreature2: SampleCreature = new SampleCreature(
  'w0',
  'tur',
  '10',
  '20',
  '10',
  ['ws', 'du'],
  'w',
  '0'
);

beforeEach(init);

describe("Initialize contract", () => {

  it("Sample creatures are available in map", () => {
    expect(sampleCreaturesMap.contains("f0")).toBe(true);
  });

  it("Generation map is available", () => {
    expect(generationMap.contains('dw')).toBe(true);
  });

  it("Offspring map is available", () => {
    expect(offspringMap.contains('00')).toBe(true);
  });
});

describe("Give owner 2 creatures", () => {

  it("owner does not own any creatures", () => {
    let creatureIdList = getCreaturesByOwner(owner);
    expect(creatureIdList).toHaveLength(0);
  });

  it("owner is given 2 creatures", () => {
    let creatureIdList = getCreaturesByOwner(owner);
    expect(creatureIdList).toHaveLength(0);
    const givenCreatures: Array<Creature> = giveCreaturesToOwner('d0', 'l0');
    creatureIdList = getCreaturesByOwner(owner);
    expect(creatureIdList).toHaveLength(2);
  });
});

describe("Test hardcoded getters", () => {

  // simulates generateCreature
  it("Test get and set CreatureIdList", () => {

    // setCreatureById
    creaturesByInstanceId.set('1', tempCreature1);

    // getCreatureIdsByOwner
    let idList = creaturesByOwner.get(owner);
    expect(idList).toBeNull();
    let arrayOfIds = new Array<string>();

    // setCreatureIdsByOwner
    arrayOfIds.push('1');
    let newList = new CreatureIdList(arrayOfIds);
    creaturesByOwner.set(owner, newList);

    // final: test getter of creaturesById
    let retrievedCreature = creaturesByInstanceId.get('1');
    expect(retrievedCreature).toStrictEqual(tempCreature1);

    // final: test getter of creaturesByOwner
    idList = creaturesByOwner.get(owner);
    expect(idList).not.toBeNull();
  })
})

describe("Can create creature", () => {

  it("test generateCreatureObject()", () => {
    let creatureIdList = creaturesByOwner.get(owner);
    expect(creatureIdList).toBeNull();

    const givenCreatures: Array<Creature> = giveCreaturesToOwner('d0', 'l0');
    const futureCreature: SampleCreature = previewFutureChildCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId);

    // calls generateCreature, setCreatureById, getCreatureIdsByOwner, setCreatureIdsByOwner
    let creatureObj = procreateCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId, futureCreature.skills, futureCreature.sampleId);

    expect(creatureObj).not.toBeNull();

    // final: test getter of creaturesBySampleId
    let retrievedCreature = creaturesByInstanceId.get(creatureObj.instanceId);
    expect(retrievedCreature).toStrictEqual(creatureObj);

    // final: test getter of creaturesByOwner
    creatureIdList = creaturesByOwner.get(owner);
    expect(creatureIdList).not.toBeNull();

    expect(creatureObj.owner).toBe(owner);
    if (creatureIdList) {
      expect(creatureIdList.arrayOfIds[2]).toBe(creatureObj.instanceId);
      expect(futureCreature.sampleId).toBe(creatureObj.sampleId);
    }
  });

  it("test setCreatureByInstanceId() and setCreatureIdsByOwner() from generateCreatureObject()", () => {
    let creatureIdList = creaturesByOwner.get(owner);
    expect(creatureIdList).toBeNull();

    setCreatureByInstanceId(tempCreature1.instanceId, tempCreature1);
    setCreatureIdsByOwner(owner, tempCreature1.instanceId);

    // final: test getter of creaturesByinstanceId
    let retrievedCreature = creaturesByInstanceId.get(tempCreature1.instanceId);
    expect(retrievedCreature).toStrictEqual(tempCreature1);

    // final: test getter of creaturesByOwner
    creatureIdList = creaturesByOwner.get(owner);
    expect(creatureIdList).not.toBeNull();
  })
});

beforeEach(init);

describe("Can preview and procreate creatures", () => {

  it("Test Preview", () => {
    const givenCreatures: Array<Creature> = giveCreaturesToOwner('d0', 'l0');

    let child_evolutionRank = givenCreatures[0].evolutionRank < givenCreatures[1].evolutionRank ?
    offspringMap.getSome(givenCreatures[0].evolutionRank.concat(givenCreatures[1].evolutionRank)) :
    offspringMap.getSome(givenCreatures[1].evolutionRank.concat(givenCreatures[0].evolutionRank));

    let child_element = givenCreatures[0].element < givenCreatures[1].element ?
    generationMap.getSome(givenCreatures[0].element.concat(givenCreatures[1].element)) :
    givenCreatures[0].element > givenCreatures[1].element ?
    generationMap.getSome(givenCreatures[1].element.concat(givenCreatures[0].element)) :
    givenCreatures[0].element.toString();

    let newCreature = sampleCreaturesMap.getSome(child_element.concat(child_evolutionRank));

    expect(newCreature.sampleId).toBe('n1');
    expect(newCreature.name).toBe('swo');
  });

  it("Test Procreate", () => {
    const givenCreatures: Array<Creature> = giveCreaturesToOwner('d0', 'l0');

    const futureCreature: SampleCreature = previewFutureChildCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId);
    const createdCreature: Creature = procreateCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId, futureCreature.skills, futureCreature.sampleId);

    expect(createdCreature.name).toBe(futureCreature.name);
    expect(createdCreature.atk).toBe(futureCreature.atk);
    expect(createdCreature.def).toBe(futureCreature.def);
    expect(createdCreature.spd).toBe(futureCreature.spd);
    expect(createdCreature.element).toBe(futureCreature.element);
    expect(createdCreature.evolutionRank).toBe(futureCreature.evolutionRank);
  })

  it("Test Preview and procreate", () => {

    const givenCreatures: Array<Creature> = giveCreaturesToOwner('f0', 'w0');
    const futureCreature: SampleCreature = previewFutureChildCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId);

    const skillsArray = [givenCreatures[0].skills[0], givenCreatures[1].skills[0], givenCreatures[1].skills[1], futureCreature.skills[0]]
    const createdCreature: Creature = procreateCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId, skillsArray, futureCreature.sampleId);

    expect(futureCreature.name).toBe(sampleCreaturesMap.getSome('d1').name);
    expect(futureCreature.atk).toBe(sampleCreaturesMap.getSome('d1').atk);
    expect(futureCreature.def).toBe(sampleCreaturesMap.getSome('d1').def);
    expect(futureCreature.spd).toBe(sampleCreaturesMap.getSome('d1').spd);
    expect(futureCreature.skills).toHaveLength(sampleCreaturesMap.getSome('d1').skills.length);
    expect(futureCreature.element).toBe(sampleCreaturesMap.getSome('d1').element);
    expect(futureCreature.evolutionRank).toBe(sampleCreaturesMap.getSome('d1').evolutionRank);

    expect(createdCreature.sampleId).toBe(sampleCreaturesMap.getSome('d1').sampleId);
    expect(createdCreature.name).toBe(sampleCreaturesMap.getSome('d1').name);
    expect(createdCreature.atk).toBe(sampleCreaturesMap.getSome('d1').atk);
    expect(createdCreature.def).toBe(sampleCreaturesMap.getSome('d1').def);
    expect(createdCreature.spd).toBe(sampleCreaturesMap.getSome('d1').spd);
    expect(createdCreature.skills).toHaveLength(skillsArray.length);
    expect(createdCreature.element).toBe(sampleCreaturesMap.getSome('d1').element);
    expect(createdCreature.evolutionRank).toBe(sampleCreaturesMap.getSome('d1').evolutionRank);
  });
})

describe("Test getter functions", () => {

  it("Get creature objects by owner", () => {
    let creaturesList: Creature[] = getCreaturesByOwner(owner)
    expect(creaturesList).toHaveLength(0);
    
    const givenCreatures: Array<Creature> = giveCreaturesToOwner('d0', 'l0');
    creaturesList = getCreaturesByOwner(owner);
    expect(creaturesList).toHaveLength(2);
  });

  it("Get child creature preview", () => {
    const givenCreatures: Array<Creature> = giveCreaturesToOwner('f0', 'w0');

    let creature = previewFutureChildCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId);

    expect(creature.sampleId).toBe('d1');
    expect(creature.name).toBe('imp');
  });

  it("Get sample creature objects map", () => {
    let creature = getSampleCreature('d0');
    expect(creature.name).toBe('bat');
  });

  it("Get generation map", () => {
    let generation = getGeneration('df');
    expect(generation).toStrictEqual('g');
  });

  it("Get offspring map", () => {
    let offspring = getOffspring('00');
    expect(offspring).toStrictEqual('1');
  });

  it("Get creature by instance id", () => {
    const givenCreatures: Array<Creature> = giveCreaturesToOwner('f0', 'w0');
    const futureCreature: SampleCreature = previewFutureChildCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId);
    let creatureObj = procreateCreature(givenCreatures[0].instanceId, givenCreatures[1].instanceId, futureCreature.skills, futureCreature.sampleId);
    let creature = getCreatureByInstanceId(creatureObj.instanceId);

    expect(creature.name).toBe(creatureObj.name);
  });
});

describe('Delete creature from owner', () => {

  it('delete by instance id', () => {
    const givenCreatures: Array<Creature> = giveCreaturesToOwner('d0', 'l0');

    let numCreatures = getCreaturesByOwner(owner);
    expect(numCreatures).toHaveLength(2);
    deleteCreatureByInstanceId(givenCreatures[0].instanceId);

    numCreatures = getCreaturesByOwner(owner);
    expect(numCreatures).toHaveLength(1);
    deleteCreatureByInstanceId(givenCreatures[1].instanceId);

    numCreatures = getCreaturesByOwner(owner);
    expect(numCreatures).toHaveLength(0);
  })
});
'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/index.ts ---
import { context, logging, base64, math, PersistentVector, PersistentMap } from "near-sdk-as";

import {
  CreatureIdList,
  Creature,
  SampleCreature,
  creaturesByInstanceId,
  creaturesByOwner,
  sampleCreaturesMap,
  generationMap,
  offspringMap,
  initContract
} from "./models";

export function init(): void {
  initContract();
}

export function getCreaturesByOwner(owner: string): Creature[] {
  let creatureIdList = getCreatureIdsByOwner(owner);
  let creaturesList = new Array<Creature>();
  for (let i = 0; i < creatureIdList.length; i++) {
    let creatureId = creatureIdList[i];
    if (creaturesByInstanceId.contains(creatureId)) {
      let creature = creaturesByInstanceId.getSome(creatureId);
      creaturesList.push(creature);
    }
  }
  return creaturesList;
}

export function previewFutureChildCreature(creatureInstanceIdA: string, creatureInstanceIdB: string): SampleCreature {
  let parentA = getCreatureByInstanceId(creatureInstanceIdA);
  let parentB = getCreatureByInstanceId(creatureInstanceIdB);

  let child_evolutionRank = parentA.evolutionRank < parentB.evolutionRank ?
    offspringMap.getSome(parentA.evolutionRank.concat(parentB.evolutionRank)) :
    offspringMap.getSome(parentB.evolutionRank.concat(parentA.evolutionRank));

  let child_element = parentA.element < parentB.element ?
    generationMap.getSome(parentA.element.concat(parentB.element)) :
    parentA.element > parentB.element ?
    generationMap.getSome(parentB.element.concat(parentA.element)) :
    parentA.element.toString();

  let newCreature = sampleCreaturesMap.getSome(child_element.concat(child_evolutionRank));

  return newCreature;
}

export function procreateCreature(parentInstanceIdA: string, parentInstanceIdB: string, newSkills: Array<string>, newCreatureSampleId: string): Creature {

  if(newSkills.length > 6){
    return new Creature('', '', '', '', '', '', [], '', '');
  }

  let parentA = getCreatureByInstanceId(parentInstanceIdA);
  let parentB = getCreatureByInstanceId(parentInstanceIdB);

  const newCreature = sampleCreaturesMap.getSome(newCreatureSampleId)
  let child_id = generateRandomId();

  let availableSkills = parentA.skills.concat(parentB.skills).concat(newCreature.skills).filter((skill, index, availableSkills) => availableSkills.indexOf(skill) == index);
  newSkills = newSkills.filter((skill, index, newSkills) => newSkills.indexOf(skill) == index);

  for(let i = 0; i < newSkills.length; i++){
    if(!availableSkills.includes(newSkills[i])){
      return new Creature('', '', '', '', '', '', [], '', '');
    }
  }

  return generateCreatureObject(
    child_id,
    newCreature,
    newSkills
  );
}

function generateCreatureObject(
  instanceId: string,
  newCreature: SampleCreature,
  newSkills: Array<string>
): Creature {
  let creature = new Creature(
    newCreature.sampleId,
    instanceId,
    newCreature.name,
    newCreature.atk,
    newCreature.def,
    newCreature.spd,
    newSkills,
    newCreature.element,
    newCreature.evolutionRank
  );

  setCreatureByInstanceId(instanceId, creature);
  setCreatureIdsByOwner(context.sender, instanceId);

  return creature;
}

export function giveCreaturesToOwner(creatureSampleId1: string, creatureSampleId2: string): Array<Creature> {
  let parentCreature1: SampleCreature = sampleCreaturesMap.getSome(creatureSampleId1);
  let parentCreature2: SampleCreature = sampleCreaturesMap.getSome(creatureSampleId2);

  let id1 = generateRandomId();
  let id2 = generateRandomId();

  let newCreature1 = generateCreatureObject(id1, parentCreature1, parentCreature1.skills);
  let newCreature2 = generateCreatureObject(id2, parentCreature2, parentCreature2.skills);

  return [newCreature1, newCreature2];
}

export function getSampleCreature(creatureSampleId: string): SampleCreature {
  return sampleCreaturesMap.getSome(creatureSampleId);
}

export function getGeneration(combo: string): string {
  return generationMap.getSome(combo);
}

export function getOffspring(combo: string): string {
  return offspringMap.getSome(combo);
}

function getCreatureIdsByOwner(owner: string): Array<string> {
  let creatureIdList = creaturesByOwner.get(owner);
  if (!creatureIdList) {
    return new Array<string>();
  }
  return creatureIdList.arrayOfIds;
}

export function setCreatureIdsByOwner(owner: string, id: string): void {
  let creatureIdArray = getCreatureIdsByOwner(owner);
  creatureIdArray.push(id);
  let newList = new CreatureIdList(creatureIdArray);
  creaturesByOwner.set(owner, newList);
}

function deleteCreatureIdsByOwner(owner: string, id: string): void {
  const creatureIdList = getCreatureIdsByOwner(owner);
  for (let i = 0; i < creatureIdList.length; i++) {
    if (id == creatureIdList[i]) {
      creatureIdList.splice(i, 1);
    }
  }
  let newList = new CreatureIdList(creatureIdList);
  creaturesByOwner.set(owner, newList);
}

export function getCreatureByInstanceId(instanceId: string): Creature {
  return creaturesByInstanceId.getSome(instanceId);
}

export function setCreatureByInstanceId(instanceId: string, creature: Creature): void {
  creaturesByInstanceId.set(instanceId, creature);
}

export function deleteCreatureByInstanceId(instanceId: string): void {
  let creature = getCreatureByInstanceId(instanceId);
  deleteCreatureIdsByOwner(creature.owner, instanceId);
  creaturesByInstanceId.delete(instanceId);
}

function generateRandomId(): string {
  const ID_DIGITS: u32 = 16;
  return base64.encode(math.randomBuffer(ID_DIGITS));
}

export function randomNum(): u32 {
  let buf = math.randomBuffer(4);
  return (
    (((0xff & buf[0]) << 24) |
      ((0xff & buf[1]) << 16) |
      ((0xff & buf[2]) << 8) |
      ((0xff & buf[3]) << 0)) %
    100
  );
}

// export function getSkillsVector(): Array<string> {
//   const length = skillsVector.length;
//   const result = new Array<string>(length);
//   for (let i = 0; i < length; i++) {
//     result[i] = skillsVector[i];
//   }
//   return result;
// }
'''
'''--- assembly/models.ts ---
import { context, logging, PersistentMap, PersistentVector } from "near-sdk-as";

@nearBindgen
export class CreatureIdList {
  constructor(public arrayOfIds: Array<string>) { }
}

@nearBindgen
export class Creature {
  owner: string;
  constructor(
    public sampleId: string,
    public instanceId: string,
    public name: string,
    public atk: string,
    public def: string,
    public spd: string,
    public skills: Array<string>,
    public element: string,
    public evolutionRank: string,
  ) {
    this.owner = context.sender;
  }
}

@nearBindgen
export class SampleCreature {
  constructor(
    public sampleId: string,
    public name: string,
    public atk: string,
    public def: string,
    public spd: string,
    public skills: Array<string>,
    public element: string,
    public evolutionRank: string
  ) {

  }
}

export const creaturesByInstanceId = new PersistentMap<string, Creature>('ci');

export const creaturesByOwner = new PersistentMap<string, CreatureIdList>("co");

export const sampleCreaturesMap = new PersistentMap<string, SampleCreature>("cm");

export const generationMap = new PersistentMap<string, string>("gm");

export const offspringMap = new PersistentMap<string, string>("om");

// export const skillsVector = new PersistentVector<string>("sm");

// export const creaturesVector = new Array<SampleCreature>();

export function initContract(): void {
  initCreatures();
  initGenerationMap();
  initOffspringMap();
  // initSkillsVector();
}

function initCreatures(): void {
  const creaturesData = [
    "f0:sal:10:10:10:fs,su:f:0",
    "w0:tur:10:20:10:ws,du:w:0",
    "g0:boa:20:20:10:gs,au:g:0",
    "l0:eag:20:10:20:ha,ls:l:0",
    "d0:bat:20:10:20:ds,dd:d:0",
    "n0:can:20:20:10:ns,ng:n:0",
    "f1:ser:30:30:30:fg,ad:f:1",
    "w1:sha:30:30:30:ha,gg:w:1",
    "g1:fai:20:20:20:ha,gg:g:1",
    "l1:osp:30:20:30:ls,su:l:1",
    "d1:imp:20:30:30:dg,sd:d:1",
    "n1:swo:30:30:20:au,nb:n:1",
    "f2:chi:30:30:30:fb,dd:f:2",
    "w2:lev:40:40:40:wg,au:w:2",
    "g2:dry:30:40:30:du,gb:g:2",
    "l2:spi:30:30:40:lb,lg:l:2",
    "d2:vam:30:40:40:db,ad:d:2",
    "n2:kni:40:30:30:nB,du:n:2",
    "f3:pel:40:40:50:fB,sd:f:3",
    "w3:sob:50:40:50:wB,gg:w:3",
    "g3:gai:40:50:40:gB,ng:g:3",
    "l3:tho:50:30:50:lB,dg:l:3",
    "d3:had:40:50:40:dB,lg:d:3",
    "n3:her:50:50:30:fg,dg:n:3"
  ]

  for (let i = 0; i < creaturesData.length; i++) {
    let creatureData = creaturesData[i].split(":");
    let creature = new SampleCreature(
      creatureData[0],
      creatureData[1],
      creatureData[2],
      creatureData[3],
      creatureData[4],
      creatureData[5].split(','),
      creatureData[6],
      creatureData[7]
    );
    sampleCreaturesMap.set(creatureData[6].concat(creatureData[7]), creature);
    // creaturesVector.push(creature);
  }
}

function initGenerationMap(): void {
  const creaturesData = [
    "dw:f",
    "dl:n",
    "dn:n",
    "dg:w",
    "df:g",
    "fw:d",
    "fg:l",
    "fl:w",
    "fn:n",
    "gw:n",
    "gl:f",
    "gn:n",
    "lw:g",
    "ln:n",
    "nw:n"
  ]

  for (let i = 0; i < creaturesData.length; i++) {
    const keyPair = creaturesData[i].split(":")
    generationMap.set(keyPair[0], keyPair[1]);
  }
}

// function initSkillsVector(): void {
//   const skillsData = [
//     "ha",
//     "fg",
//     "wg",
//     "gg",
//     "lg",
//     "dg",
//     "ng",
//     "fs",
//     "fb",
//     "fB",
//     "ws",
//     "wb",
//     "wB",
//     "gs",
//     "gb",
//     "gB",
//     "ls",
//     "lb",
//     "lB",
//     "ds",
//     "db",
//     "dB",
//     "ns",
//     "nb",
//     "nB",
//     "au",
//     "du",
//     "su",
//     "ad",
//     "dd",
//     "sd"
//   ];

//   for (let i = 0; i < skillsData.length; i++) {
//     skillsVector.push(skillsData[i]);
//   }
// }

function initOffspringMap(): void {
  const offspringData = [
    "00:1",
    "01:1",
    "02:1",
    "03:1",
    "11:2",
    "12:2",
    "13:2",
    "22:3",
    "23:3",
    "33:0"
  ]

  for (let i = 0; i < offspringData.length; i++) {
    const keyPair = offspringData[i].split(":")
    offspringMap.set(keyPair[0], keyPair[1]);
  }
}
'''
'''--- assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- compile.js ---
// This file does two things:
//
// 1. Compile the AssemblyScript contract using the scripts in package.json
//    (see buildCmd below). This will create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')
const path = require('path')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// AssemblyScript project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// Use the correct build command based on the `--debug` flag
const buildCmd = debug
  ? 'npm run build:debug'
  : 'npm run build'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require(`${__dirname}/package.json`).name
  const outFile = `./build/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  const linkPath = path.relative(linkDir, outFile)
  sh.ln('-s', linkPath, link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- package.json ---
{
  "name": "near-mons",
  "version": "0.0.1",
  "description": "Creatures",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn build:release && yarn test:unit",
    "clean": "rm -rf ./build && rm -rf ./neardev && rm -rf ./target",
    "test:debug": "node --inspect-brk ./node_modules/.bin/asp"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {},
  "dependencies": {
    "near-sdk-as": "^3.0.0"
  }
}

'''
'''--- scripts/1.init.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER

echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release

echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./out/main.wasm

echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo near call CONTRACT init '{}' --account_id OWNER
echo

exit 0

'''
'''--- scripts/2.run.sh ---
#!/usr/bin/env bash
set -e

echo
echo \$CONTRACT is $CONTRACT
echo \$OWNER is $OWNER
echo

near call $CONTRACT init '{}' --account_id $OWNER

near call $CONTRACT giveCreaturesToOwner '{"creatureSampleId1": "g0", "creatureSampleId2": "f0"}' --account_id $OWNER

echo near view $CONTRACT getCreaturesByOwner '{"owner":"'$OWNER'"}'

echo
echo "Hello! You have been given two creatures!"
echo
echo 'check 2.run.sh for command: near call $CONTRACT previewFutureChildCreature '{"creatureInstanceIdA": "ID", "creatureInstanceIdB": "ID"}' --account_id $OWNER'
echo
echo 'check 2.run.sh for command: near view $CONTRACT getCreatureByInstanceId '{"instanceId": "ID"}''
echo
echo 'check 2.run.sh for command: near call $CONTRACT procreateCreature '{"parentInstanceIdA": "ID", "parentInstanceIdB": "ID", "newSkills": ["du", "dd", "fB"], "newCreatureSampleId": "ID"}' --account_id $OWNER'

'''
'''--- scripts/README.md ---
# Scripts

## Setting up your terminal

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=mons.testnet
  ```

- Commands
  ```sh
  1.init.sh               # cleanup, compile and deploy contract
  2.run.sh                # call methods on the deployed contract
  ```
---

## Common Contract calls

*There are several essential functions that can be called.*

  Retrieves a list of all creatures that OWNER owns.

    near view $CONTRACT getCreaturesByOwner '{"owner":"'$OWNER'"}'

  Retrieves the creature that would result from the fusion of two creatures. Replace the placeholder instances of "ID" with respective parent creature instance id.

    near call $CONTRACT previewFutureChildCreature '{"creatureInstanceIdA": "ID",   "creatureInstanceIdB": "ID"}' --account_id $OWNER

  Retrieves creature by instance id. Replace the placeholder instances of "ID" with respective parent creature instance id.

    near view $CONTRACT getCreatureByInstanceId '{"instanceId": "ID"}'

  Fuse for the new creature using two parent creatures. Replace the placeholder instances of "ID" with respective parent creature instance id.

    near call $CONTRACT procreateCreature '{"parentInstanceIdA": "ID", "parentInstanceIdB": "ID", "newSkills": ["du", "dd", "fB"], "newCreatureSampleId": "ID"}' --account_id $OWNER
'''