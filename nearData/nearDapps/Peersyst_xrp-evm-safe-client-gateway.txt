*GitHub Repository "Peersyst/xrp-evm-safe-client-gateway"*

'''--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: bug
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
- Call url `...`
- Provide `json` you are submitting to the service (if it applies)
- Links to issues in other repos (if possible)

**Expected behavior**
A clear and concise description of what you expected to happen.

**Environment (please complete the following information):**
 - Staging or production?
 - Which chain?
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

'''
'''--- .github/ISSUE_TEMPLATE/feature_request.md ---
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Provide references to the feature you are implementing that requires this change**
Provide at least one of the following: 
- Links to epics in your repository
- Images taken from mocks
- Gitbook or any form of written documentation links, etc. Any of these alternatives will help us contextualise your request.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

'''
'''--- .github/action-rs/grcov.yml ---
branch: true
ignore-not-existing: true
llvm: true
filter: covered
output-type: lcov
output-path: ./lcov.info
coveralls-token: ${{ secrets.COVERALLS_TOKEN }}
prefix-dir: .
ignore:
  - "/*"
  - "/**/tests/**"
  - "target/debug/build/**"

excl-line: "#\\[cfg\\(test\\)\\]|#\\[derive|#\\[serde"
excl-br-line: "#\\[derive\\("
excl-start: "mod tests \\{"
excl-br-start: "mod tests \\{"

'''
'''--- .github/dependabot.yml ---
version: 2

updates:
  - package-ecosystem: cargo
    directory: "/"
    schedule:
      interval: weekly
      day: monday

'''
'''--- .github/landing_page/index.html ---
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="icon" href="/favicon.ico">
    <title>Safe Client Gateway</title>
    <style>
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}code{font-family:source-code-pro,Menlo,Monaco,Consolas,"Courier New",monospace}.App{text-align:center}.App-logo{width:300px;position:relative;}img{display:inline;margin:0 auto;height:100%;width:auto}.App-header{background-color:#282c34;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:calc(10px + 2vmin);color:#fff}.App-link{color:#fff;text-decoration:none}

    </style>
</head>
<body>
<div id="root">
    <div class="App">
        <header class="App-header"><img src="./gnosis_safe_logo.png" class="App-logo" alt="logo">
            <a class="App-link" href="https://safe.global/safe-client-gateway/docs/" rel="noopener noreferrer">
                <p>Safe Client Gateway</p>
            </a>
        </header>
    </div>
</div>
</body>
</html>

'''
'''--- .github/pull_request_template.md ---
Make sure these boxes are checked! ðŸ“¦âœ…

- [ ] You have a nightly compatible version of `rustfmt` installed
```bash
rustup component add rustfmt --toolchain nightly
```
- [ ] You ran `cargo +nightly fmt` on the code base before submitting

'''
'''--- .github/workflows/cla.yml ---
name: "CLA Assistant"
on:
  issue_comment:
    types: [ created ]
  pull_request_target:
    types: [ opened,closed,synchronize ]

jobs:
  CLAssistant:
    runs-on: ubuntu-latest
    steps:
      - name: "CLA Assistant"
        if: (github.event.comment.body == 'recheck' || github.event.comment.body == 'I have read the CLA Document and I hereby sign the CLA') || github.event_name == 'pull_request_target'
        # Beta Release
        uses: cla-assistant/github-action@v2.1.3-beta
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # the below token should have repo scope and must be manually added by you in the repository's secret
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        with:
          path-to-signatures: 'signatures/version1/cla.json'
          path-to-document: 'https://safe.global/cla/'
          # branch should not be protected
          branch: 'cla-signatures'
          allowlist: hectorgomezv,moisses89,luarx,fmrsabino,rmeissner,Uxio0,*bot # may need to update this expression if we add new bots

          #below are the optional inputs - If the optional inputs are not given, then default values will be taken
          #remote-organization-name: enter the remote organization name where the signatures should be stored (Default is storing the signatures in the same repository)
          #remote-repository-name:  enter the  remote repository name where the signatures should be stored (Default is storing the signatures in the same repository)
          #create-file-commit-message: 'For example: Creating file for storing CLA Signatures'
          #signed-commit-message: 'For example: $contributorName has signed the CLA in #$pullRequestNo'
          #custom-notsigned-prcomment: 'pull request comment with Introductory message to ask new contributors to sign'
          #custom-pr-sign-comment: 'The signature to be committed in order to sign the CLA'
          #custom-allsigned-prcomment: 'pull request comment when all contributors has signed, defaults to **CLA Assistant Lite bot** All Contributors have signed the CLA.'
          #lock-pullrequest-aftermerge: false - if you don't want this bot to automatically lock the pull request after merging (default - true)
          #use-dco-flag: true - If you are using DCO instead of CLA

'''
'''--- .github/workflows/rust.yml ---
name: safe-client-gateway

on: [ push, pull_request ]

env:
  CARGO_TERM_COLOR: always

jobs:

  rustfmt:
    runs-on: ubuntu-20.04
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2

      - name: Install toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: nightly-2022-02-18
          override: true
          components: rustfmt

      - name: Run rustfmt
        uses: actions-rs/cargo@v1
        with:
          command: fmt
          args: --all --check

  tests:
    runs-on: ubuntu-20.04

    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    env:
      RUSTC_BOOTSTRAP: 1 # grcov requires a nightly build. See https://github.com/mozilla/grcov#usage
      REDIS_URI: redis://localhost:6379
      REDIS_URI_MAINNET: redis://localhost:6379
      WEBHOOK_TOKEN: test_webhook_token
      CONFIG_SERVICE_URI: https://config.service.url
      VPC_TRANSACTION_SERVICE_URI: 'false'
      SCHEME: http
      TRANSACTION_SERVICE_AUTH_TOKEN: some_other_random_token

    steps:
      - name: Checkout branch
        uses: actions/checkout@v2

      # This can be removed once https://github.com/actions-rs/toolchain/pull/209 is merged and released
      - name: Set variables
        run: |
          echo "TOOLCHAIN=$(rustup show active-toolchain | cut -d " " -f1)" >> $GITHUB_ENV

      - name: Install toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: ${{ env.TOOLCHAIN }}
          override: true

      - name: Cargo cache
        uses: Swatinem/rust-cache@v1

      - name: Run tests
        uses: actions-rs/cargo@v1
        with:
          command: test
          args: --verbose --all --locked -- --test-threads 1
        env:
          CARGO_INCREMENTAL: '0'
          RUSTFLAGS: '-Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Awarnings'

      - name: Cache grcov
        id: grcov-cache
        uses: actions/cache@v2.1.5
        with:
          path: /home/runner/.cargo/bin/
          key: ${{ runner.os }}-grcov-v080

      - name: Fetch grcov
        if: steps.grcov-cache.outputs.cache-hit != 'true'
        run: curl --location https://github.com/mozilla/grcov/releases/download/v0.8.0/grcov-linux-x86_64.tar.bz2 | tar jxf -

      - name: Run grcov
        id: coverage
        uses: actions-rs/grcov@v0.1
        with:
          config: ./.github/action-rs/grcov.yml

      - name: Coveralls upload
        uses: coverallsapp/github-action@master
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path-to-lcov: ${{ steps.coverage.outputs.report }}

  docs:
    runs-on: ubuntu-20.04
    needs: [ rustfmt, tests ]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
        with:
          fetch-depth: 0 # checks out all branches and tags, necessary for versioning /about endpoint

      - name: Set variables
        run: |
          echo "TOOLCHAIN=$(rustup show active-toolchain | cut -d " " -f1)" >> $GITHUB_ENV

      - name: Install toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: ${{ env.TOOLCHAIN }}
          override: true
          components: rustfmt

      - name: Cargo cache
        uses: Swatinem/rust-cache@v1

      - name: Generate docs
        uses: actions-rs/cargo@v1
        with:
          command: doc
          args: --no-deps --workspace --locked

      - name: Move folder
        run: |
          rm -rf target/doc/docs
          mv target/doc/safe_client_gateway target/doc/docs
          cp .github/landing_page/* target/doc

      - name: Fix internal links
        run: find ./target/doc/docs/ -type f -exec sed -i "s/safe_client_gateway/docs/g" {} \;

      - name: Update docs
        uses: peaceiris/actions-gh-pages@v3.7.3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./target/doc

  deploy:
    runs-on: ubuntu-20.04
    env:
      DOCKERHUB_ORG: safeglobal
      DOCKERHUB_PROJECT: safe-client-gateway
    needs: [ rustfmt, tests ]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
        with:
          fetch-depth: 0 # checks out all branches and tags, necessary for versioning /about endpoint

      - name: Dockerhub login
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Deploy main
        if: github.ref == 'refs/heads/main'
        run: bash scripts/deploy_docker.sh staging

      - name: Deploy tag
        if: startsWith(github.ref, 'refs/tags/')
        run: bash scripts/deploy_docker.sh ${GITHUB_REF##*/}

      - name: Deploy develop # unused
        if: github.ref == 'refs/heads/develop'
        run: bash scripts/deploy_docker.sh develop

  autodeploy:
    runs-on: ubuntu-20.04
    needs: [deploy]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v2
    - name: Deploy staging
      run: bash scripts/autodeploy.sh
      env:
        AUTODEPLOY_URL: ${{ secrets.AUTODEPLOY_URL }}
        AUTODEPLOY_TOKEN: ${{ secrets.AUTODEPLOY_TOKEN }}
        TARGET_ENV: "staging"

'''
'''--- Cargo.toml ---
[package]
name = "safe-client-gateway"
version = "3.43.0"
authors = ["jpalvarezl <jose.alvarez@gnosis.io>", "rmeissner <richard@safe.global>", "fmrsabino <frederico.sabino@safe.global>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
bb8-redis = "0.12.0"
bigdecimal = { version = "0.3.0", features = ["serde"] }
chrono = { version = "0.4.23", features = ["serde"] }
derivative = "2.2.0"
dotenv = "0.15.0"
env_logger = "0.10.0"
ethcontract-common = "0.23.0"
ethabi = "18.0.0"
itertools = "0.10.5"
lazy_static = "1.4.0"
log = "0.4.17"
mockall = "0.11.3"
rand = "0.8.5"
r2d2 = "0.8.10"
regex = "1.7.0"
reqwest = { version = "0.11.13", features = ["json"] }
rocket = { version = "0.5.0-rc.2", features = ["tls", "json"] }
rocket_codegen = { version = "0.5.0-rc.2" }
rocket_okapi = { version="0.8.0-rc.2", features = ["swagger"] }
semver = "1.0.14"
serde = { version = "1.0.150", features = ["derive"] }
serde_json = { version = "1.0.89", features = ["raw_value"] }
serde_repr = "0.1.9"
thiserror = "1.0.37"
tokio = "1.16.1"

'''
'''--- README.md ---
# Safe Client Gateway
[![Actions Status](https://github.com/safe-global/safe-client-gateway/workflows/safe-client-gateway/badge.svg?branch=main)](https://github.com/safe-global/safe-client-gateway/actions)
[![Coverage Status](https://coveralls.io/repos/github/safe-global/safe-client-gateway/badge.svg)](https://coveralls.io/github/safe-global/safe-client-gateway)

## Motivation

This project is a gateway between the Safe clients ([Android](https://github.com/safe-global/safe-android)/ [iOS](https://github.com/safe-global/safe-ios)/ [web](https://github.com/safe-global/safe-react)) and the Safe backend services ([transaction service](https://github.com/safe-global/safe-transaction-service) and Ethereum nodes). It is providing a more UI-oriented mapping and multi-sourced data structures for ease of integration and rendering.

## Documentation

- [Client Gateway Docs](https://safe.global/safe-client-gateway/)
- [Swagger](https://safe-client.safe.global/index.html)
- [Safe developer documentation](https://docs.gnosis-safe.io/)

## Quickstart

This project requires `rustup` and `redis`

```bash
git clone https://github.com/safe-global/safe-client-gateway.git
cd safe-client-gateway
cp .env.sample .env
redis-server
cargo run
./add_rustfmt_git_hook.sh  # It installs a git precommit hook that will autoformat the code on every commit
```

After doing any change code must be formatted using [Rustfmt](https://github.com/rust-lang/rustfmt)
- `cargo +nightly fmt --all`
Auto formatting can also [be configured in the most common code editors](https://github.com/rust-lang/rustfmt#running-rustfmt-from-your-editor)

## Configuration

Rocket specific configurations (including databases) can be configured via the `Rocket.toml` for local development (see https://rocket.rs/v0.4/guide/configuration/#rockettoml).

For configurations specific to this service the `.env` file can be used. See next section.

## Environment

Place a `.env` file in the root of the project containing URL pointing to the environment in which you want the gateway to run.

The contents of the file should be the following (see `.env.sample` for an example)

## Tests

In order to run the test suite of the project:

1. Have an instance of Redis running (as some of them test the integration with Redis).

```bash
redis-server
```

2. Make sure that the required environment variables are set (the following example assumes that Redis is runnning on the default port `6379`):

```bash
export REDIS_URI=redis://localhost:6379
export REDIS_URI_MAINNET=redis://localhost:6379
```

3. Run the tests

```bash
cargo test -- --test-threads 1
```

By default, `cargo test` will execute the tests in the test suite in parallel. Because some of the tests update some shared local state (eg.: environment variables) the tests should be executed on a single thread â€“ thus `--test-threads 1`.

'''
'''--- add_rustfmt_git_hook.sh ---
#!/bin/sh

# check that rustfmt installed, or else this hook doesn't make much sense
command -v rustfmt >/dev/null 2>&1 || { echo >&2 "Rustfmt is required but it's not installed. Aborting."; exit 1; }

# write a whole script to pre-commit hook
# NOTE: it will overwrite pre-commit file!
cat > .git/hooks/pre-commit <<'EOF'
#!/bin/bash -e
declare -a rust_files=()
files=$(git diff-index --name-only HEAD)
echo 'Formatting source files'
for file in $files; do
    if [ ! -f "${file}" ]; then
        continue
    fi
    if [[ "${file}" == *.rs ]]; then
        rust_files+=("${file}")
    fi
done
if [ ${#rust_files[@]} -ne 0 ]; then
    command -v rustfmt >/dev/null 2>&1 || { echo >&2 "Rustfmt is required but it's not installed. Aborting."; exit 1; }
    $(command -v rustfmt) --edition 2018 --unstable-features --skip-children ${rust_files[@]} &
fi
wait
if [ ${#rust_files[@]} -ne 0 ]; then
    git add ${rust_files[@]}
    echo "Formatting done, changed files: ${rust_files[@]}"
else
    echo "No changes, formatting skipped"
fi
EOF

chmod +x .git/hooks/pre-commit

echo "Hooks updated"

'''
'''--- docker-compose.yml ---
version: '3.5'

services:
  nginx:
    image: nginx:1.21-alpine
    env_file:
      - .env
    ports:
      - "${NGINX_HOST_PORT}:80"
    volumes:
      - ./nginx/templates:/etc/nginx/templates
    depends_on:
      - web

  web:
    build: .
    env_file:
      - .env
    depends_on:
      - redis

  redis:
    image: redis:6-alpine
    env_file:
      - .env
    ports:
      - "${REDIS_PORT}:${REDIS_PORT}"

'''
'''--- rust-toolchain.toml ---
[toolchain]
# match with version in DockerFile
channel = "1.65.0"

'''
'''--- rustfmt.toml ---
# Enable unstable features on the unstable channel.
unstable_features = true

# Reorder impl items. type and const are put first, then macros and methods.
reorder_impl_items = true

# Convert /* */ comments to // comments where possible
normalize_comments = true

# Merge imports from the same module into a single use statement. Conversely, imports from different modules are split into separate statements.
imports_granularity = "Module"

'''
'''--- scripts/autodeploy.sh ---
#!/bin/bash

set -ev

curl -s --output /dev/null --write-out "%{http_code}" \
    -H "Content-Type: application/json" \
    -X POST \
    -u "$AUTODEPLOY_TOKEN" \
    -d '{"push_data": {"tag": "'$TARGET_ENV'" }}' \
    $AUTODEPLOY_URL

'''
'''--- scripts/deploy_docker.sh ---
#!/bin/bash

set -euo pipefail

# Workflow run number
export BUILD_NUMBER=$GITHUB_RUN_NUMBER
# strip the first char as that should always be "v" (as tags should be in the format "vX.X.X")
description="$(git describe --tags --always)"
export VERSION=${description:1}

echo "Trigger docker build and upload for version $VERSION ($BUILD_NUMBER)"

if [ "$1" = "develop" -o "$1" = "main" ]; then
    cache_tag="$1"
else
    cache_tag="staging"
fi

cached_builder_image_id="$DOCKERHUB_ORG/$DOCKERHUB_PROJECT:$cache_tag-builder"
cached_runtime_image_id="$DOCKERHUB_ORG/$DOCKERHUB_PROJECT:$cache_tag"
runtime_image_id="$DOCKERHUB_ORG/$DOCKERHUB_PROJECT:$1"

# Load cached builder image
docker pull $cached_builder_image_id || true
# Rebuild builder image if required
docker build \
    --target builder \
    --cache-from $cached_builder_image_id \
    -t $cached_builder_image_id \
    -f Dockerfile \
    --build-arg VERSION --build-arg BUILD_NUMBER \
    .

# Load cached runtime image
docker pull $cached_runtime_image_id || true
# Rebuild runtime image if required
docker build \
    --cache-from $cached_builder_image_id \
    --cache-from $cached_runtime_image_id \
    -t $runtime_image_id \
    -f Dockerfile \
    --build-arg VERSION --build-arg BUILD_NUMBER \
    .

# Push runtime images to remote repository
docker push $runtime_image_id

# Push builder image to remote repository for next build
docker push $cached_builder_image_id

# If release, set latest docker tag
case $1 in v*)
    latest_image_id="$DOCKERHUB_ORG/$DOCKERHUB_PROJECT:latest"
    docker tag $runtime_image_id $latest_image_id
    docker push $latest_image_id
esac

'''
'''--- scripts/generate_test_tx.sh ---
#!/bin/bash

curl --location --request POST 'https://safe-transaction.rinkeby.gnosis.io/api/v1/safes/0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f/multisig-transactions/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "to": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9",
    "value": "100000",
    "operation": "0",
    "safeTxGas": "0",
    "baseGas": "0",
    "gasPrice": "0",
    "nonce": "3",
    "contractTransactionHash": "0x8ec2103ec6d9d298f38e1d5b6e0e3f475a875a103219742b8376ca0fda5b5eb9",
    "sender": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
}'

curl --location --request POST 'https://safe-transaction.rinkeby.gnosis.io/api/v1/safes/0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f/multisig-transactions/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "to": "0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f",
    "value": "0",
    "operation": "0",
    "safeTxGas": "0",
    "baseGas": "0",
    "gasPrice": "0",
    "nonce": "3",
    "contractTransactionHash": "0xdfa23b5831bc5530bc7646d372dddd9afd1ef1883d799752a515f27cd4058bf5",
    "sender": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
}'

curl --location --request POST 'https://safe-transaction.rinkeby.gnosis.io/api/v1/safes/0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f/multisig-transactions/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "to": "0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f",
    "value": "12378797979797979792616486748431541",
    "operation": "0",
    "safeTxGas": "0",
    "baseGas": "0",
    "gasPrice": "0",
    "nonce": "3",
    "contractTransactionHash": "0x1addcdee38ce15c04ccfead718c23aadcc17b62774b4e6875d9d02231129e67f",
    "sender": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
}'

curl --location --request POST 'https://safe-transaction.rinkeby.gnosis.io/api/v1/safes/0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f/multisig-transactions/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "to": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9",
    "value": "12378797979797979792616486748431541",
    "operation": "0",
    "safeTxGas": "0",
    "baseGas": "0",
    "gasPrice": "0",
    "nonce": "4",
    "contractTransactionHash": "0xd720f976fe7dd6692217dedbeec1ca2936d3e677ddf77e3da57b8b8b914dc09d",
    "sender": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
}'

curl --location --request POST 'https://safe-transaction.rinkeby.gnosis.io/api/v1/safes/0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f/multisig-transactions/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "to": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9",
    "value": "0",
    "operation": "0",
    "safeTxGas": "0",
    "baseGas": "0",
    "gasPrice": "0",
    "nonce": "5",
    "contractTransactionHash": "0xfd9a8a8b365004ace135fdd75f5870e7c752921d3881235ddaab9a62a4a6f2bb",
    "sender": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
}'

curl --location --request POST 'https://safe-transaction.rinkeby.gnosis.io/api/v1/safes/0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f/multisig-transactions/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "to": "0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f",
    "value": "0",
    "data": "0xfd9a8a8b365004ace135fdd75f5870e7c752921d3881235ddaab9a62a4a6f2bb",
    "operation": "0",
    "safeTxGas": "0",
    "baseGas": "0",
    "gasPrice": "0",
    "nonce": "5",
    "contractTransactionHash": "0x4398414227cebb41d76d8aa471f6cf77f939c7d3dde789b40c8db669447f1457",
    "sender": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
}'
'''
'''--- src/cache/cache_op_executors.rs ---
use crate::cache::cache_operations::{CacheResponse, InvalidationPattern, RequestCached};
use crate::cache::inner_cache::CachedWithCode;
use crate::cache::{Cache, CACHE_REQS_PREFIX, CACHE_RESP_PREFIX};
use crate::utils::errors::{ApiError, ApiResult, ErrorDetails};
use crate::utils::http_client::Request;
use rocket::response::content;
use serde::Serialize;
use std::sync::Arc;
use std::time::Duration;

pub(super) async fn invalidate(cache: Arc<dyn Cache>, pattern: &InvalidationPattern) {
    cache
        .invalidate_pattern(pattern.to_pattern_string().as_str())
        .await;
}

pub(super) async fn cache_response<S>(
    cache_response: &CacheResponse<'_, S>,
) -> ApiResult<content::RawJson<String>>
where
    S: Serialize,
{
    let cache = cache_response.cache.clone();
    let cache_key = format!("{}_{}", CACHE_RESP_PREFIX, cache_response.key);
    let cached = cache.fetch(&cache_key).await;
    match cached {
        Some(value) => Ok(content::RawJson(value)),
        None => {
            let resp_string = serde_json::to_string(&cache_response.generate().await?)?;
            cache
                .create(&cache_key, &resp_string, cache_response.duration)
                .await;
            Ok(content::RawJson(resp_string))
        }
    }
}

pub(super) async fn request_cached(operation: &RequestCached) -> ApiResult<String> {
    let cache = operation.cache.clone();
    let client = operation.client.clone();
    let cache_key = format!("{}_{}", CACHE_REQS_PREFIX, &operation.url);
    match cache.fetch(&cache_key).await {
        Some(cached) => CachedWithCode::split(&cached).to_result(),
        None => {
            let http_request = {
                let mut request = Request::new(String::from(&operation.url));
                request.timeout(Duration::from_millis(operation.request_timeout));
                for (header, value) in &operation.headers {
                    request.add_header((header, value));
                }
                request
            };
            let response = client.get(http_request).await;

            match response {
                Err(error) => {
                    let default_message: String = String::from("Unknown error");
                    let response_body: &String =
                        error.details.message.as_ref().unwrap_or(&default_message);
                    // TODO extract http error range check (client error vs server error)
                    let is_client_error = error.status >= 400 && error.status < 500;

                    // If cache_all_errors is enabled we cache both client and server errors
                    // else we just cache client errors
                    if is_client_error || operation.cache_all_errors {
                        cache
                            .create(
                                &cache_key,
                                &CachedWithCode::join(error.status, &response_body),
                                operation.error_cache_duration,
                            )
                            .await;
                    }

                    if let Some(error_details) =
                        serde_json::from_str::<ErrorDetails>(response_body).ok()
                    {
                        Err(ApiError::new(error.status, error_details))
                    } else {
                        Err(ApiError::new_from_message_with_code(
                            error.status,
                            String::from(response_body),
                        ))
                    }
                }
                Ok(response) => {
                    let status_code = response.status_code;
                    let response_body = response.body;

                    cache
                        .create(
                            &cache_key,
                            &CachedWithCode::join(status_code, &response_body),
                            operation.cache_duration,
                        )
                        .await;
                    Ok(response_body.to_string())
                }
            }
        }
    }
}

'''
'''--- src/cache/cache_operations.rs ---
use std::collections::HashMap;
use std::future::Future;
use std::sync::Arc;

use rocket::futures::future::BoxFuture;
use rocket::futures::FutureExt;
use rocket::response::content;
use serde::{Deserialize, Serialize};

use crate::cache::cache_op_executors::{cache_response, invalidate, request_cached};
use crate::cache::manager::ChainCache;
use crate::cache::{Cache, CACHE_REQS_PREFIX, CACHE_REQS_RESP_PREFIX, CACHE_RESP_PREFIX};
use crate::config::{
    base_config_service_uri, default_request_timeout, request_cache_duration,
    request_error_cache_duration,
};
use crate::providers::info::generate_token_key;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::HttpClient;

pub struct Invalidate {
    pub(super) cache: Arc<dyn Cache>,
    pattern: InvalidationPattern,
}

#[derive(Deserialize, Debug, Clone)]
pub enum InvalidationScope {
    Requests,
    Responses,
    Both,
}

#[derive(Deserialize, Debug, Clone)]
#[serde(tag = "invalidate", content = "pattern_details")]
pub enum InvalidationPattern {
    Any(InvalidationScope, String),
    Transactions(InvalidationScope, String),
    Balances(InvalidationScope, String),
    Collectibles(InvalidationScope, String),
    Transfers(InvalidationScope, String),
    Chains,
    Contracts,
    Tokens { chain_id: String },
}

impl InvalidationPattern {
    pub(super) fn to_pattern_string(&self) -> String {
        match &self {
            InvalidationPattern::Any(scope, value) => {
                format!("{}*{}*", scope.invalidation_scope_string(), &value)
            }
            InvalidationPattern::Balances(scope, value) => {
                format!("{}*/{}/balances*", scope.invalidation_scope_string(), value)
            }
            InvalidationPattern::Collectibles(scope, value) => {
                format!(
                    "{}*/{}/collectibles*",
                    scope.invalidation_scope_string(),
                    value
                )
            }
            InvalidationPattern::Transfers(scope, value) => {
                format!(
                    "{}*/{}/*transfer*",
                    scope.invalidation_scope_string(),
                    value
                )
            }
            InvalidationPattern::Transactions(scope, value) => {
                format!(
                    "{}*/{}/*transactions/*",
                    scope.invalidation_scope_string(),
                    value
                )
            }
            InvalidationPattern::Contracts => String::from("*contract*"),
            InvalidationPattern::Tokens { chain_id } => generate_token_key(chain_id),
            InvalidationPattern::Chains => {
                format!("*{}*", base_config_service_uri())
            }
        }
    }
}

impl InvalidationScope {
    pub(super) fn invalidation_scope_string(&self) -> &str {
        match &self {
            InvalidationScope::Requests => CACHE_REQS_PREFIX,
            InvalidationScope::Responses => CACHE_RESP_PREFIX,
            InvalidationScope::Both => CACHE_REQS_RESP_PREFIX,
        }
    }
}

impl Invalidate {
    pub fn new(pattern: InvalidationPattern, cache: Arc<dyn Cache>) -> Self {
        Invalidate { cache, pattern }
    }

    pub async fn execute(&self) {
        invalidate(self.cache.clone(), &self.pattern).await
    }
}

pub struct CacheResponse<'a, R>
where
    R: Serialize,
{
    pub(super) cache: Arc<dyn Cache>,
    pub key: String,
    pub duration: usize,
    // "dyn" allows setting the type of the BoxFuture to different times in runtime
    pub resp_generator: Option<Box<dyn Fn() -> BoxFuture<'a, ApiResult<R>> + Send + Sync + 'a>>,
}

impl<'a, R> CacheResponse<'a, R>
where
    R: Serialize,
{
    pub fn new(context: &RequestContext, chain_cache: ChainCache) -> Self {
        CacheResponse {
            key: context.request_id.to_string(),
            cache: context.cache(chain_cache),
            duration: request_cache_duration(),
            resp_generator: None,
        }
    }

    pub fn duration(&mut self, duration: usize) -> &mut Self {
        self.duration = duration;
        self
    }

    pub fn resp_generator<F, Fut>(&mut self, resp_generator: F) -> &mut Self
    where
        F: Fn() -> Fut + Send + Sync + 'a,
        Fut: Future<Output = ApiResult<R>> + Send + 'a,
    {
        self.resp_generator = Some(Box::new(move || resp_generator().boxed()));
        self
    }

    pub async fn generate(&self) -> ApiResult<R> {
        (self.resp_generator.as_ref().unwrap())().await
    }

    pub async fn execute(&self) -> ApiResult<content::RawJson<String>> {
        cache_response(self).await
    }
}

pub struct RequestCached {
    pub(super) client: Arc<dyn HttpClient>,
    pub(super) cache: Arc<dyn Cache>,
    pub url: String,
    pub request_timeout: u64,
    pub cache_duration: usize,
    pub error_cache_duration: usize,
    pub cache_all_errors: bool,
    pub headers: HashMap<String, String>,
}

impl RequestCached {
    pub fn new(url: String, client: &Arc<dyn HttpClient>, cache: &Arc<dyn Cache>) -> Self {
        RequestCached {
            client: client.clone(),
            cache: cache.clone(),
            url,
            request_timeout: default_request_timeout(),
            cache_duration: request_cache_duration(),
            error_cache_duration: request_error_cache_duration(),
            cache_all_errors: false,
            headers: HashMap::default(),
        }
    }

    pub fn new_from_context(
        url: String,
        context: &RequestContext,
        chain_cache: ChainCache,
    ) -> Self {
        RequestCached {
            client: context.http_client(),
            cache: context.cache(chain_cache),
            url,
            request_timeout: default_request_timeout(),
            cache_duration: request_cache_duration(),
            error_cache_duration: request_error_cache_duration(),
            cache_all_errors: false,
            headers: HashMap::new(),
        }
    }

    pub fn request_timeout(&mut self, request_timeout: u64) -> &mut Self {
        self.request_timeout = request_timeout;
        self
    }

    pub fn cache_duration(&mut self, cache_duration: usize) -> &mut Self {
        self.cache_duration = cache_duration;
        self
    }

    pub fn error_cache_duration(&mut self, error_cache_duration: usize) -> &mut Self {
        self.error_cache_duration = error_cache_duration;
        self
    }

    pub fn cache_all_errors(&mut self) -> &mut Self {
        self.cache_all_errors = true;
        self
    }

    pub fn add_header(&mut self, header: (&str, &str)) -> &mut Self {
        self.headers
            .insert(String::from(header.0), String::from(header.1));
        self
    }

    pub async fn execute(&self) -> ApiResult<String> {
        assert!(self.request_timeout > 0);
        request_cached(self).await
    }
}

'''
'''--- src/cache/inner_cache.rs ---
use crate::utils::errors::ApiError;

#[derive(Debug, PartialEq)]
pub(super) struct CachedWithCode {
    pub(super) code: u16,
    pub(super) data: String,
}

impl CachedWithCode {
    const SEPARATOR: &'static str = ";";

    pub(super) fn split(cached: &str) -> Self {
        let cached_with_code: Vec<&str> = cached.splitn(2, CachedWithCode::SEPARATOR).collect();
        CachedWithCode {
            code: cached_with_code
                .get(0)
                .expect("Must have a status code")
                .parse()
                .expect("Not a valid Http code"),
            data: cached_with_code.get(1).expect("Must have data").to_string(),
        }
    }

    pub(super) fn join(code: u16, data: &str) -> String {
        format!("{}{}{}", code, CachedWithCode::SEPARATOR, data)
    }

    pub(super) fn is_error(&self) -> bool {
        200 > self.code || self.code >= 400
    }

    pub(super) fn to_result(&self) -> Result<String, ApiError> {
        if self.is_error() {
            Err(ApiError::from_backend_error(self.code, &self.data))
        } else {
            Ok(String::from(&self.data))
        }
    }
}

'''
'''--- src/cache/manager.rs ---
use std::sync::Arc;

use crate::cache::redis::{new_service_cache, new_service_cache_mainnet};
use crate::cache::Cache;

pub enum ChainCache {
    Mainnet,
    Other,
}

impl From<&str> for ChainCache {
    fn from(id: &str) -> Self {
        match id {
            "1" => ChainCache::Mainnet,
            _ => ChainCache::Other,
        }
    }
}

#[rocket::async_trait]
pub trait RedisCacheManager: Send + Sync {
    fn cache_for_chain(&self, chain_cache: ChainCache) -> Arc<dyn Cache>;
}

pub struct DefaultRedisCacheManager {
    mainnet_cache: Arc<dyn Cache>,
    default_cache: Arc<dyn Cache>,
}

pub async fn create_cache_manager() -> DefaultRedisCacheManager {
    DefaultRedisCacheManager {
        mainnet_cache: Arc::new(new_service_cache_mainnet().await),
        default_cache: Arc::new(new_service_cache().await),
    }
}

#[rocket::async_trait]
impl RedisCacheManager for DefaultRedisCacheManager {
    fn cache_for_chain(&self, chain_cache: ChainCache) -> Arc<dyn Cache> {
        match chain_cache {
            ChainCache::Mainnet => self.mainnet_cache.clone(),
            ChainCache::Other => self.default_cache.clone(),
        }
    }
}

'''
'''--- src/cache/mod.rs ---
use mockall::automock;

mod cache_op_executors;
pub mod cache_operations;
mod inner_cache;
pub mod manager;
pub mod redis;

#[cfg(test)]
mod tests;

const CACHE_REQS_PREFIX: &'static str = "c_reqs";
const CACHE_RESP_PREFIX: &'static str = "c_resp";
const CACHE_REQS_RESP_PREFIX: &'static str = "c_re";

#[automock]
#[rocket::async_trait]
pub trait Cache: Send + Sync {
    async fn fetch(&self, id: &str) -> Option<String>;
    async fn create(&self, id: &str, dest: &str, timeout: usize);
    async fn insert_in_hash(&self, hash: &str, id: &str, dest: &str);
    async fn get_from_hash(&self, hash: &str, id: &str) -> Option<String>;
    async fn has_key(&self, id: &str) -> bool;
    async fn expire_entity(&self, id: &str, timeout: usize);
    async fn invalidate_pattern(&self, pattern: &str);
    async fn invalidate(&self, id: &str);
    async fn info(&self) -> Option<String>;
}

'''
'''--- src/cache/redis.rs ---
use bb8_redis::bb8::{self, Pool, PooledConnection};
use bb8_redis::redis::{cmd, AsyncCommands, AsyncIter, Cmd, Pipeline, ToRedisArgs};
use bb8_redis::RedisConnectionManager;

use crate::cache::Cache;
use crate::config::{redis_scan_count, redis_uri, redis_uri_mainnet};

type RedisPool = Pool<RedisConnectionManager>;
type RedisConnection<'a> = PooledConnection<'a, RedisConnectionManager>;

async fn create_pool(for_mainnet: bool) -> RedisPool {
    let target = if for_mainnet {
        redis_uri_mainnet()
    } else {
        redis_uri()
    };
    let manager = RedisConnectionManager::new(target)
        .expect("Establishing connection with redis instance failed");
    bb8::Pool::builder()
        .max_size(15) // default is 10
        .build(manager) // we can technically also set a connection await timeout if necessary
        .await
        .expect("Redis connection pool initialization failed")
}

pub struct ServiceCache(RedisPool);

pub async fn new_service_cache() -> impl Cache {
    ServiceCache(create_pool(false).await)
}

pub async fn new_service_cache_mainnet() -> impl Cache {
    ServiceCache(create_pool(true).await)
}

impl ServiceCache {
    async fn conn(&self) -> RedisConnection<'_> {
        self.0.get().await.unwrap()
    }
}

#[rocket::async_trait]
impl Cache for ServiceCache {
    async fn fetch(&self, id: &str) -> Option<String> {
        match self.conn().await.get(id).await {
            Ok(value) => Some(value),
            _ => None,
        }
    }

    async fn create(&self, id: &str, dest: &str, timeout: usize) {
        let _: () = self.conn().await.pset_ex(id, dest, timeout).await.unwrap();
    }

    async fn insert_in_hash(&self, hash: &str, id: &str, dest: &str) {
        let _: () = self.conn().await.hset(hash, id, dest).await.unwrap();
    }

    async fn get_from_hash(&self, hash: &str, id: &str) -> Option<String> {
        self.conn().await.hget(hash, id).await.ok()
    }

    async fn has_key(&self, id: &str) -> bool {
        let result: Option<usize> = self.conn().await.exists(id).await.ok();
        result.map(|it| it != 0).unwrap_or(false)
    }

    async fn expire_entity(&self, id: &str, timeout: usize) {
        let _: () = self.conn().await.pexpire(id, timeout).await.unwrap();
    }

    async fn invalidate_pattern(&self, pattern: &str) {
        let mut con = self.conn().await;
        let keys_cmd = scan_match_count_cmd(pattern, redis_scan_count());
        let mut keys = keys_cmd.iter_async(&mut *con).await.unwrap();
        pipeline_delete(&mut keys)
            .await
            .query_async::<_, ()>(&mut *con)
            .await
            .expect("Pipeline delete error");
    }

    async fn invalidate(&self, id: &str) {
        let _: () = self.conn().await.del(id).await.unwrap();
    }

    async fn info(&self) -> Option<String> {
        let mut conn = self.conn().await;
        cmd("INFO").query_async(&mut *conn).await.ok()
    }
}

async fn pipeline_delete(keys: &mut AsyncIter<'_, String>) -> Pipeline {
    let mut pipeline = Pipeline::new();
    while let Some(key) = keys.next_item().await {
        pipeline.del(key);
    }
    pipeline
}

fn scan_match_count_cmd<P: ToRedisArgs, C: ToRedisArgs>(pattern: P, count: C) -> Cmd {
    let mut cmd = cmd("SCAN");
    cmd.cursor_arg(0)
        .arg("MATCH")
        .arg(pattern)
        .arg("COUNT")
        .arg(count);
    cmd
}

'''
'''--- src/cache/tests/cache_inner.rs ---
use crate::cache::inner_cache::CachedWithCode;
use crate::utils::errors::{ApiError, ErrorDetails};

#[test]
fn cache_with_code_split_success() {
    let input = "400;123";

    let cached_with_code = CachedWithCode::split(input);
    let expected = CachedWithCode {
        code: 400,
        data: String::from("123"),
    };

    assert_eq!(cached_with_code, expected);
}

#[test]
#[should_panic]
fn cache_with_code_split_failure_parse() {
    CachedWithCode::split("400A;123");
}

#[test]
#[should_panic]
fn cache_with_code_split_failure_not_enough_parts() {
    CachedWithCode::split("400MissingSeparatorForSomeReason");
}

#[test]
fn cache_with_code_split_multiple_separators() {
    let expected = CachedWithCode {
        code: 404,
        data: String::from("foo;bar"),
    };
    let actual = CachedWithCode::split("404;foo;bar");

    assert_eq!(actual, expected);
}

#[test]
fn cache_with_code_split_data_is_only_separators() {
    let expected = CachedWithCode {
        code: 404,
        data: String::from(";;;;;"),
    };
    let actual = CachedWithCode::split("404;;;;;;");

    assert_eq!(actual, expected);
}

#[test]
fn cache_with_code_join() {
    let actual = CachedWithCode::join(400, "data");
    let expected = String::from("400;data");

    assert_eq!(actual, expected);
}

#[test]
fn cache_with_code_error_code() {
    let cached_with_code = CachedWithCode {
        code: 418,
        data: "teapot".to_string(),
    };

    assert!(cached_with_code.is_error())
}

#[test]
fn cache_with_code_success_code() {
    let cached_with_code = CachedWithCode {
        code: 200,
        data: "not a teapot".to_string(),
    };

    assert!(!cached_with_code.is_error())
}

#[test]
fn cache_with_code_unwrap_ok() {
    let cached_with_code = CachedWithCode {
        code: 200,
        data: "not a teapot".to_string(),
    };

    assert_eq!(cached_with_code.to_result().unwrap(), "not a teapot");
}

#[test]
fn cache_with_code_unwrap_err() {
    let cached_with_code = CachedWithCode {
        code: 418,
        data: "teapot".to_string(),
    };
    let expected = ApiError {
        status: 418,
        details: ErrorDetails {
            code: 42,
            message: Some(String::from("teapot")),
            arguments: None,
            debug: None,
        },
    };

    assert_eq!(cached_with_code.to_result().expect_err(""), expected);
}

'''
'''--- src/cache/tests/cache_op_executors.rs ---
use std::sync::Arc;

use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::utils::context::RequestContext;
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::{HttpClient, MockHttpClient, Response};
use crate::{create_cache_manager, RedisCacheManager};
use serde_json::json;

#[rocket::async_test]
async fn error_from_backend_deserialization() {
    let request_uri = "some.url";
    let error_json = json!({
        "code": 1,
        "message": "Checksum address validation failed",
        "arguments": [
            "0xD6f5Bef6bb4acD235CF85c0ce196316d10785d67"
        ]
    });

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client.expect_get().times(1).returning(move |_| {
        Err(ApiError::from_http_response(&Response {
            body: error_json.to_string(),
            status_code: 422,
        }))
    });
    let cache_manager = create_cache_manager().await;

    let context = RequestContext::setup_for_test(
        String::from(request_uri),
        "host".to_string(),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Err(ApiError::new(
        422,
        serde_json::from_value::<ErrorDetails>(json!({
            "code": 1,
            "message": "Checksum address validation failed",
            "arguments": [
                "0xD6f5Bef6bb4acD235CF85c0ce196316d10785d67"
            ]
        }))
        .unwrap(),
    ));

    let request =
        RequestCached::new_from_context(String::from(request_uri), &context, ChainCache::Other);
    let actual = request.execute().await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn error_from_backend_deserialization_unknown_json_struct() {
    // we've changed the json type of "code" to string,
    // for the sake of creating a synthetic API breaking change
    let request_uri = "some.url";
    let error_json = json!({
        "code": "1",
        "message": "Checksum address validation failed",
        "arguments": [
            "0xD6f5Bef6bb4acD235CF85c0ce196316d10785d67"
        ],
    });

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client.expect_get().times(1).returning(move |_| {
        Err(ApiError::from_http_response(&Response {
            body: error_json.to_string(),
            status_code: 422,
        }))
    });
    let cache_manager = create_cache_manager().await;

    let context = RequestContext::setup_for_test(
        String::from(request_uri),
        "host".to_string(),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Err(ApiError::new_from_message_with_code(
        422,
        json!({
            "code": "1",
            "message": "Checksum address validation failed",
            "arguments": [
                "0xD6f5Bef6bb4acD235CF85c0ce196316d10785d67"
            ],
        })
        .to_string(),
    ));
    let request =
        RequestCached::new_from_context(String::from(request_uri), &context, ChainCache::Other);
    let actual = request.execute().await;

    assert_eq!(expected, actual);
}

'''
'''--- src/cache/tests/cache_operations.rs ---
use crate::cache::cache_operations::{InvalidationPattern, InvalidationScope};
use crate::cache::{CACHE_REQS_PREFIX, CACHE_REQS_RESP_PREFIX, CACHE_RESP_PREFIX};
use crate::config::base_config_service_uri;
use crate::providers::info::TOKENS_KEY_BASE;

#[test]
fn invalidation_pattern_any_string() {
    let invalidation_pattern =
        InvalidationPattern::Any(InvalidationScope::Both, "some_address".to_string());
    let expected = format!("{}*some_address*", CACHE_REQS_RESP_PREFIX);

    let actual = invalidation_pattern.to_pattern_string();

    assert_eq!(expected, actual);
}

#[test]
fn invalidation_pattern_transactions_string() {
    let invalidation_pattern =
        InvalidationPattern::Transactions(InvalidationScope::Both, "some_address".to_string());
    let expected = format!("{}*/some_address/*transactions/*", CACHE_REQS_RESP_PREFIX);

    let actual = invalidation_pattern.to_pattern_string();

    assert_eq!(expected, actual);
}

#[test]
fn invalidation_pattern_transfers_string() {
    let invalidation_pattern =
        InvalidationPattern::Transfers(InvalidationScope::Requests, "some_address".to_string());
    let expected = format!("{}*/some_address/*transfer*", CACHE_REQS_PREFIX);

    let actual = invalidation_pattern.to_pattern_string();

    assert_eq!(expected, actual);
}

#[test]
fn invalidation_pattern_tokens_string() {
    let invalidation_pattern = InvalidationPattern::Tokens {
        chain_id: "4".to_string(),
    };
    let expected = format!("{}_{}", TOKENS_KEY_BASE.to_string(), "4");

    let actual = invalidation_pattern.to_pattern_string();

    assert_eq!(expected, actual);
}

#[test]
fn invalidation_pattern_contracts_string() {
    let invalidation_pattern = InvalidationPattern::Contracts;
    let expected = String::from("*contract*");

    let actual = invalidation_pattern.to_pattern_string();

    assert_eq!(expected, actual);
}

#[test]
fn invalidation_pattern_balances_string() {
    let invalidation_pattern =
        InvalidationPattern::Balances(InvalidationScope::Both, "some_address".to_string());
    let expected = format!("{}*/some_address/balances*", CACHE_REQS_RESP_PREFIX);

    let actual = invalidation_pattern.to_pattern_string();

    assert_eq!(expected, actual);
}

#[test]
fn invalidation_pattern_collectibles_string() {
    let invalidation_pattern =
        InvalidationPattern::Collectibles(InvalidationScope::Both, "some_address".to_string());
    let expected = format!("{}*/some_address/collectibles*", CACHE_REQS_RESP_PREFIX);

    let actual = invalidation_pattern.to_pattern_string();

    assert_eq!(expected, actual);
}

#[test]
fn invalidation_pattern_chains_string() {
    std::env::set_var("CONFIG_SERVICE_URI", "https://config-url-example.com");
    let invalidation_pattern = InvalidationPattern::Chains;
    let expected = format!("*{}*", base_config_service_uri());

    let actual = invalidation_pattern.to_pattern_string();

    assert_eq!(expected, actual);
}

#[test]
fn invalidation_scope_both_to_string() {
    assert_eq!(
        CACHE_REQS_RESP_PREFIX,
        InvalidationScope::Both.invalidation_scope_string()
    )
}

#[test]
fn invalidation_scope_requests_to_string() {
    assert_eq!(
        CACHE_REQS_PREFIX,
        InvalidationScope::Requests.invalidation_scope_string()
    )
}

#[test]
fn invalidation_scope_responses_to_string() {
    assert_eq!(
        CACHE_RESP_PREFIX,
        InvalidationScope::Responses.invalidation_scope_string()
    )
}

'''
'''--- src/cache/tests/mod.rs ---
mod cache_inner;
mod cache_op_executors;
mod cache_operations;

'''
'''--- src/common/converters/data_decoded.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::data_decoded::{
    DataDecoded, InternalTransaction, Operation, ParamValue, Parameter, ValueDecodedType,
};
use crate::config::feature_flag_nested_decoding;
use crate::providers::ext::InfoProviderExt;
use crate::providers::info::InfoProvider;
use crate::routes::transactions::models::SettingsInfo;
use crate::utils::{
    ADD_OWNER_WITH_THRESHOLD, CHANGE_MASTER_COPY, CHANGE_THRESHOLD, DISABLE_MODULE, ENABLE_MODULE,
    MULTI_SEND, MULTI_SEND_TRANSACTIONS_PARAM, REMOVE_OWNER, SET_FALLBACK_HANDLER, SET_GUARD,
    SWAP_OWNER,
};
use std::collections::HashMap;

impl DataDecoded {
    pub(crate) async fn to_settings_info(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> Option<SettingsInfo> {
        match self.method.as_str() {
            SET_FALLBACK_HANDLER => {
                let handler = self.get_parameter_single_value_at(0)?;
                Some(SettingsInfo::SetFallbackHandler {
                    handler: info_provider
                        .address_ex_from_contracts_or_default(&handler)
                        .await,
                })
            }
            ADD_OWNER_WITH_THRESHOLD => {
                let owner = self.get_parameter_single_value_at(0)?;
                Some(SettingsInfo::AddOwner {
                    owner: AddressEx::address_only(&owner),
                    threshold: self.get_parameter_single_value_at(1)?.parse().ok()?,
                })
            }
            REMOVE_OWNER => {
                let owner = self.get_parameter_single_value_at(1)?;
                Some(SettingsInfo::RemoveOwner {
                    owner: AddressEx::address_only(&owner),
                    threshold: self.get_parameter_single_value_at(2)?.parse().ok()?,
                })
            }
            SWAP_OWNER => {
                let old_owner = self.get_parameter_single_value_at(1)?;
                let new_owner = self.get_parameter_single_value_at(2)?;
                Some(SettingsInfo::SwapOwner {
                    old_owner: AddressEx::address_only(&old_owner),
                    new_owner: AddressEx::address_only(&new_owner),
                })
            }
            CHANGE_MASTER_COPY => {
                let implementation = self.get_parameter_single_value_at(0)?;
                Some(SettingsInfo::ChangeImplementation {
                    implementation: info_provider
                        .address_ex_from_contracts_or_default(&implementation)
                        .await,
                })
            }
            ENABLE_MODULE => {
                let module = self.get_parameter_single_value_at(0)?;
                Some(SettingsInfo::EnableModule {
                    module: info_provider
                        .address_ex_from_contracts_or_default(&module)
                        .await,
                })
            }
            DISABLE_MODULE => {
                let module = self.get_parameter_single_value_at(1)?;
                Some(SettingsInfo::DisableModule {
                    module: info_provider
                        .address_ex_from_contracts_or_default(&module)
                        .await,
                })
            }
            CHANGE_THRESHOLD => Some(SettingsInfo::ChangeThreshold {
                threshold: self.get_parameter_single_value_at(0)?.parse().ok()?,
            }),
            SET_GUARD => {
                let guard = self.get_parameter_single_value_at(0)?;
                let settings_info = if guard != "0x0000000000000000000000000000000000000000" {
                    let guard = info_provider
                        .address_ex_from_contracts_or_default(&guard)
                        .await;
                    SettingsInfo::SetGuard { guard }
                } else {
                    SettingsInfo::DeleteGuard
                };
                Some(settings_info)
            }
            _ => None,
        }
    }
}

impl DataDecoded {
    pub(crate) async fn build_address_info_index(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> Option<HashMap<String, AddressEx>> {
        if !feature_flag_nested_decoding() {
            return None;
        }

        let mut index: HashMap<String, AddressEx> = HashMap::new();
        if self.method == MULTI_SEND {
            if let Some(value_decoded_type) =
                &self.get_parameter_value_decoded(MULTI_SEND_TRANSACTIONS_PARAM)
            {
                match value_decoded_type {
                    ValueDecodedType::InternalTransaction(transactions) => {
                        for transaction in transactions.iter() {
                            insert_value_into_index(&transaction.to, &mut index, info_provider)
                                .await;
                            put_parameter_into_index(
                                &transaction
                                    .data_decoded
                                    .as_ref()
                                    .map(|it| it.parameters.to_owned())
                                    .flatten(),
                                &mut index,
                                info_provider,
                            )
                            .await
                        }
                    }
                }
            }
        } else {
            put_parameter_into_index(&self.parameters, &mut index, info_provider).await;
        }
        if index.is_empty() {
            None
        } else {
            Some(index)
        }
    }

    pub fn has_nested_delegated(&self) -> bool {
        if let Some(parameters) = &self.parameters {
            parameters
                .iter()
                .map(|parameter| {
                    if let Some(value) = &parameter.value_decoded {
                        match value {
                            ValueDecodedType::InternalTransaction(transactions) => transactions
                                .iter()
                                .filter(|transaction| transaction.operation == Operation::DELEGATE)
                                .collect::<Vec<&InternalTransaction>>()
                                .is_empty(),
                        }
                    } else {
                        true // the "if" branch checks that there are NO entries with DELEGATE, therefore default true
                    }
                })
                .filter(|&it| it) // filter "true" meaning, we remove those entries with "no" DELEGATE
                .collect::<Vec<bool>>()
                .is_empty()
        } else {
            false
        }
    }
}

async fn put_parameter_into_index(
    parameters: &Option<Vec<Parameter>>,
    index: &mut HashMap<String, AddressEx>,
    info_provider: &impl InfoProvider,
) {
    if let Some(parameters) = parameters {
        for parameter in parameters {
            match &parameter.value {
                ParamValue::SingleValue(value) => {
                    insert_value_into_index(value, index, info_provider).await
                }
                ParamValue::ArrayValue(values) => {
                    for value in values {
                        if let ParamValue::SingleValue(value) = value {
                            insert_value_into_index(value, index, info_provider).await
                        }
                    }
                }
            }
        }
    }
}

async fn insert_value_into_index(
    value: &String,
    index: &mut HashMap<String, AddressEx>,
    info_provider: &impl InfoProvider,
) {
    if value.len() == 42
        && value.starts_with("0x")
        && value != "0x0000000000000000000000000000000000000000"
        && !index.contains_key(value)
    {
        if let Some(address_ex) = info_provider.address_ex_from_any_source(&value).await.ok() {
            index.insert(value.to_owned(), address_ex);
        };
    }
}

'''
'''--- src/common/converters/mod.rs ---
pub mod data_decoded;
pub mod page_metadata;
pub mod transfers;

#[cfg(test)]
mod tests;

use crate::common::models::addresses::AddressEx;
use crate::providers::info::InfoProvider;
use crate::routes::transactions::models::TransferDirection;

pub(crate) fn get_transfer_direction(safe: &str, from: &str, to: &str) -> TransferDirection {
    if safe == from {
        TransferDirection::Outgoing
    } else if safe == to {
        TransferDirection::Incoming
    } else {
        TransferDirection::Unknown
    }
}

// This method is required to prevent polluting the cache with all the safe requests
// This is done to prevent that every user that queries a transfer transaction, doesn't
// leave a mark in our cache.
pub(crate) async fn get_address_ex_from_any_source(
    safe: &str,
    address: &str,
    info_provider: &impl InfoProvider,
) -> AddressEx {
    if safe != address {
        info_provider
            .address_ex_from_any_source(address)
            .await
            .unwrap_or(AddressEx::address_only(address))
    } else {
        AddressEx::address_only(address)
    }
}

'''
'''--- src/common/converters/page_metadata.rs ---
use crate::common::models::page::PageMetadata;
use std::ops::Deref;

impl PageMetadata {
    pub fn to_url_string(&self) -> String {
        return format!("limit={}&offset={}", self.limit, self.offset);
    }

    pub fn from_cursor(encoded_cursor: &str) -> Self {
        let mut output = Self::default();

        let chunked: Vec<Vec<&str>> = encoded_cursor
            .split("&")
            .map(|it| it.split("=").collect())
            .collect();

        chunked.into_iter().for_each(|it| {
            let first = it.first().unwrap_or(&"").deref();
            if first == "limit" {
                output.limit = it.get(1).unwrap_or(&"0").parse::<u64>().unwrap_or(20);
            } else if first == "offset" {
                output.offset = it.get(1).unwrap_or(&"0").parse::<u64>().unwrap_or(0);
            }
        });

        output
    }
}
impl Default for PageMetadata {
    fn default() -> Self {
        Self {
            offset: 0,
            limit: 20,
        }
    }
}

'''
'''--- src/common/converters/tests/balances.rs ---
use crate::common::models::backend::balances::Balance as BalanceDto;
use crate::common::models::backend::chains::NativeCurrency;
use crate::providers::info::{TokenInfo, TokenType};
use crate::routes::balances::models::Balance;
use crate::tests::json::{BALANCE_COMPOUND_ETHER, BALANCE_ETHER};

#[test]
fn native_token_balance() {
    std::env::set_var("FEATURE_FLAG_BALANCES_RATE_IMPLEMENTATION", "false");
    let balance_dto = serde_json::from_str::<BalanceDto>(BALANCE_ETHER).unwrap();

    let expected = Balance {
        token_info: TokenInfo {
            token_type: TokenType::NativeToken,
            address: "0x0000000000000000000000000000000000000000".to_string(),
            decimals: 18,
            symbol: "ETH".to_string(),
            name: "Ether".to_string(),
            logo_uri: Some("https://test.token.image.url".to_string()),
        },
        balance: "7457594371050000001".to_string(),
        fiat_balance: "7928.7487".to_string(),
        fiat_conversion: "1063.1777".to_string(),
    };

    let usd_to_fiat = std::f64::consts::PI;
    let native_currency = NativeCurrency {
        name: "Ether".to_string(),
        symbol: "ETH".to_string(),
        decimals: 18,
        logo_uri: "https://test.token.image.url".to_string(),
    };
    let actual = balance_dto.to_balance(usd_to_fiat, &native_currency);

    assert_eq!(actual, expected);
}

#[test]
fn erc20_token_balance_usd_balance() {
    std::env::set_var("FEATURE_FLAG_BALANCES_RATE_IMPLEMENTATION", "false");
    std::env::set_var("VPC_TRANSACTION_SERVICE_URI", "false");
    let balance_dto = serde_json::from_str::<BalanceDto>(BALANCE_COMPOUND_ETHER).unwrap();

    let expected = Balance {
        token_info: TokenInfo {
            token_type: TokenType::Erc20,
            address: "0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e".to_string(),
            decimals: 8,
            symbol: "cETH".to_string(),
            name: "Compound Ether ðŸ“ˆ".to_string(),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e.png".to_string()),
        },
        balance: "5002".to_string(),
        fiat_balance: "0.0014".to_string(),
        fiat_conversion: "28.5462".to_string(),
    };

    let usd_to_fiat = 1.0;
    let native_currency = NativeCurrency {
        name: "Compound Ether ðŸ“ˆ".to_string(),
        symbol: "cETH".to_string(),
        decimals: 8,
        logo_uri: "https://test.token.image.url".to_string(),
    };
    let actual = balance_dto.to_balance(usd_to_fiat, &native_currency);

    assert_eq!(actual, expected);
}

#[test]
fn erc20_token_balance_fiat_is_twice_usd() {
    std::env::set_var("FEATURE_FLAG_BALANCES_RATE_IMPLEMENTATION", "false");
    std::env::set_var("VPC_TRANSACTION_SERVICE_URI", "false");
    let balance_dto = serde_json::from_str::<BalanceDto>(BALANCE_COMPOUND_ETHER).unwrap();

    let expected = Balance {
        token_info: TokenInfo {
            token_type: TokenType::Erc20,
            address: "0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e".to_string(),
            decimals: 8,
            symbol: "cETH".to_string(),
            name: "Compound Ether ðŸ“ˆ".to_string(),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e.png".to_string()),
        },
        balance: "5002".to_string(),
        fiat_balance: "0.0028".to_string(),
        fiat_conversion: "57.0924".to_string(),
    };

    let usd_to_fiat = 2.0;
    let native_currency = NativeCurrency {
        name: "Compound Ether ðŸ“ˆ".to_string(),
        symbol: "cETH".to_string(),
        decimals: 8,
        logo_uri: "https://test.token.image.url".to_string(),
    };
    let actual = balance_dto.to_balance(usd_to_fiat, &native_currency);

    assert_eq!(actual, expected);
}

'''
'''--- src/common/converters/tests/balances_v2.rs ---
use crate::common::models::backend::balances_v2::Balance as BalanceDto;
use crate::common::models::backend::chains::NativeCurrency;
use crate::providers::info::{TokenInfo, TokenType};
use crate::routes::balances::models::Balance;
use crate::tests::json::{BALANCE_COMPOUND_ETHER, BALANCE_ETHER};
use bigdecimal::BigDecimal;
use std::str::FromStr;

#[test]
fn native_token_balance() {
    std::env::set_var("FEATURE_FLAG_BALANCES_RATE_IMPLEMENTATION", "true");
    let balance_dto = serde_json::from_str::<BalanceDto>(BALANCE_ETHER).unwrap();

    let expected = Balance {
        token_info: TokenInfo {
            token_type: TokenType::NativeToken,
            address: "0x0000000000000000000000000000000000000000".to_string(),
            decimals: 18,
            symbol: "ETH".to_string(),
            name: "Ether".to_string(),
            logo_uri: Some("https://test.token.image.url".to_string()),
        },
        balance: "7457594371050000001".to_string(),
        fiat_balance: "2523.79908".to_string(),
        fiat_conversion: "338.420".to_string(),
    };

    let token_to_usd = BigDecimal::from_str("338.42").unwrap();
    let usd_to_fiat = BigDecimal::from_str("1.0").unwrap();
    let native_currency = NativeCurrency {
        name: "Ether".to_string(),
        symbol: "ETH".to_string(),
        decimals: 18,
        logo_uri: "https://test.token.image.url".to_string(),
    };
    let actual = balance_dto.to_balance_v2(&token_to_usd, &usd_to_fiat, &native_currency);

    assert_eq!(actual, expected);
}

#[test]
fn erc20_token_balance_usd_balance() {
    std::env::set_var("FEATURE_FLAG_BALANCES_RATE_IMPLEMENTATION", "true");
    let balance_dto = serde_json::from_str::<BalanceDto>(BALANCE_COMPOUND_ETHER).unwrap();

    let expected = Balance {
        token_info: TokenInfo {
            token_type: TokenType::Erc20,
            address: "0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e".to_string(),
            decimals: 8,
            symbol: "cETH".to_string(),
            name: "Compound Ether ðŸ“ˆ".to_string(),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e.png".to_string()),
        },
        balance: "5002".to_string(),
        fiat_balance: "0.00142".to_string(),
        fiat_conversion: "28.54620".to_string(),
    };

    let token_to_usd = BigDecimal::from_str("28.5462").unwrap();
    let usd_to_fiat = BigDecimal::from_str("1.0").unwrap();
    let native_currency = NativeCurrency {
        name: "Compound Ether ðŸ“ˆ".to_string(),
        symbol: "cETH".to_string(),
        decimals: 8,
        logo_uri: "https://test.token.image.url".to_string(),
    };
    let actual = balance_dto.to_balance_v2(&token_to_usd, &usd_to_fiat, &native_currency);

    assert_eq!(actual, expected);
}

#[test]
fn erc20_token_balance_fiat_is_twice_usd() {
    std::env::set_var("FEATURE_FLAG_BALANCES_RATE_IMPLEMENTATION", "true");
    let balance_dto = serde_json::from_str::<BalanceDto>(BALANCE_COMPOUND_ETHER).unwrap();

    let expected = Balance {
        token_info: TokenInfo {
            token_type: TokenType::Erc20,
            address: "0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e".to_string(),
            decimals: 8,
            symbol: "cETH".to_string(),
            name: "Compound Ether ðŸ“ˆ".to_string(),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e.png".to_string()),
        },
        balance: "5002".to_string(),
        fiat_balance: "0.00285".to_string(),
        fiat_conversion: "57.09240".to_string(),
    };

    let token_to_usd = BigDecimal::from_str("28.5462").unwrap();
    let usd_to_fiat = BigDecimal::from_str("2.0").unwrap();
    let native_currency = NativeCurrency {
        name: "Compound Ether ðŸ“ˆ".to_string(),
        symbol: "cETH".to_string(),
        decimals: 8,
        logo_uri: "https://test.token.image.url".to_string(),
    };
    let actual = balance_dto.to_balance_v2(&token_to_usd, &usd_to_fiat, &native_currency);

    assert_eq!(actual, expected);
}

'''
'''--- src/common/converters/tests/data_decoded.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::data_decoded::{DataDecoded, ParamValue, Parameter};
use crate::providers::info::*;
use crate::routes::transactions::models::{SettingsChange, SettingsInfo};
use mockall::predicate::eq;
use mockall::Sequence;
use serde_json::json;
use std::collections::HashMap;

#[rocket::async_test]
async fn data_decoded_set_fallback_handler_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| bail!("Some http error"));

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_SET_FALLBACK_HANDLER)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::SetFallbackHandler {
            handler: AddressEx::address_only("0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44"),
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_set_fallback_handler_to_settings_info_with_address_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| {
            Ok(AddressEx {
                value: "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44".to_string(),
                name: Some("Address name".to_string()),
                logo_uri: Some("logo.url".to_string()),
            })
        });

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_SET_FALLBACK_HANDLER)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::SetFallbackHandler {
            handler: AddressEx {
                value: "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44".to_string(),
                name: Some("Address name".to_string()),
                logo_uri: Some("logo.url".to_string()),
            },
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_add_owner_with_threshold_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(0);

    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_ADD_OWNER_WITH_THRESHOLD,
    )
    .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::AddOwner {
            owner: AddressEx::address_only("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
            threshold: 1,
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_add_owner_with_threshold_to_settings_info_with_address_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(0);

    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_ADD_OWNER_WITH_THRESHOLD,
    )
    .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::AddOwner {
            owner: AddressEx::address_only("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
            threshold: 1,
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_remove_owner_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(0);

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_REMOVE_OWNER).unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::RemoveOwner {
            owner: AddressEx::address_only("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
            threshold: 2,
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_swap_owner_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(0);

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_SWAP_OWNER).unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::SwapOwner {
            old_owner: AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
            new_owner: AddressEx::address_only("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_change_threshold_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(0);

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_CHANGE_THRESHOLD)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::ChangeThreshold { threshold: 2 }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_change_implementation_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| bail!("Some http error"));

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_CHANGE_MASTER_COPY)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::ChangeImplementation {
            implementation: AddressEx::address_only("0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A"),
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_change_implementation_to_settings_info_with_address_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| {
            Ok(AddressEx {
                value: "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A".to_string(),
                name: Some("Address name".to_string()),
                logo_uri: Some("logo.url".to_string()),
            })
        });

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_CHANGE_MASTER_COPY)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::ChangeImplementation {
            implementation: AddressEx {
                value: "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A".to_string(),
                name: Some("Address name".to_string()),
                logo_uri: Some("logo.url".to_string()),
            },
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_enable_module_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| bail!("Some http error"));

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_ENABLE_MODULE)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::EnableModule {
            module: AddressEx::address_only("0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d"),
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_enable_module_to_settings_info_with_address_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| {
            Ok(AddressEx {
                value: "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d".to_string(),
                name: Some("Address name".to_string()),
                logo_uri: Some("logo.url".to_string()),
            })
        });

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_ENABLE_MODULE)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::EnableModule {
            module: AddressEx {
                value: "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d".to_string(),
                name: Some("Address name".to_string()),
                logo_uri: Some("logo.url".to_string()),
            },
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_disable_module_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| bail!("Some http error"));

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_DISABLE_MODULE)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::DisableModule {
            module: AddressEx::address_only("0x25F73b24B866963B0e560fFF9bbA7908be0263E8"),
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_disable_module_to_settings_info_with_address_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| {
            Ok(AddressEx {
                value: "0x25F73b24B866963B0e560fFF9bbA7908be0263E8".to_string(),
                name: Some("Address name".to_string()),
                logo_uri: Some("logo.url".to_string()),
            })
        });

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_DISABLE_MODULE)
            .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::DisableModule {
            module: AddressEx {
                value: "0x25F73b24B866963B0e560fFF9bbA7908be0263E8".to_string(),
                name: Some("Address name".to_string()),
                logo_uri: Some("logo.url".to_string()),
            },
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_unknown_to_settings_info() {
    let mut mock_info_provider = MockInfoProvider::new();

    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_EXEC_TRANSACTION_FROM_MODULE,
    )
    .unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: None,
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_set_guard_address_known() {
    let guard = AddressEx {
        value: "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD".to_string(),
        name: Some("Cool guard contract".to_string()),
        logo_uri: Some("logo.url".to_string()),
    };
    let mut mock_info_provider = MockInfoProvider::new();
    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_SET_GUARD).unwrap();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .with(eq("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"))
        .times(1)
        .return_once(move |_| {
            Ok(AddressEx {
                value: "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD".to_string(),
                name: Some("Cool guard contract".to_string()),
                logo_uri: Some("logo.url".to_string()),
            })
        });

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::SetGuard { guard }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_set_guard_address_unknown() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .with(eq("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"))
        .times(1)
        .return_once(move |_| bail!("Some http error"));

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_SET_GUARD).unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::SetGuard {
            guard: AddressEx::address_only("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"),
        }),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[rocket::async_test]
async fn data_decoded_delete_guard() {
    let mut mock_info_provider = MockInfoProvider::new();

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_DELETE_GUARD).unwrap();

    let expected = SettingsChange {
        data_decoded: data_decoded.clone(),
        settings_info: Some(SettingsInfo::DeleteGuard),
    };

    let actual = DataDecoded::to_settings_info(&data_decoded, &mut mock_info_provider).await;

    assert_eq!(expected.settings_info, actual);
}

#[test]
fn data_decoded_with_nested_safe_transaction() {
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_EXEC_TRANSACTION_WITH_VALUE_DECODED,
    )
    .unwrap();

    let expected = DataDecoded {
        method: "execTransaction".to_string(),
        parameters: Some(vec![
            Parameter {
                name: "to".to_string(),
                param_type: "address".to_string(),
                value: ParamValue::SingleValue("0x441E604Ad49602c0B9C0B08D0781eCF96740786a".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "value".to_string(),
                param_type: "uint256".to_string(),
                value: ParamValue::SingleValue("0".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "data".to_string(),
                param_type: "bytes".to_string(),
                value: ParamValue::SingleValue("0x610b592500000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "operation".to_string(),
                param_type: "uint8".to_string(),
                value: ParamValue::SingleValue("0".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "safeTxGas".to_string(),
                param_type: "uint256".to_string(),
                value: ParamValue::SingleValue("53036".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "baseGas".to_string(),
                param_type: "uint256".to_string(),
                value: ParamValue::SingleValue("0".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "gasPrice".to_string(),
                param_type: "uint256".to_string(),
                value: ParamValue::SingleValue("0".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "gasToken".to_string(),
                param_type: "address".to_string(),
                value: ParamValue::SingleValue("0x0000000000000000000000000000000000000000".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "refundReceiver".to_string(),
                param_type: "address".to_string(),
                value: ParamValue::SingleValue("0x0000000000000000000000000000000000000000".to_string()),
                value_decoded: None,
            },
            Parameter {
                name: "signatures".to_string(),
                param_type: "bytes".to_string(),
                value: ParamValue::SingleValue("0x0000000000000000000000000e24b6e3beff0b44b773f068343bc2cb56cb37690000000000000000000000000000000000000000000000000000000000000000017e86d3185b70c297e33c7691d537fb9f11601ceb3a34f3c7b50fc7a3086380451c0924eac2e1bdd9cab77a96ced513f4c9df0432a19e9b61859261cdfb7dd6b41b".to_string()),
                value_decoded: None,
            },
        ]),
    };

    assert_eq!(expected, data_decoded);
}

#[rocket::async_test]
async fn address_info_index_not_multi_send_address_single_value() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A"))
        .times(1)
        .return_once(move |_| {
            Ok(AddressEx {
                value: "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A".to_string(),
                name: Some("Master Copy".to_string()),
                logo_uri: Some("url.de".to_string()),
            })
        });

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_CHANGE_MASTER_COPY)
            .unwrap();

    let expected = {
        let mut map = HashMap::new();
        map.insert(
            "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A".to_string(),
            AddressEx {
                value: "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A".to_string(),
                name: Some("Master Copy".to_string()),
                logo_uri: Some("url.de".to_string()),
            },
        );
        map
    };

    let actual = data_decoded
        .build_address_info_index(&mock_info_provider)
        .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn address_info_index_not_multi_send_address_array_value() {
    // expected address in json, one will not return to test behaviour of that too
    // 1) "0x4FB84d2dFc50017aFa759107a389759c8fD077DE" -> returns
    // 2) "0x111111111117dC0aa78b770fA6A738034120C302" -> returns
    // 3) "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE" -> bails
    // 4) "0x4FB84d2dFc50017aFa759107a389759c8fD077DE" -> skip duplicate
    // 5) "0xBc79855178842FDBA0c353494895DEEf509E26bB" -> bails
    // 6) "0x991c44331f0E59510Bcff76edBA06C3f552Eef8B" -> returns
    // we expect the index to contain 4 values

    let mut sequence = Sequence::new();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0x4FB84d2dFc50017aFa759107a389759c8fD077DE"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0x111111111117dC0aa78b770fA6A738034120C302"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"))
        .times(1)
        .return_once(move |_| bail!("no address"))
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0xBc79855178842FDBA0c353494895DEEf509E26bB"))
        .times(1)
        .return_once(move |_| bail!("no address"))
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0x991c44331f0E59510Bcff76edBA06C3f552Eef8B"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_SWAP_ARRAY_VALUES)
            .unwrap();

    let expected = {
        let mut map = HashMap::new();
        map.insert(
            "0x4FB84d2dFc50017aFa759107a389759c8fD077DE".to_string(),
            AddressEx {
                value: "0x4FB84d2dFc50017aFa759107a389759c8fD077DE".to_owned(),
                name: Some("0x4FB84d2dFc50017aFa759107a389759c8fD077DE_name".to_string()),
                logo_uri: Some("0x4FB84d2dFc50017aFa759107a389759c8fD077DE_url".to_string()),
            },
        );

        map.insert(
            "0x111111111117dC0aa78b770fA6A738034120C302".to_string(),
            AddressEx {
                value: "0x111111111117dC0aa78b770fA6A738034120C302".to_owned(),
                name: Some("0x111111111117dC0aa78b770fA6A738034120C302_name".to_string()),
                logo_uri: Some("0x111111111117dC0aa78b770fA6A738034120C302_url".to_string()),
            },
        );

        map.insert(
            "0x991c44331f0E59510Bcff76edBA06C3f552Eef8B".to_string(),
            AddressEx {
                value: "0x991c44331f0E59510Bcff76edBA06C3f552Eef8B".to_owned(),
                name: Some("0x991c44331f0E59510Bcff76edBA06C3f552Eef8B_name".to_string()),
                logo_uri: Some("0x991c44331f0E59510Bcff76edBA06C3f552Eef8B_url".to_string()),
            },
        );

        map
    };

    let actual = data_decoded
        .build_address_info_index(&mock_info_provider)
        .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn address_info_index_multi_send_single_level_of_nesting() {
    let mut sequence = Sequence::new();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0x111111125434b319222CdBf8C261674aDB56F3ae"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0xBc79855178842FDBA0c353494895DEEf509E26bB"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_MULTI_SEND_SINGLE_INNER_TRANSACTION,
    )
    .unwrap();

    let expected = {
        let mut map = HashMap::new();
        map.insert(
            "0x111111125434b319222CdBf8C261674aDB56F3ae".to_string(),
            AddressEx {
                value: "0x111111125434b319222CdBf8C261674aDB56F3ae".to_owned(),
                name: Some("0x111111125434b319222CdBf8C261674aDB56F3ae_name".to_string()),
                logo_uri: Some("0x111111125434b319222CdBf8C261674aDB56F3ae_url".to_string()),
            },
        );

        map.insert(
            "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5".to_string(),
            AddressEx {
                value: "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5".to_owned(),
                name: Some("0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5_name".to_string()),
                logo_uri: Some("0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5_url".to_string()),
            },
        );

        map.insert(
            "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE".to_string(),
            AddressEx {
                value: "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE".to_owned(),
                name: Some("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE_name".to_string()),
                logo_uri: Some("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE_url".to_string()),
            },
        );

        map.insert(
            "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".to_string(),
            AddressEx {
                value: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".to_owned(),
                name: Some("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2_name".to_string()),
                logo_uri: Some("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2_url".to_string()),
            },
        );

        map.insert(
            "0xBc79855178842FDBA0c353494895DEEf509E26bB".to_string(),
            AddressEx {
                value: "0xBc79855178842FDBA0c353494895DEEf509E26bB".to_owned(),
                name: Some("0xBc79855178842FDBA0c353494895DEEf509E26bB_name".to_string()),
                logo_uri: Some("0xBc79855178842FDBA0c353494895DEEf509E26bB_url".to_string()),
            },
        );

        map
    };

    let actual = data_decoded
        .build_address_info_index(&mut mock_info_provider)
        .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn address_info_index_multi_send_two_levels_of_nesting() {
    let mut sequence = Sequence::new();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_owned(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0x991c44331f0E59510Bcff76edBA06C3f552Eef8B"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_owned(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0x68881260bd04E9dAc7F77a314360ce05435B4818"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_owned(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        })
        .in_sequence(&mut sequence);

    // Had to doctor the json in order to have different address in the nested calls and verify that we
    // don't call them, not because they are duplicate, but because they are 1 level further nested
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DOCTORED_DATA_DECODED_NESTED_MULTI_SENDS,
    )
    .unwrap();

    let expected = {
        let mut map = HashMap::new();
        map.insert(
            "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE".to_string(),
            AddressEx {
                value: "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE".to_owned(),
                name: Some("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE_name".to_string()),
                logo_uri: Some("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE_url".to_string()),
            },
        );

        map.insert(
            "0x991c44331f0E59510Bcff76edBA06C3f552Eef8B".to_string(),
            AddressEx {
                value: "0x991c44331f0E59510Bcff76edBA06C3f552Eef8B".to_owned(),
                name: Some("0x991c44331f0E59510Bcff76edBA06C3f552Eef8B_name".to_string()),
                logo_uri: Some("0x991c44331f0E59510Bcff76edBA06C3f552Eef8B_url".to_string()),
            },
        );

        map.insert(
            "0x68881260bd04E9dAc7F77a314360ce05435B4818".to_string(),
            AddressEx {
                value: "0x68881260bd04E9dAc7F77a314360ce05435B4818".to_owned(),
                name: Some("0x68881260bd04E9dAc7F77a314360ce05435B4818_name".to_string()),
                logo_uri: Some("0x68881260bd04E9dAc7F77a314360ce05435B4818_url".to_string()),
            },
        );

        map
    };

    let actual = data_decoded
        .build_address_info_index(&mut mock_info_provider)
        .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn address_info_index_skip_address_info_for_0x0() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0x441E604Ad49602c0B9C0B08D0781eCF96740786a"))
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_owned(),
                name: Some(format!("{}_name", &address)),
                logo_uri: Some(format!("{}_url", &address)),
            })
        });

    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_EXEC_TRANSACTION_WITH_VALUE_DECODED,
    )
    .unwrap();

    let expected = {
        let mut map = HashMap::new();
        map.insert(
            "0x441E604Ad49602c0B9C0B08D0781eCF96740786a".to_string(),
            AddressEx {
                value: "0x441E604Ad49602c0B9C0B08D0781eCF96740786a".to_string(),
                name: Some("0x441E604Ad49602c0B9C0B08D0781eCF96740786a_name".to_string()),
                logo_uri: Some("0x441E604Ad49602c0B9C0B08D0781eCF96740786a_url".to_string()),
            },
        );

        map
    };

    let actual = data_decoded
        .build_address_info_index(&mut mock_info_provider)
        .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn address_info_index_no_results_returns_none() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .with(eq("0x441E604Ad49602c0B9C0B08D0781eCF96740786a"))
        .times(1)
        .return_once(move |_| bail!("no address info"));

    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_EXEC_TRANSACTION_WITH_VALUE_DECODED,
    )
    .unwrap();

    let expected = None;

    let actual = data_decoded
        .build_address_info_index(&mut mock_info_provider)
        .await;

    assert_eq!(expected, actual);
}

#[test]
fn nested_delegate_in_multi_send_with_nested_delegate() {
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DOCTORED_DATA_DECODED_MULTI_SEND_NESTED_DELEGATE,
    )
    .unwrap();

    assert_eq!(data_decoded.has_nested_delegated(), true);
}

#[test]
fn nested_delegate_in_multi_send_without_nested_delegate() {
    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_MULTI_SEND).unwrap();

    assert_eq!(data_decoded.has_nested_delegated(), false);
}

#[test]
fn no_param_data_decoded_has_nested_delegate() {
    let data_decoded =
        serde_json::from_value::<DataDecoded>(json!({"method":"parameterlessMethod"})).unwrap();

    assert_eq!(data_decoded.has_nested_delegated(), false);
}

#[test]
fn not_multi_send_with_delegate_call() {
    let data_decoded =
        serde_json::from_value::<DataDecoded>(json!({
                "method": "notMultiSend",
                "parameters": [
                  {
                    "name": "notTransactions",
                    "type": "bytes",
                    "value": "0x00d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c6800000d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c6800000d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
                    "valueDecoded": [
                      {
                        "operation": 1,
                        "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
                        "value": "0",
                        "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
                        "dataDecoded": null
                      }
                    ]
                  }
                ]
    })).unwrap();

    assert_eq!(data_decoded.has_nested_delegated(), true);
}

'''
'''--- src/common/converters/tests/get_address_ex_from_any_source.rs ---
use crate::common::converters::get_address_ex_from_any_source;
use crate::common::models::addresses::AddressEx;
use crate::providers::info::*;

#[rocket::async_test]
async fn get_address_info_address_diff_than_safe() {
    let address = "0x1234";
    let safe = "0x4321";

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let expected = AddressEx {
        value: address.to_string(),
        name: Some("".to_string()),
        logo_uri: None,
    };

    let actual = get_address_ex_from_any_source(safe, address, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn get_address_info_address_diff_than_safe_error() {
    let address = "0x1234";
    let safe = "0x4321";

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let actual = get_address_ex_from_any_source(safe, address, &mut mock_info_provider).await;
    assert_eq!(AddressEx::address_only(address), actual);
}

#[rocket::async_test]
async fn get_address_info_address_equal_to_safe() {
    let address = "0x1234";
    let safe = "0x1234";

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(0);

    let actual = get_address_ex_from_any_source(safe, address, &mut mock_info_provider).await;
    assert_eq!(AddressEx::address_only(address), actual);
}

'''
'''--- src/common/converters/tests/get_transfer_direction.rs ---
use crate::common::converters::get_transfer_direction;
use crate::routes::transactions::models::TransferDirection;

#[test]
fn get_transfer_direction_incoming() {
    let safe = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let to = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let from = "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0";

    let actual = get_transfer_direction(safe, from, to);

    assert_eq!(actual, TransferDirection::Incoming);
}

#[test]
fn get_transfer_direction_outgoing() {
    let safe = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let to = "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0";
    let from = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";

    let actual = get_transfer_direction(safe, from, to);

    assert_eq!(actual, TransferDirection::Outgoing);
}

#[test]
fn get_transfer_direction_unknown() {
    let safe = "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23";
    let to = "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0";
    let from = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";

    let actual = get_transfer_direction(safe, from, to);

    assert_eq!(actual, TransferDirection::Unknown);
}

'''
'''--- src/common/converters/tests/mod.rs ---
pub(super) mod balances;
pub(super) mod balances_v2;
mod data_decoded;
mod get_address_ex_from_any_source;
mod get_transfer_direction;
mod page_metadata;
mod safe_app;
mod transfer_erc20;
mod transfer_erc721;
mod transfer_ether;
mod transfers;

'''
'''--- src/common/converters/tests/page_metadata.rs ---
use crate::common::models::page::PageMetadata;

#[test]
fn page_metadata_with_valid_non_zero_data() {
    let input = "limit=20&offset=20&queued=false";

    let actual = PageMetadata::from_cursor(input);
    let expected = PageMetadata {
        offset: 20,
        limit: 20,
    };
    assert_eq!(expected, actual);
}

#[test]
fn page_metadata_with_zeros() {
    let input = "limit=0&offset=0";

    let actual = PageMetadata::from_cursor(input);
    let expected = PageMetadata {
        offset: 0,
        limit: 0,
    };
    assert_eq!(expected, actual);
}

#[test]
fn page_metadata_with_missing_optional_args() {
    let input = "offset=50";

    let actual = PageMetadata::from_cursor(input);
    let expected = PageMetadata {
        offset: 50,
        limit: 20,
    };
    assert_eq!(expected, actual);
}

'''
'''--- src/common/converters/tests/safe_app.rs ---
use crate::common::models::backend::safe_apps::SafeApp as BackendSafeApp;
use crate::routes::safe_apps::models::{
    SafeApp, SafeAppAccessControlPolicies, SafeAppDomainAllowlistPolicy, SafeAppProvider,
};

#[test]
fn safe_apps_empty() {
    let backend_json = "[]";
    let expected: Vec<SafeApp> = vec![];
    let response = serde_json::from_str::<Vec<BackendSafeApp>>(backend_json)
        .expect("SafeApp deserialization failed");

    let actual: Vec<SafeApp> = response
        .into_iter()
        .map(|safe_app| safe_app.into())
        .collect();

    assert_eq!(expected, actual);
}

#[test]
fn safe_apps_several_apps() {
    let response =
        serde_json::from_str::<Vec<BackendSafeApp>>(crate::tests::json::POLYGON_SAFE_APPS)
            .expect("SafeApps deserialization failure");

    let actual = response
        .into_iter()
        .map(|safe_app| safe_app.into())
        .collect::<Vec<SafeApp>>();

    let expected = vec![
        SafeApp {
            id: 26,
            url: "https://curve.fi".to_string(),
            name: "Curve".to_string(),
            icon_url: "https://curve.fi/logo-square.svg".to_string(),
            description: "Decentralized exchange liquidity pool designed for extremely efficient stablecoin trading and low-risk income for liquidity providers".to_string(),
            chain_ids: vec!["1".to_string(), "137".to_string()],
            provider: None,
            access_control: SafeAppAccessControlPolicies::NoRestrictions,
            tags: vec![]
        },
        SafeApp {
            id: 24,
            url: "https://safe-apps.dev.gnosisdev.com/tx-builder".to_string(),
            name: "Transaction Builder".to_string(),
            icon_url: "https://safe-apps.dev.gnosisdev.com/tx-builder/tx-builder.png".to_string(),
            description: "A Safe app to compose custom transactions".to_string(),
            chain_ids: vec!["1".to_string(), "4".to_string(),"10".to_string(),"56".to_string(),"100".to_string(),"137".to_string(),"246".to_string(), "42161".to_string(), "43114".to_string(), "73799".to_string()],
            provider: None,
            access_control: SafeAppAccessControlPolicies::NoRestrictions,
            tags: vec![]
        },
        SafeApp {
            id: 11,
            url: "https://app.1inch.io".to_string(),
            name: "1inch.exchange".to_string(),
            icon_url: "https://app.1inch.io/assets/images/1inch.svg".to_string(),
            description: "The most efficient defi aggregator".to_string(),
            chain_ids: vec!["1".to_string(),"56".to_string(),"137".to_string()],
            provider: Some(SafeAppProvider {
                url: "https://1inch.exchange".to_string(),
                name: "1inch corporation".to_string(),
            }),
            access_control: SafeAppAccessControlPolicies::DomainAllowlist(SafeAppDomainAllowlistPolicy {
                value: vec!["https://gnosis-safe.io".to_string(), "https://dev.gnosis-safe.io".to_string()],
            }),
            tags: vec![]
        },
        SafeApp {
            id: 30,
            url: "https://paraswap.io".to_string(),
            name: "ParaSwap".to_string(),
            icon_url: "https://paraswap.io/paraswap.svg".to_string(),
            description: "ParaSwap allows dApps and traders to get the best DEX liquidity by aggregating multiple markets and offering the best rates".to_string(),
            chain_ids: vec!["1".to_string(),"56".to_string(),"137".to_string()],
            provider: None,
            access_control: SafeAppAccessControlPolicies::NoRestrictions,
            tags: vec![]
        },
        SafeApp {
            id: 25,
            url: "https://safe-apps.dev.gnosisdev.com/wallet-connect".to_string(),
            name: "WalletConnect".to_string(),
            icon_url: "https://safe-apps.dev.gnosisdev.com/wallet-connect/wallet-connect.svg".to_string(),
            description: "Connect your Safe to any dApp that supports WalletConnect".to_string(),
            chain_ids: vec!["1".to_string(), "4".to_string(), "10".to_string(),"56".to_string(),"100".to_string(),"137".to_string(),"246".to_string(), "73799".to_string(), "42161".to_string(), "43114".to_string()],
            provider: None,
            access_control: SafeAppAccessControlPolicies::NoRestrictions,
            tags: vec![]
        },
    ];

    assert_eq!(actual, expected);
}

'''
'''--- src/common/converters/tests/transfer_erc20.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transfers::{
    Erc20Transfer as Erc20TransferDto, Transfer as TransferDto,
};
use crate::providers::info::*;
use crate::routes::transactions::models::{
    Erc20Transfer, Transfer, TransferDirection, TransferInfo,
};

#[rocket::async_test]
async fn erc20_transfer_dto_to_incoming_transfer_transaction() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let erc20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITH_TOKEN_INFO_INCOMING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = Transfer {
        sender: AddressEx::address_only("0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F"),
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: TransferInfo::Erc20(
            Erc20Transfer {
                token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
                value: "1000000000000000000".to_string(),
                token_name: Some("Dai".to_string()),
                token_symbol: Some("DAI".to_string()),
                decimals: Some(18),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png".to_string()),
            }
        ),
    };

    let actual = Erc20TransferDto::to_transfer_transaction(
        &erc20_transfer,
        &mut mock_info_provider,
        safe_address,
    )
    .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc20_transfer_dto_to_incoming_transfer_transaction_with_address_info() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let erc20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITH_TOKEN_INFO_INCOMING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let expected = Transfer {
        sender: AddressEx{
            value: "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F".to_string(),
            name: Some("".to_string()),
            logo_uri: None
        },
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: TransferInfo::Erc20(
            Erc20Transfer {
                token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
                value: "1000000000000000000".to_string(),
                token_name: Some("Dai".to_string()),
                token_symbol: Some("DAI".to_string()),
                decimals: Some(18),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png".to_string()),
            }
        ),
    };

    let actual = Erc20TransferDto::to_transfer_transaction(
        &erc20_transfer,
        &mut mock_info_provider,
        safe_address,
    )
    .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc20_transfer_dto_to_outgoing_transfer_transaction_with_address_info() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let erc20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITH_TOKEN_INFO_OUTGOING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let expected = Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx{
            value: "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F".to_string(),
            name: Some("".to_string()),
            logo_uri: None
        },
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc20(
            Erc20Transfer {
                token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
                value: "1000000000000000000".to_string(),
                token_name: Some("Dai".to_string()),
                token_symbol: Some("DAI".to_string()),
                decimals: Some(18),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png".to_string()),
            }
        ),
    };

    let actual = Erc20TransferDto::to_transfer_transaction(
        &erc20_transfer,
        &mut mock_info_provider,
        safe_address,
    )
    .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc20_transfer_dto_to_transfer_info_token_available() {
    let erc20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITH_TOKEN_INFO_INCOMING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);

    let expected = TransferInfo::Erc20(
        Erc20Transfer {
            token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
            value: "1000000000000000000".to_string(),
            token_name: Some("Dai".to_string()),
            token_symbol: Some("DAI".to_string()),
            decimals: Some(18),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png".to_string()),
        }
    );

    let actual = Erc20TransferDto::to_transfer_info(&erc20_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc20_transfer_dto_to_transfer_info_token_unavailable() {
    let erc20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITHOUT_TOKEN_INFO,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| bail!("No token info"));

    let expected = TransferInfo::Erc20(Erc20Transfer {
        token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
        value: "1000000000000000000".to_string(),
        token_name: None,
        token_symbol: None,
        decimals: None,
        logo_uri: None,
    });

    let actual = Erc20TransferDto::to_transfer_info(&erc20_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc20_transfer_dto_get_token_info_present() {
    let erc20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITH_TOKEN_INFO_INCOMING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);

    let expected = TransferInfo::Erc20 (Erc20Transfer{
        token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
        token_name: Some("Dai".to_string()),
        token_symbol: Some("DAI".to_string()),
        decimals: Some(18),
        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png".to_string()),
        value: "1000000000000000000".to_string()
    });
    let actual = Erc20TransferDto::to_transfer_info(&erc20_transfer, &mut mock_info_provider).await;

    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn erc20_transfer_dto_get_token_info_not_present() {
    let erc20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITHOUT_TOKEN_INFO,
    )
    .unwrap();
    let token_info = serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_DAI).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));

    let expected = TransferInfo::Erc20 (Erc20Transfer{
        token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
        token_name: Some("Dai".to_string()),
        token_symbol: Some("DAI".to_string()),
        decimals: Some(18),
        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png".to_string()),
        value: "1000000000000000000".to_string()
    });

    let actual = Erc20TransferDto::to_transfer_info(&erc20_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc20_transfer_dto_get_info_provider_error() {
    let erc20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITHOUT_TOKEN_INFO,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(|_| bail!("No token info"));

    let expected = TransferInfo::Erc20(Erc20Transfer {
        token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
        token_name: None,
        token_symbol: None,
        decimals: None,
        logo_uri: None,
        value: "1000000000000000000".to_string(),
    });

    let actual = Erc20TransferDto::to_transfer_info(&erc20_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[test]
fn erc20_transfer_dto_get_execution_time() {
    let ether_transfer_dto = TransferDto::Erc20(
        serde_json::from_str::<Erc20TransferDto>(
            crate::tests::json::ERC_20_TRANSFER_WITHOUT_TOKEN_INFO,
        )
        .unwrap(),
    );

    let actual = TransferDto::get_execution_time(&ether_transfer_dto);

    assert_eq!(Some(1597162353000), actual);
}

#[test]
fn erc20_transfer_dto_get_transaction_hash() {
    let ether_transfer_dto = TransferDto::Erc20(
        serde_json::from_str::<Erc20TransferDto>(
            crate::tests::json::ERC_20_TRANSFER_WITHOUT_TOKEN_INFO,
        )
        .unwrap(),
    );

    let actual = TransferDto::get_transaction_hash(&ether_transfer_dto);

    assert_eq!(
        Some("0x3663ae11e5414620b0fd7fe7c8175e4356070a0a403e6e6516d7aece29b7680d".to_string()),
        actual
    );
}

'''
'''--- src/common/converters/tests/transfer_erc721.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transfers::{
    Erc721Transfer as Erc721TransferDto, Transfer as TransferDto,
};
use crate::providers::info::*;
use crate::routes::transactions::models::{
    Erc721Transfer, Transfer, TransferDirection, TransferInfo,
};

#[rocket::async_test]
async fn erc721_transfer_dto_to_incoming_transfer_transaction() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let erc721_transfer = serde_json::from_str::<Erc721TransferDto>(
        crate::tests::json::ERC_721_TRANSFER_WITH_TOKEN_INFO_INCOMING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = Transfer {
        sender: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: TransferInfo::Erc721(
            Erc721Transfer {
                token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
                token_id: "37".to_string(),
                token_name: Some("PV Memorial Token".to_string()),
                token_symbol: Some("PVT".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png".to_string()),
            }
        ),
    };

    let actual = Erc721TransferDto::to_transfer_transaction(
        &erc721_transfer,
        &mut mock_info_provider,
        safe_address,
    )
    .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc721_transfer_dto_to_incoming_transfer_transaction_with_address_info() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let erc721_transfer = serde_json::from_str::<Erc721TransferDto>(
        crate::tests::json::ERC_721_TRANSFER_WITH_TOKEN_INFO_INCOMING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let expected = Transfer {
        sender: AddressEx { value: "0x938bae50a210b80EA233112800Cd5Bc2e7644300".to_string(), name: Some("".to_string()), logo_uri: None },
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: TransferInfo::Erc721(
            Erc721Transfer {
                token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
                token_id: "37".to_string(),
                token_name: Some("PV Memorial Token".to_string()),
                token_symbol: Some("PVT".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png".to_string()),
            }
        ),
    };

    let actual = Erc721TransferDto::to_transfer_transaction(
        &erc721_transfer,
        &mut mock_info_provider,
        safe_address,
    )
    .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc721_transfer_dto_to_outgoing_transfer_transaction_with_address_info() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let erc721_transfer = serde_json::from_str::<Erc721TransferDto>(
        crate::tests::json::ERC_721_TRANSFER_WITH_TOKEN_INFO_OUTGOING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let expected = Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx{ value: "0x938bae50a210b80EA233112800Cd5Bc2e7644300".to_string(), name: Some("".to_string()), logo_uri: None },
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc721(
            Erc721Transfer {
                token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
                token_id: "37".to_string(),
                token_name: Some("PV Memorial Token".to_string()),
                token_symbol: Some("PVT".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png".to_string()),
            }
        ),
    };

    let actual = Erc721TransferDto::to_transfer_transaction(
        &erc721_transfer,
        &mut mock_info_provider,
        safe_address,
    )
    .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc721_transfer_dto_to_transfer_info_token_available() {
    let erc721_transfer = serde_json::from_str::<Erc721TransferDto>(
        crate::tests::json::ERC_721_TRANSFER_WITH_TOKEN_INFO_INCOMING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);

    let expected = TransferInfo::Erc721(
        Erc721Transfer {
            token_id: "37".to_string(),
            token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
            token_name: Some("PV Memorial Token".to_string()),
            token_symbol: Some("PVT".to_string()),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png".to_string()),
        }
    );

    let actual =
        Erc721TransferDto::to_transfer_info(&erc721_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc721_transfer_dto_to_transfer_info_token_unavailable() {
    let erc721_transfer = serde_json::from_str::<Erc721TransferDto>(
        crate::tests::json::ERC_721_TRANSFER_WITHOUT_TOKEN_INFO,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| bail!("No token info"));

    let expected = TransferInfo::Erc721(Erc721Transfer {
        token_id: "37".to_string(),
        token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
        token_name: None,
        token_symbol: None,
        logo_uri: None,
    });

    let actual =
        Erc721TransferDto::to_transfer_info(&erc721_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc721_transfer_dto_get_token_info_present() {
    let erc721_transfer = serde_json::from_str::<Erc721TransferDto>(
        crate::tests::json::ERC_721_TRANSFER_WITH_TOKEN_INFO_INCOMING,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);

    let expected = TransferInfo::Erc721(Erc721Transfer{
        token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
        token_id: "37".to_string(),
        token_name: Some("PV Memorial Token".to_string()),
        token_symbol: Some("PVT".to_string()),
        logo_uri:  Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png".to_string())
    }) ;

    let actual =
        Erc721TransferDto::to_transfer_info(&erc721_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc721_transfer_dto_get_token_info_not_present() {
    let erc721_transfer = serde_json::from_str::<Erc721TransferDto>(
        crate::tests::json::ERC_721_TRANSFER_WITHOUT_TOKEN_INFO,
    )
    .unwrap();
    let token_info =
        serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_PV_MEMORIAL_TOKEN).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));

    let expected = TransferInfo::Erc721 (Erc721Transfer{
        token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
        token_id: "37".to_string(),
        token_name: Some("PV Memorial Token".to_string()),
        token_symbol: Some("PVT".to_string()),
        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png".to_string()),
    });

    let actual =
        Erc721TransferDto::to_transfer_info(&erc721_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc721_transfer_dto_get_info_provider_error() {
    let erc721_transfer = serde_json::from_str::<Erc721TransferDto>(
        crate::tests::json::ERC_721_TRANSFER_WITHOUT_TOKEN_INFO,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| bail!("No token info"));

    let expected = TransferInfo::Erc721(Erc721Transfer {
        token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
        token_id: "37".to_string(),
        token_name: None,
        token_symbol: None,
        logo_uri: None,
    });

    let actual =
        Erc721TransferDto::to_transfer_info(&erc721_transfer, &mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[test]
fn erc721_transfer_dto_get_execution_time() {
    let ether_transfer_dto = TransferDto::Erc721(
        serde_json::from_str::<Erc721TransferDto>(
            crate::tests::json::ERC_721_TRANSFER_WITHOUT_TOKEN_INFO,
        )
        .unwrap(),
    );

    let actual = TransferDto::get_execution_time(&ether_transfer_dto);

    assert_eq!(Some(1595594051000), actual);
}

#[test]
fn erc721_transfer_dto_get_transaction_hash() {
    let ether_transfer_dto = TransferDto::Erc721(
        serde_json::from_str::<Erc721TransferDto>(
            crate::tests::json::ERC_721_TRANSFER_WITHOUT_TOKEN_INFO,
        )
        .unwrap(),
    );

    let actual = TransferDto::get_transaction_hash(&ether_transfer_dto);

    assert_eq!(
        Some("0x6b4ddfcf19320e1edaad5bcdef3da54f463ee5cb609ba4a1e2042fbff702e718".to_string()),
        actual
    );
}

'''
'''--- src/common/converters/tests/transfer_ether.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transfers::{
    EtherTransfer as EtherTransferDto, Transfer as TransferDto,
};
use crate::providers::info::*;
use crate::routes::transactions::models::{
    NativeCoinTransfer, Transfer, TransferDirection, TransferInfo,
};

#[rocket::async_test]
async fn ether_transfer_dto_ether_incoming_transfer_transaction() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("no address info"));

    let ether_transfer_dto =
        serde_json::from_str::<EtherTransferDto>(crate::tests::json::ETHER_TRANSFER_INCOMING)
            .unwrap();
    let safe = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let expected = Transfer {
        sender: AddressEx::address_only("0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F"),
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: (TransferInfo::NativeCoin(NativeCoinTransfer {
            value: "1000000000000000".to_string(),
        })),
    };

    let actual = EtherTransferDto::to_transfer_transaction(
        &ether_transfer_dto,
        &mut mock_info_provider,
        safe,
    )
    .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn ether_transfer_dto_ether_incoming_transfer_transaction_with_address_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let ether_transfer_dto =
        serde_json::from_str::<EtherTransferDto>(crate::tests::json::ETHER_TRANSFER_INCOMING)
            .unwrap();
    let safe = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let expected = Transfer {
        sender: AddressEx {
            value: "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F".to_string(),
            name: Some("".to_string()),
            logo_uri: None,
        },
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: (TransferInfo::NativeCoin(NativeCoinTransfer {
            value: "1000000000000000".to_string(),
        })),
    };

    let actual = EtherTransferDto::to_transfer_transaction(
        &ether_transfer_dto,
        &mut mock_info_provider,
        safe,
    )
    .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn ether_transfer_dto_ether_outgoing_transfer_transaction_with_address_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let ether_transfer_dto =
        serde_json::from_str::<EtherTransferDto>(crate::tests::json::ETHER_TRANSFER_OUTGOING)
            .unwrap();
    let safe = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let expected = Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx {
            value: "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F".to_string(),
            name: Some("".to_string()),
            logo_uri: None,
        },
        direction: TransferDirection::Outgoing,
        transfer_info: (TransferInfo::NativeCoin(NativeCoinTransfer {
            value: "1000000000000000".to_string(),
        })),
    };

    let actual = EtherTransferDto::to_transfer_transaction(
        &ether_transfer_dto,
        &mut mock_info_provider,
        safe,
    )
    .await;

    assert_eq!(expected, actual);
}

#[test]
fn ether_transfer_dto_to_transfer_info() {
    let ether_transfer_dto =
        serde_json::from_str::<EtherTransferDto>(crate::tests::json::ETHER_TRANSFER_INCOMING)
            .unwrap();
    let expected = TransferInfo::NativeCoin(NativeCoinTransfer {
        value: "1000000000000000".to_string(),
    });

    let actual = EtherTransferDto::to_transfer_info(&ether_transfer_dto);

    assert_eq!(expected, actual);
}

#[test]
fn ether_transfer_dto_get_execution_time() {
    let ether_transfer_dto = TransferDto::Ether(
        serde_json::from_str::<EtherTransferDto>(crate::tests::json::ETHER_TRANSFER_INCOMING)
            .unwrap(),
    );

    let actual = TransferDto::get_execution_time(&ether_transfer_dto);

    assert_eq!(Some(1597733631000), actual);
}

#[test]
fn ether_transfer_dto_get_transaction_hash() {
    let ether_transfer_dto = TransferDto::Ether(
        serde_json::from_str::<EtherTransferDto>(crate::tests::json::ETHER_TRANSFER_INCOMING)
            .unwrap(),
    );

    let actual = TransferDto::get_transaction_hash(&ether_transfer_dto);

    assert_eq!(
        Some("0x41b610e8cce50bbe3aa06d6953ecc5f92a838aedc024a265c0afca7ec4f33bdf".to_string()),
        actual
    );
}

'''
'''--- src/common/converters/tests/transfers.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transfers::{
    Erc20Transfer as Erc20TransferDto, Erc721Transfer as Erc721TransferDto,
    EtherTransfer as EtherTransferDto, Transfer as TransferDto,
};
use crate::providers::info::*;
use crate::routes::transactions::models::details::TransactionDetails;
use crate::routes::transactions::models::{
    Erc20Transfer, Erc721Transfer, NativeCoinTransfer, TransactionInfo, TransactionStatus,
    Transfer, TransferDirection, TransferInfo,
};

#[rocket::async_test]
async fn erc_20_transfer_dto_to_transaction_info() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let erc_20_transfer = TransferDto::Erc20(
        serde_json::from_str::<Erc20TransferDto>(
            crate::tests::json::ERC_20_TRANSFER_WITH_TOKEN_INFO_INCOMING,
        )
        .unwrap(),
    );

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F"),
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: TransferInfo::Erc20(
            Erc20Transfer {
                token_address: "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa".to_string(),
                value: "1000000000000000000".to_string(),
                token_name: Some("Dai".to_string()),
                token_symbol: Some("DAI".to_string()),
                decimals: Some(18),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png".to_string()),
            }
        ),
    });

    let actual = erc_20_transfer
        .to_transfer(&mut mock_info_provider, safe_address)
        .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn erc_721_transfer_dto_to_transaction_info() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let erc_721_transfer = TransferDto::Erc721(
        serde_json::from_str::<Erc721TransferDto>(
            crate::tests::json::ERC_721_TRANSFER_WITH_TOKEN_INFO_INCOMING,
        )
        .unwrap(),
    );

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: TransferInfo::Erc721(
            Erc721Transfer {
                token_address: "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98".to_string(),
                token_id: "37".to_string(),
                token_name: Some("PV Memorial Token".to_string()),
                token_symbol: Some("PVT".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png".to_string()),
            }
        ),
    });

    let actual = erc_721_transfer
        .to_transfer(&mut mock_info_provider, safe_address)
        .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn ether_transfer_dto_to_transaction_info() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let ether_transfer_dto = TransferDto::Ether(
        serde_json::from_str::<EtherTransferDto>(crate::tests::json::ETHER_TRANSFER_INCOMING)
            .unwrap(),
    );

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F"),
        recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        direction: TransferDirection::Incoming,
        transfer_info: (TransferInfo::NativeCoin(NativeCoinTransfer {
            value: "1000000000000000".to_string(),
        })),
    });

    let actual = ether_transfer_dto
        .to_transfer(&mut mock_info_provider, safe_address)
        .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn unknown_transfer_dto_to_transaction_info() {
    let unknown_transfer_dto = TransferDto::Unknown;
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(0);

    let actual = unknown_transfer_dto
        .to_transfer(&mut mock_info_provider, safe_address)
        .await;

    assert_eq!(TransactionInfo::Unknown, actual);
}

#[test]
fn unknown_transfer_dto_get_execution_time() {
    let unknown_transfer_dto = TransferDto::Unknown;

    let actual = unknown_transfer_dto.get_execution_time();

    assert_eq!(None, actual);
}

#[test]
fn unknown_transfer_dto_get_transaction_hash() {
    let unknown_transfer_dto = TransferDto::Unknown;

    let actual = unknown_transfer_dto.get_transaction_hash();

    assert_eq!(None, actual);
}

#[rocket::async_test]
async fn transfer_dto_to_transaction_details() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let ether_transfer_dto = TransferDto::Ether(
        serde_json::from_str::<EtherTransferDto>(crate::tests::json::ETHER_TRANSFER_INCOMING)
            .unwrap(),
    );

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionDetails {
        safe_address: safe_address.to_owned(),
        tx_id: ether_transfer_dto.generate_id(
            safe_address,
            "0x41b610e8cce50bbe3aa06d6953ecc5f92a838aedc024a265c0afca7ec4f33bdf",
        ),
        executed_at: Some(1597733631000),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Transfer(Transfer {
            sender: AddressEx::address_only("0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F"),
            recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
            direction: TransferDirection::Incoming,
            transfer_info: (TransferInfo::NativeCoin(NativeCoinTransfer {
                value: "1000000000000000".to_string(),
            })),
        }),
        tx_data: None,
        detailed_execution_info: None,
        tx_hash: Some(
            "0x41b610e8cce50bbe3aa06d6953ecc5f92a838aedc024a265c0afca7ec4f33bdf".to_string(),
        ),
        safe_app_info: None,
    };

    let actual = ether_transfer_dto
        .to_transaction_details(
            &mut mock_info_provider,
            safe_address,
            "0x41b610e8cce50bbe3aa06d6953ecc5f92a838aedc024a265c0afca7ec4f33bdf",
        )
        .await
        .unwrap();

    assert_eq!(expected, actual)
}

#[rocket::async_test]
async fn transfer_erc20_transfer_with_erc721_token_info_returns_transfer_tx() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let erc_20_transfer = serde_json::from_str::<Erc20TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITH_ERC721_TOKEN_INFO,
    )
    .unwrap();

    let transfer = TransferDto::Erc20(erc_20_transfer);
    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0xd31e655bC4Eb5BCFe25A47d636B25bb4aa4041B2"),
        recipient: AddressEx::address_only("0xBc79855178842FDBA0c353494895DEEf509E26bB"),
        direction: TransferDirection::Incoming,
        transfer_info: TransferInfo::Erc721(Erc721Transfer {
            token_address: "0xa9517B2E61a57350D6555665292dBC632C76adFe".to_string(),
            token_id: "856420144564".to_string(),
            token_name: Some("a!NEVER VISIT www.168pools.com to check DeFi ROi !".to_string()),
            token_symbol: Some("a!NEVER VISIT www.168pools.com to check DeFi ROi !".to_string()),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xa9517B2E61a57350D6555665292dBC632C76adFe.png".to_string()),
        }),
    });

    let actual = transfer
        .to_transfer(
            &mut mock_info_provider,
            "0xBc79855178842FDBA0c353494895DEEf509E26bB",
        )
        .await;

    assert_eq!(expected, actual)
}

'''
'''--- src/common/converters/transfers.rs ---
use super::get_transfer_direction;
use crate::common::converters::get_address_ex_from_any_source;
use crate::common::models::backend::transfers::{
    Erc20Transfer as Erc20TransferDto, Erc721Transfer as Erc721TransferDto,
    EtherTransfer as EtherTransferDto, Transfer as TransferDto,
};
use crate::providers::info::{InfoProvider, TokenInfo, TokenType};
use crate::routes::transactions::models::details::TransactionDetails;
use crate::routes::transactions::models::{
    Erc20Transfer, Erc721Transfer, NativeCoinTransfer, TransactionInfo, TransactionStatus,
    Transfer as ServiceTransfer, TransferInfo,
};
use crate::utils::errors::ApiResult;

impl TransferDto {
    pub async fn to_transfer(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        safe: &str,
    ) -> TransactionInfo {
        match self {
            TransferDto::Erc721(transfer) => TransactionInfo::Transfer(
                transfer.to_transfer_transaction(info_provider, safe).await,
            ),
            TransferDto::Erc20(transfer) => TransactionInfo::Transfer(
                transfer.to_transfer_transaction(info_provider, safe).await,
            ),
            TransferDto::Ether(transfer) => TransactionInfo::Transfer(
                transfer.to_transfer_transaction(info_provider, safe).await,
            ),
            _ => TransactionInfo::Unknown,
        }
    }

    pub async fn to_transaction_details(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        safe: &str,
        tx_hash: &str,
    ) -> ApiResult<TransactionDetails> {
        Ok(TransactionDetails {
            safe_address: safe.to_owned(),
            tx_id: self.generate_id(safe, tx_hash),
            executed_at: self.get_execution_time(),
            tx_status: TransactionStatus::Success,
            tx_info: self.to_transfer(info_provider, safe).await,
            tx_data: None,
            tx_hash: self.get_transaction_hash(),
            detailed_execution_info: None,
            safe_app_info: None,
        })
    }

    pub(crate) fn get_execution_time(&self) -> Option<i64> {
        match self {
            TransferDto::Erc721(transfer) => Some(transfer.execution_date.timestamp_millis()),
            TransferDto::Erc20(transfer) => Some(transfer.execution_date.timestamp_millis()),
            TransferDto::Ether(transfer) => Some(transfer.execution_date.timestamp_millis()),
            _ => None,
        }
    }

    pub(crate) fn get_transaction_hash(&self) -> Option<String> {
        match self {
            TransferDto::Erc721(transfer) => Some(transfer.transaction_hash.to_owned()),
            TransferDto::Erc20(transfer) => Some(transfer.transaction_hash.to_owned()),
            TransferDto::Ether(transfer) => Some(transfer.transaction_hash.to_owned()),
            _ => None,
        }
    }
}

impl Erc20TransferDto {
    pub(super) async fn to_transfer_transaction(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        safe: &str,
    ) -> ServiceTransfer {
        ServiceTransfer {
            sender: get_address_ex_from_any_source(safe, &self.from, info_provider).await,
            recipient: get_address_ex_from_any_source(safe, &self.to, info_provider).await,
            direction: get_transfer_direction(safe, &self.from, &self.to),
            transfer_info: self.to_transfer_info(info_provider).await,
        }
    }

    pub(super) async fn to_transfer_info(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> TransferInfo {
        let token_info =
            token_info_with_fallback(info_provider, &self.token_address, self.token_info.clone())
                .await;
        build_transfer_info(
            token_info.as_ref(),
            TokenType::Erc20,
            &self.token_address,
            &self.value,
        )
    }
}

impl Erc721TransferDto {
    pub(super) async fn to_transfer_transaction(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        safe: &str,
    ) -> ServiceTransfer {
        ServiceTransfer {
            sender: get_address_ex_from_any_source(safe, &self.from, info_provider).await,
            recipient: get_address_ex_from_any_source(safe, &self.to, info_provider).await,
            direction: get_transfer_direction(safe, &self.from, &self.to),
            transfer_info: self.to_transfer_info(info_provider).await,
        }
    }

    pub(super) async fn to_transfer_info(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> TransferInfo {
        let token_info =
            token_info_with_fallback(info_provider, &self.token_address, self.token_info.clone())
                .await;
        build_transfer_info(
            token_info.as_ref(),
            TokenType::Erc721,
            &self.token_address,
            &self.token_id,
        )
    }
}

impl EtherTransferDto {
    pub(super) async fn to_transfer_transaction(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        safe: &str,
    ) -> ServiceTransfer {
        ServiceTransfer {
            sender: get_address_ex_from_any_source(safe, &self.from, info_provider).await,
            recipient: get_address_ex_from_any_source(safe, &self.to, info_provider).await,
            direction: get_transfer_direction(safe, &self.from, &self.to),
            transfer_info: self.to_transfer_info(),
        }
    }

    pub(super) fn to_transfer_info(&self) -> TransferInfo {
        TransferInfo::NativeCoin(NativeCoinTransfer {
            value: self.value.clone(),
        })
    }
}

fn build_transfer_info(
    token_info: Option<&TokenInfo>,
    default_token_type: TokenType,
    token_address: &str,
    element: &str,
) -> TransferInfo {
    match token_info
        .map(|it| it.token_type.to_owned())
        .unwrap_or(default_token_type)
    {
        TokenType::Erc20 => TransferInfo::Erc20(Erc20Transfer {
            token_address: token_address.to_owned(),
            token_name: token_info.map(|it| it.name.to_owned()),
            token_symbol: token_info.map(|it| it.symbol.to_owned()),
            logo_uri: token_info.map(|it| it.logo_uri.to_owned()).flatten(),
            decimals: token_info.map(|it| it.decimals.to_owned()),
            value: element.to_owned(),
        }),
        TokenType::Erc721 => TransferInfo::Erc721(Erc721Transfer {
            token_address: token_address.to_owned(),
            token_id: element.to_owned(),
            token_name: token_info.map(|it| it.name.to_owned()),
            token_symbol: token_info.map(|it| it.symbol.to_owned()),
            logo_uri: token_info.map(|it| it.logo_uri.to_owned()).flatten(),
        }),
        _ => panic!("Transfer token type not supported"),
    }
}

async fn token_info_with_fallback(
    info_provider: &(impl InfoProvider + Sync),
    token_address: &str,
    token_info: Option<TokenInfo>,
) -> Option<TokenInfo> {
    if token_info.is_none() {
        info_provider.token_info(token_address).await.ok()
    } else {
        token_info
    }
}

'''
'''--- src/common/mod.rs ---
#[doc(hidden)]
pub mod converters;
pub mod models;

pub mod routes;
#[cfg(test)]
mod tests;

'''
'''--- src/common/models/addresses.rs ---
use crate::providers::info::InfoProvider;
use serde::Serialize;

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct AddressEx {
    pub value: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logo_uri: Option<String>,
}

impl AddressEx {
    pub fn zero() -> Self {
        AddressEx {
            value: "0x0000000000000000000000000000000000000000".to_owned(),
            name: None,
            logo_uri: None,
        }
    }

    pub fn address_only(address: &str) -> Self {
        AddressEx {
            value: address.to_owned(),
            name: None,
            logo_uri: None,
        }
    }

    pub async fn any_source(address: &str, info_provider: &(impl InfoProvider + Sync)) -> Self {
        info_provider
            .address_ex_from_any_source(address)
            .await
            .unwrap_or(AddressEx::address_only(address))
    }
}

'''
'''--- src/common/models/backend/about.rs ---
use serde::Deserialize;

#[derive(Deserialize, Debug)]
pub struct About {
    pub name: String,
    pub version: String,
    pub api_version: String,
    pub secure: bool,
    pub settings: SettingsDto,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub struct SettingsDto {
    ethereum_node_url: String,
    ethereum_tracing_node_url: String,
    eth_internal_txs_block_process_limit: Option<usize>,
    eth_reorg_blocks: usize,
    eth_uniswap_factory_address: String,
}

'''
'''--- src/common/models/backend/balances.rs ---
use serde::Deserialize;

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct Balance {
    pub token_address: Option<String>,
    pub token: Option<BalanceToken>,
    pub balance: String,
    pub fiat_balance: String,
    pub fiat_conversion: String,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct BalanceToken {
    pub name: String,
    pub symbol: String,
    pub decimals: u64,
    pub logo_uri: String,
}

'''
'''--- src/common/models/backend/balances_v2.rs ---
use bigdecimal::BigDecimal;
use serde::Deserialize;

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct Balance {
    pub token_address: Option<String>,
    pub token: Option<BalanceToken>,
    pub balance: String,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BalanceToken {
    pub name: String,
    pub symbol: String,
    pub decimals: u64,
    pub logo_uri: String,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TokenPrice {
    pub fiat_code: String,
    pub fiat_price: BigDecimal,
    pub timestamp: String,
}

'''
'''--- src/common/models/backend/chains.rs ---
use serde::Deserialize;

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ChainInfo {
    pub recommended_master_copy_version: String,
    pub transaction_service: String,
    pub vpc_transaction_service: String,
    pub chain_id: String,
    pub chain_name: String,
    pub short_name: String,
    pub l2: bool,
    pub description: String,
    pub rpc_uri: RpcUri,
    pub safe_apps_rpc_uri: RpcUri,
    pub public_rpc_uri: RpcUri,
    pub block_explorer_uri_template: BlockExplorerUriTemplate,
    pub native_currency: NativeCurrency,
    pub theme: Theme,
    pub ens_registry_address: Option<String>,
    pub gas_price: Vec<GasPrice>,
    pub disabled_wallets: Vec<String>,
    pub features: Vec<String>,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct NativeCurrency {
    pub name: String,
    pub symbol: String,
    pub decimals: u64,
    pub logo_uri: String,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Theme {
    pub text_color: String,
    pub background_color: String,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(tag = "type")]
#[serde(rename_all = "lowercase")]
pub enum GasPrice {
    #[serde(rename_all = "camelCase")]
    Oracle {
        uri: String,
        gas_parameter: String,
        gwei_factor: String,
    },
    #[serde(rename_all = "camelCase")]
    Fixed { wei_value: String },
    #[serde(other)]
    Unknown,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct RpcUri {
    pub authentication: RpcAuthentication,
    pub value: String,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum RpcAuthentication {
    ApiKeyPath,
    NoAuthentication,
    #[serde(other)]
    Unknown,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct BlockExplorerUriTemplate {
    pub address: String,
    pub tx_hash: String,
    pub api: String,
}

'''
'''--- src/common/models/backend/hooks.rs ---
use serde::Deserialize;

#[derive(Deserialize, Debug, Hash)]
#[serde(tag = "type")]
pub struct Payload {
    pub address: String,
    #[serde(rename(deserialize = "chainId"))]
    pub chain_id: String,
    #[serde(flatten)]
    pub details: Option<PayloadDetails>,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(tag = "type", rename_all = "SCREAMING_SNAKE_CASE")]
pub enum PayloadDetails {
    NewConfirmation(NewConfirmation),
    ExecutedMultisigTransaction(ExecutedMultisigTransaction),
    PendingMultisigTransaction(PendingMultisigTransaction),
    IncomingEther(IncomingEther),
    IncomingToken(IncomingToken),
    #[serde(other)]
    Unknown,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct NewConfirmation {
    pub owner: String,
    pub safe_tx_hash: String,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct ExecutedMultisigTransaction {
    pub safe_tx_hash: String,
    pub tx_hash: String,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct PendingMultisigTransaction {
    pub safe_tx_hash: String,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct IncomingEther {
    pub tx_hash: String,
    pub value: String,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct IncomingToken {
    pub tx_hash: String,
    pub token_address: String,
    pub token_id: Option<String>,
    pub value: Option<String>,
}

'''
'''--- src/common/models/backend/mod.rs ---
pub mod about;
pub mod balances;
pub mod balances_v2;
pub mod chains;
pub mod hooks;
pub mod notifications;
pub mod safe_apps;
pub mod safes;
pub mod transactions;
pub mod transfers;

'''
'''--- src/common/models/backend/notifications.rs ---
use crate::routes::notifications::models::DeviceData;
use serde::Serialize;

#[derive(Serialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct NotificationRegistrationRequest {
    #[serde(flatten)]
    pub notification_device_data: DeviceData,
    pub safes: Vec<String>,
    pub signatures: Vec<String>,
}

'''
'''--- src/common/models/backend/safe_apps.rs ---
use serde::Deserialize;

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SafeApp {
    pub id: u64,
    pub url: String,
    pub name: String,
    pub icon_url: String,
    pub description: String,
    pub chain_ids: Vec<u64>,
    pub provider: Option<SafeAppProvider>,
    pub access_control: SafeAppAccessControlPolicies,
    // We set this value as a default since this feature might not be enabled yet. See SAFE_APPS_TAGS_FEATURE_ENABLED
    #[serde(default)]
    pub tags: Vec<String>,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SafeAppProvider {
    pub url: String,
    pub name: String,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(tag = "type")]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum SafeAppAccessControlPolicies {
    NoRestrictions,
    DomainAllowlist(SafeAppDomainAllowlistPolicy),
    #[serde(other)]
    Unknown,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SafeAppDomainAllowlistPolicy {
    pub value: Vec<String>,
}

'''
'''--- src/common/models/backend/safes.rs ---
use serde::Deserialize;

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MasterCopy {
    pub address: String,
    pub version: String,
    pub deployer: String,
    pub deployed_block_number: u64,
    pub last_indexed_block_number: u64,
}

'''
'''--- src/common/models/backend/transactions.rs ---
use crate::common::models::backend::transfers::Transfer;
use crate::common::models::data_decoded::{DataDecoded, Operation};
use chrono::{DateTime, Utc};
use serde::Deserialize;

#[derive(Deserialize, Debug)]
#[serde(tag = "txType")]
pub enum Transaction {
    #[serde(rename(deserialize = "MULTISIG_TRANSACTION"))]
    Multisig(MultisigTransaction),
    #[serde(rename(deserialize = "ETHEREUM_TRANSACTION"))]
    Ethereum(EthereumTransaction),
    #[serde(rename(deserialize = "MODULE_TRANSACTION"))]
    Module(ModuleTransaction),
    #[serde(other)]
    Unknown,
}

#[derive(Deserialize, Debug, PartialEq, Hash)]
#[serde(rename_all = "camelCase")]
pub struct SafeTransaction {
    pub safe: String,
    pub to: String,
    pub value: Option<String>,
    pub data: Option<String>,
    pub data_decoded: Option<DataDecoded>,
    pub operation: Operation,
}

#[derive(Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct MultisigTransaction {
    #[serde(flatten)]
    pub safe_transaction: SafeTransaction,
    pub gas_token: Option<String>,
    pub safe_tx_gas: Option<usize>,
    pub base_gas: Option<usize>,
    pub gas_price: Option<String>,
    pub refund_receiver: Option<String>,
    pub nonce: u64,
    pub execution_date: Option<DateTime<Utc>>,
    pub submission_date: DateTime<Utc>,
    pub modified: Option<DateTime<Utc>>,
    pub block_number: Option<u64>,
    pub transaction_hash: Option<String>,
    pub safe_tx_hash: String,
    pub executor: Option<String>,
    pub is_executed: bool,
    pub is_successful: Option<bool>,
    pub eth_gas_price: Option<String>,
    pub gas_used: Option<usize>,
    pub fee: Option<String>,
    pub origin: Option<String>,
    pub confirmations_required: Option<u64>,
    pub confirmations: Option<Vec<Confirmation>>,
    pub signatures: Option<String>,
    pub trusted: bool,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct EthereumTransaction {
    pub execution_date: DateTime<Utc>,
    pub data: Option<String>,
    pub tx_hash: String,
    pub block_number: u64,
    pub transfers: Option<Vec<Transfer>>,
    pub from: String,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct ModuleTransaction {
    #[serde(flatten)]
    pub safe_transaction: SafeTransaction,
    pub created: String,
    pub execution_date: DateTime<Utc>,
    pub block_number: u64,
    pub is_successful: bool,
    pub transaction_hash: String,
    pub module: String,
    // pub transfers: Option<Vec<Transfer>>,
}

#[derive(Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Confirmation {
    pub owner: String,
    pub submission_date: DateTime<Utc>,
    pub transaction_hash: Option<String>,
    pub signature_type: String,
    pub signature: Option<String>,
}

#[derive(Deserialize, Debug, Hash)]
#[serde(rename_all = "camelCase")]
pub struct CreationTransaction {
    pub created: DateTime<Utc>,
    pub creator: String,
    pub transaction_hash: String,
    pub factory_address: Option<String>,
    pub master_copy: Option<String>,
    pub setup_data: Option<String>,
    pub data_decoded: Option<DataDecoded>,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct SafeTransactionEstimation {
    pub safe_tx_gas: String,
}

'''
'''--- src/common/models/backend/transfers.rs ---
use crate::providers::info::TokenInfo;
use chrono::{DateTime, Utc};
use derivative::Derivative;
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone, Hash)]
#[serde(tag = "type")]
pub enum Transfer {
    #[serde(rename(deserialize = "ERC721_TRANSFER"))]
    Erc721(Erc721Transfer),
    #[serde(rename(deserialize = "ERC20_TRANSFER"))]
    Erc20(Erc20Transfer),
    #[serde(rename(deserialize = "ETHER_TRANSFER"))]
    Ether(EtherTransfer),
    #[serde(other)]
    Unknown,
}

#[derive(Derivative, Deserialize, Debug, PartialEq, Clone)]
#[derivative(Hash)]
#[serde(rename_all = "camelCase")]
pub struct Erc721Transfer {
    pub execution_date: DateTime<Utc>,
    pub block_number: u64,
    pub transaction_hash: String,
    pub to: String,
    pub token_id: String,
    pub token_address: String,
    #[derivative(Hash = "ignore")]
    pub token_info: Option<TokenInfo>,
    pub from: String,
}

#[derive(Derivative, Deserialize, Debug, Clone)]
#[derivative(Hash)]
#[serde(rename_all = "camelCase")]
pub struct Erc20Transfer {
    pub execution_date: DateTime<Utc>,
    pub block_number: u64,
    pub transaction_hash: String,
    pub to: String,
    pub value: String,
    pub token_address: String,
    #[derivative(Hash = "ignore")]
    pub token_info: Option<TokenInfo>,
    pub from: String,
}

#[derive(Derivative, Deserialize, Debug, Clone)]
#[derivative(Hash)]
#[serde(rename_all = "camelCase")]
pub struct EtherTransfer {
    pub execution_date: DateTime<Utc>,
    pub block_number: u64,
    pub transaction_hash: String,
    pub to: String,
    pub value: String,
    pub from: String,
}

'''
'''--- src/common/models/data_decoded.rs ---
use crate::utils::json;
use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};

#[derive(Serialize_repr, Deserialize_repr, PartialEq, Debug, Clone, Copy, Hash)]
#[repr(u8)]
pub enum Operation {
    CALL = 0,
    DELEGATE = 1,
}

#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct DataDecoded {
    pub method: String,
    pub parameters: Option<Vec<Parameter>>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Parameter {
    pub name: String,
    #[serde(rename = "type")]
    pub param_type: String,
    pub value: ParamValue,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(deserialize_with = "json::try_deserialize")]
    #[serde(default)]
    pub value_decoded: Option<ValueDecodedType>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq)]
#[serde(untagged)]
pub enum ParamValue {
    SingleValue(String),
    ArrayValue(Vec<ParamValue>),
}

#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq)]
#[serde(untagged)]
pub enum ValueDecodedType {
    InternalTransaction(Vec<InternalTransaction>),
}

#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct InternalTransaction {
    pub operation: Operation,
    pub to: String, // TODO: Address that will not be mapped to AddressEx for now
    pub value: Option<String>,
    pub data: Option<String>,
    pub data_decoded: Option<DataDecoded>,
}

impl From<String> for ParamValue {
    fn from(item: String) -> Self {
        ParamValue::SingleValue(item)
    }
}

'''
'''--- src/common/models/mod.rs ---
pub mod addresses;
#[doc(hidden)]
pub mod backend;
pub mod data_decoded;
pub mod page;

'''
'''--- src/common/models/page.rs ---
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(PartialEq))]
pub struct Page<T> {
    pub next: Option<String>,
    pub previous: Option<String>,
    pub results: Vec<T>,
}

#[derive(Debug, PartialEq)]
pub struct PageMetadata {
    pub offset: u64,
    pub limit: u64,
}

#[derive(Serialize, Deserialize, Debug)]
#[cfg_attr(test, derive(PartialEq))]
pub struct SafeList {
    safes: Vec<String>,
}

impl<T> Page<T> {
    pub fn map_inner<U>(self, link_mapper: impl Fn(Option<String>) -> Option<String>) -> Page<U>
    where
        U: From<T>,
    {
        Page {
            next: link_mapper(self.next),
            previous: link_mapper(self.previous),
            results: self.results.into_iter().map(|it| U::from(it)).collect(),
        }
    }
}

'''
'''--- src/common/routes/authorization.rs ---
use crate::config::webhook_token;
use rocket::http::Status;
use rocket::request::{FromRequest, Outcome};
use rocket::Request;

pub struct AuthorizationToken {
    value: String,
}

#[derive(Debug)]
pub enum AuthorizationError {
    Missing,
    Invalid,
}

#[rocket::async_trait]
impl<'r> FromRequest<'r> for AuthorizationToken {
    type Error = AuthorizationError;

    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error> {
        match request.headers().get_one("Authorization") {
            // Require the header to be present
            None => Outcome::Failure((Status::BadRequest, AuthorizationError::Missing)),
            Some(key) if key == format!("Basic {}", webhook_token()) => {
                Outcome::Success(AuthorizationToken {
                    value: key.to_string(),
                })
            }
            // If the Authorization header didn't match with "Basic <token>" we consider it to be
            // an invalid token
            Some(_) => Outcome::Failure((Status::Unauthorized, AuthorizationError::Invalid)),
        }
    }
}

'''
'''--- src/common/routes/mod.rs ---
pub mod authorization;

'''
'''--- src/common/tests/common.rs ---
use crate::common::models::data_decoded::{
    DataDecoded, InternalTransaction, Operation, ParamValue, Parameter, ValueDecodedType,
};
use crate::tests::json;

#[test]
fn deserialise_params_value_as_string() {
    let json = r#"
    {
        "name": "_threshold",
        "type": "uint256",
        "value": "2"
    }
    "#;

    let actual = serde_json::from_str::<Parameter>(json);

    let expected = Parameter {
        name: "_threshold".to_string(),
        param_type: "uint256".to_string(),
        value: "2".to_string().into(),
        value_decoded: None,
    };

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn deserialise_params_value_as_array() {
    let json = r#"
    {
        "name": "_owners",
        "type": "address[]",
        "value": [
            "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
            "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
        ]
    }
    "#;

    let actual = serde_json::from_str::<Parameter>(json);

    let expected = Parameter {
        name: "_owners".to_string(),
        param_type: "address[]".to_string(),
        value_decoded: None,
        value: ParamValue::ArrayValue(vec![
            "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
                .to_string()
                .into(),
            "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
                .to_string()
                .into(),
        ]),
    };

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn deserialize_decoded_value() {
    let actual = serde_json::from_str::<DataDecoded>(json::DATA_DECODED_MULTI_SEND).unwrap();

    let expected = DataDecoded {
        method: "multiSend".to_string(),
        parameters: Some(vec![
            Parameter {
                name: String::from("transactions"),
                param_type: String::from("bytes"),
                value: ParamValue::SingleValue(String::from("0x00d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c6800000d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c6800000d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000")),
                value_decoded: Some(ValueDecodedType::InternalTransaction(vec![
                    InternalTransaction {
                        operation: Operation::CALL,
                        to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
                        value: Some(0.to_string()),
                        data: Some(String::from("0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000")),
                        data_decoded: Some(DataDecoded {
                            method: String::from("transfer"),
                            parameters: Some(vec![
                                Parameter {
                                    name: String::from("to"),
                                    param_type: String::from("address"),
                                    value: ParamValue::SingleValue(String::from("0x938bae50a210b80EA233112800Cd5Bc2e7644300")),
                                    value_decoded: None,
                                },
                                Parameter {
                                    name: String::from("value"),
                                    param_type: String::from("uint256"),
                                    value: ParamValue::SingleValue(String::from("1000000000000000")),
                                    value_decoded: None,
                                },
                            ]),
                        }),
                    },
                    InternalTransaction {
                        operation: Operation::CALL,
                        to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
                        value: Some(0.to_string()),
                        data: Some(String::from("0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000")),
                        data_decoded: Some(DataDecoded {
                            method: String::from("transfer"),
                            parameters: Some(vec![
                                Parameter {
                                    name: String::from("to"),
                                    param_type: String::from("address"),
                                    value: ParamValue::SingleValue(String::from("0x938bae50a210b80EA233112800Cd5Bc2e7644300")),
                                    value_decoded: None,
                                },
                                Parameter {
                                    name: String::from("value"),
                                    param_type: String::from("uint256"),
                                    value: ParamValue::SingleValue(String::from("1000000000000000")),
                                    value_decoded: None,
                                },
                            ]),
                        }),
                    },
                    InternalTransaction {
                        operation: Operation::CALL,
                        to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
                        value: Some(0.to_string()),
                        data: Some(String::from("0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000")),
                        data_decoded: Some(DataDecoded {
                            method: String::from("transfer"),
                            parameters: Some(vec![
                                Parameter {
                                    name: String::from("to"),
                                    param_type: String::from("address"),
                                    value: ParamValue::SingleValue(String::from("0x938bae50a210b80EA233112800Cd5Bc2e7644300")),
                                    value_decoded: None,
                                },
                                Parameter {
                                    name: String::from("value"),
                                    param_type: String::from("uint256"),
                                    value: ParamValue::SingleValue(String::from("1000000000000000")),
                                    value_decoded: None,
                                },
                            ]),
                        }),
                    }
                ])),
            },
        ]),
    };

    assert_eq!(actual, expected);
}

'''
'''--- src/common/tests/mod.rs ---
mod common;

'''
'''--- src/config/mod.rs ---
use std::env;
use std::str::FromStr;

#[cfg(test)]
mod tests;

pub fn redis_uri() -> String {
    env::var("REDIS_URI").expect("REDIS_URI missing in env")
}

pub fn redis_uri_mainnet() -> String {
    env::var("REDIS_URI_MAINNET").expect("REDIS_URI_MAINNET missing in env")
}

pub fn base_config_service_uri() -> String {
    format!(
        "{}{}",
        env::var("CONFIG_SERVICE_URI").expect("CONFIG_SERVICE_URI missing in env"),
        "/api"
    )
}

pub fn base_exchange_api_uri() -> String {
    format!(
        "{}?access_key={}",
        env::var("EXCHANGE_API_BASE_URI").unwrap(),
        env::var("EXCHANGE_API_KEY").unwrap()
    )
}

pub fn webhook_token() -> String {
    env::var("WEBHOOK_TOKEN").expect("WEBHOOK_TOKEN missing in env")
}

pub fn scheme() -> String {
    env_with_default("SCHEME", "https".into())
}

// TIME DURATION VALUES
fn indefinite_timeout() -> usize {
    env_with_default("INDEFINITE_TIMEOUT", 60 * 60 * 1000)
}

pub fn short_error_duration() -> usize {
    env_with_default("SHORT_ERROR_DURATION", 60 * 1000)
}

pub fn long_error_duration() -> usize {
    env_with_default("LONG_ERROR_DURATION", 60 * 15 * 1000)
}

// FUNCTIONAL TIMEOUTS
pub fn safe_info_cache_duration() -> usize {
    env_with_default("SAFE_INFO_CACHE_DURATION", indefinite_timeout())
}

pub fn address_info_cache_duration() -> usize {
    env_with_default("ADDRESS_INFO_CACHE_DURATION", indefinite_timeout())
}

pub fn token_info_cache_duration() -> usize {
    env_with_default("TOKEN_INFO_CACHE_DURATION", 60 * 60 * 24 * 1000)
}

pub fn chain_info_cache_duration() -> usize {
    env_with_default("CHAIN_INFO_CACHE_DURATION", indefinite_timeout())
}

pub fn chain_info_response_cache_duration() -> usize {
    env_with_default("CHAIN_INFO_RESPONSE_CACHE_DURATION", 1) // set to negligible value
}

pub fn exchange_api_cache_duration() -> usize {
    env_with_default("EXCHANGE_API_CACHE_DURATION", 60 * 60 * 12 * 1000)
}

pub fn request_cache_duration() -> usize {
    env_with_default("REQUEST_CACHE_DURATION", indefinite_timeout())
}

pub fn about_cache_duration() -> usize {
    env_with_default("ABOUT_CACHE_DURATION", 60 * 15 * 1000)
}

pub fn balances_cache_duration() -> usize {
    env_with_default("BALANCES_REQUEST_CACHE_DURATION", 60 * 1000)
}

pub fn balances_core_request_cache_duration() -> usize {
    env_with_default("BALANCES_CORE_REQUEST_CACHE_DURATION", indefinite_timeout())
}

pub fn owners_for_safes_cache_duration() -> usize {
    env_with_default("OWNERS_FOR_SAFES_CACHE_DURATION", 60 * 1000)
}

pub fn safe_apps_cache_duration() -> usize {
    env_with_default("SAFE_APPS_CACHE_DURATION", indefinite_timeout())
}

pub fn token_price_cache_duration() -> usize {
    env_with_default("TOKEN_PRICE_CACHE_DURATION", 10 * 1000)
}

pub fn tx_queued_cache_duration() -> usize {
    env_with_default("TX_QUEUED_CACHE_DURATION", request_cache_duration())
}

// REQUEST TIMEOUTS
pub fn internal_client_connect_timeout() -> u64 {
    env_with_default("INTERNAL_CLIENT_CONNECT_TIMEOUT", 1000)
}

pub fn safe_app_info_request_timeout() -> u64 {
    env_with_default("SAFE_APP_INFO_REQUEST_TIMEOUT", 3000)
}

pub fn transaction_request_timeout() -> u64 {
    env_with_default("TRANSACTION_REQUEST_TIMEOUT", 30000)
}

pub fn safe_info_request_timeout() -> u64 {
    env_with_default("SAFE_INFO_REQUEST_TIMEOUT", 10000)
}

pub fn token_info_request_timeout() -> u64 {
    env_with_default("TOKEN_INFO_REQUEST_TIMEOUT", 15000)
}

pub fn chain_info_request_timeout() -> u64 {
    env_with_default("CHAIN_INFO_REQUEST_TIMEOUT", 15000)
}

pub fn contract_info_request_timeout() -> u64 {
    env_with_default("CONTRACT_INFO_REQUEST_TIMEOUT", 3000)
}

pub fn balances_request_timeout() -> u64 {
    env_with_default("BALANCES_REQUEST_TIMEOUT", 20000)
}

pub fn collectibles_request_timeout() -> u64 {
    env_with_default("COLLECTIBLES_REQUEST_TIMEOUT", 20000)
}

pub fn default_request_timeout() -> u64 {
    env_with_default("DEFAULT_REQUEST_TIMEOUT", 10000)
}

// ERRORS
pub fn request_error_cache_duration() -> usize {
    env_with_default("REQS_ERROR_CACHE_DURATION", short_error_duration())
}

pub fn log_all_error_responses() -> bool {
    env_with_default("LOG_ALL_ERROR_RESPONSES", false)
}

// OTHERS
pub fn redis_scan_count() -> usize {
    env_with_default("REDIS_SCAN_COUNT", 300)
}

pub fn token_cache_size_count() -> usize {
    env_with_default("TOKEN_CACHE_SIZE_COUNT", 20000)
}

pub fn feature_flag_nested_decoding() -> bool {
    env_with_default("FEATURE_FLAG_NESTED_DECODING", true)
}

pub fn feature_flag_balances_rate_implementation() -> bool {
    env_with_default("FEATURE_FLAG_BALANCES_RATE_IMPLEMENTATION", false)
}

pub fn is_messages_feature_enabled() -> bool {
    env_with_default("FEATURE_MESSAGES", false)
}

pub fn is_preview_endpoint_enabled() -> bool {
    env_with_default("FEATURE_PREVIEW_ENDPOINT", false)
}

pub fn is_safe_apps_tags_feature_enabled() -> bool {
    env_with_default("SAFE_APPS_TAGS_FEATURE_ENABLED", false)
}

pub fn vpc_transaction_service_uri() -> bool {
    env_with_default("VPC_TRANSACTION_SERVICE_URI", true)
}

pub fn concurrent_balance_token_requests() -> usize {
    env_with_default("CONCURRENT_BALANCE_TOKEN_REQUESTS", 5)
}

pub fn log_threshold() -> f32 {
    env_with_default("LOG_THRESHOLD", 1.0)
}

pub fn build_number() -> Option<String> {
    option_env!("BUILD_NUMBER").map(|it| it.to_string())
}

pub fn version() -> String {
    option_env!("VERSION")
        .unwrap_or(env!("CARGO_PKG_VERSION"))
        .to_string()
}

fn env_with_default<T: FromStr>(key: &str, default: T) -> T
where
    <T as FromStr>::Err: std::fmt::Debug,
{
    match env::var(key) {
        Ok(value) => value
            .parse()
            .expect(&format!("Parsing of {} env var key failed", &key)),
        Err(_) => default,
    }
}

'''
'''--- src/config/tests/mod.rs ---
#[test]
fn test_env() {
    for test_case in build_usize_test_cases() {
        test_case.assert_default();
        test_case.assert_env_key();
    }

    for test_case in build_u64_test_cases() {
        test_case.assert_default();
        test_case.assert_env_key();
    }
}

fn build_usize_test_cases() -> Vec<USizeEnvValue> {
    vec![
        USizeEnvValue {
            expected_default: 60 * 60 * 1000,
            env_key: String::from("SAFE_INFO_CACHE_DURATION"),
            generator: Box::new(super::safe_info_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 60 * 1000,
            env_key: String::from("ADDRESS_INFO_CACHE_DURATION"),
            generator: Box::new(super::address_info_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 60 * 24 * 1000,
            env_key: String::from("TOKEN_INFO_CACHE_DURATION"),
            generator: Box::new(super::token_info_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 60 * 1000,
            env_key: String::from("CHAIN_INFO_CACHE_DURATION"),
            generator: Box::new(super::chain_info_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 60 * 12 * 1000,
            env_key: String::from("EXCHANGE_API_CACHE_DURATION"),
            generator: Box::new(super::exchange_api_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 60 * 1000,
            env_key: String::from("REQUEST_CACHE_DURATION"),
            generator: Box::new(super::request_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 15 * 1000,
            env_key: String::from("ABOUT_CACHE_DURATION"),
            generator: Box::new(super::about_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 1000,
            env_key: String::from("BALANCES_REQUEST_CACHE_DURATION"),
            generator: Box::new(super::balances_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 1000,
            env_key: String::from("OWNERS_FOR_SAFES_CACHE_DURATION"),
            generator: Box::new(super::owners_for_safes_cache_duration),
        },
        USizeEnvValue {
            expected_default: 60 * 60 * 1000,
            env_key: String::from("BALANCES_CORE_REQUEST_CACHE_DURATION"),
            generator: Box::new(super::balances_core_request_cache_duration),
        },
        USizeEnvValue {
            expected_default: 10 * 1000,
            env_key: String::from("TOKEN_PRICE_CACHE_DURATION"),
            generator: Box::new(super::token_price_cache_duration),
        },
        USizeEnvValue {
            expected_default: super::request_cache_duration(),
            env_key: String::from("TX_QUEUED_CACHE_DURATION"),
            generator: Box::new(super::tx_queued_cache_duration),
        },
        USizeEnvValue {
            expected_default: super::token_cache_size_count(),
            env_key: String::from("TOKEN_CACHE_SIZE_COUNT"),
            generator: Box::new(super::token_cache_size_count),
        },
    ]
}

fn build_u64_test_cases() -> Vec<U64EnvValue> {
    vec![
        U64EnvValue {
            expected_default: 1000,
            env_key: String::from("INTERNAL_CLIENT_CONNECT_TIMEOUT"),
            generator: Box::new(super::internal_client_connect_timeout),
        },
        U64EnvValue {
            expected_default: 3000,
            env_key: String::from("SAFE_APP_INFO_REQUEST_TIMEOUT"),
            generator: Box::new(super::safe_app_info_request_timeout),
        },
        U64EnvValue {
            expected_default: 30000,
            env_key: String::from("TRANSACTION_REQUEST_TIMEOUT"),
            generator: Box::new(super::transaction_request_timeout),
        },
        U64EnvValue {
            expected_default: 10000,
            env_key: String::from("SAFE_INFO_REQUEST_TIMEOUT"),
            generator: Box::new(super::safe_info_request_timeout),
        },
        U64EnvValue {
            expected_default: 15000,
            env_key: String::from("TOKEN_INFO_REQUEST_TIMEOUT"),
            generator: Box::new(super::token_info_request_timeout),
        },
        U64EnvValue {
            expected_default: 3000,
            env_key: String::from("CONTRACT_INFO_REQUEST_TIMEOUT"),
            generator: Box::new(super::contract_info_request_timeout),
        },
        U64EnvValue {
            expected_default: 20000,
            env_key: String::from("BALANCES_REQUEST_TIMEOUT"),
            generator: Box::new(super::balances_request_timeout),
        },
        U64EnvValue {
            expected_default: 20000,
            env_key: String::from("COLLECTIBLES_REQUEST_TIMEOUT"),
            generator: Box::new(super::collectibles_request_timeout),
        },
        U64EnvValue {
            expected_default: 10000,
            env_key: String::from("DEFAULT_REQUEST_TIMEOUT"),
            generator: Box::new(super::default_request_timeout),
        },
    ]
}

trait TestCase {
    fn assert_default(&self);
    fn assert_env_key(&self);
}

struct USizeEnvValue {
    expected_default: usize,
    env_key: String,
    generator: Box<dyn Fn() -> usize>,
}

impl TestCase for USizeEnvValue {
    fn assert_default(&self) {
        std::env::remove_var(&self.env_key);
        let actual_default = (&self.generator)();
        assert_eq!(
            self.expected_default, actual_default,
            "Test default value for env key: {}",
            &self.env_key
        );
    }

    fn assert_env_key(&self) {
        let mock_env_var_value = 1;
        std::env::set_var(&self.env_key, &mock_env_var_value.to_string());
        let actual_env = (&self.generator)();
        std::env::remove_var(&self.env_key);
        assert_eq!(
            mock_env_var_value, actual_env,
            "Test env var for env key: {}",
            &self.env_key
        );
    }
}

struct U64EnvValue {
    expected_default: u64,
    env_key: String,
    generator: Box<dyn Fn() -> u64>,
}

impl TestCase for U64EnvValue {
    fn assert_default(&self) {
        std::env::remove_var(&self.env_key);
        let actual_default = (&self.generator)();
        assert_eq!(
            self.expected_default, actual_default,
            "Test default value for env key: {}",
            &self.env_key
        );
    }

    fn assert_env_key(&self) {
        let mock_env_var_value = 1;
        std::env::set_var(&self.env_key, &mock_env_var_value.to_string());
        let actual_env = (&self.generator)();
        std::env::remove_var(&self.env_key);
        assert_eq!(
            mock_env_var_value, actual_env,
            "Test env var for env key: {}",
            &self.env_key
        );
    }
}

'''
'''--- src/macros.rs ---
use crate::common::models::backend::chains::ChainInfo;
use crate::config::vpc_transaction_service_uri;
macro_rules! concat_parts {
    ($parts_head:expr) => {
        // `stringify!` will convert the expression *as it is* into a string.
        format!(
            "{}{}",
            $crate::routes::transactions::models::ID_SEPARATOR,
            $parts_head
        )
    };
    ($parts_head:expr, $($parts_tail:expr),+) => {
        // `stringify!` will convert the expression *as it is* into a string.
        format!(
            "{}{}{}",
            $crate::routes::transactions::models::ID_SEPARATOR,
            $parts_head,
            concat_parts!($($parts_tail),+)
        )
    };
}

macro_rules! create_id {
    ($tx_type:expr, $($parts:expr),+) => {
        // `stringify!` will convert the expression *as it is* into a string.
        format!("{}{}", $tx_type, concat_parts!($($parts),+))
    };
}

macro_rules! bail {
    ($msg:literal $(,)?) => {
        return Err($crate::api_error!($msg))
    };
    ($fmt:expr, $($arg:tt)*) => {
        return Err($crate::api_error!($fmt, $($arg)*))
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! api_error {
    ($msg:literal $(,)?) => {
        // Handle $:literal as a special case to make cargo-expanded code more
        // concise in the common case.
        $crate::utils::errors::ApiError::new_from_message($msg)
    };
    ($fmt:expr, $($arg:tt)*) => {
        $crate::utils::errors::ApiError::new_from_message(format!($fmt, $($arg)*))
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! client_error {
    ($status_code:expr, $message:expr) => {
        $crate::utils::errors::ApiError::new_from_message_with_code($status_code, format!($message))
    };
}

macro_rules! to_hex_string {
    ($input:expr) => {{
        let mut output = String::new();
        for byte in $input.iter() {
            output.push_str(&format!("{:02x?}", byte)) // uppercase x is for uppercase hex char.
        }
        format!("0x{}", output)
    }};
}

pub fn get_transaction_service_host(chain_info: ChainInfo) -> String {
    if vpc_transaction_service_uri() {
        chain_info.vpc_transaction_service
    } else {
        chain_info.transaction_service
    }
}

#[doc(hidden)]
#[macro_export]
macro_rules! core_uri {
    ($info_provider:tt, $path:expr) => {{
        let result: ApiResult<String> =
        match $info_provider.chain_info().await {
            Ok(chain_info) => Ok(format!("{}/api{}", crate::macros::get_transaction_service_host(chain_info), $path)),
            Err(error) => Err(error,)
        };
        result
    }};
    ($info_provider:tt, $path:literal, $($arg:tt)*) => {{
        let full_path: String = format!($path, $($arg)*);
        core_uri!($info_provider, full_path)
    }};
}

#[doc(hidden)]
#[macro_export]
macro_rules! config_uri {
    ($path:expr) => {{
        format!("{}{}", $crate::config::base_config_service_uri(), $path)
    }};
    ($path:literal, $($arg:tt)*) => {{
        let full_path: String = format!($path, $($arg)*);
        config_uri!(full_path)
    }};
}

'''
'''--- src/main.rs ---
#![deny(unused_must_use)]
#![deny(rustdoc::broken_intra_doc_links)]

#[macro_use]
extern crate rocket;

use std::sync::Arc;

use dotenv::dotenv;
use rocket::{Build, Rocket};

use routes::active_routes;
use utils::cors::CORS;

use crate::cache::manager::{create_cache_manager, RedisCacheManager};
use crate::routes::error_catchers;
use crate::utils::http_client::{setup_http_client, HttpClient};
use rocket_okapi::swagger_ui::{make_swagger_ui, SwaggerUIConfig};

#[doc(hidden)]
#[macro_use]
pub mod macros;

#[doc(hidden)]
mod cache;
mod common;
#[doc(hidden)]
mod config;

#[doc(hidden)]
mod monitoring;
mod providers;

/// Collection of all endpoints all endpoints
mod routes;
#[doc(hidden)]
mod utils;

#[cfg(test)]
mod tests;

#[doc(hidden)]
#[launch]
async fn rocket() -> Rocket<Build> {
    dotenv().ok();
    setup_logger();

    let client = setup_http_client();
    let cache_manager = create_cache_manager().await;

    rocket::build()
        .mount("/", active_routes())
        .mount(
            "/",
            make_swagger_ui(&SwaggerUIConfig {
                url: "../openapi.json".to_owned(),
                ..Default::default()
            }),
        )
        .register("/", error_catchers())
        .manage(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>)
        .manage(Arc::new(client) as Arc<dyn HttpClient>)
        .attach(monitoring::performance::PerformanceMonitor())
        .attach(CORS())
}

#[cfg(test)]
fn setup_logger() {
    // noop: no need to set the logger for tests
}

#[doc(hidden)]
#[cfg(not(test))]
fn setup_logger() {
    env_logger::init();
}

'''
'''--- src/monitoring/mod.rs ---
pub mod performance;

#[cfg(test)]
mod tests;

'''
'''--- src/monitoring/performance.rs ---
use crate::config;
use chrono::Utc;
use rocket::fairing::{Fairing, Info, Kind};
use rocket::http::uri::Path;
use rocket::{Data, Request, Response};

pub struct PerformanceMonitor();

#[rocket::async_trait]
impl Fairing for PerformanceMonitor {
    fn info(&self) -> Info {
        Info {
            name: "PerformanceMonitor",
            kind: Kind::Request | Kind::Response,
        }
    }

    async fn on_request(&self, request: &mut Request<'_>, _data: &mut Data<'_>) {
        request.local_cache(|| Utc::now().timestamp_millis());
    }

    async fn on_response<'r>(&self, request: &'r Request<'_>, response: &mut Response<'r>) {
        if rand::random::<f32>() <= config::log_threshold() {
            let request_path = request.uri().path();

            let chain_id = extract_chain_id(&request_path);

            let route = request
                .route()
                .map(|route| route.uri.to_string())
                .unwrap_or(request.uri().path().to_string());
            let cached = request
                .local_cache(|| Utc::now().timestamp_millis())
                .to_owned();
            let method = request.method().as_str();
            let status_code = response.status().code;
            let delta = Utc::now().timestamp_millis() - cached;
            log::info!(
                "MT::{}::{}::{}::{}::{}::{}",
                method,
                route,
                delta,
                status_code,
                request.uri().to_string(), // full path with query params
                chain_id
            );
        }
    }
}

pub(super) fn extract_chain_id(path: &Path) -> String {
    let chain_id = path.segments().get(2);
    let contains_chains = path.segments().get(1).map_or(false, |it| it == "chains");
    if contains_chains && chain_id.is_some() {
        chain_id.unwrap().to_string()
    } else {
        String::from("-1")
    }
}

'''
'''--- src/monitoring/tests/mod.rs ---
mod path_patterns;

'''
'''--- src/monitoring/tests/path_patterns.rs ---
use crate::monitoring::performance::extract_chain_id;

#[test]
fn chain_dependent_endpoint() {
    let uri = uri!("/v1/chains/1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b");
    let actual = extract_chain_id(&uri.path());

    assert_eq!("1", actual);
}

#[test]
fn chain_info_endpoint_single() {
    let uri = uri!("/v1/chains/1337");
    let actual = extract_chain_id(&uri.path());

    assert_eq!("1337", actual);
}

#[test]
fn chain_info_all() {
    let uri = uri!("/v1/chains");

    let actual = extract_chain_id(&uri.path());
    assert_eq!("-1", actual);
}

#[test]
fn chain_independent_endpoint() {
    let uri = uri!("/about/redis/");

    let actual = extract_chain_id(&uri.path());
    assert_eq!("-1", actual);
}

'''
'''--- src/providers/address_info.rs ---
use crate::utils::json::default_if_null;
use serde::{Deserialize, Serialize};
use serde_json::value::Value;

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(PartialEq))]
pub struct ContractInfo {
    pub address: String,
    #[serde(deserialize_with = "default_if_null")]
    pub name: String,
    #[serde(deserialize_with = "default_if_null")]
    pub display_name: String,
    pub logo_uri: Option<String>,
    pub contract_abi: Option<Value>,
    pub trusted_for_delegate_call: bool,
}

'''
'''--- src/providers/ext.rs ---
use crate::common::models::addresses::AddressEx;
use crate::providers::info::{InfoProvider, TokenInfo};
use rocket::futures::future::OptionFuture;

// Using the pattern here:
// use rocket::futures::stream::StreamExt;
impl<T: ?Sized> InfoProviderExt for T where T: InfoProvider {}

#[rocket::async_trait]
pub trait InfoProviderExt: InfoProvider {
    async fn address_to_token_info(&self, address: &Option<String>) -> Option<TokenInfo> {
        let address = address.as_ref()?;
        self.token_info(address).await.ok()
    }

    async fn address_ex_from_contracts_or_default(&self, address: &String) -> AddressEx {
        self.address_ex_from_contracts(&address)
            .await
            .unwrap_or(AddressEx::address_only(address))
    }

    async fn multiple_address_ex_from_contracts(
        &self,
        addresses: &Option<Vec<String>>,
    ) -> Option<Vec<AddressEx>> {
        let addresses = addresses.as_ref()?;
        if addresses.is_empty() {
            return None;
        }
        let mut results = Vec::with_capacity(addresses.len());
        for address in addresses {
            results.push(self.address_ex_from_contracts_or_default(address).await)
        }
        Some(results)
    }

    async fn address_ex_from_contracts_optional(&self, address: &String) -> Option<AddressEx> {
        if address != "0x0000000000000000000000000000000000000000" {
            Some(self.address_ex_from_contracts_or_default(address).await)
        } else {
            None
        }
    }

    async fn optional_address_ex_from_contracts(
        &self,
        address: &Option<String>,
    ) -> Option<AddressEx> {
        OptionFuture::from(
            address.as_ref().map(|address| async move {
                self.address_ex_from_contracts_or_default(address).await
            }),
        )
        .await
    }
}

'''
'''--- src/providers/fiat.rs ---
use std::collections::HashMap;
use std::sync::Arc;

use bigdecimal::BigDecimal;
use serde::Deserialize;

use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::cache::Cache;
use crate::config::{base_exchange_api_uri, exchange_api_cache_duration, short_error_duration};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::HttpClient;

#[derive(Deserialize, Clone, Debug)]
pub struct Exchange {
    pub rates: Option<HashMap<String, BigDecimal>>,
    pub base: String,
}

pub struct FiatInfoProvider {
    client: Arc<dyn HttpClient>,
    cache: Arc<dyn Cache>,
}

impl FiatInfoProvider {
    pub fn new(context: &RequestContext) -> Self {
        FiatInfoProvider {
            client: context.http_client(),
            cache: context.cache(ChainCache::Other),
        }
    }

    pub async fn exchange_usd_to(&self, currency_code: &str) -> ApiResult<BigDecimal> {
        if &currency_code.to_lowercase() == "usd" {
            return Ok(BigDecimal::from(1));
        }

        let currency_code = currency_code.to_uppercase();
        let exchange = self.fetch_exchange().await?;
        match exchange.rates {
            Some(rates) => {
                let base_to_usd = rates.get("USD").unwrap_or(&BigDecimal::from(0)).to_owned();
                rates
                    .get(&currency_code)
                    .cloned()
                    .map(|base_to_requested_code| base_to_requested_code / base_to_usd)
                    .ok_or(client_error!(422, "Currency not found"))
            }
            None => Err(client_error!(422, "Currency not found")),
        }
    }

    pub async fn available_currency_codes(&self) -> ApiResult<Vec<String>> {
        let exchange = self.fetch_exchange().await?;
        Ok(exchange
            .rates
            .map_or(vec![], |s| s.keys().cloned().collect::<Vec<_>>()))
    }

    async fn fetch_exchange(&self) -> ApiResult<Exchange> {
        let url = base_exchange_api_uri();
        let body = RequestCached::new(url, &self.client, &self.cache)
            .cache_duration(exchange_api_cache_duration())
            .error_cache_duration(short_error_duration())
            .execute()
            .await?;
        serde_json::from_str::<Exchange>(&body)
            .map_err(|_| api_error!("Unknown 'Exchange' json structure"))
    }
}

'''
'''--- src/providers/info.rs ---
use std::collections::HashMap;
use std::future::Future;
use std::sync::Arc;
use std::time::Duration;

use lazy_static::lazy_static;
use mockall::automock;
use rocket::futures::TryFutureExt;
use rocket::tokio::sync::Mutex;
use semver::Version;
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};
use serde_json;

use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::cache::Cache;
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::chains::ChainInfo;
use crate::common::models::backend::safe_apps::SafeApp;
use crate::common::models::backend::safes::MasterCopy;
use crate::common::models::page::Page;
use crate::config::{
    address_info_cache_duration, chain_info_cache_duration, chain_info_request_timeout,
    contract_info_request_timeout, default_request_timeout, long_error_duration,
    request_cache_duration, safe_info_cache_duration, safe_info_request_timeout,
    short_error_duration, token_cache_size_count, token_info_cache_duration,
    token_info_request_timeout,
};
use crate::providers::address_info::ContractInfo;
use crate::utils::context::RequestContext;
use crate::utils::errors::{ApiError, ApiResult, ErrorDetails};
use crate::utils::http_client::{HttpClient, Request};
use crate::utils::json::default_if_null;

pub const TOKENS_KEY_BASE: &'static str = "dip_ti";
lazy_static! {
    pub static ref SAFE_V_1_3_0: Version = Version::new(1, 3, 0);
}

// TODO: move models that are (de)serialized into models module.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum TokenType {
    Erc721,
    Erc20,
    NativeToken,
    #[serde(other)]
    Unknown,
}

#[derive(Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(PartialEq))]
pub struct SafeInfo {
    pub address: String,
    pub nonce: u64,
    pub threshold: u64,
    pub owners: Vec<String>,
    pub master_copy: String,
    pub modules: Option<Vec<String>>,
    pub fallback_handler: String,
    pub guard: String,
    pub version: Option<String>,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize, PartialEq))]
pub struct SafeAppInfo {
    pub name: String,
    pub url: String,
    pub logo_uri: String,
}

impl From<&SafeApp> for SafeAppInfo {
    fn from(safe_app: &SafeApp) -> Self {
        SafeAppInfo {
            name: safe_app.name.clone(),
            url: safe_app.url.clone(),
            logo_uri: safe_app.icon_url.clone(),
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TokenInfo {
    #[serde(rename = "type")]
    pub token_type: TokenType,
    // No need to map to AddressEx as the information are present in this struct
    pub address: String,
    #[serde(deserialize_with = "default_if_null")]
    pub decimals: u64,
    pub symbol: String,
    pub name: String,
    pub logo_uri: Option<String>,
}

#[automock]
#[rocket::async_trait]
pub trait InfoProvider {
    async fn chain_info(&self) -> ApiResult<ChainInfo>;
    async fn safe_info(&self, safe: &str) -> ApiResult<SafeInfo>;
    async fn token_info(&self, token: &str) -> ApiResult<TokenInfo>;
    async fn safe_app_info(&self, url: &str) -> ApiResult<SafeAppInfo>;
    async fn safe_app_info_by_id(&self, id: u64) -> ApiResult<SafeAppInfo>;
    async fn contract_info(&self, contract_address: &str) -> ApiResult<ContractInfo>;

    async fn address_ex_from_any_source(&self, address: &str) -> ApiResult<AddressEx>;
    async fn address_ex_from_contracts(&self, address: &str) -> ApiResult<AddressEx>;

    fn chain_id(&self) -> &str;
    fn client(&self) -> Arc<dyn HttpClient>;
    fn cache(&self) -> Arc<dyn Cache>;
}

pub struct DefaultInfoProvider<'p> {
    pub chain_id: &'p str,
    client: Arc<dyn HttpClient>,
    cache: Arc<dyn Cache>,
    // Mutex is an async Mutex, meaning that the lock is non-blocking
    safe_cache: Mutex<HashMap<String, Option<SafeInfo>>>,
    token_cache: Mutex<HashMap<String, Option<TokenInfo>>>,
    chain_cache: Mutex<HashMap<String, Option<ChainInfo>>>,
}

#[rocket::async_trait]
impl InfoProvider for DefaultInfoProvider<'_> {
    fn chain_id(&self) -> &str {
        self.chain_id
    }

    async fn chain_info(&self) -> ApiResult<ChainInfo> {
        let chain_cache = &mut self.chain_cache.lock().await;
        Self::cached(chain_cache, || self.load_chain_info(), self.chain_id).await
    }

    async fn safe_info(&self, safe: &str) -> ApiResult<SafeInfo> {
        let safe_cache = &mut self.safe_cache.lock().await;
        Self::cached(safe_cache, || self.load_safe_info(safe.to_string()), safe).await
    }

    async fn token_info(&self, token: &str) -> ApiResult<TokenInfo> {
        if token != "0x0000000000000000000000000000000000000000" {
            let token_cache = &mut self.token_cache.lock().await;
            Self::cached(
                token_cache,
                || self.load_token_info(token.to_string()),
                token,
            )
            .await
        } else {
            bail!("Token Address is 0x0")
        }
    }

    async fn safe_app_info(&self, url: &str) -> ApiResult<SafeAppInfo> {
        let config_service_url = config_uri!("/v1/safe-apps/?url={}", url);

        let result = RequestCached::new(config_service_url, &self.client, &self.cache)
            .execute()
            .await?;

        let config_safe_apps: Vec<SafeApp> = serde_json::from_str::<Vec<SafeApp>>(&result)?;

        match config_safe_apps.first() {
            None => Err(ApiError {
                status: 404,
                details: ErrorDetails {
                    code: 404,
                    message: Some("No Safe Apps match the url".to_string()),
                    arguments: None,
                    debug: None,
                },
            }),
            Some(first) => Ok(SafeAppInfo::from(first)),
        }
    }

    async fn safe_app_info_by_id(&self, id: u64) -> ApiResult<SafeAppInfo> {
        let config_service_url = config_uri!("/v1/safe-apps/");
        let result = RequestCached::new(config_service_url, &self.client, &self.cache)
            .execute()
            .await?;

        let safe_apps: Vec<SafeApp> = serde_json::from_str::<Vec<SafeApp>>(&result)?;
        let safe_app: Option<&SafeApp> = safe_apps.iter().find(|safe_app| safe_app.id == id);

        return match safe_app {
            None => Err(ApiError {
                status: 404,
                details: ErrorDetails {
                    code: 404,
                    message: Some(format!("No Safe App with id {}", id)),
                    arguments: None,
                    debug: None,
                },
            }),
            Some(safe_app) => Ok(SafeAppInfo::from(safe_app)),
        };
    }

    async fn contract_info(&self, contract_address: &str) -> ApiResult<ContractInfo> {
        let url = core_uri!(self, "/v1/contracts/{}/", contract_address)?;
        let contract_info_json = RequestCached::new(url, &self.client, &self.cache)
            .cache_duration(address_info_cache_duration())
            .error_cache_duration(long_error_duration())
            .request_timeout(contract_info_request_timeout())
            .execute()
            .await?;

        Ok(serde_json::from_str::<ContractInfo>(&contract_info_json)?)
    }

    async fn address_ex_from_contracts(&self, address: &str) -> ApiResult<AddressEx> {
        let contract_info = self.contract_info(address).await?;
        if contract_info.display_name.trim().is_empty() {
            bail!("No display name")
        } else {
            Ok(AddressEx {
                value: address.to_owned(),
                name: Some(contract_info.display_name.to_owned()),
                logo_uri: contract_info.logo_uri.to_owned(),
            })
        }
    }

    async fn address_ex_from_any_source(&self, address: &str) -> ApiResult<AddressEx> {
        self.token_info(&address)
            .map_ok(|it| AddressEx {
                value: address.to_owned(),
                name: Some(it.name),
                logo_uri: it.logo_uri,
            })
            .or_else(|_| async move { self.address_ex_from_contracts(&address).await })
            .await
    }

    fn client(&self) -> Arc<dyn HttpClient> {
        self.client.clone()
    }

    fn cache(&self) -> Arc<dyn Cache> {
        self.cache.clone()
    }
}

impl<'a> DefaultInfoProvider<'a> {
    pub fn new(chain_id: &'a str, context: &RequestContext) -> Self {
        DefaultInfoProvider {
            chain_id,
            client: context.http_client(),
            cache: context.cache(ChainCache::from(chain_id)),
            safe_cache: Default::default(),
            token_cache: Default::default(),
            chain_cache: Default::default(),
        }
    }
}

impl DefaultInfoProvider<'_> {
    async fn cached<'a, T, Fut>(
        local_cache: &'a mut HashMap<String, Option<T>>,
        generator: impl FnOnce() -> Fut,
        key: impl Into<String>,
    ) -> ApiResult<T>
    where
        T: Clone + DeserializeOwned + 'a,
        Fut: Future<Output = ApiResult<Option<T>>>,
    {
        let key = key.into();
        match local_cache.get(&key) {
            Some(value) => value
                .clone()
                .ok_or(api_error!("Cached value not available")),
            None => {
                let value: Option<T> = generator().await?;
                local_cache.insert(key, value.clone());
                value.ok_or(api_error!("Could not generate value"))
            }
        }
    }

    async fn load_safe_info(&self, safe: String) -> ApiResult<Option<SafeInfo>> {
        let url = core_uri!(self, "/v1/safes/{}/", safe)?;
        let data = RequestCached::new(url, &self.client, &self.cache)
            .cache_duration(safe_info_cache_duration())
            .error_cache_duration(short_error_duration())
            .request_timeout(safe_info_request_timeout())
            .execute()
            .await?;
        Ok(serde_json::from_str(&data).ok())
    }

    async fn populate_token_cache(&self) -> ApiResult<()> {
        let token_cache_size_count = token_cache_size_count();
        let url = core_uri!(self, "/v1/tokens/?limit={}", token_cache_size_count)?;
        let request = {
            let mut request = Request::new(url);
            request.timeout(Duration::from_millis(token_info_request_timeout()));
            request
        };

        let response = self.client.get(request).await?;
        let data: Page<TokenInfo> = serde_json::from_str(&response.body)?;
        let token_key = generate_token_key(self.chain_id);
        for token in data.results.iter() {
            self.cache
                .insert_in_hash(&token_key, &token.address, &serde_json::to_string(&token)?)
                .await;
        }
        Ok(())
    }

    async fn check_token_cache(&self) -> ApiResult<()> {
        let token_key = generate_token_key(&self.chain_id);
        if self.cache.has_key(&token_key).await {
            return Ok(());
        }
        self.cache
            .insert_in_hash(&token_key, "state", "populating")
            .await;
        let result = self.populate_token_cache().await;
        if result.is_ok() {
            self.cache
                .expire_entity(&token_key, token_info_cache_duration())
                .await;
            self.cache
                .insert_in_hash(&token_key, "state", "populated")
                .await;
        } else {
            self.cache
                .expire_entity(&token_key, short_error_duration())
                .await;
            self.cache
                .insert_in_hash(&token_key, "state", "errored")
                .await;
        }
        result
    }

    async fn load_token_info(&self, token: String) -> ApiResult<Option<TokenInfo>> {
        self.check_token_cache().await?;
        match self
            .cache
            .get_from_hash(&generate_token_key(&self.chain_id), &token)
            .await
        {
            Some(cached) => Ok(Some(serde_json::from_str::<TokenInfo>(&cached)?)),
            None => Ok(None),
        }
    }

    async fn load_chain_info(&self) -> ApiResult<Option<ChainInfo>> {
        let url = config_uri!("/v1/chains/{}/", self.chain_id);
        let data = RequestCached::new(url, &self.client, &self.cache)
            .cache_duration(chain_info_cache_duration())
            .error_cache_duration(short_error_duration())
            .request_timeout(chain_info_request_timeout())
            .execute()
            .await?;
        let result = serde_json::from_str::<ChainInfo>(&data).ok();
        Ok(result)
    }

    pub async fn master_copies(&self) -> ApiResult<Vec<MasterCopy>> {
        let url = core_uri!(self, "/v1/about/master-copies/")?;
        let body = RequestCached::new(url, &self.client, &self.cache)
            .cache_duration(request_cache_duration())
            .error_cache_duration(short_error_duration())
            .request_timeout(default_request_timeout())
            .execute()
            .await?;
        Ok(serde_json::from_str(&body)?)
    }
}

pub fn generate_token_key(chain_id: &str) -> String {
    format!("{}_{}", TOKENS_KEY_BASE, chain_id)
}

'''
'''--- src/providers/mod.rs ---
pub mod address_info;
#[doc(hidden)]
pub mod ext;
#[doc(hidden)]
pub mod fiat;
#[doc(hidden)]
pub mod info;

#[cfg(test)]
mod tests;

'''
'''--- src/providers/tests/fiat.rs ---
use std::str::FromStr;
use std::sync::Arc;

use bigdecimal::BigDecimal;
use mockall::predicate::eq;
use serde_json::json;

use crate::cache::manager::ChainCache;
use crate::providers::fiat::{Exchange, FiatInfoProvider};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiError;
use crate::utils::http_client::{HttpClient, MockHttpClient, Request, Response};
use crate::{create_cache_manager, RedisCacheManager};

const EXCHANGE_API_BASE_URI: &'static str = "https://test.exchange-rate.api";
const EXCHANGE_API_KEY: &'static str = "some_random_key";

fn setup_exchange_env() {
    std::env::set_var("EXCHANGE_API_BASE_URI", EXCHANGE_API_BASE_URI);
    std::env::set_var("EXCHANGE_API_KEY", EXCHANGE_API_KEY);
}

#[rocket::async_test]
async fn available_currency_codes() {
    setup_exchange_env();
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let request = Request::new(format!(
        "{}?access_key={}",
        EXCHANGE_API_BASE_URI, EXCHANGE_API_KEY
    ));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::EXCHANGE_CURRENCY_RATES),
            })
        });
    let context = RequestContext::setup_for_test(
        String::from("request_id"),
        String::from("host"),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let fiat_provider = FiatInfoProvider::new(&context);

    let mut expected =
        serde_json::from_str::<Exchange>(crate::tests::json::EXCHANGE_CURRENCY_RATES)
            .unwrap()
            .rates
            .unwrap()
            .into_keys()
            .collect::<Vec<String>>();

    let mut actual = fiat_provider.available_currency_codes().await.unwrap();

    assert_eq!(expected.sort(), actual.sort());
}

#[rocket::async_test]
async fn available_currency_codes_api_error() {
    setup_exchange_env();
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;
    let api_error_json =
        json!({"success":false,"error":{"code":105,"type":"base_currency_access_restricted"}});

    let mut mock_http_client = MockHttpClient::new();
    let request = Request::new(format!(
        "{}?access_key={}",
        EXCHANGE_API_BASE_URI, EXCHANGE_API_KEY
    ));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(api_error_json.to_string()),
            })
        });
    let context = RequestContext::setup_for_test(
        String::from("request_id"),
        String::from("host"),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let fiat_provider = FiatInfoProvider::new(&context);

    let actual = fiat_provider.available_currency_codes().await;

    let expected = Err(ApiError::new_from_message_with_code(
        500,
        String::from("Unknown 'Exchange' json structure"),
    ));
    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn exchange_usd_to() {
    setup_exchange_env();
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let request = Request::new(format!(
        "{}?access_key={}",
        EXCHANGE_API_BASE_URI, EXCHANGE_API_KEY
    ));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::EXCHANGE_CURRENCY_RATES),
            })
        });
    let context = RequestContext::setup_for_test(
        String::from("request_id"),
        String::from("host"),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let fiat_provider = FiatInfoProvider::new(&context);
    let expected = Ok(1 / BigDecimal::from_str("1.125036").unwrap());

    let actual = fiat_provider.exchange_usd_to("EUR").await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn exchange_usd_to_usd() {
    setup_exchange_env();
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client.expect_get().times(0);
    let context = RequestContext::setup_for_test(
        String::from("request_id"),
        String::from("host"),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let fiat_provider = FiatInfoProvider::new(&context);
    let expected = Ok(BigDecimal::from(1));

    let actual = fiat_provider.exchange_usd_to("USD").await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn exchange_usd_to_unknown_code() {
    setup_exchange_env();
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let request = Request::new(format!(
        "{}?access_key={}",
        EXCHANGE_API_BASE_URI, EXCHANGE_API_KEY
    ));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::EXCHANGE_CURRENCY_RATES),
            })
        });
    let context = RequestContext::setup_for_test(
        String::from("request_id"),
        String::from("host"),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let fiat_provider = FiatInfoProvider::new(&context);
    let expected = Err(ApiError::new_from_message_with_code(
        422,
        String::from("Currency not found"),
    ));

    let actual = fiat_provider.exchange_usd_to("UNKOWN_CURRENCY_CODE").await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn exchange_usd_to_api_failure() {
    setup_exchange_env();
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;
    let api_error_json =
        json!({"success":false,"error":{"code":105,"type":"base_currency_access_restricted"}});

    let mut mock_http_client = MockHttpClient::new();
    let request = Request::new(format!(
        "{}?access_key={}",
        EXCHANGE_API_BASE_URI, EXCHANGE_API_KEY
    ));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(api_error_json.to_string()),
            })
        });
    let context = RequestContext::setup_for_test(
        String::from("request_id"),
        String::from("host"),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let fiat_provider = FiatInfoProvider::new(&context);

    let actual = fiat_provider.exchange_usd_to("EUR").await;

    let expected = Err(ApiError::new_from_message_with_code(
        500,
        String::from("Unknown 'Exchange' json structure"),
    ));
    assert_eq!(expected, actual);
}

'''
'''--- src/providers/tests/info.rs ---
use crate::cache::manager::ChainCache;
use crate::common::models::backend::chains::ChainInfo;
use crate::common::models::page::Page;
use crate::config::{
    chain_info_request_timeout, contract_info_request_timeout, safe_info_request_timeout,
    token_info_request_timeout,
};
use crate::providers::address_info::ContractInfo;
use crate::providers::info::{DefaultInfoProvider, InfoProvider, SafeAppInfo, SafeInfo, TokenInfo};
use crate::utils::context::RequestContext;
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::{HttpClient, MockHttpClient, Request, Response};
use crate::{create_cache_manager, RedisCacheManager};
use mockall::predicate::eq;
use std::sync::Arc;
use std::time::Duration;

#[rocket::async_test]
async fn default_info_provider_chain_info() {
    let expected =
        serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY).unwrap();
    let request_uri = config_uri!("/v1/chains/{}/", 4);
    let cache_manager = create_cache_manager().await;

    let mut mock_http_client = MockHttpClient::new();
    let mut chain_request = Request::new(request_uri.clone());
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });
    let context = RequestContext::setup_for_test(
        String::from(&request_uri),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;

    let info_provider = DefaultInfoProvider::new("4", &context);

    let actual = info_provider.chain_info().await.unwrap();

    assert_eq!(actual, expected)
}

#[rocket::async_test]
async fn default_info_provider_chain_info_not_found() {
    let request_uri = config_uri!("/v1/chains/{}/", 4);
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let mut chain_request = Request::new(request_uri.clone());
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: String::from("Not found"),
            }))
        });
    let context = RequestContext::setup_for_test(
        String::from(&request_uri),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = ApiError {
        status: 404,
        details: ErrorDetails {
            code: 1337,
            message: Some(String::from("Not found")),
            arguments: None,
            debug: None,
        },
    };
    let info_provider = DefaultInfoProvider::new("4", &context);

    let actual = info_provider.chain_info().await;

    assert_eq!(actual, Err(expected));
}

#[rocket::async_test]
async fn default_info_provider_safe_info() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let request_uri = config_uri!("/v1/chains/{}/", 4);
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let mut chain_request = Request::new(request_uri.clone());
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_MODULES),
                status_code: 200,
            })
        });

    let context = RequestContext::setup_for_test(
        String::from(&request_uri),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES)
        .expect("SafeInfo deserialization issue");
    let info_provider = DefaultInfoProvider::new("4", &context);

    let actual = info_provider.safe_info(safe_address).await.unwrap();

    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn default_info_provider_safe_info_not_found() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let request_uri = config_uri!("/v1/chains/{}/", 4);
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let mut chain_request = Request::new(request_uri.clone());
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: String::from("Not found"),
            }))
        });

    let context = RequestContext::setup_for_test(
        String::from(&request_uri),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = ApiError {
        status: 404,
        details: ErrorDetails {
            code: 1337,
            message: Some(String::from("Not found")),
            arguments: None,
            debug: None,
        },
    };
    let info_provider = DefaultInfoProvider::new("4", &context);

    let actual = info_provider.safe_info(safe_address).await;

    assert_eq!(actual, Err(expected));
}

#[rocket::async_test]
async fn default_info_provider_token_info() {
    let token_address = "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46";
    let request_uri = config_uri!("/v1/chains/{}/", 4);
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let mut chain_request = Request::new(request_uri.clone());
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut token_request = Request::new(String::from(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/tokens/?limit=20000",
    ));
    token_request.timeout(Duration::from_millis(token_info_request_timeout()));
    let page_tokens: Page<TokenInfo> = Page {
        next: None,
        previous: None,
        results: vec![
            serde_json::from_str(crate::tests::json::TOKEN_BAT).expect("BAT token failure")
        ],
    };

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(token_request))
        .returning(move |_| {
            Ok(Response {
                body: serde_json::to_string(&page_tokens).expect("Token page failure"),
                status_code: 200,
            })
        });
    let context = RequestContext::setup_for_test(
        String::from(&request_uri),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Ok(serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_BAT).unwrap());

    let info_provider = DefaultInfoProvider::new("4", &context);
    let actual = info_provider.token_info(token_address).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn default_info_provider_token_info_request_failure() {
    let token_address = "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46";
    let request_uri = config_uri!("/v1/chains/{}/", 4);
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let mut chain_request = Request::new(request_uri.clone());
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut token_request = Request::new(String::from(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/tokens/?limit=20000",
    ));
    token_request.timeout(Duration::from_millis(token_info_request_timeout()));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(token_request))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: String::from("Not found"),
            }))
        });
    let context = RequestContext::setup_for_test(
        String::from(&request_uri),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Err(ApiError::new_from_message_with_code(
        404,
        String::from("Not found"),
    ));

    let info_provider = DefaultInfoProvider::new("4", &context);
    let actual = info_provider.token_info(token_address).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn default_info_provider_token_info_not_found_in_cache() {
    let token_address = "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De41";
    let request_uri = config_uri!("/v1/chains/{}/", 4);
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();
    let mut chain_request = Request::new(request_uri.clone());
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut token_request = Request::new(String::from(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/tokens/?limit=20000",
    ));
    token_request.timeout(Duration::from_millis(token_info_request_timeout()));
    let page_tokens: Page<TokenInfo> = Page {
        next: None,
        previous: None,
        results: vec![
            serde_json::from_str(crate::tests::json::TOKEN_BAT).expect("BAT token failure")
        ],
    };

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(token_request))
        .returning(move |_| {
            Ok(Response {
                body: serde_json::to_string(&page_tokens).expect("Token page failure"),
                status_code: 200,
            })
        });
    let context = RequestContext::setup_for_test(
        String::from(&request_uri),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Err(ApiError::new_from_message("Could not generate value"));

    let info_provider = DefaultInfoProvider::new("4", &context);
    let actual = info_provider.token_info(token_address).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn default_info_provider_token_info_address_0x0() {
    let token_address = "0x0000000000000000000000000000000000000000";
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mock_http_client = MockHttpClient::new();

    let context = RequestContext::setup_for_test(
        String::from(""),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Err(ApiError::new_from_message_with_code(
        500,
        String::from("Token Address is 0x0"),
    ));

    let info_provider = DefaultInfoProvider::new("4", &context);
    let actual = info_provider.token_info(token_address).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn default_info_provider_safe_app_info_error() {
    let origin_url = "https://app.uniswap.org";
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();

    let config_service_request = Request::new(config_uri!("/v1/safe-apps/?url={}", &origin_url));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(config_service_request))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                body: "".to_string(),
                status_code: 0,
            }))
        });

    let context = RequestContext::setup_for_test(
        String::from(""),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Err(ApiError {
        status: 0,
        details: ErrorDetails {
            code: 1337,
            message: Some("".to_string()),
            arguments: None,
            debug: None,
        },
    });

    let info_provider = DefaultInfoProvider::new("4", &context);
    let actual = info_provider.safe_app_info(origin_url).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn default_info_provider_safe_app_info_success() {
    let origin_url = "https://test.app";
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();

    let config_service_request = Request::new(config_uri!("/v1/safe-apps/?url={}", &origin_url));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(config_service_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::POLYGON_SAFE_APP_URL_QUERY),
                status_code: 200,
            })
        });

    let context = RequestContext::setup_for_test(
        String::from(""),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;

    let expected = Ok(SafeAppInfo {
        name: String::from("Test App"),
        url: String::from("https://test.app"),
        logo_uri: format!("{}/{}", "https://test.app", "logo.svg"),
    });

    let info_provider = DefaultInfoProvider::new("137", &context);
    let actual = info_provider.safe_app_info(origin_url).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn default_info_provider_safe_app_info_not_found() {
    let origin_url = "https://app.uniswap.org";
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();

    let config_service_request = Request::new(config_uri!("/v1/safe-apps/?url={}", &origin_url));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(config_service_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from("[]"),
                status_code: 200,
            })
        });

    let context = RequestContext::setup_for_test(
        String::from(""),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Err(ApiError {
        status: 404,
        details: ErrorDetails {
            code: 404,
            message: Some("No Safe Apps match the url".to_string()),
            arguments: None,
            debug: None,
        },
    });

    let info_provider = DefaultInfoProvider::new("4", &context);
    let actual = info_provider.safe_app_info(origin_url).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn contract_info() {
    let bip_contract_address = "0x00000000000045166C45aF0FC6E4Cf31D9E14B9A";
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut contract_info_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/contracts/{}/",
        &bip_contract_address
    ));
    contract_info_request.timeout(Duration::from_millis(contract_info_request_timeout()));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(contract_info_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 202,
                body: String::from(crate::tests::json::CONTRACT_INFO_BID),
            })
        });

    let context = RequestContext::setup_for_test(
        String::from(""),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected =
        serde_json::from_str::<ContractInfo>(crate::tests::json::CONTRACT_INFO_BID).unwrap();

    let info_provider = DefaultInfoProvider::new("4", &context);
    let actual = info_provider
        .contract_info(bip_contract_address)
        .await
        .unwrap();

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn contract_info_not_found() {
    let bip_contract_address = "0x00000000000045166C45aF0FC6E4Cf31D9E14B9A";
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    let mut mock_http_client = MockHttpClient::new();

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut contract_info_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/contracts/{}/",
        &bip_contract_address
    ));
    contract_info_request.timeout(Duration::from_millis(contract_info_request_timeout()));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(contract_info_request))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: String::from("Not found"),
            }))
        });

    let context = RequestContext::setup_for_test(
        String::from(""),
        config_uri!(""),
        &(Arc::new(mock_http_client) as Arc<dyn HttpClient>),
        &(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>),
    )
    .await;
    let expected = Err(ApiError::new_from_message_with_code(
        404,
        String::from("Not found"),
    ));

    let info_provider = DefaultInfoProvider::new("4", &context);
    let actual = info_provider.contract_info(bip_contract_address).await;

    assert_eq!(expected, actual);
}

'''
'''--- src/providers/tests/mod.rs ---
mod fiat;
mod info;

'''
'''--- src/routes/about/handlers.rs ---
use crate::config::{build_number, version};
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::about::models::{About, ChainAbout};
use crate::routes::safes::models::Implementation;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;

pub async fn chains_about(context: &RequestContext, chain_id: &str) -> ApiResult<ChainAbout> {
    let info_provider = DefaultInfoProvider::new(chain_id, &context);
    let chain_info = info_provider.chain_info().await?;
    let about = about();
    Ok(ChainAbout {
        transaction_service_base_uri: chain_info.transaction_service,
        about: About {
            name: about.name,
            version: about.version,
            build_number: about.build_number,
        },
    })
}

pub fn about() -> About {
    About {
        name: env!("CARGO_PKG_NAME").to_string(),
        version: version(),
        build_number: build_number(),
    }
}

pub async fn get_master_copies(
    context: &RequestContext,
    chain_id: &str,
) -> ApiResult<Vec<Implementation>> {
    let info_provider = DefaultInfoProvider::new(chain_id, &context);
    Ok(info_provider
        .master_copies()
        .await?
        .into_iter()
        .map(|master_copy| master_copy.into())
        .collect())
}

'''
'''--- src/routes/about/mod.rs ---
#[doc(hidden)]
pub mod handlers;
pub mod models;
pub mod routes;

#[cfg(test)]
mod tests;

'''
'''--- src/routes/about/models.rs ---
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use serde::Serialize;
/// ChainAbout
///
/// <details>
/// <summary>Sample</summary>
///
/// ```json
/// {
///   "transactionServiceBaseUri": "https://safe-transaction.mainnet.staging.gnosisdev.com",
///   "name": "safe-client-gateway",
///   "version": "3.0.0",
///   "buildNumber": "48"
/// }
/// ```
/// </details>
#[derive(Serialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct ChainAbout {
    /// base URI string used for backend requests
    pub transaction_service_base_uri: String,
    #[serde(flatten)]
    pub about: About,
}

/// About
///
/// <details>
/// <summary>Sample</summary>
///
/// ```json
/// {
///   "name": "safe-client-gateway",
///   "version": "3.0.0",
///   "buildNumber": "48"
/// }
/// ```
/// </details>
#[derive(Serialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct About {
    /// crate name
    pub name: String,
    /// env variable `VERSION`, defaults to crate version
    pub version: String,
    /// Build number from github action
    pub build_number: Option<String>,
}

'''
'''--- src/routes/about/routes.rs ---
use rocket::response::content;

use crate::cache::cache_operations::CacheResponse;
use crate::cache::manager::ChainCache;
use crate::common::routes::authorization::AuthorizationToken;
use crate::config::about_cache_duration;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::about::handlers;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::Request;
use rocket_okapi::openapi;

/// `/v1/chains/<chain_id>/about` <br />
/// Returns [ChainAbout](crate::routes::about::models::ChainAbout)
///
/// # Chain's About
///
/// The about endpoint provides information of the environmental variables set for the instance of `safe-client-gateway`. This would allow to identify on which commit and version the last deployment happened and to which safe transaction handlers backend environment the current instance of the gateway is pointing to.
///
/// ## Path
///
/// `/v1/chains/<chain_id>/about`
///
/// ## Query parameters
///
/// There are no query parameters for this endpoint
#[openapi(tag = "About")]
#[get("/v1/chains/<chain_id>/about")]
pub async fn get_chains_about(
    context: RequestContext,
    chain_id: String,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .duration(about_cache_duration())
        .resp_generator(|| handlers::chains_about(&context, &chain_id))
        .execute()
        .await
}

/// `/about` <br />
/// [About](crate::routes::about::models::About)
///
/// # About
///
/// This endpoint is chain independent, and returns non cached information regarding this current CGW instance.
///
/// ## Path
///
/// `/about`
#[openapi(tag = "About")]
#[get("/about")]
pub async fn get_about() -> ApiResult<content::RawJson<String>> {
    Ok(content::RawJson(serde_json::to_string(&handlers::about())?))
}
/// `/v1/chains/<chain_id>/about/master-copies` <br />
/// Returns a list of `MasterCopy`
///
/// # Master Copies
///
/// This endpoint returns a list of `MasterCopy` objects just as documented in the core services
///
/// ## Path
///
/// `/v1/chains/<chain_id>/about/master-copies` where `chain_id` correspond to the chain id of the desired network
///
/// ## Sample Json
/// <details>
/// <summary>JSON sample</summary>
///
/// ```json
/// [
///   {
///     "address": "0x8942595A2dC5181Df0465AF0D7be08c8f23C93af",
///     "version": "0.1.0"
///   }
/// ]
/// ```
/// </details>
#[openapi(tag = "About")]
#[get("/v1/chains/<chain_id>/about/master-copies")]
pub async fn get_master_copies(
    context: RequestContext,
    chain_id: String,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .duration(about_cache_duration())
        .resp_generator(|| handlers::get_master_copies(&context, chain_id.as_str()))
        .execute()
        .await
}

#[doc(hidden)]
#[openapi(tag = "About")]
#[get("/v1/chains/<chain_id>/about/backbone")]
pub async fn backbone(
    context: RequestContext,
    chain_id: String,
) -> ApiResult<content::RawJson<String>> {
    let client = context.http_client();
    let info_provider = DefaultInfoProvider::new(chain_id.as_str(), &context);
    let url = core_uri!(info_provider, "/v1/about/")?;
    let request = Request::new(url);
    Ok(content::RawJson(client.get(request).await?.body))
}

#[doc(hidden)]
#[get("/about/redis")]
pub async fn redis(context: RequestContext, _token: AuthorizationToken) -> ApiResult<String> {
    Ok(context
        .cache(ChainCache::Other)
        .info()
        .await
        .unwrap_or(String::new()))
}

'''
'''--- src/routes/about/tests/mod.rs ---
mod routes;

'''
'''--- src/routes/about/tests/routes.rs ---
use core::time::Duration;
use std::env;

use mockall::predicate::eq;
use rocket::http::{Header, Status};
use rocket::local::asynchronous::Client;

use crate::cache::MockCache;
use crate::config::{build_number, chain_info_request_timeout, version};
use crate::routes::about::models::{About, ChainAbout};
use crate::routes::safes::models::Implementation;
use crate::tests::main::{setup_rocket, setup_rocket_with_mock_cache};
use crate::utils::http_client::{MockHttpClient, Request, Response};

#[rocket::async_test]
async fn get_chains_about() {
    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();
        mock_http_client
            .expect_get()
            .times(1)
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
                })
            });
        mock_http_client
    };
    let expected = ChainAbout {
        transaction_service_base_uri: "https://safe-transaction.rinkeby.staging.gnosisdev.com"
            .to_string(),
        about: About {
            name: env!("CARGO_PKG_NAME").to_string(),
            version: version(),
            build_number: build_number(),
        },
    };

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_chains_about],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/v1/chains/4/about");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::Ok);
    assert_eq!(
        response.into_string().await.unwrap(),
        serde_json::to_string(&expected).unwrap()
    );
}

#[rocket::async_test]
async fn get_about() {
    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();
        mock_http_client.expect_get().times(0);
        mock_http_client
    };
    let expected = About {
        name: env!("CARGO_PKG_NAME").to_string(),
        version: version(),
        build_number: build_number(),
    };

    let client = Client::tracked(
        setup_rocket(mock_http_client, routes![super::super::routes::get_about]).await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/about");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::Ok);
    assert_eq!(
        response.into_string().await.unwrap(),
        serde_json::to_string(&expected).unwrap()
    );
}

#[rocket::async_test]
async fn get_master_copies() {
    let chain_request = {
        let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 137));
        chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
        chain_request
    };
    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(chain_request))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::CHAIN_INFO_POLYGON),
                })
            });
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(Request::new(
                "https://safe-transaction-polygon.staging.gnosisdev.com/api/v1/about/master-copies/"
                    .to_string(),
            )))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::POLYGON_MASTER_COPIES),
                })
            });
        mock_http_client
    };
    let expected = vec![
        Implementation {
            address: "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552".to_string(),
            version: "1.3.0".to_string(),
        },
        Implementation {
            address: "0x3E5c63644E683549055b9Be8653de26E0B4CD36E".to_string(),
            version: "1.3.0+L2".to_string(),
        },
    ];

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_master_copies],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/v1/chains/137/about/master-copies");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::Ok);
    assert_eq!(
        response.into_string().await.unwrap(),
        serde_json::to_string(&expected).unwrap()
    );
}

#[rocket::async_test]
async fn get_backbone() {
    let chain_request = {
        let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 137));
        chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
        chain_request
    };
    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(chain_request))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::CHAIN_INFO_POLYGON),
                })
            });
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(Request::new(
                "https://safe-transaction-polygon.staging.gnosisdev.com/api/v1/about/".to_string(),
            )))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from("{\"json\":\"json\"}"),
                })
            });
        mock_http_client
    };
    let expected = "{\"json\":\"json\"}";

    let client = Client::tracked(
        setup_rocket(mock_http_client, routes![super::super::routes::backbone]).await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/v1/chains/137/about/backbone");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::Ok);
    assert_eq!(response.into_string().await.unwrap(), expected);
}

#[rocket::async_test]
#[ignore] // TODO remove this
async fn get_redis() {
    env::set_var("WEBHOOK_TOKEN", "test_webhook_token");
    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();
        mock_http_client.expect_get().times(0);
        mock_http_client
    };
    let mock_cache = {
        let mut mock_cache = MockCache::new();
        mock_cache
            .expect_info()
            .times(1)
            .return_once(move || Some(String::from("Cache info")));
        mock_cache
    };

    let client = Client::tracked(setup_rocket_with_mock_cache(
        mock_http_client,
        mock_cache,
        routes![super::super::routes::redis],
    ))
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/about/redis");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.add_header(Header::new("Authorization", "Basic test_webhook_token"));
        response.dispatch().await
    };

    let expected = "Cache info";

    assert_eq!(response.status(), Status::Ok);
    assert_eq!(response.into_string().await.unwrap(), expected);
}

'''
'''--- src/routes/balances/converters.rs ---
use crate::common::models::backend::balances::Balance as BalanceDto;
use crate::common::models::backend::chains::NativeCurrency;
use crate::providers::info::{TokenInfo, TokenType};
use crate::routes::balances::models::Balance;

const SCALE: f64 = 1_0000_f64;

impl BalanceDto {
    pub fn to_balance(&self, usd_to_fiat: f64, native_coin: &NativeCurrency) -> Balance {
        let fiat_conversion = self.fiat_conversion.parse::<f64>().unwrap_or(0.0) * usd_to_fiat;
        let fiat_balance = self.fiat_balance.parse::<f64>().unwrap_or(0.0) * usd_to_fiat;
        let token_type = self
            .token_address
            .as_ref()
            .map(|_| TokenType::Erc20)
            .unwrap_or(TokenType::NativeToken);

        let logo_uri = if token_type == TokenType::NativeToken {
            Some(native_coin.logo_uri.to_string())
        } else {
            self.token.as_ref().map(|it| it.logo_uri.to_string())
        };
        Balance {
            token_info: TokenInfo {
                token_type,
                address: self
                    .token_address
                    .to_owned()
                    .unwrap_or(String::from("0x0000000000000000000000000000000000000000")),
                decimals: self
                    .token
                    .as_ref()
                    .map(|it| it.decimals)
                    .unwrap_or(native_coin.decimals),
                symbol: self
                    .token
                    .as_ref()
                    .map(|it| it.symbol.to_string())
                    .unwrap_or(native_coin.symbol.to_string()),
                name: self
                    .token
                    .as_ref()
                    .map(|it| it.name.to_string())
                    .unwrap_or(native_coin.name.to_string()),
                logo_uri,
            },
            balance: self.balance.to_owned(),
            fiat_balance: ((fiat_balance * SCALE).floor() / SCALE).to_string(),
            fiat_conversion: ((fiat_conversion * SCALE).floor() / SCALE).to_string(),
        }
    }
}

'''
'''--- src/routes/balances/converters_v2.rs ---
use crate::common::models::backend::balances_v2::Balance as BalanceDto;
use crate::common::models::backend::chains::NativeCurrency;
use crate::providers::info::{TokenInfo, TokenType};
use crate::routes::balances::models::Balance;
use bigdecimal::num_bigint::BigInt;
use bigdecimal::{BigDecimal, ToPrimitive, Zero};
use std::str::FromStr;

impl BalanceDto {
    pub fn to_balance_v2(
        &self,
        token_to_usd: &BigDecimal,
        usd_to_fiat: &BigDecimal,
        native_coin: &NativeCurrency,
    ) -> Balance {
        let token_decimals = self
            .token
            .as_ref()
            .and_then(|token| Some(token.decimals))
            .and_then(|decimals| decimals.to_i64())
            .unwrap_or(native_coin.decimals.to_i64().unwrap());

        let balance = BigInt::from_str(&self.balance).unwrap_or(Zero::zero());
        let token_balance = BigDecimal::new(balance, token_decimals);
        let fiat_conversion = token_to_usd * usd_to_fiat;
        let fiat_balance = (token_balance * token_to_usd * usd_to_fiat).with_scale(5);

        let (token_type, logo_uri) = if self.token_address.is_some() {
            (
                TokenType::Erc20,
                self.token.as_ref().map(|it| it.logo_uri.to_string()),
            )
        } else {
            (
                TokenType::NativeToken,
                Some(native_coin.logo_uri.to_string()),
            )
        };

        Balance {
            token_info: TokenInfo {
                token_type,
                address: self
                    .token_address
                    .to_owned()
                    .unwrap_or(String::from("0x0000000000000000000000000000000000000000")),
                decimals: self
                    .token
                    .as_ref()
                    .map(|it| it.decimals)
                    .unwrap_or(native_coin.decimals),
                symbol: self
                    .token
                    .as_ref()
                    .map(|it| it.symbol.to_string())
                    .unwrap_or(native_coin.symbol.to_string()),
                name: self
                    .token
                    .as_ref()
                    .map(|it| it.name.to_string())
                    .unwrap_or(native_coin.name.to_string()),
                logo_uri,
            },
            balance: self.balance.to_owned(),
            fiat_balance: fiat_balance.to_string(),
            fiat_conversion: fiat_conversion.to_string(),
        }
    }
}

'''
'''--- src/routes/balances/handlers.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::backend::balances::Balance as BalanceDto;
use crate::common::models::backend::chains::NativeCurrency;
use crate::config::{balances_cache_duration, balances_request_timeout};
use crate::providers::fiat::FiatInfoProvider;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::balances::models::{Balance, Balances};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use bigdecimal::{BigDecimal, ToPrimitive};
use std::cmp::Ordering;

pub async fn balances(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    fiat: &str,
    trusted: bool,
    exclude_spam: bool,
) -> ApiResult<Balances> {
    let info_provider = DefaultInfoProvider::new(chain_id, &context);
    let fiat_info_provider = FiatInfoProvider::new(&context);
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/balances/usd/?trusted={}&exclude_spam={}",
        safe_address,
        trusted,
        exclude_spam
    )?;

    let body = RequestCached::new_from_context(url, context, ChainCache::from(chain_id))
        .cache_duration(balances_cache_duration())
        .request_timeout(balances_request_timeout())
        .execute()
        .await?;
    let backend_balances: Vec<BalanceDto> = serde_json::from_str(&body)?;

    let usd_to_fiat = fiat_info_provider
        .exchange_usd_to(fiat)
        .await
        .unwrap_or(BigDecimal::from(0))
        .to_f64()
        .unwrap_or(f64::from(0));

    let native_currency: NativeCurrency = info_provider.chain_info().await?.native_currency;

    let mut total_fiat = 0.0;

    let mut service_balances: Vec<Balance> = backend_balances
        .into_iter()
        .map(|it| {
            let balance = it.to_balance(usd_to_fiat, &native_currency);
            total_fiat += balance.fiat_balance.parse::<f64>().unwrap_or(0.0);
            balance
        })
        .collect();

    service_balances.sort_by(|a, b| {
        b.fiat_balance
            .parse::<f64>()
            .unwrap_or(0.0)
            .partial_cmp(&a.fiat_balance.parse::<f64>().unwrap_or(0.0))
            .unwrap_or(Ordering::Equal)
    });
    Ok(Balances {
        fiat_total: total_fiat.to_string(),
        items: service_balances,
    })
}

pub async fn fiat_codes(context: &RequestContext) -> ApiResult<Vec<String>> {
    let info_provider = FiatInfoProvider::new(&context);
    let mut fiat_codes = info_provider.available_currency_codes().await?;

    let usd_index = fiat_codes.iter().position(|it| it.eq("USD")).unwrap();
    let eur_index = fiat_codes.iter().position(|it| it.eq("EUR")).unwrap();

    let usd_code = fiat_codes.swap_remove(usd_index);
    let eur_code = fiat_codes.swap_remove(eur_index);

    fiat_codes.sort_by(|a, b| a.to_lowercase().cmp(&b.to_lowercase()));

    let mut output = vec![usd_code, eur_code];
    output.append(&mut fiat_codes);

    Ok(output)
}

'''
'''--- src/routes/balances/handlers_v2.rs ---
use std::cmp::Ordering;
use std::str::FromStr;

use bigdecimal::BigDecimal;
use rocket::futures::{stream, StreamExt};

use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::backend::balances_v2::{
    Balance as BalanceDto, TokenPrice as BackendTokenPrice,
};
use crate::common::models::backend::chains::NativeCurrency;
use crate::config::{
    balances_core_request_cache_duration, balances_request_timeout,
    concurrent_balance_token_requests, token_price_cache_duration,
};
use crate::providers::fiat::FiatInfoProvider;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::balances::models::{Balance, Balances, TokenPrice};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;

pub async fn balances(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    fiat: &str,
    trusted: bool,
    exclude_spam: bool,
) -> ApiResult<Balances> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    let fiat_info_provider = FiatInfoProvider::new(context);
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/balances/?trusted={}&exclude_spam={}",
        safe_address,
        trusted,
        exclude_spam
    )?;

    let body = RequestCached::new_from_context(url, context, ChainCache::from(chain_id))
        .cache_duration(balances_core_request_cache_duration())
        .request_timeout(balances_request_timeout())
        .execute()
        .await?;
    let backend_balances: Vec<BalanceDto> = serde_json::from_str(&body)?;

    let usd_to_fiat = fiat_info_provider
        .exchange_usd_to(fiat)
        .await
        .unwrap_or(BigDecimal::from(0));

    let native_currency: NativeCurrency = info_provider.chain_info().await?.native_currency;

    let mut total_fiat = 0.0;

    let token_prices: Vec<TokenPrice> =
        get_token_prices(context, &info_provider, &backend_balances).await;

    let mut service_balances: Vec<Balance> = backend_balances
        .iter()
        .map(|it| {
            let token_address: String = it
                .token_address
                .to_owned()
                .unwrap_or("0x0000000000000000000000000000000000000000".to_string());
            let token_price: Option<&TokenPrice> = token_prices
                .iter()
                .find(|&token_price| token_price.address == token_address);
            let token_to_usd: BigDecimal = token_price
                .and_then(|t| Some(t.fiat_price.to_owned()))
                .unwrap_or(BigDecimal::from(0));

            let balance = it.to_balance_v2(&token_to_usd, &usd_to_fiat, &native_currency);
            total_fiat += balance.fiat_balance.parse::<f64>().unwrap_or(0.0);
            balance
        })
        .collect::<Vec<Balance>>();

    service_balances.sort_by(|b1, b2| {
        BigDecimal::from_str(&b2.fiat_balance)
            .unwrap()
            .partial_cmp(&BigDecimal::from_str(&b1.fiat_balance).unwrap())
            .unwrap_or(Ordering::Equal)
    });

    Ok(Balances {
        fiat_total: total_fiat.to_string(),
        items: service_balances,
    })
}

async fn get_token_prices(
    context: &RequestContext,
    info_provider: &impl InfoProvider,
    backend_balances: &Vec<BalanceDto>,
) -> Vec<TokenPrice> {
    let token_addresses: Vec<String> = backend_balances
        .iter()
        .map(|balance| {
            balance
                .token_address
                .to_owned()
                .unwrap_or("0x0000000000000000000000000000000000000000".to_string())
        })
        .collect();

    // We collect the TokenPrice which were successful â€“ unsuccessful ones are ignored
    return stream::iter(token_addresses)
        .map(|token_address| get_token_usd_rate(context, token_address, info_provider))
        .buffer_unordered(concurrent_balance_token_requests())
        .filter_map(|t| async move {
            match t {
                Ok(token_price) => Some(token_price),
                Err(_) => None,
            }
        })
        .collect()
        .await;
}

/// Gets the [TokenPrice] of the token with address `token_address` for the chain `chain_id`
/// To retrieve the Native Currency fiat price of the chain (eg.: Ether), 0x0000000000000000000000000000000000000000 should be used
///
/// # Arguments
///
/// * `context`: The context where the request will be executed
/// * `chain_id`: The chain id on which this request should be executed
/// * `token_address`: The token address (0x0000000000000000000000000000000000000000 for native currency)
///
/// returns: Result<TokenPrice, ApiError>
async fn get_token_usd_rate(
    context: &RequestContext,
    token_address: String,
    info_provider: &impl InfoProvider,
) -> ApiResult<TokenPrice> {
    let url = core_uri!(info_provider, "/v1/tokens/{}/prices/usd/", token_address)?;

    let body =
        RequestCached::new_from_context(url, context, ChainCache::from(info_provider.chain_id()))
            .cache_duration(token_price_cache_duration())
            .execute()
            .await?;
    let response: BackendTokenPrice = serde_json::from_str(&body)?;

    return Ok(TokenPrice {
        address: token_address.to_string(),
        fiat_code: response.fiat_code,
        fiat_price: response.fiat_price,
        timestamp: response.timestamp,
    });
}

'''
'''--- src/routes/balances/mod.rs ---
#[doc(hidden)]
pub mod converters;
#[doc(hidden)]
pub mod converters_v2;
#[doc(hidden)]
pub mod handlers;
#[doc(hidden)]
pub mod handlers_v2;
pub mod models;
pub mod routes;

'''
'''--- src/routes/balances/models.rs ---
use crate::providers::info::TokenInfo;
use bigdecimal::BigDecimal;
use serde::Serialize;

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Balance {
    pub token_info: TokenInfo,
    pub balance: String,
    pub fiat_balance: String,
    pub fiat_conversion: String,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Balances {
    /// Aggregated fiat balance
    pub fiat_total: String,
    /// Individual [Balance] entries for each ERC20 in the Safe
    pub items: Vec<Balance>,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TokenPrice {
    pub address: String,
    pub fiat_code: String,
    pub fiat_price: BigDecimal,
    pub timestamp: String,
}

'''
'''--- src/routes/balances/routes.rs ---
use rocket::futures::FutureExt;
use rocket::response::content;

use crate::cache::cache_operations::CacheResponse;
use crate::cache::manager::ChainCache;
use crate::config::{balances_cache_duration, feature_flag_balances_rate_implementation};
use crate::routes::balances::handlers::fiat_codes;
use crate::routes::balances::{handlers, handlers_v2};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket_okapi::openapi;

/// `/v1/chains/<chain_id>/safes/<safe_address>/balances/<fiat>?<trusted>&<exclude_spam>`<br/>
/// Returns [Balances](crate::routes::balances::models::Balances)
///
/// # Balances
///
/// This endpoint returns the [Balances](crate::routes::balances::models::Balances) with information (when available) of their converted balance into a designated fiat. The entries are sorted by their fiat balance value.
///
/// The `fiat_code` can be selected from any of the values returned by the supported fiat endpoint.
///
/// The total balance in the designated fiat is also part of the response.
///
/// ## Path
///
/// - `/v1/chains/<chain_id>/safes/<safe_address>/balances/<fiat>?<trusted>&<exclude_spam>` returns the balance for every supported ERC20 token for a `<safe_address>`, as well as the aggregated fiat total in the fiat currency requested with `<fiat>` . Sorted by fiat balance.
///
/// ## Query parameters
///
/// - `<trusted>` : A token is defined as trusted by our core handlers process when adding them. Default value is `false`
/// - `<exclude_spam>`: A token is defined as spam by our core handlers process when adding them. Default value is `true`
#[openapi(tag = "Balances")]
#[get("/v1/chains/<chain_id>/safes/<safe_address>/balances/<fiat>?<trusted>&<exclude_spam>")]
pub async fn get_balances(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    fiat: String,
    trusted: Option<bool>,
    exclude_spam: Option<bool>,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .duration(balances_cache_duration())
        .resp_generator(|| {
            if feature_flag_balances_rate_implementation() {
                handlers_v2::balances(
                    &context,
                    chain_id.as_str(),
                    safe_address.as_str(),
                    fiat.as_str(),
                    trusted.unwrap_or(false),
                    exclude_spam.unwrap_or(true),
                )
                .left_future()
            } else {
                handlers::balances(
                    &context,
                    chain_id.as_str(),
                    safe_address.as_str(),
                    fiat.as_str(),
                    trusted.unwrap_or(false),
                    exclude_spam.unwrap_or(true),
                )
                .right_future()
            }
        })
        .execute()
        .await
}

/// `/v1/balances/supported-fiat-codes` <br/>
/// Returns [Vec] of [String]
///
/// Supported fiat codes for balances
/// `/v1/balances/supported-fiat-codes` : returns the supported fiat codes to be included int the `<fiat>` segment of the balance endpoint.
/// The entries are sorted alphabetically, with the exception of `USD` and `EUR` being placed in the top of the list in that order.
#[openapi(tag = "Balances")]
#[get("/v1/balances/supported-fiat-codes")]
pub async fn get_supported_fiat(context: RequestContext) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::Other)
        .resp_generator(|| fiat_codes(&context))
        .execute()
        .await
}

'''
'''--- src/routes/chains/converters.rs ---
use crate::common::models::backend::chains::{
    ChainInfo as BackendChainInfo, GasPrice, RpcAuthentication, RpcUri as BackendRpcUri,
};
use crate::routes::chains::models::{
    BlockExplorerUriTemplate as ServiceBlockExplorerUriTemplate, ChainInfo as ServiceChainInfo,
    GasPrice as ServiceGasPrice, NativeCurrency as ServiceNativeCurrency,
    RpcAuthentication as ServiceRpcAuthentication, RpcUri as ServiceRpcUri, Theme as ServiceTheme,
};

impl From<BackendChainInfo> for ServiceChainInfo {
    fn from(chain_info: BackendChainInfo) -> Self {
        Self {
            transaction_service: chain_info.transaction_service,
            chain_id: chain_info.chain_id,
            chain_name: chain_info.chain_name,
            short_name: chain_info.short_name,
            l2: chain_info.l2,
            description: chain_info.description,
            rpc_uri: chain_info.rpc_uri.into(),
            safe_apps_rpc_uri: chain_info.safe_apps_rpc_uri.into(),
            public_rpc_uri: chain_info.public_rpc_uri.into(),
            block_explorer_uri_template: ServiceBlockExplorerUriTemplate {
                address: chain_info.block_explorer_uri_template.address,
                tx_hash: chain_info.block_explorer_uri_template.tx_hash,
                api: chain_info.block_explorer_uri_template.api,
            },
            native_currency: ServiceNativeCurrency {
                name: chain_info.native_currency.name,
                symbol: chain_info.native_currency.symbol,
                decimals: chain_info.native_currency.decimals,
                logo_uri: chain_info.native_currency.logo_uri,
            },
            theme: ServiceTheme {
                text_color: chain_info.theme.text_color,
                background_color: chain_info.theme.background_color,
            },
            ens_registry_address: chain_info.ens_registry_address,
            gas_price: chain_info
                .gas_price
                .iter()
                .map(|gas_price| match gas_price {
                    GasPrice::Oracle {
                        uri,
                        gas_parameter,
                        gwei_factor,
                    } => ServiceGasPrice::Oracle {
                        uri: uri.to_string(),
                        gas_parameter: gas_parameter.to_string(),
                        gwei_factor: gwei_factor.to_string(),
                    },
                    GasPrice::Fixed { wei_value } => ServiceGasPrice::Fixed {
                        wei_value: wei_value.to_string(),
                    },
                    GasPrice::Unknown => ServiceGasPrice::Unknown,
                })
                .collect::<Vec<ServiceGasPrice>>(),
            disabled_wallets: chain_info.disabled_wallets,
            features: chain_info.features,
        }
    }
}

impl From<BackendRpcUri> for ServiceRpcUri {
    fn from(rpc_uri: BackendRpcUri) -> Self {
        ServiceRpcUri {
            authentication: match rpc_uri.authentication {
                RpcAuthentication::ApiKeyPath => ServiceRpcAuthentication::ApiKeyPath,
                RpcAuthentication::NoAuthentication => ServiceRpcAuthentication::NoAuthentication,
                RpcAuthentication::Unknown => ServiceRpcAuthentication::Unknown,
            },
            value: rpc_uri.value,
        }
    }
}

'''
'''--- src/routes/chains/handlers.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::backend::chains::ChainInfo as BackendChainInfo;
use crate::common::models::page::{Page, PageMetadata};
use crate::config::{chain_info_cache_duration, chain_info_request_timeout};
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::chains::models::ChainInfo as ServiceChainInfo;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::urls::build_absolute_uri;

pub async fn get_chains_paginated(
    context: &RequestContext,
    cursor: &Option<String>,
) -> ApiResult<Page<ServiceChainInfo>> {
    let page_metadata = cursor
        .as_ref()
        .map(|cursor| PageMetadata::from_cursor(cursor));
    let url = config_uri!(
        "/v1/chains/?{}",
        page_metadata
            .as_ref()
            .unwrap_or(&PageMetadata::default())
            .to_url_string()
    );

    let body = RequestCached::new_from_context(url, context, ChainCache::Other)
        .request_timeout(chain_info_request_timeout())
        .cache_duration(chain_info_cache_duration())
        .execute()
        .await?;

    let page = serde_json::from_str::<Page<BackendChainInfo>>(&body)?;

    Ok(page.map_inner(|link| map_link(context, link)))
}

pub async fn get_single_chain(
    context: &RequestContext,
    chain_id: &str,
) -> ApiResult<ServiceChainInfo> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    Ok(info_provider.chain_info().await?.into())
}

fn map_link(context: &RequestContext, original_link: Option<String>) -> Option<String> {
    original_link.as_ref().map(|link| {
        let cursor =
            PageMetadata::from_cursor(link.split("?").collect::<Vec<&str>>().get(1).unwrap_or(&""))
                .to_url_string();
        let uri = build_absolute_uri(
            context,
            uri!(crate::routes::chains::routes::get_chains(Some(cursor))),
        );
        String::from(uri)
    })
}

'''
'''--- src/routes/chains/mod.rs ---
#[doc(hidden)]
pub mod converters;
#[doc(hidden)]
pub mod handlers;
pub mod models;
pub mod routes;

#[cfg(test)]
mod tests;

'''
'''--- src/routes/chains/models.rs ---
use serde::Serialize;

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct ChainInfo {
    pub transaction_service: String,
    // do we need to expose this?
    pub chain_id: String,
    pub chain_name: String,
    pub short_name: String,
    pub l2: bool,
    pub description: String,
    pub rpc_uri: RpcUri,
    pub safe_apps_rpc_uri: RpcUri,
    pub public_rpc_uri: RpcUri,
    pub block_explorer_uri_template: BlockExplorerUriTemplate,
    pub native_currency: NativeCurrency,
    pub theme: Theme,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ens_registry_address: Option<String>,
    pub gas_price: Vec<GasPrice>,
    pub disabled_wallets: Vec<String>,
    pub features: Vec<String>,
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct NativeCurrency {
    pub name: String,
    pub symbol: String,
    pub decimals: u64,
    pub logo_uri: String,
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct Theme {
    pub text_color: String,
    pub background_color: String,
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(tag = "type")]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub enum GasPrice {
    #[serde(rename_all = "camelCase")]
    Oracle {
        uri: String,
        gas_parameter: String,
        gwei_factor: String,
    },
    #[serde(rename_all = "camelCase")]
    Fixed {
        wei_value: String,
    },
    Unknown,
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct RpcUri {
    pub authentication: RpcAuthentication,
    pub value: String,
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub enum RpcAuthentication {
    ApiKeyPath,
    NoAuthentication,
    #[serde(other)]
    Unknown,
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct BlockExplorerUriTemplate {
    pub address: String,
    pub tx_hash: String,
    pub api: String,
}

'''
'''--- src/routes/chains/routes.rs ---
use crate::cache::cache_operations::CacheResponse;
use crate::cache::manager::ChainCache;
use crate::config::chain_info_response_cache_duration;
use crate::routes::chains::handlers::{get_chains_paginated, get_single_chain};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::response::content;
use rocket_okapi::openapi;

/// `/v1/chains/<chain_id>/` <br/>
/// Returns [ChainInfo](crate::routes::chains::models::ChainInfo)
///
/// # Chains
///
/// This endpoint returns the [ChainInfo](crate::routes::chains::models::ChainInfo) for a given `chain_id`
///
/// ## Path
///
/// - `/v1/chains/<chain_id>/`returns the `ChainInfo` for `<chain_id>`
#[openapi(tag = "Chains")]
#[get("/v1/chains/<chain_id>")]
pub async fn get_chain(
    context: RequestContext,
    chain_id: String,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .duration(chain_info_response_cache_duration())
        .resp_generator(|| get_single_chain(&context, &chain_id))
        .execute()
        .await
}

/// `/v1/chains/` <br/>
/// Returns a [Page](crate::common::models::page::Page) of [ChainInfo](crate::routes::chains::models::ChainInfo)
///
/// # Chains
///
/// Returns a paginated list of all the supported [ChainInfo](crate::routes::chains::models::ChainInfo)
///
/// ## Path
///
/// - `/v1/chains/` Returns the `ChainInfo` for our services supported networks
#[openapi(tag = "Chains")]
#[get("/v1/chains?<cursor>")]
pub async fn get_chains(
    context: RequestContext,
    cursor: Option<String>,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::Other)
        .duration(chain_info_response_cache_duration())
        .resp_generator(|| get_chains_paginated(&context, &cursor))
        .execute()
        .await
}

'''
'''--- src/routes/chains/tests/chains.rs ---
use crate::common::models::backend::chains::{
    BlockExplorerUriTemplate, ChainInfo, GasPrice, NativeCurrency, RpcAuthentication, RpcUri, Theme,
};
use crate::routes::chains::models::{
    BlockExplorerUriTemplate as ServiceBlockExplorerUriTemplate, ChainInfo as ServiceChainInfo,
    GasPrice as ServiceGasPrice, NativeCurrency as ServiceNativeCurrency,
    RpcAuthentication as ServiceRpcAuthentication, RpcUri as ServiceRpcUri, Theme as ServiceTheme,
};

#[test]
fn chain_info_json() {
    let expected = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        vpc_transaction_service: "http://rinkeby-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: NativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![GasPrice::Oracle {
            uri: "https://gaspriceoracle.com/".to_string(),
            gas_parameter: "average".to_string(),
            gwei_factor: "10".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };

    let actual = serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY);

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn chain_info_json_with_fixed_gas_price() {
    let expected = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        vpc_transaction_service: "http://rinkeby-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: NativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#fff".to_string(),
            background_color: "#000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![GasPrice::Fixed {
            wei_value: "1000000000".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };

    let actual =
        serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY_FIXED_GAS_PRICE);

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn chain_info_json_with_no_gas_price() {
    let expected = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        vpc_transaction_service: "http://rinkeby-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: NativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#fff".to_string(),
            background_color: "#000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![],
        disabled_wallets: vec![],
        features: vec![],
    };

    let actual =
        serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY_NO_GAS_PRICE);

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn chain_info_json_with_multiple_gas_price() {
    let expected = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        vpc_transaction_service: "http://rinkeby-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: NativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#fff".to_string(),
            background_color: "#000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![
            GasPrice::Oracle {
                uri: "https://gaspriceoracle.com/".to_string(),
                gas_parameter: "average".to_string(),
                gwei_factor: "10".to_string(),
            },
            GasPrice::Fixed {
                wei_value: "1000000000".to_string(),
            },
        ],
        disabled_wallets: vec![],
        features: vec![],
    };

    let actual = serde_json::from_str::<ChainInfo>(
        crate::tests::json::CHAIN_INFO_RINKEBY_MULTIPLE_GAS_PRICE,
    );

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn chain_info_json_with_unknown_gas_price_type() {
    let expected = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        vpc_transaction_service: "http://rinkeby-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: NativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![GasPrice::Unknown],
        disabled_wallets: vec![],
        features: vec![],
    };

    let actual =
        serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY_UNKNOWN_GAS_PRICE);

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn chain_info_json_with_no_rpc_authentication() {
    let expected = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        vpc_transaction_service: "http://rinkeby-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::NoAuthentication,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: NativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![GasPrice::Oracle {
            uri: "https://gaspriceoracle.com/".to_string(),
            gas_parameter: "average".to_string(),
            gwei_factor: "10".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };

    let actual = serde_json::from_str::<ChainInfo>(
        crate::tests::json::CHAIN_INFO_RINKEBY_RPC_NO_AUTHENTICATION,
    );

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn chain_info_json_with_unknown_rpc_authentication() {
    let expected = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        vpc_transaction_service: "http://rinkeby-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::Unknown,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: NativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![GasPrice::Oracle {
            uri: "https://gaspriceoracle.com/".to_string(),
            gas_parameter: "average".to_string(),
            gwei_factor: "10".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };

    let actual = serde_json::from_str::<ChainInfo>(
        crate::tests::json::CHAIN_INFO_RINKEBY_RPC_UNKNOWN_AUTHENTICATION,
    );

    assert!(actual.is_ok());
    assert_eq!(expected, actual.unwrap());
}

#[test]
fn chain_info_json_to_service_chain_info() {
    let expected = ServiceChainInfo {
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: ServiceBlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: ServiceNativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: ServiceTheme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![ServiceGasPrice::Oracle {
            uri: "https://gaspriceoracle.com/".to_string(),
            gas_parameter: "average".to_string(),
            gwei_factor: "10".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };

    let from_json =
        serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY).unwrap();
    let actual: ServiceChainInfo = from_json.into();

    assert_eq!(expected, actual);
}

#[test]
fn unknown_gas_price_type_to_service_chain_info() {
    let expected = ServiceChainInfo {
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: ServiceBlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: ServiceNativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: ServiceTheme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![ServiceGasPrice::Unknown],
        disabled_wallets: vec![],
        features: vec![],
    };

    let from_json =
        serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY_UNKNOWN_GAS_PRICE)
            .unwrap();
    let actual: ServiceChainInfo = from_json.into();

    assert_eq!(expected, actual);
}

#[test]
fn no_authentication_to_service_chain_info() {
    let expected = ServiceChainInfo {
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::NoAuthentication,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: ServiceBlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: ServiceNativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: ServiceTheme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![ServiceGasPrice::Oracle {
            uri: "https://gaspriceoracle.com/".to_string(),
            gas_parameter: "average".to_string(),
            gwei_factor: "10".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };

    let from_json = serde_json::from_str::<ChainInfo>(
        crate::tests::json::CHAIN_INFO_RINKEBY_RPC_NO_AUTHENTICATION,
    )
    .unwrap();
    let actual: ServiceChainInfo = from_json.into();

    assert_eq!(expected, actual);
}

#[test]
fn unknown_authentication_to_service_chain_info() {
    let expected = ServiceChainInfo {
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::Unknown,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: ServiceBlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: ServiceNativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: ServiceTheme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![ServiceGasPrice::Oracle {
            uri: "https://gaspriceoracle.com/".to_string(),
            gas_parameter: "average".to_string(),
            gwei_factor: "10".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };

    let from_json = serde_json::from_str::<ChainInfo>(
        crate::tests::json::CHAIN_INFO_RINKEBY_RPC_UNKNOWN_AUTHENTICATION,
    )
    .unwrap();
    let actual: ServiceChainInfo = from_json.into();

    assert_eq!(expected, actual);
}

#[test]
fn disabled_wallets_to_service_chain_info() {
    let expected = ServiceChainInfo {
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: ServiceBlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: ServiceNativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: ServiceTheme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![ServiceGasPrice::Oracle {
            uri: "https://gaspriceoracle.com/".to_string(),
            gas_parameter: "average".to_string(),
            gwei_factor: "10".to_string(),
        }],
        disabled_wallets: vec![String::from("metamask"), String::from("trezor")],
        features: vec![],
    };

    let from_json =
        serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY_DISABLED_WALLETS)
            .unwrap();
    let actual: ServiceChainInfo = from_json.into();

    assert_eq!(expected, actual);
}

#[test]
fn features_to_service_chain_info() {
    let expected = ServiceChainInfo {
        transaction_service: "https://safe-transaction.rinkeby.staging.gnosisdev.com".to_string(),
        chain_id: "4".to_string(),
        chain_name: "Rinkeby".to_string(),
        short_name: "rin".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc".to_string(),
        },
        safe_apps_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/apps".to_string(),
        },
        public_rpc_uri: ServiceRpcUri {
            authentication: ServiceRpcAuthentication::ApiKeyPath,
            value: "https://someurl.com/rpc/public".to_string(),
        },
        block_explorer_uri_template: ServiceBlockExplorerUriTemplate {
            address: "https://blockexplorer.com/{{address}}".to_string(),
            tx_hash: "https://blockexplorer.com/{{txHash}}".to_string(),
            api: "https://blockexplorer.com/api".to_string(),
        },
        native_currency: ServiceNativeCurrency {
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            decimals: 18,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: ServiceTheme {
            text_color: "#ffffff".to_string(),
            background_color: "#000000".to_string(),
        },
        ens_registry_address: Some("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF".to_string()),
        gas_price: vec![ServiceGasPrice::Oracle {
            uri: "https://gaspriceoracle.com/".to_string(),
            gas_parameter: "average".to_string(),
            gwei_factor: "10".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![String::from("Feature 1"), String::from("Feature 2")],
    };

    let from_json =
        serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY_ENABLED_FEATURES)
            .unwrap();
    let actual: ServiceChainInfo = from_json.into();

    assert_eq!(expected, actual);
}

'''
'''--- src/routes/chains/tests/json/backend_chains_info_page.json ---
{
    "count": 3,
    "next": "https://safe-config.safe.global/api/v1/chains/?limit=1&offset=2",
    "previous": "https://safe-config.safe.global/api/v1/chains/?limit=1",
    "results": [
        {
            "chainId": "137",
            "chainName": "Polygon",
            "shortName": "matic",
            "description": "Test",
            "l2": true,
            "rpcUri": {
                "authentication": "API_KEY_PATH",
                "value": "https://polygon-mainnet.infura.io/v3/"
            },
            "safeAppsRpcUri": {
                "authentication": "API_KEY_PATH",
                "value": "https://polygon-mainnet.infura.io/v3/"
            },
            "publicRpcUri": {
                "authentication": "NO_AUTHENTICATION",
                "value": "https://polygon-rpc.com/"
            },
            "blockExplorerUriTemplate": {
                "address": "https://polygonscan.com/address/{{address}}",
                "txHash": "https://polygonscan.com/tx/{{txHash}}",
                "api": "https://api.polygonscan.com/api?module={{module}}&action={{action}}&address={{address}}&apiKey={{apiKey}}"
            },
            "nativeCurrency": {
                "name": "Matic",
                "symbol": "MATIC",
                "decimals": 18,
                "logoUri": "https://safe-transaction-assets.staging.gnosisdev.com/chains/137/currency_logo.png"
            },
            "transactionService": "https://safe-transaction-polygon.staging.gnosisdev.com",
            "vpcTransactionService": "http://staging-polygon-safe-transaction-web.safe.svc.cluster.local",
            "theme": {
                "textColor": "#ffffff",
                "backgroundColor": "#8248E5"
            },
            "gasPrice": [
                {
                    "type": "oracle",
                    "uri": "https://gasstation-mainnet.matic.network",
                    "gasParameter": "standard",
                    "gweiFactor": "1000000000.000000000"
                }
            ],
            "ensRegistryAddress": null,
            "recommendedMasterCopyVersion": "1.3.0",
            "disabledWallets": [
                "authereum",
                "coinbase",
                "fortmatic",
                "keystone",
                "lattice",
                "opera",
                "operaTouch",
                "portis",
                "torus",
                "trezor",
                "trust",
                "walletLink"
            ],
            "features": [
                "CONTRACT_INTERACTION",
                "ERC721",
                "SAFE_APPS",
                "SAFE_TX_GAS_OPTIONAL"
            ]
        }
    ]
}

'''
'''--- src/routes/chains/tests/json/expected_chains_info_page.json ---
{
    "next": "http://test.safe.global/api/v1/chains?cursor=limit%3D1%26offset%3D2",
    "previous": "http://test.safe.global/api/v1/chains?cursor=limit%3D1%26offset%3D0",
    "results": [
        {
            "transactionService": "https://safe-transaction-polygon.staging.gnosisdev.com",
            "chainId": "137",
            "chainName": "Polygon",
            "shortName": "matic",
            "l2": true,
            "description": "Test",
            "rpcUri": {
                "authentication": "API_KEY_PATH",
                "value": "https://polygon-mainnet.infura.io/v3/"
            },
            "safeAppsRpcUri": {
                "authentication": "API_KEY_PATH",
                "value": "https://polygon-mainnet.infura.io/v3/"
            },
            "publicRpcUri": {
                "authentication": "NO_AUTHENTICATION",
                "value": "https://polygon-rpc.com/"
            },
            "blockExplorerUriTemplate": {
                "address": "https://polygonscan.com/address/{{address}}",
                "txHash": "https://polygonscan.com/tx/{{txHash}}",
                "api": "https://api.polygonscan.com/api?module={{module}}&action={{action}}&address={{address}}&apiKey={{apiKey}}"
            },
            "nativeCurrency": {
                "name": "Matic",
                "symbol": "MATIC",
                "decimals": 18,
                "logoUri": "https://safe-transaction-assets.staging.gnosisdev.com/chains/137/currency_logo.png"
            },
            "theme": {
                "textColor": "#ffffff",
                "backgroundColor": "#8248E5"
            },
            "gasPrice": [
                {
                    "type": "ORACLE",
                    "uri": "https://gasstation-mainnet.matic.network",
                    "gasParameter": "standard",
                    "gweiFactor": "1000000000.000000000"
                }
            ],
            "disabledWallets": [
                "authereum",
                "coinbase",
                "fortmatic",
                "keystone",
                "lattice",
                "opera",
                "operaTouch",
                "portis",
                "torus",
                "trezor",
                "trust",
                "walletLink"
            ],
            "features": [
                "CONTRACT_INTERACTION",
                "ERC721",
                "SAFE_APPS",
                "SAFE_TX_GAS_OPTIONAL"
            ]
        }
    ]
}
'''
'''--- src/routes/chains/tests/mod.rs ---
mod chains;
mod routes;

pub(super) const BACKEND_CHAINS_INFO_PAGE: &str =
    include_str!("json/backend_chains_info_page.json");
pub(super) const EXPECTED_CHAINS_INFO_PAGE: &str =
    include_str!("json/expected_chains_info_page.json");

'''
'''--- src/routes/chains/tests/routes.rs ---
use crate::common::models::backend::chains::ChainInfo as BackendChainInfo;
use crate::common::models::page::Page;
use crate::config::chain_info_request_timeout;
use crate::routes::chains::models::ChainInfo;
use crate::tests::main::setup_rocket;
use crate::utils::http_client::{MockHttpClient, Request, Response};
use mockall::predicate::eq;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;

use std::time::Duration;

#[rocket::async_test]
async fn paginated_chain_infos() {
    let request_uri = config_uri!("/v1/chains/?limit=1&offset=1");

    let mut mock_http_client = MockHttpClient::new();
    let mut chain_request = Request::new(request_uri.clone());
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(super::BACKEND_CHAINS_INFO_PAGE),
            })
        });

    let client = Client::tracked(
        setup_rocket(mock_http_client, routes![super::super::routes::get_chains]).await,
    )
    .await
    .expect("valid rocket instance");
    let expected =
        serde_json::from_str::<Page<ChainInfo>>(super::EXPECTED_CHAINS_INFO_PAGE).unwrap();

    let request = client
        .get("/v1/chains?cursor=limit%3D1%26offset%3D1")
        .header(Header::new("Host", "test.safe.global/api"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json_body = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<Page<ChainInfo>>(&actual_json_body).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn single_chain_info() {
    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();
        mock_http_client
            .expect_get()
            .times(1)
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
                })
            });
        mock_http_client
    };

    let client = Client::tracked(
        setup_rocket(mock_http_client, routes![super::super::routes::get_chain]).await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/v1/chains/4");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };
    let expected: ChainInfo =
        serde_json::from_str::<BackendChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY)
            .unwrap()
            .into();

    let actual_status = response.status();
    let actual_json_body = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<ChainInfo>(&actual_json_body).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

'''
'''--- src/routes/collectibles/handlers.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::page::{Page, PageMetadata};
use crate::config::collectibles_request_timeout;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::collectibles::models::Collectible as ServiceCollectible;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::urls::build_absolute_uri;
use rocket::response::content::RawJson;
use rocket::serde::json::Json;

pub async fn collectibles(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    trusted: Option<bool>,
    exclude_spam: Option<bool>,
) -> ApiResult<RawJson<String>> {
    let info_provider = DefaultInfoProvider::new(chain_id, &context);

    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/collectibles/?trusted={}&exclude_spam={}",
        safe_address,
        trusted.unwrap_or(false),
        exclude_spam.unwrap_or(true)
    )?;

    Ok(RawJson(
        RequestCached::new_from_context(url, &context, ChainCache::from(chain_id))
            .request_timeout(collectibles_request_timeout())
            .execute()
            .await?,
    ))
}

/// Returns paginated collectibles.
pub async fn collectibles_paginated(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    cursor: &Option<String>,
    trusted: Option<bool>,
    exclude_spam: Option<bool>,
) -> ApiResult<Json<Page<ServiceCollectible>>> {
    let info_provider = DefaultInfoProvider::new(chain_id, &context);
    let page_metadata = cursor
        .as_ref()
        .map(|cursor| PageMetadata::from_cursor(cursor))
        .as_ref()
        .unwrap_or(&PageMetadata::default())
        .to_url_string();

    let url = core_uri!(
        info_provider,
        "/v2/safes/{}/collectibles/?{}&trusted={}&exclude_spam={}",
        safe_address,
        page_metadata,
        trusted.unwrap_or(false),
        exclude_spam.unwrap_or(true)
    )?;

    let body = RequestCached::new_from_context(url, &context, ChainCache::from(chain_id))
        .request_timeout(collectibles_request_timeout())
        .execute()
        .await?;

    let page = serde_json::from_str::<Page<ServiceCollectible>>(&body)?;

    Ok(Json(page.map_inner(|link| {
        map_link(
            context,
            link,
            chain_id.to_string(),
            safe_address.to_string(),
            trusted,
            exclude_spam,
        )
    })))
}

fn map_link(
    context: &RequestContext,
    original_link: Option<String>,
    chain_id: String,
    safe_address: String,
    trusted: Option<bool>,
    exclude_spam: Option<bool>,
) -> Option<String> {
    original_link.as_ref().map(|link| {
        let cursor =
            PageMetadata::from_cursor(link.split("?").collect::<Vec<&str>>().get(1).unwrap_or(&""))
                .to_url_string();
        let uri = build_absolute_uri(
            context,
            uri!(
                crate::routes::collectibles::routes::get_collectibles_paginated(
                    chain_id,
                    safe_address,
                    Some(cursor),
                    trusted,
                    exclude_spam
                )
            ),
        );
        String::from(uri)
    })
}

'''
'''--- src/routes/collectibles/mod.rs ---
#[doc(hidden)]
pub mod handlers;
pub mod models;
pub mod routes;

#[cfg(test)]
mod tests;

'''
'''--- src/routes/collectibles/models.rs ---
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct Collectible {
    address: String,
    token_name: String,
    token_symbol: String,
    logo_uri: String,
    id: String,
    uri: Option<String>,
    name: Option<String>,
    description: Option<String>,
    image_uri: Option<String>,
    metadata: Option<serde_json::Value>,
}

'''
'''--- src/routes/collectibles/routes.rs ---
use crate::common::models::page::Page;
use crate::routes::collectibles::handlers::collectibles;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::response::content;
use rocket::serde::json::Json;
use rocket_okapi::openapi;

use super::handlers::collectibles_paginated;
use super::models::Collectible;
/// `/v1/chains/<chain_id>/safes/<safe_address>/collectibles?<trusted>&<exclude_spam>` <br />
/// Returns collectibles from the transaction handlers
///
/// # Collectibles
///
/// The collectibles endpoint does not implement any logic in the client-gateway. The response from the core services is cached and then forwarded to the clients.
///
/// ## Path
///
/// - `/v1/chains/<chain_id>/safes/<safe_address>/collectibles?<trusted>&<exclude_spam>` : Returns a list of the ERC721 tokens stored in a safe
///
/// ## Query parameters
///
/// `<trusted>` : A token is defined as trusted by our core handlers process when adding them. Default value is `false`
/// `<exclude_spam>`: A token is defined as spam by our core handlers process when adding them. Default value is `true`
///
/// ## Models
///
///
/// ```json
/// [
///   {
///     "address": "string",
///     "tokenName": "string",
///     "tokenSymbol": "string",
///     "logoUri": "string",
///     "id": "string",
///     "uri": "string",
///     "name": "string",
///     "description": "string",
///     "imageUri": "string",
///     "metadata": {
///       "additionalProp1": "string",
///       "additionalProp2": "string",
///       "additionalProp3": "string"
///     }
///   }
/// ]
/// ```
///
/// ## JSON
///
/// <details>
/// <summary>Full response</summary>
///
/// ```json
/// [
///   {
///     "address": "0xD753e03c05533F85bA9695C139771b1E9698a53C",
///     "tokenName": "Main",
///     "tokenSymbol": "JOSE",
///     "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD753e03c05533F85bA9695C139771b1E9698a53C.png",
///     "id": "2",
///     "uri": "https://arweave.net/8Vje5kmuRKaJwYht19rl-tEte9J8WifCrXoCwAB2IK8",
///     "name": "Chiken dinner",
///     "description": "This token is meant for testing. ",
///     "imageUri": "https://arweave.net/a_poR6wHyGUortY2G3ITFmpQJOsRGJUXngpUAharq8I",
///     "metadata": {
///       "minter": "0x4d3101d77aac1b90ae42efa38d235a81af270d40",
///       "mintedOn": "2020-12-29T13:49:02.654Z",
///       "contractAddress": "0xd753e03c05533f85ba9695c139771b1e9698a53c",
///       "minted": "Minted on Mintbase.io",
///       "fiatPrice": "$0.00",
///       "name": "Chiken dinner",
///       "description": "This token is meant for testing. ",
///       "youtubeUrl": "",
///       "price": 0,
///       "ethPrice": "0",
///       "amountToMint": "5",
///       "visibility": "safe",
///       "forSale": false,
///       "image": "https://arweave.net/a_poR6wHyGUortY2G3ITFmpQJOsRGJUXngpUAharq8I",
///       "attributes": [],
///       "category": "DQFi8lDeEyqqoAOPesJb",
///       "externalUrl": "https://mintbase.io/my-market/0xd753e03c05533f85ba9695c139771b1e9698a53c",
///       "type": "ERC721"
///     }
///   },
///   {
///     "address": "0xD753e03c05533F85bA9695C139771b1E9698a53C",
///     "tokenName": "Main",
///     "tokenSymbol": "JOSE",
///     "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD753e03c05533F85bA9695C139771b1E9698a53C.png",
///     "id": "4",
///     "uri": "https://arweave.net/8Vje5kmuRKaJwYht19rl-tEte9J8WifCrXoCwAB2IK8",
///     "name": "Chiken dinner",
///     "description": "This token is meant for testing. ",
///     "imageUri": "https://arweave.net/a_poR6wHyGUortY2G3ITFmpQJOsRGJUXngpUAharq8I",
///     "metadata": {
///       "minter": "0x4d3101d77aac1b90ae42efa38d235a81af270d40",
///       "mintedOn": "2020-12-29T13:49:02.654Z",
///       "contractAddress": "0xd753e03c05533f85ba9695c139771b1e9698a53c",
///       "minted": "Minted on Mintbase.io",
///       "fiatPrice": "$0.00",
///       "name": "Chiken dinner",
///       "description": "This token is meant for testing. ",
///       "youtubeUrl": "",
///       "price": 0,
///       "ethPrice": "0",
///       "amountToMint": "5",
///       "visibility": "safe",
///       "forSale": false,
///       "image": "https://arweave.net/a_poR6wHyGUortY2G3ITFmpQJOsRGJUXngpUAharq8I",
///       "attributes": [],
///       "category": "DQFi8lDeEyqqoAOPesJb",
///       "externalUrl": "https://mintbase.io/my-market/0xd753e03c05533f85ba9695c139771b1e9698a53c",
///       "type": "ERC721"
///     }
///   },
///   {
///     "address": "0xD753e03c05533F85bA9695C139771b1E9698a53C",
///     "tokenName": "Main",
///     "tokenSymbol": "JOSE",
///     "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD753e03c05533F85bA9695C139771b1E9698a53C.png",
///     "id": "5",
///     "uri": "https://arweave.net/8Vje5kmuRKaJwYht19rl-tEte9J8WifCrXoCwAB2IK8",
///     "name": "Chiken dinner",
///     "description": "This token is meant for testing. ",
///     "imageUri": "https://arweave.net/a_poR6wHyGUortY2G3ITFmpQJOsRGJUXngpUAharq8I",
///     "metadata": {
///       "minter": "0x4d3101d77aac1b90ae42efa38d235a81af270d40",
///       "mintedOn": "2020-12-29T13:49:02.654Z",
///       "contractAddress": "0xd753e03c05533f85ba9695c139771b1e9698a53c",
///       "minted": "Minted on Mintbase.io",
///       "fiatPrice": "$0.00",
///       "name": "Chiken dinner",
///       "description": "This token is meant for testing. ",
///       "youtubeUrl": "",
///       "price": 0,
///       "ethPrice": "0",
///       "amountToMint": "5",
///       "visibility": "safe",
///       "forSale": false,
///       "image": "https://arweave.net/a_poR6wHyGUortY2G3ITFmpQJOsRGJUXngpUAharq8I",
///       "attributes": [],
///       "category": "DQFi8lDeEyqqoAOPesJb",
///       "externalUrl": "https://mintbase.io/my-market/0xd753e03c05533f85ba9695c139771b1e9698a53c",
///       "type": "ERC721"
///     }
///   }
/// ]
/// ```
/// </details>
#[openapi(tag = "Collectibles")]
#[get("/v1/chains/<chain_id>/safes/<safe_address>/collectibles?<trusted>&<exclude_spam>")]
pub async fn get_collectibles(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    trusted: Option<bool>,
    exclude_spam: Option<bool>,
) -> ApiResult<content::RawJson<String>> {
    collectibles(
        &context,
        chain_id.as_str(),
        safe_address.as_str(),
        trusted,
        exclude_spam,
    )
    .await
}

/// `/v2/chains/<chain_id>/safes/<safe_address>/collectibles?<cursor>&<trusted>&<exclude_spam>` <br />
/// Returns collectibles paginated
///
/// # Collectibles
///
/// The collectibles endpoint does not implement any logic in the client-gateway. The response from the core services is cached and then forwarded to the clients.
///
/// ## Path
///
/// - `/v1/chains/<chain_id>/safes/<safe_address>/collectibles?<cursor>&<trusted>&<exclude_spam>` : Returns a list of the ERC721 tokens stored in a safe
///
/// ## Query parameters
///
/// `<cursor>` : Pagination parameters (limit and offset)
/// `<trusted>` : A token is defined as trusted by our core handlers process when adding them. Default value is `false`
/// `<exclude_spam>`: A token is defined as spam by our core handlers process when adding them. Default value is `true`
#[openapi(tag = "Collectibles")]
#[get("/v2/chains/<chain_id>/safes/<safe_address>/collectibles?<cursor>&<trusted>&<exclude_spam>")]
pub async fn get_collectibles_paginated(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    cursor: Option<String>,
    trusted: Option<bool>,
    exclude_spam: Option<bool>,
) -> ApiResult<Json<Page<Collectible>>> {
    collectibles_paginated(
        &context,
        chain_id.as_str(),
        safe_address.as_str(),
        &cursor,
        trusted,
        exclude_spam,
    )
    .await
}

'''
'''--- src/routes/collectibles/tests/mod.rs ---
mod routes;

'''
'''--- src/routes/collectibles/tests/routes.rs ---
use crate::common::models::page::Page;
use crate::config::{chain_info_request_timeout, collectibles_request_timeout};
use crate::routes::collectibles::models::Collectible;
use crate::tests::json::{
    COLLECTIBLES_PAGINATED_EMPTY_CGW, COLLECTIBLES_PAGINATED_EMPTY_TXS,
    COLLECTIBLES_PAGINATED_ONE_CGW, COLLECTIBLES_PAGINATED_ONE_TXS, COLLECTIBLES_PAGINATED_TWO_CGW,
    COLLECTIBLES_PAGINATED_TWO_TXS,
};
use crate::tests::main::setup_rocket;
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::{MockHttpClient, Request, Response};
use core::time::Duration;
use mockall::predicate::eq;
use rocket::http::{Header, Status};
use rocket::local::asynchronous::Client;
use serde_json::json;

#[rocket::async_test]
async fn collectibles() {
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut collectibles_request = Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles/?trusted=false&exclude_spam=true"));
    collectibles_request.timeout(Duration::from_millis(collectibles_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(collectibles_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::COLLECTIBLES_PAGE),
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_collectibles],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client
            .get("/v1/chains/4/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::Ok);
    assert_eq!(
        response.into_string().await.unwrap(),
        crate::tests::json::COLLECTIBLES_PAGE
    );
}

#[rocket::async_test]
async fn collectibles_not_found() {
    let backend_error_json = json!({"details": "Not found"}).to_string();
    let error = ErrorDetails {
        code: 1337,
        message: Some(backend_error_json.clone()),
        arguments: None,
        debug: None,
    };

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut collectibles_request = Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles/?trusted=false&exclude_spam=true"));
    collectibles_request.timeout(Duration::from_millis(collectibles_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(collectibles_request))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: backend_error_json.clone(),
            }))
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_collectibles],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client
            .get("/v1/chains/4/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::NotFound);
    assert_eq!(
        response.into_string().await.unwrap(),
        serde_json::to_string(&error).unwrap()
    );
}

#[rocket::async_test]
async fn collectibles_paginated_empty() {
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    // TEST empty answer
    let mut collectibles_request = Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v2/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles/?limit=10&offset=0&trusted=false&exclude_spam=true"));
    collectibles_request.timeout(Duration::from_millis(collectibles_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(collectibles_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(COLLECTIBLES_PAGINATED_EMPTY_TXS),
            })
        });
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_collectibles_paginated],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let response = {
        let mut response = client
            .get("/v2/chains/4/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles?cursor=limit%3D10%26offset%3D0&trusted=false&exclude_spam=true");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::Ok);
    let expected =
        serde_json::from_str::<Page<Collectible>>(COLLECTIBLES_PAGINATED_EMPTY_CGW).unwrap();
    let actual =
        serde_json::from_str::<Page<Collectible>>(&response.into_string().await.unwrap()).unwrap();
    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn collectibles_paginated_page_one() {
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    // TEST response page one with
    let mut collectibles_request = Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v2/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles/?limit=3&offset=0&trusted=false&exclude_spam=true"));
    collectibles_request.timeout(Duration::from_millis(collectibles_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(collectibles_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(COLLECTIBLES_PAGINATED_ONE_TXS),
            })
        });
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_collectibles_paginated],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let response = {
        let mut response = client
            .get("/v2/chains/4/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles?cursor=limit%3D3%26offset%3D0&trusted=false&exclude_spam=true");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::Ok);
    let expected =
        serde_json::from_str::<Page<Collectible>>(COLLECTIBLES_PAGINATED_ONE_CGW).unwrap();
    let actual =
        serde_json::from_str::<Page<Collectible>>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual, expected);
}

// Test second and last page
#[rocket::async_test]
async fn collectibles_paginated_page_two() {
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    // TEST response page one with
    let mut collectibles_request = Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v2/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles/?limit=3&offset=3&trusted=false&exclude_spam=true"));
    collectibles_request.timeout(Duration::from_millis(collectibles_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(collectibles_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(COLLECTIBLES_PAGINATED_TWO_TXS),
            })
        });
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_collectibles_paginated],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let response = {
        let mut response = client
            .get("/v2/chains/4/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles?cursor=limit%3D3%26offset%3D3&trusted=false&exclude_spam=true");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::Ok);
    let expected =
        serde_json::from_str::<Page<Collectible>>(COLLECTIBLES_PAGINATED_TWO_CGW).unwrap();
    let actual =
        serde_json::from_str::<Page<Collectible>>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual, expected);
}

'''
'''--- src/routes/contracts/handlers.rs ---
use crate::common::models::data_decoded::DataDecoded;
use crate::providers::address_info::ContractInfo;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::contracts::models::DataDecoderRequest;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::Request;
use serde_json::json;

pub async fn request_data_decoded(
    context: &RequestContext,
    chain_id: &str,
    data_decoder_request: &DataDecoderRequest,
) -> ApiResult<DataDecoded> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    let client = context.http_client();
    let url = core_uri!(info_provider, "/v1/data-decoder/")?;
    let body = json!({"data": &data_decoder_request.data});

    let request = {
        let mut request = Request::new(url);
        request.body(Some(body.to_string()));
        request
    };

    let response_body = client.post(request).await?.body;
    Ok(serde_json::from_str::<DataDecoded>(&response_body)?)
}

pub async fn get_contract(
    context: &RequestContext,
    chain_id: &str,
    contract_address: &str,
) -> ApiResult<ContractInfo> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    info_provider.contract_info(contract_address).await
}

'''
'''--- src/routes/contracts/mod.rs ---
#[doc(hidden)]
pub mod handlers;
pub mod models;
pub mod routes;

#[cfg(test)]
mod tests;

'''
'''--- src/routes/contracts/models.rs ---
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct DataDecoderRequest {
    pub data: String,
    pub to: Option<String>,
}

'''
'''--- src/routes/contracts/routes.rs ---
use crate::cache::cache_operations::CacheResponse;
use crate::cache::manager::ChainCache;
use crate::routes::contracts::handlers;
use crate::routes::contracts::models::DataDecoderRequest;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::response::content;
use rocket::serde::json::{Error, Json};
use rocket_okapi::openapi;
/// `/v1/chains/<chain_id>/data-decoder` <br/>
/// Returns [DataDecoded](crate::common::models::data_decoded::DataDecoded)
///
/// # Data Decoder
///
/// This endpoint requires the client to send in the body of the request a hexadecimal `String` containing the `data` field of a transaction for decoding
///
/// The result is of the type [DataDecoded](crate::common::models::data_decoded::DataDecoded)
///
/// ## Path
///
/// - `/v1/chains/<chain_id>/data-decoder`
///
/// ## Examples
///
/// Example request body:
///
/// ```json
/// {
///   "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"
/// }
/// ```
/// This results in:
///
/// ```json
/// {
///   "method": "approve",
///   "parameters": [
///    {
///       "name": "spender",
///       "type": "address",
///       "value": "0xae9844F89D98c150F5e61bfC676D68b492155990"
///     },
///     {
///       "name": "value",
///       "type": "uint256",
///       "value": "500000000000000"
///     }
///   ]
/// }
/// ```
// TODO add to swagger
#[post(
    "/v1/chains/<chain_id>/data-decoder",
    format = "application/json",
    data = "<data_decoder_request>"
)]
pub async fn post_data_decoder<'e>(
    context: RequestContext,
    chain_id: String,
    data_decoder_request: Result<Json<DataDecoderRequest>, Error<'e>>,
) -> ApiResult<content::RawJson<String>> {
    Ok(content::RawJson(serde_json::to_string(
        &handlers::request_data_decoded(&context, &chain_id, &data_decoder_request?.0).await?,
    )?))
}

/// `/v1/chains/<chain_id>/contracts/<address>` <br/>
/// Returns [ContractInfo](crate::providers::address_info::ContractInfo)
///
/// # Contract Info
///
/// This endpoint is chain dependant and returns the details of a Contract such as: name, logoUri, ABI, among others
///
/// The result is of the type [ContractInfo](crate::providers::address_info::ContractInfo)
///
/// ## Path
///
/// - `GET /v1/chains/<chain_id>/contract/<contract_address>`
#[openapi(tag = "Contracts")]
#[get("/v1/chains/<chain_id>/contracts/<contract_address>")]
pub async fn get_contract(
    context: RequestContext,
    chain_id: String,
    contract_address: String,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| handlers::get_contract(&context, &chain_id, &contract_address))
        .execute()
        .await
}

'''
'''--- src/routes/contracts/tests/mod.rs ---
mod routes;

'''
'''--- src/routes/contracts/tests/routes.rs ---
use crate::common::models::data_decoded::DataDecoded;
use crate::config::{chain_info_request_timeout, contract_info_request_timeout};
use crate::providers::address_info::ContractInfo;
use crate::tests::main::setup_rocket;
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::{MockHttpClient, Request, Response};
use core::time::Duration;
use mockall::predicate::eq;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;
use serde_json::json;

#[rocket::async_test]
async fn data_decoded() {
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut collectibles_request = Request::new(String::from(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/data-decoder/",
    ));
    collectibles_request.body(Some(
        json!({
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"
        }).to_string()
    ));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(collectibles_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::DATA_DECODED_APPROVE),
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_data_decoder],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let request  = client.post("/v1/chains/4/data-decoder")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON)
        .body(&json!({"data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"}).to_string());

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual =
        serde_json::from_str::<DataDecoded>(&response.into_string().await.unwrap()).unwrap();
    let expected =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_APPROVE).unwrap();
    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn data_decoded_error() {
    let backend_error_json = json!({"details": "Not found"}).to_string();
    let error = ErrorDetails {
        code: 1337,
        message: Some(backend_error_json.clone()),
        arguments: None,
        debug: None,
    };

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut collectibles_request = Request::new(String::from(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/data-decoder/",
    ));
    collectibles_request.body(Some(
        json!({
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"
        }).to_string()
    ));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(collectibles_request))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: backend_error_json.clone(),
            }))
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_data_decoder],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let request  = client.post("/v1/chains/4/data-decoder")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON)
        .body(&json!({"data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"}).to_string());

    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::NotFound);
    assert_eq!(
        response.into_string().await.unwrap(),
        serde_json::to_string(&error).unwrap()
    );
}

#[rocket::async_test]
async fn get_contract() {
    let bip_contract_address = "0x00000000000045166C45aF0FC6E4Cf31D9E14B9A";
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut contract_info_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/contracts/{}/",
        &bip_contract_address
    ));
    contract_info_request.timeout(Duration::from_millis(contract_info_request_timeout()));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(contract_info_request))
        .returning(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CONTRACT_INFO_BID),
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_contract],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .get(format!("/v1/chains/4/contracts/{}", &bip_contract_address))
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;
    let actual_status = response.status();
    let actual =
        serde_json::from_str::<ContractInfo>(&response.into_string().await.unwrap()).unwrap();
    let expected =
        serde_json::from_str::<ContractInfo>(crate::tests::json::CONTRACT_INFO_BID).unwrap();

    assert_eq!(Status::Ok, actual_status);
    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn get_contract_not_found() {
    let backend_error_json = json!({"details": "Not found"}).to_string();
    let error = ErrorDetails {
        code: 1337,
        message: Some(backend_error_json.clone()),
        arguments: None,
        debug: None,
    };
    let bip_contract_address = "0x00000000000045166C45aF0FC6E4Cf31D9E14B9A";
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut contract_info_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/contracts/{}/",
        &bip_contract_address
    ));
    contract_info_request.timeout(Duration::from_millis(contract_info_request_timeout()));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(contract_info_request))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: backend_error_json.clone(),
            }))
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_contract],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .get(format!("/v1/chains/4/contracts/{}", &bip_contract_address))
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;
    let actual_status = response.status();
    let actual = response.into_string().await.unwrap();
    let expected = serde_json::to_string(&error).unwrap();

    assert_eq!(Status::NotFound, actual_status);
    assert_eq!(expected, actual);
}

'''
'''--- src/routes/delegates/handlers.rs ---
use crate::common::models::page::Page;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::delegates::models::{
    Delegate, DelegateCreate, DelegateDelete, SafeDelegateDelete,
};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::Request;

pub async fn get_delegates(
    context: &RequestContext,
    chain_id: String,
    safe: Option<String>,
    delegate: Option<String>,
    delegator: Option<String>,
    label: Option<String>,
) -> ApiResult<Page<Delegate>> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    let url = core_uri!(
        info_provider,
        "/v1/delegates/?safe={}&delegate={}&delegator={}&label={}",
        safe.unwrap_or(String::from("")),
        delegate.unwrap_or(String::from("")),
        delegator.unwrap_or(String::from("")),
        label.unwrap_or(String::from("")),
    )?;

    let request = Request::new(url);

    let response = context.http_client().get(request).await?;
    let safe_delegates = serde_json::from_str::<Page<Delegate>>(&response.body)?;

    return Ok(safe_delegates);
}

pub async fn post_delegate(
    context: &RequestContext,
    chain_id: String,
    safe_delegate_create: DelegateCreate,
) -> ApiResult<()> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    let url = core_uri!(info_provider, "/v1/delegates/",)?;

    let request = {
        let mut request = Request::new(url);
        request.body(serde_json::to_string(&safe_delegate_create).ok());
        request
    };

    context.http_client().post(request).await?;
    Ok(())
}

pub async fn delete_delegate(
    context: &RequestContext,
    chain_id: String,
    delegate_address: String,
    delegate_delete: DelegateDelete,
) -> ApiResult<()> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    let url = core_uri!(info_provider, "/v1/delegates/{}/", delegate_address)?;

    let request = {
        let mut request = Request::new(url);
        request.body(serde_json::to_string(&delegate_delete).ok());
        request
    };

    context.http_client().delete(request).await?;
    Ok(())
}

pub async fn delete_safe_delegate(
    context: &RequestContext,
    chain_id: String,
    safe_address: String,
    delegate_address: String,
    safe_delegate_delete: SafeDelegateDelete,
) -> ApiResult<()> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/delegates/{}/",
        safe_address,
        delegate_address
    )?;

    let request = {
        let mut request = Request::new(url);
        request.body(serde_json::to_string(&safe_delegate_delete).ok());
        request
    };

    context.http_client().delete(request).await?;
    Ok(())
}

'''
'''--- src/routes/delegates/mod.rs ---
#[doc(hidden)]
mod handlers;
mod models;
pub mod routes;

#[cfg(test)]
mod tests;

'''
'''--- src/routes/delegates/models.rs ---
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(PartialEq))]
pub struct Delegate {
    safe: Option<String>,
    delegate: String,
    delegator: String,
    label: String,
}

#[derive(Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct DelegateCreate {
    safe: Option<String>,
    delegate: String,
    delegator: String,
    signature: String,
    label: String,
}

#[derive(Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct DelegateDelete {
    delegate: String,
    delegator: String,
    signature: String,
}

#[derive(Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct SafeDelegateDelete {
    safe: String,
    delegate: String,
    signature: String,
}

'''
'''--- src/routes/delegates/routes.rs ---
use crate::routes::delegates::handlers;
use crate::routes::delegates::models::{DelegateCreate, DelegateDelete, SafeDelegateDelete};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::response::content;
use rocket::serde::json::Json;
use rocket_okapi::openapi;

#[openapi(tag = "Delegates")]
#[get("/v1/chains/<chain_id>/delegates?<safe>&<delegate>&<delegator>&<label>")]
pub async fn get_delegates<'e>(
    context: RequestContext,
    chain_id: String,
    safe: Option<String>,
    delegate: Option<String>,
    delegator: Option<String>,
    label: Option<String>,
) -> ApiResult<content::RawJson<String>> {
    let json = serde_json::to_string(
        &handlers::get_delegates(&context, chain_id, safe, delegate, delegator, label).await?,
    )?;
    Ok(content::RawJson(json))
}

#[openapi(tag = "Delegates")]
#[post(
    "/v1/chains/<chain_id>/delegates",
    format = "application/json",
    data = "<safe_delegate>"
)]
pub async fn post_delegate<'e>(
    context: RequestContext,
    chain_id: String,
    safe_delegate: Json<DelegateCreate>,
) -> ApiResult<()> {
    return handlers::post_delegate(&context, chain_id, safe_delegate.0).await;
}

#[openapi(tag = "Delegates")]
#[delete(
    "/v1/chains/<chain_id>/delegates/<delegate_address>",
    format = "application/json",
    data = "<delegate_delete>"
)]
pub async fn delete_delegate<'e>(
    context: RequestContext,
    chain_id: String,
    delegate_address: String,
    delegate_delete: Json<DelegateDelete>,
) -> ApiResult<()> {
    return handlers::delete_delegate(&context, chain_id, delegate_address, delegate_delete.0)
        .await;
}

#[openapi(tag = "Delegates")]
#[delete(
    "/v1/chains/<chain_id>/safes/<safe_address>/delegates/<delegate_address>",
    format = "application/json",
    data = "<delegate_delete>"
)]
pub async fn delete_safe_delegate<'e>(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    delegate_address: String,
    delegate_delete: Json<SafeDelegateDelete>,
) -> ApiResult<()> {
    return handlers::delete_safe_delegate(
        &context,
        chain_id,
        safe_address,
        delegate_address,
        delegate_delete.0,
    )
    .await;
}

'''
'''--- src/routes/delegates/tests/json/backend_create_delegate.json ---
{
    "safe": null,
    "delegate": "0x4CA998cE947Aed03c340141a5491Df539ff1Fd05",
    "delegator": "0xe6450667b7E9C19845751183f93bc97B01fBAec0",
    "signature": "0x7c3b61f015633198494c4f6153272e390785a2d1f5c661ac7fa7e53c434cf67d019a7778eb317ab4fb7c4c4cbec0dfa6130094f680da8458d849f58a4a412d291b",
    "label": "test_delegate"
}
'''
'''--- src/routes/delegates/tests/json/backend_delete_delegate.json ---
{
    "delegate": "0x4CA998cE947Aed03c340141a5491Df539ff1Fd05",
    "delegator": "0xe6450667b7E9C19845751183f93bc97B01fBAec0",
    "signature": "0x7c3b61f015633198494c4f6153272e390785a2d1f5c661ac7fa7e53c434cf67d019a7778eb317ab4fb7c4c4cbec0dfa6130094f680da8458d849f58a4a412d291b"
}
'''
'''--- src/routes/delegates/tests/json/backend_delete_delegate_safe.json ---
{
    "safe": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
    "delegate": "0x4CA998cE947Aed03c340141a5491Df539ff1Fd05",
    "signature": "0x7c3b61f015633198494c4f6153272e390785a2d1f5c661ac7fa7e53c434cf67d019a7778eb317ab4fb7c4c4cbec0dfa6130094f680da8458d849f58a4a412d291b"
}
'''
'''--- src/routes/delegates/tests/json/backend_list_delegates_of_safe.json ---
{
    "count": 2,
    "next": null,
    "previous": null,
    "results": [
        {
            "safe": "0xaE3c91c89153DEaC332Ab7BBd167164978638c30",
            "delegate": "0x0911D6309FD31f3facAB29BDF236454De23FA29a",
            "delegator": "0x0e329fa8d6Fcd1ba0Cda495431F1f7CA24F442C2",
            "label": "sdf"
        },
        {
            "safe": "0xaE3c91c89153DEaC332Ab7BBd167164978638c30",
            "delegate": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            "delegator": "0x0e329fa8d6Fcd1ba0Cda495431F1f7CA24F442C2",
            "label": "My new delegate2"
        }
    ]
}
'''
'''--- src/routes/delegates/tests/json/expected_list_delegates_of_safe.json ---
{
    "next": null,
    "previous": null,
    "results": [
        {
            "safe": "0xaE3c91c89153DEaC332Ab7BBd167164978638c30",
            "delegate": "0x0911D6309FD31f3facAB29BDF236454De23FA29a",
            "delegator": "0x0e329fa8d6Fcd1ba0Cda495431F1f7CA24F442C2",
            "label": "sdf"
        },
        {
            "safe": "0xaE3c91c89153DEaC332Ab7BBd167164978638c30",
            "delegate": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            "delegator": "0x0e329fa8d6Fcd1ba0Cda495431F1f7CA24F442C2",
            "label": "My new delegate2"
        }
    ]
}
'''
'''--- src/routes/delegates/tests/mod.rs ---
mod routes;

pub const BACKEND_LIST_DELEGATES_OF_SAFE: &str =
    include_str!("json/backend_list_delegates_of_safe.json");
pub const EXPECTED_LIST_DELEGATES_OF_SAFE: &str =
    include_str!("json/expected_list_delegates_of_safe.json");
pub const BACKEND_CREATE_DELEGATE: &str = include_str!("json/backend_create_delegate.json");
pub const BACKEND_DELETE_DELEGATE: &str = include_str!("json/backend_delete_delegate.json");
pub const BACKEND_DELETE_DELEGATE_SAFE: &str =
    include_str!("json/backend_delete_delegate_safe.json");

'''
'''--- src/routes/delegates/tests/routes.rs ---
use crate::common::models::page::Page;
use crate::routes::delegates::models::{
    Delegate, DelegateCreate, DelegateDelete, SafeDelegateDelete,
};
use crate::tests::main::setup_rocket;
use crate::utils::http_client::{MockHttpClient, Request, Response};
use core::time::Duration;
use mockall::predicate::eq;
use rocket::http::hyper::request;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;
use serde_json::json;

use crate::config::{chain_info_request_timeout, default_request_timeout};

/// Test get delegate from safe
/// Check the CGW requests to the config-service and transaction-service
/// Check the response of get /v1/chains/{}/delegates?safe={}
#[rocket::async_test]
async fn get_delegates_from_safe() {
    let safe_address = "0xaE3c91c89153DEaC332Ab7BBd167164978638c30";
    // Mock config service
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });
    // Mock delegates transaction service
    let mut delegates_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/delegates/?safe={}&delegate=&delegator=&label=",
        &safe_address));
    delegates_request.timeout(Duration::from_millis(default_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(delegates_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::BACKEND_LIST_DELEGATES_OF_SAFE),
                status_code: 200,
            })
        });
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_delegates],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let expected =
        serde_json::from_str::<Page<Delegate>>(super::EXPECTED_LIST_DELEGATES_OF_SAFE).unwrap();
    // Create request get delegates
    let request = client
        .get(format!("/v1/chains/{}/delegates?safe={}", 4, &safe_address))
        .header(Header::new("Host", "test.safe.global/api"))
        .header(ContentType::JSON);
    let response = request.dispatch().await;
    let actual_status = response.status();
    let actual_json_body = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<Page<Delegate>>(&actual_json_body).unwrap();
    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

/// Test add delegate to safe
/// Check the CGW requests to the config-service and transaction-service
/// Check the status response
#[rocket::async_test]
async fn add_delegate() {
    // Mock config service
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });
    // Mock transaction service delegates
    let mut delegates_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/delegates/"
    ));
    let mut body_string = String::from(super::BACKEND_CREATE_DELEGATE);
    body_string = body_string.replace('\n', "");
    body_string = body_string.replace(' ', "");
    delegates_request.body(Some(body_string));
    delegates_request.timeout(Duration::from_millis(default_request_timeout()));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(delegates_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::BACKEND_CREATE_DELEGATE),
                status_code: 201,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_delegate],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    // Create post request
    let request = client
        .post(format!("/v1/chains/4/delegates"))
        .body(String::from(super::BACKEND_CREATE_DELEGATE))
        .header(Header::new("Host", "test.safe.global/api"))
        .header(ContentType::JSON);
    let response = request.dispatch().await;
    let actual_status = response.status();

    assert_eq!(actual_status, Status::Ok);
}

/// Test delete delegate
/// Check the CGW requests to the config-service and transaction-service
/// Check the status response
#[rocket::async_test]
async fn delete_delegate() {
    // Mock the response of config service
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });
    let delegate_address = "0x4CA998cE947Aed03c340141a5491Df539ff1Fd05";
    // Mock the response of transaction service delegates
    let mut delegates_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/delegates/{}/",
        delegate_address
    ));
    let mut body_string = String::from(super::BACKEND_DELETE_DELEGATE);
    body_string = body_string.replace('\n', "");
    body_string = body_string.replace(' ', "");
    delegates_request.body(Some(body_string));
    delegates_request.timeout(Duration::from_millis(default_request_timeout()));
    mock_http_client
        .expect_delete()
        .times(1)
        .with(eq(delegates_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(""),
                status_code: 204,
            })
        });
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::delete_delegate],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    // Create request to delete a delegate
    let request = client
        .delete(format!("/v1/chains/4/delegates/{}", delegate_address))
        .body(String::from(super::BACKEND_DELETE_DELEGATE))
        .header(Header::new("Host", "test.safe.global/api"))
        .header(ContentType::JSON);
    let response = request.dispatch().await;
    let actual_status = response.status();
    // Should return OK
    assert_eq!(actual_status, Status::Ok);
}

/// Test delete delegate of a safe
/// Check the CGW requests to the config-service and transaction-service
/// Check the status response
#[rocket::async_test]
async fn delete_delegate_safe() {
    // Mock the response of config service
    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });
    let delegate_address = "0x4CA998cE947Aed03c340141a5491Df539ff1Fd05";
    let safe_address = "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02";
    // Mock the response of transaction service delegates
    let mut delegates_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/delegates/{}/",
        safe_address, delegate_address
    ));
    let mut body_string = String::from(super::BACKEND_DELETE_DELEGATE_SAFE);
    body_string = body_string.replace('\n', "");
    body_string = body_string.replace(' ', "");
    delegates_request.body(Some(body_string));
    delegates_request.timeout(Duration::from_millis(default_request_timeout()));
    mock_http_client
        .expect_delete()
        .times(1)
        .with(eq(delegates_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(""),
                status_code: 204,
            })
        });
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::delete_safe_delegate],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    // Create request to delete a delegate
    let request = client
        .delete(format!(
            "/v1/chains/4/safes/{}/delegates/{}/",
            safe_address, delegate_address
        ))
        .body(String::from(super::BACKEND_DELETE_DELEGATE_SAFE))
        .header(Header::new("Host", "test.safe.global/api"))
        .header(ContentType::JSON);
    let response = request.dispatch().await;
    let actual_status = response.status();
    // Should return OK
    assert_eq!(actual_status, Status::Ok);
}

'''
'''--- src/routes/health/mod.rs ---
pub mod routes;
#[cfg(test)]
mod tests;

'''
'''--- src/routes/health/routes.rs ---
use crate::cache::cache_operations::CacheResponse;
use crate::cache::manager::ChainCache;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::response::content;
use rocket_okapi::openapi;

#[openapi(tag = "Health")]
#[get("/health")]
pub async fn health(context: RequestContext) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::Other)
        .resp_generator(|| async { Ok(String::new()) })
        .execute()
        .await
}

'''
'''--- src/routes/health/tests/mod.rs ---
mod routes;

'''
'''--- src/routes/health/tests/routes.rs ---
use crate::tests::main::setup_rocket;
use crate::utils::http_client::MockHttpClient;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;

#[rocket::async_test]
async fn health() {
    let mock_http_client = MockHttpClient::new();

    let client = Client::tracked(
        setup_rocket(mock_http_client, routes![super::super::routes::health]).await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .get("/health")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;
    let actual_status = response.status();
    let actual = response.into_string().await.unwrap();

    assert_eq!(Status::Ok, actual_status);
    assert_eq!("\"\"", actual);
}

'''
'''--- src/routes/hooks/handlers.rs ---
use crate::cache::cache_operations::{Invalidate, InvalidationPattern, InvalidationScope};
use crate::cache::Cache;
use crate::common::models::backend::hooks::{Payload, PayloadDetails};
use crate::utils::errors::ApiResult;
use rocket::futures::future::OptionFuture;
use std::sync::Arc;

pub async fn invalidate_caches(cache: Arc<dyn Cache>, payload: &Payload) -> ApiResult<()> {
    Invalidate::new(
        InvalidationPattern::Any(InvalidationScope::Both, payload.address.to_owned()),
        cache.clone(),
    )
    .execute()
    .await;

    OptionFuture::from(payload.details.as_ref().map(|d| async move {
        match d {
            PayloadDetails::NewConfirmation(data) => {
                Invalidate::new(
                    InvalidationPattern::Any(
                        InvalidationScope::Both,
                        String::from(&data.safe_tx_hash),
                    ),
                    cache.clone(),
                )
                .execute()
                .await
            }
            PayloadDetails::ExecutedMultisigTransaction(data) => {
                Invalidate::new(
                    InvalidationPattern::Any(
                        InvalidationScope::Both,
                        String::from(&data.safe_tx_hash),
                    ),
                    cache.clone(),
                )
                .execute()
                .await
            }
            PayloadDetails::PendingMultisigTransaction(data) => {
                Invalidate::new(
                    InvalidationPattern::Any(
                        InvalidationScope::Both,
                        String::from(&data.safe_tx_hash),
                    ),
                    cache.clone(),
                )
                .execute()
                .await
            }
            _ => (),
        }
    }))
    .await;
    Ok(())
}

'''
'''--- src/routes/hooks/mod.rs ---
#[doc(hidden)]
pub mod handlers;
pub mod routes;

#[cfg(test)]
mod tests;

'''
'''--- src/routes/hooks/routes.rs ---
use rocket::serde::json::Json;

use crate::cache::cache_operations::{Invalidate, InvalidationPattern};
use crate::cache::manager::ChainCache;
use crate::common::models::backend::hooks::Payload;
use crate::common::routes::authorization::AuthorizationToken;
use crate::config::webhook_token;
use crate::routes::hooks::handlers::invalidate_caches;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;

#[post("/v1/hook/update/<token>", format = "json", data = "<update>")]
pub async fn update(
    context: RequestContext,
    token: String,
    update: Json<Payload>,
) -> ApiResult<()> {
    if token != webhook_token() {
        bail!("Invalid token");
    }
    invalidate_caches(
        context.cache(ChainCache::from(update.chain_id.as_str())),
        &update,
    )
    .await
}

#[post(
    "/v1/chains/<chain_id>/hook/update/<token>",
    format = "json",
    data = "<payload>"
)]
pub async fn post_hook_update(
    context: RequestContext,
    chain_id: String,
    token: String,
    payload: Json<Payload>,
) -> ApiResult<()> {
    update(context, token, payload).await
}

#[post(
    "/v1/chains/<chain_id>/hooks/events",
    format = "json",
    data = "<payload>"
)]
pub async fn post_hooks_events(
    context: RequestContext,
    chain_id: String,
    _token: AuthorizationToken,
    payload: Json<Payload>,
) -> ApiResult<()> {
    invalidate_caches(context.cache(ChainCache::from(chain_id.as_str())), &payload).await
}

#[post("/v1/flush/<token>", format = "json", data = "<invalidation_pattern>")]
pub async fn flush(
    context: RequestContext,
    token: String,
    invalidation_pattern: Json<InvalidationPattern>,
) -> ApiResult<()> {
    if token != webhook_token() {
        bail!("Invalid token");
    }
    Invalidate::new(invalidation_pattern.0, context.cache(ChainCache::Other))
        .execute()
        .await;
    Ok(())
}

#[post("/v2/flush", format = "json", data = "<invalidation_pattern>")]
pub async fn post_flush_events(
    context: RequestContext,
    _token: AuthorizationToken,
    invalidation_pattern: Json<InvalidationPattern>,
) -> ApiResult<()> {
    Invalidate::new(
        invalidation_pattern.0.clone(),
        context.cache(ChainCache::Mainnet),
    )
    .execute()
    .await;
    Invalidate::new(invalidation_pattern.0, context.cache(ChainCache::Other))
        .execute()
        .await;
    Ok(())
}

'''
'''--- src/routes/hooks/tests/invalidate_caches.rs ---
use crate::cache::*;
use crate::common::models::backend::hooks::{
    ExecutedMultisigTransaction, NewConfirmation, Payload, PayloadDetails,
    PendingMultisigTransaction,
};
use crate::routes::hooks::handlers::invalidate_caches;
use mockall::predicate::*;
use mockall::Sequence;
use std::sync::Arc;

#[rocket::async_test]
async fn invalidate_with_empty_payload() {
    let payload = Payload {
        address: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
        chain_id: "1".to_string(),
        details: None,
    };

    let mut mock_cache = MockCache::new();

    mock_cache.expect_fetch().times(0);
    mock_cache.expect_create().times(0);
    mock_cache.expect_invalidate().times(0);

    mock_cache
        .expect_invalidate_pattern()
        .times(1)
        .return_const(())
        .with(eq("c_re*0x1230B3d59858296A31053C1b8562Ecf89A2f888b*"));

    invalidate_caches(Arc::new(mock_cache), &payload)
        .await
        .unwrap();
}

#[rocket::async_test]
async fn invalidate_new_confirmation_payload() {
    let payload = Payload {
        address: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
        chain_id: "1".to_string(),
        details: Some(PayloadDetails::NewConfirmation(NewConfirmation {
            owner: "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0".to_string(),
            safe_tx_hash: "0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621"
                .to_string(),
        })),
    };

    let mut mock_cache = MockCache::new();
    let mut sequence = Sequence::new();

    mock_cache.expect_fetch().times(0);
    mock_cache.expect_create().times(0);
    mock_cache.expect_invalidate().times(0);
    mock_cache
        .expect_invalidate_pattern()
        .times(1)
        .return_const(())
        .with(eq("c_re*0x1230B3d59858296A31053C1b8562Ecf89A2f888b*"))
        .in_sequence(&mut sequence);
    mock_cache
        .expect_invalidate_pattern()
        .times(1)
        .return_const(())
        .with(eq(
            "c_re*0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621*",
        ))
        .in_sequence(&mut sequence);

    invalidate_caches(Arc::new(mock_cache), &payload)
        .await
        .unwrap();
}

#[rocket::async_test]
async fn invalidate_executed_multisig_transaction_payload() {
    let payload = Payload {
        address: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
        chain_id: "1".to_string(),
        details: Some(PayloadDetails::ExecutedMultisigTransaction(
            ExecutedMultisigTransaction {
                safe_tx_hash: "0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621"
                    .to_string(),
                tx_hash: "0x0ebb2c317f55c96469e0ed2014f5833dc02a70b42f0ac52f4630938900caa698"
                    .to_string(),
            },
        )),
    };

    let mut mock_cache = MockCache::new();
    let mut sequence = Sequence::new();

    mock_cache.expect_fetch().times(0);
    mock_cache.expect_create().times(0);
    mock_cache.expect_invalidate().times(0);
    mock_cache
        .expect_invalidate_pattern()
        .times(1)
        .return_const(())
        .with(eq("c_re*0x1230B3d59858296A31053C1b8562Ecf89A2f888b*"))
        .in_sequence(&mut sequence);
    mock_cache
        .expect_invalidate_pattern()
        .times(1)
        .return_const(())
        .with(eq(
            "c_re*0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621*",
        ))
        .in_sequence(&mut sequence);

    invalidate_caches(Arc::new(mock_cache), &payload)
        .await
        .unwrap();
}

#[rocket::async_test]
async fn invalidate_pending_multisig_transaction_payload() {
    let payload = Payload {
        address: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
        chain_id: "1".to_string(),
        details: Some(PayloadDetails::PendingMultisigTransaction(
            PendingMultisigTransaction {
                safe_tx_hash: "0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621"
                    .to_string(),
            },
        )),
    };

    let mut mock_cache = MockCache::new();
    let mut sequence = Sequence::new();
    mock_cache.expect_fetch().times(0);
    mock_cache.expect_create().times(0);
    mock_cache.expect_invalidate().times(0);
    mock_cache
        .expect_invalidate_pattern()
        .times(1)
        .return_const(())
        .with(eq("c_re*0x1230B3d59858296A31053C1b8562Ecf89A2f888b*"))
        .in_sequence(&mut sequence);
    mock_cache
        .expect_invalidate_pattern()
        .times(1)
        .return_const(())
        .with(eq(
            "c_re*0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621*",
        ))
        .in_sequence(&mut sequence);

    invalidate_caches(Arc::new(mock_cache), &payload)
        .await
        .unwrap();
}

'''
'''--- src/routes/hooks/tests/mod.rs ---
mod invalidate_caches;
mod routes;
mod safes;

'''
'''--- src/routes/hooks/tests/routes.rs ---
use std::env;

use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;
use rocket::serde::json::json;

use crate::tests::main::setup_rocket;
use crate::utils::http_client::MockHttpClient;

#[rocket::async_test]
async fn post_hooks_events_no_token_set() {
    let mock_http_client = MockHttpClient::new();
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_hooks_events],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v1/chains/1/hooks/events")
        .body(&json!({"address": "0x6810e776880C02933D47DB1b9fc05908e5386b96"}).to_string())
        .header(ContentType::JSON)
        .header(Header::new("Host", "test.safe.global"));
    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::BadRequest);
}

#[rocket::async_test]
async fn post_hooks_events_invalid_token() {
    env::set_var("WEBHOOK_TOKEN", "test_webhook_token");
    let mock_http_client = MockHttpClient::new();
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_hooks_events],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v1/chains/1/hooks/events")
        .body(&json!({"address": "0x6810e776880C02933D47DB1b9fc05908e5386b96"}).to_string())
        .header(ContentType::JSON)
        .header(Header::new("Authorization", "Basic some_token"))
        .header(Header::new("Host", "test.safe.global"));
    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::Unauthorized);
}

#[rocket::async_test]
async fn post_hooks_events_valid_token() {
    env::set_var("WEBHOOK_TOKEN", "test_webhook_token");
    let mock_http_client = MockHttpClient::new();
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_hooks_events],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v1/chains/1/hooks/events")
        .body(
            &json!({"address": "0x6810e776880C02933D47DB1b9fc05908e5386b96", "chainId" : "1"})
                .to_string(),
        )
        .header(ContentType::JSON)
        .header(Header::new("Authorization", "Basic test_webhook_token"))
        .header(Header::new("Host", "test.safe.global"));
    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::Ok);
}

#[rocket::async_test]
async fn post_flush_events_no_token_set() {
    let mock_http_client = MockHttpClient::new();
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_flush_events],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v2/flush")
        .header(ContentType::JSON)
        .header(Header::new("Host", "test.safe.global"));
    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::BadRequest);
}

#[rocket::async_test]
async fn post_flush_events_invalid_token() {
    env::set_var("WEBHOOK_TOKEN", "test_webhook_token");
    let mock_http_client = MockHttpClient::new();
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_flush_events],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v2/flush")
        .header(ContentType::JSON)
        .header(Header::new("Host", "test.safe.global"))
        .header(Header::new("Authorization", "Basic some_token"));
    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::Unauthorized);
}

#[rocket::async_test]
async fn post_flush_events_valid_token() {
    env::set_var("WEBHOOK_TOKEN", "test_webhook_token");
    let mock_http_client = MockHttpClient::new();
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_flush_events],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v2/flush")
        .body(&json!({"invalidate": "Chains"}).to_string())
        .header(ContentType::JSON)
        .header(Header::new("Host", "test.safe.global"))
        .header(Header::new("Authorization", "Basic test_webhook_token"));
    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::Ok);
}

'''
'''--- src/routes/hooks/tests/safes.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::chains::ChainInfo;
use crate::common::models::backend::safes::MasterCopy;
use crate::providers::info::*;
use crate::routes::safes::converters::calculate_version_state;
use crate::routes::safes::models::{Implementation, ImplementationVersionState, SafeInfoEx};
use rocket::serde::json::json;

#[rocket::async_test]
async fn to_safe_info_ex_no_address_info() {
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(5)
        .returning(move |_| bail!("No safe info"));
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .returning(move || Ok(build_chain_info()));
    mock_info_provider
        .expect_chain_id()
        .times(1)
        .return_const("4".to_string());
    let supported_master_copies = vec![MasterCopy {
        address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
        version: "1.1.1".to_string(),
        deployer: "".to_string(),
        deployed_block_number: 0,
        last_indexed_block_number: 0,
    }];

    let expected = SafeInfoEx {
        address: AddressEx {
            value: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
            name: None,
            logo_uri: None,
        },
        chain_id: "4".to_string(),
        nonce: 180,
        threshold: 3,
        owners: vec![
            AddressEx {
                value: "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0".to_string(),
                name: None,
                logo_uri: None,
            },
        ],
        implementation: AddressEx {
            value: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
            name: None,
            logo_uri: None,
        },
        modules: Some(vec![
            AddressEx {
                value: "0x25F73b24B866963B0e560fFF9bbA7908be0263E8".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0x10A7EC8D10CD175dC33781fB9Cf3394220Fac78c".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d".to_string(),
                name: None,
                logo_uri: None,
            },
        ]),
        fallback_handler: Some(AddressEx {
            value: "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44".to_string(),
            name: None,
            logo_uri: None,
        }),
        guard: None,
        version: Some("1.1.1".to_string()),
        implementation_version_state: ImplementationVersionState::UpToDate,
    };

    let actual = safe_info
        .to_safe_info_ex(&mut mock_info_provider, supported_master_copies)
        .await;

    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn to_safe_info_ex_no_address_info_up_to_date() {
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(5)
        .returning(move |_| bail!("No safe info"));
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .returning(move || Ok(build_chain_info()));
    mock_info_provider
        .expect_chain_id()
        .times(1)
        .return_const("4".to_string());
    let supported_master_copies = vec![MasterCopy {
        address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
        version: "1.1.1".to_string(),
        deployer: "".to_string(),
        deployed_block_number: 0,
        last_indexed_block_number: 0,
    }];

    let expected = SafeInfoEx {
        address: AddressEx {
            value: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
            name: None,
            logo_uri: None,
        },
        chain_id: "4".to_string(),
        nonce: 180,
        threshold: 3,
        owners: vec![
            AddressEx {
                value: "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0".to_string(),
                name: None,
                logo_uri: None,
            },
        ],
        implementation: AddressEx {
            value: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
            name: None,
            logo_uri: None,
        },
        modules: Some(vec![
            AddressEx {
                value: "0x25F73b24B866963B0e560fFF9bbA7908be0263E8".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0x10A7EC8D10CD175dC33781fB9Cf3394220Fac78c".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d".to_string(),
                name: None,
                logo_uri: None,
            },
        ]),
        fallback_handler: Some(AddressEx {
            value: "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44".to_string(),
            name: None,
            logo_uri: None,
        }),
        guard: None,
        version: Some("1.1.1".to_string()),
        implementation_version_state: ImplementationVersionState::UpToDate,
    };

    let actual = safe_info
        .to_safe_info_ex(&mut mock_info_provider, supported_master_copies)
        .await;

    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn to_safe_info_ex_address_info() {
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(5)
        .returning(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("name_{}", &address)),
                logo_uri: Some(format!("logo_uri_{}", &address)),
            })
        });
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .returning(move || Ok(build_chain_info()));
    mock_info_provider
        .expect_chain_id()
        .times(1)
        .return_const("4".to_string());
    let supported_master_copies = vec![MasterCopy {
        address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
        version: "1.1.1".to_string(),
        deployer: "".to_string(),
        deployed_block_number: 0,
        last_indexed_block_number: 0,
    }];

    let expected = SafeInfoEx {
        address: AddressEx {
            value: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
            name: None,
            logo_uri: None,
        },
        chain_id: "4".to_string(),
        nonce: 180,
        threshold: 3,
        owners: vec![
            AddressEx {
                value: "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd".to_string(),
                name: None,
                logo_uri: None,
            },
            AddressEx {
                value: "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0".to_string(),
                name: None,
                logo_uri: None,
            },
        ],
        implementation: AddressEx {
            value: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
            name: Some("name_0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string()),
            logo_uri: Some("logo_uri_0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string()),
        },
        modules: Some(vec![
            AddressEx {
                value: "0x25F73b24B866963B0e560fFF9bbA7908be0263E8".to_string(),
                name: Some("name_0x25F73b24B866963B0e560fFF9bbA7908be0263E8".to_string()),
                logo_uri: Some("logo_uri_0x25F73b24B866963B0e560fFF9bbA7908be0263E8".to_string()),
            },
            AddressEx {
                value: "0x10A7EC8D10CD175dC33781fB9Cf3394220Fac78c".to_string(),
                name: Some("name_0x10A7EC8D10CD175dC33781fB9Cf3394220Fac78c".to_string()),
                logo_uri: Some("logo_uri_0x10A7EC8D10CD175dC33781fB9Cf3394220Fac78c".to_string()),
            },
            AddressEx {
                value: "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d".to_string(),
                name: Some("name_0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d".to_string()),
                logo_uri: Some("logo_uri_0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d".to_string()),
            },
        ]),
        fallback_handler: Some(AddressEx {
            value: "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44".to_string(),
            name: Some("name_0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44".to_string()),
            logo_uri: Some("logo_uri_0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44".to_string()),
        }),
        guard: None,
        version: Some("1.1.1".to_string()),
        implementation_version_state: ImplementationVersionState::UpToDate,
    };

    let actual = safe_info
        .to_safe_info_ex(&mut mock_info_provider, supported_master_copies)
        .await;

    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn to_safe_info_ex_nullable_fields_are_all_null() {
    let safe_info = serde_json::from_str::<SafeInfo>(
        &json!({
            "address": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            "nonce" : 180,
            "threshold" : 3,
            "owners" : ["0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"],
            "masterCopy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
            "fallbackHandler": "0x0000000000000000000000000000000000000000",
            "guard": "0x0000000000000000000000000000000000000000"
        })
        .to_string(),
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |_| bail!("No address info"));
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .returning(move || Ok(build_chain_info()));
    mock_info_provider
        .expect_chain_id()
        .times(1)
        .return_const("4".to_string());
    let supported_master_copies = vec![MasterCopy {
        address: "".to_string(),
        version: "1.1.1".to_string(),
        deployer: "".to_string(),
        deployed_block_number: 0,
        last_indexed_block_number: 0,
    }];

    let expected = SafeInfoEx {
        address: AddressEx {
            value: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
            name: None,
            logo_uri: None,
        },
        chain_id: "4".to_string(),
        nonce: 180,
        threshold: 3,
        owners: vec![AddressEx {
            value: "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23".to_string(),
            name: None,
            logo_uri: None,
        }],
        implementation: AddressEx {
            value: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
            name: None,
            logo_uri: None,
        },
        modules: None,
        fallback_handler: None,
        guard: None,
        version: None,
        implementation_version_state: ImplementationVersionState::Unknown,
    };

    let actual = safe_info
        .to_safe_info_ex(&mut mock_info_provider, supported_master_copies)
        .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn to_safe_info_guard_and_fallback_handler_defined() {
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(3)
        .returning(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("name_{}", &address)),
                logo_uri: Some(format!("logo_uri_{}", &address)),
            })
        });
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .returning(move || Ok(build_chain_info()));
    mock_info_provider
        .expect_chain_id()
        .times(1)
        .return_const("4".to_string());
    let supported_master_copies = vec![MasterCopy {
        address: "0x3E5c63644E683549055b9Be8653de26E0B4CD36E".to_string(),
        version: "1.1.1".to_string(),
        deployer: "".to_string(),
        deployed_block_number: 0,
        last_indexed_block_number: 0,
    }];

    let expected = SafeInfoEx {
        address: AddressEx {
            value: "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f".to_string(),
            name: None,
            logo_uri: None,
        },
        chain_id: "4".to_string(),
        nonce: 7,
        threshold: 1,
        owners: vec![AddressEx {
            value: "0x5aC255889882aCd3da2aA939679E3f3d4cea221e".to_string(),
            name: None,
            logo_uri: None,
        }],
        implementation: AddressEx {
            value: "0x3E5c63644E683549055b9Be8653de26E0B4CD36E".to_string(),
            name: Some("name_0x3E5c63644E683549055b9Be8653de26E0B4CD36E".to_string()),
            logo_uri: Some("logo_uri_0x3E5c63644E683549055b9Be8653de26E0B4CD36E".to_string()),
        },
        modules: None,
        fallback_handler: Some(AddressEx {
            value: "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4".to_string(),
            name: Some("name_0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4".to_string()),
            logo_uri: Some("logo_uri_0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4".to_string()),
        }),
        guard: Some(AddressEx {
            value: "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D".to_string(),
            name: Some("name_0x40A2aCCbd92BCA938b02010E17A5b8929b49130D".to_string()),
            logo_uri: Some("logo_uri_0x40A2aCCbd92BCA938b02010E17A5b8929b49130D".to_string()),
        }),
        version: Some("1.3.0".to_string()),
        implementation_version_state: ImplementationVersionState::UpToDate,
    };

    let actual = safe_info
        .to_safe_info_ex(&mock_info_provider, supported_master_copies)
        .await;

    assert_eq!(expected, actual);
}

#[test]
fn calculate_version_state_up_to_date() {
    let supported_master_copies = vec![
        MasterCopy {
            address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
            version: "1.1.1".to_string(),
            deployer: "".to_string(),
            deployed_block_number: 0,
            last_indexed_block_number: 0,
        },
        MasterCopy {
            address: "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552".to_string(),
            version: "1.3.0".to_string(),
            deployer: "".to_string(),
            deployed_block_number: 0,
            last_indexed_block_number: 0,
        },
    ];

    let actual_equal = calculate_version_state(
        "1.1.1",
        "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        &supported_master_copies,
        "1.1.1".to_string(),
    );
    let actual_newer = calculate_version_state(
        "1.3.0",
        "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
        &supported_master_copies,
        "1.1.1".to_string(),
    );

    assert_eq!(actual_equal, ImplementationVersionState::UpToDate);
    assert_eq!(actual_newer, ImplementationVersionState::UpToDate);
}

#[test]
fn calculate_version_state_outdated() {
    let supported_master_copies = vec![
        MasterCopy {
            address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
            version: "1.1.1".to_string(),
            deployer: "".to_string(),
            deployed_block_number: 0,
            last_indexed_block_number: 0,
        },
        MasterCopy {
            address: "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552".to_string(),
            version: "1.3.0".to_string(),
            deployer: "".to_string(),
            deployed_block_number: 0,
            last_indexed_block_number: 0,
        },
    ];

    let actual = calculate_version_state(
        "1.1.1",
        "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        &supported_master_copies,
        "1.3.0".to_string(),
    );

    assert_eq!(actual, ImplementationVersionState::Outdated);
}

#[test]
fn calculate_version_state_unknown() {
    let actual = calculate_version_state(
        "1.1.1",
        "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
        &vec![],
        "1.1.1".to_string(),
    );

    assert_eq!(actual, ImplementationVersionState::Unknown);
}

#[test]
fn calculate_version_state_version_up_to_date_but_address_mismatch() {
    let supported_master_copies = vec![MasterCopy {
        address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
        version: "1.1.1".to_string(),
        deployer: "".to_string(),
        deployed_block_number: 0,
        last_indexed_block_number: 0,
    }];
    let actual = calculate_version_state(
        "1.1.1",
        "some_unexpected_address",
        &supported_master_copies,
        "1.1.1".to_string(),
    );

    assert_eq!(actual, ImplementationVersionState::Unknown);
}

#[test]
fn implementation_from_master_copy() {
    let master_copy = MasterCopy {
        address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
        version: "1.1.1".to_string(),
        deployer: "".to_string(),
        deployed_block_number: 0,
        last_indexed_block_number: 0,
    };

    let expected = Implementation {
        address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F".to_string(),
        version: "1.1.1".to_string(),
    };

    assert_eq!(expected, master_copy.into());
}

fn build_chain_info() -> ChainInfo {
    serde_json::from_str::<ChainInfo>(crate::tests::json::CHAIN_INFO_RINKEBY).unwrap()
}

'''
'''--- src/routes/messages/backend_models.rs ---
use chrono::{DateTime, Utc};
use serde::Deserialize;
use std::collections::BTreeMap;

#[derive(Deserialize, Debug)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub(super) enum SignatureType {
    ContractSignature,
    ApprovedHash,
    Eoa,
    EthSign,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(super) struct Confirmation {
    pub(super) created: DateTime<Utc>,
    pub(super) modified: DateTime<Utc>,
    pub(super) owner: String,
    pub(super) signature: String,
    pub(super) signature_type: SignatureType,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct Message {
    pub(super) created: DateTime<Utc>,
    pub(crate) modified: DateTime<Utc>,
    pub(super) safe: String,
    pub(super) message_hash: String,
    pub(super) message: MessageValue,
    pub(super) proposed_by: String,
    pub(super) safe_app_id: Option<u64>,
    pub(super) confirmations: Vec<Confirmation>,
    pub(super) prepared_signature: Option<String>,
}

#[derive(Deserialize, Debug)]
#[serde(untagged)]
pub enum MessageValue {
    String(String),
    Object(BTreeMap<String, serde_json::Value>),
}

'''
'''--- src/routes/messages/create_message.rs ---
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::{Request, Response};
use rocket::serde::json::Json;
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[post(
    "/v1/chains/<chain_id>/safes/<safe_address>/messages",
    format = "application/json",
    data = "<message_payload>"
)]
pub async fn route(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    message_payload: Json<CreateMessage>,
) -> ApiResult<String> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    let url = core_uri!(info_provider, "/v1/safes/{}/messages/", safe_address)?;

    let request = {
        let mut request = Request::new(url);
        request.body(serde_json::to_string(&message_payload.0).ok());
        request
    };
    let response_body: Response = context.http_client().post(request).await?;
    return Ok(response_body.body);
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CreateMessage {
    message: MessageValue,
    safe_app_id: Option<u64>,
    signature: String,
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(untagged)]
pub enum MessageValue {
    String(String),
    Object(BTreeMap<String, serde_json::Value>),
}

'''
'''--- src/routes/messages/frontend_models.rs ---
use crate::common::models::addresses::AddressEx;
use serde::Serialize;
use std::collections::BTreeMap;

#[derive(Serialize, Debug)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub(super) enum MessageStatus {
    NeedsConfirmation,
    Confirmed,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(super) struct Confirmation {
    pub(super) owner: AddressEx,
    pub(super) signature: String,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(super) struct Message {
    pub(super) message_hash: String,
    pub(super) status: MessageStatus,
    pub(super) logo_uri: Option<String>,
    pub(super) name: Option<String>,
    pub(super) message: MessageValue,
    pub(super) creation_timestamp: i64,
    pub(super) modified_timestamp: i64,
    pub(super) confirmations_submitted: usize,
    pub(super) confirmations_required: usize,
    pub(super) proposed_by: AddressEx,
    pub(super) confirmations: Vec<Confirmation>,
    pub(super) prepared_signature: Option<String>,
}

#[derive(Serialize, Debug)]
#[serde(untagged)]
pub enum MessageValue {
    String(String),
    Object(BTreeMap<String, serde_json::Value>),
}

'''
'''--- src/routes/messages/get_message.rs ---
use super::frontend_models::Message as FrontendMessage;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::messages::backend_models::Message;
use crate::routes::messages::message_mapper::map_message;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::Request;
use rocket::response::content;

#[get("/v1/chains/<chain_id>/messages/<message_hash>")]
pub async fn route(
    context: RequestContext,
    chain_id: String,
    message_hash: String,
) -> ApiResult<content::RawJson<String>> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);

    // Request
    let url = core_uri!(info_provider, "/v1/messages/{}/", message_hash)?;
    let http_request = Request::new(url);
    let body = info_provider.client().get(http_request).await?.body;
    let backend_message: Message = serde_json::from_str::<Message>(&body)?;

    // Request Safe Info with the safe field that was retrieved from the Message
    let safe_info = info_provider.safe_info(&backend_message.safe).await?;

    let message: FrontendMessage = map_message(&info_provider, &safe_info, &backend_message).await;

    let body = serde_json::to_string(&message)?;
    return Ok(content::RawJson(body));
}

'''
'''--- src/routes/messages/get_messages.rs ---
use super::frontend_models::Message as FrontendMessage;
use crate::common::models::page::{Page, PageMetadata};
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::messages::backend_models::Message;
use crate::routes::messages::get_messages::MessageItem::DateLabel;
use crate::routes::messages::message_mapper::map_message;
use crate::utils::context::RequestContext;
use crate::utils::errors::{ApiError, ApiResult, ErrorDetails};
use crate::utils::http_client::Request;
use crate::utils::urls::build_absolute_uri;
use chrono::{DateTime, Datelike, NaiveDate, Utc};
use itertools::Itertools;
use reqwest::Url;
use rocket::response::content;
use serde::Serialize;
use std::borrow::Cow;

#[derive(Serialize, Debug)]
#[serde(tag = "type", rename_all = "SCREAMING_SNAKE_CASE")]
enum MessageItem {
    Message(FrontendMessage),
    #[serde(rename_all = "camelCase")]
    DateLabel {
        timestamp: i64,
    },
}

#[get("/v1/chains/<chain_id>/safes/<safe_address>/messages?<cursor>")]
pub async fn route(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    cursor: Option<String>,
) -> ApiResult<content::RawJson<String>> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    let page_metadata = PageMetadata::from_cursor(cursor.as_ref().unwrap_or(&"".to_string()));
    let safe_info = info_provider.safe_info(&safe_address).await?;

    // Build Safe Transaction Service URL (with pagination)
    let url = core_uri!(info_provider, "/v1/safes/{}/messages/", safe_address)?;
    let mut url = Url::parse(&url).map_err(|_| ApiError {
        status: 500,
        details: ErrorDetails {
            code: 500,
            message: None,
            arguments: None,
            debug: None,
        },
    })?;
    url.set_query(Some(&page_metadata.to_url_string()));

    // Request
    let http_request = Request::new(url.into_string());
    let body = info_provider.client().get(http_request).await?.body;

    let messages_page: Page<Message> = serde_json::from_str::<Page<Message>>(&body)?;
    let message_groups: Vec<(Option<NaiveDate>, Vec<Message>)> =
        group_messages_by_date(messages_page.results);

    // Build final collection which includes DateLabels and Message types
    let mut message_items: Vec<MessageItem> = vec![];
    for (date_header, messages) in message_groups {
        // Maps the group header into a UNIX timestamp
        let date_label_item: Option<MessageItem> = date_header
            .and_then(|date| date.and_hms_nano_opt(0, 0, 0, 0))
            .map(|date| DateLabel {
                timestamp: date.timestamp_millis(),
            });

        // If we have a resulting DateLabel we push it
        if let Some(message_item) = date_label_item {
            message_items.push(message_item);
        }

        for message in messages {
            let message_item = map_message(&info_provider, &safe_info, &message).await;
            message_items.push(MessageItem::Message(message_item));
        }
    }

    let next_pagination: Option<PageMetadata> = match messages_page.next {
        None => None,
        Some(next) => page_metadata_from_url(&next),
    };

    let previous_pagination: Option<PageMetadata> = match messages_page.previous {
        None => None,
        Some(previous) => page_metadata_from_url(&previous),
    };

    let body = Page {
        next: get_route_url(&context, &chain_id, &safe_address, &next_pagination),
        previous: get_route_url(&context, &chain_id, &safe_address, &previous_pagination),
        results: message_items,
    };

    let body = serde_json::to_string(&body)?;
    return Ok(content::RawJson(body));
}

fn group_messages_by_date(messages: Vec<Message>) -> Vec<(Option<NaiveDate>, Vec<Message>)> {
    let groups = messages
        .into_iter()
        // Sort by descending order (grouping works on consecutive entries)
        .sorted_by(|m1, m2| m2.created.cmp(&m1.created))
        // Group by date
        .group_by(|message| {
            let message_date: DateTime<Utc> = message.created;
            return NaiveDate::from_ymd_opt(
                message_date.year(),
                message_date.month(),
                message_date.day(),
            );
        });

    let mut data_grouped: Vec<(Option<NaiveDate>, Vec<Message>)> = Vec::new();
    for (key, group) in &groups {
        data_grouped.push((key, group.collect()));
    }
    return data_grouped;
}

fn get_route_url(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    page_metadata: &Option<PageMetadata>,
) -> Option<String> {
    let cursor: String = page_metadata
        .as_ref()
        .map(|page_metadata| page_metadata.to_url_string())?;
    let absolute_uri: String = build_absolute_uri(
        &context,
        uri!(route(
            chain_id = chain_id.to_string(),
            safe_address = safe_address.to_string(),
            cursor = Some(cursor),
        )),
    );
    return Some(absolute_uri);
}

fn page_metadata_from_url(url: &str) -> Option<PageMetadata> {
    let url = Url::parse(url).ok()?;
    let query_pairs = url.query_pairs();
    let mut limit: u64 = 20;
    let mut offset: u64 = 0;

    for pair in query_pairs {
        match pair.0 {
            Cow::Borrowed("limit") => {
                limit = pair.1.parse::<u64>().ok()?;
            }
            Cow::Borrowed("offset") => {
                offset = pair.1.parse::<u64>().ok()?;
            }
            _ => {}
        }
    }

    return Some(PageMetadata { offset, limit });
}

'''
'''--- src/routes/messages/message_mapper.rs ---
use super::frontend_models::{
    Confirmation as FrontendConfirmation, Message as FrontendMessage,
    MessageValue as FrontendMessageValue,
};
use crate::common::models::addresses::AddressEx;
use crate::providers::ext::InfoProviderExt;
use crate::providers::info::{InfoProvider, SafeInfo};
use crate::routes::messages::backend_models::{Confirmation, Message, MessageValue};
use crate::routes::messages::frontend_models::MessageStatus;
use rocket::futures::future;

pub(super) async fn map_message(
    info_provider: &(impl InfoProvider + Sync),
    safe_info: &SafeInfo,
    message: &Message,
) -> FrontendMessage {
    let confirmations_required = safe_info.threshold as usize;
    let confirmations_submitted = message.confirmations.len();

    // Get Safe App Info for specific ID.
    // If the Safe App Info cannot be retrieved we return null
    let safe_app_name_logo: (Option<String>, Option<String>) = match message.safe_app_id {
        None => (None, None),
        Some(safe_app_id) => info_provider
            .safe_app_info_by_id(safe_app_id)
            .await
            .map_or((None, None), |safe_app| {
                (Some(safe_app.name), Some(safe_app.logo_uri))
            }),
    };

    // Known Address for proposed_by
    let proposed_by: AddressEx = info_provider
        .address_ex_from_contracts_or_default(&message.proposed_by)
        .await;

    // Known address for each confirmation
    let confirmations: Vec<FrontendConfirmation> = future::join_all(
        message
            .confirmations
            .iter()
            .map(|confirmation| map_confirmation(info_provider, &confirmation)),
    )
    .await;

    return FrontendMessage {
        message_hash: message.message_hash.to_string(),
        status: if confirmations_submitted >= confirmations_required {
            MessageStatus::Confirmed
        } else {
            MessageStatus::NeedsConfirmation
        },
        name: safe_app_name_logo.0,
        logo_uri: safe_app_name_logo.1,
        message: match &message.message {
            MessageValue::String(value) => FrontendMessageValue::String(value.to_string()),
            MessageValue::Object(value) => FrontendMessageValue::Object(value.clone()),
        },
        creation_timestamp: message.created.timestamp_millis(),
        modified_timestamp: message.modified.timestamp_millis(),
        confirmations_submitted,
        confirmations_required,
        proposed_by,
        confirmations,
        prepared_signature: match &message.prepared_signature {
            None => None,
            Some(value) => {
                if confirmations_submitted >= confirmations_required {
                    Some(value.to_string())
                } else {
                    None
                }
            }
        },
    };
}

async fn map_confirmation(
    info_provider: &(impl InfoProvider + Sync),
    confirmation: &Confirmation,
) -> FrontendConfirmation {
    let owner: AddressEx = info_provider
        .address_ex_from_contracts_or_default(&confirmation.owner)
        .await;

    return FrontendConfirmation {
        owner,
        signature: confirmation.signature.to_string(),
    };
}

'''
'''--- src/routes/messages/mod.rs ---
pub mod backend_models;
pub mod create_message;
pub mod get_message;
pub mod get_messages;
pub mod update_message;

mod frontend_models;
mod message_mapper;

'''
'''--- src/routes/messages/update_message.rs ---
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::{Request, Response};
use rocket::serde::json::Json;
use serde::{Deserialize, Serialize};

#[post(
    "/v1/chains/<chain_id>/messages/<message_hash>/signatures",
    format = "application/json",
    data = "<signature_payload>"
)]
pub async fn route(
    context: RequestContext,
    chain_id: String,
    message_hash: String,
    signature_payload: Json<UpdateMessage>,
) -> ApiResult<String> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    let url = core_uri!(info_provider, "/v1/messages/{}/signatures/", &message_hash)?;

    let request = {
        let mut request = Request::new(url);
        request.body(serde_json::to_string(&signature_payload.0).ok());
        request
    };
    let response_body: Response = context.http_client().post(request).await?;
    return Ok(response_body.body);
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct UpdateMessage {
    signature: String,
}

'''
'''--- src/routes/mod.rs ---
use rocket::response::Redirect;
use rocket::serde::json::{json, Value};
use rocket::{Catcher, Route};
use rocket_okapi::openapi_get_routes;

use crate::config::{is_messages_feature_enabled, is_preview_endpoint_enabled};

/// # About endpoint
pub mod about;
/// # Balance endpoints
pub mod balances;
/// # Chain endpoints
pub mod chains;
/// # Collectibles endpoint
pub mod collectibles;
/// # Utility endpoints
pub mod contracts;
pub mod delegates;
#[doc(hidden)]
pub mod health;
#[doc(hidden)]
pub mod hooks;
pub mod messages;
/// # Notification endpoints
pub mod notifications;
/// # SafeApps endpoints
pub mod safe_apps;
/// # Safe endpoints
pub mod safes;
/// # Transactions endpoints
///
/// As presented by the endpoints in this handlers, we are taking in the types returned by the [transaction handlers](https://github.com/gnosis/safe-transaction-service-example), which to this data are `Multisig`, `Module` and `Ethereum` transaction types.
///
/// The types served by the gate way are `Transfer`, `SettingsChange` and `Custom`. Additionally, we treat the `Creation` transaction as one additional type, as it is meant to be group with the rest of the items in the same UI component in the apps.
pub mod transactions;

#[doc(hidden)]
pub fn active_routes() -> Vec<Route> {
    let no_openapi = routes![
        // rocket_okapi don't support lifetimes
        // https://github.com/GREsau/okapi/issues/84
        contracts::routes::post_data_decoder,
        notifications::routes::post_notification_registration,
        safes::routes::post_safe_gas_estimation,
        safes::routes::post_safe_gas_estimation_v2,
        transactions::routes::post_confirmation,
        transactions::routes::post_transaction,
        // This endpoints shouldn't be exposed on swagger
        about::routes::redis,
        hooks::routes::update,
        hooks::routes::post_hook_update,
        hooks::routes::post_hooks_events,
        hooks::routes::post_flush_events,
        hooks::routes::flush,
    ];

    let preview_route = if is_preview_endpoint_enabled() {
        routes![transactions::routes::post_preview_transaction]
    } else {
        routes![]
    };

    let messages_routes = if is_messages_feature_enabled() {
        routes![
            messages::create_message::route,
            messages::get_message::route,
            messages::get_messages::route,
            messages::update_message::route,
        ]
    } else {
        routes![]
    };

    let openapi = openapi_get_routes![
        about::routes::backbone,
        about::routes::get_about,
        about::routes::get_chains_about,
        about::routes::get_master_copies,
        balances::routes::get_balances,
        balances::routes::get_supported_fiat,
        chains::routes::get_chain,
        chains::routes::get_chains,
        collectibles::routes::get_collectibles,
        collectibles::routes::get_collectibles_paginated,
        contracts::routes::get_contract,
        delegates::routes::delete_delegate,
        delegates::routes::delete_safe_delegate,
        delegates::routes::get_delegates,
        delegates::routes::post_delegate,
        notifications::routes::delete_notification_registration,
        safes::routes::get_safe_info,
        safes::routes::get_owners,
        safe_apps::routes::get_safe_apps,
        transactions::routes::get_transactions,
        transactions::routes::get_transactions_history,
        transactions::routes::get_transactions_queued,
        transactions::routes::get_incoming_transfers,
        transactions::routes::get_module_transactions,
        transactions::routes::get_multisig_transactions,
        health::routes::health
    ];
    return [
        &no_openapi[..],
        &preview_route[..],
        &messages_routes[..],
        &openapi[..],
    ]
    .concat();
}

#[doc(hidden)]
pub fn error_catchers() -> Vec<Catcher> {
    catchers![not_found, panic]
}

#[doc(hidden)]
#[catch(404)]
fn not_found() -> Value {
    json!({
        "status": "error",
        "reason": "Resource was not found."
    })
}

#[doc(hidden)]
#[catch(500)]
fn panic() -> Value {
    json!({
        "status": "error",
        "reason": "Server error occurred."
    })
}

'''
'''--- src/routes/notifications/handlers.rs ---
use itertools::Itertools;
use serde_json::value::{RawValue, Value};
use serde_json::{self, json};

use crate::common::models::backend::notifications::NotificationRegistrationRequest as BackendRegistrationRequest;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::notifications::models::{
    DeviceData, NotificationRegistrationRequest, SafeRegistration,
};
use crate::utils::context::RequestContext;
use crate::utils::errors::{ApiError, ApiResult, ErrorDetails};
use crate::utils::http_client::Request;

pub async fn delete_registration(
    context: &RequestContext,
    chain_id: String,
    uuid: String,
    safe_address: String,
) -> ApiResult<()> {
    let info_provider = DefaultInfoProvider::new(&chain_id, &context);
    let url = core_uri!(
        info_provider,
        "/v1/notifications/devices/{}/safes/{}/",
        uuid,
        safe_address
    )?;

    let request = Request::new(url);
    context.http_client().delete(request).await?;

    Ok(())
}

struct NotificationRegistrationError {
    status_code: u16,
    chain_id: String,
    error: Value,
}

pub async fn post_registration(
    context: &RequestContext,
    registration_request: NotificationRegistrationRequest,
) -> ApiResult<()> {
    let client = context.http_client();
    let mut requests = Vec::with_capacity(registration_request.safe_registrations.len());

    for safe_registration in registration_request.safe_registrations.iter() {
        let info_provider = DefaultInfoProvider::new(&safe_registration.chain_id, &context);
        let url = core_uri!(info_provider, "/v1/notifications/devices/")?;
        let backend_request =
            build_backend_request(&registration_request.device_data, safe_registration);

        let request = {
            let mut request = Request::new(url);
            request.body(Some(serde_json::to_string(&backend_request)?));
            request
        };
        requests.push((&safe_registration.chain_id, client.post(request)));
    }

    let mut errors: Vec<NotificationRegistrationError> = vec![];
    for (chain_id, request) in requests.into_iter() {
        match request.await {
            Err(api_error) => {
                errors.push(
                    NotificationRegistrationError {
                    status_code: api_error.status,
                    chain_id: String::from(chain_id),
                    error: json!(
                            {chain_id :   RawValue::from_string(api_error.details.message.unwrap_or(String::from("Unknown notification registration issue")))?}),
                });
            }
            _ => {}
        }
    }

    if errors.is_empty() {
        Ok(())
    } else {
        let has_server_error = errors
            .iter()
            .any(|error| (500..600).contains(&error.status_code));
        let error_chain_ids = errors.iter().map(|error| &error.chain_id).join(", ");
        let json_error = errors.iter().map(|error| &error.error).collect::<Vec<_>>();

        let error = ApiError {
            // This is decoupled from the error collection so it is assuming that any value in [errors]
            // is between 400 and 600. If server errors are found we return 500. Else we return 400
            status: if has_server_error { 500 } else { 400 },
            details: ErrorDetails {
                code: 1337,
                message: Some(format!(
                    "Push notification registration failed for chain IDs: {}",
                    error_chain_ids
                )),
                arguments: None,
                debug: Some(json!(json_error)),
            },
        };
        Err(error)
    }
}

pub fn build_backend_request(
    device_data: &DeviceData,
    safe_registration: &SafeRegistration,
) -> BackendRegistrationRequest {
    BackendRegistrationRequest {
        notification_device_data: device_data.clone(),
        safes: safe_registration.safes.to_owned(),
        signatures: safe_registration.signatures.to_owned(),
    }
}

'''
'''--- src/routes/notifications/mod.rs ---
#[doc(hidden)]
pub mod handlers;
pub mod models;
pub mod routes;
#[cfg(test)]
mod tests;

'''
'''--- src/routes/notifications/models.rs ---
use serde::{Deserialize, Serialize};

/// NotificationRegistrationRequest
///
/// <details>
/// <summary>Example body of NotificationRegistrationRequest registering a device for push notifications</summary>
///
/// ```json
/// 
/// {
///  "uuid": "c50750df-700c-4b17-98ca-b95a5c27ca18",
///  "cloudMessagingToken": "eWv4Ya6OSaiuDI91S0_C6D:APA91bGpprbGOCa1Qev0h3vlMu2nXa9nWpaL7N9fEcX2G4byZ3TSKXircrMtuWg1H4nSG9Ugu7a7rgY1eDKAR9UaxgaP1egTRj3taqAfAQblApuiWFfRRkyxdD3N23t7wYi9ZBIXZ88Z",
///  "bundle": "io.gnosis.safe.debug",
///  "version": "2.13.0",
///  "deviceType": "ANDROID",
///  "buildNumber": "703",
///  "timestamp": "1618906387",
///  "safeRegistrations": [
///      {
///        "chainId": "1",
///        "safes": [
///          "0x00E17aA063fbDB3BFdEfc2c3b2c13173d2711a35"
///        ],
///        "signatures": "0x4b574e7c729db54b427dd17a6b2ae3481221642a9d61c52a53f77500d98ddc1d739c39dfb117619fb09a20e3f5070d018e62c37f89fb622ae10b56a6be9af5c11b"
///      },
///      {
///        "chainId": "4",
///        "safes": [
///          "0x00E17aA063fbDB3BFdEfc2c3b2c13173d2711a35",
///          "0x00e17Aa063FbDB3bFdEfC2c3b2C13173D2711A36"
///        ],
///        "signatures": [
///          "0x4b574e7c729db54b427dd17a6b2ae3481221642a9d61c52a53f77500d98ddc1d739c39dfb117619fb09a20e3f5070d018e62c37f89fb622ae10b56a6be9af5c11b"
///        ]
///       }
///    ]
///  }
/// ```
/// </details>
#[derive(Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(Serialize))]
pub struct NotificationRegistrationRequest {
    #[serde(flatten)]
    pub device_data: DeviceData,
    pub safe_registrations: Vec<SafeRegistration>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct DeviceData {
    pub uuid: Option<String>,
    pub cloud_messaging_token: String,
    pub build_number: String,
    pub bundle: String,
    pub device_type: DeviceType,
    pub version: String,
    pub timestamp: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "UPPERCASE")]
pub enum DeviceType {
    Android,
    Ios,
    Web,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct SafeRegistration {
    pub chain_id: String,
    pub safes: Vec<String>,
    pub signatures: Vec<String>,
}

'''
'''--- src/routes/notifications/routes.rs ---
use crate::routes::notifications::handlers::{delete_registration, post_registration};
use crate::routes::notifications::models::NotificationRegistrationRequest;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::serde::json::{Error, Json};
use rocket_okapi::openapi;

/// `/v1/register/notifications` <br />
/// Returns `()`
///
/// # Register notifications
///
/// This endpoint provides a way for registering devices for push notifications.
///
/// One can subscribe to as many safes in different chains as [SafeRegistration](crate::routes::notifications::models::SafeRegistration) provided in the payload
///
/// ## Path
///
/// `POST /v1/register/notifications`
///
/// ## Query parameters
///
/// No query parameters available for this endpoint.
#[post(
    "/v1/register/notifications",
    format = "application/json",
    data = "<registration_request>"
)]
pub async fn post_notification_registration<'e>(
    context: RequestContext,
    registration_request: Result<Json<NotificationRegistrationRequest>, Error<'e>>,
) -> ApiResult<()> {
    post_registration(&context, registration_request?.0).await
}

/// `/v1/chains/<chain_id>/notifications/devices/<uuid>/safes/<safe_address>` <br />
/// Returns `()`
///
/// # Unregister notifications
///
/// This endpoint provides a way to unsubscribe from push notifications for a given `uuid`.
///
/// Clients are expected to manage the `uuid` provided originally to the backend.
///
/// ## Path
///
/// `DELETE /v1/chains/<chain_id>/notifications/devices/<uuid>/safes/<safe_address>`
///
/// ## Query parameters
///
/// No query parameters available for this endpoint.
#[openapi(tag = "Notifications")]
#[delete("/v1/chains/<chain_id>/notifications/devices/<uuid>/safes/<safe_address>")]
pub async fn delete_notification_registration(
    context: RequestContext,
    chain_id: String,
    uuid: String,
    safe_address: String,
) -> ApiResult<()> {
    delete_registration(&context, chain_id, uuid, safe_address).await
}

'''
'''--- src/routes/notifications/tests/mod.rs ---
mod routes;

'''
'''--- src/routes/notifications/tests/routes.rs ---
use crate::config::chain_info_request_timeout;
use crate::routes::notifications::handlers::build_backend_request;
use crate::routes::notifications::models::{
    DeviceData, DeviceType, NotificationRegistrationRequest, SafeRegistration,
};
use crate::tests::main::setup_rocket;
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::{MockHttpClient, Request, Response};
use mockall::predicate::eq;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;
use std::time::Duration;

#[rocket::async_test]
async fn delete_notification_success() {
    let uuid = "some_uuid";
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let delete_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com\
    /api/v1/notifications/devices/{}/safes/{}/",
        uuid, safe_address
    ));
    mock_http_client
        .expect_delete()
        .times(1)
        .with(eq(delete_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 204,
                body: String::new(),
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::delete_notification_registration],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .delete(format!(
            "/v1/chains/{}/notifications/devices/{}/safes/{}",
            4, uuid, safe_address
        ))
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;
    let actual_status = response.status();

    assert_eq!(Status::Ok, actual_status);
}

#[rocket::async_test]
async fn delete_notification_error() {
    let uuid = "some_uuid";
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let delete_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com\
    /api/v1/notifications/devices/{}/safes/{}/",
        uuid, safe_address
    ));
    mock_http_client
        .expect_delete()
        .times(1)
        .with(eq(delete_request))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 422,
                body: String::new(),
            }))
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::delete_notification_registration],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .delete(format!(
            "/v1/chains/{}/notifications/devices/{}/safes/{}",
            4, uuid, safe_address
        ))
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;
    let actual_status = response.status();

    assert_eq!(Status::UnprocessableEntity, actual_status);
}

#[rocket::async_test]
async fn post_notification_success() {
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";

    let request = NotificationRegistrationRequest {
        device_data: DeviceData {
            uuid: None,
            cloud_messaging_token: "cloud_messaging_token".to_string(),
            build_number: "build_number".to_string(),
            bundle: "bundle".to_string(),
            device_type: DeviceType::Android,
            version: "version".to_string(),
            timestamp: None,
        },
        safe_registrations: vec![
            SafeRegistration {
                chain_id: "4".to_string(),
                safes: vec![safe_address.to_string()],
                signatures: vec!["signature".to_string()],
            },
            SafeRegistration {
                chain_id: "137".to_string(),
                safes: vec![safe_address.to_string()],
                signatures: vec!["signature".to_string()],
            },
        ],
    };

    let backend_request =
        build_backend_request(&request.device_data, &request.safe_registrations[0]); // chain_id is ignored by this method

    let mut mock_http_client = MockHttpClient::new();

    let mut rinkeby_chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    rinkeby_chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    mock_http_client
        .expect_get()
        .with(eq(rinkeby_chain_request))
        .times(1)
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut polygon_chain_request = Request::new(config_uri!("/v1/chains/{}/", 137));
    polygon_chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    mock_http_client
        .expect_get()
        .with(eq(polygon_chain_request))
        .times(1)
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_POLYGON),
            })
        });

    let mut post_request_rinkeby = Request::new(String::from(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/notifications/devices/",
    ));
    post_request_rinkeby.body(Some(serde_json::to_string(&backend_request).unwrap()));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(post_request_rinkeby))
        .return_once(move |_| {
            Ok(Response {
                status_code: 204,
                body: String::new(),
            })
        });

    let mut post_request_polygon = Request::new(String::from(
        "https://safe-transaction-polygon.staging.gnosisdev.com/api/v1/notifications/devices/",
    ));
    post_request_polygon.body(Some(serde_json::to_string(&backend_request).unwrap()));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(post_request_polygon))
        .return_once(move |_| {
            Ok(Response {
                status_code: 204,
                body: String::new(),
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_notification_registration],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v1/register/notifications")
        .body(&serde_json::to_string(&request).unwrap())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;
    let actual_status = response.status();

    assert_eq!(Status::Ok, actual_status);
}

#[rocket::async_test]
async fn post_notification_client_error() {
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";
    let expected_error = ErrorDetails {
        code: 1337,
        message: Some("Push notification registration failed for chain IDs: 4, 137".to_string()),
        arguments: None,
        debug: serde_json::from_str(
            "[{\"4\":{\"code\":500,\"message\":null}}\
        ,{\"137\":{\"safes\":{\"0\":[\"Address 0x0 is not valid\"]},\
        \"timestamp\":[\"Provided timestamp is not in a range within 5 minutes\"]}}]",
        )
        .ok(),
    };

    let request = NotificationRegistrationRequest {
        device_data: DeviceData {
            uuid: None,
            cloud_messaging_token: "cloud_messaging_token".to_string(),
            build_number: "build_number".to_string(),
            bundle: "bundle".to_string(),
            device_type: DeviceType::Android,
            version: "version".to_string(),
            timestamp: None,
        },
        safe_registrations: vec![
            SafeRegistration {
                chain_id: "4".to_string(),
                safes: vec!["0x0".to_string()],
                signatures: vec!["signature".to_string()],
            },
            SafeRegistration {
                chain_id: "137".to_string(),
                safes: vec![safe_address.to_string()],
                signatures: vec!["signature".to_string()],
            },
        ],
    };

    let rinkeby_backend_request =
        build_backend_request(&request.device_data, &request.safe_registrations[0]);
    let polygon_backend_request =
        build_backend_request(&request.device_data, &request.safe_registrations[1]);

    let mut mock_http_client = MockHttpClient::new();

    let mut rinkeby_chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    rinkeby_chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    mock_http_client
        .expect_get()
        .with(eq(rinkeby_chain_request))
        .times(1)
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut polygon_chain_request = Request::new(config_uri!("/v1/chains/{}/", 137));
    polygon_chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));

    mock_http_client
        .expect_get()
        .with(eq(polygon_chain_request))
        .times(1)
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_POLYGON),
            })
        });

    let mut post_request_rinkeby = Request::new(String::from(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/notifications/devices/",
    ));
    post_request_rinkeby.body(Some(
        serde_json::to_string(&rinkeby_backend_request).unwrap(),
    ));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(post_request_rinkeby))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 422,
                body: serde_json::to_string(&ErrorDetails {
                    code: 500,
                    message: None,
                    arguments: None,
                    debug: None,
                })
                .unwrap(),
            }))
        });

    let mut post_request_polygon = Request::new(String::from(
        "https://safe-transaction-polygon.staging.gnosisdev.com/api/v1/notifications/devices/",
    ));
    post_request_polygon.body(Some(
        serde_json::to_string(&polygon_backend_request).unwrap(),
    ));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(post_request_polygon))
        .return_once(move |_| {
            Err(ApiError::new_from_message_with_code(
                400,
                "{\"safes\": {\
                            \"0\": [\
                                \"Address 0x0 is not valid\"\
                            ]\
                        },\
                        \"timestamp\": [\
                            \"Provided timestamp is not in a range within 5 minutes\"\
                        ]}"
                .to_string(),
            ))
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_notification_registration],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v1/register/notifications")
        .body(&serde_json::to_string(&request).unwrap())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;
    let actual_status = response.status();
    let error_body = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<ErrorDetails>(&error_body).unwrap();

    assert_eq!(Status::BadRequest, actual_status);
    assert_eq!(expected_error, actual);
}

#[rocket::async_test]
async fn post_notification_server_and_client_errors() {
    let mut mock_http_client = MockHttpClient::new();
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";
    // Mock /v1/chains/
    let mut polygon_chain_request = Request::new(config_uri!("/v1/chains/{}/", 137));
    polygon_chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    mock_http_client
        .expect_get()
        .with(eq(polygon_chain_request))
        .times(1)
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_POLYGON),
            })
        });
    // Request Payload
    let request = NotificationRegistrationRequest {
        device_data: DeviceData {
            uuid: None,
            cloud_messaging_token: "cloud_messaging_token".to_string(),
            build_number: "build_number".to_string(),
            bundle: "bundle".to_string(),
            device_type: DeviceType::Android,
            version: "version".to_string(),
            timestamp: None,
        },
        safe_registrations: vec![
            SafeRegistration {
                chain_id: "137".to_string(),
                safes: vec!["0x0".to_string()],
                signatures: vec!["signature".to_string()],
            },
            SafeRegistration {
                chain_id: "137".to_string(),
                safes: vec![safe_address.to_string()],
                signatures: vec!["signature".to_string()],
            },
        ],
    };
    // POST request with first payload â€“ returns a 400
    let polygon_backend_request_0 =
        build_backend_request(&request.device_data, &request.safe_registrations[0]);
    let mut post_request_polygon_0 = Request::new(String::from(
        "https://safe-transaction-polygon.staging.gnosisdev.com/api/v1/notifications/devices/",
    ));
    post_request_polygon_0.body(Some(
        serde_json::to_string(&polygon_backend_request_0).unwrap(),
    ));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(post_request_polygon_0))
        .return_once(move |_| {
            Err(ApiError::new_from_message_with_code(
                400,
                "{ \"test\" : \"Some client error\"}".to_string(),
            ))
        });
    // POST request with first payload â€“ returns a 500
    let polygon_backend_request_1 =
        build_backend_request(&request.device_data, &request.safe_registrations[1]);
    let mut post_request_polygon_1 = Request::new(String::from(
        "https://safe-transaction-polygon.staging.gnosisdev.com/api/v1/notifications/devices/",
    ));
    post_request_polygon_1.body(Some(
        serde_json::to_string(&polygon_backend_request_1).unwrap(),
    ));
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(post_request_polygon_1))
        .return_once(move |_| {
            Err(ApiError::new_from_message_with_code(
                500,
                "{ \"test\" : \"Some server error\"}".to_string(),
            ))
        });

    // Test execution
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_notification_registration],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let request = client
        .post("/v1/register/notifications")
        .body(&serde_json::to_string(&request).unwrap())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);
    let response = request.dispatch().await;
    let actual_status = response.status();
    let error_body = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<ErrorDetails>(&error_body).unwrap();

    let expected_error = ErrorDetails {
        code: 1337,
        message: Some("Push notification registration failed for chain IDs: 137, 137".to_string()),
        arguments: None,
        debug: serde_json::from_str("[ {\"137\" : { \"test\" : \"Some client error\"}}, {\"137\" : { \"test\" : \"Some server error\"}}]").ok(),
    };
    assert_eq!(Status::InternalServerError, actual_status);
    assert_eq!(expected_error, actual);
}

'''
'''--- src/routes/safe_apps/converters.rs ---
use crate::common::models::backend::safe_apps::{
    SafeApp as BackendSafeApp, SafeAppAccessControlPolicies as BackendSafeAppAccessControlPolicies,
};
use crate::routes::safe_apps::models::{
    SafeApp, SafeAppAccessControlPolicies, SafeAppDomainAllowlistPolicy, SafeAppProvider,
};

impl From<BackendSafeApp> for SafeApp {
    fn from(safe_app: BackendSafeApp) -> Self {
        SafeApp {
            id: safe_app.id,
            url: safe_app.url.to_string(),
            name: safe_app.name.to_string(),
            icon_url: safe_app.icon_url.to_string(),
            description: safe_app.description.to_string(),
            chain_ids: safe_app
                .chain_ids
                .into_iter()
                .map(|chain_id| chain_id.to_string())
                .collect(),
            provider: safe_app.provider.as_ref().map(|provider| SafeAppProvider {
                url: provider.url.to_string(),
                name: provider.name.to_string(),
            }),
            access_control: match safe_app.access_control {
                BackendSafeAppAccessControlPolicies::NoRestrictions => {
                    SafeAppAccessControlPolicies::NoRestrictions
                }
                BackendSafeAppAccessControlPolicies::DomainAllowlist(policy) => {
                    SafeAppAccessControlPolicies::DomainAllowlist(SafeAppDomainAllowlistPolicy {
                        value: policy.value,
                    })
                }
                _ => SafeAppAccessControlPolicies::Unknown,
            },
            tags: safe_app.tags,
        }
    }
}

'''
'''--- src/routes/safe_apps/handlers.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::backend::safe_apps::SafeApp as BackendSafeApp;
use crate::config::safe_apps_cache_duration;
use crate::routes::safe_apps::models::SafeApp;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;

pub async fn safe_apps(
    context: &RequestContext,
    chain_id: &String,
    client_url: &Option<String>,
    url: &Option<String>,
) -> ApiResult<Vec<SafeApp>> {
    let url = config_uri!(
        "/v1/safe-apps/?chainId={}&clientUrl={}&url={}",
        chain_id,
        client_url.as_deref().unwrap_or(""),
        url.as_deref().unwrap_or("")
    );
    let data = RequestCached::new_from_context(url, &context, ChainCache::from(chain_id.as_str()))
        .cache_duration(safe_apps_cache_duration())
        .execute()
        .await?;

    Ok(serde_json::from_str::<Vec<BackendSafeApp>>(&data)?
        .into_iter()
        .map(|backend_safe_app| backend_safe_app.into())
        .collect::<Vec<SafeApp>>())
}

'''
'''--- src/routes/safe_apps/mod.rs ---
#[doc(hidden)]
pub mod converters;
#[doc(hidden)]
pub mod handlers;
pub mod models;
pub mod routes;
#[cfg(test)]
mod tests;

'''
'''--- src/routes/safe_apps/models.rs ---
use serde::Serialize;

use crate::config::is_safe_apps_tags_feature_enabled;

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct SafeApp {
    pub id: u64,
    pub url: String,
    pub name: String,
    pub icon_url: String,
    pub description: String,
    pub chain_ids: Vec<String>,
    pub provider: Option<SafeAppProvider>,
    pub access_control: SafeAppAccessControlPolicies,
    #[serde(skip_serializing_if = "should_skip_serializing_tags")]
    // We deserialize this for testing so it would break since the value wouldn't be present
    #[serde(default)]
    pub tags: Vec<String>,
}

pub fn should_skip_serializing_tags(_tags: &Vec<String>) -> bool {
    return !is_safe_apps_tags_feature_enabled();
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct SafeAppProvider {
    pub url: String,
    pub name: String,
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(tag = "type")]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub enum SafeAppAccessControlPolicies {
    NoRestrictions,
    DomainAllowlist(SafeAppDomainAllowlistPolicy),
    #[serde(other)]
    Unknown,
}

#[derive(Serialize, Debug, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct SafeAppDomainAllowlistPolicy {
    pub value: Vec<String>,
}

'''
'''--- src/routes/safe_apps/routes.rs ---
use crate::routes::safe_apps::handlers::safe_apps;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::response::content;
use rocket_okapi::openapi;
/// `/v1/chains/<chain_id>/safe-apps` <br />
/// Returns [SafeApp](crate::routes::safe_apps::models::SafeApp)
///
/// # Safe Apps
///
/// This endpoint returns the list of Safe apps supported on a network
///
/// ## Path
///
/// - `/v1/chains/<chain_id>/safe-apps`
///
/// ## Query parameters
///
/// - `client_url`: The URL of the client application. Optional.
/// - `url`: Filter Safe Apps available from url. url needs to be an exact match. Optional.
///
/// ## Examples
///
/// [
///     {
///         "id": 24,
///         "url": "https://cloudflare-ipfs.com/ipfs/QmdVaZxDov4bVARScTLErQSRQoxgqtBad8anWuw3YPQHCs",
///         "name": "Transaction Builder",
///         "iconUrl": "https://cloudflare-ipfs.com/ipfs/QmdVaZxDov4bVARScTLErQSRQoxgqtBad8anWuw3YPQHCs/tx-builder.png",
///         "description": "A Safe app to compose custom transactions",
///         "chainIds": [
///             "1",
///             "4",
///             "56",
///             "100",
///             "137",
///             "246",
///             "73799"
///         ],
///         "provider": null,
///         "accessControl": {
///            "type": "NO_RESTRICTIONS"
///          }
///     },
///     {
///         "id": 25,
///         "url": "https://cloudflare-ipfs.com/ipfs/QmTpLhxSiD1H94BFxeV2P6RfJf6EyCxxUCVYpcDffyMmmZ",
///         "name": "WalletConnect",
///         "iconUrl": "https://cloudflare-ipfs.com/ipfs/QmTpLhxSiD1H94BFxeV2P6RfJf6EyCxxUCVYpcDffyMmmZ/wallet-connect.svg",
///         "description": "Allows your Gnosis Safe Multisig to connect to dapps via WalletConnect.",
///         "chainIds": [
///             "1",
///             "4",
///             "56",
///             "100",
///             "137",
///             "246",
///             "73799",
///             "42161"
///         ],
///         "provider": null,
///         "accessControl": {
///            "type": "DOMAIN_ALLOWLIST",
///           "value": ["https://gnosis-safe.io"]
///          }
///     }
/// ]
#[openapi(tag = "SafeApps")]
#[get("/v1/chains/<chain_id>/safe-apps?<client_url>&<url>")]
pub async fn get_safe_apps(
    context: RequestContext,
    chain_id: String,
    client_url: Option<String>,
    url: Option<String>,
) -> ApiResult<content::RawJson<String>> {
    Ok(content::RawJson(serde_json::to_string(
        &safe_apps(&context, &chain_id, &client_url, &url).await?,
    )?))
}

'''
'''--- src/routes/safe_apps/tests/json/response_safe_apps.json ---
[
  {
    "id": 26,
    "url": "https://curve.fi",
    "name": "Curve",
    "iconUrl": "https://curve.fi/logo-square.svg",
    "description": "Decentralized exchange liquidity pool designed for extremely efficient stablecoin trading and low-risk income for liquidity providers",
    "chainIds": ["1", "137"],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  },
  {
    "id": 24,
    "url": "https://safe-apps.dev.gnosisdev.com/tx-builder",
    "name": "Transaction Builder",
    "iconUrl": "https://safe-apps.dev.gnosisdev.com/tx-builder/tx-builder.png",
    "description": "A Safe app to compose custom transactions",
    "chainIds": [
      "1",
      "4",
      "10",
      "56",
      "100",
      "137",
      "246",
      "42161",
      "43114",
      "73799"
    ],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  },
  {
    "id": 11,
    "url": "https://app.1inch.io",
    "name": "1inch.exchange",
    "iconUrl": "https://app.1inch.io/assets/images/1inch.svg",
    "description": "The most efficient defi aggregator",
    "chainIds": ["1", "56", "137"],
    "provider": {
      "url": "https://1inch.exchange",
      "name": "1inch corporation"
    },
    "accessControl": {
      "type": "DOMAIN_ALLOWLIST",
      "value": ["https://gnosis-safe.io", "https://dev.gnosis-safe.io"]
    }
  },
  {
    "id": 30,
    "url": "https://paraswap.io",
    "name": "ParaSwap",
    "iconUrl": "https://paraswap.io/paraswap.svg",
    "description": "ParaSwap allows dApps and traders to get the best DEX liquidity by aggregating multiple markets and offering the best rates",
    "chainIds": ["1", "56", "137"],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  },
  {
    "id": 25,
    "url": "https://safe-apps.dev.gnosisdev.com/wallet-connect",
    "name": "WalletConnect",
    "iconUrl": "https://safe-apps.dev.gnosisdev.com/wallet-connect/wallet-connect.svg",
    "description": "Connect your Safe to any dApp that supports WalletConnect",
    "chainIds": [
      "1",
      "4",
      "10",
      "56",
      "100",
      "137",
      "246",
      "73799",
      "42161",
      "43114"
    ],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  }
]

'''
'''--- src/routes/safe_apps/tests/json/response_safe_apps_url_query.json ---
[
  {
    "id": 26,
    "url": "https://test.app",
    "name": "Test App",
    "iconUrl": "https://test.app/logo.svg",
    "description": "Some cool app",
    "chainIds": ["1", "137"],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  }
]

'''
'''--- src/routes/safe_apps/tests/json/response_safe_apps_with_tags.json ---
[
  {
    "id": 26,
    "url": "https://curve.fi",
    "name": "Curve",
    "iconUrl": "https://curve.fi/logo-square.svg",
    "description": "Decentralized exchange liquidity pool designed for extremely efficient stablecoin trading and low-risk income for liquidity providers",
    "chainIds": ["1", "137"],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    },
    "tags": ["tag1"]
  },
  {
    "id": 24,
    "url": "https://safe-apps.dev.gnosisdev.com/tx-builder",
    "name": "Transaction Builder",
    "iconUrl": "https://safe-apps.dev.gnosisdev.com/tx-builder/tx-builder.png",
    "description": "A Safe app to compose custom transactions",
    "chainIds": [
      "1",
      "4",
      "10",
      "56",
      "100",
      "137",
      "246",
      "42161",
      "43114",
      "73799"
    ],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    },
    "tags": ["tag2"]
  },
  {
    "id": 11,
    "url": "https://app.1inch.io",
    "name": "1inch.exchange",
    "iconUrl": "https://app.1inch.io/assets/images/1inch.svg",
    "description": "The most efficient defi aggregator",
    "chainIds": ["1", "56", "137"],
    "provider": {
      "url": "https://1inch.exchange",
      "name": "1inch corporation"
    },
    "accessControl": {
      "type": "DOMAIN_ALLOWLIST",
      "value": ["https://gnosis-safe.io", "https://dev.gnosis-safe.io"]
    }
  },
  {
    "id": 30,
    "url": "https://paraswap.io",
    "name": "ParaSwap",
    "iconUrl": "https://paraswap.io/paraswap.svg",
    "description": "ParaSwap allows dApps and traders to get the best DEX liquidity by aggregating multiple markets and offering the best rates",
    "chainIds": ["1", "56", "137"],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  },
  {
    "id": 25,
    "url": "https://safe-apps.dev.gnosisdev.com/wallet-connect",
    "name": "WalletConnect",
    "iconUrl": "https://safe-apps.dev.gnosisdev.com/wallet-connect/wallet-connect.svg",
    "description": "Connect your Safe to any dApp that supports WalletConnect",
    "chainIds": [
      "1",
      "4",
      "10",
      "56",
      "100",
      "137",
      "246",
      "73799",
      "42161",
      "43114"
    ],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    },
    "tags": ["tag1", "tag2"]
  }
]

'''
'''--- src/routes/safe_apps/tests/mod.rs ---
mod routes;

pub(crate) const RESPONSE_SAFE_APPS: &str = include_str!("json/response_safe_apps.json");
pub(crate) const RESPONSE_SAFE_APPS_WITH_TAGS: &str =
    include_str!("json/response_safe_apps_with_tags.json");
pub(crate) const RESPONSE_SAFE_APPS_WITH_URL_QUERY: &str =
    include_str!("json/response_safe_apps_url_query.json");

'''
'''--- src/routes/safe_apps/tests/routes.rs ---
use crate::routes::safe_apps::models::SafeApp;
use crate::routes::safe_apps::tests::{
    RESPONSE_SAFE_APPS_WITH_TAGS, RESPONSE_SAFE_APPS_WITH_URL_QUERY,
};
use crate::tests::main::setup_rocket;
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::{MockHttpClient, Request, Response};
use mockall::predicate::eq;
use rocket::http::{Header, Status};
use rocket::local::asynchronous::Client;
use serde_json::json;
use std::env;

use super::RESPONSE_SAFE_APPS;

#[rocket::async_test]
async fn safe_apps() {
    env::set_var("SAFE_APPS_TAGS_FEATURE_ENABLED", "false");
    let chain_id = "137";
    let client_url = "https://gnosis-safe.io";

    let mut mock_http_client = MockHttpClient::new();

    let safe_apps_request = Request::new(config_uri!(
        "/v1/safe-apps/?chainId={}&clientUrl={}&url=",
        chain_id,
        client_url
    ));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_apps_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::POLYGON_SAFE_APPS),
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_safe_apps],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/v1/chains/137/safe-apps?client_url=https://gnosis-safe.io");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };
    let actual_status = response.status();
    let actual_body = response.into_string().await.unwrap();
    let actual: Vec<SafeApp> = serde_json::from_str(&actual_body).unwrap();
    let expected: Vec<SafeApp> = serde_json::from_str(RESPONSE_SAFE_APPS).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn safe_apps_not_found() {
    env::set_var("SAFE_APPS_TAGS_FEATURE_ENABLED", "false");
    let chain_id = "4";
    let backend_error_json = json!({"details": "Not found"}).to_string();
    let error = ErrorDetails {
        code: 1337,
        message: Some(backend_error_json.clone()),
        arguments: None,
        debug: None,
    };

    let mut mock_http_client = MockHttpClient::new();

    let safe_apps_request = Request::new(config_uri!(
        "/v1/safe-apps/?chainId={}&clientUrl=&url=",
        chain_id
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_apps_request))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: backend_error_json.clone(),
            }))
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_safe_apps],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/v1/chains/4/safe-apps");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };

    assert_eq!(response.status(), Status::NotFound);
    assert_eq!(
        response.into_string().await.unwrap(),
        serde_json::to_string(&error).unwrap()
    );
}

#[rocket::async_test]
async fn safe_apps_tags() {
    env::set_var("SAFE_APPS_TAGS_FEATURE_ENABLED", "true");
    let chain_id = "137";
    let client_url = "https://gnosis-safe.io";
    let mut mock_http_client = MockHttpClient::new();
    let safe_apps_request = Request::new(config_uri!(
        "/v1/safe-apps/?chainId={}&clientUrl={}&url=",
        chain_id,
        client_url
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_apps_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::POLYGON_SAFE_APPS_WITH_TAGS),
            })
        });
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_safe_apps],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client.get("/v1/chains/137/safe-apps?client_url=https://gnosis-safe.io");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };
    let actual_status = response.status();
    let actual_body = response.into_string().await.unwrap();
    let actual: Vec<SafeApp> = serde_json::from_str(&actual_body).unwrap();
    let expected: Vec<SafeApp> = serde_json::from_str(RESPONSE_SAFE_APPS_WITH_TAGS).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn safe_apps_url_query_param() {
    env::set_var("SAFE_APPS_TAGS_FEATURE_ENABLED", "false");
    let chain_id = "137";
    let client_url = "https://gnosis-safe.io";
    let url = "https://test.app";

    let mut mock_http_client = MockHttpClient::new();

    let safe_apps_request = Request::new(config_uri!(
        "/v1/safe-apps/?chainId={}&clientUrl={}&url={}",
        chain_id,
        client_url,
        url
    ));

    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_apps_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::POLYGON_SAFE_APP_URL_QUERY),
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_safe_apps],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let response = {
        let mut response = client
            .get("/v1/chains/137/safe-apps?client_url=https://gnosis-safe.io&url=https://test.app");
        response.add_header(Header::new("Host", "test.safe.global"));
        response.dispatch().await
    };
    let actual_status = response.status();
    let actual_body = response.into_string().await.unwrap();
    let actual: Vec<SafeApp> = serde_json::from_str(&actual_body).unwrap();
    let expected: Vec<SafeApp> = serde_json::from_str(RESPONSE_SAFE_APPS_WITH_URL_QUERY).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

'''
'''--- src/routes/safes/converters.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::safes::MasterCopy;
use crate::providers::ext::InfoProviderExt;
use crate::providers::info::{InfoProvider, SafeInfo};
use crate::routes::safes::models::{Implementation, ImplementationVersionState, SafeInfoEx};
use semver::Version;
use std::cmp::Ordering;

// We need to add Sync as trait bound as info_provider moves across threads
impl SafeInfo {
    pub async fn to_safe_info_ex(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        supported_master_copies: Vec<MasterCopy>,
    ) -> SafeInfoEx {
        let min_chain_version = info_provider
            .chain_info()
            .await
            .expect("ChainInfo must be available")
            .recommended_master_copy_version;
        let implementation_version_state =
            self.version
                .as_ref()
                .map_or(ImplementationVersionState::Unknown, |safe_version| {
                    calculate_version_state(
                        safe_version,
                        &self.master_copy,
                        &supported_master_copies,
                        min_chain_version,
                    )
                });

        SafeInfoEx {
            address: AddressEx::address_only(&self.address),
            chain_id: info_provider.chain_id().to_string(),
            nonce: self.nonce,
            threshold: self.threshold,
            implementation: info_provider
                .address_ex_from_contracts_or_default(&self.master_copy)
                .await,
            owners: self
                .owners
                .iter()
                .map(|owner| AddressEx::address_only(&owner))
                .collect(),
            modules: info_provider
                .multiple_address_ex_from_contracts(&self.modules)
                .await,
            fallback_handler: info_provider
                .address_ex_from_contracts_optional(&self.fallback_handler)
                .await,
            guard: info_provider
                .address_ex_from_contracts_optional(&self.guard)
                .await,
            version: self.version.to_owned(),
            implementation_version_state,
        }
    }
}

pub(crate) fn calculate_version_state(
    safe_version: &str,
    safe_implementation_address: &str,
    supported_master_copies: &Vec<MasterCopy>,
    min_chain_version: String,
) -> ImplementationVersionState {
    let sem_ver_safe = Version::parse(safe_version);
    let sem_ver_min = Version::parse(&min_chain_version);

    let supported_addresses = supported_master_copies
        .iter()
        .map(|it| it.address.as_str())
        .collect::<Vec<&str>>();

    if sem_ver_min.is_err()
        || sem_ver_safe.is_err()
        || !supported_addresses.contains(&safe_implementation_address)
    {
        return ImplementationVersionState::Unknown;
    }

    let sem_ver_safe = sem_ver_safe.unwrap();
    let sem_ver_min = sem_ver_min.unwrap();

    match sem_ver_safe.cmp(&sem_ver_min) {
        Ordering::Less => ImplementationVersionState::Outdated,
        Ordering::Equal | Ordering::Greater => ImplementationVersionState::UpToDate,
    }
}

impl From<MasterCopy> for Implementation {
    fn from(master_copy: MasterCopy) -> Self {
        Implementation {
            address: master_copy.address,
            version: master_copy.version,
        }
    }
}

'''
'''--- src/routes/safes/handlers/estimations.rs ---
use std::sync::Arc;

use crate::common::models::backend::transactions::{
    MultisigTransaction as BackendMultisigTransaction,
    SafeTransactionEstimation as BackendSafeTransactionEstimation,
};
use crate::common::models::page::Page;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::safes::models::{
    SafeTransactionEstimation, SafeTransactionEstimationRequest, SafeTransactionEstimationV2,
};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::{HttpClient, Request};
use std::cmp::max;

async fn get_last_known_nonce_and_estimate(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    safe_transaction_estimation_request: &SafeTransactionEstimationRequest,
) -> ApiResult<(String, u64, Option<u64>)> {
    let info_provider = DefaultInfoProvider::new(chain_id, &context);

    let current_nonce = info_provider.safe_info(safe_address).await?.nonce;

    let latest_multisig_tx_url = core_uri!(
        info_provider,
        "/v1/safes/{}/multisig-transactions/?ordering=-nonce&trusted=true&limit=1",
        safe_address
    )?;
    let last_known_nonce =
        fetch_last_known_nonce(context.http_client(), latest_multisig_tx_url).await?;

    let estimation_url = core_uri!(
        info_provider,
        "/v1/safes/{}/multisig-transactions/estimations/",
        safe_address
    )?;
    let safe_tx_gas = fetch_estimation(
        context.http_client(),
        estimation_url,
        safe_transaction_estimation_request,
    )
    .await?;

    Ok((safe_tx_gas, current_nonce, last_known_nonce))
}

pub async fn estimate_safe_tx_gas(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    safe_transaction_estimation_request: &SafeTransactionEstimationRequest,
) -> ApiResult<SafeTransactionEstimation> {
    let (safe_tx_gas, current_nonce, last_known_nonce) = get_last_known_nonce_and_estimate(
        context,
        chain_id,
        safe_address,
        safe_transaction_estimation_request,
    )
    .await?;

    // If there is no transaction available on the tx service, we default to 0
    // Note: This is not really correct and therefore clients should use the recommended nonce returned
    let latest_nonce = last_known_nonce.unwrap_or(0);

    Ok(SafeTransactionEstimation {
        current_nonce,
        latest_nonce,
        safe_tx_gas,
    })
}

pub async fn estimate_safe_tx_gas_v2(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    safe_transaction_estimation_request: &SafeTransactionEstimationRequest,
) -> ApiResult<SafeTransactionEstimationV2> {
    let (safe_tx_gas, current_nonce, last_known_nonce) = get_last_known_nonce_and_estimate(
        context,
        chain_id,
        safe_address,
        safe_transaction_estimation_request,
    )
    .await?;

    // The next nonce recommended to use for a new transaction is the maximum of
    // - the nonce of the latest transaction from the tx service plus 1, or 0 if there is no such transaction
    // - the current Safe nonce
    let recommended_nonce = max(
        current_nonce,
        last_known_nonce.map(|it| it + 1).unwrap_or(0),
    );

    Ok(SafeTransactionEstimationV2 {
        current_nonce,
        recommended_nonce,
        safe_tx_gas,
    })
}

async fn fetch_estimation(
    client: Arc<dyn HttpClient>,
    request_url: String,
    safe_transaction_estimation_request: &SafeTransactionEstimationRequest,
) -> ApiResult<String> {
    let request = {
        let mut request = Request::new(request_url);
        request.body(Some(serde_json::to_string(
            safe_transaction_estimation_request,
        )?));
        request
    };
    let estimation_response = client.post(request).await?;

    Ok(
        serde_json::from_str::<BackendSafeTransactionEstimation>(&estimation_response.body)?
            .safe_tx_gas,
    )
}

async fn fetch_last_known_nonce(
    client: Arc<dyn HttpClient>,
    request_url: String,
) -> ApiResult<Option<u64>> {
    let request = Request::new(request_url);
    let latest_multisig_tx_response = client.get(request).await?;
    let nonce = serde_json::from_str::<Page<BackendMultisigTransaction>>(
        &latest_multisig_tx_response.body,
    )?
    .results
    .first()
    .map(|it| it.nonce);

    Ok(nonce)
}

'''
'''--- src/routes/safes/handlers/mod.rs ---
pub mod estimations;
pub mod safes;

'''
'''--- src/routes/safes/handlers/safes.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::backend::transactions::{MultisigTransaction, Transaction};
use crate::common::models::backend::transfers::Transfer;
use crate::common::models::page::{Page, SafeList};
use crate::config::{
    is_messages_feature_enabled, owners_for_safes_cache_duration, transaction_request_timeout,
};
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::messages::backend_models::Message;
use crate::routes::safes::models::{SafeLastChanges, SafeState};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::Request;
use chrono::Utc;
use rocket::futures::join;

// We use Utc::now().timestamp() as the fallback value so that we don't block clients from reloading
// as returning always 0, and the clients invalidating on value changes, would prevent reloading
pub async fn get_safe_info_ex(
    context: &RequestContext,
    chain_id: &String,
    safe_address: &String,
) -> ApiResult<SafeState> {
    let info_provider = DefaultInfoProvider::new(chain_id, &context);
    let safe_info = info_provider.safe_info(safe_address).await?;
    // We want to be able to return the rest of `SafeInfo` in case the `about/master-copies` endpoint is not available
    let supported_master_copies = info_provider.master_copies().await.unwrap_or(vec![]);
    let safe_info_ex = safe_info
        .to_safe_info_ex(&info_provider, supported_master_copies)
        .await;

    let (collectibles_tag, tx_queued_tag, tx_history_tag) = join!(
        get_last_collectible(&info_provider, safe_address),
        get_last_queued_tx(&info_provider, safe_address),
        get_last_history_tx(&info_provider, safe_address)
    );

    // This branch won't be required once the Messages feature is considered stable
    // SafeLastChanges.messages_tag can also be safely converted to a non-optional field
    let messages_tag: Option<String> = if is_messages_feature_enabled() {
        Some(
            get_last_modified_message(&info_provider, safe_address)
                .await
                .unwrap_or(Utc::now().timestamp())
                .to_string(),
        )
    } else {
        None
    };

    let safe_state = SafeState {
        safe_config: safe_info_ex,
        safe_state: SafeLastChanges {
            collectibles_tag: collectibles_tag
                .unwrap_or(Utc::now().timestamp())
                .to_string(),
            tx_queued_tag: tx_queued_tag.unwrap_or(Utc::now().timestamp()).to_string(),
            tx_history_tag: tx_history_tag.unwrap_or(Utc::now().timestamp()).to_string(),
            messages_tag,
        },
    };

    Ok(safe_state)
}

async fn get_last_modified_message(
    info_provider: &impl InfoProvider,
    safe_address: &String,
) -> ApiResult<i64> {
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/messages/?ordering=-modified&limit=1",
        safe_address
    )?;
    let http_request = Request::new(url);
    let body = info_provider.client().get(http_request).await?.body;
    let messages_page: Page<Message> = serde_json::from_str::<Page<Message>>(&body)?;

    return messages_page
        .results
        .get(0)
        .map(|message| message.modified.timestamp())
        .ok_or(api_error!("Couldn't get tx timestamps"));
}

async fn get_last_collectible(
    info_provider: &impl InfoProvider,
    safe_address: &String,
) -> ApiResult<i64> {
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/transfers/?\
        &erc721=true\
        &limit=1",
        safe_address,
    )?;

    let body = RequestCached::new(url, &info_provider.client(), &info_provider.cache())
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;
    let transaction: Page<Transfer> = serde_json::from_str(&body)?;

    transaction
        .results
        .get(0)
        .as_ref()
        .map(|transfer| match transfer {
            Transfer::Erc721(transfer) => transfer.execution_date.timestamp(),
            Transfer::Erc20(transfer) => transfer.execution_date.timestamp(),
            Transfer::Ether(transfer) => transfer.execution_date.timestamp(),
            Transfer::Unknown => Utc::now().timestamp(),
        })
        .ok_or(api_error!("Couldn't get tx timestamps"))
}

async fn get_last_queued_tx(
    info_provider: &impl InfoProvider,
    safe_address: &String,
) -> ApiResult<i64> {
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/multisig-transactions/?\
        &ordering=-modified\
        &executed=false\
        &trusted=true\
        &limit=1",
        safe_address,
    )?;

    let body = RequestCached::new(url, &info_provider.client(), &info_provider.cache())
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;
    let transaction: Page<MultisigTransaction> = serde_json::from_str(&body)?;

    transaction
        .results
        .get(0)
        .as_ref()
        .map(|tx| tx.modified.as_ref().map(|it| it.timestamp()))
        .flatten()
        .ok_or(api_error!("Couldn't get tx timestamps"))
}

async fn get_last_history_tx(
    info_provider: &impl InfoProvider,
    safe_address: &String,
) -> ApiResult<i64> {
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/all-transactions/?\
        &ordering=executionDate
        &queued=false\
        &executed=true",
        safe_address
    )?;

    let body = RequestCached::new(url, &info_provider.client(), &info_provider.cache())
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;
    let transaction: Page<Transaction> = serde_json::from_str(&body)?;

    transaction
        .results
        .get(0)
        .as_ref()
        .map(|tx| match tx {
            Transaction::Multisig(tx) => tx
                .modified
                .as_ref()
                .map(|it| it.timestamp())
                .unwrap_or(tx.submission_date.timestamp()),
            Transaction::Ethereum(tx) => tx.execution_date.timestamp(),
            Transaction::Module(tx) => tx.execution_date.timestamp(),
            Transaction::Unknown => Utc::now().timestamp(),
        })
        .ok_or(api_error!("Couldn't get tx timestamps"))
}

pub async fn get_owners_for_safe(
    context: &RequestContext,
    chain_id: &str,
    owner_address: &str,
) -> ApiResult<SafeList> {
    let info_provider = DefaultInfoProvider::new(&chain_id, context);

    let url = core_uri!(info_provider, "/v1/owners/{}/safes/", owner_address)?;
    let body = RequestCached::new_from_context(url, context, ChainCache::from(chain_id))
        .cache_duration(owners_for_safes_cache_duration())
        .execute()
        .await?;

    Ok(serde_json::from_str(&body)?)
}

'''
'''--- src/routes/safes/mod.rs ---
#[doc(hidden)]
pub mod converters;
#[doc(hidden)]
pub mod handlers;
pub mod models;
pub mod routes;

#[cfg(test)]
mod tests;

'''
'''--- src/routes/safes/models.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::data_decoded::Operation;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(Deserialize))]
pub struct SafeInfoEx {
    pub address: AddressEx,
    pub chain_id: String,
    pub nonce: u64,
    pub threshold: u64,
    pub owners: Vec<AddressEx>,
    pub implementation: AddressEx,
    pub modules: Option<Vec<AddressEx>>,
    pub fallback_handler: Option<AddressEx>,
    pub guard: Option<AddressEx>,
    pub version: Option<String>,
    pub implementation_version_state: ImplementationVersionState,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(Deserialize))]
pub struct SafeLastChanges {
    pub collectibles_tag: String,
    pub tx_queued_tag: String,
    pub tx_history_tag: String,
    // Can be String once the Messages feature is considered stable
    #[serde(skip_serializing_if = "Option::is_none")]
    pub messages_tag: Option<String>,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(Deserialize))]
pub struct SafeState {
    #[serde(flatten)]
    pub safe_config: SafeInfoEx,
    #[serde(flatten)]
    pub safe_state: SafeLastChanges,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(Deserialize))]
pub enum ImplementationVersionState {
    UpToDate,
    Outdated,
    Unknown,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Implementation {
    pub address: String,
    pub version: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct SafeTransactionEstimationRequest {
    // Address will not be mapped to AddressEx as it is a POST body that is forwarded to the core services
    pub to: String,
    pub value: String,
    pub data: String,
    pub operation: Operation,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(Deserialize, PartialEq))]
pub struct SafeTransactionEstimation {
    pub current_nonce: u64,
    pub latest_nonce: u64,
    pub safe_tx_gas: String,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(Deserialize, PartialEq))]
pub struct SafeTransactionEstimationV2 {
    pub current_nonce: u64,
    pub recommended_nonce: u64,
    pub safe_tx_gas: String,
}

'''
'''--- src/routes/safes/routes.rs ---
use crate::cache::cache_operations::CacheResponse;
use crate::cache::manager::ChainCache;
use crate::config::owners_for_safes_cache_duration;
use crate::routes::safes::handlers::estimations;
use crate::routes::safes::handlers::safes::{get_owners_for_safe, get_safe_info_ex};
use crate::routes::safes::models::SafeTransactionEstimationRequest;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::response::content;
use rocket::serde::json::{Error, Json};
use rocket_okapi::openapi;
/// `/v1/chains/<chain_id>/safes/<safe_address>` <br />
/// Returns [SafeState](crate::routes::safes::models::SafeState)
#[openapi(tag = "Safes")]
#[get("/v1/chains/<chain_id>/safes/<safe_address>")]
pub async fn get_safe_info(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| get_safe_info_ex(&context, &chain_id, &safe_address))
        .execute()
        .await
}

/// `/v1/chains/<chain_id>/owners/<safe_address>/safes` <br/>
/// Returns [Vec] of [String]
///
/// Returns a list of Safes for which the address is an owner
#[openapi(tag = "Safes")]
#[get("/v1/chains/<chain_id>/owners/<owner_address>/safes")]
pub async fn get_owners(
    context: RequestContext,
    chain_id: String,
    owner_address: String,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| get_owners_for_safe(&context, &chain_id, &owner_address))
        .duration(owners_for_safes_cache_duration())
        .execute()
        .await
}

/// DEPRECATED
/// `/v1/chains/<chain_id>/safes/<safe_address>/multisig-transactions/estimations` <br />
/// Returns [SafeTransactionEstimation](crate::routes::safes::models::SafeTransactionEstimation)
///
/// # Safe Gas Estimation
///
/// This endpoint provides a `safeTxGas` according to the transaction passed as part of the request body
///
/// ## Path
///
/// - `/v1/chains/<chain_id>/safes/<safe_address>/multisig-transactions/estimations
///
/// ## Examples
///
/// Example request body:
///
/// ```json
/// {
///   "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
///   "value": "0",
///   "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
///   "operation": 0
/// }
/// ```
///
/// This results (at the time of writing this documentation) in:
///
/// ```json
/// {
///   "latestNonce": 76,
///   "safeTxGas": "63417"
/// }
/// ```

#[post(
    "/v1/chains/<chain_id>/safes/<safe_address>/multisig-transactions/estimations",
    format = "application/json",
    data = "<safe_transaction_estimation_request>"
)]
pub async fn post_safe_gas_estimation<'e>(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    safe_transaction_estimation_request: Result<Json<SafeTransactionEstimationRequest>, Error<'e>>,
) -> ApiResult<content::RawJson<String>> {
    Ok(content::RawJson(serde_json::to_string(
        &estimations::estimate_safe_tx_gas(
            &context,
            &chain_id,
            &safe_address,
            &safe_transaction_estimation_request?.0,
        )
        .await?,
    )?))
}

/// `/v2/chains/<chain_id>/safes/<safe_address>/multisig-transactions/estimations` <br />
/// Returns [SafeTransactionEstimationV2](crate::routes::safes::models::SafeTransactionEstimationV2)
///
/// # Safe Transaction Estimations
///
/// This endpoint provides a `safeTxGas` according to the transaction passed as part of the request body,
/// the `currentNonce` indicating what the nonce of the Safe currently is,
/// and a `recommendedNonce` that should be used for the new transaction.
///
/// ## Path
///
/// - `/v2/chains/<chain_id>/safes/<safe_address>/multisig-transactions/estimations
///
/// ## Examples
///
/// Example request body:
///
/// ```json
/// {
///   "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
///   "value": "0",
///   "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
///   "operation": 0
/// }
/// ```
///
/// This results (at the time of writing this documentation) in:
///
/// ```json
/// {
///   "currentNonce": 7,
///   "recommendedNonce": 77,
///   "safeTxGas": "63417"
/// }
/// ```
#[post(
    "/v2/chains/<chain_id>/safes/<safe_address>/multisig-transactions/estimations",
    format = "application/json",
    data = "<safe_transaction_estimation_request>"
)]
pub async fn post_safe_gas_estimation_v2<'e>(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    safe_transaction_estimation_request: Result<Json<SafeTransactionEstimationRequest>, Error<'e>>,
) -> ApiResult<content::RawJson<String>> {
    Ok(content::RawJson(serde_json::to_string(
        &estimations::estimate_safe_tx_gas_v2(
            &context,
            &chain_id,
            &safe_address,
            &safe_transaction_estimation_request?.0,
        )
        .await?,
    )?))
}

'''
'''--- src/routes/safes/tests/json/last_collectible_transfer.json ---
{
    "count": 7,
    "next": "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/transfers/?erc721=true&limit=1&offset=1",
    "previous": null,
    "results": [
        {
            "type": "ERC721_TRANSFER",
            "executionDate": "2021-04-01T07:21:56Z",
            "blockNumber": 8335209,
            "transactionHash": "0x7ed2757062518b71b0735560f56fdd117ed08e377d893c7842834b2538d637ef",
            "to": "0x95b5324C8D770F49a828968e03FAB334d6c3d9FC",
            "value": null,
            "tokenId": "3",
            "tokenAddress": "0xD753e03c05533F85bA9695C139771b1E9698a53C",
            "tokenInfo": {
                "type": "ERC721",
                "address": "0xD753e03c05533F85bA9695C139771b1E9698a53C",
                "name": "Main",
                "symbol": "TEST",
                "decimals": null,
                "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD753e03c05533F85bA9695C139771b1E9698a53C.png"
            },
            "from": "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f"
        }
    ]
}

'''
'''--- src/routes/safes/tests/json/last_history_tx.json ---
{
    "count": 1485,
    "next": "https://safe-transaction.staging.gnosisdev.com/api/v1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/all-transactions/?executed=false&limit=1&offset=1&ordering=executionDate&queued=false",
    "previous": null,
    "results": [
        {
            "safe": "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f",
            "to": "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f",
            "value": "0",
            "data": "0xf8dc5dd900000000000000000000000043386301321e6c6e9f89ebfcb373fb223b0d36dd0000000000000000000000006169b3e26fac6870208e12074d91df7ed124339e0000000000000000000000000000000000000000000000000000000000000003",
            "operation": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "safeTxGas": 60850,
            "baseGas": 0,
            "gasPrice": "0",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            "nonce": 6,
            "executionDate": "2021-11-30T15:57:49Z",
            "submissionDate": "2021-11-30T15:57:49Z",
            "modified": "2021-11-30T15:57:49Z",
            "blockNumber": 9733629,
            "transactionHash": "0x3250894bebae371b706aafadbd43be15513dc1cefc4ee215c54efabe46c2ad58",
            "safeTxHash": "0x8fb21d8f9612f33978e4b1f20740d65d38c7a6ba33109b8b7af7a5ddfd44eb6a",
            "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
            "isExecuted": true,
            "isSuccessful": true,
            "ethGasPrice": "116000000000",
            "gasUsed": 83675,
            "fee": "9706300000000000",
            "origin": null,
            "dataDecoded": {
                "method": "removeOwner",
                "parameters": [
                    {
                        "name": "prevOwner",
                        "type": "address",
                        "value": "0x43386301321E6C6E9F89EBfCB373Fb223b0D36DD"
                    },
                    {
                        "name": "owner",
                        "type": "address",
                        "value": "0x6169b3e26fac6870208e12074d91DF7eD124339e"
                    },
                    {
                        "name": "_threshold",
                        "type": "uint256",
                        "value": "3"
                    }
                ]
            },
            "confirmationsRequired": 4,
            "confirmations": [
                {
                    "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
                    "submissionDate": "2021-11-30T15:57:49Z",
                    "transactionHash": null,
                    "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
                    "signatureType": "APPROVED_HASH"
                },
                {
                    "owner": "0x6169b3e26fac6870208e12074d91DF7eD124339e",
                    "submissionDate": "2021-11-30T15:57:49Z",
                    "transactionHash": null,
                    "signature": "0x307e139747ddd256a59817c4388c6f45b6975e03d12cb911776080ba52f06a9d15ba46ec3fc1cd177f14e3ec17e2d9ba2bb12097518f5572c0e39fb48c98f4681f",
                    "signatureType": "ETH_SIGN"
                },
                {
                    "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
                    "submissionDate": "2021-11-30T15:57:49Z",
                    "transactionHash": null,
                    "signature": "0x45acfc556ada730db02ed872957f48b925795ed8e6ecc3824f7dff98c49cb687458ad4c5773095356307265da3388eb482cdddf362d254dc2e77c876976678281c",
                    "signatureType": "EOA"
                },
                {
                    "owner": "0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164",
                    "submissionDate": "2021-11-30T15:57:49Z",
                    "transactionHash": null,
                    "signature": "0x97f1627db1aa81f7c8c7065bb62112891403c7e99a0f2984573aac1ebd65236d6a24bb9a01fad196b4619ed3019c3c60fcc74978a417b6adad9c20a96f6e2e491b",
                    "signatureType": "EOA"
                }
            ],
            "signatures": "0x307e139747ddd256a59817c4388c6f45b6975e03d12cb911776080ba52f06a9d15ba46ec3fc1cd177f14e3ec17e2d9ba2bb12097518f5572c0e39fb48c98f4681f45acfc556ada730db02ed872957f48b925795ed8e6ecc3824f7dff98c49cb687458ad4c5773095356307265da3388eb482cdddf362d254dc2e77c876976678281c97f1627db1aa81f7c8c7065bb62112891403c7e99a0f2984573aac1ebd65236d6a24bb9a01fad196b4619ed3019c3c60fcc74978a417b6adad9c20a96f6e2e491b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
            "transfers": [],
            "txType": "MULTISIG_TRANSACTION",
            "trusted": false
        }
    ]
}

'''
'''--- src/routes/safes/tests/json/last_queued_tx.json ---
{
    "count": 41,
    "next": "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/?executed=false&limit=1&offset=1&ordering=-modified&trusted=true",
    "previous": null,
    "results": [
        {
            "safe": "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f",
            "to": "0xc778417E063141139Fce010982780140Aa0cD5Ab",
            "value": "20000000000000000",
            "data": null,
            "operation": 0,
            "gasToken": "0x0000000000000000000000000000000000000000",
            "safeTxGas": 23392,
            "baseGas": 0,
            "gasPrice": "0",
            "refundReceiver": "0x0000000000000000000000000000000000000000",
            "nonce": 76,
            "executionDate": null,
            "submissionDate": "2021-03-26T10:46:32.834635Z",
            "modified": "2021-03-26T10:46:32.834635Z",
            "blockNumber": null,
            "transactionHash": null,
            "safeTxHash": "0x9b2e45363dd5a0c2077e233d52915f07d8b4635bffe83edcb6c95e17c1b129f4",
            "executor": null,
            "isExecuted": false,
            "isSuccessful": null,
            "ethGasPrice": null,
            "gasUsed": null,
            "fee": null,
            "origin": "{\"url\":\"https://localhost:3000/\",\"name\":\"ETH Wrapper\"}",
            "dataDecoded": null,
            "confirmationsRequired": null,
            "confirmations": [
                {
                    "owner": "0xBe8C10Dbf4c6148f9834C56C3331f8191f355552",
                    "submissionDate": "2021-03-26T10:46:32.878135Z",
                    "transactionHash": null,
                    "signature": "0x778bff3b86a22d9fe5544fed8253c603f3749ff43a26124c1209328ceb5b691c237d98fa71cbe5ab2eb74a78dd98b5385e54da5464b06bcbaa580ee16b96320a1c",
                    "signatureType": "EOA"
                }
            ],
            "signatures": null,
            "trusted": false
        }
    ],
    "countUniqueNonce": 81
}

'''
'''--- src/routes/safes/tests/json/safe_state.json ---
{
    "address": {
        "value": "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f"
    },
    "nonce": 7,
    "threshold": 1,
    "chainId": "4",
    "owners": [
        {
            "value": "0x5aC255889882aCd3da2aA939679E3f3d4cea221e"
        }
    ],
    "implementation": {
        "value": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E"
    },
    "modules": null,
    "fallbackHandler": {
        "value": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4"
    },
    "guard": {
        "value": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D"
    },
    "version": "1.3.0",
    "implementationVersionState": "UP_TO_DATE",
    "collectiblesTag": "1617261716",
    "txQueuedTag": "1616755592",
    "txHistoryTag": "1638287869"
}

'''
'''--- src/routes/safes/tests/mod.rs ---
mod routes;

const SAFE_STATE: &str = include_str!("json/safe_state.json");
const LAST_COLLECTIBLE_TRANSFER: &str = include_str!("json/last_collectible_transfer.json");
const LAST_QUEUED_TX: &str = include_str!("json/last_queued_tx.json");
const LAST_HISTORY_TX: &str = include_str!("json/last_history_tx.json");

'''
'''--- src/routes/safes/tests/routes.rs ---
use core::time::Duration;

use mockall::predicate::eq;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;
use serde_json::json;

use crate::common::models::data_decoded::Operation;
use crate::common::models::page::SafeList;
use crate::config::{
    chain_info_request_timeout, safe_info_request_timeout, transaction_request_timeout,
};
use crate::routes::safes::models::{
    SafeState, SafeTransactionEstimation, SafeTransactionEstimationRequest,
    SafeTransactionEstimationV2,
};
use crate::tests::main::setup_rocket;
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::{MockHttpClient, Request, Response};

#[rocket::async_test]
async fn get_safe_info() {
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let master_copies_request = Request::new(String::from(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/about/master-copies/",
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(master_copies_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::POLYGON_MASTER_COPIES),
                status_code: 200,
            })
        });

    let mut request_last_collectible = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}\
        /transfers/\
        ?&erc721=true\
        &limit=1",
        safe_address
    ));

    request_last_collectible.timeout(Duration::from_millis(transaction_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_collectible))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_COLLECTIBLE_TRANSFER),
                status_code: 200,
            })
        });

    let mut request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/?\
        &ordering=-modified\
        &executed=false\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    request_last_queued_tx.timeout(Duration::from_millis(transaction_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_QUEUED_TX),
                status_code: 200,
            })
        });

    let mut request_last_history_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        all-transactions/?\
        &ordering=executionDate
        &queued=false\
        &executed=true",
        safe_address
    ));
    request_last_history_tx.timeout(Duration::from_millis(transaction_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_history_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_HISTORY_TX),
                status_code: 200,
            })
        });

    mock_http_client.expect_get().returning(move |_| {
        Err(ApiError::from_http_response(&Response {
            body: String::new(),
            status_code: 404,
        }))
    });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_safe_info],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");
    let expected = serde_json::from_str::<SafeState>(super::SAFE_STATE).unwrap();

    let request = client
        .get("/v1/chains/4/safes/0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json_body = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<SafeState>(&actual_json_body).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn get_safe_info_not_found() {
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";
    let error = ErrorDetails {
        code: 1337,
        message: Some(String::new()),
        arguments: None,
        debug: None,
    };

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: String::new(),
            }))
        });
    let expected = serde_json::to_string(&error).unwrap();

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_safe_info],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .get("/v1/chains/4/safes/0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json_body = response.into_string().await.unwrap();

    assert_eq!(actual_status, Status::NotFound);
    assert_eq!(actual_json_body, expected);
}

#[rocket::async_test]
async fn get_owners() {
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";
    let safe_list = json!({
    "safes": [
      "0x71779e2b8882aDe7F98499fF43b7f920Bbd2f11A",
      "0xd6c67939b1baDE7A98B90C35d6EFdb70ddC1eB85",
      "0x38CE506e08E00193FcD160098E7af15210377887",
      "0x22592D55509db089da6667180253e18a32276763",
      "0xF735023d5c134A07e613749047B0AFC569eCfDE6",
      "0xCAd65D5981Abc26be93cf0C8803b6DaCe3F6c220",
      "0x9b2194B7AE34f5d412a4a42eC13f74ff4454b32e",
      "0xAE62Ff4cBa6ffBFF83bb94b39D6bD95F36908ba0",
      "0x69E479a77a0DDAA2e3364d73Ab55cdBF18A60B9a",
      "0xF8F8ca7EAc92fe7606e91E8D7832A8B18625fD9F"
    ]})
    .to_string();
    let expected = serde_json::from_str::<SafeList>(&safe_list).unwrap();

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/owners/{}/safes/",
        &safe_address
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: safe_list,
            })
        });

    let client = Client::tracked(
        setup_rocket(mock_http_client, routes![super::super::routes::get_owners]).await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .get("/v1/chains/4/owners/0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f/safes")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual = serde_json::from_str::<SafeList>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn get_owners_not_found() {
    let safe_address = "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f";
    let error = ErrorDetails {
        code: 1337,
        message: Some(String::new()),
        arguments: None,
        debug: None,
    };

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/owners/{}/safes/",
        &safe_address
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 404,
                body: String::new(),
            }))
        });
    let expected = serde_json::to_string(&error).unwrap();

    let client = Client::tracked(
        setup_rocket(mock_http_client, routes![super::super::routes::get_owners]).await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .get("/v1/chains/4/owners/0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f/safes")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json_body = response.into_string().await.unwrap();

    assert_eq!(actual_status, Status::NotFound);
    assert_eq!(actual_json_body, expected);
}

#[rocket::async_test]
async fn post_safe_gas_estimation() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_QUEUED_TX),
                status_code: 200,
            })
        });

    let mut estimation_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        estimations/",
        &safe_address
    ));
    estimation_request.body(Some(serde_json::to_string(
        &SafeTransactionEstimationRequest{
            to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: String::from("0"),
            data: String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"),
            operation: Operation::CALL
            }).unwrap())
        );
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(estimation_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: json!({
                    "safeTxGas" : "63417"
                })
                .to_string(),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let expected = serde_json::from_value(json!( {
        "currentNonce": 7,
        "latestNonce": 76,
        "safeTxGas": "63417"
    }))
    .unwrap();

    let request = client
        .post("/v1/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<SafeTransactionEstimation>(&actual_json).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_no_queued_tx() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::EMPTY_PAGE),
                status_code: 200,
            })
        });

    let mut estimation_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        estimations/",
        &safe_address
    ));
    estimation_request.body(Some(serde_json::to_string(
        &SafeTransactionEstimationRequest{
            to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: String::from("0"),
            data: String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"),
            operation: Operation::CALL
            }).unwrap())
        );

    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(estimation_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: json!({
                    "safeTxGas" : "63417"
                })
                .to_string(),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let expected = serde_json::from_value(json!( {
        "currentNonce": 7,
        "latestNonce": 0,
        "safeTxGas": "63417"
    }))
    .unwrap();

    let request = client
        .post("/v1/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<SafeTransactionEstimation>(&actual_json).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_delayed_indexing() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_known_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_known_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_HISTORY_TX),
                status_code: 200,
            })
        });

    let mut estimation_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        estimations/",
        &safe_address
    ));
    estimation_request.body(Some(serde_json::to_string(
        &SafeTransactionEstimationRequest{
            to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: String::from("0"),
            data: String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"),
            operation: Operation::CALL
            }).unwrap())
        );

    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(estimation_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: json!({
                    "safeTxGas" : "63417"
                })
                .to_string(),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let expected = serde_json::from_value(json!( {
        "currentNonce": 7,
        "latestNonce": 6,
        "safeTxGas": "63417"
    }))
    .unwrap();

    let request = client
        .post("/v1/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<SafeTransactionEstimation>(&actual_json).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_estimation_error() {
    let safe_address = "0xD6f5Bef6bb4acD235CF85c0ce196316d10785d67"; // not checksummed
    let error_message = "{\"code\":1,\"message\":\"Checksum address validation failed\",/
    \"arguments\":[\"0xd6f5Bef6bb4acd235CF85c0ce196316d10785d67\"]}";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_QUEUED_TX),
                status_code: 200,
            })
        });

    let mut estimation_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        estimations/",
        &safe_address
    ));
    estimation_request.body(Some(serde_json::to_string(
        &SafeTransactionEstimationRequest{
            to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: String::from("0"),
            data: String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"),
            operation: Operation::CALL
            }).unwrap())
        );

    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(estimation_request))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 422,
                body: String::from(error_message),
            }))
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let expected = ApiError::new_from_message_with_code(422, String::from(error_message));

    let request = client
        .post("/v1/chains/4/safes/0xD6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_error_details =
        serde_json::from_str::<ErrorDetails>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual_status, Status::UnprocessableEntity);
    assert_eq!(actual_error_details, expected.details);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_nonce_error() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                body: String::new(),
                status_code: 404,
            }))
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v1/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::NotFound);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_safe_error() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                body: String::new(),
                status_code: 404,
            }))
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v1/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::NotFound);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_v2() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_QUEUED_TX),
                status_code: 200,
            })
        });

    let mut estimation_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        estimations/",
        &safe_address
    ));
    estimation_request.body(Some(serde_json::to_string(
        &SafeTransactionEstimationRequest{
            to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: String::from("0"),
            data: String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"),
            operation: Operation::CALL
            }).unwrap())
        );
    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(estimation_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: json!({
                    "safeTxGas" : "63417"
                })
                .to_string(),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation_v2],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let expected = serde_json::from_value(json!( {
        "currentNonce": 7,
        "recommendedNonce": 77,
        "safeTxGas": "63417"
    }))
    .unwrap();

    let request = client
        .post("/v2/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<SafeTransactionEstimationV2>(&actual_json).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_v2_no_queued_tx() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::EMPTY_PAGE),
                status_code: 200,
            })
        });

    let mut estimation_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        estimations/",
        &safe_address
    ));
    estimation_request.body(Some(serde_json::to_string(
        &SafeTransactionEstimationRequest{
            to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: String::from("0"),
            data: String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"),
            operation: Operation::CALL
            }).unwrap())
        );

    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(estimation_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: json!({
                    "safeTxGas" : "63417"
                })
                .to_string(),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation_v2],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let expected = serde_json::from_value(json!( {
        "currentNonce": 7,
        "recommendedNonce": 7,
        "safeTxGas": "63417"
    }))
    .unwrap();

    let request = client
        .post("/v2/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<SafeTransactionEstimationV2>(&actual_json).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_v2_delayed_indexing() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_known_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_known_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_HISTORY_TX),
                status_code: 200,
            })
        });

    let mut estimation_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        estimations/",
        &safe_address
    ));
    estimation_request.body(Some(serde_json::to_string(
        &SafeTransactionEstimationRequest{
            to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: String::from("0"),
            data: String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"),
            operation: Operation::CALL
            }).unwrap())
        );

    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(estimation_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: json!({
                    "safeTxGas" : "63417"
                })
                .to_string(),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation_v2],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let expected = serde_json::from_value(json!( {
        "currentNonce": 7,
        "recommendedNonce": 7,
        "safeTxGas": "63417"
    }))
    .unwrap();

    let request = client
        .post("/v2/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_json = response.into_string().await.unwrap();
    let actual = serde_json::from_str::<SafeTransactionEstimationV2>(&actual_json).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_v2_estimation_error() {
    let safe_address = "0xD6f5Bef6bb4acD235CF85c0ce196316d10785d67"; // not checksummed
    let error_message = "{\"code\":1,\"message\":\"Checksum address validation failed\",/
    \"arguments\":[\"0xd6f5Bef6bb4acd235CF85c0ce196316d10785d67\"]}";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Ok(Response {
                body: String::from(super::LAST_QUEUED_TX),
                status_code: 200,
            })
        });

    let mut estimation_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        estimations/",
        &safe_address
    ));
    estimation_request.body(Some(serde_json::to_string(
        &SafeTransactionEstimationRequest{
            to: String::from("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: String::from("0"),
            data: String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000"),
            operation: Operation::CALL
            }).unwrap())
        );

    mock_http_client
        .expect_post()
        .times(1)
        .with(eq(estimation_request))
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                status_code: 422,
                body: String::from(error_message),
            }))
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation_v2],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let expected = ApiError::new_from_message_with_code(422, String::from(error_message));

    let request = client
        .post("/v2/chains/4/safes/0xD6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let actual_error_details =
        serde_json::from_str::<ErrorDetails>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual_status, Status::UnprocessableEntity);
    assert_eq!(actual_error_details, expected.details);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_v2_nonce_error() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let request_last_queued_tx = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/\
        multisig-transactions/\
        ?ordering=-nonce\
        &trusted=true\
        &limit=1",
        safe_address,
    ));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(request_last_queued_tx))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                body: String::new(),
                status_code: 404,
            }))
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Ok(Response {
                body: String::from(crate::tests::json::SAFE_WITH_GUARD_SAFE_V130_L2),
                status_code: 200,
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation_v2],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v2/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::NotFound);
}

#[rocket::async_test]
async fn post_safe_gas_estimation_v2_safe_error() {
    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut safe_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/",
        &safe_address
    ));
    safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(safe_request))
        .returning(move |_| {
            Err(ApiError::from_http_response(&Response {
                body: String::new(),
                status_code: 404,
            }))
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_safe_gas_estimation_v2],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .post("/v2/chains/4/safes/0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67/multisig-transactions/estimations")
        .body(&json!({
            "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "value": "0",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "operation": 0
            }).to_string())
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    assert_eq!(response.status(), Status::NotFound);
}

'''
'''--- src/routes/transactions/converters/details.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::{ModuleTransaction, MultisigTransaction};
use crate::common::models::data_decoded::{DataDecoded, Operation};
use crate::providers::ext::InfoProviderExt;
use crate::providers::info::{InfoProvider, SafeInfo, TokenInfo};
use crate::routes::transactions::converters::safe_app_info::safe_app_info_from;
use crate::routes::transactions::models::details::{
    DetailedExecutionInfo, ModuleExecutionDetails, MultisigConfirmation, MultisigExecutionDetails,
    TransactionData, TransactionDetails,
};
use crate::utils::errors::ApiResult;
use rocket::futures::future::OptionFuture;

impl MultisigTransaction {
    pub async fn to_transaction_details(
        &self,
        rejections: Option<Vec<String>>,
        info_provider: &(impl InfoProvider + Sync),
    ) -> ApiResult<TransactionDetails> {
        let safe_info = info_provider
            .safe_info(&self.safe_transaction.safe.to_string())
            .await?;
        let gas_token = info_provider.address_to_token_info(&self.gas_token).await;
        let is_trusted_delegate_call = is_trusted_delegate_call(
            &self.safe_transaction.operation,
            &self.safe_transaction.to,
            &self.safe_transaction.data_decoded,
            info_provider,
        )
        .await?;

        Ok(TransactionDetails {
            safe_address: self.safe_transaction.safe.to_owned(),
            tx_id: self.generate_id(),
            executed_at: self.execution_date.map(|data| data.timestamp_millis()),
            tx_status: self.map_status(&safe_info),
            tx_info: self.transaction_info(info_provider).await,
            tx_data: Some(TransactionData {
                to: AddressEx::any_source(&self.safe_transaction.to, info_provider).await,
                value: self.safe_transaction.value.to_owned(),
                hex_data: self.safe_transaction.data.to_owned(),
                data_decoded: self.safe_transaction.data_decoded.clone(),
                operation: self.safe_transaction.operation,
                address_info_index: OptionFuture::from(
                    self.safe_transaction
                        .data_decoded
                        .as_ref()
                        .map(|data_decoded| async move {
                            data_decoded.build_address_info_index(info_provider).await
                        }),
                )
                .await
                .flatten(),
                trusted_delegate_call_target: is_trusted_delegate_call,
            }),
            tx_hash: self.transaction_hash.as_ref().map(|hash| hash.to_owned()),
            detailed_execution_info: Some(DetailedExecutionInfo::Multisig(
                self.build_execution_details(safe_info, gas_token, rejections),
            )),
            safe_app_info: OptionFuture::from(
                self.origin
                    .as_ref()
                    .map(|origin| async move { safe_app_info_from(origin, info_provider).await }),
            )
            .await
            .flatten(),
        })
    }

    fn build_execution_details(
        &self,
        safe_info: SafeInfo,
        gas_token_info: Option<TokenInfo>,
        rejections: Option<Vec<String>>,
    ) -> MultisigExecutionDetails {
        MultisigExecutionDetails {
            submitted_at: self.submission_date.timestamp_millis(),
            nonce: self.nonce,
            safe_tx_hash: self.safe_tx_hash.to_owned(),
            executor: self
                .executor
                .as_ref()
                .map(|address| AddressEx::address_only(&address)),
            signers: safe_info
                .owners
                .iter()
                .map(|rejection| AddressEx::address_only(rejection))
                .collect(),
            confirmations_required: self.confirmations_required.unwrap_or(safe_info.threshold),
            confirmations: self
                .confirmations
                .as_ref()
                .unwrap_or(&vec![])
                .into_iter()
                .map(|confirmation| MultisigConfirmation {
                    signer: AddressEx::address_only(&confirmation.owner),
                    signature: confirmation.signature.to_owned(),
                    submitted_at: confirmation.submission_date.timestamp_millis(),
                })
                .collect(),
            refund_receiver: self
                .refund_receiver
                .as_ref()
                .map(|address| AddressEx::address_only(address))
                .unwrap_or(AddressEx::zero()),
            gas_token: self
                .gas_token
                .as_ref()
                .unwrap_or(&String::from("0x0000000000000000000000000000000000000000"))
                .to_owned(),
            base_gas: self.base_gas.unwrap_or(0).to_string(),
            safe_tx_gas: self.safe_tx_gas.unwrap_or(0).to_string(),
            gas_price: self
                .gas_price
                .as_ref()
                .unwrap_or(&String::from("0"))
                .to_owned(),
            gas_token_info,
            rejectors: rejections.map(|r| {
                r.iter()
                    .map(|rejection| AddressEx::address_only(rejection))
                    .collect()
            }),
            trusted: self.trusted,
        }
    }
}

impl ModuleTransaction {
    pub async fn to_transaction_details(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> ApiResult<TransactionDetails> {
        let safe_transaction = &self.safe_transaction;
        let module_info = info_provider
            .address_ex_from_contracts_or_default(&self.module)
            .await;
        let is_trusted_delegate_call = is_trusted_delegate_call(
            &self.safe_transaction.operation,
            &self.safe_transaction.to,
            &safe_transaction.data_decoded,
            info_provider,
        )
        .await?;

        Ok(TransactionDetails {
            safe_address: self.safe_transaction.safe.to_owned(),
            tx_id: self.generate_id(),
            executed_at: Some(self.execution_date.timestamp_millis()),
            tx_status: self.map_status(),
            tx_info: self.transaction_info(info_provider).await,
            tx_data: Some(TransactionData {
                to: AddressEx::any_source(&self.safe_transaction.to, info_provider).await,
                value: safe_transaction.value.to_owned(),
                hex_data: safe_transaction.data.to_owned(),
                data_decoded: safe_transaction.data_decoded.clone(),
                operation: safe_transaction.operation,
                address_info_index: OptionFuture::from(safe_transaction.data_decoded.as_ref().map(
                    |data_decoded| async move {
                        data_decoded.build_address_info_index(info_provider).await
                    },
                ))
                .await
                .flatten(),
                trusted_delegate_call_target: is_trusted_delegate_call,
            }),
            tx_hash: Some(self.transaction_hash.to_owned()),
            detailed_execution_info: Some(DetailedExecutionInfo::Module(ModuleExecutionDetails {
                address: module_info,
            })),
            safe_app_info: None,
        })
    }
}

pub async fn is_trusted_delegate_call(
    operation: &Operation,
    to: &str,
    data_decoded: &Option<DataDecoded>,
    info_provider: &(impl InfoProvider + Sync),
) -> ApiResult<Option<bool>> {
    if operation == &Operation::DELEGATE {
        let contract_info = info_provider.contract_info(to).await;
        let contract_info = match contract_info {
            Ok(contract_info) => contract_info,
            Err(api_error) => {
                return match api_error.status {
                    404 => Ok(None),
                    _ => Err(api_error),
                };
            }
        };

        let has_nested_delegate_calls = !data_decoded
            .as_ref()
            .map_or(false, |data_decoded| data_decoded.has_nested_delegated());

        let is_trusted_delegate_call =
            contract_info.trusted_for_delegate_call && has_nested_delegate_calls;
        return Ok(Some(is_trusted_delegate_call));
    } else {
        Ok(None)
    }
}

'''
'''--- src/routes/transactions/converters/mod.rs ---
pub mod details;
pub mod safe_app_info;
pub mod summary;
pub mod transaction_id;

#[cfg(test)]
mod tests;

use crate::common::converters::{get_address_ex_from_any_source, get_transfer_direction};
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::{
    ModuleTransaction, MultisigTransaction, SafeTransaction,
};
use crate::common::models::data_decoded::{DataDecoded, Operation};
use crate::providers::info::{InfoProvider, SafeInfo, TokenInfo, TokenType};
use crate::routes::transactions::models::{
    Custom, Erc20Transfer, Erc721Transfer, NativeCoinTransfer, SettingsChange, TransactionInfo,
    TransactionStatus, Transfer, TransferDirection, TransferInfo,
};
use crate::utils::{SAFE_TRANSFER_FROM_METHOD, TRANSFER_FROM_METHOD, TRANSFER_METHOD};
use rocket::futures::future::OptionFuture;

impl SafeTransaction {
    pub(crate) async fn transaction_info(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        is_cancellation: bool,
    ) -> TransactionInfo {
        let value = self.value_as_uint();
        let data_size = data_size(&self.data);

        if (value > 0 && data_size > 0) || self.operation != Operation::CALL {
            TransactionInfo::Custom(self.to_custom(info_provider, is_cancellation).await)
        } else if value > 0 && data_size == 0 {
            TransactionInfo::Transfer(self.to_ether_transfer(info_provider).await)
        } else if value == 0
            && data_size > 0
            && self.safe == self.to
            && self
                .data_decoded
                .as_ref()
                .map_or_else(|| false, |it| it.is_settings_change())
        {
            TransactionInfo::SettingsChange(self.to_settings_change(info_provider).await)
        } else if self
            .data_decoded
            .as_ref()
            .map(|data_decoded| {
                data_decoded.is_erc20_transfer_method() || data_decoded.is_erc721_transfer_method()
            })
            .unwrap_or(false)
            && check_sender_or_receiver(&self.data_decoded, &self.safe)
        {
            match info_provider.token_info(&self.to).await {
                Ok(token) => match token.token_type {
                    TokenType::Erc20 => TransactionInfo::Transfer(
                        self.to_erc20_transfer(&token, info_provider).await,
                    ),
                    TokenType::Erc721 => TransactionInfo::Transfer(
                        self.to_erc721_transfer(&token, info_provider).await,
                    ),
                    _ => TransactionInfo::Custom(
                        self.to_custom(info_provider, is_cancellation).await,
                    ),
                },
                _ => TransactionInfo::Custom(self.to_custom(info_provider, is_cancellation).await),
            }
        } else {
            TransactionInfo::Custom(self.to_custom(info_provider, is_cancellation).await)
        }
    }

    async fn to_custom(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        is_cancellation: bool,
    ) -> Custom {
        Custom {
            to: crate::common::converters::get_address_ex_from_any_source(
                &self.safe,
                &self.to,
                info_provider,
            )
            .await,
            is_cancellation,
            data_size: data_size(&self.data).to_string(),
            value: self.value.as_ref().unwrap_or(&String::from("0")).clone(),
            method_name: self.data_decoded.as_ref().map(|it| it.method.to_owned()),
            action_count: self
                .data_decoded
                .as_ref()
                .and_then(|it| it.get_action_count()),
        }
    }

    async fn to_erc20_transfer(
        &self,
        token: &TokenInfo,
        info_provider: &impl InfoProvider,
    ) -> Transfer {
        let sender = get_from_param(&self.data_decoded, &self.safe);
        let recipient = get_to_param(
            &self.data_decoded,
            "0x0000000000000000000000000000000000000000",
        );
        let direction = get_transfer_direction(&self.safe, &sender, &recipient);
        Transfer {
            sender: get_address_ex_from_any_source(&self.safe, &sender, info_provider).await,
            recipient: get_address_ex_from_any_source(&self.safe, &recipient, info_provider).await,
            direction,
            transfer_info: TransferInfo::Erc20(Erc20Transfer {
                token_address: token.address.to_owned(),
                logo_uri: token.logo_uri.to_owned(),
                token_name: Some(token.name.to_owned()),
                token_symbol: Some(token.symbol.to_owned()),
                decimals: Some(token.decimals),
                value: get_value_param(&self.data_decoded, "0"),
            }),
        }
    }

    async fn to_erc721_transfer(
        &self,
        token: &TokenInfo,
        info_provider: &impl InfoProvider,
    ) -> Transfer {
        let sender = get_from_param(&self.data_decoded, &self.safe);
        let recipient = get_to_param(
            &self.data_decoded,
            "0x0000000000000000000000000000000000000000",
        );
        let direction = get_transfer_direction(&self.safe, &sender, &recipient);
        Transfer {
            sender: get_address_ex_from_any_source(&self.safe, &sender, info_provider).await,
            recipient: get_address_ex_from_any_source(&self.safe, &recipient, info_provider).await,
            direction,
            transfer_info: TransferInfo::Erc721(Erc721Transfer {
                token_address: token.address.to_owned(),
                logo_uri: token.logo_uri.to_owned(),
                token_name: Some(token.name.to_owned()),
                token_symbol: Some(token.symbol.to_owned()),
                token_id: get_value_param(&self.data_decoded, "0"),
            }),
        }
    }

    async fn to_ether_transfer(&self, info_provider: &impl InfoProvider) -> Transfer {
        Transfer {
            sender: AddressEx::address_only(&self.safe),
            recipient: get_address_ex_from_any_source(&self.safe, &self.to, info_provider).await,
            direction: TransferDirection::Outgoing,
            transfer_info: TransferInfo::NativeCoin(NativeCoinTransfer {
                value: self.value.as_ref().unwrap().to_string(),
            }),
        }
    }

    async fn to_settings_change(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> SettingsChange {
        SettingsChange {
            data_decoded: self.data_decoded.as_ref().unwrap().to_owned(),
            settings_info: OptionFuture::from(
                self.data_decoded
                    .as_ref()
                    .map(|it| async move { it.to_settings_info(info_provider).await }),
            )
            .await
            .flatten(),
        }
    }

    fn value_as_uint(&self) -> u128 {
        self.value
            .as_ref()
            .map(|it| it.parse::<u128>().ok())
            .flatten()
            .unwrap_or(0)
    }
}

impl MultisigTransaction {
    async fn transaction_info(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> TransactionInfo {
        self.safe_transaction
            .transaction_info(info_provider, self.is_cancellation())
            .await
    }

    fn confirmation_count(&self) -> u64 {
        match &self.confirmations {
            Some(confirmations) => confirmations.len() as u64,
            None => 0,
        }
    }

    fn confirmation_required(&self, threshold: u64) -> u64 {
        self.confirmations_required.unwrap_or(threshold)
    }

    fn missing_signers(&self, owners: &Vec<String>) -> Vec<AddressEx> {
        self.confirmations.as_ref().map_or_else(
            || {
                owners
                    .iter()
                    .map(|owner| AddressEx::address_only(&owner))
                    .collect()
            },
            |confirmations| {
                owners
                    .iter()
                    .filter_map(|owner| {
                        if !confirmations.iter().any(|c| &c.owner == owner) {
                            Some(AddressEx::address_only(&owner))
                        } else {
                            None
                        }
                    })
                    .collect()
            },
        )
    }

    fn map_status(&self, safe_info: &SafeInfo) -> TransactionStatus {
        if self.is_executed {
            if self.is_successful.unwrap_or(false) {
                TransactionStatus::Success
            } else {
                TransactionStatus::Failed
            }
        } else if safe_info.nonce > self.nonce {
            TransactionStatus::Cancelled
        } else if self.confirmation_count() < self.confirmation_required(safe_info.threshold) {
            TransactionStatus::AwaitingConfirmations
        } else {
            TransactionStatus::AwaitingExecution
        }
    }

    fn is_cancellation(&self) -> bool {
        self.safe_transaction.to == self.safe_transaction.safe
            && data_size(&self.safe_transaction.data) == 0
            && self
                .safe_transaction
                .value
                .as_ref()
                .map_or(true, |value| value == "0")
            && self.safe_transaction.operation == Operation::CALL
            && self
                .base_gas
                .as_ref()
                .map_or(true, |base_gas| base_gas.eq(&0))
            && self
                .gas_price
                .as_ref()
                .map_or(true, |gas_price| gas_price == "0")
            && self.gas_token.as_ref().map_or(true, |gas_token| {
                gas_token == "0x0000000000000000000000000000000000000000"
            })
            && self
                .refund_receiver
                .as_ref()
                .map_or(true, |refund_receiver| {
                    refund_receiver == "0x0000000000000000000000000000000000000000"
                })
            && self
                .safe_tx_gas
                .as_ref()
                .map_or(true, |safe_tx_gas| safe_tx_gas.eq(&0))
    }
}

impl ModuleTransaction {
    async fn transaction_info(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> TransactionInfo {
        self.safe_transaction
            .transaction_info(info_provider, false)
            .await
    }

    fn map_status(&self) -> TransactionStatus {
        if self.is_successful {
            TransactionStatus::Success
        } else {
            TransactionStatus::Failed
        }
    }
}

fn data_size(data: &Option<String>) -> usize {
    match data {
        Some(actual_data) => {
            let length = actual_data.len();
            match length {
                0 => 0,
                _ => (length - 2) / 2,
            }
        }
        None => 0,
    }
}

fn get_from_param(data_decoded: &Option<DataDecoded>, fallback: &str) -> String {
    data_decoded
        .as_ref()
        .and_then(|data_decoded| match data_decoded.method.as_str() {
            TRANSFER_METHOD => None,
            TRANSFER_FROM_METHOD => data_decoded.get_parameter_single_value_at(0),
            SAFE_TRANSFER_FROM_METHOD => data_decoded.get_parameter_single_value_at(0),
            _ => None,
        })
        .unwrap_or(String::from(fallback))
}

fn get_to_param(data_decoded: &Option<DataDecoded>, fallback: &str) -> String {
    data_decoded
        .as_ref()
        .and_then(|data_decoded| match data_decoded.method.as_str() {
            TRANSFER_METHOD => data_decoded.get_parameter_single_value_at(0),
            TRANSFER_FROM_METHOD => data_decoded.get_parameter_single_value_at(1),
            SAFE_TRANSFER_FROM_METHOD => data_decoded.get_parameter_single_value_at(1),
            _ => None,
        })
        .unwrap_or(String::from(fallback))
}

fn get_value_param(data_decoded: &Option<DataDecoded>, fallback: &str) -> String {
    data_decoded
        .as_ref()
        .and_then(|data_decoded| match data_decoded.method.as_str() {
            TRANSFER_METHOD => data_decoded.get_parameter_single_value_at(1),
            TRANSFER_FROM_METHOD => data_decoded.get_parameter_single_value_at(2),
            SAFE_TRANSFER_FROM_METHOD => data_decoded.get_parameter_single_value_at(2),
            _ => None,
        })
        .unwrap_or(String::from(fallback))
}

fn check_sender_or_receiver(data_decoded: &Option<DataDecoded>, expected: &str) -> bool {
    if data_decoded.is_none() {
        return false;
    };
    let data = data_decoded.as_ref().unwrap();
    data.method == TRANSFER_METHOD
        || &get_from_param(data_decoded, "") == expected
        || &get_to_param(data_decoded, "") == expected
}

'''
'''--- src/routes/transactions/converters/safe_app_info.rs ---
use crate::providers::info::{InfoProvider, SafeAppInfo};
use serde::Deserialize;

pub async fn safe_app_info_from(
    origin: &str,
    info_provider: &(impl InfoProvider + Sync),
) -> Option<SafeAppInfo> {
    let origin_internal = serde_json::from_str::<OriginInternal>(origin).ok()?;
    info_provider
        .safe_app_info(
            &origin_internal
                .url
                .replace("ipfs.io", "cloudflare-ipfs.com"),
        )
        .await
        .ok()
}

#[derive(Deserialize, Debug, PartialEq)]
pub(super) struct OriginInternal {
    pub(super) url: String,
}

'''
'''--- src/routes/transactions/converters/summary.rs ---
use crate::common::models::backend::transactions::{
    CreationTransaction, EthereumTransaction, ModuleTransaction, MultisigTransaction, Transaction,
};
use crate::common::models::backend::transfers::Transfer;
use crate::providers::ext::InfoProviderExt;
use crate::providers::info::InfoProvider;
use crate::routes::transactions::converters::safe_app_info::safe_app_info_from;
use crate::routes::transactions::models::summary::{
    ExecutionInfo, ModuleExecutionInfo, MultisigExecutionInfo, TransactionSummary,
};
use crate::routes::transactions::models::{Creation, TransactionInfo, TransactionStatus};
use crate::utils::errors::ApiResult;
use crate::utils::hex_hash;
use rocket::futures::future::OptionFuture;

impl Transaction {
    pub async fn to_transaction_summary(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        safe: &str,
    ) -> ApiResult<Vec<TransactionSummary>> {
        match self {
            Transaction::Multisig(transaction) => {
                Ok(transaction.to_transaction_summary(info_provider).await?)
            }
            Transaction::Ethereum(transaction) => Ok(transaction
                .to_transaction_summary(info_provider, safe)
                .await),
            Transaction::Module(transaction) => {
                Ok(transaction.to_transaction_summary(info_provider).await)
            }
            Transaction::Unknown => bail!("Unknown transaction type from backend"),
        }
    }
}

impl MultisigTransaction {
    pub async fn to_transaction_summary(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> ApiResult<Vec<TransactionSummary>> {
        let safe_info = info_provider
            .safe_info(&self.safe_transaction.safe.to_string())
            .await?;
        let tx_status = self.map_status(&safe_info);
        let missing_signers = if tx_status == TransactionStatus::AwaitingConfirmations {
            Some(self.missing_signers(&safe_info.owners))
        } else {
            None
        };
        Ok(vec![TransactionSummary {
            id: self.generate_id(),
            timestamp: self
                .execution_date
                .unwrap_or(self.submission_date)
                .timestamp_millis(),
            tx_status,
            execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
                nonce: self.nonce,
                confirmations_submitted: self.confirmation_count(),
                confirmations_required: self.confirmation_required(safe_info.threshold),
                missing_signers,
            })),
            tx_info: self.transaction_info(info_provider).await,
            safe_app_info: OptionFuture::from(
                self.origin
                    .as_ref()
                    .map(|origin| async move { safe_app_info_from(&origin, info_provider).await }),
            )
            .await
            .flatten(),
        }])
    }
}

impl EthereumTransaction {
    pub(super) async fn to_transaction_summary(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        safe_address: &str,
    ) -> Vec<TransactionSummary> {
        match &self.transfers {
            Some(transfers) => {
                let mut results = Vec::with_capacity(transfers.len());

                for transfer in transfers {
                    let transaction_summary = TransactionSummary {
                        id: self.generate_id(safe_address, &hex_hash(transfer)),
                        timestamp: self.execution_date.timestamp_millis(),
                        tx_status: TransactionStatus::Success,
                        execution_info: None,
                        safe_app_info: None,
                        tx_info: transfer.to_transfer(info_provider, safe_address).await,
                    };

                    results.push(transaction_summary);
                }
                results
            }
            _ => vec![],
        }
    }
}

impl Transfer {
    pub async fn to_transaction_summary(
        &self,
        info_provider: &(impl InfoProvider + Sync),
        execution_date: i64,
        safe_address: &str,
    ) -> TransactionSummary {
        let tx_hash = match self {
            Transfer::Erc721(t) => &t.transaction_hash,
            Transfer::Erc20(t) => &t.transaction_hash,
            Transfer::Ether(t) => &t.transaction_hash,
            Transfer::Unknown => panic!("Cannot map transfer"),
        };
        TransactionSummary {
            id: self.generate_id(safe_address, tx_hash),
            timestamp: execution_date,
            tx_status: TransactionStatus::Success,
            execution_info: None,
            safe_app_info: None,
            tx_info: self.to_transfer(info_provider, safe_address).await,
        }
    }
}

impl ModuleTransaction {
    pub async fn to_transaction_summary(
        &self,
        info_provider: &(impl InfoProvider + Sync),
    ) -> Vec<TransactionSummary> {
        let module_info = info_provider
            .address_ex_from_contracts_or_default(&self.module)
            .await;
        vec![TransactionSummary {
            id: self.generate_id(),
            timestamp: self.execution_date.timestamp_millis(),
            tx_status: self.map_status(),
            execution_info: Some(ExecutionInfo::Module(ModuleExecutionInfo {
                address: module_info,
            })),
            safe_app_info: None,
            tx_info: self.transaction_info(info_provider).await,
        }]
    }
}

impl CreationTransaction {
    pub async fn to_transaction_summary(
        &self,
        safe_address: &str,
        info_provider: &(impl InfoProvider + Sync),
    ) -> TransactionSummary {
        TransactionSummary {
            id: self.generate_id(safe_address),
            timestamp: self.created.timestamp_millis(),
            tx_status: TransactionStatus::Success,
            tx_info: TransactionInfo::Creation(Creation {
                creator: info_provider
                    .address_ex_from_contracts_or_default(&self.creator)
                    .await,
                transaction_hash: self.transaction_hash.clone(),
                implementation: info_provider
                    .optional_address_ex_from_contracts(&self.master_copy)
                    .await,
                factory: info_provider
                    .optional_address_ex_from_contracts(&self.factory_address)
                    .await,
            }),
            execution_info: None,
            safe_app_info: None,
        }
    }
}

'''
'''--- src/routes/transactions/converters/tests/check_sender_or_receiver.rs ---
use crate::common::models::data_decoded::ParamValue::SingleValue;
use crate::common::models::data_decoded::{DataDecoded, Parameter};
use crate::routes::transactions::converters::check_sender_or_receiver;

#[test]
fn check_sender_or_receiver_safe_sender() {
    let data_decoded = Some(DataDecoded {
        method: "transfer".to_string(),
        parameters: Some(vec![Parameter {
            name: "from".to_string(),
            param_type: "address".to_string(),
            value: SingleValue("0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string()),
            value_decoded: None,
        }]),
    });

    let actual =
        check_sender_or_receiver(&data_decoded, "0x1230B3d59858296A31053C1b8562Ecf89A2f888b");
    assert!(actual);
}

#[test]
fn check_sender_or_receiver_safe_receiver() {
    let data_decoded = Some(DataDecoded {
        method: "transfer".to_string(),
        parameters: Some(vec![Parameter {
            name: "to".to_string(),
            param_type: "address".to_string(),
            value: SingleValue("0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string()),
            value_decoded: None,
        }]),
    });

    let actual =
        check_sender_or_receiver(&data_decoded, "0x1230B3d59858296A31053C1b8562Ecf89A2f888b");
    assert!(actual);
}

#[test]
fn check_sender_or_receiver_safe_invalid_sender() {
    let data_decoded = Some(DataDecoded {
        method: "transfer".to_string(),
        parameters: Some(vec![Parameter {
            name: "from".to_string(),
            param_type: "address".to_string(),
            value: SingleValue("0x2230B3d59858296A31053C1b8562Ecf89A2f888b".to_string()),
            value_decoded: None,
        }]),
    });

    let actual =
        check_sender_or_receiver(&data_decoded, "0x1230B3d59858296A31053C1b8562Ecf89A2f888b");
    assert!(actual);
}

#[test]
fn check_sender_or_receiver_safe_invalid_receiver() {
    let data_decoded = Some(DataDecoded {
        method: "transfer".to_string(),
        parameters: Some(vec![Parameter {
            name: "to".to_string(),
            param_type: "address".to_string(),
            value: SingleValue("021230B3d59858296A31053C1b8562Ecf89A2f888b".to_string()),
            value_decoded: None,
        }]),
    });

    let actual =
        check_sender_or_receiver(&data_decoded, "0x1230B3d59858296A31053C1b8562Ecf89A2f888b");
    assert!(actual);
}

#[test]
fn check_sender_or_receiver_data_decoded_none() {
    let data_decoded: Option<DataDecoded> = Option::None;

    let actual = check_sender_or_receiver(&data_decoded, "");

    assert!(!actual);
}

#[test]
fn check_sender_or_receiver_everything_wrong() {
    let data_decoded = Some(DataDecoded {
        method: "wrong_transfer_method".to_string(),
        parameters: Some(vec![Parameter {
            name: "to".to_string(),
            param_type: "address".to_string(),
            value: SingleValue("0x2230B3d59858296A31053C1b8562Ecf89A2f888b".to_string()),
            value_decoded: None,
        }]),
    });

    let actual =
        check_sender_or_receiver(&data_decoded, "0x1230B3d59858296A31053C1b8562Ecf89A2f888b");
    assert!(!actual);
}

'''
'''--- src/routes/transactions/converters/tests/data_size_calculation.rs ---
use crate::routes::transactions::converters::data_size;

#[test]
fn data_size_calculation() {
    assert_eq!(data_size(&None), 0);
    assert_eq!(data_size(&Some(String::from(""))), 0);
    assert_eq!(data_size(&Some(String::from("0x"))), 0);
    assert_eq!(
        data_size(&Some(String::from("0x8d80ff0a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000f2001230b3d59858296a31053c1b8562ecf89a2f888b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000247de7edef00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f001230b3d59858296a31053c1b8562ecf89a2f888b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024f08a0323000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000"))),
        324
    );
}

'''
'''--- src/routes/transactions/converters/tests/details.rs ---
use mockall::predicate::eq;

use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::{ModuleTransaction, MultisigTransaction};
use crate::common::models::backend::transfers::Transfer as TransferDto;
use crate::common::models::data_decoded::ParamValue::SingleValue;
use crate::common::models::data_decoded::{DataDecoded, Operation, Parameter};
use crate::providers::address_info::ContractInfo;
use crate::providers::info::*;
use crate::routes::transactions::converters::details::is_trusted_delegate_call;
use crate::routes::transactions::models::details::{
    DetailedExecutionInfo, ModuleExecutionDetails, MultisigConfirmation, MultisigExecutionDetails,
    TransactionData, TransactionDetails,
};
use crate::routes::transactions::models::{
    Custom, Erc721Transfer, TransactionInfo, TransactionStatus, Transfer, TransferDirection,
    TransferInfo,
};
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::Response;

#[rocket::async_test]
async fn multisig_custom_transaction_to_transaction_details() {
    let multisig_tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_CUSTOM)
            .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let safe_address = safe_info.address.to_owned();
    let timestamp_confirmation0: i64 = 1592837914055;
    let timestamp_confirmation1: i64 = 1592838142231;

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider
        .expect_token_info()
        .times(1)
        .returning(move |_| bail!("Token Address 0x0"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(3) // to_info, tx_data and data_decoded "spender" address parameter
        .returning(move |_| bail!("No address info"));

    let expected = TransactionDetails {
        safe_address: safe_address,
        tx_id: multisig_tx.generate_id(),
        executed_at: multisig_tx.execution_date.map(|it| it.timestamp_millis()),
        tx_status: TransactionStatus::Success,
        tx_hash: Some("0x0ebb2c317f55c96469e0ed2014f5833dc02a70b42f0ac52f4630938900caa698".to_string()),
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            data_size: "68".to_string(),
            value: "0".to_string(),
            method_name: Some("approve".to_string()),
            action_count: None,
            is_cancellation: false,
        }),
        tx_data: Some(TransactionData {
            hex_data: Some(String::from("0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000")),
            data_decoded: Some(DataDecoded {
                method: "approve".to_string(),
                parameters: Some(vec![
                    Parameter {
                        name: "spender".to_string(),
                        param_type: "address".to_string(),
                        value: SingleValue(String::from("0xae9844F89D98c150F5e61bfC676D68b492155990")),
                        value_decoded: None,
                    },
                    Parameter {
                        name: "value".to_string(),
                        param_type: "uint256".to_string(),
                        value: SingleValue(String::from("500000000000000")),
                        value_decoded: None,
                    },
                ]),
            }),
            to: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            value: Some(String::from("0")),
            operation: Operation::CALL,
            address_info_index: None,
            trusted_delegate_call_target: None,
        }),
        detailed_execution_info: Some(DetailedExecutionInfo::Multisig(
            MultisigExecutionDetails {
                submitted_at: multisig_tx.submission_date.timestamp_millis(),
                nonce: 84,
                safe_tx_gas: "43485".to_string(),
                base_gas: "0".to_string(),
                gas_price: "0".to_string(),
                gas_token: "0x0000000000000000000000000000000000000000".to_string(),
                refund_receiver: AddressEx::address_only("0x0000000000000000000000000000000000000000"),
                safe_tx_hash: "0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621".to_string(),
                executor: Some(AddressEx::address_only("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd")),
                signers: vec![
                    AddressEx::address_only("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
                    AddressEx::address_only("0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72"),
                    AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
                    AddressEx::address_only("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
                    AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
                ],
                confirmations_required: 2,
                confirmations: vec![
                    MultisigConfirmation {
                        signer: AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
                        signature: Some(String::from("0x83b1506c409918f21031e93ed2f62310a5e0c05b1be89242a6a266a7de4af7bc6094e206b33387b8d4465af6087a4d2158815e613aeb186d88d9a1973e00bbe81b")),
                        submitted_at: timestamp_confirmation0,
                    },
                    MultisigConfirmation {
                        signer: AddressEx::address_only("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
                        signature: Some(String::from("0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001")),
                        submitted_at: timestamp_confirmation1,
                    },
                ],
                rejectors: None,
                gas_token_info: None,
                trusted: false,
            })),
        safe_app_info: None,
    };

    let actual =
        MultisigTransaction::to_transaction_details(&multisig_tx, None, &mut mock_info_provider)
            .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn module_transaction_to_transaction_details_module_info_success() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .returning(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", address).to_string()),
                logo_uri: None,
            })
        });
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(2)
        .returning(move |_| bail!("No address info"));

    let module_transaction =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX).unwrap();

    let expected = TransactionDetails {
        safe_address: module_transaction.safe_transaction.safe.to_owned(),
        tx_id: module_transaction.generate_id(),
        executed_at: Some(module_transaction.execution_date.timestamp_millis()),
        tx_status: TransactionStatus::Success,
        tx_hash: Some("0x705167e310ef0acb80a5f73eb4f8e66cfb32a896ac9380f3eb43e68ef8603a9f".to_string()),
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only("0xaAEb2035FF394fdB2C879190f95e7676f1A9444B"),
            data_size: "132".to_string(),
            value: "0".to_string(),
            method_name: None,
            action_count: None,
            is_cancellation: false,
        }),
        tx_data: Some(TransactionData {
            hex_data: Some(String::from("0x59f96ae500000000000000000000000000df91984582e6e96288307e9c2f20b38c8fece9000000000000000000000000c778417e063141139fce010982780140aa0cd5ab0000000000000000000000000000000000000000000000000000000000000475000000000000000000000000000000000000000000000003d962c8be3053def2")),
            data_decoded: None,
            to: AddressEx::address_only("0xaAEb2035FF394fdB2C879190f95e7676f1A9444B"),
            value: Some(String::from("0")),
            operation: Operation::CALL,
            address_info_index: None,
            trusted_delegate_call_target: None,
        }),
        detailed_execution_info: Some(DetailedExecutionInfo::Module(
            ModuleExecutionDetails {
                address: AddressEx {
                    value: "0xfa559f0932b7B60d90B4af0b8813d4088465096b".to_string(),
                    name: Some("0xfa559f0932b7B60d90B4af0b8813d4088465096b_name".to_string()),
                    logo_uri: None,
                }
            })),
        safe_app_info: None,
    };

    let actual =
        ModuleTransaction::to_transaction_details(&module_transaction, &mut mock_info_provider)
            .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn module_transaction_to_transaction_details_success() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .returning(move |_| bail!("No address info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(2)
        .returning(move |_| bail!("No address info"));

    let module_transaction =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX).unwrap();

    let expected = TransactionDetails {
        safe_address: module_transaction.safe_transaction.safe.to_owned(),
        tx_id: module_transaction.generate_id(),
        executed_at: Some(module_transaction.execution_date.timestamp_millis()),
        tx_status: TransactionStatus::Success,
        tx_hash: Some("0x705167e310ef0acb80a5f73eb4f8e66cfb32a896ac9380f3eb43e68ef8603a9f".to_string()),
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only("0xaAEb2035FF394fdB2C879190f95e7676f1A9444B"),
            data_size: "132".to_string(),
            value: "0".to_string(),
            method_name: None,
            action_count: None,
            is_cancellation: false,
        }),
        tx_data: Some(TransactionData {
            hex_data: Some(String::from("0x59f96ae500000000000000000000000000df91984582e6e96288307e9c2f20b38c8fece9000000000000000000000000c778417e063141139fce010982780140aa0cd5ab0000000000000000000000000000000000000000000000000000000000000475000000000000000000000000000000000000000000000003d962c8be3053def2")),
            data_decoded: None,
            to: AddressEx::address_only("0xaAEb2035FF394fdB2C879190f95e7676f1A9444B"),
            value: Some(String::from("0")),
            operation: Operation::CALL,
            address_info_index: None,
            trusted_delegate_call_target: None,
        }),
        detailed_execution_info: Some(DetailedExecutionInfo::Module(
            ModuleExecutionDetails {
                address: AddressEx::address_only("0xfa559f0932b7B60d90B4af0b8813d4088465096b")
            })),
        safe_app_info: None,
    };

    let actual =
        ModuleTransaction::to_transaction_details(&module_transaction, &mut mock_info_provider)
            .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn module_transaction_to_transaction_details_failed() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .returning(move |_| bail!("No address info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(2)
        .returning(move |_| bail!("No address info"));

    let module_transaction =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX_FAILED).unwrap();

    let expected = TransactionDetails {
        safe_address: module_transaction.safe_transaction.safe.to_owned(),
        tx_id: module_transaction.generate_id(),
        executed_at: Some(module_transaction.execution_date.timestamp_millis()),
        tx_status: TransactionStatus::Failed,
        tx_hash: Some("0x705167e310ef0acb80a5f73eb4f8e66cfb32a896ac9380f3eb43e68ef8603a9f".to_string()),
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only("0xaAEb2035FF394fdB2C879190f95e7676f1A9444B"),
            data_size: "132".to_string(),
            value: "0".to_string(),
            method_name: None,
            action_count: None,
            is_cancellation: false,
        }),
        tx_data: Some(TransactionData {
            hex_data: Some(String::from("0x59f96ae500000000000000000000000000df91984582e6e96288307e9c2f20b38c8fece9000000000000000000000000c778417e063141139fce010982780140aa0cd5ab0000000000000000000000000000000000000000000000000000000000000475000000000000000000000000000000000000000000000003d962c8be3053def2")),
            data_decoded: None,
            to: AddressEx::address_only("0xaAEb2035FF394fdB2C879190f95e7676f1A9444B"),
            value: Some(String::from("0")),
            operation: Operation::CALL,
            address_info_index: None,
            trusted_delegate_call_target: None,
        }),
        detailed_execution_info: Some(DetailedExecutionInfo::Module(
            ModuleExecutionDetails {
                address: AddressEx::address_only("0xfa559f0932b7B60d90B4af0b8813d4088465096b")
            })),
        safe_app_info: None,
    };

    let actual =
        ModuleTransaction::to_transaction_details(&module_transaction, &mut mock_info_provider)
            .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn ethereum_tx_transfer_to_transaction_details() {
    let transfer = serde_json::from_str::<TransferDto>(
        crate::tests::json::ERC_20_TRANSFER_WITH_ERC721_TOKEN_INFO,
    )
    .unwrap();

    let expected = TransactionDetails {
        safe_address: "0xBc79855178842FDBA0c353494895DEEf509E26bB".to_string(),
        tx_id: transfer.generate_id("0xBc79855178842FDBA0c353494895DEEf509E26bB", "0x317db9d079e46fef2f758e37bd20efb14d5c83e2510307079207bc6f04cdee48"),
        executed_at: Some(transfer.get_execution_time().unwrap()),
        tx_status: TransactionStatus::Success,
        tx_hash: Some(
            "0x317db9d079e46fef2f758e37bd20efb14d5c83e2510307079207bc6f04cdee48".to_string(),
        ),
        tx_info: TransactionInfo::Transfer(Transfer {
            sender: AddressEx::address_only("0xd31e655bC4Eb5BCFe25A47d636B25bb4aa4041B2"),
            recipient: AddressEx::address_only("0xBc79855178842FDBA0c353494895DEEf509E26bB"),
            direction: TransferDirection::Incoming,
            transfer_info: TransferInfo::Erc721(Erc721Transfer {
                token_address: "0xa9517B2E61a57350D6555665292dBC632C76adFe".to_string(),
                token_id: "856420144564".to_string(),
                token_name: Some("a!NEVER VISIT www.168pools.com to check DeFi ROi !".to_string()),
                token_symbol: Some("a!NEVER VISIT www.168pools.com to check DeFi ROi !".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xa9517B2E61a57350D6555665292dBC632C76adFe.png".to_string()),
            }),
        }),
        tx_data: None,
        detailed_execution_info: None,
        safe_app_info: None,
    };

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let actual = TransferDto::to_transaction_details(
        &transfer,
        &mut mock_info_provider,
        "0xBc79855178842FDBA0c353494895DEEf509E26bB",
        "0x317db9d079e46fef2f758e37bd20efb14d5c83e2510307079207bc6f04cdee48",
    )
    .await;

    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn multisig_transaction_with_origin() {
    let multisig_tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_WITH_ORIGIN)
            .unwrap();
    let mut safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    // Lower nonce so that transaction is pending again
    safe_info.nonce = 140;

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| bail!("No token info"));
    mock_info_provider
        .expect_safe_app_info()
        .times(1)
        .return_once(move |_| {
            Ok(SafeAppInfo {
                name: "WalletConnect".to_string(),
                url: "https://apps.gnosis-safe.io/walletConnect".to_string(),
                logo_uri: "https://apps.gnosis-safe.io/walletConnect/walletConnect.jpg".to_string(),
            })
        });
    mock_info_provider
        .expect_contract_info()
        .with(eq("0x8D29bE29923b68abfDD21e541b9374737B49cdAD"))
        .times(1)
        .return_once(move |_| {
            Ok(ContractInfo {
                name: "multiSend".to_string(),
                address: "0x8D29bE29923b68abfDD21e541b9374737B49cdAD".to_string(),
                display_name: "Gnosis Safe: Multi Send 1.1.1".to_string(),
                logo_uri: None,
                contract_abi: None,
                trusted_for_delegate_call: true,
            })
        });
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(8) // 2 (to) + 6 calls within data decoded multisig
        .returning(move |_| bail!("no address info"));

    let expected =
        serde_json::from_str::<TransactionDetails>(crate::tests::json::TX_DETAILS_WITH_ORIGIN)
            .unwrap();

    let actual =
        MultisigTransaction::to_transaction_details(&multisig_tx, None, &mut mock_info_provider)
            .await
            .unwrap();

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn is_trusted_delegate_with_call() {
    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_MULTI_SEND).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_contract_info().times(0);

    let actual = is_trusted_delegate_call(
        &Operation::CALL,
        "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
        &Some(data_decoded),
        &mock_info_provider,
    )
    .await
    .unwrap();

    assert_eq!(actual, None);
}

#[rocket::async_test]
async fn is_trusted_delegate_with_delegate() {
    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_MULTI_SEND).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_contract_info()
        .with(eq("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"))
        .times(1)
        .return_once(move |_| {
            Ok(ContractInfo {
                name: "name".to_string(),
                address: "address".to_string(),
                display_name: "display name".to_string(),
                logo_uri: None,
                contract_abi: None,
                trusted_for_delegate_call: false,
            })
        });

    let actual = is_trusted_delegate_call(
        &Operation::DELEGATE,
        "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
        &Some(data_decoded),
        &mock_info_provider,
    )
    .await
    .unwrap();

    assert_eq!(actual, Some(false));
}

#[rocket::async_test]
async fn is_trusted_delegate_with_contract_request_404() {
    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_MULTI_SEND).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_contract_info()
        .with(eq("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"))
        .times(1)
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                body: String::new(),
                status_code: 404,
            }))
        });

    let actual = is_trusted_delegate_call(
        &Operation::DELEGATE,
        "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
        &Some(data_decoded),
        &mock_info_provider,
    )
    .await;

    assert_eq!(actual.unwrap(), None);
}

#[rocket::async_test]
async fn is_trusted_delegate_with_contract_request_failure() {
    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_MULTI_SEND).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_contract_info()
        .with(eq("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"))
        .times(1)
        .return_once(move |_| {
            Err(ApiError::from_http_response(&Response {
                body: String::new(),
                status_code: 500,
            }))
        });

    let actual = is_trusted_delegate_call(
        &Operation::DELEGATE,
        "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
        &Some(data_decoded),
        &mock_info_provider,
    )
    .await;

    assert_eq!(
        actual.unwrap_err(),
        ApiError {
            status: 500,
            details: ErrorDetails {
                code: 1337,
                message: Some("".to_string()),
                debug: None,
                arguments: None
            }
        }
    );
}

#[rocket::async_test]
async fn is_trusted_delegate_with_call_but_nested_delegate() {
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DOCTORED_DATA_DECODED_MULTI_SEND_NESTED_DELEGATE,
    )
    .unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_contract_info()
        .with(eq("0x8D29bE29923b68abfDD21e541b9374737B49cdAD"))
        .times(1)
        .return_once(move |_| {
            Ok(ContractInfo {
                name: "multiSend".to_string(),
                address: "0x8D29bE29923b68abfDD21e541b9374737B49cdAD".to_string(),
                display_name: "Gnosis Safe: Multi Send 1.1.1".to_string(),
                logo_uri: None,
                contract_abi: None,
                trusted_for_delegate_call: true,
            })
        });

    let actual = is_trusted_delegate_call(
        &Operation::DELEGATE,
        "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
        &Some(data_decoded),
        &mock_info_provider,
    )
    .await
    .unwrap();

    assert_eq!(actual, Some(false));
}

'''
'''--- src/routes/transactions/converters/tests/is_cancellation.rs ---
use crate::common::models::backend::transactions::{MultisigTransaction, SafeTransaction};
use crate::common::models::data_decoded::Operation;
use chrono::Utc;

#[test]
fn is_cancellation_result_true() {
    let tx = build_multisig_tx();

    assert_eq!(true, tx.is_cancellation());
}

#[test]
fn is_cancellation_has_0x_data_result_true() {
    let mut tx = build_multisig_tx();
    tx.safe_transaction.data = Some(String::from("0x"));

    assert_eq!(true, tx.is_cancellation());
}

#[test]
fn is_cancellation_has_safe_tx_gas_result_false() {
    let mut tx = build_multisig_tx();
    tx.safe_tx_gas = Some(1);

    assert_eq!(false, tx.is_cancellation());
}

#[test]
fn is_cancellation_has_value_result_false() {
    let mut tx = build_multisig_tx();
    tx.safe_transaction.value = Some(String::from("1"));

    assert_eq!(false, tx.is_cancellation());
}

#[test]
fn is_cancellation_has_data_result_false() {
    let mut tx = build_multisig_tx();
    tx.safe_transaction.data = Some(String::from("0x12345678"));

    assert_eq!(false, tx.is_cancellation());
}

#[test]
fn is_cancellation_delegate_operation_false() {
    let mut tx = build_multisig_tx();
    tx.safe_transaction.operation = Operation::DELEGATE;

    assert_eq!(false, tx.is_cancellation());
}

#[test]
fn is_cancellation_has_base_gas_result_false() {
    let mut tx = build_multisig_tx();
    tx.base_gas = Some(1);

    assert_eq!(false, tx.is_cancellation());
}

#[test]
fn is_cancellation_has_gas_price_result_false() {
    let mut tx = build_multisig_tx();
    tx.gas_price = Some(String::from("1"));

    assert_eq!(false, tx.is_cancellation());
}

#[test]
fn is_cancellation_has_gas_token_result_false() {
    let mut tx = build_multisig_tx();
    tx.gas_token = Some(String::from("0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46"));

    assert_eq!(false, tx.is_cancellation());
}

#[test]
fn is_cancellation_has_refund_receiver_result_false() {
    let mut tx = build_multisig_tx();
    tx.refund_receiver = Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"));

    assert_eq!(false, tx.is_cancellation());
}

fn build_multisig_tx() -> MultisigTransaction {
    MultisigTransaction {
        safe_transaction: SafeTransaction {
            safe: "0x1".to_string(),
            to: "0x1".to_string(),
            value: None,
            data: None,
            data_decoded: None,
            operation: Operation::CALL,
        },
        gas_token: None,
        safe_tx_gas: None,
        base_gas: None,
        gas_price: None,
        refund_receiver: None,
        nonce: 0,
        execution_date: None,
        submission_date: Utc::now(),
        modified: None,
        block_number: None,
        transaction_hash: None,
        safe_tx_hash: "".to_string(),
        executor: None,
        is_executed: false,
        is_successful: None,
        eth_gas_price: None,
        gas_used: None,
        fee: None,
        origin: None,
        confirmations_required: None,
        confirmations: None,
        signatures: None,
        trusted: false,
    }
}

'''
'''--- src/routes/transactions/converters/tests/map_status.rs ---
use crate::common::models::backend::transactions::MultisigTransaction;
use crate::providers::info::SafeInfo;
use crate::routes::transactions::models::TransactionStatus;

#[test]
fn map_status_to_success() {
    let tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_ETHER_TRANSFER)
            .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let actual = tx.map_status(&safe_info);

    assert_eq!(TransactionStatus::Success, actual);
}

#[test]
fn map_status_to_failed() {
    let tx = serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_FAILED)
        .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let actual = tx.map_status(&safe_info);

    assert_eq!(TransactionStatus::Failed, actual);
}

#[test]
fn map_status_to_cancelled() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC721_TRANSFER_CANCELLED,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES_AND_HIGH_NONCE)
            .unwrap();
    let actual = tx.map_status(&safe_info);

    assert_eq!(TransactionStatus::Cancelled, actual);
}

#[test]
fn map_status_awaiting_execution() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_EXECUTION,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let actual = tx.map_status(&safe_info);

    assert_eq!(TransactionStatus::AwaitingExecution, actual);
}

#[test]
fn map_status_awaiting_confirmations_required_field_none() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS_REQUIRED_NULL,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_THRESHOLD_TWO).unwrap();
    let actual = tx.map_status(&safe_info);

    assert_eq!(TransactionStatus::AwaitingConfirmations, actual);
}

#[test]
fn map_status_awaiting_confirmations_required_field_some() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_THRESHOLD_TWO).unwrap();
    let actual = tx.map_status(&safe_info);

    assert_eq!(TransactionStatus::AwaitingConfirmations, actual);
}

#[test]
fn confirmations_required_none() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS_REQUIRED_NULL,
    )
    .unwrap();
    let actual = tx.confirmation_required(11);

    assert_eq!(11, actual);
}

#[test]
fn confirmations_required_some() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS,
    )
    .unwrap();
    let actual = tx.confirmation_required(11);

    assert_eq!(2, actual);
}

#[test]
fn confirmation_count_none() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_CONFIRMATIONS_NULL,
    )
    .unwrap();

    let actual = tx.confirmation_count();
    assert_eq!(0, actual)
}

#[test]
fn confirmation_count_some() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS,
    )
    .unwrap();

    let actual = tx.confirmation_count();
    assert_eq!(1, actual)
}

'''
'''--- src/routes/transactions/converters/tests/missing_signers.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::MultisigTransaction;
use crate::providers::info::SafeInfo;

#[test]
fn missing_signers_on_awaiting_confirmation_empty() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS_EMPTY,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();

    let actual = tx.missing_signers(&safe_info.owners);
    let expected: Vec<AddressEx> = vec![
        AddressEx::address_only("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
        AddressEx::address_only("0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72"),
        AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
        AddressEx::address_only("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
    ];
    assert_eq!(expected, actual);
}

#[test]
fn missing_signers_on_awaiting_confirmation_null() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS_NULL,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();

    let actual = tx.missing_signers(&safe_info.owners);
    let expected: Vec<AddressEx> = vec![
        AddressEx::address_only("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
        AddressEx::address_only("0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72"),
        AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
        AddressEx::address_only("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
    ];
    assert_eq!(expected, actual);
}

#[test]
fn missing_signers_on_awaiting_confirmation() {
    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();

    let actual = tx.missing_signers(&safe_info.owners);
    let expected: Vec<AddressEx> = vec![
        AddressEx::address_only("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
        AddressEx::address_only("0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72"),
        AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
    ];
    assert_eq!(expected, actual);
}

'''
'''--- src/routes/transactions/converters/tests/mod.rs ---
pub(super) mod check_sender_or_receiver;
mod data_size_calculation;
mod details;
mod is_cancellation;
pub(super) mod map_status;
pub(super) mod missing_signers;
mod safe_app_info;
mod summary;
pub mod transaction_id;
pub(super) mod transaction_types;
pub(super) mod transfer_type_checks;

'''
'''--- src/routes/transactions/converters/tests/safe_app_info.rs ---
use crate::providers::info::*;
use crate::routes::transactions::converters::safe_app_info::{safe_app_info_from, OriginInternal};
use mockall::predicate::eq;

#[test]
fn valid_full_origin_data() {
    let origin =
        "{\"url\":\"https://apps.gnosis-safe.io/walletConnect\",\"name\":\"WalletConnect\"}";

    let expected = OriginInternal {
        url: "https://apps.gnosis-safe.io/walletConnect".to_string(),
    };

    let actual = serde_json::from_str::<OriginInternal>(origin).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn valid_missing_name_origin_data() {
    let origin = "{\"url\":\"https://apps.gnosis-safe.io/walletConnect\"}";

    let expected = OriginInternal {
        url: "https://apps.gnosis-safe.io/walletConnect".to_string(),
    };

    let actual = serde_json::from_str::<OriginInternal>(origin).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn ellipsized_name_origin_data() {
    let origin =
        "{\"url\":\"https://apps.gnosis-safe.io/walletConnect\",\"name\":\"Walle...nect\"}";

    let expected = OriginInternal {
        url: "https://apps.gnosis-safe.io/walletConnect".to_string(),
    };

    let actual = serde_json::from_str::<OriginInternal>(origin).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn ellipsized_url_origin_data() {
    let origin = "{\"url\":\"https://apps.gnosis-safe.io/wallet...t\",\"name\":\"WalletConnect\"}";

    let expected = OriginInternal {
        url: "https://apps.gnosis-safe.io/wallet...t".to_string(),
    };

    let actual = serde_json::from_str::<OriginInternal>(origin).unwrap();

    assert_eq!(expected, actual);
}

#[test]
#[should_panic]
fn ellipsized_invalid_json_origin_data() {
    let origin =
        "{\"url\":\"https://apps.gnosis-safe.io/walletConnect\",...me\":\"WalletConnect\"}";

    serde_json::from_str::<OriginInternal>(origin).unwrap();
}

#[rocket::async_test]
async fn to_safe_app_info_bad_url() {
    let origin = "{\"url\":\"https://apps.gnosis-safe.io/walletConnect\"}";
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_app_info()
        .times(1)
        .return_once(move |_| bail!("Some http error"));

    let actual = safe_app_info_from(origin, &mut mock_info_provider).await;
    assert!(actual.is_none());
}

#[rocket::async_test]
async fn to_safe_app_info_correct() {
    let origin = "{\"url\":\"https://apps.gnosis-safe.io/walletConnect\"}";
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_app_info()
        .times(1)
        .return_once(move |_| {
            Ok(SafeAppInfo {
                name: "WalletConnect".to_string(),
                url: "https://apps.gnosis-safe.io/walletConnect".to_string(),
                logo_uri: "https://apps.gnosis-safe.io/walletConnect/walletConnect.jpg".to_string(),
            })
        });

    let expected = SafeAppInfo {
        name: "WalletConnect".to_string(),
        url: "https://apps.gnosis-safe.io/walletConnect".to_string(),
        logo_uri: "https://apps.gnosis-safe.io/walletConnect/walletConnect.jpg".to_string(),
    };

    let actual = safe_app_info_from(origin, &mut mock_info_provider).await;
    assert!(actual.is_some());
    assert_eq!(expected, actual.unwrap());
}

#[rocket::async_test]
async fn valid_ipfs_origin_gets_replaced() {
    let origin =
        "{\"url\":\"https://ipfs.io/ipfs/QmRWtuktjfU6WMAEJFgzBC4cUfqp3FF5uN9QoWb55SdGG5/manifest.json\",\"name\":\"WalletConnect\"}";
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_app_info()
        .times(1)
        .with(eq("https://cloudflare-ipfs.com/ipfs/QmRWtuktjfU6WMAEJFgzBC4cUfqp3FF5uN9QoWb55SdGG5/manifest.json"))
        .return_once(move |_| {
            Ok(SafeAppInfo {
                name: "WalletConnect".to_string(),
                url: "https://ipfs.io/ipfs/QmRWtuktjfU6WMAEJFgzBC4cUfqp3FF5uN9QoWb55SdGG5/walletConnect".to_string(),
                logo_uri: "https://ipfs.io/ipfs/QmRWtuktjfU6WMAEJFgzBC4cUfqp3FF5uN9QoWb55SdGG5/walletConnect/walletConnect.jpg".to_string(),
            })
        });

    let expected = SafeAppInfo {
        name: "WalletConnect".to_string(),
        url: "https://ipfs.io/ipfs/QmRWtuktjfU6WMAEJFgzBC4cUfqp3FF5uN9QoWb55SdGG5/walletConnect".to_string(),
        logo_uri: "https://ipfs.io/ipfs/QmRWtuktjfU6WMAEJFgzBC4cUfqp3FF5uN9QoWb55SdGG5/walletConnect/walletConnect.jpg".to_string(),
    };

    let actual = safe_app_info_from(origin, &mut mock_info_provider).await;
    assert!(actual.is_some());
    assert_eq!(expected, actual.unwrap());
}

'''
'''--- src/routes/transactions/converters/tests/summary.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::{
    CreationTransaction, EthereumTransaction, ModuleTransaction, MultisigTransaction,
    SafeTransaction, Transaction as TransactionDto,
};
use crate::common::models::backend::transfers::{
    EtherTransfer as EtherTransferDto, Transfer as TransferDto,
};
use crate::common::models::data_decoded::ParamValue::SingleValue;
use crate::common::models::data_decoded::{DataDecoded, Operation, Parameter};
use crate::providers::info::*;
use crate::routes::transactions::converters::data_size;
use crate::routes::transactions::models::summary::{
    ExecutionInfo, ModuleExecutionInfo, MultisigExecutionInfo, TransactionSummary,
};
use crate::routes::transactions::models::{
    Creation, Custom, Erc20Transfer, Erc721Transfer, NativeCoinTransfer, SettingsChange,
    SettingsInfo, TransactionInfo, TransactionStatus, Transfer, TransferDirection, TransferInfo,
    ID_PREFIX_CREATION_TX, ID_PREFIX_ETHEREUM_TX, ID_PREFIX_MODULE_TX, ID_PREFIX_MULTISIG_TX,
};
use crate::utils::hex_hash;
use chrono::Utc;

#[test]
fn data_size_calculation() {
    assert_eq!(data_size(&None), 0);
    assert_eq!(data_size(&Some(String::from(""))), 0);
    assert_eq!(data_size(&Some(String::from("0x"))), 0);
    assert_eq!(
        data_size(&Some(String::from("0x8d80ff0a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000f2001230b3d59858296a31053c1b8562ecf89a2f888b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000247de7edef00000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f001230b3d59858296a31053c1b8562ecf89a2f888b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024f08a0323000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000"))),
        324
    );
}

#[rocket::async_test]
async fn unknown_tx_to_summary_transaction() {
    let unknown_tx = TransactionDto::Unknown;
    let mut mock_info_provider = MockInfoProvider::new();

    let error = unknown_tx
        .to_transaction_summary(&mut mock_info_provider, &String::from(""))
        .await;

    assert!(error.is_err());
}

#[rocket::async_test]
async fn module_tx_to_summary_transaction_success() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .returning(move |_| bail!("No address info"));

    let expected_to = String::from("0x12345789");
    let expected_date = Utc::now();
    let expected_date_in_millis = expected_date.timestamp_millis();
    let module_tx = ModuleTransaction {
        safe_transaction: SafeTransaction {
            safe: String::from("safe"),
            to: expected_to.clone(),
            value: None,
            data: None,
            data_decoded: None,
            operation: Operation::CALL,
        },
        created: String::from("created"),
        execution_date: expected_date,
        block_number: 0,
        is_successful: true,
        transaction_hash: String::from("tx_hash"),
        module: String::from("module"),
    };

    let actual =
        ModuleTransaction::to_transaction_summary(&module_tx, &mut mock_info_provider).await;
    let expected = vec![TransactionSummary {
        id: create_id!(
            ID_PREFIX_MODULE_TX,
            module_tx.safe_transaction.safe,
            module_tx.transaction_hash,
            hex_hash(&module_tx)
        ),
        timestamp: expected_date_in_millis,
        tx_status: TransactionStatus::Success,
        execution_info: Some(ExecutionInfo::Module(ModuleExecutionInfo {
            address: AddressEx::address_only("module"),
        })),
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only(&expected_to),
            data_size: String::from("0"),
            value: String::from("0"),
            method_name: None,
            action_count: None,
            is_cancellation: false,
        }),
        safe_app_info: None,
    }];
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn module_tx_to_summary_transaction_failed() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .returning(move |_| bail!("No address info"));

    let expected_to = String::from("0x12345789");
    let expected_date = Utc::now();
    let expected_date_in_millis = expected_date.timestamp_millis();
    let module_tx = ModuleTransaction {
        safe_transaction: SafeTransaction {
            safe: String::from("safe"),
            to: expected_to.clone(),
            value: None,
            data: None,
            data_decoded: None,
            operation: Operation::CALL,
        },
        created: String::from("created"),
        execution_date: expected_date,
        block_number: 0,
        is_successful: false,
        transaction_hash: String::from("tx_hash"),
        module: String::from("module"),
    };

    let actual =
        ModuleTransaction::to_transaction_summary(&module_tx, &mut mock_info_provider).await;
    let expected = vec![TransactionSummary {
        id: create_id!(
            ID_PREFIX_MODULE_TX,
            module_tx.safe_transaction.safe,
            module_tx.transaction_hash,
            hex_hash(&module_tx)
        ),
        timestamp: expected_date_in_millis,
        tx_status: TransactionStatus::Failed,
        execution_info: Some(ExecutionInfo::Module(ModuleExecutionInfo {
            address: AddressEx::address_only("module"),
        })),
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only(&expected_to),
            data_size: String::from("0"),
            value: String::from("0"),
            method_name: None,
            action_count: None,
            is_cancellation: false,
        }),
        safe_app_info: None,
    }];
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn module_transaction_to_custom_summary_and_module_info() {
    let module_tx =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX).unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some(format!("{}_name", address)),
                logo_uri: None,
            })
        });
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionSummary {
        id: create_id!(
            ID_PREFIX_MODULE_TX,
            module_tx.safe_transaction.safe,
            module_tx.transaction_hash,
            hex_hash(&module_tx)
        ),
        timestamp: module_tx.execution_date.timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only("0xaAEb2035FF394fdB2C879190f95e7676f1A9444B"),
            data_size: "132".to_string(),
            value: "0".to_string(),
            method_name: None,
            action_count: None,
            is_cancellation: false,
        }),
        execution_info: Some(ExecutionInfo::Module(ModuleExecutionInfo {
            address: AddressEx {
                value: "0xfa559f0932b7B60d90B4af0b8813d4088465096b".to_string(),
                name: Some("0xfa559f0932b7B60d90B4af0b8813d4088465096b_name".to_string()),
                logo_uri: None,
            },
        })),
        safe_app_info: None,
    };

    let actual =
        ModuleTransaction::to_transaction_summary(&module_tx, &mut mock_info_provider).await;

    assert_eq!(&expected, actual.get(0).unwrap());
}

#[rocket::async_test]
async fn ethereum_tx_to_summary_transaction_no_transfers() {
    let safe_address = String::from("0x2323");
    let mut mock_info_provider = MockInfoProvider::new();

    let ethereum_tx = EthereumTransaction {
        execution_date: Utc::now(),
        data: None,
        tx_hash: String::from("0x4321"),
        block_number: 0,
        transfers: None,
        from: String::from("0x6789"),
    };

    let actual = EthereumTransaction::to_transaction_summary(
        &ethereum_tx,
        &mut mock_info_provider,
        &safe_address,
    )
    .await;
    assert_eq!(actual, Vec::new());
}

#[rocket::async_test]
async fn ethereum_tx_to_summary_transaction_with_transfers() {
    let safe_address = String::from("0x2323");
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(4)
        .returning(move |_| bail!("No address info"));
    let timestamp = Utc::now();
    let timestamp_millis = timestamp.timestamp_millis();

    let transfers = vec![
        TransferDto::Ether(EtherTransferDto {
            execution_date: timestamp,
            block_number: 0,
            transaction_hash: "".to_string(),
            to: "".to_string(),
            value: String::from("1"),
            from: "".to_string(),
        }),
        TransferDto::Ether(EtherTransferDto {
            execution_date: timestamp,
            block_number: 0,
            transaction_hash: "".to_string(),
            to: "".to_string(),
            value: String::from("1"),
            from: "".to_string(),
        }),
    ];
    let ethereum_tx = EthereumTransaction {
        execution_date: timestamp,
        data: None,
        tx_hash: String::from("0x4321"),
        block_number: 0,
        transfers: Some(transfers.to_vec()),
        from: String::from("0x6789"),
    };

    let actual = EthereumTransaction::to_transaction_summary(
        &ethereum_tx,
        &mut mock_info_provider,
        &safe_address,
    )
    .await;
    let expected = vec![
        TransactionSummary {
            id: create_id!(
                ID_PREFIX_ETHEREUM_TX,
                safe_address,
                ethereum_tx.tx_hash,
                hex_hash(&ethereum_tx.transfers.as_ref().unwrap().get(0).unwrap())
            ),
            timestamp: timestamp_millis,
            tx_status: TransactionStatus::Success,
            tx_info: TransactionInfo::Transfer(Transfer {
                sender: AddressEx::address_only(""),
                recipient: AddressEx::address_only(""),
                direction: TransferDirection::Unknown,
                transfer_info: TransferInfo::NativeCoin(NativeCoinTransfer {
                    value: "1".to_string(),
                }),
            }),
            execution_info: None,
            safe_app_info: None,
        },
        TransactionSummary {
            id: create_id!(
                ID_PREFIX_ETHEREUM_TX,
                safe_address,
                ethereum_tx.tx_hash,
                hex_hash(&ethereum_tx.transfers.as_ref().unwrap().get(1).unwrap())
            ),
            timestamp: timestamp_millis,
            tx_status: TransactionStatus::Success,
            tx_info: TransactionInfo::Transfer(Transfer {
                sender: AddressEx::address_only(""),
                recipient: AddressEx::address_only(""),
                direction: TransferDirection::Unknown,
                transfer_info: TransferInfo::NativeCoin(NativeCoinTransfer {
                    value: "1".to_string(),
                }),
            }),
            execution_info: None,
            safe_app_info: None,
        },
    ];
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn creation_transaction_to_summary_no_address_info_available() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(3)
        .returning(move |_| bail!("No address info"));

    let created_date = Utc::now();
    let safe_address = String::from("0x38497");
    let creator = String::from("0x123");
    let transaction_hash = String::from("0x2232");
    let factory_address = String::from("0x123");
    let master_copy = String::from("0x987");
    let creation_tx = CreationTransaction {
        created: created_date,
        creator: creator.clone(),
        transaction_hash: transaction_hash.clone(),
        factory_address: Some(factory_address.clone()),
        master_copy: Some(master_copy.clone()),
        setup_data: None,
        data_decoded: None,
    };
    let expected = TransactionSummary {
        id: create_id!(ID_PREFIX_CREATION_TX, safe_address),
        timestamp: created_date.timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Creation(Creation {
            creator: AddressEx::address_only(&creator),
            transaction_hash,
            implementation: Some(AddressEx::address_only(&master_copy)),
            factory: Some(AddressEx::address_only(&factory_address)),
        }),
        execution_info: None,
        safe_app_info: None,
    };

    let actual = creation_tx
        .to_transaction_summary(&safe_address, &mut mock_info_provider)
        .await;

    assert_eq!(expected, actual);
}

// TODO test with addresses returned
#[rocket::async_test]
async fn creation_transaction_to_summary_address_info_available() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(3)
        .returning(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let created_date = Utc::now();
    let safe_address = String::from("0x38497");
    let creator = String::from("0x123");
    let transaction_hash = String::from("0x2232");
    let factory_address = String::from("0x123");
    let master_copy = String::from("0x987");
    let creation_tx = CreationTransaction {
        created: created_date,
        creator: creator.clone(),
        transaction_hash: transaction_hash.clone(),
        factory_address: Some(factory_address.clone()),
        master_copy: Some(master_copy.clone()),
        setup_data: None,
        data_decoded: None,
    };
    let expected = TransactionSummary {
        id: create_id!(ID_PREFIX_CREATION_TX, safe_address),
        timestamp: created_date.timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Creation(Creation {
            creator: AddressEx {
                value: creator,
                name: Some("".to_string()),
                logo_uri: None,
            },
            transaction_hash,
            implementation: Some(AddressEx {
                value: master_copy,
                name: Some("".to_string()),
                logo_uri: None,
            }),
            factory: Some(AddressEx {
                value: factory_address,
                name: Some("".to_string()),
                logo_uri: None,
            }),
        }),
        execution_info: None,
        safe_app_info: None,
    };

    let actual = creation_tx
        .to_transaction_summary(&safe_address, &mut mock_info_provider)
        .await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn multisig_transaction_to_erc20_transfer_summary() {
    let multisig_tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_ERC20_TRANSFER)
            .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let token_info = serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_USDT).unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionSummary {
        id: create_id!(ID_PREFIX_MULTISIG_TX, "0x1230B3d59858296A31053C1b8562Ecf89A2f888b", "0x95e32bb8cb88ecdc45732c0a551eae7b3744187cf1ba19cda1440eaaf7b4950c"),
        timestamp: multisig_tx.execution_date.unwrap().timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Transfer(Transfer {
            sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
            recipient: AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
            direction: TransferDirection::Outgoing,
            transfer_info: TransferInfo::Erc20(Erc20Transfer {
                token_address: "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02".to_string(),
                token_name: Some("Compound USDT".to_string()),
                token_symbol: Some("USDT".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png".to_string()),
                decimals: Some(18),
                value: "50000000000000".to_string(),
            }),
        }),
        execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
            nonce: 178,
            confirmations_required: 3,
            confirmations_submitted: 3,
            missing_signers: None,
        })),
        safe_app_info: None,
    };

    let actual =
        MultisigTransaction::to_transaction_summary(&multisig_tx, &mut mock_info_provider).await;

    assert_eq!(&expected, actual.unwrap().get(0).unwrap());
}

#[rocket::async_test]
async fn multisig_transaction_to_erc721_transfer_summary() {
    let multisig_tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC721_TRANSFER,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    let token_info =
        serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_CRYPTO_KITTIES).unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionSummary {
        id: create_id!(ID_PREFIX_MULTISIG_TX, "0x1230B3d59858296A31053C1b8562Ecf89A2f888b", "0x9155f7741dd33572bc49c251eb4f4a5e9cf9653151417bdc4a2aca0767779603"),
        timestamp: multisig_tx.execution_date.unwrap().timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Transfer(Transfer {
            sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
            recipient: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
            direction: TransferDirection::Outgoing,
            transfer_info: TransferInfo::Erc721(Erc721Transfer {
                token_address: "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF".to_string(),
                token_id: "1316".to_string(),
                token_name: Some("CryptoKitties".to_string()),
                token_symbol: Some("CK".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png".to_string()),
            }),
        }),
        execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
            nonce: 177,
            confirmations_required: 3,
            confirmations_submitted: 3,
            missing_signers: None,
        })),
        safe_app_info: None,
    };

    let actual =
        MultisigTransaction::to_transaction_summary(&multisig_tx, &mut mock_info_provider).await;

    assert_eq!(&expected, actual.unwrap().get(0).unwrap());
}

#[rocket::async_test]
async fn multisig_transaction_to_ether_transfer_summary() {
    let multisig_tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_ETHER_TRANSFER)
            .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionSummary {
        id: create_id!(
            ID_PREFIX_MULTISIG_TX,
            "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            "0x6e631d27c638458329ba95cc17961e74b8146c46886545cd1984bb2bcf4eccd3"
        ),
        timestamp: multisig_tx.execution_date.unwrap().timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Transfer(Transfer {
            sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
            recipient: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
            direction: TransferDirection::Outgoing,
            transfer_info: TransferInfo::NativeCoin(NativeCoinTransfer {
                value: "100000000000000000".to_string(),
            }),
        }),
        execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
            nonce: 147,
            confirmations_required: 2,
            confirmations_submitted: 2,
            missing_signers: None,
        })),
        safe_app_info: None,
    };

    let actual =
        MultisigTransaction::to_transaction_summary(&multisig_tx, &mut mock_info_provider).await;

    assert_eq!(&expected, actual.unwrap().get(0).unwrap());
}

#[rocket::async_test]
async fn multisig_transaction_to_settings_change_summary() {
    let multisig_tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_SETTINGS_CHANGE,
    )
    .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(0);
    mock_info_provider.expect_token_info().times(0);

    let expected = TransactionSummary {
        id: create_id!(
            ID_PREFIX_MULTISIG_TX,
            "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            "0x57d94fe21bbee8f6646c420ee23126cd1ba1b9a53a6c9b10099a043da8f32eea"
        ),
        timestamp: multisig_tx.execution_date.unwrap().timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::SettingsChange(SettingsChange {
            settings_info: Some(SettingsInfo::AddOwner {
                owner: AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
                threshold: 2,
            }),
            data_decoded: DataDecoded {
                method: "addOwnerWithThreshold".to_string(),
                parameters: Some(vec![
                    Parameter {
                        name: "owner".to_string(),
                        param_type: "address".to_string(),
                        value: SingleValue(
                            "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D".to_string(),
                        ),
                        value_decoded: None,
                    },
                    Parameter {
                        name: "_threshold".to_string(),
                        param_type: "uint256".to_string(),
                        value: SingleValue("2".to_string()),
                        value_decoded: None,
                    },
                ]),
            },
        }),
        execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
            nonce: 135,
            confirmations_required: 2,
            confirmations_submitted: 2,
            missing_signers: None,
        })),
        safe_app_info: None,
    };

    let actual =
        MultisigTransaction::to_transaction_summary(&multisig_tx, &mut mock_info_provider).await;

    assert_eq!(&expected, actual.unwrap().get(0).unwrap());
}

#[rocket::async_test]
async fn multisig_transaction_to_custom_summary() {
    let multisig_tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_CUSTOM)
            .unwrap();
    let safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionSummary {
        id: create_id!(
            ID_PREFIX_MULTISIG_TX,
            "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            "0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621"
        ),
        timestamp: multisig_tx.execution_date.unwrap().timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
            data_size: "68".to_string(),
            value: "0".to_string(),
            method_name: Some("approve".to_string()),
            action_count: None,
            is_cancellation: false,
        }),
        execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
            nonce: 84,
            confirmations_required: 2,
            confirmations_submitted: 2,
            missing_signers: None,
        })),
        safe_app_info: None,
    };

    let actual =
        MultisigTransaction::to_transaction_summary(&multisig_tx, &mut mock_info_provider).await;

    assert_eq!(&expected, actual.unwrap().get(0).unwrap());
}

#[rocket::async_test]
async fn multisig_transaction_with_missing_signers() {
    let multisig_tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_AWAITING_CONFIRMATIONS,
    )
    .unwrap();
    let mut safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    // Lower nonce so that transaction is pending again
    safe_info.nonce = 140;

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected = TransactionSummary {
        id: create_id!(
            ID_PREFIX_MULTISIG_TX,
            "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            "0x6e631d27c638458329ba95cc17961e74b8146c46886545cd1984bb2bcf4eccd3"
        ),
        timestamp: multisig_tx.submission_date.timestamp_millis(),
        tx_status: TransactionStatus::AwaitingConfirmations,
        tx_info: TransactionInfo::Transfer(Transfer {
            sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
            recipient: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
            direction: TransferDirection::Outgoing,
            transfer_info: TransferInfo::NativeCoin(NativeCoinTransfer {
                value: "100000000000000000".to_string(),
            }),
        }),
        execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
            nonce: 147,
            confirmations_required: 2,
            confirmations_submitted: 1,
            missing_signers: Some(vec![
                AddressEx::address_only("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
                AddressEx::address_only("0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72"),
                AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
                AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
            ]),
        })),
        safe_app_info: None,
    };

    let actual =
        MultisigTransaction::to_transaction_summary(&multisig_tx, &mut mock_info_provider).await;

    assert_eq!(&expected, actual.unwrap().get(0).unwrap());
}

#[rocket::async_test]
async fn ethereum_transaction_with_inconsistent_token_types() {
    let ethereum_tx = serde_json::from_str::<EthereumTransaction>(
        crate::tests::json::ETHEREUM_TX_INCONSISTENT_TOKEN_TYPES,
    )
    .unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let actual = EthereumTransaction::to_transaction_summary(
        &ethereum_tx,
        &mut mock_info_provider,
        "0xBc79855178842FDBA0c353494895DEEf509E26bB",
    )
    .await;
    let expected = TransactionSummary {
        id: create_id!(
            ID_PREFIX_ETHEREUM_TX,
            "0xBc79855178842FDBA0c353494895DEEf509E26bB",
            ethereum_tx.tx_hash,
            hex_hash(ethereum_tx.transfers.unwrap().first().unwrap())
        ),
        timestamp: ethereum_tx.execution_date.timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Transfer(Transfer {
            sender: AddressEx::address_only("0xd31e655bC4Eb5BCFe25A47d636B25bb4aa4041B2"),
            recipient: AddressEx::address_only("0xBc79855178842FDBA0c353494895DEEf509E26bB"),
            direction: TransferDirection::Incoming,
            transfer_info: TransferInfo::Erc721(Erc721Transfer {
                token_address: "0xb07de4b2989E180F8907B8C7e617637C26cE2776".to_string(),
                token_id: "856420144564".to_string(),
                token_name: Some("A! WWW.SPACESWAP.APP ! TOP DEFI AGGREGATOR !".to_string()),
                token_symbol: Some("A! WWW.SPACESWAP.APP ! TOP DEFI AGGREGATOR !".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xb07de4b2989E180F8907B8C7e617637C26cE2776.png".to_string()),
            }),
        }),
        execution_info: None,
        safe_app_info: None,
    };

    assert_eq!(1, actual.len());
    assert_eq!(&expected, actual.first().unwrap());
}

#[rocket::async_test]
async fn multisig_transaction_with_origin() {
    let multisig_tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_WITH_ORIGIN)
            .unwrap();
    let mut safe_info =
        serde_json::from_str::<SafeInfo>(crate::tests::json::SAFE_WITH_MODULES).unwrap();
    // Lower nonce so that transaction is pending again
    safe_info.nonce = 140;

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(1)
        .return_once(move |_| Ok(safe_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));
    mock_info_provider
        .expect_safe_app_info()
        .times(1)
        .return_once(move |_| {
            Ok(SafeAppInfo {
                name: "WalletConnect".to_string(),
                url: "https://apps.gnosis-safe.io/walletConnect".to_string(),
                logo_uri: "https://apps.gnosis-safe.io/walletConnect/walletConnect.jpg".to_string(),
            })
        });
    mock_info_provider.expect_token_info().times(0);

    let expected = TransactionSummary {
        id: create_id!(
            ID_PREFIX_MULTISIG_TX,
            "0xBc79855178842FDBA0c353494895DEEf509E26bB",
            "0x728e6dec56dc61523b56dc440e34c1c4c39c66895df8e5d3499ed1f7d4fcfe80"
        ),
        timestamp: multisig_tx.execution_date.unwrap().timestamp_millis(),
        tx_status: TransactionStatus::Success,
        tx_info: TransactionInfo::Custom(Custom {
            to: AddressEx::address_only("0x8D29bE29923b68abfDD21e541b9374737B49cdAD"),
            data_size: "3108".to_string(),
            value: "0".to_string(),
            method_name: Some("multiSend".to_string()),
            action_count: Some(1),
            is_cancellation: false,
        }),
        execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
            nonce: 160,
            confirmations_required: 2,
            confirmations_submitted: 2,
            missing_signers: None,
        })),
        safe_app_info: Some(SafeAppInfo {
            name: "WalletConnect".to_string(),
            url: "https://apps.gnosis-safe.io/walletConnect".to_string(),
            logo_uri: "https://apps.gnosis-safe.io/walletConnect/walletConnect.jpg".to_string(),
        }),
    };

    let actual =
        MultisigTransaction::to_transaction_summary(&multisig_tx, &mut mock_info_provider).await;

    assert_eq!(&expected, actual.unwrap().get(0).unwrap());
}

'''
'''--- src/routes/transactions/converters/tests/transaction_id.rs ---
use crate::common::models::backend::transactions::{
    CreationTransaction, EthereumTransaction, ModuleTransaction, MultisigTransaction,
};
use crate::common::models::backend::transfers::Transfer;
use crate::utils::hex_hash;

#[test]
fn multisig_transaction_id() {
    let multisig_tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_WITH_ORIGIN)
            .unwrap();

    let expected = "multisig_0xBc79855178842FDBA0c353494895DEEf509E26bB_0x728e6dec56dc61523b56dc440e34c1c4c39c66895df8e5d3499ed1f7d4fcfe80";
    let actual = multisig_tx.generate_id();

    assert_eq!(expected, actual);
}

#[test]
fn ethereum_transaction_id() {
    let ethereum_tx = serde_json::from_str::<EthereumTransaction>(
        crate::tests::json::ETHEREUM_TX_INCONSISTENT_TOKEN_TYPES,
    )
    .unwrap();

    let transfer_hash = hex_hash(ethereum_tx.transfers.as_ref().unwrap().first().unwrap());

    let expected = format!("ethereum_0xb07de4b2989E180F8907B8C7e617637C26cE2776_0x2f920d8b75eff1857266643aedcfcf677b834ca164b6684a23a2c8e4574432ec_{}", &transfer_hash);
    let actual =
        ethereum_tx.generate_id("0xb07de4b2989E180F8907B8C7e617637C26cE2776", &transfer_hash);

    assert_eq!(expected, actual);
}

#[test]
fn module_transaction_id() {
    let module_tx =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX).unwrap();

    let module_tx_hash = hex_hash(&module_tx);

    let expected = format!("module_0x9422ff6AFB126C31F62057e2853d65cBB73f4608_0x705167e310ef0acb80a5f73eb4f8e66cfb32a896ac9380f3eb43e68ef8603a9f_{}", module_tx_hash);
    let actual = module_tx.generate_id();

    assert_eq!(expected, actual);
}

#[test]
fn transfer_transaction_id() {
    let transfer =
        serde_json::from_str::<Transfer>(crate::tests::json::ETHER_TRANSFER_INCOMING).unwrap();

    let transfer_hash = hex_hash(&transfer);
    let eth_tx_hash = "some_valid_tx_hash";

    let expected = format!(
        "ethereum_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_{}_{}",
        &eth_tx_hash, &transfer_hash
    );
    let actual = transfer.generate_id("0x1230B3d59858296A31053C1b8562Ecf89A2f888b", &eth_tx_hash);

    assert_eq!(expected, actual);
}

#[test]
fn creation_transaction_id() {
    let creation_tx =
        serde_json::from_str::<CreationTransaction>(crate::tests::json::CREATION_TX).unwrap();

    let safe_address = "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67";

    let expected = format!("creation_{}", safe_address);
    let actual = creation_tx.generate_id(safe_address);

    assert_eq!(expected, actual);
}

'''
'''--- src/routes/transactions/converters/tests/transaction_types.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::{ModuleTransaction, MultisigTransaction};
use crate::common::models::data_decoded::ParamValue::SingleValue;
use crate::common::models::data_decoded::{DataDecoded, Parameter};
use crate::providers::info::*;
use crate::routes::transactions::models::{
    Custom, Erc20Transfer, Erc721Transfer, NativeCoinTransfer, SettingsChange, SettingsInfo,
    TransactionInfo, Transfer, TransferDirection, TransferInfo,
};

#[rocket::async_test]
async fn transaction_operation_not_call() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC20_TRANSFER_DELEGATE,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
        data_size: "68".to_string(),
        value: "0".to_string(),
        method_name: Some("transfer".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_size_and_value_greater_than_0() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC20_TRANSFER_WITH_VALUE,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
        data_size: "68".to_string(),
        value: "100000000000000000".to_string(),
        method_name: Some("transfer".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_size_and_value_greater_than_0_with_address_info() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |address| {
            Ok(AddressEx {
                value: address.to_string(),
                name: Some("".to_string()),
                logo_uri: None,
            })
        });

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC20_TRANSFER_WITH_VALUE,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx {
            value: "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02".to_string(),
            name: Some("".to_string()),
            logo_uri: None,
        },
        data_size: "68".to_string(),
        value: "100000000000000000".to_string(),
        method_name: Some("transfer".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_size_0_value_greater_than_0() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_ETHER_TRANSFER)
            .unwrap();
    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::NativeCoin(NativeCoinTransfer {
            value: "100000000000000000".to_string(),
        }),
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn module_transaction_data_size_0_value_greater_than_0() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX_ETHER_TRANSFER)
            .unwrap();
    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::NativeCoin(NativeCoinTransfer {
            value: "100000000000000000".to_string(),
        }),
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_size_greater_than_value_0_to_is_safe_is_settings_method() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(0);

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_SETTINGS_CHANGE,
    )
    .unwrap();
    let expected = TransactionInfo::SettingsChange(SettingsChange {
        settings_info: Some(SettingsInfo::AddOwner {
            owner: AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
            threshold: 2,
        }),
        data_decoded: DataDecoded {
            method: "addOwnerWithThreshold".to_string(),
            parameters: Some(vec![
                Parameter {
                    name: "owner".to_string(),
                    param_type: "address".to_string(),
                    value: SingleValue("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D".to_string()),
                    value_decoded: None,
                },
                Parameter {
                    name: "_threshold".to_string(),
                    param_type: "uint256".to_string(),
                    value: SingleValue("2".to_string()),
                    value_decoded: None,
                },
            ]),
        },
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_size_greater_than_value_0_to_is_safe_is_settings_method_with_address_info(
) {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(0);

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_SETTINGS_CHANGE,
    )
    .unwrap();
    let expected = TransactionInfo::SettingsChange(SettingsChange {
        settings_info: Some(SettingsInfo::AddOwner {
            owner: AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
            threshold: 2,
        }),
        data_decoded: DataDecoded {
            method: "addOwnerWithThreshold".to_string(),
            parameters: Some(vec![
                Parameter {
                    name: "owner".to_string(),
                    param_type: "address".to_string(),
                    value: SingleValue("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D".to_string()),
                    value_decoded: None,
                },
                Parameter {
                    name: "_threshold".to_string(),
                    param_type: "uint256".to_string(),
                    value: SingleValue("2".to_string()),
                    value_decoded: None,
                },
            ]),
        },
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn module_transaction_data_size_greater_than_value_0_to_is_safe_is_settings_method_with_address_info(
) {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    // We do not expect any address info loading as it is a call to the Safe itself
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(0);

    let tx =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX_SETTINGS_CHANGE)
            .unwrap();
    let expected = TransactionInfo::SettingsChange(SettingsChange {
        settings_info: Some(SettingsInfo::AddOwner {
            owner: AddressEx::address_only("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"),
            threshold: 2,
        }),
        data_decoded: DataDecoded {
            method: "addOwnerWithThreshold".to_string(),
            parameters: Some(vec![
                Parameter {
                    name: "owner".to_string(),
                    param_type: "address".to_string(),
                    value: SingleValue("0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D".to_string()),
                    value_decoded: None,
                },
                Parameter {
                    name: "_threshold".to_string(),
                    param_type: "uint256".to_string(),
                    value: SingleValue("2".to_string()),
                    value_decoded: None,
                },
            ]),
        },
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_size_greater_than_value_0_to_is_safe_is_not_settings_method() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    // We do not expect any address info loading as it is a call to the Safe itself
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(0);

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_UNKNOWN_SETTINGS_CHANGE,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        data_size: "68".to_string(),
        value: "0".to_string(),
        method_name: Some("newAndDifferentAddOwnerWithThreshold".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn module_transaction_data_size_greater_than_value_0_to_is_safe_is_not_settings_method() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    // We do not expect any address info loading as it is a call to the Safe itself
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(0);

    let tx = serde_json::from_str::<ModuleTransaction>(
        crate::tests::json::MODULE_TX_UNKNOWN_SETTINGS_CHANGE,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        data_size: "68".to_string(),
        value: "0".to_string(),
        method_name: Some("newAndDifferentAddOwnerWithThreshold".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_decoded_is_erc20_receiver_ok_transfer_method() {
    let token_info = serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_USDT).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_ERC20_TRANSFER)
            .unwrap();
    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc20(
            Erc20Transfer {
                token_address: "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02".to_string(),
                token_name: Some("Compound USDT".to_string()),
                token_symbol: Some("USDT".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png".to_string()),
                decimals: Some(18),
                value: "50000000000000".to_string(),
            }),
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn module_transaction_data_decoded_is_erc20_receiver_ok_transfer_method() {
    let token_info = serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_USDT).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX_ERC20_TRANSFER)
            .unwrap();
    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc20(
            Erc20Transfer {
                token_address: "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02".to_string(),
                token_name: Some("Compound USDT".to_string()),
                token_symbol: Some("USDT".to_string()),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png".to_string()),
                decimals: Some(18),
                value: "100000000000000".to_string(),
            }),
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_decoded_is_erc721_receiver_ok_transfer_method() {
    let token_info =
        serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_CRYPTO_KITTIES).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC721_TRANSFER,
    )
    .unwrap();
    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc721(Erc721Transfer {
            token_address: "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF".to_string(),
            token_id: "1316".to_string(),
            token_name: Some("CryptoKitties".to_string()),
            token_symbol: Some("CK".to_string()),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png".to_string()),
        }),
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn module_transaction_data_decoded_is_erc721_receiver_ok_transfer_method() {
    let token_info =
        serde_json::from_str::<TokenInfo>(crate::tests::json::TOKEN_CRYPTO_KITTIES).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx =
        serde_json::from_str::<ModuleTransaction>(crate::tests::json::MODULE_TX_ERC721_TRANSFER)
            .unwrap();
    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
        recipient: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc721(Erc721Transfer {
            token_address: "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF".to_string(),
            token_id: "1316".to_string(),
            token_name: Some("CryptoKitties".to_string()),
            token_symbol: Some("CK".to_string()),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png".to_string()),
        }),
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_decoded_is_erc20_receiver_not_ok_transfer_method() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("no address info"));

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC20_TRANSFER_INVALID_TO_AND_FROM,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
        data_size: "68".to_string(),
        value: "0".to_string(),
        method_name: Some("transferFrom".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_decoded_is_erc721_receiver_not_ok_transfer_method() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC721_TRANSFER_INVALID_TO_AND_FROM,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF"),
        data_size: "68".to_string(),
        value: "0".to_string(),
        method_name: Some("safeTransferFrom".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_decoded_is_transfer_method_receiver_ok_token_type_unknown() {
    let token_info = TokenInfo {
        token_type: TokenType::Unknown,
        address: "".to_string(),
        decimals: 0,
        symbol: "".to_string(),
        name: "".to_string(),
        logo_uri: None,
    };
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC721_TRANSFER,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF"),
        data_size: "68".to_string(),
        value: "0".to_string(),
        method_name: Some("transfer".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_decoded_is_erc20_receiver_ok_token_fetch_error() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::MULTISIG_TX_ERC721_TRANSFER,
    )
    .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF"),
        data_size: "68".to_string(),
        value: "0".to_string(),
        method_name: Some("transfer".to_string()),
        action_count: None,
        is_cancellation: false,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn transaction_data_decoded_is_erc20_unexpected_parameter_names() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| {
            Ok(TokenInfo {
                token_type: TokenType::Erc20,
                address: "0xc778417E063141139Fce010982780140Aa0cD5Ab".to_string(),
                decimals: 18,
                symbol: "WETH".to_string(),
                name: "Wrapped Ether".to_string(),
                logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xc778417E063141139Fce010982780140Aa0cD5Ab.png".to_string()),
            })
        });

    let tx = serde_json::from_str::<MultisigTransaction>(
        crate::tests::json::ERC_20_TRANSFER_UNEXPECTED_PARAM_NAMES,
    )
    .unwrap();
    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only("0x1C8b9B78e3085866521FE206fa4c1a67F49f153A"),
        recipient: AddressEx::address_only("0x1C8b9B78e3085866521FE206fa4c1a67F49f153A"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc20(Erc20Transfer {
            token_address: "0xc778417E063141139Fce010982780140Aa0cD5Ab".to_string(),
            token_name: Some("Wrapped Ether".to_string()),
            token_symbol: Some("WETH".to_string()),
            logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xc778417E063141139Fce010982780140Aa0cD5Ab.png".to_string()),
            decimals: Some(18),
            value: "10000000000000000".to_string(),
        }),
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn cancellation_transaction() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    // We do not expect any address info loading as it is a call to the Safe itself
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(0);

    let tx =
        serde_json::from_str::<MultisigTransaction>(crate::tests::json::MULTISIG_TX_CANCELLATION)
            .unwrap();
    let expected = TransactionInfo::Custom(Custom {
        to: AddressEx::address_only("0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67"),
        data_size: "0".to_string(),
        value: "0".to_string(),
        method_name: None,
        action_count: None,
        is_cancellation: true,
    });

    let actual = tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

'''
'''--- src/routes/transactions/converters/tests/transfer_type_checks.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::{
    Confirmation, MultisigTransaction, SafeTransaction,
};
use crate::common::models::data_decoded::{DataDecoded, Operation, Parameter};
use crate::providers::info::*;
use crate::routes::transactions::models::{
    Erc20Transfer, Erc721Transfer, NativeCoinTransfer, TransactionInfo, Transfer,
    TransferDirection, TransferInfo,
};
use chrono::Utc;

#[rocket::async_test]
async fn multisig_tx_check_erc721_transfer() {
    let token_info = TokenInfo {
        token_type: TokenType::Erc721,
        address: String::from("0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF"),
        name: String::from("CryptoKitties"),
        symbol: String::from("CK"),
        decimals: 0,
        logo_uri: Some(String::from("https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png")),
    };
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected_date = Utc::now();
    let safe = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let to = String::from("0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF");
    let multisig_tx = MultisigTransaction {
        safe_transaction: SafeTransaction {
            safe: safe.to_string(),
            to,
            value: Some(String::from("0")),
            data: Some(String::from("0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e76443000000000000000000000000000000000000000000000000000000000000000466")),
            data_decoded: Some(DataDecoded {
                method: String::from("transfer"),
                parameters: Some(vec!(
                    Parameter { name: String::from("to"), param_type: String::from("address"), value: String::from("0x938bae50a210b80EA233112800Cd5Bc2e7644300").into(), value_decoded: None },
                    Parameter { name: String::from("value"), param_type: String::from("uint256"), value: String::from("1126").into(), value_decoded: None },
                )),
            }),
            operation: Operation::CALL,
        },
        gas_token: Some(String::from("0x0000000000000000000000000000000000000000")),
        safe_tx_gas: Some(47810),
        base_gas: Some(0),
        gas_price: Some(String::from("0")),
        refund_receiver: Some(String::from("0x0000000000000000000000000000000000000000")),
        nonce: 175,
        execution_date: Some(expected_date),
        submission_date: expected_date,
        modified: Some(expected_date),
        block_number: Some(6954173),
        transaction_hash: Some(String::from("0xc76ee22b0ab2785c5c8e93d029acf5643a8fccabcc3f223704bdbfc2af8193ae")),
        safe_tx_hash: String::from("0xcddc60c644e85ee3bff84204380a86578d3b62f8dd05a86de40e7e662012caf5"),
        executor: Some(String::from("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd")),
        is_executed: true,
        is_successful: Some(true),
        eth_gas_price: Some(String::from("1000000000")),
        gas_used: Some(80507),
        fee: Some(String::from("80507000000000")),
        origin: None,
        confirmations_required: Some(3),
        confirmations: Some(vec!(
            Confirmation {
                owner: String::from("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
                submission_date: expected_date,
                transaction_hash: None,
                signature_type: String::from("EOA"),
                signature: Some(String::from("0x6722a6772c15dd72851593c69e521729be5f6e86cbe6881498885b6efb02f6a61638976cf12bb113d8a1f7cea776e9d5c4949dde7d8015ca03e433acc6f9435b1b")),
            },
            Confirmation {
                owner: String::from("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
                submission_date: expected_date,
                transaction_hash: None,
                signature_type: String::from("EOA"),
                signature: Some(String::from("0x75aa624315ed8a72e1fcf396fe8d7a50d6d71f18c3b6bddb025bf426b7e4de3f52ead25cef15c9b35feaeefb2b81f2b5333ed949035f948fbe0a9aec56f7ac5b1b")),
            },
            Confirmation {
                owner: String::from("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
                submission_date: expected_date,
                transaction_hash: None,
                signature_type: String::from("EOA"),
                signature: Some(String::from("0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001")),
            },
        )),
        signatures: Some(String::from("0x6722a6772c15dd72851593c69e521729be5f6e86cbe6881498885b6efb02f6a61638976cf12bb113d8a1f7cea776e9d5c4949dde7d8015ca03e433acc6f9435b1b75aa624315ed8a72e1fcf396fe8d7a50d6d71f18c3b6bddb025bf426b7e4de3f52ead25cef15c9b35feaeefb2b81f2b5333ed949035f948fbe0a9aec56f7ac5b1b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001")),
        trusted: false,
    };

    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only(safe),
        recipient: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc721(Erc721Transfer {
            token_address: "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF".to_string(),
            token_id: "1126".to_string(),
            token_name: Some(String::from("CryptoKitties")),
            token_symbol: Some(String::from("CK")),
            logo_uri: Some(String::from("https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png")),
        }),
    });

    let actual = multisig_tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn multisig_tx_check_erc20_transfer() {
    let token_info = TokenInfo {
        token_type: TokenType::Erc20,
        address: String::from("0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85"),
        name: String::from("Maker"),
        symbol: String::from("MKR"),
        decimals: 18,
        logo_uri: Some(String::from("https://gnosis-safe-token-logos.s3.amazonaws.com/0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85.png")),
    };
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_token_info()
        .times(1)
        .return_once(move |_| Ok(token_info));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected_date = Utc::now();
    let safe = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let to = String::from("0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85");
    let multisig_tx = MultisigTransaction {
        safe_transaction: SafeTransaction {
            safe: safe.to_string(),
            to,
            value: Some(String::from("0")),
            data: Some(String::from("0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000002d79883d2000")),
            data_decoded: Some(DataDecoded {
                method: String::from("transfer"),
                parameters: Some(vec!(
                    Parameter { name: String::from("to"), param_type: String::from("address"), value: String::from("0x938bae50a210b80EA233112800Cd5Bc2e7644300").into(), value_decoded: None },
                    Parameter { name: String::from("value"), param_type: String::from("uint256"), value: String::from("50000000000000").into(), value_decoded: None },
                )),
            }),
            operation: Operation::CALL,
        },
        gas_token: Some(String::from("0x0000000000000000000000000000000000000000")),
        safe_tx_gas: Some(36698),
        base_gas: Some(0),
        gas_price: Some(String::from("0")),
        refund_receiver: Some(String::from("0x0000000000000000000000000000000000000000")),
        nonce: 174,
        execution_date: Some(expected_date),
        submission_date: expected_date,
        modified: Some(expected_date),
        block_number: Some(6953959),
        transaction_hash: Some(String::from("0x8bdce717cbf13200180e418138cbf7325642fa8ff715c7a262328853b7792271")),
        safe_tx_hash: String::from("0xf94fc3d3607845b3e04e2c6ae51802ffe2b4d39dd9b3159a8d9d9e31a05b5beb"),
        executor: Some(String::from("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0")),
        is_executed: true,
        is_successful: Some(true),
        eth_gas_price: Some(String::from("1000000000")),
        gas_used: Some(69431),
        fee: Some(String::from("69431000000000")),
        origin: None,
        confirmations_required: Some(3),
        confirmations: Some(vec!(
            Confirmation {
                owner: String::from("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
                submission_date: expected_date,
                transaction_hash: None,
                signature_type: String::from("EOA"),
                signature: Some(String::from("0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b0000000000000000000000000000000000000000000000000000000000000000001")),
            },
            Confirmation {
                owner: String::from("0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"),
                submission_date: expected_date,
                transaction_hash: None,
                signature_type: String::from("EOA"),
                signature: Some(String::from("0xccbf629ad44c41c39e397d4c3c199593be908edf57d728204c2ebd5f384ad5c90f1e7fca86dab291e406724b99d7d956acaa01cb78d146e410a7accd1ffe0df01b")),
            },
            Confirmation {
                owner: String::from("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
                submission_date: expected_date,
                transaction_hash: None,
                signature_type: String::from("EOA"),
                signature: Some(String::from("0x9b3733a7018e90ca4ebb1504e1c230260f8d41d0542180e915fa10af694f18b360f5fe6c9dc252e257b3d45071b32977224122165ff771a018a392bb62dbf1491b")),
            },
        )),
        signatures: Some(String::from("0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b0000000000000000000000000000000000000000000000000000000000000000001ccbf629ad44c41c39e397d4c3c199593be908edf57d728204c2ebd5f384ad5c90f1e7fca86dab291e406724b99d7d956acaa01cb78d146e410a7accd1ffe0df01b9b3733a7018e90ca4ebb1504e1c230260f8d41d0542180e915fa10af694f18b360f5fe6c9dc252e257b3d45071b32977224122165ff771a018a392bb62dbf1491b")),
        trusted: false,
    };

    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only(safe),
        recipient: AddressEx::address_only("0x938bae50a210b80EA233112800Cd5Bc2e7644300"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::Erc20(Erc20Transfer {
            token_address: "0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85".to_string(),
            token_name: Some(String::from("Maker")),
            token_symbol: Some(String::from("MKR")),
            logo_uri: Some(String::from("https://gnosis-safe-token-logos.s3.amazonaws.com/0xF9bA5210F91D0474bd1e1DcDAeC4C58E359AaD85.png")),
            decimals: Some(18),
            value: "50000000000000".to_string(),
        }),
    });

    let actual = multisig_tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn multisig_tx_check_ether_transfer() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let expected_date = Utc::now();
    let safe = "0x938bae50a210b80EA233112800Cd5Bc2e7644300";
    let to = String::from("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0");
    let multisig_tx = MultisigTransaction {
        safe_transaction: SafeTransaction {
            safe: safe.to_string(),
            to,
            value: Some(String::from("50000000000000")),
            data: None,
            data_decoded: None,
            operation: Operation::CALL,
        },
        gas_token: Some(String::from("0x0000000000000000000000000000000000000000")),
        safe_tx_gas: Some(27845),
        base_gas: Some(0),
        gas_price: Some(String::from("0")),
        refund_receiver: Some(String::from("0x0000000000000000000000000000000000000000")),
        nonce: 47,
        execution_date: Some(expected_date),
        submission_date: expected_date,
        modified: Some(expected_date),
        block_number: Some(6971215),
        transaction_hash: Some(String::from("0x26aa6abf9d8945d108f7c45e833f4d5b506a1cf3251d3feec2161bcb5f9fe62a")),
        safe_tx_hash: String::from("0xc09dd34d20c4edbce12b18a5fd49a075c95fd5dc95235321689d903487854129"),
        executor: Some(String::from("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd")),
        is_executed: true,
        is_successful: Some(true),
        eth_gas_price: Some(String::from("1000000000")),
        gas_used: Some(69431),
        fee: Some(String::from("53493000000000")),
        origin: None,
        confirmations_required: Some(2),
        confirmations: Some(vec!(
            Confirmation {
                owner: String::from("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
                submission_date: expected_date,
                transaction_hash: None,
                signature_type: String::from("EOA"),
                signature: Some(String::from("0x8b841f4b1b24c4db687bed9d9754253f94cd543d05447b31d32d945be6967a636a454fb210e058f783115c84fd141adf0e8d2fedb17df19419858cbb03fdddb31c")),
            },
            Confirmation {
                owner: String::from("0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"),
                submission_date: expected_date,
                transaction_hash: None,
                signature_type: String::from("APPROVED_HASH"),
                signature: Some(String::from("0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001")),
            },
        )),
        signatures: Some(String::from("0x8b841f4b1b24c4db687bed9d9754253f94cd543d05447b31d32d945be6967a636a454fb210e058f783115c84fd141adf0e8d2fedb17df19419858cbb03fdddb31c000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001")),
        trusted: false,
    };

    let expected = TransactionInfo::Transfer(Transfer {
        sender: AddressEx::address_only(safe),
        recipient: AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"),
        direction: TransferDirection::Outgoing,
        transfer_info: TransferInfo::NativeCoin(NativeCoinTransfer {
            value: "50000000000000".to_string(),
        }),
    });

    let actual = multisig_tx.transaction_info(&mut mock_info_provider).await;

    assert_eq!(expected, actual);
}

'''
'''--- src/routes/transactions/converters/transaction_id.rs ---
use crate::common::models::backend::transactions::{
    CreationTransaction, EthereumTransaction, ModuleTransaction, MultisigTransaction,
};
use crate::common::models::backend::transfers::Transfer;
use crate::utils::hex_hash;

impl MultisigTransaction {
    pub fn generate_id(&self) -> String {
        create_id!(
            super::super::models::ID_PREFIX_MULTISIG_TX,
            &self.safe_transaction.safe,
            self.safe_tx_hash
        )
    }
}

impl EthereumTransaction {
    pub fn generate_id(&self, safe_address: &str, transfer_hash: &str) -> String {
        create_id!(
            super::super::models::ID_PREFIX_ETHEREUM_TX,
            safe_address,
            self.tx_hash,
            transfer_hash
        )
    }
}

impl ModuleTransaction {
    pub fn generate_id(&self) -> String {
        create_id!(
            super::super::models::ID_PREFIX_MODULE_TX,
            self.safe_transaction.safe,
            self.transaction_hash,
            hex_hash(self)
        )
    }
}

impl Transfer {
    pub fn generate_id(&self, safe_address: &str, tx_hash: &str) -> String {
        create_id!(
            super::super::models::ID_PREFIX_ETHEREUM_TX,
            safe_address,
            tx_hash,
            hex_hash(self)
        )
    }
}

impl CreationTransaction {
    pub fn generate_id(&self, safe_address: &str) -> String {
        create_id!(super::super::models::ID_PREFIX_CREATION_TX, safe_address)
    }
}

'''
'''--- src/routes/transactions/filters/mod.rs ---
pub mod module;
pub mod multisig;
pub mod transfer;

#[cfg(test)]
mod tests;

pub trait QueryParam {
    fn as_query_param(&self) -> String;
}

'''
'''--- src/routes/transactions/filters/module.rs ---
use super::QueryParam;
use rocket::form::FromForm;
use rocket::http::uri::fmt::{Formatter, FromUriParam, Query, UriDisplay};
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use std::fmt;

#[derive(FromForm, Debug, JsonSchema)]
pub struct ModuleFilters {
    pub to: Option<String>,
    pub module: Option<String>,
}

impl QueryParam for ModuleFilters {
    fn as_query_param(&self) -> String {
        let mut query_params = String::new();

        if let Some(to) = &self.to {
            query_params.push_str(&format!("to={}&", to))
        }

        if let Some(module) = &self.module {
            query_params.push_str(&format!("module={}&", module))
        }

        return query_params;
    }
}

impl FromUriParam<Query, (Option<String>, Option<String>)> for ModuleFilters {
    type Target = ModuleFilters;

    fn from_uri_param((to, module): (Option<String>, Option<String>)) -> Self::Target {
        ModuleFilters { to, module }
    }
}

impl UriDisplay<Query> for ModuleFilters {
    fn fmt(&self, f: &mut Formatter<Query>) -> fmt::Result {
        f.write_named_value("to", &self.to)?;
        f.write_named_value("module", &self.module)
    }
}

'''
'''--- src/routes/transactions/filters/multisig.rs ---
use super::QueryParam;
use rocket::form::FromForm;
use rocket::http::uri::fmt::{Formatter, FromUriParam, Query, UriDisplay};
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use std::fmt;

#[derive(FromForm, Debug, JsonSchema)]
pub struct MultisigFilters {
    #[field(name = "execution_date__gte")]
    pub execution_date_gte: Option<String>,
    #[field(name = "execution_date__lte")]
    pub execution_date_lte: Option<String>,
    pub to: Option<String>,
    pub value: Option<String>,
    pub nonce: Option<String>,
    pub executed: Option<String>,
}

impl QueryParam for MultisigFilters {
    fn as_query_param(&self) -> String {
        let mut query_params = String::new();

        if let Some(execution_date_gte) = &self.execution_date_gte {
            query_params.push_str(&format!("execution_date__gte={}&", execution_date_gte))
        }

        if let Some(execution_date_lte) = &self.execution_date_lte {
            query_params.push_str(&format!("execution_date__lte={}&", execution_date_lte))
        }

        if let Some(to) = &self.to {
            query_params.push_str(&format!("to={}&", to))
        }

        if let Some(value) = &self.value {
            query_params.push_str(&format!("value={}&", value))
        }

        if let Some(nonce) = &self.nonce {
            query_params.push_str(&format!("nonce={}&", nonce))
        }

        if let Some(executed) = &self.executed {
            query_params.push_str(&format!("executed={}&", executed))
        }

        return query_params;
    }
}

impl
    FromUriParam<
        Query,
        (
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
        ),
    > for MultisigFilters
{
    type Target = MultisigFilters;

    fn from_uri_param(
        (execution_date_gte, execution_date_lte, to, value, nonce, executed): (
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
        ),
    ) -> Self::Target {
        MultisigFilters {
            execution_date_gte,
            execution_date_lte,
            to,
            value,
            nonce,
            executed,
        }
    }
}

impl UriDisplay<Query> for MultisigFilters {
    fn fmt(&self, f: &mut Formatter<Query>) -> fmt::Result {
        f.write_named_value("execution_date__gte", &self.execution_date_gte)?;
        f.write_named_value("execution_date__lte", &self.execution_date_lte)?;
        f.write_named_value("to", &self.to)?;
        f.write_named_value("value", &self.value)?;
        f.write_named_value("nonce", &self.nonce)?;
        f.write_named_value("executed", &self.executed)
    }
}

'''
'''--- src/routes/transactions/filters/tests/mod.rs ---
use crate::routes::transactions::filters::multisig::MultisigFilters;
use crate::routes::transactions::filters::QueryParam;

use super::module::ModuleFilters;
use super::transfer::TransferFilters;

#[test]
pub fn transfer_filters() {
    let filter_all_defined = TransferFilters {
        execution_date_gte: Some(String::from("1234")),
        execution_date_lte: Some(String::from("4321")),
        to: Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b")),
        value: Some(String::from("100")),
        token_address: Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b")),
    };

    let filter_none = TransferFilters {
        execution_date_gte: None,
        execution_date_lte: None,
        to: None,
        value: None,
        token_address: None,
    };

    let filter_only_to = TransferFilters {
        execution_date_gte: None,
        execution_date_lte: None,
        to: Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b")),
        value: None,
        token_address: None,
    };

    assert_eq!(
        filter_all_defined.as_query_param(),
        "execution_date__gte=1234&\
        execution_date__lte=4321&\
    to=0x1230B3d59858296A31053C1b8562Ecf89A2f888b&\
    value=100&\
    token_address=0x1230B3d59858296A31053C1b8562Ecf89A2f888b&"
    );
    assert_eq!(filter_none.as_query_param(), "");
    assert_eq!(
        filter_only_to.as_query_param(),
        "to=0x1230B3d59858296A31053C1b8562Ecf89A2f888b&"
    );
}

#[test]
pub fn module_filters() {
    let filter_all_defined = ModuleFilters {
        to: Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b")),
        module: Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b")),
    };

    let filter_none = ModuleFilters {
        to: None,
        module: None,
    };

    let filter_only_to = ModuleFilters {
        to: Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b")),
        module: None,
    };
    assert_eq!(
        filter_all_defined.as_query_param(),
        "to=0x1230B3d59858296A31053C1b8562Ecf89A2f888b&\
    module=0x1230B3d59858296A31053C1b8562Ecf89A2f888b&"
    );
    assert_eq!(filter_none.as_query_param(), "");
    assert_eq!(
        filter_only_to.as_query_param(),
        "to=0x1230B3d59858296A31053C1b8562Ecf89A2f888b&"
    );
}

#[test]
pub fn multisig_filters() {
    let filter_all_defined = MultisigFilters {
        execution_date_gte: Some(String::from("1234")),
        execution_date_lte: Some(String::from("4321")),
        to: Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b")),
        value: Some(String::from("100")),
        nonce: Some(String::from("50")),
        executed: Some(String::from("true")),
    };

    let filter_none = MultisigFilters {
        execution_date_gte: None,
        execution_date_lte: None,
        to: None,
        value: None,
        nonce: None,
        executed: None,
    };

    let filter_only_to = MultisigFilters {
        execution_date_gte: None,
        execution_date_lte: None,
        to: Some(String::from("0x1230B3d59858296A31053C1b8562Ecf89A2f888b")),
        value: None,
        nonce: None,
        executed: None,
    };

    assert_eq!(
        filter_all_defined.as_query_param(),
        "execution_date__gte=1234&\
        execution_date__lte=4321&\
    to=0x1230B3d59858296A31053C1b8562Ecf89A2f888b&\
    value=100&\
    nonce=50&\
    executed=true&"
    );
    assert_eq!(filter_none.as_query_param(), "");
    assert_eq!(
        filter_only_to.as_query_param(),
        "to=0x1230B3d59858296A31053C1b8562Ecf89A2f888b&"
    );
}

'''
'''--- src/routes/transactions/filters/transfer.rs ---
use super::QueryParam;
use rocket::form::FromForm;
use rocket::http::uri::fmt::{Formatter, FromUriParam, Query, UriDisplay};
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use std::fmt;

#[derive(FromForm, Debug, JsonSchema)]
pub struct TransferFilters {
    #[field(name = "execution_date__gte")]
    pub execution_date_gte: Option<String>,
    #[field(name = "execution_date__lte")]
    pub execution_date_lte: Option<String>,
    pub to: Option<String>,
    pub value: Option<String>,
    pub token_address: Option<String>,
}

impl QueryParam for TransferFilters {
    fn as_query_param(&self) -> String {
        let mut query_params = String::new();

        if let Some(execution_date_gte) = &self.execution_date_gte {
            query_params.push_str(&format!("execution_date__gte={}&", execution_date_gte))
        }

        if let Some(execution_date_lte) = &self.execution_date_lte {
            query_params.push_str(&format!("execution_date__lte={}&", execution_date_lte))
        }

        if let Some(to) = &self.to {
            query_params.push_str(&format!("to={}&", to))
        }

        if let Some(value) = &self.value {
            query_params.push_str(&format!("value={}&", value))
        }

        if let Some(token_address) = &self.token_address {
            query_params.push_str(&format!("token_address={}&", token_address))
        }

        return query_params;
    }
}

impl
    FromUriParam<
        Query,
        (
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
        ),
    > for TransferFilters
{
    type Target = TransferFilters;

    fn from_uri_param(
        (execution_date_gte, execution_date_lte, to, value, token_address): (
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
            Option<String>,
        ),
    ) -> Self::Target {
        TransferFilters {
            execution_date_gte,
            execution_date_lte,
            to,
            value,
            token_address,
        }
    }
}

impl UriDisplay<Query> for TransferFilters {
    fn fmt(&self, f: &mut Formatter<Query>) -> fmt::Result {
        f.write_named_value("execution_date__gte", &self.execution_date_gte)?;
        f.write_named_value("execution_date__lte", &self.execution_date_lte)?;
        f.write_named_value("to", &self.to)?;
        f.write_named_value("token_address", &self.token_address)?;
        f.write_named_value("value", &self.value)
    }
}

'''
'''--- src/routes/transactions/handlers/commons.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::page::{Page, PageMetadata};
use crate::routes::transactions::filters::QueryParam;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use rocket::serde::DeserializeOwned;

pub async fn get_backend_page<D>(
    context: &RequestContext,
    chain_id: &str,
    url: &str,
    request_timeout: u64,
    page_meta: &PageMetadata,
    filters: &(impl QueryParam + std::fmt::Debug),
) -> ApiResult<Page<D>>
where
    D: DeserializeOwned,
{
    let mut full_url = String::from(url);
    full_url.push_str("?");
    full_url.push_str(&page_meta.to_url_string());

    let filters = filters.as_query_param();
    if !filters.is_empty() {
        full_url.push_str("&");
        full_url.push_str(&filters);
    }
    let body = RequestCached::new_from_context(full_url, context, ChainCache::from(chain_id))
        .request_timeout(request_timeout)
        .execute()
        .await?;
    let object = serde_json::from_str::<Page<D>>(&body)?;
    Ok(object)
}

'''
'''--- src/routes/transactions/handlers/details.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::common::models::backend::transactions::{ModuleTransaction, MultisigTransaction};
use crate::common::models::backend::transfers::Transfer;
use crate::common::models::page::Page;
use crate::config::transaction_request_timeout;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::transactions::models::details::TransactionDetails;
use crate::routes::transactions::models::{TransactionIdParts, ID_SEPARATOR};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::hex_hash;
use crate::utils::transactions::fetch_rejections;
use log::debug;

pub async fn get_multisig_transaction_details(
    info_provider: &(impl InfoProvider + Sync),
    chain_id: &str,
    safe_tx_hash: &str,
) -> ApiResult<TransactionDetails> {
    let url = core_uri!(info_provider, "/v1/multisig-transactions/{}/", safe_tx_hash)?;
    let body = RequestCached::new(url, &info_provider.client(), &info_provider.cache())
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;
    let multisig_tx: MultisigTransaction = serde_json::from_str(&body)?;

    let rejections = fetch_rejections(
        info_provider,
        chain_id,
        &multisig_tx.safe_transaction.safe,
        multisig_tx.nonce,
    )
    .await;

    let details = multisig_tx
        .to_transaction_details(rejections, info_provider)
        .await?;
    Ok(details)
}

async fn get_ethereum_transaction_details(
    info_provider: &(impl InfoProvider + Sync),
    safe: &str,
    tx_hash: &str,
    detail_hash: &str,
) -> ApiResult<TransactionDetails> {
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/transfers/?transaction_hash={}&limit=1000",
        safe,
        tx_hash
    )?;
    debug!("url: {}", url);
    let body = RequestCached::new(url, &info_provider.client(), &info_provider.cache())
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;
    let transfers: Page<Transfer> = serde_json::from_str(&body)?;
    let transfer = transfers
        .results
        .into_iter()
        .find(|transfer| {
            debug!("expected: {}", detail_hash);
            debug!("actual: {}", hex_hash(transfer));
            hex_hash(transfer) == detail_hash
        })
        .ok_or(api_error!("No transfer found"))?;
    let details = transfer
        .to_transaction_details(info_provider, &safe.to_owned(), tx_hash)
        .await?;

    Ok(details)
}

async fn get_module_transaction_details(
    info_provider: &(impl InfoProvider + Sync),
    safe_address: &str,
    safe_tx_hash: &str,
    detail_hash: &str,
) -> ApiResult<TransactionDetails> {
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/module-transactions/?transaction_hash={}&limit=1000",
        safe_address,
        safe_tx_hash
    )?;

    debug!("url: {}", url);
    let body = RequestCached::new(url, &info_provider.client(), &info_provider.cache())
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;
    let transactions: Page<ModuleTransaction> = serde_json::from_str(&body)?;
    let transaction = transactions
        .results
        .into_iter()
        .find(|tx| hex_hash(tx) == detail_hash)
        .ok_or(api_error!("No transfer found"))?;
    let details = transaction.to_transaction_details(info_provider).await?;

    Ok(details)
}

pub async fn get_transactions_details(
    context: &RequestContext,
    chain_id: &str,
    details_id: &String,
) -> ApiResult<TransactionDetails> {
    let id_parts = parse_id(details_id)?;
    let info_provider = DefaultInfoProvider::new(chain_id, context);

    match id_parts {
        TransactionIdParts::Ethereum {
            safe_address,
            transaction_hash,
            details_hash,
        } => {
            get_ethereum_transaction_details(
                &info_provider,
                &safe_address,
                &transaction_hash,
                &details_hash,
            )
            .await
        }
        TransactionIdParts::Module {
            safe_address,
            transaction_hash,
            details_hash,
        } => {
            get_module_transaction_details(
                &info_provider,
                &safe_address,
                &transaction_hash,
                &details_hash,
            )
            .await
        }
        TransactionIdParts::Multisig { safe_tx_hash, .. } => {
            get_multisig_transaction_details(&info_provider, chain_id, &safe_tx_hash).await
        }
        TransactionIdParts::TransactionHash(safe_tx_hash) => {
            get_multisig_transaction_details(&info_provider, chain_id, &safe_tx_hash).await
        }
        _ => Err(client_error!(422, "Bad transaction id")),
    }
}

pub(super) fn parse_id(details_id: &str) -> ApiResult<TransactionIdParts> {
    let id_parts: Vec<&str> = details_id.split(ID_SEPARATOR).collect();
    let tx_type = id_parts.get(0).ok_or(api_error!("Invalid id"))?;

    Ok(match tx_type.to_owned() {
        super::super::models::ID_PREFIX_MULTISIG_TX => TransactionIdParts::Multisig {
            safe_address: id_parts
                .get(1)
                .ok_or(client_error!(422, "No safe address provided"))?
                .to_string(),
            safe_tx_hash: id_parts
                .get(2)
                .ok_or(client_error!(422, "No safe tx hash provided"))?
                .to_string(),
        },
        super::super::models::ID_PREFIX_ETHEREUM_TX => TransactionIdParts::Ethereum {
            safe_address: id_parts
                .get(1)
                .ok_or(client_error!(422, "No safe address"))?
                .to_string(),
            transaction_hash: id_parts
                .get(2)
                .ok_or(client_error!(422, "No ethereum tx hash"))?
                .to_string(),
            details_hash: id_parts
                .get(3)
                .ok_or(client_error!(422, "No ethereum tx details hash"))?
                .to_string(),
        },
        super::super::models::ID_PREFIX_MODULE_TX => TransactionIdParts::Module {
            safe_address: id_parts
                .get(1)
                .ok_or(client_error!(422, "No safe address"))?
                .to_string(),
            transaction_hash: id_parts
                .get(2)
                .ok_or(client_error!(422, "No module tx hash"))?
                .to_string(),
            details_hash: id_parts
                .get(3)
                .ok_or(client_error!(422, "No module tx details hash"))?
                .to_string(),
        },
        super::super::models::ID_PREFIX_CREATION_TX => TransactionIdParts::Creation(
            id_parts
                .get(1)
                .ok_or(client_error!(422, "No safe address provided"))?
                .to_string(),
        ),
        &_ => TransactionIdParts::TransactionHash(tx_type.to_string()),
    })
}

'''
'''--- src/routes/transactions/handlers/history.rs ---
use chrono::{DateTime, Datelike, FixedOffset, NaiveDate, NaiveDateTime, Utc};
use itertools::Itertools;

use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::backend::transactions::{CreationTransaction, Transaction};
use crate::common::models::page::{Page, PageMetadata};
use crate::config::transaction_request_timeout;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::transactions::handlers::offset_page_meta;
use crate::routes::transactions::models::summary::{
    ConflictType, TransactionListItem, TransactionSummary,
};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::urls::build_absolute_uri;

pub async fn get_history_transactions(
    context: &RequestContext,
    chain_id: &String,
    safe_address: &String,
    cursor: &Option<String>,
    timezone_offset: &Option<String>,
) -> ApiResult<Page<TransactionListItem>> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    let request_timezone_offset = timezone_offset
        .as_ref()
        .and_then(|it| it.parse::<i32>().ok())
        .unwrap_or(0)
        / 1000;

    let incoming_page_metadata =
        PageMetadata::from_cursor(cursor.as_ref().unwrap_or(&"".to_string()));

    let page_metadata = adjust_page_meta(&incoming_page_metadata);
    let extended_page_cursor = Some(page_metadata.to_url_string());

    let backend_paged_txs = fetch_backend_paged_txs(
        context,
        &info_provider,
        safe_address,
        &extended_page_cursor,
        chain_id,
    )
    .await?;
    let mut backend_txs_iter = backend_paged_txs.results.into_iter();
    let prev_page_timestamp = if page_metadata.offset != 0 {
        peek_timestamp_and_remove_item(
            &mut backend_txs_iter,
            &info_provider,
            safe_address,
            request_timezone_offset,
        )
        .await
        .unwrap_or(-1)
    } else {
        -1
    };

    let mut service_txs =
        backend_txs_to_summary_txs(&mut backend_txs_iter, &info_provider, safe_address).await?;
    if backend_paged_txs.next.is_none() {
        if let Ok(creation_tx) =
            get_creation_transaction_summary(context, &info_provider, safe_address, chain_id).await
        {
            service_txs.push(creation_tx);
        }
    }

    let tx_list_items =
        service_txs_to_tx_list_items(service_txs, prev_page_timestamp, request_timezone_offset)?;

    Ok(Page {
        next: build_cursor(
            context,
            chain_id,
            safe_address,
            &incoming_page_metadata,
            timezone_offset,
            backend_paged_txs.next,
            1, // Direction forward
        ),
        previous: build_cursor(
            context,
            chain_id,
            safe_address,
            &incoming_page_metadata,
            timezone_offset,
            backend_paged_txs.previous,
            -1, // Direction backwards
        ),
        results: tx_list_items,
    })
}

fn build_cursor(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    page_meta: &PageMetadata,
    timezone_offset: &Option<String>,
    url: Option<String>,
    direction: i64,
) -> Option<String> {
    url.as_ref().map(|_| {
        build_absolute_uri(
            context,
            uri!(
                crate::routes::transactions::routes::get_transactions_history(
                    chain_id,
                    safe_address,
                    Some(offset_page_meta(
                        page_meta,
                        direction * (page_meta.limit as i64)
                    )),
                    Some(timezone_offset.clone().unwrap_or("0".to_string()))
                )
            ),
        )
    })
}

pub(super) fn adjust_page_meta(meta: &PageMetadata) -> PageMetadata {
    if meta.offset == 0 {
        PageMetadata {
            offset: 0,
            limit: meta.limit,
        }
    } else {
        PageMetadata {
            offset: meta.offset - 1,
            limit: meta.limit + 1,
        }
    }
}

async fn fetch_backend_paged_txs(
    context: &RequestContext,
    info_provider: &impl InfoProvider,
    safe_address: &str,
    cursor: &Option<String>,
    chain_id: &str,
) -> ApiResult<Page<Transaction>> {
    let page_metadata = PageMetadata::from_cursor(cursor.as_ref().unwrap_or(&"".to_string()));
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/all-transactions/?{}&queued=false&executed=true",
        safe_address,
        page_metadata.to_url_string()
    )?;
    log::debug!("request URL: {}", &url);
    log::debug!("cursor: {:#?}", &cursor);
    log::debug!("page_metadata: {:#?}", &page_metadata);
    let body = RequestCached::new_from_context(url, context, ChainCache::from(chain_id))
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;
    Ok(serde_json::from_str::<Page<Transaction>>(&body)?)
}

pub(super) async fn backend_txs_to_summary_txs(
    txs: &mut impl Iterator<Item = Transaction>,
    info_provider: &(impl InfoProvider + Sync),
    safe_address: &str,
) -> ApiResult<Vec<TransactionSummary>> {
    let mut results = vec![];

    for transaction in txs {
        results.extend(
            transaction
                .to_transaction_summary(info_provider, safe_address)
                .await
                .unwrap_or_default(),
        );
    }

    Ok(results)
}

pub(super) fn service_txs_to_tx_list_items(
    txs: Vec<TransactionSummary>,
    last_timestamp: i64,
    timezone_offset: i32,
) -> ApiResult<Vec<TransactionListItem>> {
    let mut tx_list_items = Vec::new();
    for (date_timestamp, transaction_group) in &txs
        .into_iter()
        .group_by(|transaction| get_day_timestamp_millis(transaction.timestamp, timezone_offset))
    {
        if date_timestamp != last_timestamp {
            tx_list_items.push(TransactionListItem::DateLabel {
                timestamp: date_timestamp,
            });
        }
        transaction_group.for_each(|tx| {
            tx_list_items.push(TransactionListItem::Transaction {
                transaction: tx,
                conflict_type: ConflictType::None,
            })
        });
    }
    Ok(tx_list_items)
}

pub(super) async fn peek_timestamp_and_remove_item(
    transactions: &mut impl Iterator<Item = Transaction>,
    info_provider: &(impl InfoProvider + Sync),
    safe_address: &str,
    timezone_offset: i32,
) -> ApiResult<i64> {
    let timestamp = transactions
        .next()
        .ok_or(api_error!("empty transactions"))?
        .to_transaction_summary(info_provider, safe_address)
        .await?
        .last()
        .ok_or(api_error!("empty transactions"))?
        .timestamp;

    Ok(get_day_timestamp_millis(timestamp, timezone_offset))
}

pub(super) fn get_day_timestamp_millis(timestamp_in_millis: i64, timezone_offset: i32) -> i64 {
    log::debug!("Timezone offset: {:#?}", timezone_offset);
    let date_time = DateTime::<Utc>::from_utc(
        NaiveDateTime::from_timestamp(timestamp_in_millis / 1000, 0),
        Utc,
    )
    .with_timezone(&FixedOffset::east(timezone_offset));

    // we remove the client's timezone offset of the day timestamp so we return the day timestamp at 00:00:00.0000
    // this is particularly important for negative timezone offset.
    let date =
        NaiveDate::from_ymd_opt(date_time.year(), date_time.month(), date_time.day()).unwrap();
    (date.and_hms_milli(0, 0, 0, 0).timestamp() - timezone_offset as i64) * 1000
}

pub(super) async fn get_creation_transaction_summary(
    context: &RequestContext,
    info_provider: &(impl InfoProvider + Sync),
    safe: &String,
    chain_id: &str,
) -> ApiResult<TransactionSummary> {
    let url = core_uri!(info_provider, "/v1/safes/{}/creation/", safe)?;
    debug!("{}", &url);
    let body = RequestCached::new_from_context(url, context, ChainCache::from(chain_id))
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;

    let creation_transaction_dto: CreationTransaction = serde_json::from_str(&body)?;
    let transaction_summary = creation_transaction_dto
        .to_transaction_summary(safe, info_provider)
        .await;
    Ok(transaction_summary)
}

'''
'''--- src/routes/transactions/handlers/mod.rs ---
use crate::common::models::page::PageMetadata;
use std::cmp::max;

pub mod commons;
pub mod details;
pub mod history;
pub mod module;
pub mod multisig;
pub mod preview;
pub mod proposal;
pub mod queued;
pub mod transfers;

#[cfg(test)]
mod tests;

pub(super) fn offset_page_meta(meta: &PageMetadata, offset: i64) -> String {
    PageMetadata {
        offset: (max(0, (meta.offset as i64) + offset)) as u64,
        limit: meta.limit,
    }
    .to_url_string()
}

'''
'''--- src/routes/transactions/handlers/module.rs ---
use super::commons::get_backend_page;
use crate::common::models::backend::transactions::ModuleTransaction;
use crate::common::models::page::{Page, PageMetadata};
use crate::config::transaction_request_timeout;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::transactions::filters::module::ModuleFilters;
use crate::routes::transactions::handlers::offset_page_meta;
use crate::routes::transactions::models::summary::{ConflictType, TransactionListItem};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::urls::build_absolute_uri;

pub async fn get_module_transactions(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    cursor: &Option<String>,
    filters: &ModuleFilters,
) -> ApiResult<Page<TransactionListItem>> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/module-transactions/",
        safe_address
    )?;

    let page_meta: PageMetadata =
        PageMetadata::from_cursor(cursor.as_ref().unwrap_or(&"".to_string()));

    let backend_txs = get_backend_page(
        &context,
        chain_id,
        &url,
        transaction_request_timeout(),
        &page_meta,
        filters,
    )
    .await?;
    let service_txs = backend_txs_to_summary_txs(
        &mut backend_txs.results.into_iter(),
        &info_provider,
        safe_address,
    )
    .await?;

    return Ok(Page {
        next: build_cursor(
            context,
            chain_id,
            safe_address,
            &page_meta,
            backend_txs.next,
            filters,
            1,
        ),
        previous: build_cursor(
            context,
            chain_id,
            safe_address,
            &page_meta,
            backend_txs.previous,
            filters,
            -1,
        ),
        results: service_txs,
    });
}

async fn backend_txs_to_summary_txs(
    transactions: &mut impl Iterator<Item = ModuleTransaction>,
    info_provider: &(impl InfoProvider + Sync),
    safe_address: &str,
) -> ApiResult<Vec<TransactionListItem>> {
    let mut results = vec![];
    for transaction in transactions {
        let tx_summary = transaction
            .to_transaction_summary(info_provider)
            .await
            .into_iter()
            .for_each(|tx_summary| {
                results.push(TransactionListItem::Transaction {
                    transaction: tx_summary,
                    conflict_type: ConflictType::None,
                });
            });
    }

    Ok(results)
}

fn build_cursor(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    page_meta: &PageMetadata,
    backend_page_url: Option<String>,
    filters: &ModuleFilters,
    direction: i64,
) -> Option<String> {
    backend_page_url.as_ref().map(|_| {
        let cursor = offset_page_meta(page_meta, direction * (page_meta.limit as i64));

        build_absolute_uri(
            context,
            uri!(
                crate::routes::transactions::routes::get_module_transactions(
                    chain_id = chain_id,
                    safe_address = safe_address,
                    cursor = Some(cursor),
                    filters = (filters.to.to_owned(), filters.module.to_owned())
                )
            ),
        )
    })
}

'''
'''--- src/routes/transactions/handlers/multisig.rs ---
use super::commons::get_backend_page;
use crate::common::models::backend::transactions::MultisigTransaction;
use crate::common::models::page::{Page, PageMetadata};
use crate::config::transaction_request_timeout;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::transactions::filters::multisig::MultisigFilters;
use crate::routes::transactions::handlers::offset_page_meta;
use crate::routes::transactions::models::summary::{ConflictType, TransactionListItem};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::urls::build_absolute_uri;

pub async fn get_multisig_transactions(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    cursor: &Option<String>,
    filters: &MultisigFilters,
) -> ApiResult<Page<TransactionListItem>> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/multisig-transactions/",
        safe_address
    )?;
    let page_meta: PageMetadata =
        PageMetadata::from_cursor(cursor.as_ref().unwrap_or(&"".to_string()));

    let backend_txs = get_backend_page(
        &context,
        chain_id,
        &url,
        transaction_request_timeout(),
        &page_meta,
        filters,
    )
    .await?;
    let service_txs = backend_txs_to_summary_txs(
        &mut backend_txs.results.into_iter(),
        &info_provider,
        safe_address,
    )
    .await?;

    return Ok(Page {
        next: build_cursor(
            context,
            chain_id,
            safe_address,
            &page_meta,
            backend_txs.next,
            filters,
            1,
        ),
        previous: build_cursor(
            context,
            chain_id,
            safe_address,
            &page_meta,
            backend_txs.previous,
            filters,
            -1,
        ),
        results: service_txs,
    });
}

async fn backend_txs_to_summary_txs(
    transactions: &mut impl Iterator<Item = MultisigTransaction>,
    info_provider: &(impl InfoProvider + Sync),
    safe_address: &str,
) -> ApiResult<Vec<TransactionListItem>> {
    let mut results = vec![];
    for transaction in transactions {
        let tx_summary = transaction
            .to_transaction_summary(info_provider)
            .await?
            .into_iter()
            .for_each(|tx_summary| {
                results.push(TransactionListItem::Transaction {
                    transaction: tx_summary,
                    conflict_type: ConflictType::None,
                });
            });
    }

    Ok(results)
}

fn build_cursor(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    page_meta: &PageMetadata,
    backend_page_url: Option<String>,
    filters: &MultisigFilters,
    direction: i64,
) -> Option<String> {
    backend_page_url.as_ref().map(|_| {
        let cursor = offset_page_meta(page_meta, direction * (page_meta.limit as i64));

        build_absolute_uri(
            context,
            uri!(
                crate::routes::transactions::routes::get_multisig_transactions(
                    chain_id = chain_id,
                    safe_address = safe_address,
                    cursor = Some(cursor),
                    filters = (
                        filters.execution_date_gte.to_owned(),
                        filters.execution_date_lte.to_owned(),
                        filters.to.to_owned(),
                        filters.value.to_owned(),
                        filters.nonce.to_owned(),
                        filters.executed.to_owned(),
                    )
                )
            ),
        )
    })
}

'''
'''--- src/routes/transactions/handlers/preview.rs ---
use std::collections::HashMap;

use rocket::futures::future::OptionFuture;
use serde::{Deserialize, Serialize};

use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::SafeTransaction;
use crate::common::models::data_decoded::{DataDecoded, Operation};
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::contracts::models::DataDecoderRequest;
use crate::routes::transactions::converters::details::is_trusted_delegate_call;
use crate::routes::transactions::models::details::TransactionData;
use crate::routes::transactions::models::TransactionInfo;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::Request;

#[derive(Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct TransactionPreviewRequest {
    to: String,
    data: Option<String>,
    value: String,
    operation: Operation,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(Deserialize))]
pub struct TransactionPreview {
    pub tx_info: TransactionInfo,
    pub tx_data: TransactionData,
}

pub async fn preview_transaction(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    preview_request: &TransactionPreviewRequest,
) -> ApiResult<TransactionPreview> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);

    // Get [AddressEx] for the [to] field
    let to_address_ex = info_provider
        .address_ex_from_contracts(&preview_request.to)
        .await
        .unwrap_or(AddressEx {
            value: preview_request.to.to_string(),
            name: None,
            logo_uri: None,
        });

    // Get [DataDecoded]
    let data_decoded: Option<DataDecoded> = match &preview_request.data {
        None => None,
        Some(data) => match decode_data(context, &info_provider, data, &preview_request.to).await {
            Err(_) => None,
            Ok(decoded_data) => Some(decoded_data),
        },
    };

    // We create a [SafeTransaction] so we can get the info out of it
    let safe_transaction = SafeTransaction {
        safe: safe_address.to_string(),
        to: preview_request.to.to_string(),
        value: Some(preview_request.value.to_string()),
        data: preview_request.data.clone(),
        data_decoded: data_decoded.clone(),
        operation: preview_request.operation,
    };
    let transaction_info: TransactionInfo = safe_transaction
        .transaction_info(&info_provider, false)
        .await;

    let is_trusted_delegate_call: Option<bool> = is_trusted_delegate_call(
        &safe_transaction.operation,
        &safe_transaction.to,
        &safe_transaction.data_decoded,
        &info_provider,
    )
    .await
    .unwrap_or(None);

    let address_info_index: Option<HashMap<String, AddressEx>> = OptionFuture::from(
        safe_transaction
            .data_decoded
            .as_ref()
            .map(|data_decoded| async move {
                data_decoded.build_address_info_index(&info_provider).await
            }),
    )
    .await
    .flatten();

    let transaction_data = TransactionData {
        hex_data: preview_request.data.clone(),
        data_decoded,
        to: to_address_ex,
        value: Some(preview_request.value.to_string()),
        operation: preview_request.operation,
        trusted_delegate_call_target: is_trusted_delegate_call,
        address_info_index,
    };

    Ok(TransactionPreview {
        tx_info: transaction_info,
        tx_data: transaction_data,
    })
}

async fn decode_data(
    context: &RequestContext,
    info_provider: &(impl InfoProvider + Sync),
    data: &str,
    to: &String,
) -> ApiResult<DataDecoded> {
    let data_decoder_endpoint = core_uri!(info_provider, "/v1/data-decoder/")?;
    let client = context.http_client();

    let request = {
        let mut request = Request::new(data_decoder_endpoint);
        let body = DataDecoderRequest {
            data: data.to_string(),
            to: Some(to.to_string()),
        };
        request.body(Some(serde_json::to_string(&body)?));
        request
    };
    let response_body = client.post(request).await?.body;
    Ok(serde_json::from_str::<DataDecoded>(&response_body)?)
}

'''
'''--- src/routes/transactions/handlers/proposal.rs ---
use crate::cache::cache_operations::{Invalidate, InvalidationPattern, InvalidationScope};
use crate::cache::manager::ChainCache;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::transactions::models::requests::MultisigTransactionRequest;
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::http_client::Request;
use serde_json::json;

// The transaction details are returned at the route level. The same as for transaction submission
pub async fn submit_confirmation(
    context: &RequestContext,
    chain_id: &str,
    safe_tx_hash: &str,
    signature: &str,
) -> ApiResult<()> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    let url = core_uri!(
        info_provider,
        "/v1/multisig-transactions/{}/confirmations/",
        &safe_tx_hash
    )?;

    let client = context.http_client();
    let request = {
        let mut request = Request::new(url);
        request.body(Some(json!({ "signature": signature }).to_string()));
        request
    };

    client.post(request).await?;
    Invalidate::new(
        InvalidationPattern::Any(InvalidationScope::Both, String::from(safe_tx_hash)),
        context.cache(ChainCache::from(chain_id)),
    )
    .execute()
    .await;

    Ok(())
}

pub async fn propose_transaction(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    transaction_request: &MultisigTransactionRequest,
) -> ApiResult<()> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/multisig-transactions/",
        &safe_address
    )?;

    let client = context.http_client();
    let request = {
        let mut request = Request::new(url);
        request.body(Some(serde_json::to_string(&transaction_request)?));
        request
    };
    client.post(request).await?;

    Invalidate::new(
        InvalidationPattern::Any(InvalidationScope::Both, String::from(safe_address)),
        context.cache(ChainCache::from(chain_id)),
    )
    .execute()
    .await;
    Invalidate::new(
        InvalidationPattern::Any(
            InvalidationScope::Both,
            String::from(&transaction_request.safe_tx_hash),
        ),
        context.cache(ChainCache::from(chain_id)),
    )
    .execute()
    .await;
    Ok(())
}

'''
'''--- src/routes/transactions/handlers/queued.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::cache::manager::ChainCache;
use crate::common::models::backend::transactions::MultisigTransaction;
use crate::common::models::page::{Page, PageMetadata};
use crate::config::transaction_request_timeout;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::transactions::handlers::offset_page_meta;
use crate::routes::transactions::models::summary::{ConflictType, Label, TransactionListItem};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::urls::build_absolute_uri;
use itertools::Itertools;
use std::collections::HashMap;

// use https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.peekable
pub async fn get_queued_transactions(
    context: &RequestContext,
    chain_id: &String,
    safe_address: &String,
    cursor: &Option<String>,
    timezone_offset: &Option<String>,
    trusted: &Option<bool>,
) -> ApiResult<Page<TransactionListItem>> {
    let mut info_provider = DefaultInfoProvider::new(chain_id, context);

    // Parse page meta (offset and limit)
    let page_meta = PageMetadata::from_cursor(cursor.as_ref().unwrap_or(&"".to_string()));
    // Adjust the page meta to fetch additional information of adjacent pages
    let adjusted_page_meta = adjust_page_meta(&page_meta);

    // Allow to also query queued transactions that are not submitted by an owner or delegate
    let display_trusted_only = trusted.unwrap_or(true);

    // As we require the Safe nonce later we use it here explicitely to query transaction that are in the future
    let safe_nonce = info_provider.safe_info(safe_address).await?.nonce as i64;
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/multisig-transactions/?{}&nonce__gte={}&ordering=nonce,submissionDate&trusted={}",
        safe_address,
        adjusted_page_meta.to_url_string(),
        safe_nonce,
        display_trusted_only
    )?;

    let body = RequestCached::new_from_context(url, context, ChainCache::from(chain_id.as_str()))
        .request_timeout(transaction_request_timeout())
        .execute()
        .await?;
    let mut backend_transactions: Page<MultisigTransaction> = serde_json::from_str(&body)?;

    // We need to do this before we create the iterator
    // Nonce of the first item in the next page (-1 if not present)
    let edge_nonce = get_edge_nonce(&mut backend_transactions);

    // Use an iterator to avoid shifting the result vector (would potentially trigger copies)
    let mut tx_iter = backend_transactions.results.into_iter();
    // Nonce of the last item in the previous page (-1 if not present)
    let previous_page_nonce = get_previous_page_nonce(&page_meta, &mut tx_iter);

    let service_transactions = process_transactions(
        &mut info_provider,
        safe_nonce,
        &mut tx_iter,
        previous_page_nonce,
        edge_nonce,
    )
    .await;

    Ok(Page {
        next: build_cursor(
            context,
            &chain_id,
            &safe_address,
            &page_meta,
            timezone_offset,
            display_trusted_only,
            backend_transactions.next,
            1, // Direction forward
        ),
        previous: build_cursor(
            context,
            &chain_id,
            &safe_address,
            &page_meta,
            timezone_offset,
            display_trusted_only,
            backend_transactions.previous,
            -1, // Direction backwards
        ),
        results: service_transactions,
    })
}

// Nonce of the first item in the next page (-1 if not present)
pub(super) fn get_edge_nonce(backend_transactions: &mut Page<MultisigTransaction>) -> i64 {
    // If there is a next url we remove the last item for information on the next page
    if backend_transactions.next.is_some() {
        backend_transactions.results.pop()
    } else {
        None
    }
    .map_or(-1, |tx| tx.nonce as i64)
}

// Nonce of the last item in the previous page (-1 if not present)
pub(super) fn get_previous_page_nonce(
    page_meta: &PageMetadata,
    tx_iter: &mut impl Iterator<Item = MultisigTransaction>,
) -> i64 {
    // If we are not on the first page then we take the first item to get information on the previous page
    if page_meta.offset == 0 {
        None
    } else {
        tx_iter.next()
    }
    .map_or(-1, |tx| tx.nonce as i64)
}

pub(super) async fn process_transactions(
    info_provider: &(impl InfoProvider + Sync),
    safe_nonce: i64,
    tx_iter: &mut impl Iterator<Item = MultisigTransaction>,
    previous_page_nonce: i64,
    edge_nonce: i64,
) -> Vec<TransactionListItem> {
    let mut last_proccessed_nonce = previous_page_nonce;
    let mut service_transactions: Vec<TransactionListItem> = Vec::new();
    let transaction_groups = tx_iter
        .group_by(|transaction| transaction.nonce as i64)
        .into_iter()
        .map(|(group_nonce, transaction_group)| {
            (group_nonce, transaction_group.collect::<Vec<_>>())
        })
        .collect::<HashMap<_, _>>();
    for &group_nonce in transaction_groups.keys().sorted() {
        let transaction_group = transaction_groups.get(&group_nonce).unwrap();
        // Check if we need to add section headers
        if last_proccessed_nonce < safe_nonce && group_nonce == safe_nonce {
            // If the last nonce processed was the initial nonce (-1) and this group nonce is the current Safe nonce then we start the Next section
            service_transactions.push(TransactionListItem::Label { label: Label::Next })
        } else if last_proccessed_nonce <= safe_nonce && group_nonce > safe_nonce {
            // If the last nonce processed was the initial nonce (-1) or the current Safe nonce and this group nonce higher than the Safe nonce then we start the Queue section
            service_transactions.push(TransactionListItem::Label {
                label: Label::Queued,
            })
        } // Else: If the last proccessed nonce is higher than the current Safe nonce then all headers should already be present

        // Update last proccessed nonce
        last_proccessed_nonce = group_nonce as i64;

        // Make the group peekable for conflict type checks
        let mut group_iter = transaction_group.iter().peekable();
        // There will be always at least one transaction for a group
        let group_start_tx = group_iter.next().unwrap();
        // Check if this group has the same nonce as the starting item of the next page
        let is_edge_group = group_nonce == edge_nonce;
        // This group has the same nonce as the last group from the previous page => group continues
        let conflict_from_previous_page = previous_page_nonce == group_nonce;
        // If there is more than 1 item in this group or we are in an edge group then we have a conflict
        let has_conflicts = group_iter.peek().is_some() || is_edge_group;
        // If we start a new conflict group then we should render the conflict header
        if has_conflicts && !conflict_from_previous_page {
            service_transactions.push(TransactionListItem::ConflictHeader {
                nonce: group_nonce as u64,
            })
        }
        // Add the one transaction that is always present
        add_transaction_as_summary(
            info_provider,
            &mut service_transactions,
            &group_start_tx,
            if has_conflicts {
                // We have more conflicts in this or the next page
                ConflictType::HasNext
            } else if conflict_from_previous_page {
                // We continue the group from the previous page but there are no additional conflicts in this page
                ConflictType::End
            } else {
                // No conflict in this or the previous page
                ConflictType::None
            },
        )
        .await;
        // Add additional conflicts of the group (only present when conflicts in the same page)
        while let Some(tx) = group_iter.next() {
            // Indicate if we are in a conflict group on the edge or if there are more conflicts in this page
            // Else indicate that we are at the end of the conflict group
            let conflict_type = if group_iter.peek().is_some() || is_edge_group {
                ConflictType::HasNext
            } else {
                ConflictType::End
            };
            add_transaction_as_summary(
                info_provider,
                &mut service_transactions,
                &tx,
                conflict_type,
            )
            .await;
        }
    }

    service_transactions
}

fn build_cursor(
    context: &RequestContext,
    chain_id: &String,
    safe_address: &String,
    page_meta: &PageMetadata,
    timezone_offset: &Option<String>,
    display_trusted_only: bool,
    url: Option<String>,
    direction: i64,
) -> Option<String> {
    url.as_ref().map(|_| {
        build_absolute_uri(
            context,
            uri!(
                crate::routes::transactions::routes::get_transactions_queued(
                    chain_id,
                    safe_address,
                    Some(offset_page_meta(
                        page_meta,
                        direction * (page_meta.limit as i64)
                    )),
                    Some(timezone_offset.clone().unwrap_or("0".to_string())),
                    Some(display_trusted_only)
                )
            ),
        )
    })
}

pub(super) fn adjust_page_meta(meta: &PageMetadata) -> PageMetadata {
    if meta.offset == 0 {
        PageMetadata {
            offset: 0,
            limit: meta.limit + 1,
        }
    } else {
        PageMetadata {
            offset: meta.offset - 1,
            limit: meta.limit + 2,
        }
    }
}

pub(super) async fn add_transaction_as_summary(
    info_provider: &(impl InfoProvider + Sync),
    items: &mut Vec<TransactionListItem>,
    transaction: &MultisigTransaction,
    conflict_type: ConflictType,
) {
    // Converting a multisig transaction theoretically can result in multiple summaries
    let mut tx_summary_iter = transaction
        .to_transaction_summary(info_provider)
        .await
        .unwrap_or(vec![])
        .into_iter()
        .peekable();
    while let Some(summary) = tx_summary_iter.next() {
        // If the summary items are based on an "End" item in a conflict group then we need to make sure that only the last is marked as the "End"
        let tx_conflict_type =
            if conflict_type == ConflictType::End && tx_summary_iter.peek().is_some() {
                ConflictType::HasNext
            } else {
                conflict_type.clone()
            };
        items.push(TransactionListItem::Transaction {
            transaction: summary,
            conflict_type: tx_conflict_type,
        });
    }
}

'''
'''--- src/routes/transactions/handlers/tests/mod.rs ---
mod parse_id;
pub mod transactions_history;
pub mod transactions_queued;
pub mod transfers;

'''
'''--- src/routes/transactions/handlers/tests/parse_id.rs ---
use crate::routes::transactions::handlers::details::parse_id;
use crate::routes::transactions::models::TransactionIdParts;

#[test]
fn multisig_details_id() {
    let details_id = "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x8bde30060a1e4d8383efa9b666654b31771c93325f905088c91f58803b4433b5";
    let expected = TransactionIdParts::Multisig {
        safe_address: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
        safe_tx_hash: "0x8bde30060a1e4d8383efa9b666654b31771c93325f905088c91f58803b4433b5"
            .to_string(),
    };

    let actual = parse_id(details_id).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn ethereum_details_id() {
    let details_id = "ethereum_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x4071662b18fb425db9a516b8472b4f545decb4bb6f6873af098b123b544e3cf4_0xae2714c8d2239062";
    let expected = TransactionIdParts::Ethereum {
        safe_address: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
        transaction_hash: "0x4071662b18fb425db9a516b8472b4f545decb4bb6f6873af098b123b544e3cf4"
            .to_string(),
        details_hash: "0xae2714c8d2239062".to_string(),
    };

    let actual = parse_id(details_id).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn module_details_id() {
    let details_id = "module_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x4071662b18fb425db9a516b8472b4f545decb4bb6f6873af098b123b544e3cf4_0xae2714c8d2239062";
    let expected = TransactionIdParts::Module {
        safe_address: "0x1230B3d59858296A31053C1b8562Ecf89A2f888b".to_string(),
        transaction_hash: "0x4071662b18fb425db9a516b8472b4f545decb4bb6f6873af098b123b544e3cf4"
            .to_string(),
        details_hash: "0xae2714c8d2239062".to_string(),
    };

    let actual = parse_id(details_id).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn transaction_hash_details_id() {
    let details_id = "0x8bde30060a1e4d8383efa9b666654b31771c93325f905088c91f58803b4433b5";
    let expected = TransactionIdParts::TransactionHash(String::from(
        "0x8bde30060a1e4d8383efa9b666654b31771c93325f905088c91f58803b4433b5",
    ));

    let actual = parse_id(details_id).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn creation_details_id() {
    let details_id = "creation_0x83eC7B0506556a7749306D69681aDbDbd08f0769";
    let expected =
        TransactionIdParts::Creation(String::from("0x83eC7B0506556a7749306D69681aDbDbd08f0769"));

    let actual = parse_id(details_id).unwrap();

    assert_eq!(expected, actual);
}

#[test]
#[should_panic]
fn failure_details_id() {
    let malformed_details_id = "module_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x4071662b18fb425db9a516b8472b4f545decb4bb6f6873af098b123b544e3cf4";

    parse_id(malformed_details_id).unwrap();
}

'''
'''--- src/routes/transactions/handlers/tests/transactions_history.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::Transaction;
use crate::common::models::page::{Page, PageMetadata};
use crate::providers::info::*;
use crate::routes::transactions::handlers::history::{
    adjust_page_meta, backend_txs_to_summary_txs, get_day_timestamp_millis,
    peek_timestamp_and_remove_item, service_txs_to_tx_list_items,
};
use crate::routes::transactions::models::summary::{
    ConflictType, ExecutionInfo, ModuleExecutionInfo, TransactionListItem, TransactionSummary,
};
use crate::routes::transactions::models::TransactionStatus::Success;
use crate::routes::transactions::models::TransferDirection::{Incoming, Outgoing};
use crate::routes::transactions::models::{
    Custom, Erc20Transfer, TransactionInfo, Transfer, TransferInfo,
};
use crate::tests::json::BACKEND_HISTORY_TRANSACTION_LIST_PAGE;

#[test]
fn adjust_page_meta_offset_0() {
    let input = PageMetadata {
        offset: 0,
        limit: 50,
    };
    let expected = PageMetadata {
        offset: 0,
        limit: input.limit,
    };

    let actual = adjust_page_meta(&input);

    assert_eq!(expected, actual);
}

#[test]
fn adjust_page_meta_offset_greater_than_0() {
    let input = PageMetadata {
        offset: 1,
        limit: 50,
    };
    let expected = PageMetadata {
        offset: 0,
        limit: 51,
    };

    let actual = adjust_page_meta(&input);

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn backend_txs_to_summary_txs_empty() {
    let backend_txs = Page {
        next: None,
        previous: None,
        results: vec![],
    };
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);

    let mut back_end_txs_iter = backend_txs.results.into_iter();

    let actual = backend_txs_to_summary_txs(&mut back_end_txs_iter, &mut mock_info_provider, "")
        .await
        .unwrap();
    assert_eq!(actual.is_empty(), true);
}

#[rocket::async_test]
async fn backend_txs_to_summary_txs_with_values() {
    let backend_txs =
        serde_json::from_str::<Page<Transaction>>(BACKEND_HISTORY_TRANSACTION_LIST_PAGE).unwrap();
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(3)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_token_info()
        .times(3)
        .returning(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(6)
        .returning(move |_| bail!("No address info"));

    let mut back_end_txs_iter = backend_txs.results.into_iter();
    let expected = vec![
        TransactionSummary {
            id: "module_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f_0x53b6e88b578a6313".into(),
            timestamp: 1606845854000,
            tx_status: Success,
            tx_info: TransactionInfo::Custom(
                Custom {
                    to: AddressEx::address_only("0xc778417E063141139Fce010982780140Aa0cD5Ab"),
                    data_size: "68".into(),
                    value: "0".into(),
                    method_name: Some("transfer".into()),
                    action_count: None,
                    is_cancellation: false,
                },
            ),
            execution_info: Some(ExecutionInfo::Module(ModuleExecutionInfo {
                address: AddressEx::address_only("0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134"),
            })),
            safe_app_info: None,
        },
        TransactionSummary {
            id: "module_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x1cf24abdb39bb7b156677a128e709cea55c6991b12708904d1f0f3664ad6646e_0x2e5157f6f782e36f".into(),
            timestamp: 1606845794000,
            tx_status: Success,
            tx_info: TransactionInfo::Custom(
                Custom {
                    to: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
                    data_size: "68".into(),
                    value: "0".into(),
                    method_name: Some("transfer".into()),
                    action_count: None,
                    is_cancellation: false,
                },
            ),
            execution_info: Some(ExecutionInfo::Module(ModuleExecutionInfo {
                address: AddressEx::address_only("0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134"),
            })),
            safe_app_info: None,
        },
        TransactionSummary {
            id: "module_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x3f12bb74cd91ef09d553f66e3623bceaf879ba3dcb325227b1fbf2455757891a_0x15a0e5a089475db".into(),
            timestamp: 1606845070000,
            tx_status: Success,
            tx_info: TransactionInfo::Custom(
                Custom {
                    to: AddressEx::address_only("0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"),
                    data_size: "68".into(),
                    value: "0".into(),
                    method_name: Some("transfer".into()),
                    action_count: None,
                    is_cancellation: false,
                },
            ),
            execution_info: Some(ExecutionInfo::Module(ModuleExecutionInfo {
                address: AddressEx::address_only("0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134"),
            })),
            safe_app_info: None,
        },
        TransactionSummary {
            id: "ethereum_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x021d4d8cb68f3f772906b58f97b66c6ead228c252627c5b1aff4b496d4ff0c2d_0xfd0dbbc7700a140f".into(),
            timestamp: 1606744033000,
            tx_status: Success,
            tx_info: TransactionInfo::Transfer(
                Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(
                        Erc20Transfer {
                            token_address: "0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88".into(),
                            token_name: Some(
                                "TEST AQER".into(),
                            ),
                            token_symbol: Some(
                                "AQER".into(),
                            ),
                            logo_uri: Some(
                                "https://gnosis-safe-token-logos.s3.amazonaws.com/0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88.png".into(),
                            ),
                            decimals: Some(
                                18,
                            ),
                            value: "100000000000000000".into(),
                        },
                    ),
                },
            ),
            execution_info: None,
            safe_app_info: None,
        },
        TransactionSummary {
            id: "ethereum_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x5f4b7555f8e977ae302ab4125de685ccfacf52ac70e6f0aa2939bcb347f9a732_0xb7ceaac0cd5a85c5".into(),
            timestamp: 1606743581000,
            tx_status: Success,
            tx_info: TransactionInfo::Transfer(
                Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(
                        Erc20Transfer {
                            token_address: "0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88".into(),
                            token_name: Some(
                                "TEST AQER".into(),
                            ),
                            token_symbol: Some(
                                "AQER".into(),
                            ),
                            logo_uri: Some(
                                "https://gnosis-safe-token-logos.s3.amazonaws.com/0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88.png".into(),
                            ),
                            decimals: Some(18),
                            value: "100000000000000000".into(),
                        },
                    ),
                },
            ),
            execution_info: None,
            safe_app_info: None,
        },
        TransactionSummary {
            id: "ethereum_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0xaafed95936f9d71eb8d9612e83f3f93f9decf33f11bbb4aa79cae98966ffa7fe_0x11bd3d64559a0af7".into(),
            timestamp: 1606739725000,
            tx_status: Success,
            tx_info: TransactionInfo::Transfer(
                Transfer {
                    sender: AddressEx::address_only("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"),
                    recipient: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    direction: Incoming,
                    transfer_info: TransferInfo::Erc20(
                        Erc20Transfer {
                            token_address: "0x81D0FF4fE216fB6aC98ED609086A92d94dbfE666".into(),
                            token_name: Some(
                                "LS".into(),
                            ),
                            token_symbol: Some(
                                "LS".into(),
                            ),
                            logo_uri: Some(
                                "https://gnosis-safe-token-logos.s3.amazonaws.com/0x81D0FF4fE216fB6aC98ED609086A92d94dbfE666.png".into(),
                            ),
                            decimals: Some(
                                18,
                            ),
                            value: "400000000000000".into(),
                        },
                    ),
                },
            ),
            execution_info: None,
            safe_app_info: None,
        },
    ];
    let actual = backend_txs_to_summary_txs(
        &mut back_end_txs_iter,
        &mut mock_info_provider,
        "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
    )
    .await
    .unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn service_txs_to_tx_list_items_empty() {
    let service_tx: Vec<TransactionSummary> = vec![];
    let utc_timezone_offset = 0;

    let actual = service_txs_to_tx_list_items(service_tx, -1, utc_timezone_offset).unwrap();

    assert_eq!(actual.is_empty(), true);
}

#[rocket::async_test]
async fn service_txs_to_tx_list_items_last_timestamp_undefined() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(6)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_token_info()
        .times(6)
        .returning(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(12)
        .returning(move |_| bail!("No address info"));

    let service_txs = get_service_txs(&mut mock_info_provider).await;
    let service_txs_copy = get_service_txs(&mut mock_info_provider).await;
    let utc_timezone_offset = 0;

    let mut service_txs_inter = service_txs.into_iter();

    let expected = vec![
        TransactionListItem::DateLabel {
            timestamp: 1606780800000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::DateLabel {
            timestamp: 1606694400000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
    ];

    let actual = service_txs_to_tx_list_items(service_txs_copy, -1, utc_timezone_offset).unwrap();
    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn service_txs_to_tx_list_items_last_timestamp_defined_but_different() {
    let last_timestamp = 1606867200000;
    let utc_timezone_offset = 0;

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(6)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_token_info()
        .times(6)
        .returning(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(12)
        .returning(move |_| bail!("No address info"));

    let service_txs = get_service_txs(&mut mock_info_provider).await;
    let service_txs_copy = get_service_txs(&mut mock_info_provider).await;

    let mut service_txs_inter = service_txs.into_iter();

    let expected = vec![
        TransactionListItem::DateLabel {
            timestamp: 1606780800000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::DateLabel {
            timestamp: 1606694400000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
    ];

    let actual =
        service_txs_to_tx_list_items(service_txs_copy, last_timestamp, utc_timezone_offset)
            .unwrap();
    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn service_txs_to_tx_list_items_last_timestamp_defined_and_same() {
    let last_timestamp = 1606780800000;
    let utc_timezone_offset = 0;

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(6)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_token_info()
        .times(6)
        .returning(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(12)
        .returning(move |_| bail!("No address info"));

    let service_txs = get_service_txs(&mut mock_info_provider).await;
    let service_txs_copy = get_service_txs(&mut mock_info_provider).await;

    let mut service_txs_inter = service_txs.into_iter();

    let expected = vec![
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::DateLabel {
            timestamp: 1606694400000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
    ];

    let actual =
        service_txs_to_tx_list_items(service_txs_copy, last_timestamp, utc_timezone_offset)
            .unwrap();
    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn service_txs_to_tx_list_items_date_label_berlin_timezone() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(6)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_token_info()
        .times(6)
        .returning(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(12)
        .returning(move |_| bail!("No address info"));

    let service_txs = get_service_txs(&mut mock_info_provider).await;
    let service_txs_copy = get_service_txs(&mut mock_info_provider).await;
    let berlin_timezone_offset = 3600; // + 1 hours Germany/Berlin

    let mut service_txs_inter = service_txs.into_iter();

    let expected = vec![
        TransactionListItem::DateLabel {
            timestamp: 1606777200000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::DateLabel {
            timestamp: 1606690800000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
    ];

    let actual =
        service_txs_to_tx_list_items(service_txs_copy, -1, berlin_timezone_offset).unwrap();
    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn service_txs_to_tx_list_items_date_label_melbourne_timezone() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(6)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_token_info()
        .times(6)
        .returning(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(12)
        .returning(move |_| bail!("No address info"));

    let service_txs = get_service_txs(&mut mock_info_provider).await;
    let service_txs_copy = get_service_txs(&mut mock_info_provider).await;
    let melbourne_timezone_offset = 39600; // + 11 hours Melbourne/Australia

    let mut service_txs_inter = service_txs.into_iter();

    let expected = vec![
        TransactionListItem::DateLabel {
            timestamp: 1606827600000, // 2020/12/02
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::DateLabel {
            timestamp: 1606741200000, // 2020/12/01
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::DateLabel {
            timestamp: 1606654800000, // 2020/11/30
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
    ];

    let actual =
        service_txs_to_tx_list_items(service_txs_copy, -1, melbourne_timezone_offset).unwrap();

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn service_txs_to_tx_list_items_date_label_buenos_aires_timezone() {
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(6)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_token_info()
        .times(6)
        .returning(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(12)
        .returning(move |_| bail!("No address info"));

    let service_txs = get_service_txs(&mut mock_info_provider).await;
    let service_txs_copy = get_service_txs(&mut mock_info_provider).await;
    let buenos_aires_timezone_offset = -10800; // -3 hours Argentina/Buenos Aires

    let mut service_txs_inter = service_txs.into_iter();

    let expected = vec![
        TransactionListItem::DateLabel {
            timestamp: 1606791600000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::DateLabel {
            timestamp: 1606705200000,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: service_txs_inter.next().unwrap(),
            conflict_type: ConflictType::None,
        },
    ];

    let actual =
        service_txs_to_tx_list_items(service_txs_copy, -1, buenos_aires_timezone_offset).unwrap();

    assert_eq!(expected, actual);
}

#[rocket::async_test]
#[should_panic]
async fn peek_timestamp_and_remove_item_empty() {
    let utc_timezone_offset = 3600;
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);

    let backend_txs: Vec<Transaction> = vec![];
    let mut backend_txs_iter = backend_txs.into_iter();

    peek_timestamp_and_remove_item(
        &mut backend_txs_iter,
        &mut mock_info_provider,
        "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
        utc_timezone_offset,
    )
    .await
    .unwrap();
}

#[rocket::async_test]
async fn peek_timestamp_and_remove_item_with_items() {
    let expected_timestamp = 1606780800000;
    let utc_timezone_offset = 0;

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider
        .expect_address_ex_from_contracts()
        .times(1)
        .returning(move |_| bail!("No contract info"));
    mock_info_provider
        .expect_token_info()
        .times(1)
        .returning(move |_| bail!("No token info"));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(1)
        .return_once(move |_| bail!("No address info"));

    let backend_txs =
        serde_json::from_str::<Page<Transaction>>(BACKEND_HISTORY_TRANSACTION_LIST_PAGE)
            .unwrap()
            .results;
    let mut backend_txs_iter = backend_txs.into_iter();

    let actual_timestamp = peek_timestamp_and_remove_item(
        &mut backend_txs_iter,
        &mut mock_info_provider,
        "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
        utc_timezone_offset,
    )
    .await
    .unwrap();

    assert_eq!(expected_timestamp, actual_timestamp);
}

#[test]
fn get_day_timestamp_millis_for_02_12_2020_00_00_01() {
    let input = 1606867201000; // 1 second past the 2nd of December 2020 UTC
    let utc_timezone_offset = 0;

    let actual = get_day_timestamp_millis(input, utc_timezone_offset);
    let expected = 1606867200000;

    assert_eq!(expected, actual);
}

async fn get_service_txs(mock_info_provider: &mut MockInfoProvider) -> Vec<TransactionSummary> {
    let backend_txs =
        serde_json::from_str::<Page<Transaction>>(BACKEND_HISTORY_TRANSACTION_LIST_PAGE).unwrap();

    let mut result = vec![];

    for tx in backend_txs.results {
        result.extend(
            tx.to_transaction_summary(
                mock_info_provider,
                "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
            )
            .await
            .unwrap_or_default(),
        )
    }

    result
}

'''
'''--- src/routes/transactions/handlers/tests/transactions_queued.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::backend::transactions::MultisigTransaction;
use crate::common::models::page::{Page, PageMetadata};
use crate::providers::info::*;
use crate::routes::transactions::handlers::queued::{
    adjust_page_meta, get_edge_nonce, get_previous_page_nonce, process_transactions,
};
use crate::routes::transactions::models::summary::{
    ConflictType, ExecutionInfo, Label, MultisigExecutionInfo, TransactionListItem,
    TransactionSummary,
};
use crate::routes::transactions::models::TransferDirection::Outgoing;
use crate::routes::transactions::models::{
    Erc20Transfer, TransactionInfo, TransactionStatus, Transfer, TransferInfo,
};
use crate::tests::json::{
    BACKEND_QUEUED_TRANSACTION_LIST_PAGE_CONFLICT_393,
    BACKEND_QUEUED_TRANSACTION_LIST_PAGE_CONFLICT_394,
    BACKEND_QUEUED_TRANSACTION_LIST_PAGE_NO_CONFLICTS, MULTISIG_TX_AWAITING_EXECUTION,
    MULTISIG_TX_SETTINGS_CHANGE, TOKEN_BAT,
};

#[test]
fn adjust_page_meta_offset_0() {
    let input = PageMetadata {
        offset: 0,
        limit: 50,
    };
    let expected = PageMetadata {
        offset: 0,
        limit: 51,
    };

    let actual = adjust_page_meta(&input);

    assert_eq!(expected, actual);
}

#[test]
fn adjust_page_meta_offset_greater_than_0() {
    let input = PageMetadata {
        offset: 1,
        limit: 50,
    };
    let expected = PageMetadata {
        offset: 0,
        limit: 52,
    };

    let actual = adjust_page_meta(&input);

    assert_eq!(expected, actual);
}

#[test]
fn get_edge_nonce_with_next() {
    let edge_tx = get_multisig_tx(MULTISIG_TX_AWAITING_EXECUTION);
    let expected = edge_tx.nonce as i64;
    let results = vec![get_multisig_tx(MULTISIG_TX_SETTINGS_CHANGE), edge_tx];
    let mut page: Page<MultisigTransaction> = Page {
        results,
        previous: None,
        next: Some("some_url".to_string()),
    };

    let actual = get_edge_nonce(&mut page);

    assert_eq!(expected, actual);
    assert_eq!(
        vec![get_multisig_tx(MULTISIG_TX_SETTINGS_CHANGE)],
        page.results
    );
}

#[test]
fn get_edge_nonce_without_next() {
    let results = vec![
        get_multisig_tx(MULTISIG_TX_SETTINGS_CHANGE),
        get_multisig_tx(MULTISIG_TX_AWAITING_EXECUTION),
    ];
    let mut page: Page<MultisigTransaction> = Page {
        results,
        previous: None,
        next: None,
    };

    let actual = get_edge_nonce(&mut page);

    assert_eq!(-1, actual);

    let expected = vec![
        get_multisig_tx(MULTISIG_TX_SETTINGS_CHANGE),
        get_multisig_tx(MULTISIG_TX_AWAITING_EXECUTION),
    ];
    assert_eq!(expected, page.results);
}

#[test]
fn get_previous_page_nonce_offset_0() {
    let page_meta = PageMetadata {
        offset: 0,
        limit: 20,
    };
    let results = vec![
        get_multisig_tx(MULTISIG_TX_AWAITING_EXECUTION),
        get_multisig_tx(MULTISIG_TX_SETTINGS_CHANGE),
    ];
    let mut results_iter = results.into_iter();

    let actual = get_previous_page_nonce(&page_meta, &mut results_iter);

    assert_eq!(-1, actual);
    assert_eq!(
        get_multisig_tx(MULTISIG_TX_AWAITING_EXECUTION),
        results_iter.next().unwrap()
    );
}

#[test]
fn get_previous_page_nonce_offset_greater_than_0() {
    let page_meta = PageMetadata {
        offset: 20,
        limit: 20,
    };
    let previous_page_tx = get_multisig_tx(MULTISIG_TX_AWAITING_EXECUTION);
    let expected = previous_page_tx.nonce as i64;
    let results = vec![
        previous_page_tx,
        get_multisig_tx(MULTISIG_TX_SETTINGS_CHANGE),
    ];
    let mut results_iter = results.into_iter();

    let actual = get_previous_page_nonce(&page_meta, &mut results_iter);

    assert_eq!(expected, actual);
    assert_eq!(
        get_multisig_tx(MULTISIG_TX_SETTINGS_CHANGE),
        results_iter.next().unwrap()
    );
}

#[rocket::async_test]
async fn process_transactions_empty_list() {
    let input_list: Vec<MultisigTransaction> = vec![];
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider.expect_safe_info().times(0);
    mock_info_provider.expect_token_info().times(0);

    let mut tx_iter = input_list.into_iter();
    let safe_nonce = 0;
    let previous_page_nonce = 0;
    let edge_nonce = 0;

    let actual = process_transactions(
        &mut mock_info_provider,
        safe_nonce,
        &mut tx_iter,
        previous_page_nonce,
        edge_nonce,
    )
    .await;

    let expected: Vec<TransactionListItem> = vec![];

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn process_transactions_no_conflicts_everything_queued() {
    let input_list: Vec<MultisigTransaction> = serde_json::from_str::<Page<MultisigTransaction>>(
        BACKEND_QUEUED_TRANSACTION_LIST_PAGE_NO_CONFLICTS,
    )
    .unwrap()
    .results;

    let bat_token_info = serde_json::from_str::<TokenInfo>(TOKEN_BAT).unwrap();
    let safe_info = serde_json::from_str::<SafeInfo>(
        r#"{
              "address": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
              "nonce": 391,
              "threshold": 3,
              "owners": [
                "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
                "0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164",
                "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
              ],
              "masterCopy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
              "modules": [],
              "fallbackHandler": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
              "guard": "0x0000000000000000000000000000000000000000",
              "version": "1.1.1"
            }"#,
    )
    .unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(3)
        .returning(move |_| Ok(safe_info.clone()));
    mock_info_provider
        .expect_token_info()
        .times(3)
        .returning(move |_| Ok(bat_token_info.clone()));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(3)
        .returning(move |_| bail!("No address info"));

    let mut tx_iter = input_list.into_iter();

    let safe_nonce = 391;
    let previous_page_nonce = -1;
    let edge_nonce = -1;

    let actual = process_transactions(
        &mut mock_info_provider,
        safe_nonce,
        &mut tx_iter,
        previous_page_nonce,
        edge_nonce,
    )
    .await;

    let expected: Vec<TransactionListItem> = vec![
        TransactionListItem::Label {
            label: Label::Queued,
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x0fe072e76498e0db46fc79113662026a4f8fb34e840491aefeff6dec21c766cb".to_string(),
                timestamp: 1607602242476,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "10".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo {
                    nonce: 392,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },

            conflict_type: ConflictType::None,

        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa".to_string(),
                timestamp: 1607602284354,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "20".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 393,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0xca7a464a3479af396c2975b4b3f5f7b90fc56747404ebaad5ec838c2954d2f9c".to_string(),
                timestamp: 1607602424072,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "20".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 394,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::None,
        },
    ];

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn process_transactions_conflicts_in_queued() {
    let input_list: Vec<MultisigTransaction> = serde_json::from_str::<Page<MultisigTransaction>>(
        BACKEND_QUEUED_TRANSACTION_LIST_PAGE_CONFLICT_394,
    )
    .unwrap()
    .results;

    let bat_token_info = serde_json::from_str::<TokenInfo>(TOKEN_BAT).unwrap();
    let safe_info = serde_json::from_str::<SafeInfo>(
        r#"{
              "address": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
              "nonce": 393,
              "threshold": 3,
              "owners": [
                "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
                "0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164",
                "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
              ],
              "masterCopy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
              "modules": [],
              "fallbackHandler": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
              "guard": "0x0000000000000000000000000000000000000000",
              "version": "1.1.1"
            }"#,
    )
    .unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(3)
        .returning(move |_| Ok(safe_info.clone()));
    mock_info_provider
        .expect_token_info()
        .times(3)
        .returning(move |_| Ok(bat_token_info.clone()));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(3)
        .returning(move |_| bail!("No address info"));

    let mut tx_iter = input_list.into_iter();

    let safe_nonce = 393;
    let previous_page_nonce = -1;
    let edge_nonce = -1;

    let actual = process_transactions(
        &mut mock_info_provider,
        safe_nonce,
        &mut tx_iter,
        previous_page_nonce,
        edge_nonce,
    )
    .await;

    let expected: Vec<TransactionListItem> = vec![
        TransactionListItem::Label {
            label: Label::Next,
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x0fe072e76498e0db46fc79113662026a4f8fb34e840491aefeff6dec21c766cb".to_string(),
                timestamp: 1607602242476,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "10".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 393,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::None,
        },
        TransactionListItem::Label {
            label: Label::Queued,
        },
        TransactionListItem::ConflictHeader {
            nonce: 394
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa".to_string(),
                timestamp: 1607602284354,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "20".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 394,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::HasNext,
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0xca7a464a3479af396c2975b4b3f5f7b90fc56747404ebaad5ec838c2954d2f9c".to_string(),
                timestamp: 1607602424072,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "20".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 394,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::End,
        }
    ];

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn process_transactions_conflicts_in_next() {
    let input_list: Vec<MultisigTransaction> = serde_json::from_str::<Page<MultisigTransaction>>(
        BACKEND_QUEUED_TRANSACTION_LIST_PAGE_CONFLICT_393,
    )
    .unwrap()
    .results;

    let bat_token_info = serde_json::from_str::<TokenInfo>(TOKEN_BAT).unwrap();
    let safe_info = serde_json::from_str::<SafeInfo>(
        r#"{
              "address": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
              "nonce": 393,
              "threshold": 3,
              "owners": [
                "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
                "0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164",
                "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
              ],
              "masterCopy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
              "modules": [],
              "fallbackHandler": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
              "guard": "0x0000000000000000000000000000000000000000",
              "version": "1.1.1"
            }"#,
    )
    .unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(3)
        .returning(move |_| Ok(safe_info.clone()));
    mock_info_provider
        .expect_token_info()
        .times(3)
        .returning(move |_| Ok(bat_token_info.clone()));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(3)
        .returning(move |_| bail!("No address info"));

    let mut tx_iter = input_list.into_iter();

    let safe_nonce = 393;
    let previous_page_nonce = -1;
    let edge_nonce = -1;

    let actual = process_transactions(
        &mut mock_info_provider,
        safe_nonce,
        &mut tx_iter,
        previous_page_nonce,
        edge_nonce,
    )
    .await;

    let expected: Vec<TransactionListItem> = vec![
        TransactionListItem::Label {
            label: Label::Next,
        },
        TransactionListItem::ConflictHeader {
            nonce: 393
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x0fe072e76498e0db46fc79113662026a4f8fb34e840491aefeff6dec21c766cb".to_string(),
                timestamp: 1607602242476,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "10".to_string()
                    }),

                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 393,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::HasNext,
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa".to_string(),
                timestamp: 1607602284354,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "20".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 393,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::End,
        },
        TransactionListItem::Label {
            label: Label::Queued,
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0xca7a464a3479af396c2975b4b3f5f7b90fc56747404ebaad5ec838c2954d2f9c".to_string(),
                timestamp: 1607602424072,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "20".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 394,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::None,
        }
    ];

    assert_eq!(expected, actual);
}

#[rocket::async_test]
async fn process_transactions_conflicts_in_queued_spanning_to_next_page() {
    let input_list: Vec<MultisigTransaction> = serde_json::from_str::<Page<MultisigTransaction>>(
        BACKEND_QUEUED_TRANSACTION_LIST_PAGE_CONFLICT_394,
    )
    .unwrap()
    .results;

    let bat_token_info = serde_json::from_str::<TokenInfo>(TOKEN_BAT).unwrap();
    let safe_info = serde_json::from_str::<SafeInfo>(
        r#"{
              "address": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
              "nonce": 393,
              "threshold": 3,
              "owners": [
                "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
                "0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164",
                "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
              ],
              "masterCopy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
              "modules": [],
              "fallbackHandler": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
              "guard": "0x0000000000000000000000000000000000000000",
              "version": "1.1.1"
            }"#,
    )
    .unwrap();

    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_safe_info()
        .times(3)
        .returning(move |_| Ok(safe_info.clone()));
    mock_info_provider
        .expect_token_info()
        .times(3)
        .returning(move |_| Ok(bat_token_info.clone()));
    mock_info_provider
        .expect_address_ex_from_any_source()
        .times(3)
        .returning(move |_| bail!("No address info"));

    let mut tx_iter = input_list.into_iter();

    let safe_nonce = 392;
    let previous_page_nonce = 393;
    let edge_nonce = 394;

    let actual = process_transactions(
        &mut mock_info_provider,
        safe_nonce,
        &mut tx_iter,
        previous_page_nonce,
        edge_nonce,
    )
    .await;

    // The first item expected is just a a transaction because we are not in the first page of data
    let expected: Vec<TransactionListItem> = vec![
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x0fe072e76498e0db46fc79113662026a4f8fb34e840491aefeff6dec21c766cb".to_string(),
                timestamp: 1607602242476,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "10".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 393,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::End,
        },
        TransactionListItem::ConflictHeader {
            nonce: 394
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa".to_string(),
                timestamp: 1607602284354,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "20".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 394,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::HasNext,
        },
        TransactionListItem::Transaction {
            transaction: TransactionSummary {
                id: "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0xca7a464a3479af396c2975b4b3f5f7b90fc56747404ebaad5ec838c2954d2f9c".to_string(),
                timestamp: 1607602424072,
                tx_status: TransactionStatus::AwaitingConfirmations,
                tx_info: TransactionInfo::Transfer(Transfer {
                    sender: AddressEx::address_only("0x1230B3d59858296A31053C1b8562Ecf89A2f888b"),
                    recipient: AddressEx::address_only("0xF353eBBa77e5E71c210599236686D51cA1F88b84"),
                    direction: Outgoing,
                    transfer_info: TransferInfo::Erc20(Erc20Transfer {
                        token_address: "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46".to_string(),
                        token_name: Some("BigAmount".to_string()),
                        token_symbol: Some("BA-T".to_string()),
                        logo_uri: Some("https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png".to_string()),
                        decimals: Some(1),
                        value: "20".to_string()
                    })
                }),
                execution_info: Some(ExecutionInfo::Multisig(MultisigExecutionInfo{
                    nonce: 394,
                    confirmations_required: 3,
                    confirmations_submitted:1,
                    missing_signers: Some(vec![
                        AddressEx::address_only("0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"), 
                        AddressEx::address_only("0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164")
                    ])
                })),
                safe_app_info: None,
            },
            conflict_type: ConflictType::HasNext,
        }
    ];

    assert_eq!(expected, actual);
}

fn get_multisig_tx(source: &str) -> MultisigTransaction {
    serde_json::from_str::<MultisigTransaction>(source).unwrap()
}

'''
'''--- src/routes/transactions/handlers/tests/transfers.rs ---
use crate::common::models::page::Page;
use crate::config::{chain_info_request_timeout, transaction_request_timeout};
use crate::routes::transactions::models::summary::TransactionListItem;
use crate::tests::main::setup_rocket;
use crate::utils::http_client::{MockHttpClient, Request, Response};
use core::time::Duration;
use mockall::predicate::eq;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;

#[rocket::async_test]
pub async fn get_incoming_transfers_no_filters() {
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let expected = Page {
        next: None,
        previous: None,
        results: vec![],
    };

    let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
    chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
    let mut mock_http_client = MockHttpClient::new();
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(chain_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
            })
        });

    let mut transfer_request = Request::new(format!(
        "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/{}/incoming-transfers/?limit=20&offset=0",
        &safe_address
    ));
    transfer_request.timeout(Duration::from_millis(transaction_request_timeout()));
    mock_http_client
        .expect_get()
        .times(1)
        .with(eq(transfer_request))
        .return_once(move |_| {
            Ok(Response {
                status_code: 200,
                body: serde_json::to_string(&Page::<TransactionListItem> {
                    next: None,
                    previous: None,
                    results: vec![],
                })
                .unwrap(),
            })
        });

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![crate::routes::transactions::routes::get_incoming_transfers],
        )
        .await,
    )
    .await
    .expect("valid rocket instance");

    let request = client
        .get(format!(
            "/v1/chains/4/safes/{}/incoming-transfers",
            &safe_address
        ))
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON);

    let response = request.dispatch().await;

    let actual_status = response.status();
    let value = &response.into_string().await.unwrap();
    let actual = serde_json::from_str::<Page<TransactionListItem>>(&value).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

'''
'''--- src/routes/transactions/handlers/transfers.rs ---
use crate::common::models::backend::transfers::Transfer;
use crate::common::models::page::{Page, PageMetadata};
use crate::config::transaction_request_timeout;
use crate::providers::info::{DefaultInfoProvider, InfoProvider};
use crate::routes::transactions::filters::transfer::TransferFilters;
use crate::routes::transactions::handlers::offset_page_meta;
use crate::routes::transactions::models::summary::{ConflictType, TransactionListItem};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;
use crate::utils::urls::build_absolute_uri;

use super::commons::get_backend_page;

pub async fn get_incoming_transfers(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    cursor: &Option<String>,
    filters: &TransferFilters,
) -> ApiResult<Page<TransactionListItem>> {
    let info_provider = DefaultInfoProvider::new(chain_id, context);
    let url = core_uri!(
        info_provider,
        "/v1/safes/{}/incoming-transfers/",
        safe_address
    )?;

    let page_meta: PageMetadata =
        PageMetadata::from_cursor(cursor.as_ref().unwrap_or(&"".to_string()));
    let backend_txs = get_backend_page(
        &context,
        chain_id,
        &url,
        transaction_request_timeout(),
        &page_meta,
        filters,
    )
    .await?;
    let service_txs = backend_txs_to_summary_txs(
        &mut backend_txs.results.into_iter(),
        &info_provider,
        safe_address,
    )
    .await?;

    return Ok(Page {
        next: build_cursor(
            context,
            chain_id,
            safe_address,
            &page_meta,
            backend_txs.next,
            filters,
            1,
        ),
        previous: build_cursor(
            context,
            chain_id,
            safe_address,
            &page_meta,
            backend_txs.previous,
            filters,
            -1,
        ),
        results: service_txs,
    });
}

async fn backend_txs_to_summary_txs(
    transfers: &mut impl Iterator<Item = Transfer>,
    info_provider: &(impl InfoProvider + Sync),
    safe_address: &str,
) -> ApiResult<Vec<TransactionListItem>> {
    let mut results = vec![];
    for transfer in transfers {
        let tx_summary = transfer
            .to_transaction_summary(
                info_provider,
                transfer.get_execution_time().unwrap(),
                safe_address,
            )
            .await;
        results.push(TransactionListItem::Transaction {
            transaction: tx_summary,
            conflict_type: ConflictType::None,
        });
    }

    Ok(results)
}

fn build_cursor(
    context: &RequestContext,
    chain_id: &str,
    safe_address: &str,
    page_meta: &PageMetadata,
    backend_page_url: Option<String>,
    filters: &TransferFilters,
    direction: i64,
) -> Option<String> {
    backend_page_url.as_ref().map(|_| {
        let cursor = offset_page_meta(page_meta, direction * (page_meta.limit as i64));

        build_absolute_uri(
            context,
            uri!(crate::routes::transactions::routes::get_incoming_transfers(
                chain_id = chain_id,
                safe_address = safe_address,
                cursor = Some(cursor),
                filters = (
                    filters.execution_date_gte.to_owned(),
                    filters.execution_date_lte.to_owned(),
                    filters.to.to_owned(),
                    filters.value.to_owned(),
                    filters.token_address.to_owned()
                )
            )),
        )
    })
}

'''
'''--- src/routes/transactions/mod.rs ---
#[doc(hidden)]
pub mod converters;
pub mod filters;
#[doc(hidden)]
pub mod handlers;
pub mod models;
pub mod routes;

#[cfg(test)]
mod tests;

'''
'''--- src/routes/transactions/models/details.rs ---
use super::*;
use crate::common::models::data_decoded::{DataDecoded, Operation};
use crate::providers::info::{SafeAppInfo, TokenInfo};
use serde::Serialize;
use std::collections::HashMap;

/// Top level object returned by the `/v1/transactions/<details_id>` endpoint
///
/// <details>
/// <summary>Sample 1: Multisig Transaction awaiting confirmation</summary>
///
/// ```json
/// {
///   "executedAt": null,
///   "txStatus": "AWAITING_CONFIRMATIONS",
///   "txInfo": {
///     "type": "SettingsChange",
///     "dataDecoded": {
///       "method": "changeThreshold",
///       "parameters": [
///         {
///           "name": "_threshold",
///           "type": "uint256",
///           "value": "2"
///         }
///       ]
///     }
///   },
///   "txData": {
///     "hexData": "0x694e80c30000000000000000000000000000000000000000000000000000000000000002",
///     "dataDecoded": {
///       "method": "changeThreshold",
///       "parameters": [
///         {
///           "name": "_threshold",
///           "type": "uint256",
///           "value": "2"
///         }
///       ]
///     },
///     "to": { "value" : "0x1230B3d59858296A31053C1b8562Ecf89A2f888b" },
///     "value": "0",
///     "operation": 0
///   },
///   "detailedExecutionInfo": {
///     "type": "MULTISIG",
///     "submittedAt": 1596792600322,
///     "nonce": 180,
///     "safeTxHash": "0x0ef685fb7984d7314c1368497e1b0c73016066bec41f966d32f18354b88fbd46",
///     "signers": [
///       { "value" : "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23" },
///       { "value" : "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72" },
///       { "value" : "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D" },
///       { "value" : "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd" },
///       { "value" : "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0" }
///     ],
///     "confirmationsRequired": 3,
///     "confirmations": [
///       {
///         "signer": { "value" : "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23" } ,
///         "signature": "0x1b01f3d79a50576e82d1da31810c0313bed9b76b016e1d9c6216512b2c7e53bb70df8163e568ca8ec1b8c7e7ef0a8db52d6ab2b7f47dc51c31729dd064ce375b1c"
///       }
///     ]
///   },
///   "txHash": null
/// }
/// ```
/// </details>
///
///
/// <details>
/// <summary>Sample 2: Ethereum transaction</summary>
///
/// ```json
/// {
///   "executedAt": 1604531696000,
///   "txStatus": "SUCCESS",
///   "txInfo": {
///     "type": "Transfer",
///     "sender": {
///      "value": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
///     },
///     "recipient": {
///       "value": "0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f"
///     },
///     "direction": "INCOMING",
///     "transferInfo": {
///       "type": "NATIVE_COIN",
///       "value": "100000000000000000"
///     }
///   },
///   "txData": null,
///   "detailedExecutionInfo": null,
///   "txHash": "0x7e95b9df8b1c1385665d0bccfbd5d6f913e18915750395d84dd490c7d9be9940"
/// }
/// ```
/// </details>
///
///
/// <details>
/// <summary>Sample 3: Settings change</summary>
///
/// ```json
///     {
///   "executedAt": 1595429831000,
///   "txStatus": "SUCCESS",
///   "txInfo": {
///     "type": "SettingsChange",
///     "dataDecoded": {
///       "method": "addOwnerWithThreshold",
///       "parameters": [
///         {
///           "name": "owner",
///           "type": "address",
///           "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
///         },
///         {
///           "name": "_threshold",
///           "type": "uint256",
///           "value": "2"
///         }
///       ]
///     },
///     "settingsInfo": {
///       "type": "ADD_OWNER",
///       "owner": {
///         "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
///       },
///       "threshold": 2
///     }
///   },
///   "txData": {
///     "hexData": "0x0d582f13000000000000000000000000a3daa0d9ae02daa17a664c232ada1b739ef5ae8d0000000000000000000000000000000000000000000000000000000000000002",
///     "dataDecoded": {
///       "method": "addOwnerWithThreshold",
///       "parameters": [
///         {
///           "name": "owner",
///           "type": "address",
///           "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
///         },
///         {
///           "name": "_threshold",
///           "type": "uint256",
///           "value": "2"
///         }
///       ]
///     },
///     "to": {
///       "value": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
///     },
///     "value": "0",
///     "operation": 0
///   },
///   "detailedExecutionInfo": {
///     "type": "MULTISIG",
///     "submittedAt": 1595429831000,
///     "nonce": 135,
///     "safeTxGas": 59786,
///     "baseGas": 0,
///     "gasPrice": "0",
///     "gasToken": "0x0000000000000000000000000000000000000000",
///     "refundReceiver": {
///       "value": "0x0000000000000000000000000000000000000000"
///     },
///     "safeTxHash": "0x57d94fe21bbee8f6646c420ee23126cd1ba1b9a53a6c9b10099a043da8f32eea",
///     "executor": {
///       "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
///     },
///     "signers": [
///       {
///         "value": "0x6169b3e26fac6870208e12074d91DF7eD124339e"
///       },
///       {
///         "value": "0x12536c4952c71b32c9f97FdC2BAC8CFB156A9dAf"
///       },
///       {
///         "value": "0x365ffD124183EcD9c301F5aB2E754b6f74F15876"
///       },
///       {
///         "value": "0xd0ba955b8F34561907Abb588603a2400e06BD2d2"
///       },
///       {
///         "value": "0xec7b7F5C0031e6C933931Ade1833aac867c5CD5f"
///       },
///       {
///         "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
///       },
///       {
///         "value": "0xfDDB1e19a973d7EDf1211970AF3E42d40acfd20F"
///       },
///       {
///         "value": "0x8bc9Ab35a2A8b20ad8c23410C61db69F2e5d8164"
///       },
///       {
///         "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
///       }
///     ],
///     "confirmationsRequired": 2,
///     "confirmations": [
///       {
///         "signer": {
///           "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
///         },
///         "signature": "0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b0000000000000000000000000000000000000000000000000000000000000000001",
///         "submittedAt": 1595429831000
///       },
///       {
///         "signer": {
///           "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
///         },
///         "signature": "0x2e8318bcd59462b715384e39fd848ccd0f54610cacdbb6adb46ec5c374d1bd2f1f8b3e1873f292bcafffd62c59281a00e2890478f1dfe72866d6edf3fd3522711b",
///         "submittedAt": 1595429831000
///       }
///     ]
///   },
///   "txHash": "0x7a6373c2d18e6e9dda16f4bd7f16a24600314487f3e30fb63a227b368d18121a"
/// }
/// ```
/// </details>
#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize, PartialEq))]
pub struct TransactionDetails {
    pub safe_address: String,
    pub tx_id: String,
    pub executed_at: Option<i64>,
    pub tx_status: TransactionStatus,
    pub tx_info: TransactionInfo,
    pub tx_data: Option<TransactionData>,
    pub detailed_execution_info: Option<DetailedExecutionInfo>,
    pub tx_hash: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub safe_app_info: Option<SafeAppInfo>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "type", rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(serde::Deserialize, PartialEq))]
pub enum DetailedExecutionInfo {
    Multisig(MultisigExecutionDetails),
    Module(ModuleExecutionDetails),
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize, PartialEq))]
pub struct MultisigExecutionDetails {
    pub submitted_at: i64,
    pub nonce: u64,
    pub safe_tx_gas: String,
    pub base_gas: String,
    pub gas_price: String,
    // As this is a token we will keep the token information separated
    pub gas_token: String,
    pub refund_receiver: AddressEx,
    pub safe_tx_hash: String,
    pub executor: Option<AddressEx>,
    pub signers: Vec<AddressEx>,
    pub confirmations_required: u64,
    pub confirmations: Vec<MultisigConfirmation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rejectors: Option<Vec<AddressEx>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gas_token_info: Option<TokenInfo>,
    pub trusted: bool,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize, PartialEq))]
pub struct MultisigConfirmation {
    pub signer: AddressEx,
    pub signature: Option<String>,
    pub submitted_at: i64,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize, PartialEq))]
pub struct ModuleExecutionDetails {
    pub address: AddressEx,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct TransactionData {
    pub hex_data: Option<String>,
    pub data_decoded: Option<DataDecoded>,
    pub to: AddressEx,
    pub value: Option<String>,
    pub operation: Operation,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trusted_delegate_call_target: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    // Mapping with info for the addresses in data_decoded
    pub address_info_index: Option<HashMap<String, AddressEx>>,
}

'''
'''--- src/routes/transactions/models/mod.rs ---
use crate::common::models::addresses::AddressEx;
use crate::common::models::data_decoded::DataDecoded;
use serde::Serialize;

pub mod details;
pub mod requests;
pub mod summary;

pub const ID_SEPARATOR: &str = "_";
pub const ID_PREFIX_MULTISIG_TX: &str = "multisig";
pub const ID_PREFIX_MODULE_TX: &str = "module";
pub const ID_PREFIX_ETHEREUM_TX: &str = "ethereum";
pub const ID_PREFIX_CREATION_TX: &str = "creation";

#[derive(PartialEq, Debug)]
pub(crate) enum TransactionIdParts {
    Creation(String),
    Multisig {
        safe_address: String,
        safe_tx_hash: String,
    },
    Module {
        safe_address: String,
        transaction_hash: String,
        details_hash: String,
    },
    Ethereum {
        safe_address: String,
        transaction_hash: String,
        details_hash: String,
    },
    TransactionHash(String),
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub enum TransactionStatus {
    AwaitingConfirmations,
    AwaitingExecution,
    Cancelled,
    Failed,
    Success,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(tag = "type")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub enum TransactionInfo {
    Transfer(Transfer),
    SettingsChange(SettingsChange),
    Custom(Custom),
    Creation(Creation),
    Unknown,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct Transfer {
    pub sender: AddressEx,
    pub recipient: AddressEx,
    pub direction: TransferDirection,
    pub transfer_info: TransferInfo,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub enum TransferDirection {
    Incoming,
    Outgoing,
    Unknown,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(tag = "type", rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub enum TransferInfo {
    Erc20(Erc20Transfer),
    Erc721(Erc721Transfer),
    NativeCoin(NativeCoinTransfer),
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct Erc20Transfer {
    // No need to map to AddressEx as the information are present in this struct
    pub token_address: String,
    pub token_name: Option<String>,
    pub token_symbol: Option<String>,
    pub logo_uri: Option<String>,
    pub decimals: Option<u64>,
    pub value: String,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct Erc721Transfer {
    // No need to map to AddressEx as the information are present in this struct
    pub token_address: String,
    pub token_id: String,
    pub token_name: Option<String>,
    pub token_symbol: Option<String>,
    pub logo_uri: Option<String>,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct NativeCoinTransfer {
    pub value: String,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct SettingsChange {
    pub data_decoded: DataDecoded,
    pub settings_info: Option<SettingsInfo>,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[serde(tag = "type")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub enum SettingsInfo {
    #[serde(rename_all = "camelCase")]
    SetFallbackHandler { handler: AddressEx },
    #[serde(rename_all = "camelCase")]
    AddOwner { owner: AddressEx, threshold: u64 },
    #[serde(rename_all = "camelCase")]
    RemoveOwner { owner: AddressEx, threshold: u64 },
    #[serde(rename_all = "camelCase")]
    SwapOwner {
        old_owner: AddressEx,
        new_owner: AddressEx,
    },
    #[serde(rename_all = "camelCase")]
    ChangeThreshold { threshold: u64 },
    #[serde(rename_all = "camelCase")]
    ChangeImplementation { implementation: AddressEx },
    #[serde(rename_all = "camelCase")]
    EnableModule { module: AddressEx },
    #[serde(rename_all = "camelCase")]
    DisableModule { module: AddressEx },
    #[serde(rename_all = "camelCase")]
    SetGuard { guard: AddressEx },
    #[serde(rename_all = "camelCase")]
    DeleteGuard,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct Custom {
    pub to: AddressEx,
    pub data_size: String,
    pub value: String,
    pub method_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_count: Option<usize>,
    pub is_cancellation: bool,
}

#[derive(Serialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(serde::Deserialize))]
pub struct Creation {
    pub creator: AddressEx,
    pub transaction_hash: String,
    pub implementation: Option<AddressEx>,
    pub factory: Option<AddressEx>,
}

'''
'''--- src/routes/transactions/models/requests.rs ---
use crate::common::models::data_decoded::Operation;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ConfirmationRequest {
    pub signed_safe_tx_hash: String,
}

/// MultisigTransactionRequest
///
/// <details>
/// <summary>Example body of MultisigTransactionRequest for submitting a Cancellation Transaction</summary>
///
/// ```json
/// {
///   "to": "0xBe8C10Dbf4c6148f9834C56C3331f8191f355552",
///   "value": "0",
///   "data": "0x",
///   "nonce": "39",
///   "operation": 0,
///   "safeTxGas": "0",
///   "baseGas": "0",
///   "gasPrice": "0",
///   "gasToken": "0x0000000000000000000000000000000000000000",
///   "refundReceiver": "0x0000000000000000000000000000000000000000",
///   "safeTxHash": "61b0acaeae49e74306536c3371cd80bb46aeb5732859b6ffd776ad24e2d57f8e",
///   "sender": "0xBe8C10Dbf4c6148f9834C56C3331f8191f355552",
///   "signature": "a519dd9aa226a5f6f1816035af85d43d834c3284912574bef0c04aaff1f21004602a5339da424cf53de9aac068f67a3417f3cba40e3049637ae901b6f345b4ac1b"
/// }
/// ```
/// </details>
#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
// Addresses are not mapped to AddressEx as this is a request body that is forwarded to the core services
pub struct MultisigTransactionRequest {
    pub to: String,
    pub value: String,
    pub data: Option<String>,
    pub nonce: String,
    pub operation: Operation,
    pub safe_tx_gas: String,
    pub base_gas: String,
    pub gas_price: String,
    pub gas_token: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub refund_receiver: Option<String>,
    #[serde(rename(serialize = "contractTransactionHash"))]
    pub safe_tx_hash: String,
    pub sender: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub origin: Option<String>,
}

'''
'''--- src/routes/transactions/models/summary.rs ---
use super::*;
use crate::providers::info::SafeAppInfo;
use serde::Serialize;

/// TransactionSummary - object returned for [TransactionListItem::Transaction]
///
/// <details>
/// <summary>Sample 1: History of executed transactions with date labels per day</summary>
///
/// ```json
/// {
///   "next": null,
///   "previous": null,
///   "results": [
///     {
///       "type": "DATE_LABEL",
///       "timestamp": 1604620800000
///     },
///      {
///       "type": "TRANSACTION",
///       "transaction": {
///         "id": "multisig_0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f_0x28b4cc29c036c2df40a1ba8d684cdab736abaf7d5cb84b217428462a2b4e3318",
///         "timestamp": 1604700419000,
///         "txStatus": "SUCCESS",
///         "txInfo": {
///           "type": "Custom",
///           "to": {
///             "value": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
///             "name": "Gnosis Safe: Multi Send 1.1.1",
///             "logoUri": "https://safe-transaction-assets.staging.gnosisdev.com/contracts/logos/0x8D29bE29923b68abfDD21e541b9374737B49cdAD.png"
///           },
///           "dataSize": "580",
///           "value": "0",
///           "methodName": "multiSend",
///           "actionCount": 6,
///           "isCancellation": false
///         },
///         "executionInfo": {
///           "type": "MULTISIG_EXECUTION_INFO",
///           "nonce": 2,
///           "confirmationsRequired": 1,
///           "confirmationsSubmitted": 1
///         }
///       },
///       "conflictType": "None"
///     },
///     {
///       "type": "DATE_LABEL",
///       "timestamp": 1604448000000
///     },
///     {
///       "type": "TRANSACTION",
///       "transaction": {
///         "id": "module_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f_0x53b6e88b578a6313",
///         "timestamp": 1604533603000,
///         "txStatus": "SUCCESS",
///         "txInfo": {
///           "type": "Custom",
///           "to": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
///           "dataSize": "260",
///           "value": "0",
///           "methodName": "multiSend"
///         },
///         "executionInfo": {
///           "type" : "MODULE_EXECUTION_INFO",
///           "address": {
///             "value": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134"
///           }
///         }
///       },
///       "conflictType": "None"
///     },
///     {
///       "type": "TRANSACTION",
///       "transaction": {
///         "id": "ethereum_0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f_0x7e95b9df8b1c1385665d0bccfbd5d6f913e18915750395d84dd490c7d9be9940_0xbf9e8a462afc9675",
///         "timestamp": 1604531696000,
///         "txStatus": "SUCCESS",
///         "txInfo": {
///           "type": "Transfer",
///           "sender": {
///             "value": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
///           },
///           "recipient": {
///             "value": "0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f"
///           },
///           "direction": "INCOMING",
///           "transferInfo": {
///             "type": "NATIVE_COIN",
///             "value": "100000000000000000"
///           }
///         }
///       },
///       "conflictType": "None"
///     },
///     {
///       "type": "TRANSACTION",
///       "transaction": {
///         "id": "creation_0x126ab4d9e87b5cba98Ddeb75Df703E83500b6B7f",
///         "timestamp": 1604531396000,
///         "txStatus": "SUCCESS",
///         "txInfo": {
///           "type": "Creation",
///           "creator": {
///             "value": "0x05c85Ab5B09Eb8A55020d72daf6091E04e264af9"
///           },
///           "transactionHash": "0xbfe5f021d0cfaf98ec445f757802be9e86b818301e2d892bcf3a9ee5e688d37f",
///           "implementation": {
///             "value": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
///             "name": "Gnosis Safe: Mastercopy 1.1.1",
///             "logoUri": "https://safe-transaction-assets.staging.gnosisdev.com/contracts/logos/0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F.png"
///           },
///           "factory": {
///             "value": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B"
///           }
///         }
///       },
///       "conflictType": "None"
///     }
///   ]
/// }
/// ```
///
/// </details>
#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(PartialEq, serde::Deserialize))]
pub struct TransactionSummary {
    pub id: String,
    pub timestamp: i64,
    pub tx_status: TransactionStatus,
    pub tx_info: TransactionInfo,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_info: Option<ExecutionInfo>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub safe_app_info: Option<SafeAppInfo>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "type", rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(PartialEq, serde::Deserialize))]
pub enum ExecutionInfo {
    Multisig(MultisigExecutionInfo),
    Module(ModuleExecutionInfo),
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(PartialEq, serde::Deserialize))]
pub struct MultisigExecutionInfo {
    pub nonce: u64,
    pub confirmations_required: u64,
    pub confirmations_submitted: u64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub missing_signers: Option<Vec<AddressEx>>,
}

#[derive(Serialize, Debug)]
#[serde(rename_all = "camelCase")]
#[cfg_attr(test, derive(PartialEq, serde::Deserialize))]
pub struct ModuleExecutionInfo {
    pub address: AddressEx,
}

#[derive(Serialize, Debug)]
#[serde(tag = "type")]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
#[cfg_attr(test, derive(PartialEq, serde::Deserialize))]
pub enum TransactionListItem {
    #[serde(rename_all = "camelCase")]
    Transaction {
        transaction: TransactionSummary,
        conflict_type: ConflictType,
    },
    DateLabel {
        timestamp: i64,
    },
    Label {
        label: Label,
    },
    ConflictHeader {
        nonce: u64,
    },
}

#[derive(Serialize, Debug)]
#[cfg_attr(test, derive(PartialEq, serde::Deserialize))]
pub enum Label {
    Next,
    Queued,
}

#[derive(Serialize, Debug, PartialEq, Clone, serde::Deserialize)]
pub enum ConflictType {
    None,
    HasNext,
    End,
}

'''
'''--- src/routes/transactions/routes.rs ---
use rocket::response::content;
use rocket::serde::json::{Error, Json};
use rocket_okapi::openapi;

use crate::cache::cache_operations::CacheResponse;
use crate::cache::manager::ChainCache;
use crate::config::tx_queued_cache_duration;
use crate::routes::transactions::filters::module::ModuleFilters;
use crate::routes::transactions::filters::multisig::MultisigFilters;
use crate::routes::transactions::filters::transfer::TransferFilters;
use crate::routes::transactions::handlers::preview::{
    TransactionPreview, TransactionPreviewRequest,
};
use crate::routes::transactions::handlers::{details, history, preview, proposal, queued};
use crate::routes::transactions::models::requests::{
    ConfirmationRequest, MultisigTransactionRequest,
};
use crate::utils::context::RequestContext;
use crate::utils::errors::ApiResult;

use super::handlers::{module, multisig, transfers};

/// `/v1/chains/<chain_id>/transactions/<transaction_id>` <br />
/// Returns [TransactionDetails](crate::routes::transactions::models::details::TransactionDetails)
///
/// # Transaction Details
///
/// The transaction details endpoint provides additional information for a transaction, in much more detail than what the transaction summary endpoint does. It returns a single object (TransactionDetails)[crate::routes::transactions::models::details::TransactionDetails]
///
/// ## Path
///
/// `GET /v1/chains/<chain_id>/transactions/<transaction_id>`
///
/// `<transaction_id>` can be either an `id` returned by the transaction summary list endpoint or a `safe_tx_hash` from the Safe Transaction API.
///
/// ## Query paramets
///
/// There aren't any query parameters that can be passed to this endpoint.
#[openapi(tag = "Transactions")]
#[get("/v1/chains/<chain_id>/transactions/<details_id>")]
pub async fn get_transactions(
    context: RequestContext,
    chain_id: String,
    details_id: String,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| details::get_transactions_details(&context, &chain_id, &details_id))
        .execute()
        .await
}

/// `/v1/chains/<chain_id>/transactions/<safe_tx_hash>/confirmations` <br />
/// Returns [TransactionDetails](crate::routes::transactions::models::details::TransactionDetails)
///
/// # Transaction Confirmation
///
/// This endpoint provides a way for submitting confirmations for clients making use of the `safe_tx_hash` as part of the path, and the very same `safe_tx_hash` signed by an owner corresponding to the safe from which the transaction is being sent.
///
/// If the confirmation is submitted successfully to the core services, then the local cache for that specific transaction is invalidated and the updated transaction details with the confirmation are returned in the request.
///
/// ## Path
///
/// `POST /v1/chains/<chain_id>/transactions/<safe_tx_hash>/confirmations`
///
/// The expected (ConfirmationRequest)[crate::routes::transactions::models::requests::ConfirmationRequest] body for this request, as well as the returned (TransactionDetails)[crate::routes::transactions::models::details::TransactionDetails]
///
/// ## Query parameters
///
/// No query parameters available for this endpoint.
#[post(
    "/v1/chains/<chain_id>/transactions/<safe_tx_hash>/confirmations",
    format = "application/json",
    data = "<tx_confirmation_request>"
)]
pub async fn post_confirmation<'e>(
    context: RequestContext,
    chain_id: String,
    safe_tx_hash: String,
    tx_confirmation_request: Result<Json<ConfirmationRequest>, Error<'e>>,
) -> ApiResult<content::RawJson<String>> {
    let request: ConfirmationRequest = tx_confirmation_request?.0;

    proposal::submit_confirmation(
        &context,
        &chain_id,
        &safe_tx_hash,
        &request.signed_safe_tx_hash,
    )
    .await?;

    let tx_details = CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| details::get_transactions_details(&context, &chain_id, &safe_tx_hash))
        .execute()
        .await;

    return tx_details;
}

/// `/v1/chains/<chain_id>/safes/<safe_address>/transactions/history?<cursor>&<timezone_offset>&<trusted>` <br />
/// Returns a [Page](crate::common::models::page::Page) of [TransactionListItem](crate::routes::transactions::models::summary::TransactionListItem)
///
/// # Transactions History
///
/// This endpoint returns all the transactions that have been executed for a given safe. Cancelled
/// transactions will not be shown in this endpoint. Therefore, there is no concept of conflicting `nonces`
/// for this endpoint, as there could potentially be for queued transactions.
///
/// This endpoint does not return any `TransactionListItem::Label` nor `TransactionListItem::ConflictHeader`
/// as of the writing of this iteration of this document.
///
/// Transaction are aggregated by day and for each day there is a `TransactionListItem::DateLabel` added.
/// The timestamp returned corresponds to the **date** only, **time** fields should be therefore ignored.
/// The dates are returned in UTC, in a later iteration this will be offset by the `timezone_offset`
/// sent by the clients in the query parameter.
///
/// `TransactionListItem::Transaction` is returned with the same data layout as in the `/transactions/queued` endpoint.
///
/// The structure of the `transaction` object corresponds to that of a (TransactionSummary)[crate::routes::transactions::models::summary::TransactionSummary]
///
/// ## Path
///
/// `GET /v1/chains/<chain_id>/safes/<safe_address>/transactions/history?<cursor>&<timezone_offset>&<trusted>`
///
/// ## Query parameters
///
/// - `<safe_address>` should be the checksummed address of the safe to be observed.
/// - `<cursor>` is the desired page of data to be loaded. Values for this parameter can be either `Page.next` or `Page.previous`. **WARNING:** Don't fiddle with the values of these 2 fields.
/// - `<timezone_offset>`: Currently ignored by the gateway.
/// - `<trusted>`: forwarded directly to the core services. Only for debugging purposes clients **should not** send it (unless they know what they are doing).
#[openapi(tag = "Transactions")]
#[get("/v1/chains/<chain_id>/safes/<safe_address>/transactions/history?<cursor>&<timezone_offset>")]
pub async fn get_transactions_history(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    cursor: Option<String>,
    timezone_offset: Option<String>,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| {
            history::get_history_transactions(
                &context,
                &chain_id,
                &safe_address,
                &cursor,
                &timezone_offset,
            )
        })
        .execute()
        .await
}

/// `/v1/chains/<chain_id>/safes/<safe_address>/transactions/queued?<cursor>&<timezone_offset>&<trusted>` <br />
/// Returns a [Page](crate::common::models::page::Page) of  [TransactionListItem](crate::routes::transactions::models::summary::TransactionListItem)
///
/// # Transactions Queued
///
/// This endpoint returns all the transactions that are still awaiting execution for a given safe. The list will contain a `Next` marker if there is a transaction matching the nonce of the safe, which means, that it will be the next transaction to be executed, provided there aren't any other transactions proposed utilizing the same nonce. If that were, the case a `ConflictHeader` will be introduced for which the `nonce` field will hold the conflicting value.
///
/// Additionally to the `Next` marker, there is also `Queued`. Under this marker, transactions that have a nonce greater than that of the safe are listed. Analogously to the `Next` section of the list, a `ConflictHeader` will be introduced for any group of transactions sharing the same `nonce`.
///
/// The structure of the transaction object corresponds to that of a (TransactionSummary)[crate::routes::transactions::models::summary::TransactionSummary]
///
/// A `TransactionListItem` can be either a `Label` (containing either `Next` or `Queued`), `ConflictHeader` (with the conflicting `nonce`) and a `Transaction`, for which there is a `TransactionSummary` and a `ConflictType` associated. The conflict type can have `HasNext` or `End` value. These values signal to which extent a group of conflicting transactions spans, ending as soon as a `Transaction` type item contains a `ConflictType::End`.
///
/// ## Path
///
/// `GET /v1/chains/<chain_id>/safes/<safe_address>/transactions/queued?<cursor>&<timezone_offset>&<trusted>`
///
/// The response is a list of (TransactionListItem)[crate::routes::transactions::models::summary::TransactionListItem], which is a polymorphic struct. Details follow in the models sections.
///
/// ## Query parameters
///
/// - `<safe_address>` should be the checksummed address of the safe to be observed.
/// - `<cursor>` is the desired page of data to be loaded. Values for this parameter can be either `Page.next` or `Page.previous`. **WARNING:** Don't fiddle with the values of these 2 fields.
/// - `<timezone_offset>`: Currently ignored by the gateway.
/// - `<trusted>`: forwarded directly to the core services. Only for debugging purposes clients **should not** send it (unless they know what they are doing).
#[openapi(tag = "Transactions")]
#[get("/v1/chains/<chain_id>/safes/<safe_address>/transactions/queued?<cursor>&<timezone_offset>&<trusted>")]
pub async fn get_transactions_queued(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    cursor: Option<String>,
    timezone_offset: Option<String>,
    trusted: Option<bool>,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| {
            queued::get_queued_transactions(
                &context,
                &chain_id,
                &safe_address,
                &cursor,
                &timezone_offset,
                &trusted,
            )
        })
        .duration(tx_queued_cache_duration())
        .execute()
        .await
}

/// `/v1/chains/<chain_id>/transactions/<safe_address>/propose` <br />
/// returns [TransactionDetails](crate::routes::transactions::models::details::TransactionDetails)
///
/// # Transaction Proposal
///
/// This endpoint provides a way for submitting transactions of any kind in the format expected by the core services.
/// See the example `json` to see how to submit a cancellation transaction (you would need to supply a `nonce`, `signature` and `contractTransactionHash` appropriate to the transaction you are submitting)
///
/// ## Path
///
/// `POST /v1/chains/<chain_id>/transactions/<safe_address>/propose`
///
/// The expected (MultisigTransactionRequest)[crate::routes::transactions::models::requests::MultisigTransactionRequest] body for this request, can be found in the sections [models](https://github.com/gnosis/safe-client-gateway/wiki/transactions_confirmation#models)
///
/// ## Query parameters
///
/// No query parameters available for this endpoint.
#[post(
    "/v1/chains/<chain_id>/transactions/<safe_address>/propose",
    format = "application/json",
    data = "<multisig_transaction_request>"
)]
pub async fn post_transaction<'e>(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    multisig_transaction_request: Result<Json<MultisigTransactionRequest>, Error<'e>>,
) -> ApiResult<content::RawJson<String>> {
    let request: MultisigTransactionRequest = multisig_transaction_request?.0;

    proposal::propose_transaction(&context, &chain_id, &safe_address, &request).await?;

    let tx_details = CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| {
            details::get_transactions_details(&context, &chain_id, &request.safe_tx_hash)
        })
        .execute()
        .await;

    return tx_details;
}

#[openapi(tag = "Transactions")]
#[get("/v1/chains/<chain_id>/safes/<safe_address>/incoming-transfers?<cursor>&<filters..>")]
pub async fn get_incoming_transfers(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    cursor: Option<String>,
    filters: TransferFilters,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| {
            transfers::get_incoming_transfers(&context, &chain_id, &safe_address, &cursor, &filters)
        })
        .execute()
        .await
}

#[openapi(tag = "Transactions")]
#[get("/v1/chains/<chain_id>/safes/<safe_address>/module-transactions?<cursor>&<filters..>")]
pub async fn get_module_transactions(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    cursor: Option<String>,
    filters: ModuleFilters,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| {
            module::get_module_transactions(&context, &chain_id, &safe_address, &cursor, &filters)
        })
        .execute()
        .await
}

#[openapi(tag = "Transactions")]
#[get("/v1/chains/<chain_id>/safes/<safe_address>/multisig-transactions?<cursor>&<filters..>")]
pub async fn get_multisig_transactions(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    cursor: Option<String>,
    filters: MultisigFilters,
) -> ApiResult<content::RawJson<String>> {
    CacheResponse::new(&context, ChainCache::from(chain_id.as_str()))
        .resp_generator(|| {
            multisig::get_multisig_transactions(
                &context,
                &chain_id,
                &safe_address,
                &cursor,
                &filters,
            )
        })
        .execute()
        .await
}

#[post(
    "/v1/chains/<chain_id>/transactions/<safe_address>/preview",
    format = "application/json",
    data = "<transaction_preview_request>"
)]
pub async fn post_preview_transaction(
    context: RequestContext,
    chain_id: String,
    safe_address: String,
    transaction_preview_request: Json<TransactionPreviewRequest>,
) -> ApiResult<content::RawJson<String>> {
    let transaction_preview: TransactionPreview = preview::preview_transaction(
        &context,
        &chain_id,
        &safe_address,
        &transaction_preview_request.0,
    )
    .await?;
    let body = serde_json::to_string(&transaction_preview)?;
    return Ok(content::RawJson(body));
}

'''
'''--- src/routes/transactions/tests/json/chain_response.json ---
{
  "chainId": "1",
  "chainName": "Ethereum",
  "shortName": "eth",
  "description": "The main Ethereum network",
  "l2": false,
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://mainnet.infura.io/v3/"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://mainnet.infura.io/v3/"
  },
  "publicRpcUri": {
    "authentication": "NO_AUTHENTICATION",
    "value": "https://cloudflare-eth.com"
  },
  "blockExplorerUriTemplate": {
    "address": "https://etherscan.io/address/{{address}}",
    "txHash": "https://etherscan.io/tx/{{txHash}}",
    "api": "https://api.etherscan.io/api?module={{module}}&action={{action}}&address={{address}}&apiKey={{apiKey}}"
  },
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://safe-transaction-assets.gnosis-safe.io/chains/1/currency_logo.png"
  },
  "transactionService": "https://safe-transaction.example.safe.global",
  "vpcTransactionService": "https://safe-transaction.example.safe.global",
  "theme": {
    "textColor": "#001428",
    "backgroundColor": "#E8E7E6"
  },
  "gasPrice": [
    {
      "type": "oracle",
      "uri": "https://api.etherscan.io/api?module=gastracker&action=gasoracle&apikey=JNFAU892RF9TJWBU3EV7DJCPIWZY8KEMY1",
      "gasParameter": "FastGasPrice",
      "gweiFactor": "1000000000.000000000"
    },
    {
      "type": "oracle",
      "uri": "https://ethgasstation.info/json/ethgasAPI.json?api-key=8bb8066b5c3ed1442190d0e30ad9126c7b8235314397efa76e6977791cb2",
      "gasParameter": "fast",
      "gweiFactor": "100000000.000000000"
    }
  ],
  "ensRegistryAddress": "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  "recommendedMasterCopyVersion": "1.3.0",
  "disabledWallets": [
    "lattice"
  ],
  "features": [
    "CONTRACT_INTERACTION",
    "DOMAIN_LOOKUP",
    "EIP1559",
    "ERC721",
    "SAFE_APPS",
    "SAFE_TX_GAS_OPTIONAL",
    "SPENDING_LIMIT",
    "TX_SIMULATION"
  ]
}

'''
'''--- src/routes/transactions/tests/json/contract_info_BID.json ---
{
    "address": "0x37D94d4E230859f83c0868CebEd8CcB83A765cee",
    "name": "BID",
    "displayName": "",
    "logoUri": null,
    "contractAbi": {
        "abi": [
            {
                "type": "constructor",
                "inputs": [
                    {
                        "name": "_controller",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "payable": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "Approval",
                "type": "event",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "spender",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "value",
                        "type": "uint256",
                        "indexed": false,
                        "internalType": "uint256"
                    }
                ],
                "anonymous": false
            },
            {
                "name": "Transfer",
                "type": "event",
                "inputs": [
                    {
                        "name": "from",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "to",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "value",
                        "type": "uint256",
                        "indexed": false,
                        "internalType": "uint256"
                    }
                ],
                "anonymous": false
            },
            {
                "name": "allowance",
                "type": "function",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "spender",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "approve",
                "type": "function",
                "inputs": [
                    {
                        "name": "spender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "amount",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "balanceOf",
                "type": "function",
                "inputs": [
                    {
                        "name": "account",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "decimals",
                "type": "function",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint8",
                        "internalType": "uint8"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "decreaseAllowance",
                "type": "function",
                "inputs": [
                    {
                        "name": "spender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "subtractedValue",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "increaseAllowance",
                "type": "function",
                "inputs": [
                    {
                        "name": "spender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "addedValue",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "name",
                "type": "function",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "string",
                        "internalType": "string"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "symbol",
                "type": "function",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "string",
                        "internalType": "string"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "totalSupply",
                "type": "function",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "transfer",
                "type": "function",
                "inputs": [
                    {
                        "name": "recipient",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "amount",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "transferFrom",
                "type": "function",
                "inputs": [
                    {
                        "name": "sender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "recipient",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "amount",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            }
        ],
        "description": "BID",
        "relevance": 100
    },
    "trustedForDelegateCall": false
}

'''
'''--- src/routes/transactions/tests/json/contracts_response.json ---
{
  "address": "0x6810e776880C02933D47DB1b9fc05908e5386b96",
  "name": "GnosisToken",
  "displayName": "",
  "logoUri": null,
  "contractAbi": {
    "abi": [
      {
        "name": "name",
        "type": "function",
        "inputs": [],
        "outputs": [
          {
            "name": "",
            "type": "string"
          }
        ],
        "payable": false,
        "constant": true
      },
      {
        "name": "approve",
        "type": "function",
        "inputs": [
          {
            "name": "_spender",
            "type": "address"
          },
          {
            "name": "_value",
            "type": "uint256"
          }
        ],
        "outputs": [
          {
            "name": "",
            "type": "bool"
          }
        ],
        "payable": false,
        "constant": false
      },
      {
        "name": "totalSupply",
        "type": "function",
        "inputs": [],
        "outputs": [
          {
            "name": "",
            "type": "uint256"
          }
        ],
        "payable": false,
        "constant": true
      },
      {
        "name": "transferFrom",
        "type": "function",
        "inputs": [
          {
            "name": "_from",
            "type": "address"
          },
          {
            "name": "_to",
            "type": "address"
          },
          {
            "name": "_value",
            "type": "uint256"
          }
        ],
        "outputs": [
          {
            "name": "",
            "type": "bool"
          }
        ],
        "payable": false,
        "constant": false
      },
      {
        "name": "decimals",
        "type": "function",
        "inputs": [],
        "outputs": [
          {
            "name": "",
            "type": "uint8"
          }
        ],
        "payable": false,
        "constant": true
      },
      {
        "name": "balanceOf",
        "type": "function",
        "inputs": [
          {
            "name": "_owner",
            "type": "address"
          }
        ],
        "outputs": [
          {
            "name": "",
            "type": "uint256"
          }
        ],
        "payable": false,
        "constant": true
      },
      {
        "name": "symbol",
        "type": "function",
        "inputs": [],
        "outputs": [
          {
            "name": "",
            "type": "string"
          }
        ],
        "payable": false,
        "constant": true
      },
      {
        "name": "transfer",
        "type": "function",
        "inputs": [
          {
            "name": "_to",
            "type": "address"
          },
          {
            "name": "_value",
            "type": "uint256"
          }
        ],
        "outputs": [
          {
            "name": "",
            "type": "bool"
          }
        ],
        "payable": false,
        "constant": false
      },
      {
        "name": "allowance",
        "type": "function",
        "inputs": [
          {
            "name": "_owner",
            "type": "address"
          },
          {
            "name": "_spender",
            "type": "address"
          }
        ],
        "outputs": [
          {
            "name": "",
            "type": "uint256"
          }
        ],
        "payable": false,
        "constant": true
      },
      {
        "type": "constructor",
        "inputs": [
          {
            "name": "dutchAuction",
            "type": "address"
          },
          {
            "name": "owners",
            "type": "address[]"
          },
          {
            "name": "tokens",
            "type": "uint256[]"
          }
        ],
        "payable": false
      },
      {
        "name": "Transfer",
        "type": "event",
        "inputs": [
          {
            "name": "from",
            "type": "address",
            "indexed": true
          },
          {
            "name": "to",
            "type": "address",
            "indexed": true
          },
          {
            "name": "value",
            "type": "uint256",
            "indexed": false
          }
        ],
        "anonymous": false
      },
      {
        "name": "Approval",
        "type": "event",
        "inputs": [
          {
            "name": "owner",
            "type": "address",
            "indexed": true
          },
          {
            "name": "spender",
            "type": "address",
            "indexed": true
          },
          {
            "name": "value",
            "type": "uint256",
            "indexed": false
          }
        ],
        "anonymous": false
      }
    ],
    "description": "GnosisToken",
    "relevance": 100
  },
  "trustedForDelegateCall": false
}

'''
'''--- src/routes/transactions/tests/json/multisig_tx_details.json ---
{
  "txId": "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa",
  "executedAt": 1607608259000,
  "txStatus": "SUCCESS",
  "txInfo": {
    "type": "Transfer",
    "sender": {
      "value": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    },
    "recipient": {
      "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84",
      "name": "Transfer target"
    },
    "direction": "OUTGOING",
    "transferInfo": {
      "type": "ERC20",
      "tokenAddress": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "tokenName": "BigAmount",
      "tokenSymbol": "BA-T",
      "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png",
      "decimals": 1,
      "value": "20"
    }
  },
  "txData": {
    "hexData": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
    "dataDecoded": {
      "method": "transfer",
      "parameters": [
        {
          "name": "to",
          "type": "address",
          "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
        },
        {
          "name": "value",
          "type": "uint256",
          "value": "20"
        }
      ]
    },
    "to": {
      "value": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46"
    },
    "value": "0",
    "operation": 0,
    "addressInfoIndex": {
      "0xF353eBBa77e5E71c210599236686D51cA1F88b84": {
        "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84",
        "name": "Transfer target"
      }
    }
  },
  "detailedExecutionInfo": {
    "type": "MULTISIG",
    "submittedAt": 1607608259000,
    "nonce": 393,
    "safeTxGas": "26746",
    "baseGas": "0",
    "gasPrice": "0",
    "gasToken": "0x0000000000000000000000000000000000000000",
    "refundReceiver": {
      "value": "0x0000000000000000000000000000000000000000"
    },
    "safeTxHash": "0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa",
    "executor": {
      "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
    },
    "signers": [
      {
        "value": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"
      },
      {
        "value": "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72"
      },
      {
        "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
      },
      {
        "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
      },
      {
        "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
      }
    ],
    "confirmationsRequired": 2,
    "confirmations": [
      {
        "signer": {
          "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
        },
        "signature": "0x1f6d2f092022fcbe6b10f0514255eb4205bb2302ac8789311b1aa2f0a134a7026458c827b42ccb577ffa7a5bc43582b4a23183ab811271ddc9d78446784fa3701b",
        "submittedAt": 1607608259000
      },
      {
        "signer": {
          "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
        },
        "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
        "submittedAt": 1607608259000
      }
    ]
  },
  "txHash": "0xd145bafe9766613d431a898a7ad95b69481152b4e9f846bd5fdc334ec8d78266"
}

'''
'''--- src/routes/transactions/tests/json/post_confirmation_result.json ---
{
  "safeAddress": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "txId": "multisig_0x1230B3d59858296A31053C1b8562Ecf89A2f888b_0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa",
  "executedAt": 1607608259000,
  "txStatus": "SUCCESS",
  "txInfo": {
    "type": "Transfer",
    "sender": {
      "value": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    },
    "recipient": {
      "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
    },
    "direction": "OUTGOING",
    "transferInfo": {
      "type": "ERC20",
      "tokenAddress": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "tokenName": "BigAmount",
      "tokenSymbol": "BA-T",
      "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png",
      "decimals": 1,
      "value": "20"
    }
  },
  "txData": {
    "hexData": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
    "dataDecoded": {
      "method": "transfer",
      "parameters": [
        {
          "name": "to",
          "type": "address",
          "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
        },
        {
          "name": "value",
          "type": "uint256",
          "value": "20"
        }
      ]
    },
    "to": {
      "value": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "name": "BigAmount",
      "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png"
    },
    "value": "0",
    "operation": 0
  },
  "detailedExecutionInfo": {
    "type": "MULTISIG",
    "submittedAt": 1607608259000,
    "nonce": 393,
    "safeTxGas": "26746",
    "baseGas": "0",
    "gasPrice": "0",
    "gasToken": "0x0000000000000000000000000000000000000000",
    "refundReceiver": {
      "value": "0x0000000000000000000000000000000000000000"
    },
    "safeTxHash": "0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa",
    "executor": {
      "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
    },
    "signers": [
      {
        "value": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"
      },
      {
        "value": "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72"
      },
      {
        "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
      },
      {
        "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
      },
      {
        "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
      }
    ],
    "confirmationsRequired": 2,
    "confirmations": [
      {
        "signer": {
          "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
        },
        "signature": "0x1f6d2f092022fcbe6b10f0514255eb4205bb2302ac8789311b1aa2f0a134a7026458c827b42ccb577ffa7a5bc43582b4a23183ab811271ddc9d78446784fa3701b",
        "submittedAt": 1607608259000
      },
      {
        "signer": {
          "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
        },
        "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
        "submittedAt": 1607608259000
      }
    ],
    "trusted": false
  },
  "txHash": "0xd145bafe9766613d431a898a7ad95b69481152b4e9f846bd5fdc334ec8d78266"
}

'''
'''--- src/routes/transactions/tests/json/preview_response.json ---
{
  "txInfo": {
    "type": "Custom",
    "to": {
      "value": "0x37D94d4E230859f83c0868CebEd8CcB83A765cee"
    },
    "dataSize": "68",
    "value": "0",
    "methodName": "approve",
    "isCancellation": false
  },
  "txData": {
    "hexData": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
    "dataDecoded": {
      "method": "approve",
      "parameters": [
        {
          "name": "spender",
          "type": "address",
          "value": "0xae9844F89D98c150F5e61bfC676D68b492155990"
        },
        {
          "name": "value",
          "type": "uint256",
          "value": "500000000000000"
        }
      ]
    },
    "to": {
      "value": "0x37D94d4E230859f83c0868CebEd8CcB83A765cee"
    },
    "value": "0",
    "operation": 0
  }
}

'''
'''--- src/routes/transactions/tests/json/preview_response_data_decoded_error.json ---
{
  "txInfo": {
    "type": "Custom",
    "to": {
      "value": "0x37D94d4E230859f83c0868CebEd8CcB83A765cee"
    },
    "dataSize": "68",
    "value": "0",
    "methodName": null,
    "isCancellation": false
  },
  "txData": {
    "hexData": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
    "dataDecoded": null,
    "to": {
      "value": "0x37D94d4E230859f83c0868CebEd8CcB83A765cee"
    },
    "value": "0",
    "operation": 0
  }
}

'''
'''--- src/routes/transactions/tests/mod.rs ---
mod preview;
mod routes;

const POST_CONFIRMATION_RESULT: &str = include_str!("json/post_confirmation_result.json");
const MULTISIG_TX_DETAILS: &str = include_str!("json/multisig_tx_details.json");
const CONTRACTS_RESPONSE: &str = include_str!("json/contracts_response.json");
const PREVIEW_RESPONSE: &str = include_str!("json/preview_response.json");
const PREVIEW_DATA_DECODED_ERROR_RESPONSE: &str =
    include_str!("json/preview_response_data_decoded_error.json");
const CHAIN_RESPONSE: &str = include_str!("json/chain_response.json");
const CONTRACT_INFO: &str = include_str!("json/contract_info_BID.json");

'''
'''--- src/routes/transactions/tests/preview.rs ---
use std::time::Duration;

use mockall::predicate::eq;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;
use serde_json::json;

use crate::common::models::backend::chains::{
    BlockExplorerUriTemplate, ChainInfo, GasPrice, NativeCurrency, RpcAuthentication, RpcUri, Theme,
};
use crate::config::{chain_info_request_timeout, contract_info_request_timeout};
use crate::providers::info::*;
use crate::routes::contracts::models::DataDecoderRequest;
use crate::routes::transactions::handlers::preview::TransactionPreview;
use crate::routes::transactions::tests::{
    CONTRACT_INFO, PREVIEW_DATA_DECODED_ERROR_RESPONSE, PREVIEW_RESPONSE,
};
use crate::tests::main::setup_rocket;
use crate::utils::errors::{ApiError, ApiResult};
use crate::utils::http_client::{MockHttpClient, Request, Response};

#[rocket::async_test]
async fn post_preview_success() {
    std::env::set_var("FEATURE_FLAG_NESTED_DECODING", "false");
    std::env::set_var("CONFIG_SERVICE_URI", "https://config-url-example.com");

    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();

        let contract_address = "0x37D94d4E230859f83c0868CebEd8CcB83A765cee";
        // Chain Request
        let mut chain_request =
            Request::new("https://config-url-example.com/api/v1/chains/1/".to_string());
        chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
        mock_http_client
            .expect_get()
            .with(eq(chain_request))
            .times(1)
            .returning(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(super::CHAIN_RESPONSE),
                })
            });

        // Known Address Request (to field)
        let mut contract_request = Request::new(format!(
            "https://safe-transaction.example.safe.global/api/v1/contracts/{}/",
            contract_address
        ));
        contract_request.timeout(Duration::from_millis(contract_info_request_timeout()));
        mock_http_client
            .expect_get()
            .with(eq(contract_request))
            .times(1)
            .returning(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(CONTRACT_INFO),
                })
            });

        // Data Decoder Request
        let data = "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000";
        let mut data_decoder_request = Request::new(
            "https://safe-transaction.example.safe.global/api/v1/data-decoder/".to_string(),
        );
        data_decoder_request.body(Some(
            serde_json::to_string::<DataDecoderRequest>(&DataDecoderRequest {
                to: Some("0x37D94d4E230859f83c0868CebEd8CcB83A765cee".to_string()),
                data: data.to_string(),
            })
            .unwrap(),
        ));
        mock_http_client
            .expect_post()
            .with(eq(data_decoder_request))
            .times(1)
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::DATA_DECODED_APPROVE),
                })
            });
        mock_http_client
    };

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_preview_transaction],
        )
        .await,
    )
    .await
    .expect("Valid rocket instance");

    let request =  client.post("/v1/chains/1/transactions/0x37D94d4E230859f83c0868CebEd8CcB83A765cee/preview")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON)
        .body(&json!({
            "to": "0x37D94d4E230859f83c0868CebEd8CcB83A765cee",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "value": "0",
            "operation": 0,
        }).to_string());
    let response = request.dispatch().await;

    let expected = serde_json::from_str::<TransactionPreview>(PREVIEW_RESPONSE).unwrap();
    let actual_status = response.status();
    let actual =
        serde_json::from_str::<TransactionPreview>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn post_preview_data_decoder_error() {
    std::env::set_var("FEATURE_FLAG_NESTED_DECODING", "false");
    std::env::set_var("CONFIG_SERVICE_URI", "https://config-url-example.com");

    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();

        let contract_address = "0x37D94d4E230859f83c0868CebEd8CcB83A765cee";
        // Chain Request
        let mut chain_request =
            Request::new("https://config-url-example.com/api/v1/chains/1/".to_string());
        chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
        mock_http_client
            .expect_get()
            .with(eq(chain_request))
            .times(1)
            .returning(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(super::CHAIN_RESPONSE),
                })
            });

        // Known Address Request (to field)
        let mut contract_request = Request::new(format!(
            "https://safe-transaction.example.safe.global/api/v1/contracts/{}/",
            contract_address
        ));
        contract_request.timeout(Duration::from_millis(contract_info_request_timeout()));
        mock_http_client
            .expect_get()
            .with(eq(contract_request))
            .times(1)
            .returning(move |_| {
                Err(ApiError::from_http_response(&Response {
                    body: "".to_string(),
                    status_code: 422,
                }))
            });

        // Data Decoder Request
        let data = "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000";
        let mut data_decoder_request = Request::new(
            "https://safe-transaction.example.safe.global/api/v1/data-decoder/".to_string(),
        );
        data_decoder_request.body(Some(
            serde_json::to_string::<DataDecoderRequest>(&DataDecoderRequest {
                to: Some("0x37D94d4E230859f83c0868CebEd8CcB83A765cee".to_string()),
                data: data.to_string(),
            })
            .unwrap(),
        ));
        mock_http_client
            .expect_post()
            .with(eq(data_decoder_request))
            .times(1)
            .return_once(move |_| {
                Err(ApiError::from_http_response(&Response {
                    body: "".to_string(),
                    status_code: 422,
                }))
            });
        mock_http_client
    };

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_preview_transaction],
        )
        .await,
    )
    .await
    .expect("Valid rocket instance");

    let request =  client.post("/v1/chains/1/transactions/0x37D94d4E230859f83c0868CebEd8CcB83A765cee/preview")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON)
        .body(&json!({
            "to": "0x37D94d4E230859f83c0868CebEd8CcB83A765cee",
            "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
            "value": "0",
            "operation": 0,
        }).to_string());
    let response = request.dispatch().await;

    let expected =
        serde_json::from_str::<TransactionPreview>(PREVIEW_DATA_DECODED_ERROR_RESPONSE).unwrap();
    let actual_status = response.status();
    let actual =
        serde_json::from_str::<TransactionPreview>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

'''
'''--- src/routes/transactions/tests/routes.rs ---
use crate::common::models::page::Page;
use crate::config::{
    chain_info_request_timeout, contract_info_request_timeout, safe_info_request_timeout,
    token_info_request_timeout, transaction_request_timeout,
};
use crate::providers::info::TokenInfo;
use crate::routes::transactions::models::details::TransactionDetails;
use crate::routes::transactions::tests::{MULTISIG_TX_DETAILS, POST_CONFIRMATION_RESULT};
use crate::tests::main::setup_rocket;
use crate::utils::errors::{ApiError, ErrorDetails};
use crate::utils::http_client::{MockHttpClient, Request, Response};
use core::time::Duration;
use mockall::predicate::eq;
use rocket::http::{ContentType, Header, Status};
use rocket::local::asynchronous::Client;
use serde_json::json;

#[rocket::async_test]
async fn post_confirmation_success() {
    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();

        let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
        chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(chain_request))
            .returning(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
                })
            });

        // CONFIRMATION REQUEST
        let mut backend_request = Request::new(
                "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/multisig-transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/confirmations/"
                .to_string(),
        );
        backend_request.body(Some(json!({"signature": "bd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c"}).to_string()));

        mock_http_client
            .expect_post()
            .times(1)
            .with(eq(backend_request))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 201,
                    body: String::new(),
                })
            });

        // TX DETAILS
        let mut details_request =
            Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/multisig-transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/"));
        details_request.timeout(Duration::from_millis(transaction_request_timeout()));

        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(details_request))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::BACKEND_MULTISIG_TRANSFER_TX),
                })
            });

        // safe info fetch for cancellations
        let mut safe_request = Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/"));
        safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));

        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(safe_request))
            .returning(move |_| {
                Ok(Response {
                    body: String::from(crate::tests::json::SAFE_WITH_MODULES),
                    status_code: 200,
                })
            });

        // Transfer TokenInfo
        let mut token_request = Request::new(String::from(
            "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/tokens/?limit=20000",
        ));
        token_request.timeout(Duration::from_millis(token_info_request_timeout()));
        let page_tokens: Page<TokenInfo> = Page {
            next: None,
            previous: None,
            results: vec![
                serde_json::from_str(crate::tests::json::TOKEN_BAT).expect("BAT token failure")
            ],
        };

        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(token_request))
            .returning(move |_| {
                Ok(Response {
                    body: serde_json::to_string(&page_tokens).expect("Token page failure"),
                    status_code: 200,
                })
            });

        // Catch all calls not relevant to the test
        mock_http_client.expect_get().returning(move |_| {
            Ok(Response {
                status_code: 404,
                body: String::new(),
            })
        });

        mock_http_client
    };

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_confirmation],
        )
        .await,
    )
    .await
    .expect("Valid rocket instance");

    let request =  client.post("/v1/chains/4/transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/confirmations")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON)
        .body(&json!({"signedSafeTxHash":"bd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c"}).to_string());
    let response = request.dispatch().await;

    let expected = serde_json::from_str::<TransactionDetails>(POST_CONFIRMATION_RESULT).unwrap();
    let actual_status = response.status();
    let actual =
        serde_json::from_str::<TransactionDetails>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

#[rocket::async_test]
async fn post_confirmation_confirmation_error() {
    let backend_error_json = json!({"signature": ["Transaction with safe-tx-hash=0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa was already executed"]}).to_string();
    let error = ErrorDetails {
        code: 1337,
        message: Some(backend_error_json.clone()),
        arguments: None,
        debug: None,
    };

    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();

        let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
        chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(chain_request))
            .returning(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
                })
            });

        // CONFIRMATION REQUEST
        let mut backend_request = Request::new(
            "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/multisig-transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/confirmations/"
                .to_string(),
        );
        backend_request.body(Some(json!({"signature": "bd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c"}).to_string()));

        mock_http_client
            .expect_post()
            .times(1)
            .with(eq(backend_request))
            .return_once(move |_| {
                Err(ApiError::from_http_response(&Response {
                    status_code: 400,
                    body: backend_error_json.clone(),
                }))
            });
        mock_http_client
    };
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_confirmation],
        )
        .await,
    )
    .await
    .expect("Valid rocket instance");

    let request =  client.post("/v1/chains/4/transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/confirmations")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON)
        .body(&json!({"signedSafeTxHash":"bd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c"}).to_string());
    let response = request.dispatch().await;
    let status = response.status();
    let body = response.into_string().await.unwrap();

    assert_eq!(status, Status::BadRequest);
    assert_eq!(body, serde_json::to_string(&error).unwrap());
}

#[rocket::async_test]
async fn post_confirmation_confirmation_success_tx_details_error() {
    let backend_error_json = json!({"details": "Not found"}).to_string();
    let error = ErrorDetails {
        code: 1337,
        message: Some(backend_error_json.clone()),
        arguments: None,
        debug: None,
    };

    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();

        let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
        chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(chain_request))
            .returning(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
                })
            });

        // CONFIRMATION REQUEST
        let mut backend_request = Request::new(
            "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/multisig-transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/confirmations/"
                .to_string(),
        );
        backend_request.body(Some(json!({"signature": "bd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c"}).to_string()));

        mock_http_client
            .expect_post()
            .times(1)
            .with(eq(backend_request))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 201,
                    body: String::new(),
                })
            });

        // TX DETAILS
        let mut details_request =
            Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/multisig-transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/"));
        details_request.timeout(Duration::from_millis(transaction_request_timeout()));

        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(details_request))
            .return_once(move |_| {
                Err(ApiError::from_http_response(&Response {
                    status_code: 404,
                    body: backend_error_json.clone(),
                }))
            });

        mock_http_client
    };
    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::post_confirmation],
        )
        .await,
    )
    .await
    .expect("Valid rocket instance");

    let request =  client.post("/v1/chains/4/transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/confirmations")
        .header(Header::new("Host", "test.safe.global"))
        .header(ContentType::JSON)
        .body(&json!({"signedSafeTxHash":"bd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c"}).to_string());
    let response = request.dispatch().await;
    let status = response.status();
    let body = response.into_string().await.unwrap();

    assert_eq!(status, Status::NotFound);
    assert_eq!(body, serde_json::to_string(&error).unwrap());
}

#[rocket::async_test]
#[ignore] // test is flaky so ignoring it until it is fixed
async fn tx_details_multisig_tx_success() {
    let mock_http_client = {
        let mut mock_http_client = MockHttpClient::new();

        let mut chain_request = Request::new(config_uri!("/v1/chains/{}/", 4));
        chain_request.timeout(Duration::from_millis(chain_info_request_timeout()));
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(chain_request))
            .returning(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::CHAIN_INFO_RINKEBY),
                })
            });

        // TransactionDetails
        let mut details_request =
            Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/multisig-transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/"));
        details_request.timeout(Duration::from_millis(transaction_request_timeout()));

        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(details_request))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(crate::tests::json::BACKEND_MULTISIG_TRANSFER_TX),
                })
            });

        // SafeInfo fetch for cancellations
        let mut safe_request = Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/"));
        safe_request.timeout(Duration::from_millis(safe_info_request_timeout()));

        mock_http_client
            .expect_get()
            .times(1) // From FETCHING CANCELLATION AND FROM ENRICHING TX DETAILS
            .with(eq(safe_request))
            .returning(move |_| {
                Ok(Response {
                    body: String::from(crate::tests::json::SAFE_WITH_MODULES),
                    status_code: 200,
                })
            });

        // Gas TokenInfo and Transfer token
        let mut token_request = Request::new(String::from(
            "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/tokens/?limit=10000",
        ));
        token_request.timeout(Duration::from_millis(token_info_request_timeout()));
        let page_tokens: Page<TokenInfo> = Page {
            next: None,
            previous: None,
            results: vec![
                serde_json::from_str(crate::tests::json::TOKEN_BAT).expect("BAT token failure")
            ],
        };

        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(token_request))
            .returning(move |_| {
                Ok(Response {
                    body: serde_json::to_string(&page_tokens).expect("Token page failure"),
                    status_code: 200,
                })
            });

        // Known Addresses
        // the current safe does not get requested as a knownAddress by design
        // The Transfer target gets requested multiple times, but caching reduces it to once
        let mut known_address_request = Request::new(String::from("https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v1/contracts/0xF353eBBa77e5E71c210599236686D51cA1F88b84/"));

        known_address_request.timeout(Duration::from_millis(contract_info_request_timeout()));
        mock_http_client
            .expect_get()
            .times(1)
            .with(eq(known_address_request))
            .return_once(move |_| {
                Ok(Response {
                    status_code: 200,
                    body: String::from(
                        json! ({
                            "address": "0xF353eBBa77e5E71c210599236686D51cA1F88b84",
                            "name": "Transfer target",
                            "displayName": "Transfer target",
                        })
                        .to_string(),
                    ),
                })
            });

        // Catch all calls not relevant to the test
        mock_http_client.expect_get().returning(move |_| {
            Ok(Response {
                status_code: 404,
                body: String::new(),
            })
        });

        mock_http_client
    };

    let client = Client::tracked(
        setup_rocket(
            mock_http_client,
            routes![super::super::routes::get_transactions],
        )
        .await,
    )
    .await
    .expect("Valid rocket instance");

    let request =  client.get("/v1/chains/4/transactions/0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa/")
        .header(Header::new("Host", "test.safe.global"));
    let response = request.dispatch().await;

    let expected = serde_json::from_str::<TransactionDetails>(MULTISIG_TX_DETAILS).unwrap();
    let actual_status = response.status();
    let actual =
        serde_json::from_str::<TransactionDetails>(&response.into_string().await.unwrap()).unwrap();

    assert_eq!(actual_status, Status::Ok);
    assert_eq!(actual, expected);
}

'''
'''--- src/tests/backend_url.rs ---
use crate::common::models::backend::chains::{
    BlockExplorerUriTemplate, ChainInfo, GasPrice, NativeCurrency, RpcAuthentication, RpcUri, Theme,
};
use crate::providers::info::*;
use crate::utils::errors::ApiResult;

#[rocket::async_test]
async fn core_uri_success_with_params_prod() {
    std::env::set_var("VPC_TRANSACTION_SERVICE_URI", "true");
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let trusted = false;
    let exclude_spam = true;
    let chain_info = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.mainnet.safe.global".to_string(),
        vpc_transaction_service: "http://mainnet-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "1".to_string(),
        chain_name: "".to_string(),
        short_name: "eth".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "".to_string(),
            tx_hash: "".to_string(),
            api: "".to_string(),
        },
        native_currency: NativeCurrency {
            name: "".to_string(),
            symbol: "".to_string(),
            decimals: 0,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#fff".to_string(),
            background_color: "#000".to_string(),
        },
        ens_registry_address: None,
        gas_price: vec![GasPrice::Fixed {
            wei_value: "1000000".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .return_once(move || Ok(chain_info));
    let url = core_uri!(
        mock_info_provider,
        "/v1/safes/{}/balances/usd/?trusted={}&exclude_spam={}",
        safe_address,
        trusted,
        exclude_spam
    );

    assert_eq!(url.unwrap(), "http://mainnet-safe-transaction-web.safe.svc.cluster.local/api/v1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/balances/usd/?trusted=false&exclude_spam=true".to_string());
}

#[rocket::async_test]
async fn core_uri_success_without_params_prod() {
    std::env::set_var("VPC_TRANSACTION_SERVICE_URI", "true");
    let chain_info = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.mainnet.safe.global".to_string(),
        vpc_transaction_service: "http://mainnet-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "1".to_string(),
        chain_name: "".to_string(),
        short_name: "eth".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "".to_string(),
            tx_hash: "".to_string(),
            api: "".to_string(),
        },
        native_currency: NativeCurrency {
            name: "".to_string(),
            symbol: "".to_string(),
            decimals: 0,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#fff".to_string(),
            background_color: "#000".to_string(),
        },
        ens_registry_address: None,
        gas_price: vec![GasPrice::Fixed {
            wei_value: "1000000".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .return_once(move || Ok(chain_info));
    let url = core_uri!(mock_info_provider, "/some/path");

    assert_eq!(
        "http://mainnet-safe-transaction-web.safe.svc.cluster.local/api/some/path",
        url.unwrap()
    );
}

#[rocket::async_test]
async fn core_uri_success_with_params_local() {
    std::env::set_var("VPC_TRANSACTION_SERVICE_URI", "false");
    let safe_address = "0x1230B3d59858296A31053C1b8562Ecf89A2f888b";
    let trusted = false;
    let exclude_spam = true;
    let chain_info = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.mainnet.safe.global".to_string(),
        vpc_transaction_service: "http://mainnet-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "1".to_string(),
        chain_name: "".to_string(),
        short_name: "eth".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "".to_string(),
            tx_hash: "".to_string(),
            api: "".to_string(),
        },
        native_currency: NativeCurrency {
            name: "".to_string(),
            symbol: "".to_string(),
            decimals: 0,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#fff".to_string(),
            background_color: "#000".to_string(),
        },
        ens_registry_address: None,
        gas_price: vec![GasPrice::Fixed {
            wei_value: "1000000".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .return_once(move || Ok(chain_info));
    let url = core_uri!(
        mock_info_provider,
        "/v1/safes/{}/balances/usd/?trusted={}&exclude_spam={}",
        safe_address,
        trusted,
        exclude_spam
    );

    assert_eq!(url.unwrap(), "https://safe-transaction.mainnet.safe.global/api/v1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/balances/usd/?trusted=false&exclude_spam=true".to_string());
}

#[rocket::async_test]
async fn core_uri_success_without_params_local() {
    std::env::set_var("VPC_TRANSACTION_SERVICE_URI", "false");
    let chain_info = ChainInfo {
        recommended_master_copy_version: "1.1.1".to_string(),
        transaction_service: "https://safe-transaction.mainnet.safe.global".to_string(),
        vpc_transaction_service: "http://mainnet-safe-transaction-web.safe.svc.cluster.local"
            .to_string(),
        chain_id: "1".to_string(),
        chain_name: "".to_string(),
        short_name: "eth".to_string(),
        l2: false,
        description: "Random description".to_string(),
        rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        safe_apps_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        public_rpc_uri: RpcUri {
            authentication: RpcAuthentication::ApiKeyPath,
            value: "".to_string(),
        },
        block_explorer_uri_template: BlockExplorerUriTemplate {
            address: "".to_string(),
            tx_hash: "".to_string(),
            api: "".to_string(),
        },
        native_currency: NativeCurrency {
            name: "".to_string(),
            symbol: "".to_string(),
            decimals: 0,
            logo_uri: "https://test.token.image.url".to_string(),
        },
        theme: Theme {
            text_color: "#fff".to_string(),
            background_color: "#000".to_string(),
        },
        ens_registry_address: None,
        gas_price: vec![GasPrice::Fixed {
            wei_value: "1000000".to_string(),
        }],
        disabled_wallets: vec![],
        features: vec![],
    };
    let mut mock_info_provider = MockInfoProvider::new();
    mock_info_provider
        .expect_chain_info()
        .times(1)
        .return_once(move || Ok(chain_info));
    let url = core_uri!(mock_info_provider, "/some/path");

    assert_eq!(
        "https://safe-transaction.mainnet.safe.global/api/some/path",
        url.unwrap()
    );
}

#[rocket::async_test]
#[should_panic]
async fn core_uri_error() {
    let mock_info_provider = MockInfoProvider::new();

    let url = core_uri!(mock_info_provider, "/nice/path");
    url.unwrap();
}

'''
'''--- src/tests/json/balances/balance_compound_ether.json ---
{
  "tokenAddress": "0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e",
  "token": {
    "name": "Compound Ether ðŸ“ˆ",
    "symbol": "cETH",
    "decimals": 8,
    "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xd6801a1DfFCd0a410336Ef88DeF4320D6DF1883e.png"
  },
  "balance": "5002",
  "fiatBalance": "0.0014",
  "fiatConversion": "28.5462",
  "fiatCode": "USD"
}

'''
'''--- src/tests/json/balances/balance_ether.json ---
{
  "tokenAddress": null,
  "token": null,
  "balance": "7457594371050000001",
  "fiatBalance": "2523.7991",
  "fiatConversion": "338.42",
  "fiatCode": "USD"
}

'''
'''--- src/tests/json/chains/polygon.json ---
{
  "chainId": "137",
  "chainName": "Polygon",
  "shortName": "matic",
  "description": "Test",
  "l2": true,
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://polygon-mainnet.infura.io/v3/"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://polygon-mainnet.infura.io/v3/"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://polygon-mainnet.infura.io/v3/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://polygonscan.com/address/{{address}}",
    "txHash": "https://polygonscan.com/tx/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "nativeCurrency": {
    "name": "Matic",
    "symbol": "MATIC",
    "decimals": 18,
    "logoUri": "https://safe-transaction-assets.staging.gnosisdev.com/chains/137/currency_logo.png"
  },
  "transactionService": "https://safe-transaction-polygon.staging.gnosisdev.com",
  "vpcTransactionService": "http://staging-polygon-safe-transaction-web.safe.svc.cluster.local",
  "theme": {
    "textColor": "#ffffff",
    "backgroundColor": "#8B50ED"
  },
  "gasPrice": [
    {
      "type": "oracle",
      "uri": "https://gasstation-mainnet.matic.network",
      "gasParameter": "standard",
      "gweiFactor": "1000000000.000000000"
    }
  ],
  "ensRegistryAddress": null,
  "recommendedMasterCopyVersion": "1.3.0",
  "disabledWallets": [],
  "features": []
}

'''
'''--- src/tests/json/chains/rinkeby.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "shortName" : "rin",
  "l2": false,
  "description": "Random description",
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#ffffff",
    "backgroundColor": "#000000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [
    {
      "type": "oracle",
      "uri": "https://gaspriceoracle.com/",
      "gasParameter": "average",
      "gweiFactor": "10"
    }
  ],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [],
  "features": []
}

'''
'''--- src/tests/json/chains/rinkeby_disabled_wallets.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "shortName": "rin",
  "l2": false,
  "description": "Random description",
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#ffffff",
    "backgroundColor": "#000000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [
    {
      "type": "oracle",
      "uri": "https://gaspriceoracle.com/",
      "gasParameter": "average",
      "gweiFactor": "10"
    }
  ],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [
    "metamask",
    "trezor"
  ],
  "features": []
}

'''
'''--- src/tests/json/chains/rinkeby_enabled_features.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "shortName" : "rin",
  "l2": false,
  "description": "Random description",
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#ffffff",
    "backgroundColor": "#000000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [
    {
      "type": "oracle",
      "uri": "https://gaspriceoracle.com/",
      "gasParameter": "average",
      "gweiFactor": "10"
    }
  ],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [],
  "features": ["Feature 1", "Feature 2"]
}

'''
'''--- src/tests/json/chains/rinkeby_fixed_gas_price.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "shortName": "rin",
  "l2": false,
  "description": "Random description",
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#fff",
    "backgroundColor": "#000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [
    {
      "type": "fixed",
      "weiValue": "1000000000"
    }
  ],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [],
  "features": []
}

'''
'''--- src/tests/json/chains/rinkeby_multiple_gas_price.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "shortName": "rin",
  "l2": false,
  "description": "Random description",
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#fff",
    "backgroundColor": "#000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [
    {
      "type": "oracle",
      "uri": "https://gaspriceoracle.com/",
      "gasParameter": "average",
      "gweiFactor": "10"
    },
    {
      "type": "fixed",
      "weiValue": "1000000000"
    }
  ],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [],
  "features": []
}

'''
'''--- src/tests/json/chains/rinkeby_no_gas_price.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "l2": false,
  "shortName": "rin",
  "description": "Random description",
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#fff",
    "backgroundColor": "#000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [],
  "features": []
}

'''
'''--- src/tests/json/chains/rinkeby_rpc_auth_unknown.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "shortName": "rin",
  "l2": false,
  "description": "Random description",
  "rpcUri": {
    "authentication": "SOME_RANDOM_AUTH",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#ffffff",
    "backgroundColor": "#000000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [
    {
      "type": "oracle",
      "uri": "https://gaspriceoracle.com/",
      "gasParameter": "average",
      "gweiFactor": "10"
    }
  ],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [],
  "features": []
}

'''
'''--- src/tests/json/chains/rinkeby_rpc_no_auth.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "shortName": "rin",
  "l2": false,
  "description": "Random description",
  "rpcUri": {
    "authentication": "NO_AUTHENTICATION",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#ffffff",
    "backgroundColor": "#000000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [
    {
      "type": "oracle",
      "uri": "https://gaspriceoracle.com/",
      "gasParameter": "average",
      "gweiFactor": "10"
    }
  ],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [],
  "features": []
}

'''
'''--- src/tests/json/chains/rinkeby_unknown_gas_price.json ---
{
  "chainId": "4",
  "chainName": "Rinkeby",
  "shortName": "rin",
  "l2": false,
  "description": "Random description",
  "rpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc"
  },
  "safeAppsRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/apps"
  },
  "publicRpcUri": {
    "authentication": "API_KEY_PATH",
    "value": "https://someurl.com/rpc/public"
  },
  "blockExplorerUriTemplate": {
    "address": "https://blockexplorer.com/{{address}}",
    "txHash": "https://blockexplorer.com/{{txHash}}",
    "api": "https://blockexplorer.com/api"
  },
  "transactionService": "https://safe-transaction.rinkeby.staging.gnosisdev.com",
  "vpcTransactionService": "http://rinkeby-safe-transaction-web.safe.svc.cluster.local",
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18,
    "logoUri": "https://test.token.image.url"
  },
  "theme": {
    "textColor": "#ffffff",
    "backgroundColor": "#000000"
  },
  "ensRegistryAddress": "0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF",
  "gasPrice": [
    {
      "type": "very fancy oracle",
      "fancyValue": "fancy"
    }
  ],
  "recommendedMasterCopyVersion": "1.1.1",
  "disabledWallets": [],
  "features": []
}

'''
'''--- src/tests/json/collectibles/collectibles_page.json ---
[
    {
        "address": "0x7667A25a327ee97EEc7d5d69F846659238F3c078",
        "tokenName": "Copernicus.20200210.212404",
        "tokenSymbol": "CP",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x7667A25a327ee97EEc7d5d69F846659238F3c078.png",
        "id": "11",
        "uri": "https://projectcopernicus.autonomous-times.com/assets/json/ticket_11.json",
        "name": null,
        "description": null,
        "imageUri": null,
        "metadata": {}
    },
    {
        "address": "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85",
        "tokenName": "Ethereum Name Service",
        "tokenSymbol": "ENS",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png",
        "id": "73759565539416811842765838110575927933836232265069912251972739501781285886854",
        "uri": null,
        "name": "safe1.eth",
        "description": ".eth ENS Domain",
        "imageUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png",
        "metadata": {
            "name": "safe1.eth",
            "description": ".eth ENS Domain",
            "image": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png"
        }
    },
    {
        "address": "0xAad76bea7CFEc82927239415BB18D2e93518ecBB",
        "tokenName": ".crypto",
        "tokenSymbol": "UD",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xAad76bea7CFEc82927239415BB18D2e93518ecBB.png",
        "id": "16901347448092016018370066087420610201854448193660137846183334589211113480159",
        "uri": "https://metadata.staging.unstoppabledomains.com/metadata/udtestdev-361786.crypto",
        "name": "udtestdev-361786.crypto",
        "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
        "imageUri": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
        "metadata": {
            "name": "udtestdev-361786.crypto",
            "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
            "properties": {
                "records": {}
            },
            "externalUrl": "https://unstoppabledomains.com/search?searchTerm=udtestdev-361786.crypto",
            "image": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
            "attributes": [
                {
                    "traitType": "domain",
                    "value": "udtestdev-361786.crypto"
                },
                {
                    "traitType": "level",
                    "value": 2
                },
                {
                    "traitType": "length",
                    "value": 16
                },
                {
                    "traitType": "type",
                    "value": "standard"
                }
            ],
            "imageData": "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"250px\" height=\"250px\" viewBox=\"0 0 250 250\" version=\"1.1\" style=\"background-color:#4C47F7\">\n  <!-- Generator: Sketch 61 (89581) - https://sketch.com -->\n  <title>unstoppabledomains_dot_crypto-</title>\n  <desc>Created with Sketch.</desc>\n  <g id=\"unstoppabledomains\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n      <rect fill=\"#4C47F7\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n      <g id=\"Group-6\" transform=\"translate(70.000000, 154.000000)\">\n          <g id=\"Group\" transform=\"translate(5.000000, 43.000000)\">\n          <rect x=\"0\" y=\"0\" width=\"100\" height=\"34\" stroke=\"#2FE9FF\" stroke-width=\"2.112px\" rx=\"17\"/>\n              <text  dominant-baseline=\"middle\" text-anchor=\"middle\" font-size=\"16\" font-weight=\"bold\" fill=\"#FFFFFF\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\"> <tspan x=\"19%\" y=\"20\">.CRYPTO</tspan></text>\n          </g>\n          <text text-anchor=\"middle\" id=\"domain\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\" font-size=\"24\" font-weight=\"bold\" fill=\"#FFFFFF\">\n              <tspan x=\"22.5%\" y=\"26\">udtestdev-361786</tspan>\n          </text>\n      </g>\n      <g id=\"sign\" transform=\"translate(56.000000, 19.000000)\">\n          <polygon id=\"Rectangle-Copy-3\" fill=\"#2FE9FF\" points=\"137.000268 2.12559903 137.000268 48.8887777 -2.72848394e-13 104.154352\"/>\n          <path d=\"M111.312718,-1.42108539e-14 L111.312718,80.7727631 C111.312718,104.251482 92.1448713,123.284744 68.5001341,123.284744 C44.855397,123.284744 25.6875503,104.251482 25.6875503,80.7727631 L25.6875503,46.7631786 L51.3751006,32.734225 L51.3751006,80.7727631 C51.3751006,88.9903146 58.0838469,95.6519563 66.3595049,95.6519563 C74.6351629,95.6519563 81.3439093,88.9903146 81.3439093,80.7727631 L81.3439093,16.3671125 L111.312718,-1.42108539e-14 Z\" id=\"Path\" fill=\"#FFFFFF\"/>\n      </g>\n  </g>\n</svg>",
            "backgroundColor": "4C47F7"
        }
    },
    {
        "address": "0xAad76bea7CFEc82927239415BB18D2e93518ecBB",
        "tokenName": ".crypto",
        "tokenSymbol": "UD",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xAad76bea7CFEc82927239415BB18D2e93518ecBB.png",
        "id": "65064849277095008645805721699881592934207592453433429843849505605132523369844",
        "uri": "https://metadata.staging.unstoppabledomains.com/metadata/udtestdev-8f3755.crypto",
        "name": "udtestdev-8f3755.crypto",
        "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
        "imageUri": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
        "metadata": {
            "name": "udtestdev-8f3755.crypto",
            "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
            "properties": {
                "records": {}
            },
            "externalUrl": "https://unstoppabledomains.com/search?searchTerm=udtestdev-8f3755.crypto",
            "image": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
            "attributes": [
                {
                    "traitType": "domain",
                    "value": "udtestdev-8f3755.crypto"
                },
                {
                    "traitType": "level",
                    "value": 2
                },
                {
                    "traitType": "length",
                    "value": 16
                },
                {
                    "traitType": "type",
                    "value": "standard"
                }
            ],
            "imageData": "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"250px\" height=\"250px\" viewBox=\"0 0 250 250\" version=\"1.1\" style=\"background-color:#4C47F7\">\n  <!-- Generator: Sketch 61 (89581) - https://sketch.com -->\n  <title>unstoppabledomains_dot_crypto-</title>\n  <desc>Created with Sketch.</desc>\n  <g id=\"unstoppabledomains\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n      <rect fill=\"#4C47F7\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n      <g id=\"Group-6\" transform=\"translate(70.000000, 154.000000)\">\n          <g id=\"Group\" transform=\"translate(5.000000, 43.000000)\">\n          <rect x=\"0\" y=\"0\" width=\"100\" height=\"34\" stroke=\"#2FE9FF\" stroke-width=\"2.112px\" rx=\"17\"/>\n              <text  dominant-baseline=\"middle\" text-anchor=\"middle\" font-size=\"16\" font-weight=\"bold\" fill=\"#FFFFFF\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\"> <tspan x=\"19%\" y=\"20\">.CRYPTO</tspan></text>\n          </g>\n          <text text-anchor=\"middle\" id=\"domain\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\" font-size=\"24\" font-weight=\"bold\" fill=\"#FFFFFF\">\n              <tspan x=\"22.5%\" y=\"26\">udtestdev-8f3755</tspan>\n          </text>\n      </g>\n      <g id=\"sign\" transform=\"translate(56.000000, 19.000000)\">\n          <polygon id=\"Rectangle-Copy-3\" fill=\"#2FE9FF\" points=\"137.000268 2.12559903 137.000268 48.8887777 -2.72848394e-13 104.154352\"/>\n          <path d=\"M111.312718,-1.42108539e-14 L111.312718,80.7727631 C111.312718,104.251482 92.1448713,123.284744 68.5001341,123.284744 C44.855397,123.284744 25.6875503,104.251482 25.6875503,80.7727631 L25.6875503,46.7631786 L51.3751006,32.734225 L51.3751006,80.7727631 C51.3751006,88.9903146 58.0838469,95.6519563 66.3595049,95.6519563 C74.6351629,95.6519563 81.3439093,88.9903146 81.3439093,80.7727631 L81.3439093,16.3671125 L111.312718,-1.42108539e-14 Z\" id=\"Path\" fill=\"#FFFFFF\"/>\n      </g>\n  </g>\n</svg>",
            "backgroundColor": "4C47F7"
        }
    }
]

'''
'''--- src/tests/json/collectibles/collectibles_paginated_empty_cgw.json ---
{   
    "next": null, 
    "previous": null, 
    "results": []
}
'''
'''--- src/tests/json/collectibles/collectibles_paginated_empty_txs.json ---
{   
    "count":0,
    "next": null, 
    "previous": null, 
    "results": []
}
'''
'''--- src/tests/json/collectibles/collectibles_paginated_page_1_cgw.json ---
{
"next": "http://test.safe.global/v2/chains/4/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles?cursor=limit%3D3%26offset%3D3&trusted=false&exclude_spam=true", 
"previous": null, 
"results":[
    {
        "address": "0x7667A25a327ee97EEc7d5d69F846659238F3c078",
        "tokenName": "Copernicus.20200210.212404",
        "tokenSymbol": "CP",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x7667A25a327ee97EEc7d5d69F846659238F3c078.png",
        "id": "11",
        "uri": "https://projectcopernicus.autonomous-times.com/assets/json/ticket_11.json",
        "name": null,
        "description": null,
        "imageUri": null,
        "metadata": {}
    },
    {
        "address": "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85",
        "tokenName": "Ethereum Name Service",
        "tokenSymbol": "ENS",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png",
        "id": "73759565539416811842765838110575927933836232265069912251972739501781285886854",
        "uri": null,
        "name": "safe1.eth",
        "description": ".eth ENS Domain",
        "imageUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png",
        "metadata": {
            "name": "safe1.eth",
            "description": ".eth ENS Domain",
            "image": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png"
        }
    },
    {
        "address": "0xAad76bea7CFEc82927239415BB18D2e93518ecBB",
        "tokenName": ".crypto",
        "tokenSymbol": "UD",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xAad76bea7CFEc82927239415BB18D2e93518ecBB.png",
        "id": "16901347448092016018370066087420610201854448193660137846183334589211113480159",
        "uri": "https://metadata.staging.unstoppabledomains.com/metadata/udtestdev-361786.crypto",
        "name": "udtestdev-361786.crypto",
        "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
        "imageUri": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
        "metadata": {
            "name": "udtestdev-361786.crypto",
            "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
            "properties": {
                "records": {}
            },
            "externalUrl": "https://unstoppabledomains.com/search?searchTerm=udtestdev-361786.crypto",
            "image": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
            "attributes": [
                {
                    "traitType": "domain",
                    "value": "udtestdev-361786.crypto"
                },
                {
                    "traitType": "level",
                    "value": 2
                },
                {
                    "traitType": "length",
                    "value": 16
                },
                {
                    "traitType": "type",
                    "value": "standard"
                }
            ],
            "imageData": "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"250px\" height=\"250px\" viewBox=\"0 0 250 250\" version=\"1.1\" style=\"background-color:#4C47F7\">\n  <!-- Generator: Sketch 61 (89581) - https://sketch.com -->\n  <title>unstoppabledomains_dot_crypto-</title>\n  <desc>Created with Sketch.</desc>\n  <g id=\"unstoppabledomains\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n      <rect fill=\"#4C47F7\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n      <g id=\"Group-6\" transform=\"translate(70.000000, 154.000000)\">\n          <g id=\"Group\" transform=\"translate(5.000000, 43.000000)\">\n          <rect x=\"0\" y=\"0\" width=\"100\" height=\"34\" stroke=\"#2FE9FF\" stroke-width=\"2.112px\" rx=\"17\"/>\n              <text  dominant-baseline=\"middle\" text-anchor=\"middle\" font-size=\"16\" font-weight=\"bold\" fill=\"#FFFFFF\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\"> <tspan x=\"19%\" y=\"20\">.CRYPTO</tspan></text>\n          </g>\n          <text text-anchor=\"middle\" id=\"domain\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\" font-size=\"24\" font-weight=\"bold\" fill=\"#FFFFFF\">\n              <tspan x=\"22.5%\" y=\"26\">udtestdev-361786</tspan>\n          </text>\n      </g>\n      <g id=\"sign\" transform=\"translate(56.000000, 19.000000)\">\n          <polygon id=\"Rectangle-Copy-3\" fill=\"#2FE9FF\" points=\"137.000268 2.12559903 137.000268 48.8887777 -2.72848394e-13 104.154352\"/>\n          <path d=\"M111.312718,-1.42108539e-14 L111.312718,80.7727631 C111.312718,104.251482 92.1448713,123.284744 68.5001341,123.284744 C44.855397,123.284744 25.6875503,104.251482 25.6875503,80.7727631 L25.6875503,46.7631786 L51.3751006,32.734225 L51.3751006,80.7727631 C51.3751006,88.9903146 58.0838469,95.6519563 66.3595049,95.6519563 C74.6351629,95.6519563 81.3439093,88.9903146 81.3439093,80.7727631 L81.3439093,16.3671125 L111.312718,-1.42108539e-14 Z\" id=\"Path\" fill=\"#FFFFFF\"/>\n      </g>\n  </g>\n</svg>",
            "backgroundColor": "4C47F7"
        }
    }
]
}
'''
'''--- src/tests/json/collectibles/collectibles_paginated_page_1_txs.json ---
{
"count": 4, 
"next": "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v2/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles/?limit=3&offset=3&trusted=false&exclude_spam=true", 
"previous": null, 
"results":[
    {
        "address": "0x7667A25a327ee97EEc7d5d69F846659238F3c078",
        "tokenName": "Copernicus.20200210.212404",
        "tokenSymbol": "CP",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x7667A25a327ee97EEc7d5d69F846659238F3c078.png",
        "id": "11",
        "uri": "https://projectcopernicus.autonomous-times.com/assets/json/ticket_11.json",
        "name": null,
        "description": null,
        "imageUri": null,
        "metadata": {}
    },
    {
        "address": "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85",
        "tokenName": "Ethereum Name Service",
        "tokenSymbol": "ENS",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png",
        "id": "73759565539416811842765838110575927933836232265069912251972739501781285886854",
        "uri": null,
        "name": "safe1.eth",
        "description": ".eth ENS Domain",
        "imageUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png",
        "metadata": {
            "name": "safe1.eth",
            "description": ".eth ENS Domain",
            "image": "https://gnosis-safe-token-logos.s3.amazonaws.com/ENS.png"
        }
    },
    {
        "address": "0xAad76bea7CFEc82927239415BB18D2e93518ecBB",
        "tokenName": ".crypto",
        "tokenSymbol": "UD",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xAad76bea7CFEc82927239415BB18D2e93518ecBB.png",
        "id": "16901347448092016018370066087420610201854448193660137846183334589211113480159",
        "uri": "https://metadata.staging.unstoppabledomains.com/metadata/udtestdev-361786.crypto",
        "name": "udtestdev-361786.crypto",
        "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
        "imageUri": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
        "metadata": {
            "name": "udtestdev-361786.crypto",
            "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
            "properties": {
                "records": {}
            },
            "externalUrl": "https://unstoppabledomains.com/search?searchTerm=udtestdev-361786.crypto",
            "image": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
            "attributes": [
                {
                    "traitType": "domain",
                    "value": "udtestdev-361786.crypto"
                },
                {
                    "traitType": "level",
                    "value": 2
                },
                {
                    "traitType": "length",
                    "value": 16
                },
                {
                    "traitType": "type",
                    "value": "standard"
                }
            ],
            "imageData": "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"250px\" height=\"250px\" viewBox=\"0 0 250 250\" version=\"1.1\" style=\"background-color:#4C47F7\">\n  <!-- Generator: Sketch 61 (89581) - https://sketch.com -->\n  <title>unstoppabledomains_dot_crypto-</title>\n  <desc>Created with Sketch.</desc>\n  <g id=\"unstoppabledomains\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n      <rect fill=\"#4C47F7\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n      <g id=\"Group-6\" transform=\"translate(70.000000, 154.000000)\">\n          <g id=\"Group\" transform=\"translate(5.000000, 43.000000)\">\n          <rect x=\"0\" y=\"0\" width=\"100\" height=\"34\" stroke=\"#2FE9FF\" stroke-width=\"2.112px\" rx=\"17\"/>\n              <text  dominant-baseline=\"middle\" text-anchor=\"middle\" font-size=\"16\" font-weight=\"bold\" fill=\"#FFFFFF\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\"> <tspan x=\"19%\" y=\"20\">.CRYPTO</tspan></text>\n          </g>\n          <text text-anchor=\"middle\" id=\"domain\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\" font-size=\"24\" font-weight=\"bold\" fill=\"#FFFFFF\">\n              <tspan x=\"22.5%\" y=\"26\">udtestdev-361786</tspan>\n          </text>\n      </g>\n      <g id=\"sign\" transform=\"translate(56.000000, 19.000000)\">\n          <polygon id=\"Rectangle-Copy-3\" fill=\"#2FE9FF\" points=\"137.000268 2.12559903 137.000268 48.8887777 -2.72848394e-13 104.154352\"/>\n          <path d=\"M111.312718,-1.42108539e-14 L111.312718,80.7727631 C111.312718,104.251482 92.1448713,123.284744 68.5001341,123.284744 C44.855397,123.284744 25.6875503,104.251482 25.6875503,80.7727631 L25.6875503,46.7631786 L51.3751006,32.734225 L51.3751006,80.7727631 C51.3751006,88.9903146 58.0838469,95.6519563 66.3595049,95.6519563 C74.6351629,95.6519563 81.3439093,88.9903146 81.3439093,80.7727631 L81.3439093,16.3671125 L111.312718,-1.42108539e-14 Z\" id=\"Path\" fill=\"#FFFFFF\"/>\n      </g>\n  </g>\n</svg>",
            "backgroundColor": "4C47F7"
        }
    }
]
}
'''
'''--- src/tests/json/collectibles/collectibles_paginated_page_2_cgw.json ---
{
    "next": null, 
    "previous": "http://test.safe.global/v2/chains/4/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles?cursor=limit%3D3%26offset%3D0&trusted=false&exclude_spam=true", 
    "results":
    [
    {
        "address": "0xAad76bea7CFEc82927239415BB18D2e93518ecBB",
        "tokenName": ".crypto",
        "tokenSymbol": "UD",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xAad76bea7CFEc82927239415BB18D2e93518ecBB.png",
        "id": "65064849277095008645805721699881592934207592453433429843849505605132523369844",
        "uri": "https://metadata.staging.unstoppabledomains.com/metadata/udtestdev-8f3755.crypto",
        "name": "udtestdev-8f3755.crypto",
        "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
        "imageUri": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
        "metadata": {
            "name": "udtestdev-8f3755.crypto",
            "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
            "properties": {
                "records": {}
            },
            "externalUrl": "https://unstoppabledomains.com/search?searchTerm=udtestdev-8f3755.crypto",
            "image": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
            "attributes": [
                {
                    "traitType": "domain",
                    "value": "udtestdev-8f3755.crypto"
                },
                {
                    "traitType": "level",
                    "value": 2
                },
                {
                    "traitType": "length",
                    "value": 16
                },
                {
                    "traitType": "type",
                    "value": "standard"
                }
            ],
            "imageData": "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"250px\" height=\"250px\" viewBox=\"0 0 250 250\" version=\"1.1\" style=\"background-color:#4C47F7\">\n  <!-- Generator: Sketch 61 (89581) - https://sketch.com -->\n  <title>unstoppabledomains_dot_crypto-</title>\n  <desc>Created with Sketch.</desc>\n  <g id=\"unstoppabledomains\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n      <rect fill=\"#4C47F7\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n      <g id=\"Group-6\" transform=\"translate(70.000000, 154.000000)\">\n          <g id=\"Group\" transform=\"translate(5.000000, 43.000000)\">\n          <rect x=\"0\" y=\"0\" width=\"100\" height=\"34\" stroke=\"#2FE9FF\" stroke-width=\"2.112px\" rx=\"17\"/>\n              <text  dominant-baseline=\"middle\" text-anchor=\"middle\" font-size=\"16\" font-weight=\"bold\" fill=\"#FFFFFF\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\"> <tspan x=\"19%\" y=\"20\">.CRYPTO</tspan></text>\n          </g>\n          <text text-anchor=\"middle\" id=\"domain\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\" font-size=\"24\" font-weight=\"bold\" fill=\"#FFFFFF\">\n              <tspan x=\"22.5%\" y=\"26\">udtestdev-8f3755</tspan>\n          </text>\n      </g>\n      <g id=\"sign\" transform=\"translate(56.000000, 19.000000)\">\n          <polygon id=\"Rectangle-Copy-3\" fill=\"#2FE9FF\" points=\"137.000268 2.12559903 137.000268 48.8887777 -2.72848394e-13 104.154352\"/>\n          <path d=\"M111.312718,-1.42108539e-14 L111.312718,80.7727631 C111.312718,104.251482 92.1448713,123.284744 68.5001341,123.284744 C44.855397,123.284744 25.6875503,104.251482 25.6875503,80.7727631 L25.6875503,46.7631786 L51.3751006,32.734225 L51.3751006,80.7727631 C51.3751006,88.9903146 58.0838469,95.6519563 66.3595049,95.6519563 C74.6351629,95.6519563 81.3439093,88.9903146 81.3439093,80.7727631 L81.3439093,16.3671125 L111.312718,-1.42108539e-14 Z\" id=\"Path\" fill=\"#FFFFFF\"/>\n      </g>\n  </g>\n</svg>",
            "backgroundColor": "4C47F7"
        }
    }
    ]
}
'''
'''--- src/tests/json/collectibles/collectibles_paginated_page_2_txs.json ---
{
    "count": 4,
    "next": null, 
    "previous": "https://safe-transaction.rinkeby.staging.gnosisdev.com/api/v2/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/collectibles/?limit=3&offset=0&trusted=false&exclude_spam=true", 
    "results":
    [
    {
        "address": "0xAad76bea7CFEc82927239415BB18D2e93518ecBB",
        "tokenName": ".crypto",
        "tokenSymbol": "UD",
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xAad76bea7CFEc82927239415BB18D2e93518ecBB.png",
        "id": "65064849277095008645805721699881592934207592453433429843849505605132523369844",
        "uri": "https://metadata.staging.unstoppabledomains.com/metadata/udtestdev-8f3755.crypto",
        "name": "udtestdev-8f3755.crypto",
        "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
        "imageUri": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
        "metadata": {
            "name": "udtestdev-8f3755.crypto",
            "description": "A CNS or UNS blockchain domain. Use it to resolve your cryptocurrency addresses and decentralized websites.",
            "properties": {
                "records": {}
            },
            "externalUrl": "https://unstoppabledomains.com/search?searchTerm=udtestdev-8f3755.crypto",
            "image": "https://storage.googleapis.com/dot-crypto-metadata-api/images/unstoppabledomains.svg",
            "attributes": [
                {
                    "traitType": "domain",
                    "value": "udtestdev-8f3755.crypto"
                },
                {
                    "traitType": "level",
                    "value": 2
                },
                {
                    "traitType": "length",
                    "value": 16
                },
                {
                    "traitType": "type",
                    "value": "standard"
                }
            ],
            "imageData": "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"250px\" height=\"250px\" viewBox=\"0 0 250 250\" version=\"1.1\" style=\"background-color:#4C47F7\">\n  <!-- Generator: Sketch 61 (89581) - https://sketch.com -->\n  <title>unstoppabledomains_dot_crypto-</title>\n  <desc>Created with Sketch.</desc>\n  <g id=\"unstoppabledomains\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n      <rect fill=\"#4C47F7\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n      <g id=\"Group-6\" transform=\"translate(70.000000, 154.000000)\">\n          <g id=\"Group\" transform=\"translate(5.000000, 43.000000)\">\n          <rect x=\"0\" y=\"0\" width=\"100\" height=\"34\" stroke=\"#2FE9FF\" stroke-width=\"2.112px\" rx=\"17\"/>\n              <text  dominant-baseline=\"middle\" text-anchor=\"middle\" font-size=\"16\" font-weight=\"bold\" fill=\"#FFFFFF\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\"> <tspan x=\"19%\" y=\"20\">.CRYPTO</tspan></text>\n          </g>\n          <text text-anchor=\"middle\" id=\"domain\" font-family=\"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Oxygen, Cantarell, sans-serif\" font-size=\"24\" font-weight=\"bold\" fill=\"#FFFFFF\">\n              <tspan x=\"22.5%\" y=\"26\">udtestdev-8f3755</tspan>\n          </text>\n      </g>\n      <g id=\"sign\" transform=\"translate(56.000000, 19.000000)\">\n          <polygon id=\"Rectangle-Copy-3\" fill=\"#2FE9FF\" points=\"137.000268 2.12559903 137.000268 48.8887777 -2.72848394e-13 104.154352\"/>\n          <path d=\"M111.312718,-1.42108539e-14 L111.312718,80.7727631 C111.312718,104.251482 92.1448713,123.284744 68.5001341,123.284744 C44.855397,123.284744 25.6875503,104.251482 25.6875503,80.7727631 L25.6875503,46.7631786 L51.3751006,32.734225 L51.3751006,80.7727631 C51.3751006,88.9903146 58.0838469,95.6519563 66.3595049,95.6519563 C74.6351629,95.6519563 81.3439093,88.9903146 81.3439093,80.7727631 L81.3439093,16.3671125 L111.312718,-1.42108539e-14 Z\" id=\"Path\" fill=\"#FFFFFF\"/>\n      </g>\n  </g>\n</svg>",
            "backgroundColor": "4C47F7"
        }
    }
    ]
}
'''
'''--- src/tests/json/commons/DOCTORED_data_decoded_multi_send_nested_delegate.json ---
{
  "method": "multiSend",
  "parameters": [
    {
      "name": "transactions",
      "type": "bytes",
      "value": "0x00d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c6800000d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c6800000d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
      "valueDecoded": [
        {
          "operation": 0,
          "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
          "value": "0",
          "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
          "dataDecoded": {
            "method": "transfer",
            "parameters": [
              {
                "name": "to",
                "type": "address",
                "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
              },
              {
                "name": "value",
                "type": "uint256",
                "value": "1000000000000000"
              }
            ]
          }
        },
        {
          "operation": 1,
          "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
          "value": "0",
          "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
          "dataDecoded": {
            "method": "transfer",
            "parameters": [
              {
                "name": "to",
                "type": "address",
                "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
              },
              {
                "name": "value",
                "type": "uint256",
                "value": "1000000000000000"
              }
            ]
          }
        },
        {
          "operation": 0,
          "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
          "value": "0",
          "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
          "dataDecoded": {
            "method": "transfer",
            "parameters": [
              {
                "name": "to",
                "type": "address",
                "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
              },
              {
                "name": "value",
                "type": "uint256",
                "value": "1000000000000000"
              }
            ]
          }
        }
      ]
    }
  ]
}
'''
'''--- src/tests/json/commons/DOCTORED_data_decoded_nested_multi_sends.json ---
{
  "method": "multiSend",
  "parameters": [
    {
      "name": "transactions",
      "type": "bytes",
      "value": "0x0084fd13abadf6f5f6c20f5482f264b71f353cc22d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb00000000000000000000000084fd13abadf6f5f6c20f5482f264b71f353cc22d0000000000000000000000000000000000000000000000000000000000bc614e0068881260bd04e9dac7f77a314360ce05435b4818000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e48d80ff0a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000990084fd13abadf6f5f6c20f5482f264b71f353cc22d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb00000000000000000000000084fd13abadf6f5f6c20f5482f264b71f353cc22d0000000000000000000000000000000000000000000000000000000000bc614e00000000000000",
      "valueDecoded": [
        {
          "operation": 0,
          "to": "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
          "value": "0",
          "data": "0xa9059cbb00000000000000000000000084fd13abadf6f5f6c20f5482f264b71f353cc22d0000000000000000000000000000000000000000000000000000000000bc614e",
          "dataDecoded": {
            "method": "transfer",
            "parameters": [
              {
                "name": "to",
                "type": "address",
                "value": "0x991c44331f0E59510Bcff76edBA06C3f552Eef8B"
              },
              {
                "name": "value",
                "type": "uint256",
                "value": "12345678"
              }
            ]
          }
        },
        {
          "operation": 0,
          "to": "0x68881260bd04E9dAc7F77a314360ce05435B4818",
          "value": "0",
          "data": "0x8d80ff0a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000990084fd13abadf6f5f6c20f5482f264b71f353cc22d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb00000000000000000000000084fd13abadf6f5f6c20f5482f264b71f353cc22d0000000000000000000000000000000000000000000000000000000000bc614e00000000000000",
          "dataDecoded": {
            "method": "multiSend",
            "parameters": [
              {
                "name": "transactions",
                "type": "bytes",
                "value": "0x0084fd13abadf6f5f6c20f5482f264b71f353cc22d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb00000000000000000000000084fd13abadf6f5f6c20f5482f264b71f353cc22d0000000000000000000000000000000000000000000000000000000000bc614e",
                "valueDecoded": [
                  {
                    "operation": 0,
                    "to": "0x84fd13aBadF6F5F6c20F5482F264b71F353cc22d",
                    "value": "0",
                    "data": "0xa9059cbb00000000000000000000000084fd13abadf6f5f6c20f5482f264b71f353cc22d0000000000000000000000000000000000000000000000000000000000bc614e",
                    "dataDecoded": {
                      "method": "transfer",
                      "parameters": [
                        {
                          "name": "to",
                          "type": "address",
                          "value": "0x84fd13aBadF6F5F6c20F5482F264b71F353cc22d"
                        },
                        {
                          "name": "value",
                          "type": "uint256",
                          "value": "12345678"
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          }
        }
      ]
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_add_owner_with_threshold.json ---
{
  "method": "addOwnerWithThreshold",
  "parameters": [
    {
      "name": "owner",
      "type": "address",
      "value": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"
    },
    {
      "name": "_threshold",
      "type": "uint256",
      "value": "1"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_approve.json ---
{
    "method": "approve",
    "parameters": [
        {
            "name": "spender",
            "type": "address",
            "value": "0xae9844F89D98c150F5e61bfC676D68b492155990"
        },
        {
            "name": "value",
            "type": "uint256",
            "value": "500000000000000"
        }
    ]
}

'''
'''--- src/tests/json/commons/data_decoded_change_master_copy.json ---
{
  "method": "changeMasterCopy",
  "parameters": [
    {
      "name": "_masterCopy",
      "type": "address",
      "value": "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_change_threshold.json ---
{
  "method": "changeThreshold",
  "parameters": [
    {
      "name": "_threshold",
      "type": "uint256",
      "value": "2"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_delete_guard.json ---
{
  "method": "setGuard",
  "parameters": [
    {
      "name": "guard",
      "type": "address",
      "value": "0x0000000000000000000000000000000000000000"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_disable_module.json ---
{
  "method": "disableModule",
  "parameters": [
    {
      "name": "prevModule",
      "type": "address",
      "value": "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d"
    },
    {
      "name": "module",
      "type": "address",
      "value": "0x25F73b24B866963B0e560fFF9bbA7908be0263E8"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_enable_module.json ---
{
  "method": "enableModule",
  "parameters": [
    {
      "name": "module",
      "type": "address",
      "value": "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_exec_transaction_from_module.json ---
{
  "method": "execTransactionFromModule",
  "parameters": [
    {
      "name": "to",
      "type": "address",
      "value": "0x08c841202D77513d0865Fbae847cBc2e1DDe3912"
    },
    {
      "name": "value",
      "type": "uint256",
      "value": "1"
    },
    {
      "name": "data",
      "type": "bytes",
      "value": "0x00"
    },
    {
      "name": "operation",
      "type": "uint8",
      "value": "1"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_multi_send.json ---
{
  "method": "multiSend",
  "parameters": [
    {
      "name": "transactions",
      "type": "bytes",
      "value": "0x00d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c6800000d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c6800000d9ba894e0097f8cc2bbc9d24d308b98e36dc6d0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
      "valueDecoded": [
        {
          "operation": 0,
          "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
          "value": "0",
          "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
          "dataDecoded": {
            "method": "transfer",
            "parameters": [
              {
                "name": "to",
                "type": "address",
                "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
              },
              {
                "name": "value",
                "type": "uint256",
                "value": "1000000000000000"
              }
            ]
          }
        },
        {
          "operation": 0,
          "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
          "value": "0",
          "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
          "dataDecoded": {
            "method": "transfer",
            "parameters": [
              {
                "name": "to",
                "type": "address",
                "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
              },
              {
                "name": "value",
                "type": "uint256",
                "value": "1000000000000000"
              }
            ]
          }
        },
        {
          "operation": 0,
          "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
          "value": "0",
          "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e764430000000000000000000000000000000000000000000000000000038d7ea4c68000",
          "dataDecoded": {
            "method": "transfer",
            "parameters": [
              {
                "name": "to",
                "type": "address",
                "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
              },
              {
                "name": "value",
                "type": "uint256",
                "value": "1000000000000000"
              }
            ]
          }
        }
      ]
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_multi_send_single_inner_transaction.json ---
{
  "method": "multiSend",
  "parameters": [
    {
      "name": "transactions",
      "type": "bytes",
      "value": "0x00111111125434b319222cdbf8c261674adb56f3ae000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000b8490411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "valueDecoded": [
        {
          "operation": 0,
          "to": "0x111111125434b319222CdBf8C261674aDB56F3ae",
          "value": "22",
          "data": "0x90411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
          "dataDecoded": {
            "method": "swap",
            "parameters": [
              {
                "name": "caller",
                "type": "address",
                "value": "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5"
              },
              {
                "name": "desc",
                "type": "(address,address,address,address,uint256,uint256,uint256,uint256,address,bytes)",
                "value": [
                  "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
                  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
                  "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5",
                  "0xBc79855178842FDBA0c353494895DEEf509E26bB",
                  "70000000000000000000000",
                  "69930000000000000000000",
                  "70000000000000000000000",
                  "1",
                  "0x0000000000000000000000000000000000000000",
                  "0x"
                ]
              },
              {
                "name": "calls",
                "type": "(uint256,uint256,uint256,bytes)[]",
                "value": [
                  [
                    "0",
                    "0",
                    "0",
                    "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                  ],
                  [
                    "0",
                    "0",
                    "0",
                    "0x7f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000"
                  ],
                  [
                    "0",
                    "0",
                    "0",
                    "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000"
                  ]
                ]
              }
            ]
          }
        }
      ]
    }
  ]
}

'''
'''--- src/tests/json/commons/data_decoded_nested_safe_interaction.json ---
{
  "method": "execTransaction",
  "parameters": [
    {
      "name": "to",
      "type": "address",
      "value": "0x441E604Ad49602c0B9C0B08D0781eCF96740786a"
    },
    {
      "name": "value",
      "type": "uint256",
      "value": "0"
    },
    {
      "name": "data",
      "type": "bytes",
      "value": "0x610b592500000000000000000000000034cfac646f301356faa8b21e94227e3583fe3f5f",
      "decodedValue": {
        "method": "enableModule",
        "parameters": [
          {
            "name": "module",
            "type": "address",
            "value": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F"
          }
        ]
      }
    },
    {
      "name": "operation",
      "type": "uint8",
      "value": "0"
    },
    {
      "name": "safeTxGas",
      "type": "uint256",
      "value": "53036"
    },
    {
      "name": "baseGas",
      "type": "uint256",
      "value": "0"
    },
    {
      "name": "gasPrice",
      "type": "uint256",
      "value": "0"
    },
    {
      "name": "gasToken",
      "type": "address",
      "value": "0x0000000000000000000000000000000000000000"
    },
    {
      "name": "refundReceiver",
      "type": "address",
      "value": "0x0000000000000000000000000000000000000000"
    },
    {
      "name": "signatures",
      "type": "bytes",
      "value": "0x0000000000000000000000000e24b6e3beff0b44b773f068343bc2cb56cb37690000000000000000000000000000000000000000000000000000000000000000017e86d3185b70c297e33c7691d537fb9f11601ceb3a34f3c7b50fc7a3086380451c0924eac2e1bdd9cab77a96ced513f4c9df0432a19e9b61859261cdfb7dd6b41b"
    }
  ]
}

'''
'''--- src/tests/json/commons/data_decoded_remove_owner.json ---
{
  "method": "removeOwner",
  "parameters": [
    {
      "name": "prevOwner",
      "type": "address",
      "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
    },
    {
      "name": "owner",
      "type": "address",
      "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
    },
    {
      "name": "_threshold",
      "type": "uint256",
      "value": "2"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_set_fallback_handler.json ---
{
  "method": "setFallbackHandler",
  "parameters": [
    {
      "name": "handler",
      "type": "address",
      "value": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_set_guard.json ---
{
  "method": "setGuard",
  "parameters": [
    {
      "name": "guard",
      "type": "address",
      "value": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"
    }
  ]
}
'''
'''--- src/tests/json/commons/data_decoded_swap_array_values.json ---
{
  "method": "swap",
  "parameters": [
    {
      "name": "caller",
      "type": "address",
      "value": "0x4FB84d2dFc50017aFa759107a389759c8fD077DE"
    },
    {
      "name": "desc",
      "type": "(address,address,address,address,uint256,uint256,uint256,uint256,address,bytes)",
      "value": [
        "0x111111111117dC0aa78b770fA6A738034120C302",
        "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
        "0x4FB84d2dFc50017aFa759107a389759c8fD077DE",
        "0xBc79855178842FDBA0c353494895DEEf509E26bB",
        "176496751099219826953162",
        "265828469917010058452",
        "274049968986608307683",
        "5",
        "0x991c44331f0E59510Bcff76edBA06C3f552Eef8B",
        "0x"
      ]
    },
    {
      "name": "calls",
      "type": "(uint256,uint256,uint256,bytes)[]",
      "value": [
        [
          "0",
          "0",
          "0",
          "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000000000010000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000e245636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de00000000000000000000000000000000000000000000000170d99f3dc0072e7a000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000005e0000000000000000000000000000000000000000000000000000000000000074000000000000000000000000000000000000000000000000000000000000009a00000000000000000000000000000000000000000000000000000000000000b0080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064eb5625d9000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000b11773ea2c7b9586d9efa1438ce95aba22595a7e0000000000000000000000000000000000000000000003bcca72307cd142c79400000000000000000000000000000000000000000000000000000000800000000000000000000000b11773ea2c7b9586d9efa1438ce95aba22595a7e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c4e331d039000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000000000000003bcca72307cd142c7940000000000000000000000000000000000000000000000000000000000000001000000000000000000000000910bf2d50fa5e014fd06666f456182d4ab7c8bd20000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001a4b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000070000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064d1660f99000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000074c99f3f5331676f6aec2756e1f39b4fc029a83e00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a4c9f12e9d00000000000000000000000074c99f3f5331676f6aec2756e1f39b4fc029a83e000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000034fb84d2dfc50017afa759107a389759c8fd077de000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001a4b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000d0000000000000000000000000000000d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064d1660f99000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000006da0fd433c1a5d7a4faa01111c044910a18455300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a4c9f12e9d00000000000000000000000006da0fd433c1a5d7a4faa01111c044910a184553000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000034fb84d2dfc50017afa759107a389759c8fd077de00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000164b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000004000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000001400000000000000000000000000000014000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000242e1a7d4d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ],
        [
          "0",
          "0",
          "0",
          "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000000000010000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000ca45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de0000000000000000000000000000000000000000000000017229c2c2a7d5e0860000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000980800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003e483f1291f00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000380000000000000000000000000111111111117dc0aa78b770fa6a738034120c30200000000000000000000000000000014000000000000000000000000000000b400000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064eb5625d9000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000caa6361e4ad457b8f2e78a44662b0de3df646fd3000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000800000000000000000000000caa6361e4ad457b8f2e78a44662b0de3df646fd300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c4e331d039000000000000000000000000111111111117dc0aa78b770fa6a738034120c3020000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c59900000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000910bf2d50fa5e014fd06666f456182d4ab7c8bd20000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000044800000000000000000000000000000000000000000000000000000000000004400000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003c483f1291f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003600000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000000000140000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064eb5625d90000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000001eff8af5d577060ba4ac8a29a13525bb0ee2a3d50000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000008000000000000000000000001eff8af5d577060ba4ac8a29a13525bb0ee2a3d500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a48201aa3f0000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000004480000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000164b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000004000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000001400000000000000000000000000000014000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000242e1a7d4d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ],
        [
          "0",
          "0",
          "0",
          "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000000000010000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000ca45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de0000000000000000000000000000000000000000000000016e0dc5e6f97ad5390000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000980800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003e483f1291f00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000380000000000000000000000000111111111117dc0aa78b770fa6a738034120c30200000000000000000000000000000014000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064eb5625d9000000000000000000000000111111111117dc0aa78b770fa6a738034120c3020000000000000000000000002c6264619d2f598a003d1c857e46edb95b22c75c0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000008000000000000000000000002c6264619d2f598a003d1c857e46edb95b22c75c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c4e331d039000000000000000000000000111111111117dc0aa78b770fa6a738034120c3020000000000000000000000006b175474e89094c44da98b954eedeac495271d0f00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000910bf2d50fa5e014fd06666f456182d4ab7c8bd20000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000044800000000000000000000000000000000000000000000000000000000000004400000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003c483f1291f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003600000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000000000140000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064eb5625d90000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000007afe74ae3c19f070c109a38c286684256adc656c0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000008000000000000000000000007afe74ae3c19f070c109a38c286684256adc656c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a48201aa3f0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000004480000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000164b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000004000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000001400000000000000000000000000000014000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000242e1a7d4d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ],
        [
          "0",
          "0",
          "0",
          "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000000000020000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000be45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de000000000000000000000000000000000000000000000002e65efb8c32861700000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000520000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000008c0800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003e483f1291f00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000380000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000000000280000000000000000000000000000008c00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064eb5625d9000000000000000000000000111111111117dc0aa78b770fa6a738034120c30200000000000000000000000029305f0e37e65c4d5d36466826237a59b5baf2e300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000080000000000000000000000029305f0e37e65c4d5d36466826237a59b5baf2e300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c4e331d039000000000000000000000000111111111117dc0aa78b770fa6a738034120c3020000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000910bf2d50fa5e014fd06666f456182d4ab7c8bd20000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000004480000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c0000000000000000000000000000000000000000000000000000000000000008080000000000000000000000000000000000000000000000000000000000000240000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e00000000000000000000000000000014000000000000000000000000000000140000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000088ee5007c98a9677165d78dd2109ae4a3d04d0c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a4c9f12e9d000000000000000000000000088ee5007c98a9677165d78dd2109ae4a3d04d0c0000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000034fb84d2dfc50017afa759107a389759c8fd077de00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000164b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000004000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000001400000000000000000000000000000014000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000242e1a7d4d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ],
        [
          "0",
          "0",
          "0",
          "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000000000020000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000fc45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de000000000000000000000000000000000000000000000002e051ade664fe5e0b000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000056000000000000000000000000000000000000000000000000000000000000007a000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000b400000000000000000000000000000000000000000000000000000000000000ca0800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003e483f1291f00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000380000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000000000280000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064eb5625d9000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000a09d1afae21bda81c06fd6de9bbd7c7ed7b6dfb1000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000800000000000000000000000a09d1afae21bda81c06fd6de9bbd7c7ed7b6dfb100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c4e331d039000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000910bf2d50fa5e014fd06666f456182d4ab7c8bd20000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000004480000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000300000000000000000000000000000014000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb0000000000000000000000003aa370aacf4cb08c7e1e7aa8e8ff9418d73c7e0f00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a4c9f12e9d0000000000000000000000003aa370aacf4cb08c7e1e7aa8e8ff9418d73c7e0f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000034fb84d2dfc50017afa759107a389759c8fd077de00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000001100000000000000000000000000000011000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000397ff1542f962076d0bfe58ea045ffa2d347aca000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a4c9f12e9d000000000000000000000000397ff1542f962076d0bfe58ea045ffa2d347aca0000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000034fb84d2dfc50017afa759107a389759c8fd077de00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000164b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000004000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000001400000000000000000000000000000014000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000242e1a7d4d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ],
        [
          "0",
          "0",
          "0",
          "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000111111111117dc0aa78b770fa6a738034120c3020000000000000000000000000000000300000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000005c45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de000000000000000000000000000000000000000000000004515a9f9e5423038c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000003e483f1291f00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000380000000000000000000000000111111111117dc0aa78b770fa6a738034120c3020000000000000000000000000000003c0000000000000000000000000000003c00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000016080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064eb5625d9000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000812b40c2ca7fabbac756475593fc8b1c313434fa000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000800000000000000000000000812b40c2ca7fabbac756475593fc8b1c313434fa00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c4e331d039000000000000000000000000111111111117dc0aa78b770fa6a738034120c302000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000910bf2d50fa5e014fd06666f456182d4ab7c8bd20000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000004480000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        ],
        [
          "0",
          "0",
          "0",
          "0x7f8fe7a0000000000000000000000000000000000000000000000000000000000000008080000000000000000000000000000000000000000000000000000000000000440000000000000000000000004fb84d2dfc50017afa759107a389759c8fd077de00000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000991c44331f0e59510bcff76edba06c3f552eef8b000000000000000000000000000000000000000000000000000000000000000100000000000000000c564fa02fb4f30000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000026f4ca92e4200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee00000000000000000000000000000000000000000000000edb3512d0799b0de300000000000000000000000000000000000000000000000000000000"
        ],
        [
          "0",
          "0",
          "0",
          "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000064d1660f99000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000"
        ]
      ]
    }
  ]
}

'''
'''--- src/tests/json/commons/data_decoded_swap_owner.json ---
{
  "method": "swapOwner",
  "parameters": [
    {
      "name": "prevOwner",
      "type": "address",
      "value": "0x0000000000000000000000000000000000000001"
    },
    {
      "name": "oldOwner",
      "type": "address",
      "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
    },
    {
      "name": "newOwner",
      "type": "address",
      "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
    }
  ]
}
'''
'''--- src/tests/json/commons/empty_page.json ---
{
    "count": 0,
    "next": null,
    "previous": null,
    "results": []
}

'''
'''--- src/tests/json/contracts/contract_info_BID.json ---
{
    "address": "0x00000000000045166C45aF0FC6E4Cf31D9E14B9A",
    "name": "BID",
    "displayName": "",
    "logoUri": null,
    "contractAbi": {
        "abi": [
            {
                "type": "constructor",
                "inputs": [
                    {
                        "name": "_controller",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "payable": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "Approval",
                "type": "event",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "spender",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "value",
                        "type": "uint256",
                        "indexed": false,
                        "internalType": "uint256"
                    }
                ],
                "anonymous": false
            },
            {
                "name": "Transfer",
                "type": "event",
                "inputs": [
                    {
                        "name": "from",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "to",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "value",
                        "type": "uint256",
                        "indexed": false,
                        "internalType": "uint256"
                    }
                ],
                "anonymous": false
            },
            {
                "name": "allowance",
                "type": "function",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "spender",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "approve",
                "type": "function",
                "inputs": [
                    {
                        "name": "spender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "amount",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "balanceOf",
                "type": "function",
                "inputs": [
                    {
                        "name": "account",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "decimals",
                "type": "function",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint8",
                        "internalType": "uint8"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "decreaseAllowance",
                "type": "function",
                "inputs": [
                    {
                        "name": "spender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "subtractedValue",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "increaseAllowance",
                "type": "function",
                "inputs": [
                    {
                        "name": "spender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "addedValue",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "name",
                "type": "function",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "string",
                        "internalType": "string"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "symbol",
                "type": "function",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "string",
                        "internalType": "string"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "totalSupply",
                "type": "function",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "payable": false,
                "constant": true,
                "stateMutability": "view"
            },
            {
                "name": "transfer",
                "type": "function",
                "inputs": [
                    {
                        "name": "recipient",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "amount",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            },
            {
                "name": "transferFrom",
                "type": "function",
                "inputs": [
                    {
                        "name": "sender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "recipient",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "amount",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "payable": false,
                "constant": false,
                "stateMutability": "nonpayable"
            }
        ],
        "description": "BID",
        "relevance": 100
    },
    "trustedForDelegateCall": false
}

'''
'''--- src/tests/json/exchange/currency_rates.json ---
{
    "success": true,
    "timestamp": 1637681643,
    "base": "EUR",
    "date": "2021-11-23",
    "rates": {
        "AED": 4.132218,
        "AFN": 106.034439,
        "ALL": 121.363274,
        "AMD": 536.811395,
        "ANG": 2.027014,
        "AOA": 658.146168,
        "ARS": 113.190248,
        "AUD": 1.559486,
        "AWG": 2.025347,
        "AZN": 1.914377,
        "BAM": 1.956519,
        "BBD": 2.2709,
        "BDT": 96.473386,
        "BGN": 1.953772,
        "BHD": 0.424119,
        "BIF": 2244.44749,
        "BMD": 1.125036,
        "BND": 1.537535,
        "BOB": 7.766236,
        "BRL": 6.355667,
        "BSD": 1.124696,
        "BTC": 0.000019637477,
        "BTN": 83.675778,
        "BWP": 13.162437,
        "BYN": 2.825395,
        "BYR": 22050.712187,
        "BZD": 2.267099,
        "CAD": 1.429466,
        "CDF": 2257.388573,
        "CHF": 1.049237,
        "CLF": 0.03306,
        "CLP": 912.348088,
        "CNY": 7.19112,
        "COP": 4431.799387,
        "CRC": 719.903613,
        "CUC": 1.125036,
        "CUP": 29.813463,
        "CVE": 110.669957,
        "CZK": 25.48996,
        "DJF": 200.230539,
        "DKK": 7.436524,
        "DOP": 63.733027,
        "DZD": 155.99743,
        "EGP": 17.682873,
        "ERN": 16.875894,
        "ETB": 53.169018,
        "EUR": 1,
        "FJD": 2.368246,
        "FKP": 0.83864,
        "GBP": 0.842107,
        "GEL": 3.515695,
        "GGP": 0.83864,
        "GHS": 6.896729,
        "GIP": 0.83864,
        "GMD": 58.842035,
        "GNF": 10642.843797,
        "GTQ": 8.699765,
        "GYD": 235.242873,
        "HKD": 8.767915,
        "HNL": 27.209029,
        "HRK": 7.524472,
        "HTG": 111.374236,
        "HUF": 370.127956,
        "IDR": 16072.66286,
        "ILS": 3.52925,
        "IMP": 0.83864,
        "INR": 83.786967,
        "IQD": 1643.115569,
        "IRR": 47532.785427,
        "ISK": 147.592908,
        "JEP": 0.83864,
        "JMD": 175.069675,
        "JOD": 0.797681,
        "JPY": 129.453433,
        "KES": 126.452054,
        "KGS": 95.402574,
        "KHR": 4578.897579,
        "KMF": 492.484652,
        "KPW": 1012.533096,
        "KRW": 1339.7384,
        "KWD": 0.340459,
        "KYD": 0.93733,
        "KZT": 488.187643,
        "LAK": 12071.640099,
        "LBP": 1723.576554,
        "LKR": 228.037221,
        "LRD": 161.048622,
        "LSL": 17.809644,
        "LTL": 3.32194,
        "LVL": 0.680524,
        "LYD": 5.180773,
        "MAD": 10.395433,
        "MDL": 19.924519,
        "MGA": 4500.14547,
        "MKD": 61.636166,
        "MMK": 1999.754501,
        "MNT": 3215.599795,
        "MOP": 9.02824,
        "MRO": 401.637778,
        "MUR": 48.825253,
        "MVR": 17.381795,
        "MWK": 916.904908,
        "MXN": 23.877894,
        "MYR": 4.708836,
        "MZN": 71.811413,
        "NAD": 17.809821,
        "NGN": 461.130021,
        "NIO": 39.640651,
        "NOK": 10.046348,
        "NPR": 133.880569,
        "NZD": 1.622139,
        "OMR": 0.433062,
        "PAB": 1.124796,
        "PEN": 4.511525,
        "PGK": 3.977015,
        "PHP": 57.027532,
        "PKR": 196.740759,
        "PLN": 4.700438,
        "PYG": 7691.609657,
        "QAR": 4.09628,
        "RON": 4.949597,
        "RSD": 117.562392,
        "RUB": 84.338388,
        "RWF": 1130.661518,
        "SAR": 4.220031,
        "SBD": 9.054655,
        "SCR": 14.37642,
        "SDG": 493.348224,
        "SEK": 10.150809,
        "SGD": 1.53739,
        "SHP": 1.549627,
        "SLL": 12409.151114,
        "SOS": 657.021794,
        "SRD": 24.214719,
        "STD": 23285.980717,
        "SVC": 9.842467,
        "SYP": 1413.927169,
        "SZL": 17.808816,
        "THB": 37.283978,
        "TJS": 12.703662,
        "TMT": 3.948878,
        "TND": 3.254278,
        "TOP": 2.54455,
        "TRY": 14.287846,
        "TTD": 7.644893,
        "TWD": 31.278819,
        "TZS": 2588.709051,
        "UAH": 30.248456,
        "UGX": 4015.314545,
        "USD": 1.125036,
        "UYU": 49.639487,
        "UZS": 12133.516725,
        "VEF": 240566769880.32626,
        "VND": 25515.824102,
        "VUV": 125.238605,
        "WST": 2.884189,
        "XAF": 656.185249,
        "XAG": 0.048102,
        "XAU": 0.00063,
        "XCD": 3.040467,
        "XDR": 0.80468,
        "XOF": 654.206346,
        "XPF": 119.760287,
        "YER": 281.540691,
        "ZAR": 17.872158,
        "ZMK": 10126.667553,
        "ZMW": 19.851393,
        "ZWL": 362.261241
    }
}

'''
'''--- src/tests/json/master_copies/polygon_master_copies.json ---
[
  {
    "address": "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
    "version": "1.3.0",
    "deployer": "Gnosis",
    "deployedBlockNumber": 14306478,
    "lastIndexedBlockNumber": 14306478,
    "l2": false
  },
  {
    "address": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
    "version": "1.3.0+L2",
    "deployer": "Gnosis",
    "deployedBlockNumber": 14306478,
    "lastIndexedBlockNumber": 20457018,
    "l2": true
  }
]

'''
'''--- src/tests/json/mod.rs ---
pub const MULTISIG_TX_ERC20_TRANSFER: &str =
    include_str!("transactions/multisig_erc20_transfer.json");
pub const MULTISIG_TX_ERC20_TRANSFER_DELEGATE: &str =
    include_str!("transactions/multisig_erc20_transfer_delegate.json");
pub const MULTISIG_TX_ERC20_TRANSFER_WITH_VALUE: &str =
    include_str!("transactions/multisig_erc20_transfer_with_value.json");
pub const MULTISIG_TX_ERC20_TRANSFER_INVALID_TO_AND_FROM: &str =
    include_str!("transactions/multisig_erc20_transfer_invalid_to_and_from.json");
pub const MULTISIG_TX_ERC721_TRANSFER: &str =
    include_str!("transactions/multisig_erc721_transfer.json");
pub const MULTISIG_TX_ERC721_TRANSFER_CANCELLED: &str =
    include_str!("transactions/multisig_erc721_transfer_cancelled.json");
pub const MULTISIG_TX_ERC721_TRANSFER_INVALID_TO_AND_FROM: &str =
    include_str!("transactions/multisig_erc721_transfer_invalid_to_and_from.json");
pub const MULTISIG_TX_ETHER_TRANSFER: &str =
    include_str!("transactions/multisig_ether_transfer.json");
pub const MULTISIG_TX_SETTINGS_CHANGE: &str =
    include_str!("transactions/multisig_addOwnerWithThreshold_settings_change.json");
pub const MULTISIG_TX_UNKNOWN_SETTINGS_CHANGE: &str =
    include_str!("transactions/multisig_newAndDifferentAddOwnerWithThreshold_settings_change.json");
pub const MULTISIG_TX_CUSTOM: &str = include_str!("transactions/multisig_approve_custom.json");
pub const MULTISIG_TX_FAILED: &str = include_str!("transactions/multisig_failed_transfer.json");
pub const MULTISIG_TX_AWAITING_EXECUTION: &str =
    include_str!("transactions/multisig_awaiting_execution.json");
pub const MULTISIG_TX_AWAITING_CONFIRMATIONS: &str =
    include_str!("transactions/multisig_awaiting_confirmations.json");
pub const MULTISIG_TX_AWAITING_CONFIRMATIONS_EMPTY: &str =
    include_str!("transactions/multisig_awaiting_confirmations_empty.json");
pub const MULTISIG_TX_AWAITING_CONFIRMATIONS_NULL: &str =
    include_str!("transactions/multisig_awaiting_confirmations_null.json");
pub const MULTISIG_TX_AWAITING_CONFIRMATIONS_REQUIRED_NULL: &str =
    include_str!("transactions/multisig_awaiting_confirmations_required_null.json");
pub const MULTISIG_TX_CONFIRMATIONS_NULL: &str =
    include_str!("transactions/multisig_confirmations_null.json");
pub const MULTISIG_TX_WITH_ORIGIN: &str = include_str!("transactions/multisig_with_origin.json");
pub const MULTISIG_TX_CANCELLATION: &str =
    include_str!("transactions/multisig_cancellation_transaction.json");

pub const MODULE_TX: &str = include_str!("transactions/module_transaction.json");
pub const MODULE_TX_FAILED: &str = include_str!("transactions/module_transaction_failed.json");
pub const MODULE_TX_ERC20_TRANSFER: &str = include_str!("transactions/module_erc20_transfer.json");
pub const MODULE_TX_ERC721_TRANSFER: &str =
    include_str!("transactions/module_erc721_transfer.json");
pub const MODULE_TX_ETHER_TRANSFER: &str = include_str!("transactions/module_ether_transfer.json");
pub const MODULE_TX_UNKNOWN_SETTINGS_CHANGE: &str =
    include_str!("transactions/module_newAndDifferentAddOwnerWithThreshold_settings_change.json");
pub const MODULE_TX_SETTINGS_CHANGE: &str =
    include_str!("transactions/module_addOwnerWithThreshold_settings_change.json");

pub const ETHEREUM_TX_INCONSISTENT_TOKEN_TYPES: &str =
    include_str!("transactions/ethereum_inconsistent_token_types.json");

pub const SAFE_WITH_MODULES: &str = include_str!("safes/with_modules.json");
pub const SAFE_WITH_THRESHOLD_TWO: &str = include_str!("safes/with_threshold_two.json");
pub const SAFE_WITH_MODULES_AND_HIGH_NONCE: &str =
    include_str!("safes/with_modules_and_high_nonce.json");
pub const SAFE_WITH_GUARD_SAFE_V130_L2: &str = include_str!("safes/with_guard_safe_v130_l2.json");
pub const _SAFE_WITH_MODULE_TXS: &str = include_str!("safes/with_module_transactions.json");

pub const ETHER_TRANSFER_INCOMING: &str = include_str!("transfers/ether_transfer_incoming.json");
pub const ETHER_TRANSFER_OUTGOING: &str = include_str!("transfers/ether_transfer_outgoing.json");
pub const ERC_20_TRANSFER_WITH_ERC721_TOKEN_INFO: &str =
    include_str!("transfers/erc20_transfer_with_erc721_token_info.json");
pub const ERC_20_TRANSFER_WITHOUT_TOKEN_INFO: &str =
    include_str!("transfers/erc_20_transfer_without_token_info.json");
pub const ERC_20_TRANSFER_WITH_TOKEN_INFO_INCOMING: &str =
    include_str!("transfers/erc_20_transfer_with_token_info_incoming.json");
pub const ERC_20_TRANSFER_WITH_TOKEN_INFO_OUTGOING: &str =
    include_str!("transfers/erc_20_transfer_with_token_info_outgoing.json");
pub const ERC_20_TRANSFER_UNEXPECTED_PARAM_NAMES: &str =
    include_str!("transfers/erc_20_transfer_unexpected_param_names.json");
pub const ERC_721_TRANSFER_WITHOUT_TOKEN_INFO: &str =
    include_str!("transfers/erc_721_transfer_without_token_info.json");
pub const ERC_721_TRANSFER_WITH_TOKEN_INFO_INCOMING: &str =
    include_str!("transfers/erc_721_transfer_with_token_info_incoming.json");
pub const ERC_721_TRANSFER_WITH_TOKEN_INFO_OUTGOING: &str =
    include_str!("transfers/erc_721_transfer_with_token_info_outgoing.json");

pub const CREATION_TX: &str = include_str!("transactions/creation_transaction.json");

pub const BACKEND_MULTISIG_TRANSFER_TX: &str =
    include_str!("transactions/backend_multisig_transfer_tx.json");
pub const BACKEND_HISTORY_TRANSACTION_LIST_PAGE: &str =
    include_str!("transactions/backend_history_transaction_list_page.json");
pub const BACKEND_QUEUED_TRANSACTION_LIST_PAGE_NO_CONFLICTS: &str =
    include_str!("transactions/backend_queued_transaction_list_page_no_conflicts.json");
pub const BACKEND_QUEUED_TRANSACTION_LIST_PAGE_CONFLICT_393: &str =
    include_str!("transactions/backend_queued_transaction_list_page_conflicts_393.json");
pub const BACKEND_QUEUED_TRANSACTION_LIST_PAGE_CONFLICT_394: &str =
    include_str!("transactions/backend_queued_transaction_list_page_conflicts_394.json");

pub const TOKEN_USDT: &str = include_str!("tokens/usdt.json");
pub const TOKEN_CRYPTO_KITTIES: &str = include_str!("tokens/crypto_kitties.json");
pub const TOKEN_DAI: &str = include_str!("tokens/dai.json");
pub const TOKEN_PV_MEMORIAL_TOKEN: &str = include_str!("tokens/pv_memorial_token.json");
pub const TOKEN_BAT: &str = include_str!("tokens/bat.json");

pub const DATA_DECODED_APPROVE: &str = include_str!("commons/data_decoded_approve.json");
pub const DATA_DECODED_MULTI_SEND: &str = include_str!("commons/data_decoded_multi_send.json");
pub const DATA_DECODED_ADD_OWNER_WITH_THRESHOLD: &str =
    include_str!("commons/data_decoded_add_owner_with_threshold.json");
pub const DATA_DECODED_CHANGE_MASTER_COPY: &str =
    include_str!("commons/data_decoded_change_master_copy.json");
pub const DATA_DECODED_CHANGE_THRESHOLD: &str =
    include_str!("commons/data_decoded_change_threshold.json");
pub const DATA_DECODED_DISABLE_MODULE: &str =
    include_str!("commons/data_decoded_disable_module.json");
pub const DATA_DECODED_ENABLE_MODULE: &str =
    include_str!("commons/data_decoded_enable_module.json");
pub const DATA_DECODED_REMOVE_OWNER: &str = include_str!("commons/data_decoded_remove_owner.json");
pub const DATA_DECODED_SET_FALLBACK_HANDLER: &str =
    include_str!("commons/data_decoded_set_fallback_handler.json");
pub const DATA_DECODED_SWAP_OWNER: &str = include_str!("commons/data_decoded_swap_owner.json");
pub const DATA_DECODED_EXEC_TRANSACTION_FROM_MODULE: &str =
    include_str!("commons/data_decoded_exec_transaction_from_module.json");
pub const DATA_DECODED_EXEC_TRANSACTION_WITH_VALUE_DECODED: &str =
    include_str!("commons/data_decoded_nested_safe_interaction.json");
pub const DATA_DECODED_SWAP_ARRAY_VALUES: &str =
    include_str!("commons/data_decoded_swap_array_values.json");
pub const DATA_DECODED_MULTI_SEND_SINGLE_INNER_TRANSACTION: &str =
    include_str!("commons/data_decoded_multi_send_single_inner_transaction.json");
pub const DOCTORED_DATA_DECODED_NESTED_MULTI_SENDS: &str =
    include_str!("commons/DOCTORED_data_decoded_nested_multi_sends.json");
pub const DOCTORED_DATA_DECODED_MULTI_SEND_NESTED_DELEGATE: &str =
    include_str!("commons/DOCTORED_data_decoded_multi_send_nested_delegate.json");
pub const DATA_DECODED_SET_GUARD: &str = include_str!("commons/data_decoded_set_guard.json");
pub const DATA_DECODED_DELETE_GUARD: &str = include_str!("commons/data_decoded_delete_guard.json");

pub const BALANCE_ETHER: &str = include_str!("balances/balance_ether.json");
pub const BALANCE_COMPOUND_ETHER: &str = include_str!("balances/balance_compound_ether.json");

pub const TX_DETAILS_WITH_ORIGIN: &str = include_str!("results/tx_details_with_origin.json");

pub const CHAIN_INFO_RINKEBY: &str = include_str!("chains/rinkeby.json");
pub const CHAIN_INFO_POLYGON: &str = include_str!("chains/polygon.json");
pub const CHAIN_INFO_RINKEBY_FIXED_GAS_PRICE: &str =
    include_str!("chains/rinkeby_fixed_gas_price.json");
pub const CHAIN_INFO_RINKEBY_MULTIPLE_GAS_PRICE: &str =
    include_str!("chains/rinkeby_multiple_gas_price.json");
pub const CHAIN_INFO_RINKEBY_NO_GAS_PRICE: &str = include_str!("chains/rinkeby_no_gas_price.json");
pub const CHAIN_INFO_RINKEBY_UNKNOWN_GAS_PRICE: &str =
    include_str!("chains/rinkeby_unknown_gas_price.json");
pub const CHAIN_INFO_RINKEBY_RPC_NO_AUTHENTICATION: &str =
    include_str!("chains/rinkeby_rpc_no_auth.json");
pub const CHAIN_INFO_RINKEBY_RPC_UNKNOWN_AUTHENTICATION: &str =
    include_str!("chains/rinkeby_rpc_auth_unknown.json");
pub const CHAIN_INFO_RINKEBY_DISABLED_WALLETS: &str =
    include_str!("chains/rinkeby_disabled_wallets.json");
pub const CHAIN_INFO_RINKEBY_ENABLED_FEATURES: &str =
    include_str!("chains/rinkeby_enabled_features.json");

pub const POLYGON_SAFE_APPS: &str = include_str!("safe_apps/polygon_safe_apps.json");
pub const POLYGON_SAFE_APP_URL_QUERY: &str =
    include_str!("safe_apps/polygon_safe_app_url_query.json");
pub const POLYGON_SAFE_APPS_WITH_TAGS: &str =
    include_str!("safe_apps/polygon_safe_apps_with_tags.json");

pub const POLYGON_MASTER_COPIES: &str = include_str!("master_copies/polygon_master_copies.json");

pub const COLLECTIBLES_PAGE: &str = include_str!("collectibles/collectibles_page.json");

pub const COLLECTIBLES_PAGINATED_EMPTY_TXS: &str =
    include_str!("collectibles/collectibles_paginated_empty_txs.json");

pub const COLLECTIBLES_PAGINATED_EMPTY_CGW: &str =
    include_str!("collectibles/collectibles_paginated_empty_cgw.json");

pub const COLLECTIBLES_PAGINATED_ONE_TXS: &str =
    include_str!("collectibles/collectibles_paginated_page_1_txs.json");

pub const COLLECTIBLES_PAGINATED_ONE_CGW: &str =
    include_str!("collectibles/collectibles_paginated_page_1_cgw.json");

pub const COLLECTIBLES_PAGINATED_TWO_TXS: &str =
    include_str!("collectibles/collectibles_paginated_page_2_txs.json");

pub const COLLECTIBLES_PAGINATED_TWO_CGW: &str =
    include_str!("collectibles/collectibles_paginated_page_2_cgw.json");

pub const EXCHANGE_CURRENCY_RATES: &str = include_str!("exchange/currency_rates.json");

pub const CONTRACT_INFO_BID: &str = include_str!("contracts/contract_info_BID.json");

pub const EMPTY_PAGE: &str = include_str!("commons/empty_page.json");

'''
'''--- src/tests/json/results/tx_details_with_origin.json ---
{
  "safeAddress": "0xBc79855178842FDBA0c353494895DEEf509E26bB",
  "txId": "multisig_0xBc79855178842FDBA0c353494895DEEf509E26bB_0x728e6dec56dc61523b56dc440e34c1c4c39c66895df8e5d3499ed1f7d4fcfe80",
  "executedAt": 1607346715000,
  "txStatus": "SUCCESS",
  "txInfo": {
    "type": "Custom",
    "to": {
      "value": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD"
    },
    "dataSize": "3108",
    "value": "0",
    "methodName": "multiSend",
    "actionCount": 1,
    "isCancellation": false
  },
  "txData": {
    "hexData": "0x8d80ff0a00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000bd900111111125434b319222cdbf8c261674adb56f3ae000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000b8490411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "dataDecoded": {
      "method": "multiSend",
      "parameters": [
        {
          "name": "transactions",
          "type": "bytes",
          "value": "0x00111111125434b319222cdbf8c261674adb56f3ae000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000b8490411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
          "valueDecoded": [
            {
              "operation": 0,
              "to": "0x111111125434b319222CdBf8C261674aDB56F3ae",
              "value": "22",
              "data": "0x90411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
              "dataDecoded": {
                "method": "swap",
                "parameters": [
                  {
                    "name": "caller",
                    "type": "address",
                    "value": "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5"
                  },
                  {
                    "name": "desc",
                    "type": "(address,address,address,address,uint256,uint256,uint256,uint256,address,bytes)",
                    "value": [
                      "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
                      "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
                      "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5",
                      "0xBc79855178842FDBA0c353494895DEEf509E26bB",
                      "70000000000000000000000",
                      "69930000000000000000000",
                      "70000000000000000000000",
                      "1",
                      "0x0000000000000000000000000000000000000000",
                      "0x"
                    ]
                  },
                  {
                    "name": "calls",
                    "type": "(uint256,uint256,uint256,bytes)[]",
                    "value": [
                      [
                        "0",
                        "0",
                        "0",
                        "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                      ],
                      [
                        "0",
                        "0",
                        "0",
                        "0x7f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000"
                      ],
                      [
                        "0",
                        "0",
                        "0",
                        "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000"
                      ]
                    ]
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    "to": {
      "value": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD"
    },
    "value": "0",
    "operation": 1,
    "trustedDelegateCallTarget": true
  },
  "detailedExecutionInfo": {
    "type": "MULTISIG",
    "submittedAt": 1607346684674,
    "nonce": 160,
    "safeTxGas": "124625",
    "baseGas": "0",
    "gasPrice": "0",
    "gasToken": "0x0000000000000000000000000000000000000000",
    "refundReceiver": {
      "value": "0x0000000000000000000000000000000000000000"
    },
    "safeTxHash": "0x728e6dec56dc61523b56dc440e34c1c4c39c66895df8e5d3499ed1f7d4fcfe80",
    "executor": {
      "value": "0xe965484BA4250c446779D4703f1598DC2EA00d12"
    },
    "signers": [
      {
        "value": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"
      },
      {
        "value": "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72"
      },
      {
        "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
      },
      {
        "value": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
      },
      {
        "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
      }
    ],
    "confirmationsRequired": 2,
    "confirmations": [
      {
        "signer": {
          "value": "0xc9d486048A9B82172F6f2A2ce6D9024c9D1097dC"
        },
        "signature": "0xbd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c",
        "submittedAt": 1607346684686
      },
      {
        "signer": {
          "value": "0xe965484BA4250c446779D4703f1598DC2EA00d12"
        },
        "signature": "0x000000000000000000000000e965484ba4250c446779d4703f1598dc2ea00d12000000000000000000000000000000000000000000000000000000000000000001",
        "submittedAt": 1607346715000
      }
    ],
    "trusted": false
  },
  "txHash": "0x4d84602bf94d099159baa41993edca288abb5f9795dd51cc14bd66195b9fdc77",
  "safeAppInfo": {
    "name": "WalletConnect",
    "url": "https://apps.gnosis-safe.io/walletConnect",
    "logoUri": "https://apps.gnosis-safe.io/walletConnect/walletConnect.jpg"
  }
}

'''
'''--- src/tests/json/safe_apps/polygon_safe_app_url_query.json ---
[
  {
    "id": 26,
    "url": "https://test.app",
    "name": "Test App",
    "iconUrl": "https://test.app/logo.svg",
    "description": "Some cool app",
    "chainIds": [1, 137],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  }
]

'''
'''--- src/tests/json/safe_apps/polygon_safe_apps.json ---
[
  {
    "id": 26,
    "url": "https://curve.fi",
    "name": "Curve",
    "iconUrl": "https://curve.fi/logo-square.svg",
    "description": "Decentralized exchange liquidity pool designed for extremely efficient stablecoin trading and low-risk income for liquidity providers",
    "chainIds": [1, 137],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  },
  {
    "id": 24,
    "url": "https://safe-apps.dev.gnosisdev.com/tx-builder",
    "name": "Transaction Builder",
    "iconUrl": "https://safe-apps.dev.gnosisdev.com/tx-builder/tx-builder.png",
    "description": "A Safe app to compose custom transactions",
    "chainIds": [1, 4, 10, 56, 100, 137, 246, 42161, 43114, 73799],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  },
  {
    "id": 11,
    "url": "https://app.1inch.io",
    "name": "1inch.exchange",
    "iconUrl": "https://app.1inch.io/assets/images/1inch.svg",
    "description": "The most efficient defi aggregator",
    "chainIds": [1, 56, 137],
    "provider": {
      "url": "https://1inch.exchange",
      "name": "1inch corporation"
    },
    "accessControl": {
      "type": "DOMAIN_ALLOWLIST",
      "value": ["https://gnosis-safe.io", "https://dev.gnosis-safe.io"]
    }
  },
  {
    "id": 30,
    "url": "https://paraswap.io",
    "name": "ParaSwap",
    "iconUrl": "https://paraswap.io/paraswap.svg",
    "description": "ParaSwap allows dApps and traders to get the best DEX liquidity by aggregating multiple markets and offering the best rates",
    "chainIds": [1, 56, 137],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  },
  {
    "id": 25,
    "url": "https://safe-apps.dev.gnosisdev.com/wallet-connect",
    "name": "WalletConnect",
    "iconUrl": "https://safe-apps.dev.gnosisdev.com/wallet-connect/wallet-connect.svg",
    "description": "Connect your Safe to any dApp that supports WalletConnect",
    "chainIds": [1, 4, 10, 56, 100, 137, 246, 73799, 42161, 43114],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  }
]

'''
'''--- src/tests/json/safe_apps/polygon_safe_apps_with_tags.json ---
[
  {
    "id": 26,
    "url": "https://curve.fi",
    "name": "Curve",
    "iconUrl": "https://curve.fi/logo-square.svg",
    "description": "Decentralized exchange liquidity pool designed for extremely efficient stablecoin trading and low-risk income for liquidity providers",
    "chainIds": [1, 137],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    },
    "tags": ["tag1"]
  },
  {
    "id": 24,
    "url": "https://safe-apps.dev.gnosisdev.com/tx-builder",
    "name": "Transaction Builder",
    "iconUrl": "https://safe-apps.dev.gnosisdev.com/tx-builder/tx-builder.png",
    "description": "A Safe app to compose custom transactions",
    "chainIds": [1, 4, 10, 56, 100, 137, 246, 42161, 43114, 73799],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    },
    "tags": ["tag2"]
  },
  {
    "id": 11,
    "url": "https://app.1inch.io",
    "name": "1inch.exchange",
    "iconUrl": "https://app.1inch.io/assets/images/1inch.svg",
    "description": "The most efficient defi aggregator",
    "chainIds": [1, 56, 137],
    "provider": {
      "url": "https://1inch.exchange",
      "name": "1inch corporation"
    },
    "accessControl": {
      "type": "DOMAIN_ALLOWLIST",
      "value": ["https://gnosis-safe.io", "https://dev.gnosis-safe.io"]
    }
  },
  {
    "id": 30,
    "url": "https://paraswap.io",
    "name": "ParaSwap",
    "iconUrl": "https://paraswap.io/paraswap.svg",
    "description": "ParaSwap allows dApps and traders to get the best DEX liquidity by aggregating multiple markets and offering the best rates",
    "chainIds": [1, 56, 137],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    }
  },
  {
    "id": 25,
    "url": "https://safe-apps.dev.gnosisdev.com/wallet-connect",
    "name": "WalletConnect",
    "iconUrl": "https://safe-apps.dev.gnosisdev.com/wallet-connect/wallet-connect.svg",
    "description": "Connect your Safe to any dApp that supports WalletConnect",
    "chainIds": [1, 4, 10, 56, 100, 137, 246, 73799, 42161, 43114],
    "provider": null,
    "accessControl": {
      "type": "NO_RESTRICTIONS"
    },
    "tags": ["tag1", "tag2"]
  }
]

'''
'''--- src/tests/json/safes/with_guard_safe_v130_l2.json ---
{
  "address": "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f",
  "nonce": 7,
  "threshold": 1,
  "owners": [
    "0x5aC255889882aCd3da2aA939679E3f3d4cea221e"
  ],
  "masterCopy": "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
  "modules": [],
  "fallbackHandler": "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
  "guard": "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
  "version": "1.3.0"
}

'''
'''--- src/tests/json/safes/with_module_transactions.json ---
{
  "address": "0x9422ff6AFB126C31F62057e2853d65cBB73f4608",
  "nonce": 0,
  "threshold": 1,
  "owners": [
    "0x424a46612794dbb8000194937834250Dc723fFa5",
    "0x3B376a725A36147db5D4b91aBf1F3FDf97122f0D",
    "0x7D05218D5f6EdEE9dd0b4BdA34508D440417cBe3",
    "0x6484a2514AEE516DdaC6f67Dd2322f23e0A4A7D6"
  ],
  "masterCopy": "0x8942595A2dC5181Df0465AF0D7be08c8f23C93af",
  "modules": [
    "0xfa559f0932b7B60d90B4af0b8813d4088465096b"
  ],
  "fallbackHandler": "0x0000000000000000000000000000000000000000",
  "guard": "0x0000000000000000000000000000000000000000",
  "version": "0.1.0"
}
'''
'''--- src/tests/json/safes/with_modules.json ---
{
  "address": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "nonce": 180,
  "threshold": 3,
  "owners": [
    "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
    "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72",
    "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D",
    "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
    "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
  ],
  "masterCopy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
  "modules": [
    "0x25F73b24B866963B0e560fFF9bbA7908be0263E8",
    "0x10A7EC8D10CD175dC33781fB9Cf3394220Fac78c",
    "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d"
  ],
  "fallbackHandler": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
  "guard": "0x0000000000000000000000000000000000000000",
  "version": "1.1.1"
}

'''
'''--- src/tests/json/safes/with_modules_and_high_nonce.json ---
{
  "address": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "nonce": 18000,
  "threshold": 3,
  "owners": [
    "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
    "0x37e9F140A9Df5DCBc783C6c220660a4E15CBFe72",
    "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D",
    "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
    "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
  ],
  "masterCopy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
  "modules": [
    "0x25F73b24B866963B0e560fFF9bbA7908be0263E8",
    "0x10A7EC8D10CD175dC33781fB9Cf3394220Fac78c",
    "0xF5dC3718EEbC5b003F1672A499F2ACBE77Ba790d"
  ],
  "fallbackHandler": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
  "guard": "0x0000000000000000000000000000000000000000",
  "version": "1.1.1"
}
'''
'''--- src/tests/json/safes/with_threshold_two.json ---
{
  "address": "0x9422ff6AFB126C31F62057e2853d65cBB73f4608",
  "nonce": 140,
  "threshold": 2,
  "owners": [
    "0x424a46612794dbb8000194937834250Dc723fFa5",
    "0x3B376a725A36147db5D4b91aBf1F3FDf97122f0D",
    "0x7D05218D5f6EdEE9dd0b4BdA34508D440417cBe3",
    "0x6484a2514AEE516DdaC6f67Dd2322f23e0A4A7D6"
  ],
  "masterCopy": "0x8942595A2dC5181Df0465AF0D7be08c8f23C93af",
  "modules": [
    "0xfa559f0932b7B60d90B4af0b8813d4088465096b"
  ],
  "fallbackHandler": "0x0000000000000000000000000000000000000000",
  "guard": "0x0000000000000000000000000000000000000000",
  "version": "0.1.0"
}
'''
'''--- src/tests/json/tokens/bat.json ---
{
  "type": "ERC20",
  "address": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
  "name": "BigAmount",
  "symbol": "BA-T",
  "decimals": 1,
  "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46.png"
}
'''
'''--- src/tests/json/tokens/crypto_kitties.json ---
{
  "type": "ERC721",
  "address": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
  "name": "CryptoKitties",
  "symbol": "CK",
  "decimals": 0,
  "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png"
}
'''
'''--- src/tests/json/tokens/dai.json ---
{
  "type": "ERC20",
  "address": "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa",
  "name": "Dai",
  "symbol": "DAI",
  "decimals": 18,
  "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png"
}
'''
'''--- src/tests/json/tokens/pv_memorial_token.json ---
{
  "type": "ERC721",
  "address": "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98",
  "name": "PV Memorial Token",
  "symbol": "PVT",
  "decimals": 0,
  "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png"
}
'''
'''--- src/tests/json/tokens/usdt.json ---
{
  "type": "ERC20",
  "address": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "name": "Compound USDT",
  "symbol": "USDT",
  "decimals": 18,
  "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png"
}
'''
'''--- src/tests/json/transactions/backend_history_transaction_list_page.json ---
{
  "count": 614,
  "next": "https://safe-transaction.staging.gnosisdev.com/api/v1/safes/0x1230B3d59858296A31053C1b8562Ecf89A2f888b/all-transactions/?limit=20&offset=20&queued=false&trusted=true",
  "previous": null,
  "results": [
    {
      "created": "2020-12-01T18:04:14Z",
      "executionDate": "2020-12-01T18:04:14Z",
      "blockNumber": 7645325,
      "isSuccessful": true,
      "transactionHash": "0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f",
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "module": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
      "to": "0xc778417E063141139Fce010982780140Aa0cD5Ab",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b8400000000000000000000000000000000000000000000000000005af3107a4000",
      "operation": 0,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "100000000000000"
          }
        ]
      },
      "transfers": [
        {
          "type": "ERC20_TRANSFER",
          "executionDate": "2020-12-01T18:04:14Z",
          "blockNumber": 7645325,
          "transactionHash": "0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f",
          "to": "0xF353eBBa77e5E71c210599236686D51cA1F88b84",
          "value": "100000000000000",
          "tokenId": null,
          "tokenAddress": "0xc778417E063141139Fce010982780140Aa0cD5Ab",
          "tokenInfo": {
            "type": "ERC20",
            "address": "0xc778417E063141139Fce010982780140Aa0cD5Ab",
            "name": "Wrapped Ether",
            "symbol": "WETH",
            "decimals": 18,
            "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xc778417E063141139Fce010982780140Aa0cD5Ab.png"
          },
          "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
        }
      ],
      "txType": "MODULE_TRANSACTION"
    },
    {
      "created": "2020-12-01T18:03:14Z",
      "executionDate": "2020-12-01T18:03:14Z",
      "blockNumber": 7645321,
      "isSuccessful": true,
      "transactionHash": "0x1cf24abdb39bb7b156677a128e709cea55c6991b12708904d1f0f3664ad6646e",
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "module": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
      "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b84000000000000000000000000000000000000000000000000002386f26fc10000",
      "operation": 0,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "10000000000000000"
          }
        ]
      },
      "transfers": [
        {
          "type": "ERC20_TRANSFER",
          "executionDate": "2020-12-01T18:03:14Z",
          "blockNumber": 7645321,
          "transactionHash": "0x1cf24abdb39bb7b156677a128e709cea55c6991b12708904d1f0f3664ad6646e",
          "to": "0xF353eBBa77e5E71c210599236686D51cA1F88b84",
          "value": "10000000000000000",
          "tokenId": null,
          "tokenAddress": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
          "tokenInfo": {
            "type": "ERC20",
            "address": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "name": "Compound USDT",
            "symbol": "USDT",
            "decimals": 18,
            "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png"
          },
          "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
        }
      ],
      "txType": "MODULE_TRANSACTION"
    },
    {
      "created": "2020-12-01T17:51:10Z",
      "executionDate": "2020-12-01T17:51:10Z",
      "blockNumber": 7645273,
      "isSuccessful": true,
      "transactionHash": "0x3f12bb74cd91ef09d553f66e3623bceaf879ba3dcb325227b1fbf2455757891a",
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "module": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
      "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b84000000000000000000000000000000000000000000000000002386f26fc10000",
      "operation": 0,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "10000000000000000"
          }
        ]
      },
      "transfers": [
        {
          "type": "ERC20_TRANSFER",
          "executionDate": "2020-12-01T17:51:10Z",
          "blockNumber": 7645273,
          "transactionHash": "0x3f12bb74cd91ef09d553f66e3623bceaf879ba3dcb325227b1fbf2455757891a",
          "to": "0xF353eBBa77e5E71c210599236686D51cA1F88b84",
          "value": "10000000000000000",
          "tokenId": null,
          "tokenAddress": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
          "tokenInfo": {
            "type": "ERC20",
            "address": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
            "name": "Compound USDT",
            "symbol": "USDT",
            "decimals": 18,
            "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png"
          },
          "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
        }
      ],
      "txType": "MODULE_TRANSACTION"
    },
    {
      "executionDate": "2020-11-30T13:47:13Z",
      "to": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD",
      "data": "0x6a76120200000000000000000000000063704b63ac04f3a173dfe677c7e3d330c347cd88000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c3af000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000006423b872dd0000000000000000000000001230b3d59858296a31053c1b8562ecf89a2f888b000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b84000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008200000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b0000000000000000000000000000000000000000000000000000000000000000001445651ff151d86b53f834cabfe35dc2c5078c845e0ec32466f9e72b1e9b1284353aa1d906c4ab02a5d96968b8b1fc30222249e6f4e2c47824d82a7389adeca9a1c000000000000000000000000000000000000000000000000000000000000",
      "txHash": "0x021d4d8cb68f3f772906b58f97b66c6ead228c252627c5b1aff4b496d4ff0c2d",
      "blockNumber": 7638826,
      "transfers": [
        {
          "type": "ERC20_TRANSFER",
          "executionDate": "2020-11-30T13:47:13Z",
          "blockNumber": 7638826,
          "transactionHash": "0x021d4d8cb68f3f772906b58f97b66c6ead228c252627c5b1aff4b496d4ff0c2d",
          "to": "0xF353eBBa77e5E71c210599236686D51cA1F88b84",
          "value": "100000000000000000",
          "tokenId": null,
          "tokenAddress": "0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88",
          "tokenInfo": {
            "type": "ERC20",
            "address": "0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88",
            "name": "TEST AQER",
            "symbol": "AQER",
            "decimals": 18,
            "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88.png"
          },
          "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
        }
      ],
      "txType": "ETHEREUM_TRANSACTION",
      "from": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
    },
    {
      "executionDate": "2020-11-30T13:39:41Z",
      "to": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD",
      "data": "0x6a76120200000000000000000000000063704b63ac04f3a173dfe677c7e3d330c347cd880000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008917000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000006423b872dd0000000000000000000000001230b3d59858296a31053c1b8562ecf89a2f888b000000000000000000000000f2565317f3ae8ae9ea98e9fe1e7fadc77f823cbd000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008261a6df63b95ccc29e05f9789e6ffb8a956cf6381ee183d29d031f31a3ad7d1216a52602e0a108a61585e8d8f357a3f3a7605eb9e3c17a5cf34617b2973adb45e1c000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000",
      "txHash": "0x5f4b7555f8e977ae302ab4125de685ccfacf52ac70e6f0aa2939bcb347f9a732",
      "blockNumber": 7638796,
      "transfers": [
        {
          "type": "ERC20_TRANSFER",
          "executionDate": "2020-11-30T13:39:41Z",
          "blockNumber": 7638796,
          "transactionHash": "0x5f4b7555f8e977ae302ab4125de685ccfacf52ac70e6f0aa2939bcb347f9a732",
          "to": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD",
          "value": "100000000000000000",
          "tokenId": null,
          "tokenAddress": "0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88",
          "tokenInfo": {
            "type": "ERC20",
            "address": "0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88",
            "name": "TEST AQER",
            "symbol": "AQER",
            "decimals": 18,
            "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x63704B63Ac04f3a173Dfe677C7e3D330c347CD88.png"
          },
          "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
        }
      ],
      "txType": "ETHEREUM_TRANSACTION",
      "from": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd"
    },
    {
      "executionDate": "2020-11-30T12:35:25Z",
      "to": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD",
      "data": "0x6a76120200000000000000000000000081d0ff4fe216fb6ac98ed609086a92d94dbfe666000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000687a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000044a9059cbb0000000000000000000000001230b3d59858296a31053c1b8562ecf89a2f888b00000000000000000000000000000000000000000000000000016bcc41e900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c375e6b6d79366efa60b836fe0be0dffe5823cee21767a8f03ed4f4e55456c54134e44bdafc8d35b25b8ab990e281f5ceb68e1b3bb5be4242231e7e05a02fffb761b000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b23000000000000000000000000000000000000000000000000000000000000000001e39b6ffeceaf836a547b9cf543fe9a57d1a80b55148d6a6e5c8581acd6cfceab0c6b2364a1a6298ae75d180e5a233ee08a371fa002afe9e46a3007c4fa5959511c0000000000000000000000000000000000000000000000000000000000",
      "txHash": "0xaafed95936f9d71eb8d9612e83f3f93f9decf33f11bbb4aa79cae98966ffa7fe",
      "blockNumber": 7638540,
      "transfers": [
        {
          "type": "ERC20_TRANSFER",
          "executionDate": "2020-11-30T12:35:25Z",
          "blockNumber": 7638540,
          "transactionHash": "0xaafed95936f9d71eb8d9612e83f3f93f9decf33f11bbb4aa79cae98966ffa7fe",
          "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
          "value": "400000000000000",
          "tokenId": null,
          "tokenAddress": "0x81D0FF4fE216fB6aC98ED609086A92d94dbfE666",
          "tokenInfo": {
            "type": "ERC20",
            "address": "0x81D0FF4fE216fB6aC98ED609086A92d94dbfE666",
            "name": "LS",
            "symbol": "LS",
            "decimals": 18,
            "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x81D0FF4fE216fB6aC98ED609086A92d94dbfE666.png"
          },
          "from": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"
        }
      ],
      "txType": "ETHEREUM_TRANSACTION",
      "from": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23"
    }
  ]
}
'''
'''--- src/tests/json/transactions/backend_multisig_transfer_tx.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
  "value": "0",
  "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 26746,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 393,
  "executionDate": "2020-12-10T13:50:59Z",
  "submissionDate": "2020-12-10T13:50:59Z",
  "modified": "2020-12-10T13:50:59Z",
  "blockNumber": 7695627,
  "transactionHash": "0xd145bafe9766613d431a898a7ad95b69481152b4e9f846bd5fdc334ec8d78266",
  "safeTxHash": "0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 63081,
  "fee": "63081000000000",
  "origin": null,
  "dataDecoded": {
    "method": "transfer",
    "parameters": [
      {
        "name": "to",
        "type": "address",
        "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "20"
      }
    ]
  },
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-12-10T13:50:59Z",
      "transactionHash": null,
      "signature": "0x1f6d2f092022fcbe6b10f0514255eb4205bb2302ac8789311b1aa2f0a134a7026458c827b42ccb577ffa7a5bc43582b4a23183ab811271ddc9d78446784fa3701b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-12-10T13:50:59Z",
      "transactionHash": null,
      "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x1f6d2f092022fcbe6b10f0514255eb4205bb2302ac8789311b1aa2f0a134a7026458c827b42ccb577ffa7a5bc43582b4a23183ab811271ddc9d78446784fa3701b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "trusted": false
}

'''
'''--- src/tests/json/transactions/backend_queued_transaction_list_page_conflicts_393.json ---
{
  "count": 3,
  "next": null,
  "previous": null,
  "results": [
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f2565317f3ae8ae9ea98e9fe1e7fadc77f823cbd000000000000000000000000000000000000000000000000000000000000000a",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 41746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 393,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:10:42.476237Z",
      "modified": "2020-12-10T12:10:42.476237Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0x0fe072e76498e0db46fc79113662026a4f8fb34e840491aefeff6dec21c766cb",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "10"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:10:42.600252Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0x04027fccf5b43964ffbe8111f13fb7e53541da7c0752a31bfacc817cec2a1b1748e6ff6ae133238b6b43dd84191823bef2fd9841762c47faa989a503dcef4a0c1c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    },
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 26746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 393,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:11:24.354944Z",
      "modified": "2020-12-10T12:11:24.354944Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "20"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:11:24.377002Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0xd1f7a792512199a8cfb3e8745a38faf7b8383ab3eb4c1eda0ce3203283e535174012da4583dbc2f9c8c4329d7b65d4b2962450580cddd59fb2ecfc26b951e94d1c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    },
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 26746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 394,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:13:44.072469Z",
      "modified": "2020-12-10T12:13:44.072469Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0xca7a464a3479af396c2975b4b3f5f7b90fc56747404ebaad5ec838c2954d2f9c",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "20"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:13:44.110973Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0xe5762ad08890c0ec55a2f0ce502afd35a7dcac2d71d6769f8b7eab53131b152612c5c50966625873ecdd43578afb4ebedfceaaace2a57bb7ef10e0e81213d7931c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    }
  ],
  "countUniqueNonce": 395
}
'''
'''--- src/tests/json/transactions/backend_queued_transaction_list_page_conflicts_394.json ---
{
  "count": 3,
  "next": null,
  "previous": null,
  "results": [
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f2565317f3ae8ae9ea98e9fe1e7fadc77f823cbd000000000000000000000000000000000000000000000000000000000000000a",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 41746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 393,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:10:42.476237Z",
      "modified": "2020-12-10T12:10:42.476237Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0x0fe072e76498e0db46fc79113662026a4f8fb34e840491aefeff6dec21c766cb",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "10"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:10:42.600252Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0x04027fccf5b43964ffbe8111f13fb7e53541da7c0752a31bfacc817cec2a1b1748e6ff6ae133238b6b43dd84191823bef2fd9841762c47faa989a503dcef4a0c1c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    },
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 26746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 394,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:11:24.354944Z",
      "modified": "2020-12-10T12:11:24.354944Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "20"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:11:24.377002Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0xd1f7a792512199a8cfb3e8745a38faf7b8383ab3eb4c1eda0ce3203283e535174012da4583dbc2f9c8c4329d7b65d4b2962450580cddd59fb2ecfc26b951e94d1c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    },
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 26746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 394,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:13:44.072469Z",
      "modified": "2020-12-10T12:13:44.072469Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0xca7a464a3479af396c2975b4b3f5f7b90fc56747404ebaad5ec838c2954d2f9c",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "20"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:13:44.110973Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0xe5762ad08890c0ec55a2f0ce502afd35a7dcac2d71d6769f8b7eab53131b152612c5c50966625873ecdd43578afb4ebedfceaaace2a57bb7ef10e0e81213d7931c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    }
  ],
  "countUniqueNonce": 395
}
'''
'''--- src/tests/json/transactions/backend_queued_transaction_list_page_no_conflicts.json ---
{
  "count": 3,
  "next": null,
  "previous": null,
  "results": [
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f2565317f3ae8ae9ea98e9fe1e7fadc77f823cbd000000000000000000000000000000000000000000000000000000000000000a",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 41746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 392,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:10:42.476237Z",
      "modified": "2020-12-10T12:10:42.476237Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0x0fe072e76498e0db46fc79113662026a4f8fb34e840491aefeff6dec21c766cb",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xf2565317F3Ae8Ae9EA98E9Fe1e7FADC77F823cbD"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "10"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:10:42.600252Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0x04027fccf5b43964ffbe8111f13fb7e53541da7c0752a31bfacc817cec2a1b1748e6ff6ae133238b6b43dd84191823bef2fd9841762c47faa989a503dcef4a0c1c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    },
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 26746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 393,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:11:24.354944Z",
      "modified": "2020-12-10T12:11:24.354944Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0x2e4af4b451a493470f38625c5f78f710f02303eb32780896cb55357c00d48faa",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "20"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:11:24.377002Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0xd1f7a792512199a8cfb3e8745a38faf7b8383ab3eb4c1eda0ce3203283e535174012da4583dbc2f9c8c4329d7b65d4b2962450580cddd59fb2ecfc26b951e94d1c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    },
    {
      "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
      "to": "0xD81F7D71ed570D121A1Ef9e3Bc0fc2bd6192De46",
      "value": "0",
      "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b840000000000000000000000000000000000000000000000000000000000000014",
      "operation": 0,
      "gasToken": "0x0000000000000000000000000000000000000000",
      "safeTxGas": 26746,
      "baseGas": 0,
      "gasPrice": "0",
      "refundReceiver": "0x0000000000000000000000000000000000000000",
      "nonce": 394,
      "executionDate": null,
      "submissionDate": "2020-12-10T12:13:44.072469Z",
      "modified": "2020-12-10T12:13:44.072469Z",
      "blockNumber": null,
      "transactionHash": null,
      "safeTxHash": "0xca7a464a3479af396c2975b4b3f5f7b90fc56747404ebaad5ec838c2954d2f9c",
      "executor": null,
      "isExecuted": false,
      "isSuccessful": null,
      "ethGasPrice": null,
      "gasUsed": null,
      "fee": null,
      "origin": null,
      "dataDecoded": {
        "method": "transfer",
        "parameters": [
          {
            "name": "to",
            "type": "address",
            "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
          },
          {
            "name": "value",
            "type": "uint256",
            "value": "20"
          }
        ]
      },
      "confirmationsRequired": null,
      "confirmations": [
        {
          "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
          "submissionDate": "2020-12-10T12:13:44.110973Z",
          "transactionHash": null,
          "confirmationType": "CONFIRMATION",
          "signature": "0xe5762ad08890c0ec55a2f0ce502afd35a7dcac2d71d6769f8b7eab53131b152612c5c50966625873ecdd43578afb4ebedfceaaace2a57bb7ef10e0e81213d7931c",
          "signatureType": "EOA"
        }
      ],
      "signatures": null,
      "trusted": false
    }
  ],
  "countUniqueNonce": 395
}
'''
'''--- src/tests/json/transactions/creation_transaction.json ---
{
  "created": "2020-06-15T07:40:39Z",
  "creator": "0xBe8C10Dbf4c6148f9834C56C3331f8191f355552",
  "transactionHash": "0xae835253566d4e04cd0493304aa588fd3a14bea665cb35212ff6d2f765373234",
  "factoryAddress": "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
  "masterCopy": "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
  "setupData": "0xb63e800d0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d5d82b6addc9027b22dca772aa68d5d74cdbdf440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000be8c10dbf4c6148f9834c56c3331f8191f3555520000000000000000000000000000000000000000000000000000000000000000",
  "dataDecoded": {
    "method": "setup",
    "parameters": [
      {
        "name": "_owners",
        "type": "address[]",
        "value": [
          "0xBe8C10Dbf4c6148f9834C56C3331f8191f355552"
        ]
      },
      {
        "name": "_threshold",
        "type": "uint256",
        "value": "1"
      },
      {
        "name": "to",
        "type": "address",
        "value": "0x0000000000000000000000000000000000000000"
      },
      {
        "name": "data",
        "type": "bytes",
        "value": "0x"
      },
      {
        "name": "fallbackHandler",
        "type": "address",
        "value": "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44"
      },
      {
        "name": "paymentToken",
        "type": "address",
        "value": "0x0000000000000000000000000000000000000000"
      },
      {
        "name": "payment",
        "type": "uint256",
        "value": "0"
      },
      {
        "name": "paymentReceiver",
        "type": "address",
        "value": "0x0000000000000000000000000000000000000000"
      }
    ]
  }
}

'''
'''--- src/tests/json/transactions/ethereum_inconsistent_token_types.json ---
{
  "executionDate": "2020-11-02T02:37:56Z",
  "to": "0xb07de4b2989E180F8907B8C7e617637C26cE2776",
  "data": "0x3971ee420000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000013400000000000000000000000094639a560b432efb363f430d653c880026b6dd78000000000000000000000000c5e823157debd8c60ccc6a3fdee3cbeabcfdfeda000000000000000000000000bd3aea6fae5cc8ad69b949f0b7d21c286ff49136000000000000000000000000353db79b0002d23d1bb790cfd869efe5089670df0000000000000000000000006c8e4d6f376336871821dbe369bfe444fdd1fc99000000000000000000000000629ae1f362a2bedb64c190e3ed96dfee963bd4880000000000000000000000004e1083f454cae424c8c1165d4f8e0ef5e462cba70000000000000000000000009643d74b68093876b86246b4889c37ac73457d7c000000000000000000000000128e00ff66d8bfb92923c5b8223f2db974220d69000000000000000000000000b325c1ac788f02ff7997cf53c6ff40dd762897b30000000000000000000000001398fe3c84b490fe1b49d6f0b1326d3c3c6bfe140000000000000000000000005941fdbc87c8e155f6a8f7f6e87fc67e1256d305000000000000000000000000db6c66d27a0388cd0331d1e47f67c79482f82d51000000000000000000000000cd59d9f3c6c2853476634380bc0c29a9e6e4e24d000000000000000000000000e15be66e88826bc1b9b6b763406193bcc998d5fd000000000000000000000000a6402cdd832d89fd78fb652a792800d63c602d21000000000000000000000000efb3cfad68314a6424660e1817d7a4d81e2b7373000000000000000000000000f02c7ae2031da410489afac7ff43f929b78caa9a00000000000000000000000008a5f1bfba3329c442abd27d93bd81c28dbc44580000000000000000000000006255e5d2b3f82e4025959c1a3e8f19fefe087cc2000000000000000000000000eb92c5860f22119eb5f506a2d028482a2ad362a00000000000000000000000008b0f6393d12a77885d102d3a07fc1706cc584f8b0000000000000000000000005f78bb8cc6e492a31c82c5d20e882a94f9cd59b700000000000000000000000090f85042533f11b362769ea9bee20334584dcd7d000000000000000000000000874b9c7f9bb441d60e9bdb868005f1c95fab4781000000000000000000000000f817d5600a0b1047d963e583382655bf3ca02ae400000000000000000000000051a33a5bba82f8ebd0fe2192a25ca2e60b9dc32f0000000000000000000000001dba12bd045fea43baa8876d9c2382d7b4ac46c7000000000000000000000000973e7bf17346681ad4d542a7ae483204b994001a0000000000000000000000008514a5e15d30caf76d7fcd8528928c56b93a8a57000000000000000000000000864ebf1b581b011f2eff85d030f9179eb469943b000000000000000000000000fee0f7bc42a0ac2caeab4952b25af0785879387b000000000000000000000000b6f47b02f8d4e1be6885f5a39edf584d396e42c4000000000000000000000000cd8d0156a654766b1a4eb6a1e6b1385fe8f737d000000000000000000000000013b7f66e740bc3fdb6f2c22302705ef03d4a5de700000000000000000000000098c967eceedfc8ada2f5e6601413340bfbc88ee700000000000000000000000081da4f0bcea8d330d790da28bf5349d29ad51fda0000000000000000000000005b89f4597f9ba4882b801ae5a617933341432f0f0000000000000000000000002760d810eac30c554201c938d75ca940f7fd10da000000000000000000000000afba8ae26a2495c2d4599a74f250d1744081a32f00000000000000000000000084fef68dac5766380fa074bbf9b943e1e6fb86e400000000000000000000000037168c0566c10d3cc57c74ea2c18577a1528d95f000000000000000000000000d2bc4e7ecfa4ec39069623854cd114dcd8771b84000000000000000000000000d1e3e8a30a9f599f8c3be92627e095a162d04908000000000000000000000000c31db2e710192791b65de43d4b84886a6d770322000000000000000000000000afea5b52c980bda1c5bd43dcb381a1b295213e77000000000000000000000000769eb3a5ab66cfee227ae68c3f828d7024ed659e0000000000000000000000007b750b2c1671c28e94e5b39ff82f179ff2afac07000000000000000000000000954dc267d92b32568c23dc3404d780f7921df69d000000000000000000000000ef08c3d5b02cf6240cf71908d5dbd497e361584f000000000000000000000000f51ed3805ea1321825b378e3f954912c84b7079b00000000000000000000000015e420570c475ec70cbd40af3366cd4a075195570000000000000000000000004bcc5ca6394971dde157dea794553d2b9de44b0f00000000000000000000000021427ebff254c817ae72560de70a8bc86f81512f0000000000000000000000003c3e4e713e333bbc44b36f89912b5d8dfecb725f000000000000000000000000a41487b4a93348a22edd861f7d52943b955b6d8d00000000000000000000000095a40112c37d79f6833935ec780495d5d3e23178000000000000000000000000762ac49fde60263d68259eab4efa0420ea5b65000000000000000000000000009909ea65f0b6a87d7d026c8968329c8ad3200535000000000000000000000000d6daccdae1de9d7639a247f5700f88e8a0e9d606000000000000000000000000c7e674cdd6d79d70c16d04a2c1df70b54ac67cc5000000000000000000000000250edd650bf6b312dce8238e9b725806534f512b0000000000000000000000003eb0510a2c0fe9a6aa367ebd455e011f912413fd000000000000000000000000e4db239bdbfc3fe1bf89d0d570f53f1dde24ebee000000000000000000000000c0398503eeb5c1db4748ab59e7635a576c599588000000000000000000000000ced3fc4610761f79242d7d8a72fe86f3a1c626b4000000000000000000000000cdb9c3494ef309a0e7588b6ad39de57a701ecf540000000000000000000000001d464d92570444bb387116ed879e8d28d603117800000000000000000000000055934ddd35c25dd4a0a17efe1cb443fc75db267b000000000000000000000000771861e854836843f7f09e17cd1b9489ec89b8120000000000000000000000007b0507e0b2feb81b3fd618ac13e85c3f1980738a0000000000000000000000001fe8317603ac38dc10842cee5c5a25efb1369b1f0000000000000000000000008cf1238bf670d12db9d12eb6a7584b415c8aa2e000000000000000000000000045f937d6032796b1e65d93a70c2c64c0e3eab62e0000000000000000000000004b827d771456abd5afc1d05837f915577729a751000000000000000000000000d7a0c14033521c7a8791d9f077f6cd7e5098d4910000000000000000000000005b8c253517b6bd003369173109693b01cb6841b50000000000000000000000000c4f0c0e59318048162b6b9ffe71a5f8f467cd2900000000000000000000000016587ca7d75b9f57bc240f3d09735f8a067377f2000000000000000000000000d72a0e4c9916ef172704b92601aab7677aef54020000000000000000000000007a5a81c3ee63eb217c2edaf1564d8fb77b39a2d3000000000000000000000000b02801d84f29872bb14fef7bc541a5af56d4e6c30000000000000000000000006fb2c607bbabbe81988f6791f44852295bc1fbc8000000000000000000000000e5e095c97c43496c7c23e87045fd3927759a89c900000000000000000000000066143d695baff44a3c8549bbdb16098d55674f9d000000000000000000000000c7295535fd467c135d5f922c9265becdcc228ac7000000000000000000000000eca96dae30960af5ad710bcedf748dd6adaa9c9a000000000000000000000000519a078911bd4d1fe5ef4cea15230c33adaeb351000000000000000000000000e4e39d747990c89d92592e4913120a139f2efc78000000000000000000000000e39e90e4e6950d4984b5f7cfe1e4cc192bc80f360000000000000000000000000b39a46d9fe2f26ffe03c5f32fdf19541e1e92c80000000000000000000000005fc8c4e0647fd62281901b9fc30c6eaaa6e749d3000000000000000000000000c87e7960c40d4fa4b050dd63ee63dc19e8d591af00000000000000000000000029b0b3e6f02f66fc610aa5749e70fc4497226a0c0000000000000000000000003271c01c8d5774de88b2feae825def92cf2f024f000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000006512cbdad4d76ff79d3e96ace168f2e1315c1ece000000000000000000000000ec8cd4183963c9ac572d8d654aee9778d162352d000000000000000000000000826c3064d4f5b9507152f5cb440ca9326e1ec8fa000000000000000000000000f30702ba3babd96e0de06d9cb0e81d4f870ee541000000000000000000000000fab11ff2499346e9cd39b08e5d396efc469d2b0e000000000000000000000000f32982d484f1ed13d414d44a748e2d479c77c3b9000000000000000000000000d32980c3cf70599181abb16c25efa731f029d8a500000000000000000000000003efa6c998a06e6b587e41d9ed9dfbb969de822f00000000000000000000000084dcfa3fdf29a52828ba359e936df55897a0195d0000000000000000000000007dff2df8fda8149ae089a9c7577fbbde4e2ff56c0000000000000000000000006ade2a21384818e48f02df53a8ed2436db0d740c0000000000000000000000005e5ba6b769db35d6c7e0a78888d3086fd898afe600000000000000000000000043094372a4417bb50863d86555726ccef3dde640000000000000000000000000e59ca38ffa335c3983d8c9221f225845b5d9367100000000000000000000000077bed8137d3c1640d0f45e5cd1be92291d22f7d3000000000000000000000000ff770424739a77b8990632c75ed859b74c0ef749000000000000000000000000920caffe2f546b21774e25f9315c82c12ec89b010000000000000000000000009a82aa6edbc473a883b8906bf41084c9c1b760f20000000000000000000000006cbfdb9609a1c8884556b8bc624e62bd8bcb0034000000000000000000000000a4d1ed57c4355de798e5dce4a0c9d9e71da2172e0000000000000000000000008f17c53533eba1dd94f07b83510696676e938441000000000000000000000000f7bd34dd44b92fb2f9c3d2e31aaad06570a853a6000000000000000000000000600b8a34ec1cfd8b8af78cfc49708419a16ea2e8000000000000000000000000142e67cd752722e020bacdcc9c0f317da24fb83b0000000000000000000000001d859d78437acf0cf821a372d28c9c78b3b61ee70000000000000000000000000de15c7925121aba9470a7757e920d4f393b95ab0000000000000000000000001ebc2a2cbbde95cb0d1b19f317d9a4ea3a375a8f000000000000000000000000a9bbc7693b47116220b3d5d0cdf85fa2c801be3d00000000000000000000000054a6cf34c1733cf7483f96efd9bffce81eac2874000000000000000000000000a261677d48433a8600b7bb466b1afede36f02cb7000000000000000000000000bc35b605cb9eb84a1ba26afc6a5179d70ba62c06000000000000000000000000fb7dc9dfa5da4f720e4d1ec575f7beae883b4c620000000000000000000000004c40503a9d73eca20854fa47cd6a7e85fc60a3c6000000000000000000000000562821c81bbbffa42443064917ee4d90036fba7c000000000000000000000000e3ea0fa2c310ceb55dc1978ca08380f21d81249e000000000000000000000000cbd7d22dd7f5b7e856478027844149c47999e38a00000000000000000000000011c3946dc1b186c2e8cdebbae4527b418a2395ee0000000000000000000000006de6e901bbefd26a9888798a25e4a49309d04ca9000000000000000000000000b619bc8fb9ad12c145eb0ef1f74a5b24b4d94922000000000000000000000000728742e8cb6ccf1fec195c5a7539fc87162daf2300000000000000000000000038e04c14968b625ff50538f7898efbca32527cfe0000000000000000000000005f0e6a5f0bd4fe2d8fbded8648689fbcccda02310000000000000000000000003d75c58e07ff3a44e296b0701b8a54055dbaa07e000000000000000000000000be67dcc306f745f2b7b06b5db67a3fd289b3bff4000000000000000000000000a168ea8f39d22ccf6bb7e08dc615e3391164acdf00000000000000000000000002d4f0ff6341eb0a58cd220db2955b168db280f50000000000000000000000000b503097062e3958e57dffa849c36458cecbd09200000000000000000000000021485722f25399f2190366bcb8b5d44589a8c8a8000000000000000000000000476ebecf4ad4982e0292bc8a9a1b5dda4eb867200000000000000000000000006b0a3aadfaae47cd8d56ec9861944748b4528263000000000000000000000000c58a62a70dda2eec41707b0c6bcfb71561979af2000000000000000000000000508c72b7951aec52e26fdf1cedb3637800e634a500000000000000000000000054758822f4e6530efde88f2747828318908bd1ba0000000000000000000000009684c0b24bc2ba3ab2165f409af3baaec674c4a40000000000000000000000006e3b17c99ba205891ec1af6f376c8e771e7e639000000000000000000000000045276a61559274033d23248b111cf16af57e51f6000000000000000000000000eb64b5609b4031db1a3aabe888a0b132642478ac000000000000000000000000459f67605890436db7f82f108654e483b2172c5700000000000000000000000019b0f54de434552eb632e8a50c8d9c5e0cd316ad000000000000000000000000a83fbae55302e56f98ebacea660e35f2ddcebd740000000000000000000000005f82c97e9b1755237692a946ae814998bc0e2124000000000000000000000000aa98c7afabbc0ea3acdc029a9d71b9ac83ff8cef000000000000000000000000ac8c02cfe81fc62964b4679e01ab3329eabda2d20000000000000000000000005b3f04882b11e5e25c43efeeb03cc06be18db28900000000000000000000000096e5beb992b9046378a807f9ef4d7b8c40b99f4f00000000000000000000000019c95f8bd9ea8bd93d05e3048250a679c97190d6000000000000000000000000c35ab820c9acefadfd96b4f4ea03a97c70a2d2ac000000000000000000000000c073dbf8752ac9f76fc043fce6aa667a4e240c5a0000000000000000000000004cddff23d036e15fe786508ffa39b27f73b4a01a0000000000000000000000000d4b70f17195a5ad610d903ff272c75973ba7410000000000000000000000000cf6b2ddff34d77802b39a4bfd1d9bcb887a93f7b000000000000000000000000bdc38612397355e10a2d6dd697a92f35bf1c9935000000000000000000000000f23c2071367b8ab605e16c6b0479d23793598b2b0000000000000000000000000f2fc57eab09055e2e522d257d56f7c141499de8000000000000000000000000e525f6ecdbbaefb95444b048c5449974efdbc5ca0000000000000000000000006977e753e022f65ebeb170d8267b2ea54a431523000000000000000000000000866bc7b764366e3e31e49ea6759e3698ba81928b000000000000000000000000922bf6407b136be55e827f7aea11f5f47a90c88d000000000000000000000000b96863b5a9bb3783c5ba0665e4382b766746d6fa000000000000000000000000290e9603dde0b26a65842c84dd75845d87c636070000000000000000000000007ecab8f041b1a47fbcc9bc600997e5590d09e9240000000000000000000000003fccc6dd12c16e6c25bdb1d71ff65ce86cf3621b000000000000000000000000f6adcf15a808d32ec0db6592695c201120e2c47800000000000000000000000077ee51ac95692ca9cd9c4878425ab73f664f0d470000000000000000000000001d22acc030d68b0e892564430b90a057634ed47b000000000000000000000000593065a46a507dc0da5146020efc1476067aab8c000000000000000000000000b5714084eef0f02efdd145dfb3fe2e3290591d7b0000000000000000000000005ba7d41ed4c65866cbed8fc457a62ef12505eabd000000000000000000000000b260d36965f41c6f0fa097efceae2e0ab15fcd8200000000000000000000000062fa2968ce2558a3e7dd7e333d2bf94e539816ee000000000000000000000000a1f0193a0715746f37e059b42d105abd40bd4e380000000000000000000000007ea7d6f535836f365c1ccb4410505d931e576e1400000000000000000000000054a5a4a492048080000ef50f90c69810716b207d000000000000000000000000e2ab71a9e0cb3939c0d487f4c26d2d4ae8d72a9c0000000000000000000000007fee1b58d513dbf5bb41b5baa359e99b239c255100000000000000000000000059f25862f3281a82ec66d780921b8dcd847dba14000000000000000000000000f15cc59b98527deebc865b17f3ebb7093a154238000000000000000000000000a64b6069cd630969253714e9a7e24d3f8455134d0000000000000000000000005ecd9a0d8d252cb25b39c30d4f4ed8533ad87a4e000000000000000000000000c96d78fac27ca36ce62ac8a24e3da007c9ea7ee6000000000000000000000000e6f31221b4c0d66373a49a54d1d3ce4f17eec03e000000000000000000000000e066215b3bce52e7c047e2cfa6b6c34e0cbff3e600000000000000000000000052c5ea0e19268051c34a13547426066225f59c38000000000000000000000000702188aab6bd5412eb0104b2f92d6de23f4dcf1f00000000000000000000000067922a9561423548a9ccfd67ad80d6c637c26bfe0000000000000000000000005d5f5afa475affae9a7f077326d568de32c4f5c4000000000000000000000000a449d4e5c892975798dae7507e9e3b496cd411fd000000000000000000000000f3ae3bbdeb2fb7f9c32fbb1f4fbdaf1150a1c5ce000000000000000000000000582e20f6257932a95f0eb97c2ee6ff8df42f852b000000000000000000000000221e4c70d16cd01bb71522348dfde88115be82e50000000000000000000000002178e6d50cc2a4248562a54fceafadf0f56472b000000000000000000000000025a88efbdadef5da7967fca48ea01d86fe35a03e0000000000000000000000000f5f4ed683f0f9bd7912e0ef4b00ba641b6b3546000000000000000000000000c084cef38e0a05270d06cb136eda85ba987a4d520000000000000000000000009c844a2ec1f22ea6309f0cacbe30ad0ace5317ce000000000000000000000000ae9e8ad50c4ed7181f3e19551a4a984359f1409c0000000000000000000000003dd546e60456cc06d51687dad722a734b73c0bee000000000000000000000000826c175d681f589231734722cc4c2fc2d8f9a99f0000000000000000000000004f50d47d20380172746527bbeaa274940c38efac000000000000000000000000371aafb30dfc5c2ec63bfe0e89455eb3b297703e0000000000000000000000001f2d71593150a8e38536b0b078e3ca9c9b26a7c90000000000000000000000000bd258d220c2524ca9992e873b03c1f556e3a38500000000000000000000000000e541a6e7d9ab69e9343c9ba357d5f6e367dfc20000000000000000000000003b96f42780993619e4b47b30387debbc98934220000000000000000000000000443585fca78817c8f36533c2322d427f0381715e0000000000000000000000002e1493555dbdb58bb61589fbee718286d7e690ba000000000000000000000000e3959b5921723012dc9d9c948a3737d85197014b000000000000000000000000258749962c9e2f96c059ab97d59ebce20b8436030000000000000000000000008dbe9ab6d0e207ca05bf83be64d6fdf98a295b27000000000000000000000000a9d5ce8a2cc355888c0a96e00bcc9748ad71f3d30000000000000000000000002f74044a9560d62c8e5ac362b1bdc6baf79b7660000000000000000000000000e2b284ae449c97a52a270ce8c23ca198d7dfab44000000000000000000000000f362a9d7ba3e2ff709f27d78c0545533763d06c100000000000000000000000047ed57f375d3dddae2ded7a6de522c35bc9419af000000000000000000000000928efa31db4d805dc355945a5ab3c8c7a8db2fe200000000000000000000000094e2bd0060eea1ab95f3774f3052eee2db6b60b4000000000000000000000000c0f9e8de7ce5ad40979de08b6b746ba47ca608cc0000000000000000000000001f9aa698b3781ea29878036773a0df87f5325d9800000000000000000000000094692b042a0e36671952ff0b71e43d6e0d06845a000000000000000000000000717bda626f1e8388babd061e7ad20b247644fbb5000000000000000000000000dfc367da383ad1fb5affd53ebf4e508709b98b240000000000000000000000003ebd5a0c6ca12a7d13145ba7113e1183ea0da380000000000000000000000000fec2ce5e68e8fd1f03888e026b41648e1277bf0e0000000000000000000000002f573a409666730ded9c02a843abc13c2b357e000000000000000000000000007af3edc58487bad40a21b93d90f14453282d8df3000000000000000000000000479c4a69b481449c4b92694eb32758cfc920735a000000000000000000000000ae60c874ee07f44fb7bbbd1a5087cdb66e90bed8000000000000000000000000268cb4c8b97da9d146702d84501a64f597a3aa1400000000000000000000000027cabbf0a0fcb73bcf779d97998376d65f307a7a000000000000000000000000aba7616b43f7ec88a603b0e2e46c4639206cf297000000000000000000000000a59379cc2fd562775324e61d820f446cf25b30730000000000000000000000004aab9e6eb125cdd378671188255f19325e3a804f00000000000000000000000072b223de2f773c814465c4a8f2ef9faae702cfb30000000000000000000000005db10e4c89a5224aa74e928dcbe80a0b3d9ef292000000000000000000000000d53fad2b2d98863882a873f7d1db6ba98c06a93a000000000000000000000000b7377dd86d8c1f15771c9f420e52325f8c18cc86000000000000000000000000e7ea7011246af68e71c0f7282e2209e8f70499a2000000000000000000000000bd9e0a744059bfb83dd9b6a07f050e295956abd900000000000000000000000079bfb08604feb9fcafca5647a603c6caa5a2980300000000000000000000000013e252df0cafe34116cec052177b7540afc75f76000000000000000000000000d1376fe1330752531fbd956fc57e6c1a11d5259e000000000000000000000000ead0d26003fc3b73f04a05db97e63d660a44f99f0000000000000000000000004346e413cdbcc131b6c006455e954108c815e539000000000000000000000000f8a7bf1f7198917331dd58448a0c352e09e391f50000000000000000000000007694e2c30b7f25726c4290bfe5799df5975fe56f000000000000000000000000198ad6c547d20d70f2f656a4f48e6c7cfb7b43250000000000000000000000004bdce3f6c2bfddb1cf32df8ddb7e1a6c862c1e92000000000000000000000000ebfb47a7ad0fd6e57323c8a42b2e5a6a4f68fc1a0000000000000000000000007ef2f7af07a2185465875c1fc099f8a8e38a84cd000000000000000000000000c27f848f0986044fa0c63b32193a597aeb8f666b0000000000000000000000007355ee3deaa1429b29375f240c66706e9ce9a50000000000000000000000000026de224cbe06fd4321ce5747a176cbbd24773beb00000000000000000000000076b7b7c7662f66eb590295c85b5cb83e12e1ce3e000000000000000000000000989adc42606c290aaf24cca7a209acaa25fc9f770000000000000000000000003cd1a28be614136e26f867c9fe47821fcf6dc7f600000000000000000000000065c3d3e4431c133e6d6331ab15e312a8b5873cda0000000000000000000000009970489e171254210edc739ac2577730a037755f00000000000000000000000050f617990b328de3cce1e2921db91ac294f4eb1a0000000000000000000000005310850866bbf6637223e222cf27db17cc0d788100000000000000000000000080586f344f91b76e67fd2c2a238067e7125156270000000000000000000000008a4508437197882a7960c6c1a01e2c41d554b0ec000000000000000000000000c8a81f01d0fe751dec94c9cb67e5214110d8feab0000000000000000000000000edcea1debd6fe371e94d3f7481536708dcca8cf000000000000000000000000e64387fa6a56fb958dd0a622849642c4ab2b9e3600000000000000000000000022cab81e0fee2bad5b015dbbeb6a374a1b8738de000000000000000000000000f6caaaaa35357e4c3e10ca3e40da4dd63682be8e0000000000000000000000000928a9382db99e42c17748c3c99d0730bc4455280000000000000000000000004034c56816d9cfa6476f23bb42bafb7bead1ab7a0000000000000000000000000e66cf7a7e7a7f4574670f6c2c9d463e1478a06c000000000000000000000000a38526fa20e5550b806aeb70491404506a6cb096000000000000000000000000965bedabfe79e18f07394f10b631d923c5b7e52b00000000000000000000000078e96be52e38b3fc3445a2ed34a6e586ffab9631000000000000000000000000d9a5c5bde6031f84422fbe53409804c403e1b1af000000000000000000000000fefc02fcfd02ed06770027ca00424aca4e5b90e7000000000000000000000000029cbfe5fa5ea8ed04f0d4e8e7051400238b0b610000000000000000000000004152d4ecc8a7c78ac4c5ef13b4f6f9c6a2cba5650000000000000000000000002089d2ae95feb77999361b67c05685a017868cc60000000000000000000000006df51f24eb1f234a8932cf89db91874a058582d9000000000000000000000000b78153be699b0aba0dc2446b8c6ca775506a6f3b000000000000000000000000b01e1183563acc3d71d67376b154ba5bb7d8ec39000000000000000000000000b025d5149c8ae7841882902f5b2de5a4036ccebe000000000000000000000000e07cc845fe401f5c7fa8bfb71e940b774ca776320000000000000000000000003608c988379efc4571d6f63336f14b5560f12db800000000000000000000000089e5eb2ac5340d83a4f746b29cf00cb44679c3b2000000000000000000000000e2877ccafe3cbc813ece98a63aee2b364300d2c1000000000000000000000000530defd6c816809f54f6cfa6fe873646f6ecf93000000000000000000000000028de2bd2ac425e26ee6c8f9d594bdb69c93fda180000000000000000000000008e6dc6891ae4c314e5065d34753c0156122417a6000000000000000000000000dba9a392f7d1339015d704e13228f91863bdc464000000000000000000000000d271f8c532c76b9a0970bb7f9f7ff2b5f9caceda0000000000000000000000004ef9823a4e96727da9d707ebc2c44b53378711eb00000000000000000000000089ea4b98dd4ff30bde3712378d37cad58b265eaf",
  "txHash": "0x2f920d8b75eff1857266643aedcfcf677b834ca164b6684a23a2c8e4574432ec",
  "blockNumber": 11174996,
  "transfers": [
    {
      "type": "ERC20_TRANSFER",
      "executionDate": "2020-11-02T02:37:56Z",
      "blockNumber": 11174996,
      "transactionHash": "0x2f920d8b75eff1857266643aedcfcf677b834ca164b6684a23a2c8e4574432ec",
      "to": "0xBc79855178842FDBA0c353494895DEEf509E26bB",
      "value": "856420144564",
      "tokenId": null,
      "tokenAddress": "0xb07de4b2989E180F8907B8C7e617637C26cE2776",
      "tokenInfo": {
        "type": "ERC721",
        "address": "0xb07de4b2989E180F8907B8C7e617637C26cE2776",
        "name": "A! WWW.SPACESWAP.APP ! TOP DEFI AGGREGATOR !",
        "symbol": "A! WWW.SPACESWAP.APP ! TOP DEFI AGGREGATOR !",
        "decimals": null,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xb07de4b2989E180F8907B8C7e617637C26cE2776.png"
      },
      "from": "0xd31e655bC4Eb5BCFe25A47d636B25bb4aa4041B2"
    }
  ],
  "txType": "ETHEREUM_TRANSACTION",
  "from": "0xd31e655bC4Eb5BCFe25A47d636B25bb4aa4041B2"
}
'''
'''--- src/tests/json/transactions/module_addOwnerWithThreshold_settings_change.json ---
{
  "created": "2020-12-01T18:04:14Z",
  "executionDate": "2020-12-01T18:04:14Z",
  "blockNumber": 7645325,
  "isSuccessful": true,
  "transactionHash": "0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f",
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "module": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "0",
  "data": "0x0d582f13000000000000000000000000a3daa0d9ae02daa17a664c232ada1b739ef5ae8d0000000000000000000000000000000000000000000000000000000000000002",
  "operation": 0,
  "dataDecoded": {
    "method": "addOwnerWithThreshold",
    "parameters": [
      {
        "name": "owner",
        "type": "address",
        "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
      },
      {
        "name": "_threshold",
        "type": "uint256",
        "value": "2"
      }
    ]
  },
  "transfers": [],
  "txType": "MODULE_TRANSACTION"
}

'''
'''--- src/tests/json/transactions/module_erc20_transfer.json ---
{
  "created": "2020-12-01T18:04:14Z",
  "executionDate": "2020-12-01T18:04:14Z",
  "blockNumber": 7645325,
  "isSuccessful": true,
  "transactionHash": "0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f",
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "module": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
  "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "value": "0",
  "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b8400000000000000000000000000000000000000000000000000005af3107a4000",
  "operation": 0,
  "dataDecoded": {
    "method": "transfer",
    "parameters": [
      {
        "name": "to",
        "type": "address",
        "value": "0xF353eBBa77e5E71c210599236686D51cA1F88b84"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "100000000000000"
      }
    ]
  },
  "transfers": [
    {
      "type": "ERC20_TRANSFER",
      "executionDate": "2020-12-01T18:04:14Z",
      "blockNumber": 7645325,
      "transactionHash": "0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f",
      "to": "0xF353eBBa77e5E71c210599236686D51cA1F88b84",
      "value": "100000000000000",
      "tokenId": null,
      "tokenAddress": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
      "tokenInfo": {
        "type": "ERC20",
        "address": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
        "name": "Compound USDT",
        "symbol": "USDT",
        "decimals": 18,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png"
      },
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MODULE_TRANSACTION"
}

'''
'''--- src/tests/json/transactions/module_erc721_transfer.json ---
{
  "created": "2020-12-01T18:04:14Z",
  "executionDate": "2020-12-01T18:04:14Z",
  "blockNumber": 7645325,
  "isSuccessful": true,
  "transactionHash": "0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f",
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "module": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
  "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "value": "0",
  "data": "0xa9059cbb000000000000000000000000f353ebba77e5e71c210599236686d51ca1f88b8400000000000000000000000000000000000000000000000000005af3107a4000",
  "operation": 0,
  "dataDecoded": {
    "method": "transfer",
    "parameters": [
      {
        "name": "to",
        "type": "address",
        "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "1316"
      }
    ]
  },
  "transfers": [
    {
      "type": "ERC721_TRANSFER",
      "executionDate": "2020-08-07T09:04:14Z",
      "blockNumber": 6975696,
      "transactionHash": "0xaed85c03ee20f4c3b76e6ebb46ceb8c8498a98c877089b870b421c8462ac5820",
      "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
      "value": null,
      "tokenId": "1316",
      "tokenAddress": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
      "tokenInfo": {
        "type": "ERC721",
        "address": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
        "name": "CryptoKitties",
        "symbol": "CK",
        "decimals": 0,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png"
      },
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MODULE_TRANSACTION"
}

'''
'''--- src/tests/json/transactions/module_ether_transfer.json ---
{
  "created": "2020-12-01T18:04:14Z",
  "executionDate": "2020-12-01T18:04:14Z",
  "blockNumber": 7645325,
  "isSuccessful": true,
  "transactionHash": "0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f",
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "module": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
  "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "value": "100000000000000000",
  "data": null,
  "operation": 0,
  "dataDecoded": null,
  "transfers": [],
  "txType": "MODULE_TRANSACTION"
}

'''
'''--- src/tests/json/transactions/module_newAndDifferentAddOwnerWithThreshold_settings_change.json ---
{
  "created": "2020-12-01T18:04:14Z",
  "executionDate": "2020-12-01T18:04:14Z",
  "blockNumber": 7645325,
  "isSuccessful": true,
  "transactionHash": "0xcd10b23687bf336d0f4c0a3383590d3d1722aaa99a41fd0d289a5f69a8266c8f",
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "module": "0xCFbFaC74C26F8647cBDb8c5caf80BB5b32E43134",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "0",
  "data": "0x0d582f13000000000000000000000000a3daa0d9ae02daa17a664c232ada1b739ef5ae8d0000000000000000000000000000000000000000000000000000000000000002",
  "operation": 0,
  "dataDecoded": {
    "method": "newAndDifferentAddOwnerWithThreshold",
    "parameters": [
      {
        "name": "owner",
        "type": "address",
        "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
      },
      {
        "name": "_threshold",
        "type": "uint256",
        "value": "2"
      }
    ]
  },
  "transfers": [],
  "txType": "MODULE_TRANSACTION"
}

'''
'''--- src/tests/json/transactions/module_transaction.json ---
{
  "created": "2020-03-04T10:52:19.106651Z",
  "executionDate": "2020-02-03T09:34:50Z",
  "blockNumber": 5905494,
  "isSuccessful": true,
  "transactionHash": "0x705167e310ef0acb80a5f73eb4f8e66cfb32a896ac9380f3eb43e68ef8603a9f",
  "safe": "0x9422ff6AFB126C31F62057e2853d65cBB73f4608",
  "module": "0xfa559f0932b7B60d90B4af0b8813d4088465096b",
  "to": "0xaAEb2035FF394fdB2C879190f95e7676f1A9444B",
  "value": "0",
  "data": "0x59f96ae500000000000000000000000000df91984582e6e96288307e9c2f20b38c8fece9000000000000000000000000c778417e063141139fce010982780140aa0cd5ab0000000000000000000000000000000000000000000000000000000000000475000000000000000000000000000000000000000000000003d962c8be3053def2",
  "operation": 0,
  "dataDecoded": null,
  "transfers": [],
  "txType": "MODULE_TRANSACTION"
}
'''
'''--- src/tests/json/transactions/module_transaction_failed.json ---
{
  "created": "2020-03-04T10:52:19.106651Z",
  "executionDate": "2020-02-03T09:34:50Z",
  "blockNumber": 5905494,
  "isSuccessful": false,
  "transactionHash": "0x705167e310ef0acb80a5f73eb4f8e66cfb32a896ac9380f3eb43e68ef8603a9f",
  "safe": "0x9422ff6AFB126C31F62057e2853d65cBB73f4608",
  "module": "0xfa559f0932b7B60d90B4af0b8813d4088465096b",
  "to": "0xaAEb2035FF394fdB2C879190f95e7676f1A9444B",
  "value": "0",
  "data": "0x59f96ae500000000000000000000000000df91984582e6e96288307e9c2f20b38c8fece9000000000000000000000000c778417e063141139fce010982780140aa0cd5ab0000000000000000000000000000000000000000000000000000000000000475000000000000000000000000000000000000000000000003d962c8be3053def2",
  "operation": 0,
  "dataDecoded": null,
  "transfers": [],
  "txType": "MODULE_TRANSACTION"
}
'''
'''--- src/tests/json/transactions/multisig_addOwnerWithThreshold_settings_change.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "0",
  "data": "0x0d582f13000000000000000000000000a3daa0d9ae02daa17a664c232ada1b739ef5ae8d0000000000000000000000000000000000000000000000000000000000000002",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 59786,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 135,
  "executionDate": "2020-07-22T14:57:11Z",
  "submissionDate": "2020-07-22T14:57:11Z",
  "modified": "2020-07-22T14:57:11Z",
  "blockNumber": 6884952,
  "transactionHash": "0x7a6373c2d18e6e9dda16f4bd7f16a24600314487f3e30fb63a227b368d18121a",
  "safeTxHash": "0x57d94fe21bbee8f6646c420ee23126cd1ba1b9a53a6c9b10099a043da8f32eea",
  "executor": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 86109,
  "fee": "86109000000000",
  "origin": null,
  "dataDecoded": {
    "method": "addOwnerWithThreshold",
    "parameters": [
      {
        "name": "owner",
        "type": "address",
        "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
      },
      {
        "name": "_threshold",
        "type": "uint256",
        "value": "2"
      }
    ]
  },
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-07-22T14:57:36.786743Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b0000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-07-22T14:57:36.802810Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x2e8318bcd59462b715384e39fd848ccd0f54610cacdbb6adb46ec5c374d1bd2f1f8b3e1873f292bcafffd62c59281a00e2890478f1dfe72866d6edf3fd3522711b",
      "signatureType": "EOA"
    }
  ],
  "signatures": "0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b00000000000000000000000000000000000000000000000000000000000000000012e8318bcd59462b715384e39fd848ccd0f54610cacdbb6adb46ec5c374d1bd2f1f8b3e1873f292bcafffd62c59281a00e2890478f1dfe72866d6edf3fd3522711b",
  "transfers": [],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_approve_custom.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "value": "0",
  "data": "0x095ea7b3000000000000000000000000ae9844f89d98c150f5e61bfc676d68b4921559900000000000000000000000000000000000000000000000000001c6bf52634000",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 43485,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 84,
  "executionDate": "2020-06-22T18:00:54Z",
  "submissionDate": "2020-06-22T14:58:34.037981Z",
  "modified": "2020-06-22T14:58:34.037981Z",
  "blockNumber": 6712892,
  "transactionHash": "0x0ebb2c317f55c96469e0ed2014f5833dc02a70b42f0ac52f4630938900caa698",
  "safeTxHash": "0x65df8a1e5a40703d9c67d5df6f9b552d3830faf0507c3d7350ba3764d3a68621",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 69856,
  "fee": "69856000000000",
  "origin": null,
  "dataDecoded": {
    "method": "approve",
    "parameters": [
      {
        "name": "spender",
        "type": "address",
        "value": "0xae9844F89D98c150F5e61bfC676D68b492155990"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "500000000000000"
      }
    ]
  },
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-06-22T14:58:34.055882Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x83b1506c409918f21031e93ed2f62310a5e0c05b1be89242a6a266a7de4af7bc6094e206b33387b8d4465af6087a4d2158815e613aeb186d88d9a1973e00bbe81b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-06-22T15:02:22.231589Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x83b1506c409918f21031e93ed2f62310a5e0c05b1be89242a6a266a7de4af7bc6094e206b33387b8d4465af6087a4d2158815e613aeb186d88d9a1973e00bbe81b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "transfers": [],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_awaiting_confirmations.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
  "value": "100000000000000000",
  "data": null,
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 29563,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 147,
  "executionDate": null,
  "submissionDate": "2020-07-24T09:50:56Z",
  "modified": "2020-07-24T09:50:56Z",
  "blockNumber": 6895247,
  "transactionHash": "0x0e4549a444eff6642d986296a50d48e0ec893e1ff3cef2ead3ffcdf0c7985b14",
  "safeTxHash": "0x6e631d27c638458329ba95cc17961e74b8146c46886545cd1984bb2bcf4eccd3",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": false,
  "isSuccessful": null,
  "ethGasPrice": "1000000000",
  "gasUsed": 55199,
  "fee": "55199000000000",
  "origin": null,
  "dataDecoded": null,
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-07-24T09:51:20.699502Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x99a878c1fb5eab0d695c35c57ee61db3e5722a3489db58497db671603835b704708a12df3126471bf357a6a2260dd0e01cced114d84028e2c5212ca4356e3c061b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "transfers": [
    {
      "type": "ETHER_TRANSFER",
      "executionDate": "2020-07-24T09:50:56Z",
      "blockNumber": 6895247,
      "transactionHash": "0x0e4549a444eff6642d986296a50d48e0ec893e1ff3cef2ead3ffcdf0c7985b14",
      "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
      "value": "100000000000000000",
      "tokenId": null,
      "tokenAddress": null,
      "tokenInfo": null,
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_awaiting_confirmations_empty.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "0",
  "data": null,
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 22881,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 251,
  "executionDate": null,
  "submissionDate": "2020-09-17T11:28:03Z",
  "modified": "2020-09-17T11:28:03Z",
  "blockNumber": 7212401,
  "transactionHash": "0xe1ab5dcd32433ad012e5dda690f968ded3d37425161790528cecbd7cf16187de",
  "safeTxHash": "0x9c4965cb4f0b4c650594bd26ee280ff20dd8236793b9f07260c161349037510b",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": false,
  "isSuccessful": null,
  "ethGasPrice": "1000000000",
  "gasUsed": 48457,
  "fee": "48457000000000",
  "origin": null,
  "dataDecoded": null,
  "confirmationsRequired": 3,
  "confirmations": [],
  "signatures": "0x7744eff991bea8be03f31604da4cc38974fa8f447ed9f0a4b8ac00e0385e915d59cf901b260ff262be1ac876b779520f254c2cc85538017de4a51161832757451b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_awaiting_confirmations_null.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "0",
  "data": null,
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 22881,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 251,
  "executionDate": null,
  "submissionDate": "2020-09-17T11:28:03Z",
  "modified": "2020-09-17T11:28:03Z",
  "blockNumber": 7212401,
  "transactionHash": "0xe1ab5dcd32433ad012e5dda690f968ded3d37425161790528cecbd7cf16187de",
  "safeTxHash": "0x9c4965cb4f0b4c650594bd26ee280ff20dd8236793b9f07260c161349037510b",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": false,
  "isSuccessful": null,
  "ethGasPrice": "1000000000",
  "gasUsed": 48457,
  "fee": "48457000000000",
  "origin": null,
  "dataDecoded": null,
  "confirmationsRequired": 3,
  "confirmations": null,
  "signatures": "0x7744eff991bea8be03f31604da4cc38974fa8f447ed9f0a4b8ac00e0385e915d59cf901b260ff262be1ac876b779520f254c2cc85538017de4a51161832757451b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_awaiting_confirmations_required_null.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
  "value": "100000000000000000",
  "data": null,
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 29563,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 147,
  "executionDate": null,
  "submissionDate": "2020-07-24T09:50:56Z",
  "modified": "2020-07-24T09:50:56Z",
  "blockNumber": 6895247,
  "transactionHash": "0x0e4549a444eff6642d986296a50d48e0ec893e1ff3cef2ead3ffcdf0c7985b14",
  "safeTxHash": "0x6e631d27c638458329ba95cc17961e74b8146c46886545cd1984bb2bcf4eccd3",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": false,
  "isSuccessful": null,
  "ethGasPrice": "1000000000",
  "gasUsed": 55199,
  "fee": "55199000000000",
  "origin": null,
  "dataDecoded": null,
  "confirmationsRequired": null,
  "confirmations": [
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-07-24T09:51:20.699502Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x99a878c1fb5eab0d695c35c57ee61db3e5722a3489db58497db671603835b704708a12df3126471bf357a6a2260dd0e01cced114d84028e2c5212ca4356e3c061b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "transfers": [
    {
      "type": "ETHER_TRANSFER",
      "executionDate": "2020-07-24T09:50:56Z",
      "blockNumber": 6895247,
      "transactionHash": "0x0e4549a444eff6642d986296a50d48e0ec893e1ff3cef2ead3ffcdf0c7985b14",
      "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
      "value": "100000000000000000",
      "tokenId": null,
      "tokenAddress": null,
      "tokenInfo": null,
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_awaiting_execution.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "0",
  "data": null,
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 22881,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 251,
  "executionDate": null,
  "submissionDate": "2020-09-17T11:28:03Z",
  "modified": "2020-09-17T11:28:03Z",
  "blockNumber": 7212401,
  "transactionHash": "0xe1ab5dcd32433ad012e5dda690f968ded3d37425161790528cecbd7cf16187de",
  "safeTxHash": "0x9c4965cb4f0b4c650594bd26ee280ff20dd8236793b9f07260c161349037510b",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": false,
  "isSuccessful": null,
  "ethGasPrice": "1000000000",
  "gasUsed": 48457,
  "fee": "48457000000000",
  "origin": null,
  "dataDecoded": null,
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-09-17T11:28:25.420652Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x7744eff991bea8be03f31604da4cc38974fa8f447ed9f0a4b8ac00e0385e915d59cf901b260ff262be1ac876b779520f254c2cc85538017de4a51161832757451b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-09-17T11:28:25.506478Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x7744eff991bea8be03f31604da4cc38974fa8f447ed9f0a4b8ac00e0385e915d59cf901b260ff262be1ac876b779520f254c2cc85538017de4a51161832757451b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_cancellation_transaction.json ---
{
  "safe": "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67",
  "to": "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67",
  "value": "0",
  "data": null,
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 0,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 38,
  "executionDate": "2021-02-10T16:42:19Z",
  "submissionDate": "2021-02-10T16:41:52.348029Z",
  "modified": "2021-02-10T16:42:44.011477Z",
  "blockNumber": 8049783,
  "transactionHash": "0x2f09090bca0b5409d4dc797c603acd226249999d1d17932fc5a6e71900365823",
  "safeTxHash": "0x2115301e6a038946deffb702ac192ad5d9cc769845fda4dfe0ed5a4b3d893f13",
  "executor": "0x4d3101d77Aac1B90aE42Efa38d235A81aF270d40",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "275000000000",
  "gasUsed": 48469,
  "fee": "13328975000000000",
  "origin": null,
  "dataDecoded": null,
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0xBe8C10Dbf4c6148f9834C56C3331f8191f355552",
      "submissionDate": "2021-02-10T16:41:52.365573Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x014635a679fe314e59f33cd0c325726cd2ded2ab968d1328b3de17a5d70cd8ac456da7ddc4c2ecf16cd84214f831ebf7fa534fa5345efa3f9c13abff2463e2121c",
      "signatureType": "EOA"
    },
    {
      "owner": "0x4d3101d77Aac1B90aE42Efa38d235A81aF270d40",
      "submissionDate": "2021-02-10T16:42:19Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x0000000000000000000000004d3101d77aac1b90ae42efa38d235a81af270d40000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x0000000000000000000000004d3101d77aac1b90ae42efa38d235a81af270d40000000000000000000000000000000000000000000000000000000000000000001014635a679fe314e59f33cd0c325726cd2ded2ab968d1328b3de17a5d70cd8ac456da7ddc4c2ecf16cd84214f831ebf7fa534fa5345efa3f9c13abff2463e2121c",
  "transfers": [],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}

'''
'''--- src/tests/json/transactions/multisig_confirmations_null.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
  "value": "100000000000000000",
  "data": null,
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 29563,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 147,
  "executionDate": null,
  "submissionDate": "2020-07-24T09:50:56Z",
  "modified": "2020-07-24T09:50:56Z",
  "blockNumber": 6895247,
  "transactionHash": "0x0e4549a444eff6642d986296a50d48e0ec893e1ff3cef2ead3ffcdf0c7985b14",
  "safeTxHash": "0x6e631d27c638458329ba95cc17961e74b8146c46886545cd1984bb2bcf4eccd3",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": false,
  "isSuccessful": null,
  "ethGasPrice": "1000000000",
  "gasUsed": 55199,
  "fee": "55199000000000",
  "origin": null,
  "dataDecoded": null,
  "confirmationsRequired": 2,
  "confirmations": null,
  "signatures": null,
  "transfers": [
    {
      "type": "ETHER_TRANSFER",
      "executionDate": "2020-07-24T09:50:56Z",
      "blockNumber": 6895247,
      "transactionHash": "0x0e4549a444eff6642d986296a50d48e0ec893e1ff3cef2ead3ffcdf0c7985b14",
      "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
      "value": "100000000000000000",
      "tokenId": null,
      "tokenAddress": null,
      "tokenInfo": null,
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_erc20_transfer.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "value": "0",
  "data": "0xa9059cbb00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b000000000000000000000000000000000000000000000000000002d79883d2000",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 35601,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 178,
  "executionDate": "2020-08-07T09:06:14Z",
  "submissionDate": "2020-08-07T08:51:35.193667Z",
  "modified": "2020-08-07T08:51:35.193667Z",
  "blockNumber": 6975704,
  "transactionHash": "0x08cf4bb6fe2a7e77e86e7679ec3c266516155cdc9900cdd47afef791169d6e21",
  "safeTxHash": "0x95e32bb8cb88ecdc45732c0a551eae7b3744187cf1ba19cda1440eaaf7b4950c",
  "executor": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 68346,
  "fee": "68346000000000",
  "origin": null,
  "dataDecoded": {
    "method": "transfer",
    "parameters": [
      {
        "name": "to",
        "type": "address",
        "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "50000000000000"
      }
    ]
  },
  "confirmationsRequired": 3,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-08-07T08:51:35.213346Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x2e8da6ff14c68a91caecbfdf71cdd134673f33903404bbaa2624808d7f728d0f551d26342f6eb8afa44cab779921b559311b03b7818088cbe8ca2861c7f473f81b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-08-07T09:04:34.526493Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x1018509bc2fc5f759430fa5740eeb49fe3699932ecf6539f56d42990a4afc782767961c9c88b8f7b5bba6b7b1637128b4b32c82f481f944dc7880787ce2d43b71b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
      "submissionDate": "2020-08-07T09:05:06.133804Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b23000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x2e8da6ff14c68a91caecbfdf71cdd134673f33903404bbaa2624808d7f728d0f551d26342f6eb8afa44cab779921b559311b03b7818088cbe8ca2861c7f473f81b000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b230000000000000000000000000000000000000000000000000000000000000000011018509bc2fc5f759430fa5740eeb49fe3699932ecf6539f56d42990a4afc782767961c9c88b8f7b5bba6b7b1637128b4b32c82f481f944dc7880787ce2d43b71b",
  "transfers": [
    {
      "type": "ERC20_TRANSFER",
      "executionDate": "2020-08-07T09:06:14Z",
      "blockNumber": 6975704,
      "transactionHash": "0x08cf4bb6fe2a7e77e86e7679ec3c266516155cdc9900cdd47afef791169d6e21",
      "to": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "value": "50000000000000",
      "tokenId": null,
      "tokenAddress": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
      "tokenInfo": {
        "type": "ERC20",
        "address": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
        "name": "Compound USDT",
        "symbol": "USDT",
        "decimals": 18,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png"
      },
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_erc20_transfer_delegate.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "value": "0",
  "data": "0xa9059cbb00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b000000000000000000000000000000000000000000000000000002d79883d2000",
  "operation": 1,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 35601,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 178,
  "executionDate": "2020-08-07T09:06:14Z",
  "submissionDate": "2020-08-07T08:51:35.193667Z",
  "modified": "2020-08-07T08:51:35.193667Z",
  "blockNumber": 6975704,
  "transactionHash": "0x08cf4bb6fe2a7e77e86e7679ec3c266516155cdc9900cdd47afef791169d6e21",
  "safeTxHash": "0x95e32bb8cb88ecdc45732c0a551eae7b3744187cf1ba19cda1440eaaf7b4950c",
  "executor": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 68346,
  "fee": "68346000000000",
  "origin": null,
  "dataDecoded": {
    "method": "transfer",
    "parameters": [
      {
        "name": "to",
        "type": "address",
        "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "50000000000000"
      }
    ]
  },
  "confirmationsRequired": 3,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-08-07T08:51:35.213346Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x2e8da6ff14c68a91caecbfdf71cdd134673f33903404bbaa2624808d7f728d0f551d26342f6eb8afa44cab779921b559311b03b7818088cbe8ca2861c7f473f81b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-08-07T09:04:34.526493Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x1018509bc2fc5f759430fa5740eeb49fe3699932ecf6539f56d42990a4afc782767961c9c88b8f7b5bba6b7b1637128b4b32c82f481f944dc7880787ce2d43b71b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
      "submissionDate": "2020-08-07T09:05:06.133804Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b23000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x2e8da6ff14c68a91caecbfdf71cdd134673f33903404bbaa2624808d7f728d0f551d26342f6eb8afa44cab779921b559311b03b7818088cbe8ca2861c7f473f81b000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b230000000000000000000000000000000000000000000000000000000000000000011018509bc2fc5f759430fa5740eeb49fe3699932ecf6539f56d42990a4afc782767961c9c88b8f7b5bba6b7b1637128b4b32c82f481f944dc7880787ce2d43b71b",
  "transfers": [
    {
      "type": "ERC20_TRANSFER",
      "executionDate": "2020-08-07T09:06:14Z",
      "blockNumber": 6975704,
      "transactionHash": "0x08cf4bb6fe2a7e77e86e7679ec3c266516155cdc9900cdd47afef791169d6e21",
      "to": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "value": "50000000000000",
      "tokenId": null,
      "tokenAddress": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
      "tokenInfo": {
        "type": "ERC20",
        "address": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
        "name": "Compound USDT",
        "symbol": "USDT",
        "decimals": 18,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png"
      },
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_erc20_transfer_invalid_to_and_from.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "value": "0",
  "data": "0xa9059cbb00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b000000000000000000000000000000000000000000000000000002d79883d2000",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 35601,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 178,
  "executionDate": "2020-08-07T09:06:14Z",
  "submissionDate": "2020-08-07T08:51:35.193667Z",
  "modified": "2020-08-07T08:51:35.193667Z",
  "blockNumber": 6975704,
  "transactionHash": "0x08cf4bb6fe2a7e77e86e7679ec3c266516155cdc9900cdd47afef791169d6e21",
  "safeTxHash": "0x95e32bb8cb88ecdc45732c0a551eae7b3744187cf1ba19cda1440eaaf7b4950c",
  "executor": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 68346,
  "fee": "68346000000000",
  "origin": null,
  "dataDecoded": {
    "method": "transferFrom",
    "parameters": [
      {
        "name": "from",
        "type": "address",
        "value": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"
      },
      {
        "name": "to",
        "type": "address",
        "value": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "50000000000000"
      }
    ]
  },
  "confirmationsRequired": 3,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-08-07T08:51:35.213346Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x2e8da6ff14c68a91caecbfdf71cdd134673f33903404bbaa2624808d7f728d0f551d26342f6eb8afa44cab779921b559311b03b7818088cbe8ca2861c7f473f81b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-08-07T09:04:34.526493Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x1018509bc2fc5f759430fa5740eeb49fe3699932ecf6539f56d42990a4afc782767961c9c88b8f7b5bba6b7b1637128b4b32c82f481f944dc7880787ce2d43b71b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
      "submissionDate": "2020-08-07T09:05:06.133804Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b23000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x2e8da6ff14c68a91caecbfdf71cdd134673f33903404bbaa2624808d7f728d0f551d26342f6eb8afa44cab779921b559311b03b7818088cbe8ca2861c7f473f81b000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b230000000000000000000000000000000000000000000000000000000000000000011018509bc2fc5f759430fa5740eeb49fe3699932ecf6539f56d42990a4afc782767961c9c88b8f7b5bba6b7b1637128b4b32c82f481f944dc7880787ce2d43b71b",
  "transfers": [
    {
      "type": "ERC20_TRANSFER",
      "executionDate": "2020-08-07T09:06:14Z",
      "blockNumber": 6975704,
      "transactionHash": "0x08cf4bb6fe2a7e77e86e7679ec3c266516155cdc9900cdd47afef791169d6e21",
      "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
      "value": "50000000000000",
      "tokenId": null,
      "tokenAddress": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
      "tokenInfo": {
        "type": "ERC20",
        "address": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
        "name": "Compound USDT",
        "symbol": "USDT",
        "decimals": 18,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png"
      },
      "from": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_erc20_transfer_with_value.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
  "value": "100000000000000000",
  "data": "0xa9059cbb00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b000000000000000000000000000000000000000000000000000002d79883d2000",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 35601,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 178,
  "executionDate": "2020-08-07T09:06:14Z",
  "submissionDate": "2020-08-07T08:51:35.193667Z",
  "modified": "2020-08-07T08:51:35.193667Z",
  "blockNumber": 6975704,
  "transactionHash": "0x08cf4bb6fe2a7e77e86e7679ec3c266516155cdc9900cdd47afef791169d6e21",
  "safeTxHash": "0x95e32bb8cb88ecdc45732c0a551eae7b3744187cf1ba19cda1440eaaf7b4950c",
  "executor": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 68346,
  "fee": "68346000000000",
  "origin": null,
  "dataDecoded": {
    "method": "transfer",
    "parameters": [
      {
        "name": "to",
        "type": "address",
        "value": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "50000000000000"
      }
    ]
  },
  "confirmationsRequired": 3,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-08-07T08:51:35.213346Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x2e8da6ff14c68a91caecbfdf71cdd134673f33903404bbaa2624808d7f728d0f551d26342f6eb8afa44cab779921b559311b03b7818088cbe8ca2861c7f473f81b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-08-07T09:04:34.526493Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x1018509bc2fc5f759430fa5740eeb49fe3699932ecf6539f56d42990a4afc782767961c9c88b8f7b5bba6b7b1637128b4b32c82f481f944dc7880787ce2d43b71b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
      "submissionDate": "2020-08-07T09:05:06.133804Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b23000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x2e8da6ff14c68a91caecbfdf71cdd134673f33903404bbaa2624808d7f728d0f551d26342f6eb8afa44cab779921b559311b03b7818088cbe8ca2861c7f473f81b000000000000000000000000bea2f9227230976d2813a2f8b922c22be1de1b230000000000000000000000000000000000000000000000000000000000000000011018509bc2fc5f759430fa5740eeb49fe3699932ecf6539f56d42990a4afc782767961c9c88b8f7b5bba6b7b1637128b4b32c82f481f944dc7880787ce2d43b71b",
  "transfers": [
    {
      "type": "ERC20_TRANSFER",
      "executionDate": "2020-08-07T09:06:14Z",
      "blockNumber": 6975704,
      "transactionHash": "0x08cf4bb6fe2a7e77e86e7679ec3c266516155cdc9900cdd47afef791169d6e21",
      "to": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "value": "50000000000000",
      "tokenId": null,
      "tokenAddress": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
      "tokenInfo": {
        "type": "ERC20",
        "address": "0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02",
        "name": "Compound USDT",
        "symbol": "USDT",
        "decimals": 18,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02.png"
      },
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_erc721_transfer.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
  "value": "0",
  "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e76443000000000000000000000000000000000000000000000000000000000000000524",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 47810,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 177,
  "executionDate": "2020-08-07T09:04:14Z",
  "submissionDate": "2020-08-07T07:20:33.720911Z",
  "modified": "2020-08-07T07:20:33.720911Z",
  "blockNumber": 6975696,
  "transactionHash": "0xaed85c03ee20f4c3b76e6ebb46ceb8c8498a98c877089b870b421c8462ac5820",
  "safeTxHash": "0x9155f7741dd33572bc49c251eb4f4a5e9cf9653151417bdc4a2aca0767779603",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 80507,
  "fee": "80507000000000",
  "origin": null,
  "dataDecoded": {
    "method": "transfer",
    "parameters": [
      {
        "name": "to",
        "type": "address",
        "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "1316"
      }
    ]
  },
  "confirmationsRequired": 3,
  "confirmations": [
    {
      "owner": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
      "submissionDate": "2020-08-07T07:20:33.735857Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x55e23dbe4136564b32e9c4f0963459c9317f13fe01d6f76cdf6da053211bd2e46edc38aa07373736af12e3a8021317a9f22e1707f62bd947a704fd0d3e4c17d11c",
      "signatureType": "EOA"
    },
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-08-07T08:54:31.475781Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x76419e64fba1bebc7aaaf350a9b5018c7a50ea559394871a249ce850c39cd489743bd1b720c557ea56136eed572aaebbd511f8aaf06ca517d8e43b148f88892b1b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-08-07T09:04:41.000194Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x76419e64fba1bebc7aaaf350a9b5018c7a50ea559394871a249ce850c39cd489743bd1b720c557ea56136eed572aaebbd511f8aaf06ca517d8e43b148f88892b1b55e23dbe4136564b32e9c4f0963459c9317f13fe01d6f76cdf6da053211bd2e46edc38aa07373736af12e3a8021317a9f22e1707f62bd947a704fd0d3e4c17d11c000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "transfers": [
    {
      "type": "ERC721_TRANSFER",
      "executionDate": "2020-08-07T09:04:14Z",
      "blockNumber": 6975696,
      "transactionHash": "0xaed85c03ee20f4c3b76e6ebb46ceb8c8498a98c877089b870b421c8462ac5820",
      "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
      "value": null,
      "tokenId": "1316",
      "tokenAddress": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
      "tokenInfo": {
        "type": "ERC721",
        "address": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
        "name": "CryptoKitties",
        "symbol": "CK",
        "decimals": 0,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png"
      },
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_erc721_transfer_cancelled.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85",
  "value": "0",
  "data": "0x42842e0e0000000000000000000000001230b3d59858296a31053c1b8562ecf89a2f888b000000000000000000000000938bae50a210b80ea233112800cd5bc2e7644300a3126f45b5579c653f626d160ebeb64c01750811c06f0b9cff136458e6e05b86",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 53781,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 235,
  "executionDate": null,
  "submissionDate": "2020-09-11T12:30:01.306123Z",
  "modified": "2020-09-11T12:30:01.306123Z",
  "blockNumber": null,
  "transactionHash": null,
  "safeTxHash": "0x41ce7f78a1616a3d161719bb847c51df2fe39dd27009b766620975c833efa74e",
  "executor": null,
  "isExecuted": false,
  "isSuccessful": null,
  "ethGasPrice": null,
  "gasUsed": null,
  "fee": null,
  "origin": null,
  "dataDecoded": {
    "method": "safeTransferFrom",
    "parameters": [
      {
        "name": "from",
        "type": "address",
        "value": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
      },
      {
        "name": "to",
        "type": "address",
        "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "value": "73759565539416811842765838110575927933836232265069912251972739501781285886854"
      }
    ]
  },
  "confirmationsRequired": null,
  "confirmations": [
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-09-11T12:30:01.507073Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0xd969a9c3be9745547cda407352f28854512cd0d8916596078f775e72e7b88ff32260a56278103fee88442b459adde3f482c478f2d344dfcd5468e026998ba8db1c",
      "signatureType": "EOA"
    }
  ],
  "signatures": null,
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_erc721_transfer_invalid_to_and_from.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
  "value": "0",
  "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e76443000000000000000000000000000000000000000000000000000000000000000524",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 47810,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 177,
  "executionDate": "2020-08-07T09:04:14Z",
  "submissionDate": "2020-08-07T07:20:33.720911Z",
  "modified": "2020-08-07T07:20:33.720911Z",
  "blockNumber": 6975696,
  "transactionHash": "0xaed85c03ee20f4c3b76e6ebb46ceb8c8498a98c877089b870b421c8462ac5820",
  "safeTxHash": "0x9155f7741dd33572bc49c251eb4f4a5e9cf9653151417bdc4a2aca0767779603",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 80507,
  "fee": "80507000000000",
  "origin": null,
  "dataDecoded": {
    "method": "safeTransferFrom",
    "parameters": [
      {
        "name": "from",
        "type": "address",
        "value": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF"
      },
      {
        "name": "to",
        "type": "address",
        "value": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "1316"
      }
    ]
  },
  "confirmationsRequired": 3,
  "confirmations": [
    {
      "owner": "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23",
      "submissionDate": "2020-08-07T07:20:33.735857Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x55e23dbe4136564b32e9c4f0963459c9317f13fe01d6f76cdf6da053211bd2e46edc38aa07373736af12e3a8021317a9f22e1707f62bd947a704fd0d3e4c17d11c",
      "signatureType": "EOA"
    },
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-08-07T08:54:31.475781Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x76419e64fba1bebc7aaaf350a9b5018c7a50ea559394871a249ce850c39cd489743bd1b720c557ea56136eed572aaebbd511f8aaf06ca517d8e43b148f88892b1b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-08-07T09:04:41.000194Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x76419e64fba1bebc7aaaf350a9b5018c7a50ea559394871a249ce850c39cd489743bd1b720c557ea56136eed572aaebbd511f8aaf06ca517d8e43b148f88892b1b55e23dbe4136564b32e9c4f0963459c9317f13fe01d6f76cdf6da053211bd2e46edc38aa07373736af12e3a8021317a9f22e1707f62bd947a704fd0d3e4c17d11c000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "transfers": [
    {
      "type": "ERC721_TRANSFER",
      "executionDate": "2020-08-07T09:04:14Z",
      "blockNumber": 6975696,
      "transactionHash": "0xaed85c03ee20f4c3b76e6ebb46ceb8c8498a98c877089b870b421c8462ac5820",
      "to": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
      "value": null,
      "tokenId": "1316",
      "tokenAddress": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
      "tokenInfo": {
        "type": "ERC721",
        "address": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF",
        "name": "CryptoKitties",
        "symbol": "CK",
        "decimals": 0,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF.png"
      },
      "from": "0x16baF0dE678E52367adC69fD067E5eDd1D33e3bF"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_ether_transfer.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
  "value": "100000000000000000",
  "data": null,
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 29563,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 147,
  "executionDate": "2020-07-24T09:50:56Z",
  "submissionDate": "2020-07-24T09:50:56Z",
  "modified": "2020-07-24T09:50:56Z",
  "blockNumber": 6895247,
  "transactionHash": "0x0e4549a444eff6642d986296a50d48e0ec893e1ff3cef2ead3ffcdf0c7985b14",
  "safeTxHash": "0x6e631d27c638458329ba95cc17961e74b8146c46886545cd1984bb2bcf4eccd3",
  "executor": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 55199,
  "fee": "55199000000000",
  "origin": null,
  "dataDecoded": null,
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-07-24T09:51:20.593608Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x99a878c1fb5eab0d695c35c57ee61db3e5722a3489db58497db671603835b704708a12df3126471bf357a6a2260dd0e01cced114d84028e2c5212ca4356e3c061b",
      "signatureType": "EOA"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-07-24T09:51:20.699502Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0x99a878c1fb5eab0d695c35c57ee61db3e5722a3489db58497db671603835b704708a12df3126471bf357a6a2260dd0e01cced114d84028e2c5212ca4356e3c061b000000000000000000000000f2cea96575d6b10f51d9af3b10e3e4e5738aa6bd000000000000000000000000000000000000000000000000000000000000000001",
  "transfers": [
    {
      "type": "ETHER_TRANSFER",
      "executionDate": "2020-07-24T09:50:56Z",
      "blockNumber": 6895247,
      "transactionHash": "0x0e4549a444eff6642d986296a50d48e0ec893e1ff3cef2ead3ffcdf0c7985b14",
      "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
      "value": "100000000000000000",
      "tokenId": null,
      "tokenAddress": null,
      "tokenInfo": null,
      "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_failed_transfer.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x2C7943707fA6d3cA6Ed1c92759a4195F20246c47",
  "value": "0",
  "data": "0xa9059cbb000000000000000000000000938bae50a210b80ea233112800cd5bc2e76443000000000000000000000000000000000000000000000000000000000000000005",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 0,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 245,
  "executionDate": "2020-09-17T07:57:46Z",
  "submissionDate": "2020-09-16T15:53:44.268044Z",
  "modified": "2020-09-16T15:53:44.268044Z",
  "blockNumber": 7211560,
  "transactionHash": "0x00d3813d752de89dbccd4d136866949749fc529dacdafc731edfd4ed00c0a573",
  "safeTxHash": "0x84e78b32767b1dddd6d75a28a54d670dfe88e39b8efc37cb3e9fa5aeb543c172",
  "executor": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
  "isExecuted": true,
  "isSuccessful": false,
  "ethGasPrice": "1000000000",
  "gasUsed": 47710,
  "fee": "47710000000000",
  "origin": null,
  "dataDecoded": {
    "method": "transfer",
    "parameters": [
      {
        "name": "to",
        "type": "address",
        "value": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
      },
      {
        "name": "value",
        "type": "uint256",
        "value": "5"
      }
    ]
  },
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-09-16T15:53:44.281711Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b0000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-09-16T15:54:09.989678Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x818dd5227aa4c40bd8d21c8d808ac28ba7412d1927cc2175a3d7de4e28c5b7f3283625666e69e68c968e10f5dca2b92a3d45d7c013b1da223c1eec99625aac301b",
      "signatureType": "EOA"
    }
  ],
  "signatures": "0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b0000000000000000000000000000000000000000000000000000000000000000001818dd5227aa4c40bd8d21c8d808ac28ba7412d1927cc2175a3d7de4e28c5b7f3283625666e69e68c968e10f5dca2b92a3d45d7c013b1da223c1eec99625aac301b",
  "trusted": false
}

'''
'''--- src/tests/json/transactions/multisig_newAndDifferentAddOwnerWithThreshold_settings_change.json ---
{
  "safe": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "0",
  "data": "0x0d582f13000000000000000000000000a3daa0d9ae02daa17a664c232ada1b739ef5ae8d0000000000000000000000000000000000000000000000000000000000000002",
  "operation": 0,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 59786,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 135,
  "executionDate": "2020-07-22T14:57:11Z",
  "submissionDate": "2020-07-22T14:57:11Z",
  "modified": "2020-07-22T14:57:11Z",
  "blockNumber": 6884952,
  "transactionHash": "0x7a6373c2d18e6e9dda16f4bd7f16a24600314487f3e30fb63a227b368d18121a",
  "safeTxHash": "0x57d94fe21bbee8f6646c420ee23126cd1ba1b9a53a6c9b10099a043da8f32eea",
  "executor": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "1000000000",
  "gasUsed": 86109,
  "fee": "86109000000000",
  "origin": null,
  "dataDecoded": {
    "method": "newAndDifferentAddOwnerWithThreshold",
    "parameters": [
      {
        "name": "owner",
        "type": "address",
        "value": "0xA3DAa0d9Ae02dAA17a664c232aDa1B739eF5ae8D"
      },
      {
        "name": "_threshold",
        "type": "uint256",
        "value": "2"
      }
    ]
  },
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0x65F8236309e5A99Ff0d129d04E486EBCE20DC7B0",
      "submissionDate": "2020-07-22T14:57:36.786743Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b0000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    },
    {
      "owner": "0xF2CeA96575d6b10f51d9aF3b10e3e4E5738aa6bd",
      "submissionDate": "2020-07-22T14:57:36.802810Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x2e8318bcd59462b715384e39fd848ccd0f54610cacdbb6adb46ec5c374d1bd2f1f8b3e1873f292bcafffd62c59281a00e2890478f1dfe72866d6edf3fd3522711b",
      "signatureType": "EOA"
    }
  ],
  "signatures": "0x00000000000000000000000065f8236309e5a99ff0d129d04e486ebce20dc7b00000000000000000000000000000000000000000000000000000000000000000012e8318bcd59462b715384e39fd848ccd0f54610cacdbb6adb46ec5c374d1bd2f1f8b3e1873f292bcafffd62c59281a00e2890478f1dfe72866d6edf3fd3522711b",
  "transfers": [],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transactions/multisig_with_origin.json ---
{
  "safe": "0xBc79855178842FDBA0c353494895DEEf509E26bB",
  "to": "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
  "value": "0",
  "data": "0x8d80ff0a00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000bd900111111125434b319222cdbf8c261674adb56f3ae000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000b8490411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "operation": 1,
  "gasToken": "0x0000000000000000000000000000000000000000",
  "safeTxGas": 124625,
  "baseGas": 0,
  "gasPrice": "0",
  "refundReceiver": "0x0000000000000000000000000000000000000000",
  "nonce": 160,
  "executionDate": "2020-12-07T13:11:55Z",
  "submissionDate": "2020-12-07T13:11:24.674471Z",
  "modified": "2020-12-07T13:11:24.674471Z",
  "blockNumber": 11405861,
  "transactionHash": "0x4d84602bf94d099159baa41993edca288abb5f9795dd51cc14bd66195b9fdc77",
  "safeTxHash": "0x728e6dec56dc61523b56dc440e34c1c4c39c66895df8e5d3499ed1f7d4fcfe80",
  "executor": "0xe965484BA4250c446779D4703f1598DC2EA00d12",
  "isExecuted": true,
  "isSuccessful": true,
  "ethGasPrice": "52000000000",
  "gasUsed": 161721,
  "fee": "8409492000000000",
  "origin": "{\"url\":\"https://apps.gnosis-safe.io/walletConnect\",\"name\":\"WalletConnect\"}",
  "dataDecoded": {
    "method": "multiSend",
    "parameters": [
      {
        "name": "transactions",
        "type": "bytes",
        "value": "0x00111111125434b319222cdbf8c261674adb56f3ae000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000b8490411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "valueDecoded": [
          {
            "operation": 0,
            "to": "0x111111125434b319222CdBf8C261674aDB56F3ae",
            "value": "22",
            "data": "0x90411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "dataDecoded": {
              "method": "swap",
              "parameters": [
                {
                  "name": "caller",
                  "type": "address",
                  "value": "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5"
                },
                {
                  "name": "desc",
                  "type": "(address,address,address,address,uint256,uint256,uint256,uint256,address,bytes)",
                  "value": [
                    "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
                    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
                    "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5",
                    "0xBc79855178842FDBA0c353494895DEEf509E26bB",
                    "70000000000000000000000",
                    "69930000000000000000000",
                    "70000000000000000000000",
                    "1",
                    "0x0000000000000000000000000000000000000000",
                    "0x"
                  ]
                },
                {
                  "name": "calls",
                  "type": "(uint256,uint256,uint256,bytes)[]",
                  "value": [
                    [
                      "0",
                      "0",
                      "0",
                      "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                    ],
                    [
                      "0",
                      "0",
                      "0",
                      "0x7f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000"
                    ],
                    [
                      "0",
                      "0",
                      "0",
                      "0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000"
                    ]
                  ]
                }
              ]
            }
          }
        ]
      }
    ]
  },
  "confirmationsRequired": 2,
  "confirmations": [
    {
      "owner": "0xc9d486048A9B82172F6f2A2ce6D9024c9D1097dC",
      "submissionDate": "2020-12-07T13:11:24.686613Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0xbd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c",
      "signatureType": "EOA"
    },
    {
      "owner": "0xe965484BA4250c446779D4703f1598DC2EA00d12",
      "submissionDate": "2020-12-07T13:11:55Z",
      "transactionHash": null,
      "confirmationType": "CONFIRMATION",
      "signature": "0x000000000000000000000000e965484ba4250c446779d4703f1598dc2ea00d12000000000000000000000000000000000000000000000000000000000000000001",
      "signatureType": "APPROVED_HASH"
    }
  ],
  "signatures": "0xbd42f5c205b544cc6397c8c2e592ca4ade02b8681673cc8c555ff1777b002ee959c3cca243a77a2de1bbe1b61413342ac7d6416a31ec0ff31bb1029e921202ee1c000000000000000000000000e965484ba4250c446779d4703f1598dc2ea00d12000000000000000000000000000000000000000000000000000000000000000001",
  "transfers": [
    {
      "type": "ETHER_TRANSFER",
      "executionDate": "2020-12-07T13:11:55Z",
      "blockNumber": 11405861,
      "transactionHash": "0x4d84602bf94d099159baa41993edca288abb5f9795dd51cc14bd66195b9fdc77",
      "to": "0x111111125434b319222CdBf8C261674aDB56F3ae",
      "value": "70000000000000000000000",
      "tokenId": null,
      "tokenAddress": null,
      "tokenInfo": null,
      "from": "0xBc79855178842FDBA0c353494895DEEf509E26bB"
    },
    {
      "type": "ERC20_TRANSFER",
      "executionDate": "2020-12-07T13:11:55Z",
      "blockNumber": 11405861,
      "transactionHash": "0x4d84602bf94d099159baa41993edca288abb5f9795dd51cc14bd66195b9fdc77",
      "to": "0xBc79855178842FDBA0c353494895DEEf509E26bB",
      "value": "70000000000000000000000",
      "tokenId": null,
      "tokenAddress": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      "tokenInfo": {
        "type": "ERC20",
        "address": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        "name": "Wrapped Ether",
        "symbol": "WETH",
        "decimals": 18,
        "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2.png"
      },
      "from": "0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5"
    }
  ],
  "txType": "MULTISIG_TRANSACTION",
  "trusted": false
}
'''
'''--- src/tests/json/transfers/erc20_transfer_with_erc721_token_info.json ---
{
  "type": "ERC20_TRANSFER",
  "executionDate": "2020-10-31T09:31:21Z",
  "blockNumber": 11163817,
  "transactionHash": "0x317db9d079e46fef2f758e37bd20efb14d5c83e2510307079207bc6f04cdee48",
  "to": "0xBc79855178842FDBA0c353494895DEEf509E26bB",
  "value": "856420144564",
  "tokenId": null,
  "tokenAddress": "0xa9517B2E61a57350D6555665292dBC632C76adFe",
  "tokenInfo": {
    "type": "ERC721",
    "address": "0xa9517B2E61a57350D6555665292dBC632C76adFe",
    "name": "a!NEVER VISIT www.168pools.com to check DeFi ROi !",
    "symbol": "a!NEVER VISIT www.168pools.com to check DeFi ROi !",
    "decimals": null,
    "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0xa9517B2E61a57350D6555665292dBC632C76adFe.png"
  },
  "from": "0xd31e655bC4Eb5BCFe25A47d636B25bb4aa4041B2"
}

'''
'''--- src/tests/json/transfers/erc_20_transfer_unexpected_param_names.json ---
{
    "safe": "0x1C8b9B78e3085866521FE206fa4c1a67F49f153A",
    "to": "0xc778417E063141139Fce010982780140Aa0cD5Ab",
    "value": "0",
    "data": "0xa9059cbb0000000000000000000000001c8b9b78e3085866521fe206fa4c1a67f49f153a000000000000000000000000000000000000000000000000002386f26fc10000",
    "operation": 0,
    "gasToken": "0x0000000000000000000000000000000000000000",
    "safeTxGas": 0,
    "baseGas": 0,
    "gasPrice": "0",
    "refundReceiver": "0x0000000000000000000000000000000000000000",
    "nonce": 388,
    "executionDate": "2022-01-17T09:03:41Z",
    "submissionDate": "2022-01-06T15:38:30.563130Z",
    "modified": "2022-01-17T09:04:07.223308Z",
    "blockNumber": 10005930,
    "transactionHash": "0xd0b5e6ce2685c680f7c7e2b1c03bb94ec704d16c19a2b834eac1fd06d7e5f6d9",
    "safeTxHash": "0x0437839bd4e5449c474b93328b1e27eb2f387e71eb0992f09da7ba4d484905a7",
    "executor": "0xD28293bf13549Abb49Ed1D83D515301A05E3Fc8d",
    "isExecuted": true,
    "isSuccessful": true,
    "ethGasPrice": "1500000057",
    "gasUsed": 65010,
    "fee": "97515003705570",
    "origin": null,
    "dataDecoded": {
        "method": "transfer",
        "parameters": [
            {
                "name": "dst",
                "type": "address",
                "value": "0x1C8b9B78e3085866521FE206fa4c1a67F49f153A"
            },
            {
                "name": "wad",
                "type": "uint256",
                "value": "10000000000000000"
            }
        ]
    },
    "confirmationsRequired": 2,
    "confirmations": [
        {
            "owner": "0xE86935943315293154c7AD63296b4e1adAc76364",
            "submissionDate": "2022-01-06T15:38:30.587408Z",
            "transactionHash": null,
            "signature": "0xcfde7a3d0aa3dd52db66ebcd3518b3d667184f390c0eac09c608ed21ce80c8cb22a2b494febc18da555d236a81fdab4d3adcde3c58e1e67c0cf869ada30fb1ea1c",
            "signatureType": "EOA"
        },
        {
            "owner": "0x5c9E7b93900536D9cc5559b881375Bae93c933D0",
            "submissionDate": "2022-01-10T16:48:07.329109Z",
            "transactionHash": null,
            "signature": "0xf464c18947105d68781095f547211a5b8c834b6b1d6cd87a8a7dd43cfc33821e71b7ef1dd83ad5a5739961b381f3555e6f0125faf56b728878fec847e7eec5a71b",
            "signatureType": "EOA"
        }
    ],
    "signatures": "0xf464c18947105d68781095f547211a5b8c834b6b1d6cd87a8a7dd43cfc33821e71b7ef1dd83ad5a5739961b381f3555e6f0125faf56b728878fec847e7eec5a71bcfde7a3d0aa3dd52db66ebcd3518b3d667184f390c0eac09c608ed21ce80c8cb22a2b494febc18da555d236a81fdab4d3adcde3c58e1e67c0cf869ada30fb1ea1c",
    "trusted": false
}
'''
'''--- src/tests/json/transfers/erc_20_transfer_with_token_info_incoming.json ---
{
  "type": "ERC20_TRANSFER",
  "executionDate": "2020-08-11T16:12:33Z",
  "blockNumber": 7000442,
  "transactionHash": "0x3663ae11e5414620b0fd7fe7c8175e4356070a0a403e6e6516d7aece29b7680d",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "1000000000000000000",
  "tokenId": null,
  "tokenAddress": "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa",
  "from": "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F",
  "tokenInfo": {
    "type": "ERC20",
    "address": "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa",
    "name": "Dai",
    "symbol": "DAI",
    "decimals": 18,
    "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png"
  }
}
'''
'''--- src/tests/json/transfers/erc_20_transfer_with_token_info_outgoing.json ---
{
  "type": "ERC20_TRANSFER",
  "executionDate": "2020-08-11T16:12:33Z",
  "blockNumber": 7000442,
  "transactionHash": "0x3663ae11e5414620b0fd7fe7c8175e4356070a0a403e6e6516d7aece29b7680d",
  "to": "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F",
  "value": "1000000000000000000",
  "tokenId": null,
  "tokenAddress": "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa",
  "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "tokenInfo": {
    "type": "ERC20",
    "address": "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa",
    "name": "Dai",
    "symbol": "DAI",
    "decimals": 18,
    "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa.png"
  }
}
'''
'''--- src/tests/json/transfers/erc_20_transfer_without_token_info.json ---
{
  "type": "ERC20_TRANSFER",
  "executionDate": "2020-08-11T16:12:33Z",
  "blockNumber": 7000442,
  "transactionHash": "0x3663ae11e5414620b0fd7fe7c8175e4356070a0a403e6e6516d7aece29b7680d",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "1000000000000000000",
  "tokenId": null,
  "tokenAddress": "0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa",
  "from": "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F"
}
'''
'''--- src/tests/json/transfers/erc_721_transfer_with_token_info_incoming.json ---
{
  "type": "ERC721_TRANSFER",
  "executionDate": "2020-07-24T12:34:11Z",
  "blockNumber": 6895900,
  "transactionHash": "0x6b4ddfcf19320e1edaad5bcdef3da54f463ee5cb609ba4a1e2042fbff702e718",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": null,
  "tokenId": "37",
  "tokenAddress": "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98",
  "from": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
  "tokenInfo": {
    "type": "ERC721",
    "address": "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98",
    "name": "PV Memorial Token",
    "symbol": "PVT",
    "decimals": 0,
    "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png"
  }
}
'''
'''--- src/tests/json/transfers/erc_721_transfer_with_token_info_outgoing.json ---
{
  "type": "ERC721_TRANSFER",
  "executionDate": "2020-07-24T12:34:11Z",
  "blockNumber": 6895900,
  "transactionHash": "0x6b4ddfcf19320e1edaad5bcdef3da54f463ee5cb609ba4a1e2042fbff702e718",
  "to": "0x938bae50a210b80EA233112800Cd5Bc2e7644300",
  "value": null,
  "tokenId": "37",
  "tokenAddress": "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98",
  "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "tokenInfo": {
    "type": "ERC721",
    "address": "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98",
    "name": "PV Memorial Token",
    "symbol": "PVT",
    "decimals": 0,
    "logoUri": "https://gnosis-safe-token-logos.s3.amazonaws.com/0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98.png"
  }
}
'''
'''--- src/tests/json/transfers/erc_721_transfer_without_token_info.json ---
{
  "type": "ERC721_TRANSFER",
  "executionDate": "2020-07-24T12:34:11Z",
  "blockNumber": 6895900,
  "transactionHash": "0x6b4ddfcf19320e1edaad5bcdef3da54f463ee5cb609ba4a1e2042fbff702e718",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": null,
  "tokenId": "37",
  "tokenAddress": "0x8979D84FF2c2B797dFEc02469d3a5322cBEf4b98",
  "from": "0x938bae50a210b80EA233112800Cd5Bc2e7644300"
}
'''
'''--- src/tests/json/transfers/ether_transfer_incoming.json ---
{
  "type": "ETHER_TRANSFER",
  "executionDate": "2020-08-18T06:53:51Z",
  "blockNumber": 7038526,
  "transactionHash": "0x41b610e8cce50bbe3aa06d6953ecc5f92a838aedc024a265c0afca7ec4f33bdf",
  "to": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b",
  "value": "1000000000000000",
  "tokenId": null,
  "tokenAddress": null,
  "tokenInfo": null,
  "from": "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F"
}
'''
'''--- src/tests/json/transfers/ether_transfer_outgoing.json ---
{
  "type": "ETHER_TRANSFER",
  "executionDate": "2020-08-18T06:53:51Z",
  "blockNumber": 7038526,
  "transactionHash": "0x41b610e8cce50bbe3aa06d6953ecc5f92a838aedc024a265c0afca7ec4f33bdf",
  "to": "0xfFfa5813ED9a5DB4880D7303DB7d0cBe41bC771F",
  "value": "1000000000000000",
  "tokenId": null,
  "tokenAddress": null,
  "tokenInfo": null,
  "from": "0x1230B3d59858296A31053C1b8562Ecf89A2f888b"
}
'''
'''--- src/tests/main.rs ---
use std::sync::Arc;

use dotenv::dotenv;
use rocket::{Build, Rocket, Route};

use crate::cache::manager::ChainCache;
use crate::cache::{Cache, MockCache};
use crate::utils::http_client::{HttpClient, MockHttpClient};
use crate::{create_cache_manager, RedisCacheManager};

#[cfg(test)]
pub async fn setup_rocket(
    mock_http_client: MockHttpClient,
    routes: impl Into<Vec<Route>>,
) -> Rocket<Build> {
    dotenv().ok();
    let cache_manager = create_cache_manager().await;
    cache_manager
        .cache_for_chain(ChainCache::Mainnet)
        .invalidate_pattern("*")
        .await;
    cache_manager
        .cache_for_chain(ChainCache::Other)
        .invalidate_pattern("*")
        .await;

    rocket::build()
        .mount("/", routes)
        .manage(Arc::new(mock_http_client) as Arc<dyn HttpClient>)
        .manage(Arc::new(cache_manager) as Arc<dyn RedisCacheManager>)
}

#[cfg(test)]
pub fn setup_rocket_with_mock_cache(
    mock_http_client: MockHttpClient,
    mock_cache: MockCache,
    routes: impl Into<Vec<Route>>,
) -> Rocket<Build> {
    dotenv().ok();

    rocket::build()
        .mount("/", routes)
        .manage(Arc::new(mock_http_client) as Arc<dyn HttpClient>)
        .manage(Arc::new(mock_cache) as Arc<dyn Cache>)
}

#[rocket::async_test]
pub async fn main_produces_valid_rocket_instance() {
    let _ = crate::rocket().await;
}

'''
'''--- src/tests/mod.rs ---
mod backend_url;
pub mod json;
pub mod main;

'''
'''--- src/utils/context.rs ---
use std::sync::Arc;

use rocket::request::{self, FromRequest, Request};
use rocket_okapi::gen::OpenApiGenerator;
use rocket_okapi::request::{OpenApiFromRequest, RequestHeaderInput};

use crate::cache::manager::ChainCache;
use crate::cache::Cache;
use crate::config::scheme;
use crate::utils::http_client::HttpClient;
use crate::RedisCacheManager;

pub struct RequestContext {
    pub request_id: String,
    pub host: String,
    http_client: Arc<dyn HttpClient>,
    cache_manager: Arc<dyn RedisCacheManager>,
}

impl RequestContext {
    pub fn http_client(&self) -> Arc<dyn HttpClient> {
        self.http_client.clone()
    }

    pub fn cache(&self, chain_cache: ChainCache) -> Arc<dyn Cache> {
        self.cache_manager.cache_for_chain(chain_cache)
    }

    #[cfg(test)]
    pub async fn setup_for_test(
        request_id: String,
        host: String,
        http_client: &Arc<dyn HttpClient>,
        cache_manager: &Arc<dyn RedisCacheManager>,
    ) -> Self {
        cache_manager
            .cache_for_chain(ChainCache::Mainnet)
            .invalidate_pattern("*")
            .await;
        cache_manager
            .cache_for_chain(ChainCache::Other)
            .invalidate_pattern("*")
            .await;

        RequestContext {
            request_id,
            host,
            http_client: http_client.clone(),
            cache_manager: cache_manager.clone(),
        }
    }
}

#[rocket::async_trait]
impl<'r> FromRequest<'r> for RequestContext {
    type Error = ();

    async fn from_request(request: &'r Request<'_>) -> request::Outcome<Self, Self::Error> {
        let cache_manager = request
            .rocket()
            .state::<Arc<dyn RedisCacheManager>>()
            .expect("RedisCacheManager unavailable. Is it added to rocket instance?")
            .clone();
        let http_client = request
            .rocket()
            .state::<Arc<dyn HttpClient>>()
            .expect("HttpClient unavailable. Is it added to rocket instance?")
            .clone();
        let host = request
            .headers()
            .get_one("Host")
            .expect("Request Host must be available");

        let uri = request.uri().to_string();
        let host = format!("{}://{}", scheme(), host.to_string());

        return request::Outcome::Success(RequestContext {
            request_id: uri,
            host,
            cache_manager,
            http_client,
        });
    }
}

/// Implements [OpenApiFromRequest] for [RequestContext]
/// This is required for custom types that implement [FromRequest]
/// Since we do not want to set any headers on OpenApi for [RequestContext] we return [RequestHeaderInput::None]
impl<'a> OpenApiFromRequest<'a> for RequestContext {
    fn from_request_input(
        _gen: &mut OpenApiGenerator,
        _name: String,
        _required: bool,
    ) -> rocket_okapi::Result<RequestHeaderInput> {
        Ok(RequestHeaderInput::None)
    }
}

'''
'''--- src/utils/cors.rs ---
use rocket::fairing::{Fairing, Info, Kind};
use rocket::http::{ContentType, Header, Method, Status};
use rocket::{Request, Response};

pub struct CORS();

#[rocket::async_trait]
impl Fairing for CORS {
    fn info(&self) -> Info {
        Info {
            name: "Add CORS headers to requests",
            kind: Kind::Response,
        }
    }

    async fn on_response<'r>(&self, request: &'r Request<'_>, response: &mut Response<'r>) {
        // https://github.com/lawliet89/rocket_cors/blob/master/examples/fairing.rs
        if request.method() == Method::Options || response.content_type() == Some(ContentType::JSON)
        {
            response.set_header(Header::new("Access-Control-Allow-Origin", "*"));
            response.set_header(Header::new(
                "Access-Control-Allow-Methods",
                "POST, GET, OPTIONS",
            ));
            response.set_header(Header::new(
                "Access-Control-Allow-Headers",
                "X-Requested-With, Content-Type, Authorization",
            ));
            response.set_header(Header::new("Access-Control-Allow-Credentials", "true"));
        }
        if request.method() == Method::Options && request.route().is_none() {
            response.set_header(ContentType::Plain);
            response.set_status(Status::NoContent);
            let _ = response.body_mut().take();
        }
    }
}

'''
'''--- src/utils/errors.rs ---
use crate::config::log_all_error_responses;
use crate::utils::http_client::Response as HttpClientResponse;
use reqwest::StatusCode;
use rocket::http::{ContentType, Status};
use rocket::request::Request;
use rocket::response::{self, Responder, Response};
use rocket::serde::json::Error;
use rocket_okapi::gen::OpenApiGenerator;
use rocket_okapi::okapi::openapi3::Responses;
use rocket_okapi::okapi::schemars::{self, JsonSchema};
use rocket_okapi::response::OpenApiResponderInner;
use rocket_okapi::OpenApiError;
use serde::{Deserialize, Serialize};
use serde_json;
use serde_json::value::Value;
use std::fmt;
use std::io::Cursor;
use std::result::Result;
use thiserror::Error;

pub type ApiResult<T, E = ApiError> = Result<T, E>;

#[derive(Error, Debug, PartialEq, JsonSchema)]
#[cfg_attr(test, derive(Serialize, Deserialize))]
pub struct ApiError {
    pub status: u16,
    pub details: ErrorDetails,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, JsonSchema)]
pub struct ErrorDetails {
    pub code: u64,
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub debug: Option<Value>,
}

impl ApiError {
    pub fn from_backend_error(status_code: u16, raw_error: &str) -> Self {
        let error_details = match serde_json::from_str::<ErrorDetails>(&raw_error) {
            Ok(backend_error) => backend_error,
            Err(_) => ErrorDetails {
                code: 42,
                message: Some(raw_error.to_owned()),
                arguments: None,
                debug: None,
            },
        };
        Self::new(status_code, error_details)
    }

    pub fn from_http_response(response: &HttpClientResponse) -> Self {
        Self::new_from_message_with_code(response.status_code, response.body.to_string())
    }

    pub fn new_from_message(message: impl Into<String>) -> Self {
        Self::new(
            500,
            ErrorDetails {
                code: 1337,
                message: Some(message.into()),
                arguments: None,
                debug: None,
            },
        )
    }

    pub fn new_from_message_with_debug(message: impl Into<String>, debug: Option<Value>) -> Self {
        Self::new(
            500,
            ErrorDetails {
                code: 1337,
                message: Some(message.into()),
                arguments: None,
                debug,
            },
        )
    }

    pub fn new_from_message_with_code(status_code: u16, message: String) -> Self {
        Self::new(
            status_code,
            ErrorDetails {
                code: 1337,
                message: Some(message),
                arguments: None,
                debug: None,
            },
        )
    }

    pub fn new(status_code: u16, message: ErrorDetails) -> Self {
        Self {
            status: status_code,
            details: message,
        }
    }
}

// Set to no documentation for different http codes in swagger
impl OpenApiResponderInner for ApiError {
    fn responses(_generator: &mut OpenApiGenerator) -> Result<Responses, OpenApiError> {
        Ok(Responses::default())
    }
}

impl fmt::Display for ErrorDetails {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "ApiErrorMessage: code:{:?}; message:{:?}; arguments:{:?}",
            &self.code, &self.message, &self.arguments
        )
    }
}

impl fmt::Display for ApiError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ApiError({}: {})", self.status, self.details)
    }
}

impl<'r> Responder<'r, 'static> for ApiError {
    fn respond_to(self, request: &'r Request<'_>) -> response::Result<'static> {
        if log_all_error_responses() || (self.status >= 500 && self.status < 600) {
            log::error!(
                "ERR::{}::{}::{}",
                self.status,
                request.uri().to_string(),
                self.details
            );
        }
        let resp = serde_json::to_string(&self.details).unwrap_or(String::from(
            &self
                .details
                .message
                .unwrap_or("No message error from backend".to_string()),
        ));
        Response::build()
            .sized_body(resp.len(), Cursor::new(resp))
            .header(ContentType::JSON)
            .status(Status::from_code(self.status).unwrap_or(Status::new(self.status)))
            .ok()
    }
}

impl From<reqwest::Error> for ApiError {
    fn from(err: reqwest::Error) -> Self {
        // We first check if err.is_timeout because in case of timeout the default error code is 500
        // However we want to map it to a GATEWAY_TIMEOUT (504)
        let status_code = if err.is_timeout() {
            StatusCode::GATEWAY_TIMEOUT
        } else {
            err.status().unwrap_or(StatusCode::INTERNAL_SERVER_ERROR)
        };
        Self::new_from_message_with_code(status_code.as_u16(), format!("{:?}", err))
    }
}

impl From<serde_json::error::Error> for ApiError {
    fn from(err: serde_json::error::Error) -> Self {
        Self::new_from_message(format!("{:?}", err))
    }
}

impl From<rocket::serde::json::Error<'_>> for ApiError {
    fn from(err: Error<'_>) -> Self {
        let message = match err {
            Error::Io(_) => String::from("Request deserialize IO error"),
            Error::Parse(_request_json, json_error) => json_error.to_string(),
        };
        Self::new_from_message_with_code(422, message)
    }
}

'''
'''--- src/utils/http_client.rs ---
use crate::config::default_request_timeout;
#[cfg(not(test))]
use crate::config::internal_client_connect_timeout;
use crate::utils::errors::{ApiError, ApiResult};
use core::time::Duration;
use mockall::automock;
use reqwest::header::{HeaderMap, HeaderName, HeaderValue, CONTENT_TYPE};
use std::collections::HashMap;

#[derive(PartialEq, Debug)]
pub struct Request {
    url: String,
    body: Option<String>,
    timeout: Duration,
    headers: HashMap<String, String>,
}

impl Request {
    pub fn new(url: String) -> Self {
        Request {
            url,
            body: None,
            timeout: Duration::from_millis(default_request_timeout()),
            headers: HashMap::default(),
        }
    }

    pub fn timeout(&mut self, timeout: Duration) -> &mut Self {
        self.timeout = timeout;
        self
    }

    pub fn body(&mut self, body: Option<String>) -> &mut Self {
        self.body = body;
        self
    }

    pub fn add_header(&mut self, header: (&str, &str)) -> &mut Self {
        self.headers
            .insert(String::from(header.0), String::from(header.1));
        self
    }
}

#[derive(PartialEq, Debug)]
pub struct Response {
    pub body: String,
    pub status_code: u16,
}

impl Response {
    pub fn is_server_error(&self) -> bool {
        500 <= self.status_code && self.status_code < 600
    }

    pub fn is_client_error(&self) -> bool {
        400 <= self.status_code && self.status_code < 500
    }

    pub fn is_success(&self) -> bool {
        200 <= self.status_code && self.status_code < 300
    }

    /// Maps a [reqwest::Response] into a [ApiResult<Response>]
    /// If the response is a client error [400, 500[ or a server error [500, 600[ then
    /// an [ApiError] is returned as a failure. [Response] is returned otherwise.
    ///
    /// # Arguments
    ///
    /// * `reqwest_response`: The [reqwest::Response] to be mapped
    ///
    /// returns: Result<Response, ApiError>
    async fn from(reqwest_response: reqwest::Response) -> ApiResult<Self> {
        let status_code = reqwest_response.status().as_u16();
        let body: String = reqwest_response.text().await?;
        let response = Response { body, status_code };

        if response.is_client_error() || response.is_server_error() {
            Err(ApiError::from_http_response(&response))
        } else {
            Ok(response)
        }
    }
}

#[automock]
#[rocket::async_trait]
pub trait HttpClient: Send + Sync {
    async fn get(&self, request: Request) -> ApiResult<Response>;
    async fn post(&self, request: Request) -> ApiResult<Response>;
    async fn delete(&self, request: Request) -> ApiResult<Response>;
}

#[rocket::async_trait]
impl HttpClient for reqwest::Client {
    async fn get(&self, request: Request) -> ApiResult<Response> {
        let response = self
            .get(&request.url)
            .timeout(request.timeout)
            .headers(map_headers(&request.headers))
            .send()
            .await?;
        Response::from(response).await
    }

    async fn post(&self, request: Request) -> ApiResult<Response> {
        let body = request.body.unwrap_or(String::from(""));
        let response = self
            .post(&request.url)
            .header(CONTENT_TYPE, "application/json")
            .body(body)
            .headers(map_headers(&request.headers))
            .timeout(request.timeout)
            .send()
            .await?;
        Response::from(response).await
    }

    async fn delete(&self, request: Request) -> ApiResult<Response> {
        let body = request.body.unwrap_or(String::from(""));
        let response = self
            .delete(&request.url)
            .header(CONTENT_TYPE, "application/json")
            .body(body)
            .headers(map_headers(&request.headers))
            .timeout(request.timeout)
            .send()
            .await?;
        Response::from(response).await
    }
}

fn map_headers(headers_input: &HashMap<String, String>) -> HeaderMap {
    let mut headers = HeaderMap::new();
    for (name, value) in headers_input {
        headers.insert(
            HeaderName::from_bytes(name.as_bytes())
                .expect(&format!("Header name '{}' is not supported", &name)),
            HeaderValue::from_str(value).expect(&format!("Invalid header value for '{}'", &name)),
        );
    }
    headers
}

#[cfg(test)]
pub fn setup_http_client() -> impl HttpClient {
    MockHttpClient::new()
}

#[cfg(not(test))]
pub fn setup_http_client() -> impl HttpClient {
    reqwest::Client::builder()
        .connect_timeout(Duration::from_millis(internal_client_connect_timeout()))
        .build()
        .unwrap()
}

'''
'''--- src/utils/json.rs ---
use serde::{Deserialize, Deserializer};

pub fn try_deserialize<'de, D, T>(deserializer: D) -> Result<Option<T>, D::Error>
where
    D: Deserializer<'de>,
    T: Deserialize<'de>,
{
    Ok(T::deserialize(deserializer).ok())
}

pub fn default_if_null<'de, D, T>(deserializer: D) -> Result<T, D::Error>
where
    D: serde::Deserializer<'de>,
    T: Default + serde::Deserialize<'de>,
{
    <Option<T> as serde::Deserialize>::deserialize(deserializer)
        .map(|result| result.unwrap_or_default())
}

'''
'''--- src/utils/mod.rs ---
use crate::common::models::data_decoded::ValueDecodedType::InternalTransaction;
use crate::common::models::data_decoded::{DataDecoded, ParamValue, ValueDecodedType};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

pub mod context;
pub mod cors;
pub mod errors;
pub mod http_client;
pub mod json;
pub mod transactions;
pub mod urls;

#[cfg(test)]
mod tests;

pub const TRANSFER_METHOD: &str = "transfer";
pub const TRANSFER_FROM_METHOD: &str = "transferFrom";
pub const SAFE_TRANSFER_FROM_METHOD: &str = "safeTransferFrom";
pub const ERC20_TRANSFER_METHODS: &[&str] = &[TRANSFER_METHOD, TRANSFER_FROM_METHOD];
pub const ERC721_TRANSFER_METHODS: &[&str] = &[
    TRANSFER_METHOD,
    TRANSFER_FROM_METHOD,
    SAFE_TRANSFER_FROM_METHOD,
];

pub const SET_FALLBACK_HANDLER: &'static str = "setFallbackHandler";
pub const ADD_OWNER_WITH_THRESHOLD: &'static str = "addOwnerWithThreshold";
pub const REMOVE_OWNER: &'static str = "removeOwner";
pub const SWAP_OWNER: &'static str = "swapOwner";
pub const CHANGE_THRESHOLD: &'static str = "changeThreshold";
pub const CHANGE_MASTER_COPY: &'static str = "changeMasterCopy";
pub const ENABLE_MODULE: &'static str = "enableModule";
pub const DISABLE_MODULE: &'static str = "disableModule";
pub const SET_GUARD: &'static str = "setGuard";

pub const MULTI_SEND: &'static str = "multiSend";
pub const MULTI_SEND_TRANSACTIONS_PARAM: &'static str = "transactions";

pub const SETTINGS_CHANGE_METHODS: &[&str] = &[
    SET_FALLBACK_HANDLER,
    ADD_OWNER_WITH_THRESHOLD,
    REMOVE_OWNER,
    SWAP_OWNER,
    CHANGE_THRESHOLD,
    CHANGE_MASTER_COPY,
    ENABLE_MODULE,
    DISABLE_MODULE,
    SET_GUARD,
];

impl DataDecoded {
    pub fn get_parameter_single_value(&self, some_name: &str) -> Option<String> {
        self.parameters
            .as_ref()?
            .iter()
            .find_map(|param| match &param.value {
                ParamValue::SingleValue(value) => {
                    if param.name == some_name {
                        Some(value.clone())
                    } else {
                        None
                    }
                }
                _ => None,
            })
    }

    pub fn get_parameter_value_decoded(&self, parameter_name: &str) -> Option<ValueDecodedType> {
        self.parameters
            .as_ref()?
            .iter()
            .find_map(|param| match &param.value {
                ParamValue::SingleValue(_) => {
                    if param.name == parameter_name {
                        param.value_decoded.to_owned()
                    } else {
                        None
                    }
                }
                _ => None,
            })
    }

    pub fn get_action_count(&self) -> Option<usize> {
        if self.method == MULTI_SEND {
            self.get_parameter_value_decoded(MULTI_SEND_TRANSACTIONS_PARAM)
                .as_ref()
                .map(|value_decoded| match value_decoded {
                    InternalTransaction(internal_transactions) => internal_transactions.len(),
                })
        } else {
            None
        }
    }

    pub fn get_parameter_single_value_at(&self, position: usize) -> Option<String> {
        self.parameters.as_ref().and_then(|parameters| {
            parameters
                .get(position)
                .and_then(|parameter| match &parameter.value {
                    ParamValue::SingleValue(value) => Some(value.clone()),
                    _ => None,
                })
        })
    }

    pub fn is_erc20_transfer_method(&self) -> bool {
        ERC20_TRANSFER_METHODS
            .iter()
            .any(|&value| value == self.method)
    }

    pub fn is_erc721_transfer_method(&self) -> bool {
        ERC721_TRANSFER_METHODS
            .iter()
            .any(|&value| value == self.method)
    }

    pub fn is_settings_change(&self) -> bool {
        SETTINGS_CHANGE_METHODS
            .iter()
            .any(|&value| value == self.method)
    }
}

pub fn hex_hash<T: Hash>(t: &T) -> String {
    let mut s = DefaultHasher::new();
    t.hash(&mut s);
    format!("{:#x}", s.finish())
}

'''
'''--- src/utils/tests/data_decoded_utils.rs ---
use crate::common::models::data_decoded::{
    DataDecoded, InternalTransaction, Operation, ParamValue, Parameter, ValueDecodedType,
};

#[test]
fn get_parameter_single_value_success() {
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_ADD_OWNER_WITH_THRESHOLD,
    )
    .unwrap();
    let expected = "0xBEA2F9227230976d2813a2f8b922c22bE1DE1B23";

    let actual = data_decoded.get_parameter_single_value("owner");

    assert_eq!(expected, actual.unwrap());
}

#[test]
fn get_parameter_single_value_wrong_name() {
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_ADD_OWNER_WITH_THRESHOLD,
    )
    .unwrap();
    let expected = None;

    let actual = data_decoded.get_parameter_single_value("threshold");

    assert_eq!(expected, actual);
}

#[test]
fn get_parameter_single_value_right_name_but_array_value() {
    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_SWAP_ARRAY_VALUES)
            .unwrap();
    let expected = None;

    let actual = data_decoded.get_parameter_single_value("data");

    assert_eq!(expected, actual);
}

#[test]
fn get_parameter_value_decoded_success() {
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_MULTI_SEND_SINGLE_INNER_TRANSACTION,
    )
    .unwrap();

    let expected = ValueDecodedType::InternalTransaction(vec![InternalTransaction {
        operation: Operation::CALL,
        to: "0x111111125434b319222CdBf8C261674aDB56F3ae".to_string(),
        value: Some(22.to_string()),
        data: Some("0x90411a32000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000ecee9b38efb1a680000000000000000000000000000000000000000000000000ed2b525841adfc000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000324b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002647f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000184b3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000".to_string()),
        data_decoded: Some(DataDecoded{
            method: "swap".to_string(),
            parameters: Some(vec![
                Parameter{
                    name: "caller".to_string(),
                    param_type: "address".to_string(),
                    value: ParamValue::SingleValue("0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5".to_string()),
                    value_decoded: None
                },
                Parameter{
                    name: "desc".to_string(),
                    param_type: "(address,address,address,address,uint256,uint256,uint256,uint256,address,bytes)".to_string(),
                    value: ParamValue::ArrayValue(vec![
                        ParamValue::SingleValue("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE".to_string()),
                        ParamValue::SingleValue("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2".to_string()),
                        ParamValue::SingleValue("0xd47140F6Ab73f6d6B6675Fb1610Bb5E9B5d96FE5".to_string()),
                        ParamValue::SingleValue("0xBc79855178842FDBA0c353494895DEEf509E26bB".to_string()),
                        ParamValue::SingleValue("70000000000000000000000".to_string()),
                        ParamValue::SingleValue("69930000000000000000000".to_string()),
                        ParamValue::SingleValue("70000000000000000000000".to_string()),
                        ParamValue::SingleValue("1".to_string()),
                        ParamValue::SingleValue("0x0000000000000000000000000000000000000000".to_string()),
                        ParamValue::SingleValue("0x".to_string())
                    ]),
                    value_decoded: None
                },
                Parameter{
                    name: "calls".to_string(),
                    param_type: "(uint256,uint256,uint256,bytes)[]".to_string(),
                    value: ParamValue::ArrayValue(
                        vec![
                            ParamValue::ArrayValue(vec![
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee0000000000000000000000000000001400000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001e45636885000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe5000000000000000000000000000000000000000000000ecee9b38efb1a68000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000004d0e30db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000".to_string()),
                            ]),
                            ParamValue::ArrayValue(vec![
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0x7f8fe7a000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000044000000000000000000000000d47140f6ab73f6d6b6675fb1610bb5e9b5d96fe500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a405971224000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000002f9ae7c8305c3600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004470bdb947000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000ed2b525841adfc0000000000000000000000000000000000000000000000000000000000000".to_string()),
                            ]),
                            ParamValue::ArrayValue(vec![
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0".to_string()),
                                ParamValue::SingleValue("0xb3af37c000000000000000000000000000000000000000000000000000000000000000808000000000000000000000000000000000000000000000000000000000000024000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000100000000000000000000000000000001000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000bc79855178842fdba0c353494895deef509e26bb000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000".to_string()),
                            ]),
                        ]
                    ),
                    value_decoded: None
                }
            ]),
        }),
    }]);

    let actual = data_decoded.get_parameter_value_decoded("transactions");

    assert_eq!(expected, actual.unwrap());
}

#[test]
fn get_parameter_value_decoded_wrong_name() {
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_MULTI_SEND_SINGLE_INNER_TRANSACTION,
    )
    .unwrap();
    let expected = None;

    let actual = data_decoded.get_parameter_single_value("wrong_transactions");

    assert_eq!(expected, actual);
}

#[test]
fn get_parameter_value_decoded_right_name_but_array_value() {
    let data_decoded =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_SWAP_ARRAY_VALUES)
            .unwrap();
    let expected = None;

    let actual = data_decoded.get_parameter_value_decoded("swap");

    assert_eq!(expected, actual);
}

#[test]
fn get_action_count_multisig_call() {
    let data_decoded_action_count_1 = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_MULTI_SEND_SINGLE_INNER_TRANSACTION,
    )
    .unwrap();

    let data_decoded_action_count_3 =
        serde_json::from_str::<DataDecoded>(crate::tests::json::DATA_DECODED_MULTI_SEND).unwrap();

    assert_eq!(Some(1), data_decoded_action_count_1.get_action_count());
    assert_eq!(Some(3), data_decoded_action_count_3.get_action_count());
}

#[test]
fn get_action_count_non_multisig_call() {
    let data_decoded = serde_json::from_str::<DataDecoded>(
        crate::tests::json::DATA_DECODED_EXEC_TRANSACTION_WITH_VALUE_DECODED,
    )
    .unwrap();
    let expected = None;

    let actual = data_decoded.get_parameter_value_decoded("data");

    assert_eq!(expected, actual);
}

'''
'''--- src/utils/tests/errors.rs ---
use crate::common::models::backend::transactions::MultisigTransaction;
use crate::rocket::response::Responder;
use crate::utils::errors::{ApiError, ErrorDetails};
use rocket::local::asynchronous::Client;

#[rocket::async_test]
async fn api_error_responder_json() {
    let api_error = ApiError {
        status: 418,
        details: ErrorDetails {
            code: 1337,
            message: Some("Not found".to_string()),
            arguments: None,
            debug: None,
        },
    };
    let expected_error_json = r#"{"code":1337,"message":"Not found"}"#;

    let rocket = rocket::build();
    let client = Client::debug(rocket).await.expect("valid rocket instance");
    let request = client.get("/");
    let mut response = api_error.respond_to(&request).unwrap();

    let status_code: u16 = response.status().code;
    let body_json = &response.body_mut().to_string().await.unwrap();

    assert_eq!(status_code, 418);
    assert_eq!(body_json, expected_error_json);
}

#[test]
fn api_error_from_anyhow_error() {
    let error = api_error!("Error message");
    let error_details = ErrorDetails {
        code: 1337,
        message: Some("Error message".to_string()),
        arguments: None,
        debug: None,
    };

    let actual = ApiError::from(error);

    assert_eq!(actual.status, 500);
    assert_eq!(actual.details, error_details);
}

#[test]
fn api_error_from_serde_error() {
    let error = serde_json::from_str::<MultisigTransaction>("{").expect_err("Error message");
    let error_details = ErrorDetails {
        code: 1337,
        message: Some(format!("{:?}", &error)),
        arguments: None,
        debug: None,
    };

    let actual = ApiError::from(error);

    assert_eq!(actual.status, 500);
    assert_eq!(actual.details, error_details);
}

#[test]
fn api_error_known_error_json_structure() {
    let expected_error_json = r#"{
        "code": 1,
        "message": "Checksum address validation failed",
        "arguments": [
          "0x1230b3d59858296A31053C1b8562Ecf89A2f888b"
        ]
    }"#;
    let expected_error = ErrorDetails {
        code: 1,
        message: Some("Checksum address validation failed".to_string()),
        arguments: Some(vec![
            "0x1230b3d59858296A31053C1b8562Ecf89A2f888b".to_string()
        ]),
        debug: None,
    };

    let actual = ApiError::from_backend_error(422, &expected_error_json);

    assert_eq!(actual.status, 422);
    assert_eq!(actual.details, expected_error);
}

#[test]
fn api_error_unknown_error_json_structure() {
    let expected_error_json = r#"{
        "code": 1,
        "message": ["Checksum address validation failed"],
        "arguments": [
          "0x1230b3d59858296A31053C1b8562Ecf89A2f888b"
        ]
    }"#;
    let expected_error = ErrorDetails {
        code: 42,
        message: Some(expected_error_json.to_owned()),
        arguments: None,
        debug: None,
    };

    let actual = ApiError::from_backend_error(422, &expected_error_json);

    assert_eq!(actual.status, 422);
    assert_eq!(actual.details, expected_error);
}

'''
'''--- src/utils/tests/json.rs ---
use crate::utils::json::default_if_null;
use rocket::serde::json::json;
use serde::Deserialize;

#[derive(PartialEq, Deserialize, Debug)]
struct ExpectedStruct {
    #[serde(deserialize_with = "default_if_null")]
    field: u64,
    other_field: String,
    #[serde(deserialize_with = "default_if_null")]
    with_custom_default: WithCustomDefault,
}

#[derive(PartialEq, Deserialize, Debug)]
struct WithCustomDefault(String);

impl Default for WithCustomDefault {
    fn default() -> Self {
        WithCustomDefault("custom default".to_string())
    }
}

#[test]
#[should_panic]
fn deserialize_missing_expected_field() {
    let test_json = json!({
        "other_field":"other value"
    });

    serde_json::from_str::<ExpectedStruct>(&test_json.to_string()).unwrap();
}

#[test]
fn deserialize_expected_field_null() {
    let test_json = json!({
        "field" : null,
        "other_field":"other value",
        "with_custom_default": "different value"
    });

    let expected = ExpectedStruct {
        field: 0,
        other_field: "other value".to_string(),
        with_custom_default: WithCustomDefault("different value".to_string()),
    };

    let actual = serde_json::from_str::<ExpectedStruct>(&test_json.to_string()).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn deserialize_expected_field_with_value() {
    let test_json = json!({
        "field" : 42,
        "other_field":"other value",
        "with_custom_default": "different value"
    });

    let expected = ExpectedStruct {
        field: 42,
        other_field: "other value".to_string(),
        with_custom_default: WithCustomDefault("different value".to_string()),
    };

    let actual = serde_json::from_str::<ExpectedStruct>(&test_json.to_string()).unwrap();

    assert_eq!(expected, actual);
}

#[test]
fn deserialize_expected_field_with_custom_default() {
    let test_json = json!({
        "field" : 42,
        "other_field":"other value",
        "with_custom_default": null
    });

    let expected = ExpectedStruct {
        field: 42,
        other_field: "other value".to_string(),
        with_custom_default: WithCustomDefault("custom default".to_string()),
    };

    let actual = serde_json::from_str::<ExpectedStruct>(&test_json.to_string()).unwrap();

    assert_eq!(expected, actual);
}

'''
'''--- src/utils/tests/macros.rs ---
use std::env;

#[test]
fn config_uri_formats_correctly() {
    env::set_var("CONFIG_SERVICE_URI", "https://config-url-example.com");
    let expected = "https://config-url-example.com/api/example";

    let actual = config_uri!("/example");

    assert_eq!(expected, actual)
}

#[test]
fn config_uri_formats_correctly_with_substitution() {
    env::set_var("CONFIG_SERVICE_URI", "https://config-url-example.com");
    let expected = "https://config-url-example.com/api/example/safe";

    let actual = config_uri!("/example/{}", "safe");

    assert_eq!(expected, actual)
}

'''
'''--- src/utils/tests/method_names.rs ---
use crate::common::models::data_decoded::DataDecoded;
use crate::utils::{ERC20_TRANSFER_METHODS, ERC721_TRANSFER_METHODS, SETTINGS_CHANGE_METHODS};

#[test]
fn is_settings_method() {
    SETTINGS_CHANGE_METHODS.iter().for_each(|&item| {
        let data_decoded = DataDecoded {
            method: String::from(item),
            parameters: None,
        };
        assert!(data_decoded.is_settings_change())
    });

    let unknown_setting_change = DataDecoded {
        method: String::from("unknownSettingChange"),
        parameters: None,
    };
    assert!(!unknown_setting_change.is_settings_change())
}

#[test]
fn is_erc20_transfer_method() {
    ERC20_TRANSFER_METHODS.iter().for_each(|&item| {
        let data_decoded = DataDecoded {
            method: String::from(item),
            parameters: None,
        };
        assert!(data_decoded.is_erc20_transfer_method())
    });

    let unknown_method = DataDecoded {
        method: String::from("unknownTransferMethod"),
        parameters: None,
    };
    assert!(!unknown_method.is_erc20_transfer_method())
}

#[test]
fn is_erc721_transfer_method() {
    ERC721_TRANSFER_METHODS.iter().for_each(|&item| {
        let data_decoded = DataDecoded {
            method: String::from(item),
            parameters: None,
        };
        assert!(data_decoded.is_erc721_transfer_method())
    });

    let unknown_method = DataDecoded {
        method: String::from("unknownTransferMethod"),
        parameters: None,
    };
    assert!(!unknown_method.is_erc721_transfer_method())
}

'''
'''--- src/utils/tests/mod.rs ---
mod data_decoded_utils;
mod errors;
mod json;
mod macros;
mod method_names;
mod transactions;

'''
'''--- src/utils/tests/transactions.rs ---
use crate::utils::transactions::{
    cancellation_parts_hash, domain_hash_v100, domain_hash_v130, hash, use_legacy_domain_separator,
};
use ethabi::Address;
use ethcontract_common::hash::keccak256;
use semver::Version;

#[test]
fn domain_hash_for_safe_address() {
    let safe_address: Address = serde_json::from_value(serde_json::value::Value::String(
        "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67".to_string(),
    ))
    .unwrap();
    let actual = to_hex_string!(domain_hash_v130("4", &safe_address).to_vec()); // Rinkeby
    assert_eq!(
        "0x0d56532a2a780ffd32b2c3d85d0f8a7b2fc13df0576c006e2aaa47eb66cf71c9",
        actual
    );
}

#[test]
fn domain_hash_for_safe_address_legacy() {
    let safe_address: Address = serde_json::from_value(serde_json::value::Value::String(
        "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67".to_string(),
    ))
    .unwrap();
    let actual = to_hex_string!(domain_hash_v100(&safe_address).to_vec());
    assert_eq!(
        "0x6dda5da6f3b6225311946ab4732b5658018db6dc890378fbdb529d8e9832762a",
        actual
    );
}

#[test]
fn safe_tx_hash_for_safe_address_cancellation_tx_legacy() {
    let safe_address: Address = serde_json::from_value(serde_json::value::Value::String(
        "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67".to_string(),
    ))
    .unwrap();
    let nonce = 39;
    let domain_hash = domain_hash_v100(&safe_address);

    let actual = to_hex_string!(hash(safe_address, nonce, domain_hash).to_vec());
    assert_eq!(
        "0x89067bfebe450e45c02dd97e3cc9bd1656d49ebb8a17819829eab9c5dc575c27",
        actual
    );
}

#[test]
fn safe_tx_hash_for_safe_address_cancellation_tx() {
    let safe_address: Address = serde_json::from_value(serde_json::value::Value::String(
        "0x4cb09344de5bCCD45F045c5Defa0E0452869FF0f".to_string(),
    ))
    .unwrap();
    let nonce = 39;
    let domain_hash = domain_hash_v130("4", &safe_address); // Rinkeby

    let actual = to_hex_string!(hash(safe_address, nonce, domain_hash).to_vec());
    assert_eq!(
        "0xdce3bf453ed8cf84d13c76911e5d11c31501b24004b9e856d6091808067bd398",
        actual
    );
}

#[test]
fn parts_hash_for_cancellation() {
    let safe_address: Address = serde_json::from_value(serde_json::value::Value::String(
        "0xd6f5Bef6bb4acD235CF85c0ce196316d10785d67".to_string(),
    ))
    .unwrap();
    let nonce = 39;

    let actual = cancellation_parts_hash(&safe_address, nonce);
    assert_eq!(
        to_hex_string!(actual),
        "0xf0c66ea90dae4d21f8fed03cb6e7f03eb0720479fb2562915921721eed809626"
    );
}

#[test]
fn empty_data_keccak() {
    assert_eq!(
        to_hex_string!(keccak256(vec![])),
        "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"
    );
}

#[test]
fn use_legacy_domain_separator_v130() {
    let version = Version::parse("1.3.0").ok();

    assert_eq!(false, use_legacy_domain_separator(version));
}

#[test]
fn use_legacy_domain_separator_legacy() {
    let version = Version::parse("1.1.1").ok();

    assert_eq!(true, use_legacy_domain_separator(version));
}

'''
'''--- src/utils/transactions.rs ---
use crate::cache::cache_operations::RequestCached;
use crate::common::models::backend::transactions::MultisigTransaction;
use crate::config::transaction_request_timeout;
use crate::providers::info::{InfoProvider, SAFE_V_1_3_0};
use crate::utils::errors::ApiResult;
use ethabi::ethereum_types::H256;
use ethabi::{Address, Uint};
use ethcontract_common::hash::keccak256;
use semver::Version;

pub const DOMAIN_SEPARATOR_TYPEHASH_LEGACY: &'static str =
    "0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749";
pub const DOMAIN_SEPARATOR_TYPEHASH: &'static str =
    "0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218";
pub const SAFE_TX_TYPEHASH: &'static str =
    "0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8";

pub const ERC191_BYTE: &'static str = "19";
pub const ERC191_VERSION: &'static str = "01";

pub async fn fetch_rejections(
    info_provider: &(impl InfoProvider + Sync),
    chain_id: &str,
    safe_address: &str,
    nonce: u64,
) -> Option<Vec<String>> {
    let version = info_provider
        .safe_info(safe_address)
        .await
        .ok()
        .as_ref()
        .and_then(|safe_info| safe_info.version.as_ref().map(|it| Version::parse(it).ok()))
        .flatten();
    let is_legacy = use_legacy_domain_separator(version);
    let safe_address: Address =
        serde_json::from_value(serde_json::value::Value::String(safe_address.to_string())).unwrap();
    let domain_hash = if is_legacy {
        domain_hash_v100(&safe_address)
    } else {
        domain_hash_v130(chain_id, &safe_address)
    };

    let safe_tx_hash = to_hex_string!(hash(safe_address, nonce, domain_hash).to_vec());

    let multisig_tx = fetch_cancellation_tx(info_provider, safe_tx_hash).await;
    multisig_tx
        .as_ref()
        .map(|cancel_tx| {
            cancel_tx.confirmations.as_ref().map(|confirmations| {
                confirmations
                    .iter()
                    .map(|confirmation| confirmation.owner.to_string())
                    .collect()
            })
        })
        .flatten()
}

pub(super) fn hash(safe_address: Address, nonce: u64, domain_hash: [u8; 32]) -> [u8; 32] {
    let erc_191_byte = u8::from_str_radix(ERC191_BYTE, 16).unwrap();
    let erc_191_version = u8::from_str_radix(ERC191_VERSION, 16).unwrap();

    let mut encoded = ethabi::encode(&[
        ethabi::Token::Uint(Uint::from(domain_hash)),
        ethabi::Token::Uint(Uint::from(cancellation_parts_hash(&safe_address, nonce))),
    ]);

    encoded.insert(0, erc_191_version);
    encoded.insert(0, erc_191_byte);
    keccak256(encoded)
}

pub(super) fn domain_hash_v130(chain_id: &str, safe_address: &Address) -> [u8; 32] {
    let domain_separator: H256 =
        serde_json::from_value(serde_json::Value::String(DOMAIN_SEPARATOR_TYPEHASH.into()))
            .unwrap();

    let encoded = ethabi::encode(&[
        ethabi::Token::Uint(Uint::from(domain_separator.0)),
        ethabi::Token::Uint(Uint::from(
            chain_id.parse::<u64>().expect("Chain_Id is not a u64"),
        )),
        ethabi::Token::Address(Address::from(safe_address.0)),
    ]);
    keccak256(encoded)
}

pub(super) fn domain_hash_v100(safe_address: &Address) -> [u8; 32] {
    let domain_separator: H256 = serde_json::from_value(serde_json::Value::String(
        DOMAIN_SEPARATOR_TYPEHASH_LEGACY.into(),
    ))
    .unwrap();

    let encoded = ethabi::encode(&[
        ethabi::Token::Uint(Uint::from(domain_separator.0)),
        ethabi::Token::Address(Address::from(safe_address.0)),
    ]);
    keccak256(encoded)
}

pub(super) fn cancellation_parts_hash(safe_address: &Address, nonce: u64) -> [u8; 32] {
    let safe_type_hash: H256 =
        serde_json::from_value(serde_json::Value::String(SAFE_TX_TYPEHASH.into())).unwrap();

    let encoded_parts = &ethabi::encode(&[
        ethabi::Token::Uint(Uint::from(safe_type_hash.0)),
        ethabi::Token::Address(Address::from(safe_address.0)), // to
        ethabi::Token::Uint(Uint::zero()),                     // value
        ethabi::Token::Uint(Uint::from(keccak256(vec![]))),    // data
        ethabi::Token::Uint(Uint::zero()),                     // operation
        ethabi::Token::Uint(Uint::zero()),                     // safe_tx_gas
        ethabi::Token::Uint(Uint::zero()),                     // base_gas
        ethabi::Token::Uint(Uint::zero()),                     // gas_price
        ethabi::Token::Address(Address::zero()),               // gas_token
        ethabi::Token::Address(Address::zero()),               // refund_receiver
        ethabi::Token::Uint(Uint::from(nonce)),                // base_gas
    ]);

    keccak256(encoded_parts)
}

pub(super) fn use_legacy_domain_separator(version: Option<Version>) -> bool {
    if let Some(version) = version.as_ref() {
        version < &SAFE_V_1_3_0
    } else {
        true
    }
}

// We silently fail if the cancellation transaction is not found
async fn fetch_cancellation_tx(
    info_provider: &(impl InfoProvider + Sync),
    safe_tx_hash: String,
) -> Option<MultisigTransaction> {
    let url = core_uri!(info_provider, "/v1/multisig-transactions/{}/", safe_tx_hash).ok()?;
    let body = RequestCached::new(url, &info_provider.client(), &info_provider.cache())
        .request_timeout(transaction_request_timeout())
        .execute()
        .await
        .ok();
    body.as_ref()
        .map(|body| serde_json::from_str::<MultisigTransaction>(body).ok())
        .flatten()
}

'''
'''--- src/utils/urls.rs ---
use lazy_static::lazy_static;
use regex::Regex;
use rocket::http::uri::Origin;

use super::context::RequestContext;

lazy_static! {
    static ref IP_ADDRESS: Regex = Regex::new(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}").unwrap();
}

pub fn build_absolute_uri(context: &RequestContext, origin: Origin) -> String {
    format!("{}{}", context.host, origin)
}

'''