*GitHub Repository "Graate-Org/NEAR-rock-paper-scissors"*

'''--- README.md ---
## Rock-Paper-Scissor Game
This repository includes a complete Smart Contract for a rock-paper-scissor game built on the NEAR blockchain. This smart contract has flaws that would fixed in the second version or in a branch within the repo.

The flaws within the smart contract are:
- A player can play twice within a game. 
  - solution: restrict the first player from also being the second player through assertion.
- Anyone can create a game or play a game even if not a member of the room.
  - solution: restrict a non-member from creating or playing a game within a room.
- Without making a request, a player can be added to a private room.
  - check if a join-room request exists before approving a request/member

Check out these additional video content for more informtion on this rock-paper-scissor smart contract methods:
https://loom.com/share/folder/39accbd082e44ddf99805235b2d6f4b1
https://www.loom.com/share/folder/7d02b7d00fdd40d6a77d55d5d60c8363

This is a smart contract written in the simple format. This smart contract introduces game development on the NEAR blockchain using assembly script:
- How to use Data types and the data structures within AssemblyScript based smart contract. How state management across a DApp works, and as well, how to implement restrictions on your smart contracts 
- How to implement random number generation and id checks on the NEAR block chain

## Usage

### Getting started

1. clone this repo to a local folder
2. run `yarn`
3. run `yarn test:unit`

### Top-level `yarn` commands

- run `yarn test` to run all tests
  - (!) be sure to run `yarn build:release` at least once before:
    - run `yarn test:unit` to run only unit tests
- run `yarn build` to quickly verify build status
- run `yarn clean` to clean up build folder

> Check the `./scripts` folder for the integration tests.

### Other documentation

- NEAR-rock-paper-scissor contract and test documentation
  - see `/src/rock-paper-scissor/README` for contract interface
  - see `/src/rock-paper-scissor/__tests__/README` for Sample unit testing details
'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/rock-paper-scissor"
  ]
}

'''
'''--- package.json ---
{
  "name": "near-rock-paper-scissor",
  "version": "0.0.1",
  "description": "This repository includes a complete Smart Contract for a rock-paper-scissor game built on the NEAR blockchain. This is the first variant of the smart contract with a fault.",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn build:release && yarn test:unit",
    "clean": "rm -rf ./build && rm -rf ./neardev && rm -rf ./target",
    "deploy": "./scripts/1.deploy.sh"
  },
  "keywords": ["NEAR", "NEAR protocol", "NEAR blockchain", "smart contract", "game development", "AssemblyScript"],
  "author": "support@graate.org",
  "license": "ISC",
  "dependencies": {
    "near-sdk-as": "^3.2.3"
  }
}

'''
'''--- scripts/1.deploy.sh ---
[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER

echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release

echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./build/release/rock-paper-scissor.wasm

echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo
echo

exit 0
'''
'''--- scripts/10.get_all_rooms.sh ---
near call $CONTRACT getRooms --account_id $MEMBER '{"isJoined": false}'
'''
'''--- scripts/2.create_room.sh ---
near call $CONTRACT createRoom --account_id $MEMBER '{"_isVisible": true}' --amount 0.7
'''
'''--- scripts/3.request_to_join_room.sh ---
near call $CONTRACT requestToJoinPrivateRoom --account_id $MEMBER '{"_roomId": "RM-1637596023538693122"}' --amount 0.1
'''
'''--- scripts/4.join_room.sh ---
near call $CONTRACT joinPublicRoom --account_id $MEMBER '{"_roomId": "RM-1637604297448107092", "_isVisible": true}'
'''
'''--- scripts/5.create_game.sh ---
near call $CONTRACT createGame --account_id $OWNER '{"_roomId": "RM-1637604297448107092"}' --amount 0.5
'''
'''--- scripts/6.play.sh ---
near call $CONTRACT play --account_id $OWNER '{"_gameId": "GM-1637604479178430977"}' --amount 0.2
'''
'''--- scripts/7.approve_member.sh ---
near call $CONTRACT approveMember --account_id $OWNER '{"_roomId": "RM-1637596023538693122", "acct": "akinyemi.testnet", "_isVisible": false}'
'''
'''--- scripts/8.stake.sh ---
near call $CONTRACT stake --account_id $MEMBER '{"_gameId": "GM-1637604479178430977", "stakeOn": "chukwuka.testnet"}' --amount 1
'''
'''--- scripts/9.payout.sh ---
near call $CONTRACT payout --account_id $OWNER '{"_gameId": "GM-1637604479178430977"}'
'''
'''--- scripts/README.md ---
## Deploying contract through your terminal

The `deploy.sh` file within the scripts folder demonstrates a simple way of deploying a smart contract to the testnet.

```sh
[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"
```
The above commands searches the environment variables for `$CONTRACT` and `$OWNER` variables.

```sh
echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER
```
These commands deletes the two environment variable , `$CONTRACT` and `$OWNER` if any is found in the codebase, resolving the conflict of having two set of `$CONTRACT` and `$OWNER` variables.

```sh
echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev
```
The above shell commands deletes the `./neardev` folder. This folder contains details about the smart contract once deploy, expample is the `CONTRACT_NAME` found in the `dev-account.env` file. This way we can always generate a new `./neardev` folder on every deploy.

```sh
echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release
```
These commands compiles/builds the AssemlyScript code down to WebAssembly code. This action generates a file with `.wasm` extension that contains the WebAssembly code.

```sh
echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ../build/release/block-dice.wasm
```
These commands deploys/redeploys the resulting WebAssembly file from the previous action, `yarn build:release`. This file is deployed to the Near blockchain.

```sh
echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo
echo
```

These final commands prompts the developer to export the exported interfaces, making it available for consumption on the local machine.
'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/rock-paper-scissor/README.md ---
![Near, Inc. logo](https://near.org/wp-content/themes/near-19/assets/img/logo.svg?t=1553011311)

## Design

### Interface

#### Core functions

```ts
function createRoom
```
- "Change" function (ie. a function that alters contract state)
- Recieve a boolean value (false for private room, true for public room)
- Creates a new room and update the rooms data structure with the created room.

```ts
function joinPublicRoom
```
- "Change" function (ie. a function that alters contract state)
- Recieves a `'{"_roomId": RoomId, "_isVisible": boolean}'` parameters
- Allows the account initiating the contract call to join the room that's public
- This invokes a `addNewMember` method on the `Room` data type.

```ts
function requestToJoinPrivateRoom
```
- "Change" function (ie. a function that alters contract state)
- Recieves a `'{"_roomId": RoomId}'` as parameter
- Allows the account initiating the contract call to request to join a private room
- This invokes a `addNewRequest` method on the `Room` data type.

```ts
function approveMember
```
- "Change" function (ie. a function that alters contract state)
- Recieves a `'{"_roomId": RoomId, "acct": AccountId, "_isVisible": boolean}'` as parameter
- This invokes the `addNewMember` and the `updateRequests` methods on the `Room` data type.

```ts
function createGame
```
- "Change" function (ie. a function that alters contract state)
- Recieves a `'{"_roomId": RoomId}'` as parameter
- Allows the account initiating the contract call to create a new game within a room
- This updates the `games` data structure with the new game.

```ts
function play
```
- "Change" function (ie. a function that alters contract state)
- Recieves a `'{"_gameId": GameId}'` as parameter
- This invokes the `addNewPlayer` method on the `Game` data type.
- Smart contract panics if maximum players reached.

```ts
function stake
```
- "Change" function (ie. a function that alters contract state)
- Recieves a `'{"_gameId": GameId}'` as parameter
- This invokes the `addNewStaker` method on the `Game` data type.

```ts
function payout
```
- "Change" function (ie. a function that alters contract state)
- Recieves a `'{"_gameId": GameId}'` as parameter
- Smart contract panics if game is still active.

#### Game Reporting Functions

```ts
function getRooms
```
- "View" function (ie. a function that does not alters contract state)
- Recieves a `'{"isJoined": boolean}'` as parameter
- Returns rooms that a player is a member ofor rooms a player is not a member of depending on the parameter passed.

```ts
function getRoomMembers
```
- "View" function (ie. a function that does not alters contract state)
- Recieves a `'{"_roomId": RoomId}'` as parameter
- Returns an array of members of a room.

```ts
function getRoomRequests
```
- "View" function (ie. a function that does not alters contract state)
- Recieves a `'{"_roomId": RoomId}'` as parameter
- Returns an array of requests within a private room.

```ts
function getAllGames
```
- "View" function (ie. a function that does not alters contract state)
- Recieves a `'{"_roomId": RoomId, "gameStatus": Status}'` as parameter
- Returns an array of games with the same status; either created or active or completed games.

```ts
function getGamePlayers
```
- "View" function (ie. a function that does not alters contract state)
- Recieves a `'{"_gameId": GameId}'` as parameter
- Returns an array of players participating in a game.

```ts
function getGameStakers
```
- "View" function (ie. a function that does not alters contract state)
- Recieves a `'{"_gameId": GameId}'` as parameter
- Returns an array of stakers participating in a game.

```ts
function getGameStakers
```
- "View" function (ie. a function that does not alters contract state)
- Recieves a `'{"_gameId": GameId}'` as parameter
- Returns the winner of a game.

```ts
function getGameStakers
```
- "View" function (ie. a function that does not alters contract state)
- Recieves a `'{"_gameId": GameId}'` as parameter
- Returns the winner of a game.
'''
'''--- src/rock-paper-scissor/__test__/README.md ---
## Unit tests

Unit tests can be run from the top level folder using the following command:

```
yarn test:unit
```

### Tests for Contract in `index.unit.spec.ts`

```
[Describe]: Creating a room

 [Success]: ✔ creates a new room
 [Success]: ✔ creates a new private room
 [Success]: ✔ throws an error with zero deposit

[Describe]: Joining a created room

 [Success]: ✔ Join a public room
 [Success]: ✔ Join a private room

[Describe]: Creating a game within a room

 [Success]: ✔ Create a game within a room
 [Success]: ✔ throws an error with zero deposit

[Describe]: Playing a created game within a room

 [Success]: ✔ member gets added as a player and plays
 [Success]: ✔ throws error with zero deposit

[Describe]: Staking on players within a game

 [Success]: ✔ stake on a player
 [Success]: ✔ throws error with zero deposit

[Describe]: Winning a game as a player

 [Success]: ✔ Winner of the game
 [Success]: ✔ Payout of pool

    [File]: src/rock-paper-scissor/__test__/index.unit.spec.ts
  [Groups]: 7 pass, 7 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 13 pass,  0 fail, 13 total
    [Time]: 147.669ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: ✔ PASS
   [Files]: 1 total
  [Groups]: 7 count, 7 pass
   [Tests]: 13 pass, 0 fail, 13 total
    [Time]: 8593.509ms
✨  Done in 10.24s.
```
'''
'''--- src/rock-paper-scissor/__test__/index.unit.spec.ts ---
import { VMContext } from "near-mock-vm";
import { PersistentVector, u128 } from "near-sdk-core";
import {
  approveMember,
  createGame,
  createRoom,
  joinPublicRoom,
  payout,
  play,
  requestToJoinPrivateRoom,
  stake,
} from "../assembly";
import {
  Game,
  games,
  Member,
  Player,
  Request,
  RequestStatus,
  rooms,
  Staker,
  Status,
  Visibility,
} from "../assembly/model";
import { AccountId, GFEE, JoinFEE, PFEE, RFEE, SFEE } from "../utils";

const OWNER: AccountId = "akinyemi.testnet";
const MEMBER: AccountId = "chukwuka.testnet";
const PLAYER: AccountId = "ikeh_akinyemi.testnet";
const STAKER: AccountId = "ikeh_akinyemi.testnet";

describe("Creating a room", () => {
  beforeEach(() => {
    VMContext.setSigner_account_id(OWNER);
    VMContext.setAttached_deposit(RFEE);
  });

  it("creates a new room", () => {
    createRoom(true);
    expect<i32>(rooms.length).toBeGreaterThan(
      0,
      "A new room is expected to be added to the rooms' array"
    );
  });

  it("creates a new private room", () => {
    createRoom(false);
    expect<Visibility>(rooms[0].isVisible).toStrictEqual(
      Visibility.PRIVATE,
      "This new created room should have a visibility of PRIVATE"
    );
  });

  it("throws an error with zero deposit", () => {
    VMContext.setAttached_deposit(u128.Zero);

    function zeroDeposit(): void {
      createRoom(false);
    }
    expect<() => void>(zeroDeposit).toThrow("Expected a deposit before creating a room");
  });
});

describe("Joining a created room", () => {
  beforeEach(() => {
    VMContext.setSigner_account_id(OWNER);
    VMContext.setAttached_deposit(RFEE);
  });

  it("Join a public room", () => {
    createRoom(true);
    VMContext.setSigner_account_id(MEMBER);

    joinPublicRoom(rooms[0].id, true);
    const members = rooms[0].members.get(rooms[0].id) as Member[];

    expect<Member[]>(members).toHaveLength(
      2,
      "A new member has been added to the public room"
    );
  });

  it("Join a private room", () => {
    createRoom(false);
    VMContext.setSigner_account_id(MEMBER);
    VMContext.setAttached_deposit(JoinFEE);

    requestToJoinPrivateRoom(rooms[0].id);
    let requests = rooms[0].requests.get(rooms[0].id) as Request[];
    expect<Request[]>(requests).toHaveLength(1, "A new request to join the private room");

    VMContext.setSigner_account_id(OWNER);
    approveMember(rooms[0].id, requests[0].accountId, false);
    const members = rooms[0].members.get(rooms[0].id) as Member[];

    expect<Member[]>(members).toHaveLength(
      2,
      "A new member has been added to the private room"
    );

    requests = rooms[0].requests.get(rooms[0].id) as Request[];
    expect<RequestStatus>(requests[0].state).toBe(
      RequestStatus.ACCEPTED,
      "This request has been approved"
    );
  });
});

describe("Creating a game within a room", () => {
  beforeEach(() => {
    VMContext.setSigner_account_id(OWNER);
    VMContext.setAttached_deposit(RFEE);
    createRoom(true);

    VMContext.setSigner_account_id(MEMBER);
    joinPublicRoom(rooms[0].id, true);
  });

  it("Create a game within a room", () => {
    VMContext.setAttached_deposit(GFEE);
    createGame(rooms[0].id);
    expect<PersistentVector<Game>>(games).toHaveLength(
      1,
      "A new game has been created by a member within the room"
    );
  });

  it("throws an error with zero deposit", () => {
    VMContext.setAttached_deposit(u128.Zero);
    function zeroDeposit(): void {
      createGame(rooms[0].id);
    }

    expect<() => void>(zeroDeposit).toThrow("Can't create game with zero deposit");
  });
});

describe("Playing a created game within a room", () => {
  beforeEach(() => {
    VMContext.setSigner_account_id(OWNER);
    VMContext.setAttached_deposit(RFEE);
    createRoom(true);

    VMContext.setSigner_account_id(MEMBER);
    joinPublicRoom(rooms[0].id, true);
    VMContext.setAttached_deposit(GFEE);
    createGame(rooms[0].id);
  });

  it("member gets added as a player and plays", () => {
    VMContext.setAttached_deposit(PFEE);
    play(games[0].id);
    expect<Status>(games[0].status).toBe(Status.ACTIVE, "A player has been added to the game, as well as the player has played and the game is active");

    VMContext.setSigner_account_id(PLAYER);
    joinPublicRoom(rooms[0].id, true);
    VMContext.setAttached_deposit(PFEE);
    play(games[0].id);
    expect<Status>(games[0].status).toBe(Status.COMPLETED, "This game is completed as the last player for the game has played");
  })

  it("throws error with zero deposit", () => {
    VMContext.setAttached_deposit(u128.Zero);
    function zeroDeposit(): void {
      play(games[0].id)
    }
    expect<() => void>(zeroDeposit).toThrow("Can't play a game with zero deposit")
  })

});

describe("Staking on players within a game", () => {
  beforeEach(() => {
    VMContext.setAttached_deposit(RFEE);
    VMContext.setSigner_account_id(OWNER);
    createRoom(true);

    VMContext.setSigner_account_id(MEMBER);
    joinPublicRoom(rooms[0].id, true);
    VMContext.setAttached_deposit(GFEE);
    createGame(rooms[0].id);
    VMContext.setAttached_deposit(PFEE);
    play(games[0].id)
  });

  it("stake on a player", () => {
    VMContext.setAttached_deposit(SFEE);
    VMContext.setSigner_account_id(STAKER);
    const players = games[0].players.get(games[0].id) as Player[];
    stake(games[0].id, MEMBER);
    const stakers = games[0].stakers.get(games[0].id) as Staker[]

    expect<Staker[]>(stakers).toHaveLength(1, "A staker has staked on a player involved in this game")
  })

  it("throws error with zero deposit", () => {
    VMContext.setAttached_deposit(u128.Zero);
    VMContext.setSigner_account_id(STAKER);
    const players = games[0].players.get(games[0].id) as Player[];

    function zeroDeposit(): void {
      stake(games[0].id, MEMBER);
    }
    expect<() => void>(zeroDeposit).toThrow("Can't stake within a game with zero deposit")
  })
})

describe("Winning a game as a player", () => {
  beforeEach(() => {
    VMContext.setAttached_deposit(RFEE);
    VMContext.setSigner_account_id(OWNER);
    createRoom(true);

    VMContext.setSigner_account_id(MEMBER);
    joinPublicRoom(rooms[0].id, true);
    VMContext.setAttached_deposit(GFEE);
    createGame(rooms[0].id);
    VMContext.setAttached_deposit(PFEE);
    play(games[0].id);

    VMContext.setSigner_account_id(PLAYER);
    joinPublicRoom(rooms[0].id, true);
    VMContext.setAttached_deposit(PFEE);
    play(games[0].id);
  });

  it("Winner of the game", () => {
    const winners = games[0].winners.get(games[0].id) as AccountId[];

    expect<string[]>(winners).toHaveLength(1, "We have a winner for the completed game")
  });

  it("Payout of pool", () => {
    expect<bool>(payout(games[0].id)).toBeTruthy("Successful transfer transaction to winner and stakers.");
  })
})
'''
'''--- src/rock-paper-scissor/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/rock-paper-scissor/assembly/index.ts ---
import { u128, Context, PersistentMap } from "near-sdk-as";
import {
  AccountId,
  GameId,
  GFEE,
  JoinFEE,
  PFEE,
  RFEE,
  RoomId,
  SFEE,
} from "../utils";
import {
  Game,
  games,
  Member,
  Player,
  Request,
  RequestStatus,
  Room,
  rooms,
  Staker,
  Status,
  Visibility,
} from "./model";

export function createRoom(_isVisible: boolean): void {
  const txDeposit = Context.attachedDeposit;
  verifyTxFee(txDeposit, RFEE);

  const id = generateId("RM-");
  const room = new Room(
    id,
    Context.sender,
    _isVisible ? Visibility.PUBLIC : Visibility.PRIVATE
  );

  rooms.push(room);
}

export function joinPublicRoom(_roomId: RoomId, _isVisible: boolean): void {
  if (_isVisible) {
    for (let x = 0; x < rooms.length; x++) {
      if (rooms[x].id == _roomId) {
        const room = rooms.swap_remove(x) as Room;
        const members = room.members.get(room.id) as Member[];

        for (let i = 0; i < members.length; i++) {
          if (members[i].accountId == Context.sender) {
            assert(false, "You're already a member of this room");
          }
        }

        room.addNewMember(room.id, Context.sender);
        rooms.push(room);

        break;
      }
    }
  }
}

export function requestToJoinPrivateRoom(_roomId: RoomId): void {
  const txDeposit = Context.attachedDeposit;
  verifyTxFee(txDeposit, JoinFEE);

  for (let x = 0; x < rooms.length; x++) {
    if (rooms[x].id == _roomId) {
      const room = rooms.swap_remove(x) as Room;
      const requests = room.requests.get(_roomId) as Request[];

      for (let i = 0; i < requests.length; i++) {
        assert(
          requests[i].accountId != Context.sender,
          "You already sent a request to this room. Wait for approval"
        );
      }

      room.addNewRequest(_roomId);
      rooms.push(room);

      break;
    }
  }
}

export function approveMember(
  _roomId: RoomId,
  acct: AccountId,
  _isVisible: boolean
): void {
  for (let x = 0; x < rooms.length; x++) {
    if (rooms[x].id == _roomId) {
      assert(
        Context.sender == rooms[x].owner,
        "You don't have the power to add this fellow"
      );

      break;
    }
  }

  if (!_isVisible) {
    for (let x = 0; x < rooms.length; x++) {
      if (rooms[x].id == _roomId) {
        const room = rooms.swap_remove(x) as Room;
        const members = room.members.get(room.id) as Member[];

        for (let i = 0; i < members.length; i++) {
          if (members[i].accountId == acct) {
            assert(false, "You're already a member of this room");
            break;
          }
        }

        room.addNewMember(room.id, acct);
        room.updateRequests(room.id, acct);
        rooms.push(room);

        break;
      }
    }
  }
}

export function createGame(_roomId: RoomId): void {
  const txDeposit = Context.attachedDeposit;
  verifyTxFee(txDeposit, GFEE);

  const id = generateId("GM-");
  const game = new Game(_roomId, id);

  games.push(game);
}

export function play(_gameId: GameId): void {
  const txDeposit = Context.attachedDeposit;
  verifyTxFee(txDeposit, PFEE);

  const id = generateId("PL-");

  for (let x = 0; x < games.length; x++) {
    if (games[x].id == _gameId) {
      const game = games.swap_remove(x) as Game;
      const players = game.players.get(game.id) as Player[];
      assert(
        players.length + 1 <= game.numOfPlayers,
        "Maximum players reached. Join another game"
      );
      game.addNewPlayer(game.id, id, PFEE);

      games.push(game);
    }
  }
}

export function stake(_gameId: GameId, stakeOn: AccountId): void {
  const txDeposit = Context.attachedDeposit;
  verifyTxFee(txDeposit, SFEE);

  const id = generateId("ST-");
  const staker = new Staker(_gameId, stakeOn, SFEE);
  for (let x = 0; x < games.length; x++) {
    if (games[x].id == _gameId) {
      const game = games.swap_remove(x) as Game;

      game.addNewStaker(id, _gameId, stakeOn, SFEE);

      games.push(game);
    }
  }
}

export function payout(_gameId: GameId): bool {
  let isPaid: bool = false;

  for (let x = 0; x < games.length; x++) {
    if (games[x].id == _gameId) {
      const game = games.swap_remove(x) as Game;
      const players = game.players.get(_gameId) as Player[];
      if (players.length == game.numOfPlayers) {
        game.rewardWinner(_gameId);
        games.push(game);
        isPaid = true;
        return isPaid;
      } else {
        assert(false, "This game is not yet completed!");
      }
    }
  }

  return isPaid;
}

export function getRooms(isJoined: boolean): Room[] {
  const returnedRooms: Room[] = [];

  for (let x = 0; x < rooms.length; x++) {
    const members = rooms[x].members.get(rooms[x].id) as Member[];

    for (let i = 0; i < members.length; i++) {
      if(isJoined) {
        if (members[i].accountId == Context.sender) {
          returnedRooms.push(rooms[x]);
        }
      } else if (!isJoined) {
        if (members[i].accountId != Context.sender) {
          returnedRooms.push(rooms[x]);
        }
      }
    }
  }

  return returnedRooms;
}

export function getRoomMembers(_roomId: RoomId): Member[] {
  let returnedMembers: Member[] = [];

  for (let x = 0; x < rooms.length; x++) {
    if (rooms[x].id == _roomId) {
      const members = rooms[x].members.get(rooms[x].id) as Member[];
      returnedMembers = members;

      break;
    }
  }

  return returnedMembers;
}

export function getRoomRequests(_roomId: GameId): Request[] {
  const returnedRequests: Request[] = [];

  for (let x = 0; x < rooms.length; x++) {
    if (rooms[x].id == _roomId) {
      const requests = rooms[x].requests.get(rooms[x].id) as Request[];

      for (let i = 0; i < requests.length; i++) {
        if (requests[i].state != RequestStatus.ACCEPTED) {
          returnedRequests.push(requests[i]);
        }
      }

      break;
    }
  }

  return returnedRequests;
}

export function getAllGames(_roomId: RoomId, gameStatus: Status): Game[] {
  const returnedGames: Game[] = [];

  for (let x = 0; x < games.length; x++) {
    if (games[x].status == gameStatus) {
      returnedGames.push(games[x]);
    }
  }

  return returnedGames;
}

export function getGamePlayers(_gameId: GameId): Player[] {
  let returnedPlayers: Player[] = [];

  for (let x = 0; x < games.length; x++) {
    if (games[x].id == _gameId) {
      const players = games[x].players.get(games[x].id) as Player[];

      returnedPlayers = players;
    }
  }

  return returnedPlayers;
}

export function getGameStakers(_gameId: GameId): Staker[] {
  let returnedStakers: Staker[] = [];

  for (let x = 0; x < games.length; x++) {
    if (games[x].id == _gameId) {
      const players = games[x].stakers.get(games[x].id) as Staker[];

      returnedStakers = players;
    }
  }

  return returnedStakers;
}

export function getWinner(_gameId: GameId): AccountId {
  let returnedWinner: AccountId[] = [];

  for (let x = 0; x < games.length; x++) {
    if (games[x].id == _gameId) {
      const winners = games[x].winners.get(games[x].id) as AccountId[];

      returnedWinner = winners;
    }
  }

  return returnedWinner[0];
}

function verifyTxFee(deposit: u128, Fee: u128): void {
  assert(
    deposit >= Fee,
    "You need to have at least " +
      Fee.toString() +
      " yocto of NEAR tokens to continue"
  );
}

function generateId(prefix: string): string {
  return prefix + Context.blockTimestamp.toString();
}

'''
'''--- src/rock-paper-scissor/assembly/model.ts ---
import {
  Context,
  ContractPromiseBatch,
  PersistentVector,
  PersistentMap,
  u128,
  math,
} from "near-sdk-core";
import {
  AccountId,
  GameId,
  PlayerId,
  RoomId,
  StakerId,
  Timestamp,
} from "../utils";

export enum Choice {
  ROCK,
  PAPER,
  SCISSOR,
}

export enum Participant {
  PLAYER,
  STAKER,
}

export enum Status {
  CREATED,
  ACTIVE,
  COMPLETED,
}

export enum Visibility {
  PUBLIC,
  PRIVATE,
}

@nearBindgen
export class Room {
  id: RoomId;
  owner: AccountId;
  isVisible: Visibility;
  members: PersistentMap<RoomId, Member[]>;
  requests: PersistentMap<RoomId, Request[]>;

  constructor(_id: RoomId, _owner: AccountId, _isVisible: Visibility) {
    this.id = _id;
    this.owner = _owner;
    this.isVisible = _isVisible;

    this.members = new PersistentMap<RoomId, Member[]>("m");
    this.members.set(this.id, [] as Member[]);
    this.addNewMember(this.id, this.owner);

    this.requests = new PersistentMap<RoomId, Request[]>("req");
    this.requests.set(this.id, [] as Request[]);
  }

  addNewMember(_roomId: RoomId, acctId: AccountId): void {
    const member = new Member(_roomId, acctId);
    const members = this.members.get(_roomId) as Member[];
    members.push(member);

    this.members.set(_roomId, members);
  }

  addNewRequest(_roomId: RoomId): void {
    const request = new Request(_roomId, Context.sender);
    const requests = this.requests.get(_roomId) as Request[];
    requests.push(request);

    this.requests.set(_roomId, requests);
  }

  updateRequests(_roomId: RoomId, acctId: AccountId): void {
    const requests = this.requests.get(_roomId) as Request[];

    for (let x = 0; x < requests.length; x++) {
      if (requests[x].accountId == acctId) {
        const request = requests[x];
        request.state = RequestStatus.ACCEPTED;
        this.requests.set(_roomId, requests);
      }
    }
  }
}

@nearBindgen
export class Game {
  id: GameId;
  numOfPlayers: i32;
  players: PersistentMap<GameId, Player[]>;
  stakers: PersistentMap<GameId, Staker[]>;
  createdBy: AccountId;
  createdAt: Timestamp;
  status: Status;
  winners: PersistentMap<GameId, AccountId[]>;
  pool: u128;

  constructor(public roomId: RoomId, _id: GameId) {
    this.id = _id;
    this.numOfPlayers = 2;

    this.players = new PersistentMap<GameId, Player[]>("plys");
    this.players.set(this.id, [] as Player[]);

    this.stakers = new PersistentMap<GameId, Staker[]>("stks");
    this.stakers.set(this.id, [] as Staker[]);

    this.createdBy = Context.sender;
    this.createdAt = Context.blockTimestamp;
    this.status = Status.CREATED;

    this.winners = new PersistentMap<GameId, AccountId[]>("w");
    this.winners.set(this.id, [] as AccountId[]);

    this.pool = u128.Zero;
  }

  addNewPlayer(_gameId: GameId, _playerId: PlayerId, txFee: u128): void {
    function randomNum(): u32 {
      let buf = math.randomBuffer(3);
      return (
        (((0xff & buf[0]) << 1) |
          ((0xff & buf[1]) << 2) |
          ((0xff & buf[2]) << 0)) %
        3
      );
    }
    const randNum = randomNum();

    let choice = Choice.ROCK;

    if (randNum == 1) {
      choice = Choice.PAPER;
    } else if (randNum == 2) {
      choice = Choice.SCISSOR;
    }

    const player = new Player(_playerId, Context.sender, choice, txFee);
    const players = this.players.get(_gameId) as Player[];
    players.push(player);

    this.players.set(_gameId, players);
    this.pool = u128.add(this.pool, txFee);

    const newPlayers = this.players.get(_gameId) as Player[];
    if (newPlayers.length == 1) {
      this.status = Status.ACTIVE;
    } else if (newPlayers.length == this.numOfPlayers) {
      this.status = Status.COMPLETED;
      this.winner(_gameId);
    }
  }

  addNewStaker(
    _stakerId: StakerId,
    _gameId: GameId,
    stakeOn: AccountId,
    txFee: u128
  ): void {
    const staker = new Staker(_stakerId, stakeOn, txFee);
    const stakers = this.stakers.get(_gameId) as Staker[];
    stakers.push(staker);

    this.stakers.set(_gameId, stakers);
    this.pool = u128.add(this.pool, txFee);
  }

  winner(_gameId: GameId): void {
    const players = this.players.get(_gameId) as Player[];
    const winners = this.winners.get(_gameId) as AccountId[];

    if (players[0].choice == players[1].choice) {
      winners.push("draw");
      this.winners.set(_gameId, winners);
      return;
    }

    if (players[1].choice == Choice.ROCK && players[0].choice == Choice.PAPER) {
      winners.push(players[0].name);
      this.winners.set(_gameId, winners);
    }
    if (
      players[1].choice === Choice.ROCK &&
      players[0].choice === Choice.SCISSOR
    ) {
      winners.push(players[1].name);
      this.winners.set(_gameId, winners);
    }

    if (
      players[1].choice == Choice.PAPER &&
      players[0].choice == Choice.SCISSOR
    ) {
      winners.push(players[0].name);
      this.winners.set(_gameId, winners);
    }
    if (players[1].choice == Choice.PAPER && players[0].choice == Choice.ROCK) {
      winners.push(players[1].name);
      this.winners.set(_gameId, winners);
    }
    if (
      players[1].choice == Choice.SCISSOR &&
      players[0].choice == Choice.ROCK
    ) {
      winners.push(players[0].name);
      this.winners.set(_gameId, winners);
    }
    if (
      players[1].choice == Choice.SCISSOR &&
      players[0].choice == Choice.PAPER
    ) {
      winners.push(players[1].name);
      this.winners.set(_gameId, winners);
    }
  }

  rewardWinner(_gameId: GameId): void {
    const winners = this.winners.get(this.id) as AccountId[];
    const players = this.players.get(this.id) as Player[];
    for (let x = 0; x < players.length; x++) {
      if (players[x].name == winners[0]) {
        this.transfer(players[x].name, players[x].txFee);
        this.rewardStakers(_gameId, players[x].name);

        break;
      }
    }
  }

  rewardStakers(_gameId: GameId, _betOn: AccountId): void {
    const stakers = this.stakers.get(_gameId) as Staker[];

    for (let i = 0; i < stakers.length; i++) {
      if (stakers[i].betOn == _betOn) {
        this.transfer(stakers[i].name, stakers[i].stake);
      }
    }
  }

  transfer(to: AccountId, invested: u128): void {
    const reward = u128.add(invested, u128.mul(invested, u128.from(0.5)));

    const transfer_win = ContractPromiseBatch.create(to);
    transfer_win.transfer(reward);
  }
}

@nearBindgen
export class Player {
  id: PlayerId;
  name: AccountId;
  choice: Choice;
  txFee: u128;

  constructor(_id: PlayerId, _name: AccountId, _choice: Choice, _txFee: u128) {
    this.id = _id;
    this.name = _name;
    this.choice = _choice;
    this.txFee = _txFee;
  }
}

@nearBindgen
export class Staker {
  id: StakerId;
  betOn: AccountId;
  name: AccountId;
  stake: u128;

  constructor(_id: StakerId, _betOn: AccountId, _stake: u128) {
    this.id = _id;
    this.betOn = _betOn;
    this.name = Context.sender;
    this.stake = _stake;
  }
}

@nearBindgen
export class Member {
  roomId: RoomId;
  accountId: AccountId;

  constructor(_roomId: RoomId, _accountId: AccountId) {
    this.roomId = _roomId;
    this.accountId = _accountId;
  }
}

@nearBindgen
export class Request {
  roomId: RoomId;
  accountId: AccountId;
  state: RequestStatus;

  constructor(_roomId: RoomId, _accountId: AccountId) {
    this.roomId = _roomId;
    this.accountId = _accountId;
    this.state = RequestStatus.CREATED;
  }
}

export enum RequestStatus {
  CREATED,
  ACCEPTED,
  REJECTED,
}

export const rooms = new PersistentVector<Room>("r");
export const games = new PersistentVector<Game>("g");

'''
'''--- src/rock-paper-scissor/utils.ts ---
import { u128 } from "near-sdk-core";

export type Timestamp = u64;

export type AccountId = string;

export type RoomId = string;

export type GameId = string;

export type PlayerId = string;

export type StakerId = string;

export const SFEE = u128.from("1000000000000000000000000");
export const RFEE = u128.from("700000000000000000000000");
export const GFEE = u128.from("500000000000000000000000");
export const PFEE = u128.from("200000000000000000000000");
export const JoinFEE = u128.from("100000000000000000000000");
'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''