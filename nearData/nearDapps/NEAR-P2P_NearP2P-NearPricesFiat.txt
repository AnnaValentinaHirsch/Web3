*GitHub Repository "NEAR-P2P/NearP2P-NearPricesFiat"*

'''--- .vscode/settings.json ---
{
    "python.pythonPath": "/bin/python3"
}
'''
'''--- README.md ---
# P2PBd

Python program, update in database crypto price from coinmarketcap near against fiat

Get ticker information from exchanges into postgres database, last price
'''
'''--- api.py ---
import dboperations
from flask import Flask, request

app = Flask(__name__)

@app.route('/act_prices', methods=['GET'])
def act_prices_endpoint():
    # Get the pamount parameter from the URL
    pamount = request.args.get('pamount')

    # Call the act_prices function
    result = dboperations.act_dolar(pamount)

    # Create a message
    message = f"Actualización de precios exitosa"

    return message, 200

if __name__ == '__main__':
    app.run(debug=True)
'''
'''--- bd.sql ---
-- Table: public.p2p_prices

-- DROP TABLE IF EXISTS public.p2p_prices;

CREATE TABLE IF NOT EXISTS public.p2p_prices
(
    crypto character varying COLLATE pg_catalog."default" NOT NULL,
    fiat character varying COLLATE pg_catalog."default" NOT NULL,
    value real NOT NULL,
    date date NOT NULL,
    CONSTRAINT p2p_prices_pkey PRIMARY KEY (fiat)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.p2p_prices
    OWNER to p2p;

-- FUNCTION: public.act_prices(character, character, numeric)

-- DROP FUNCTION IF EXISTS public.act_prices(character, character, numeric);

CREATE OR REPLACE FUNCTION public.act_prices(
	pcrypto character,
	pfiat character,
	pamount numeric)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
declare
lastamount double precision;
vlbehavior character(30);
vlcolor character(30);
/**
Mantiene actualizada la tabla p2p_prices
GLOBAL DVCONSULTORES /Andrés Dominguez 12/05/2022
*/
begin
--borra el registro y lo vuelve a cargar
delete from p2p_prices where crypto = pcrypto and fiat = pfiat;
--Inserta registros
insert into p2p_prices (crypto, fiat, value, date) values (pcrypto, pfiat, pamount, now());
end;
$BODY$;

ALTER FUNCTION public.act_prices(character, character, numeric)
    OWNER TO p2p;

COMMENT ON FUNCTION public.act_prices(character, character, numeric)
    IS 'Mantiene act_prices';

'''
'''--- dboperations.py ---
import psycopg2

def conection():
    conn = psycopg2.connect(host="134.209.45.101", database="p2p", user="p2p", password="p42fUEoUpfAp2b7QsibgIT4PCWrp4wCW")
    return conn

# Store procedure para actualizar datos
def act_prices(pcrypto, pfiat, pamount):
    conn = conection()
    try:
     # create a cursor object for execution
     cursor = conn.cursor()
     cursor.execute("BEGIN")
     cursor.callproc('act_prices', (pcrypto, pfiat, pamount, ))  # Llamado de procedimiento almacenado en postgres
     cursor.execute("COMMIT")
     cursor.close  # Cerrar cursor
     # Llamado de store procedure para actualizar tabla t_historical
    except (psycopg2.DatabaseError) as error:
          print(error)
    finally:
        if conn is not None:
            conn.close()  # Cerrando conección
    return

# Store procedure para actualizar datos
def act_dolar(pamount):
    conn = conection()
    try:
     # create a cursor object for execution
     cursor = conn.cursor()
     cursor.execute("BEGIN")
     cursor.callproc('act_dolar', (pamount, ))  # Llamado de procedimiento almacenado en postgres
     cursor.execute("COMMIT")
     cursor.close  # Cerrar cursor
     # Llamado de store procedure para actualizar tabla t_historical
    except (psycopg2.DatabaseError) as error:
          print(error)
    finally:
        if conn is not None:
            conn.close()  # Cerrando conección
    return    

import psycopg2
from psycopg2 import sql

def act_prices_batch(data):
    # Connect to your postgres DB
    conn = psycopg2.connect(host="134.209.45.101", database="p2p", user="p2p", password="p42fUEoUpfAp2b7QsibgIT4PCWrp4wCW")

    # Open a cursor to perform database operations
    cur = conn.cursor()

    # SQL query for deleting old records
    delete_query = sql.SQL("DELETE FROM p2p_prices WHERE crypto = %s AND fiat = %s")

    # SQL query for inserting new records
    insert_query = sql.SQL("INSERT INTO p2p_prices (crypto, fiat, value, date) VALUES (%s, %s, %s, CURRENT_DATE)")

    try:
        for item in data:
            # Delete old record
            cur.execute(delete_query, (item[0], item[1]))

            # Insert new record
            cur.execute(insert_query, item)

        # Commit the transaction
        conn.commit()
    except Exception as e:
        print(f"Failed to insert data into database. {e}")
    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()    
'''
'''--- exchanges.py ---
from multiprocessing import Process
import fiat_near, fiat_usdt, fiat_weth, fiat_eth, fiat_btc, fiat_wbtc, fiat_aurora, fiat_wnear, fiat_from_ref_finance

if __name__ == '__main__':
  p1 = Process(target=fiat_near.exec)
  p2 = Process(target=fiat_from_ref_finance.exec)
  p1.start()
  p2.start()

'''
'''--- fiat_aurora.py ---
import requests
import json
from datetime import datetime
import dboperations

def exec():
   start = datetime.now()
   #api from Coingeko
   url = "https://api.coingecko.com/api/v3/coins/aurora-near/tickers/"
   r = requests.get(url)
   

   token_price = float(r.json()["tickers"][0]["last"])
   #
   dboperations.act_prices('AURORA', 'USD', token_price)
   print('Tiempo de ejecución AURORA FIAT ' + str(datetime.now() - start))

exec()
'''
'''--- fiat_btc.py ---
import requests
import json
from datetime import datetime
import dboperations

def exec():
   start = datetime.now()
   #api from Coingeko
   url = "https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT"
   r = requests.get(url)

   token_price = float(r.json()["price"])
   #
   dboperations.act_prices('BTC', 'USD', token_price)
   print('Tiempo de ejecución BTC FIAT ' + str(datetime.now() - start))

#exec()
'''
'''--- fiat_eth.py ---
import requests
import json
from datetime import datetime
import dboperations

def exec():
   start = datetime.now()
   #api from Coingeko
   url = "https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT"
   r = requests.get(url)

   token_price = float(r.json()["price"])
   #
   dboperations.act_prices('ETH', 'USD', token_price)
   print('Tiempo de ejecución ETH FIAT ' + str(datetime.now() - start))

# exec()
'''
'''--- fiat_from_ref_finance.py ---
import requests
import json
from datetime import datetime
import dboperations

def exec():
   start = datetime.now()
   #api from Coingeko
   url = "https://indexer.ref.finance/list-token-price"
   r = requests.get(url)

   data = r.json()
   token_data = []
   for token, details in data.items():
       token_price = float(details["price"])
       token_symbol = details["symbol"]
       token_data.append((token_symbol, 'USD', token_price))

   # Assuming dboperations.act_prices_batch accepts a list of tuples
   dboperations.act_prices_batch(token_data)

   print('Tiempo de ejecución REF FINANCE FIAT ' + str(datetime.now() - start))

# exec()
'''
'''--- fiat_near.py ---
import requests
import json
from datetime import datetime
import dboperations
# from scraping import price

# def exec():
#     url = 'https://pro-api.coinmarketcap.com/v2/tools/price-conversion'
#     parameters = {
#       'symbol':'NEAR',
#       'amount':'1',
#       'convert': 'VES,USD'
#     }
#     headers = {
#       'Accepts': 'application/json',
#       'X-CMC_PRO_API_KEY': '0a756f72-99ad-4ee7-be7d-68ed5fd52658',
#     }

#     session = Session()
#     session.headers.update(headers)

#     try:
#       index = 0
#       response = session.get(url, params=parameters)
#       data = json.loads(response.text)
#       df = pd.json_normalize(data['data'])
#       #print(df)
#       for x in listSymbol:
#           index += 1
#           dboperations.act_prices('NEAR', symbol_name(index), float(df[x][0]))
#           #print(symbol_name(index))
#           #print(df[x][0])
#     except (ConnectionError, Timeout, TooManyRedirects) as e:
#       print(e)

#     #Actualizar el precio de la moneda ars
#     ars_near.exec()

def exec():
   start = datetime.now()
   #api from Coingeko
   url = "https://api.coingecko.com/api/v3/coins/near/tickers/"
   r = requests.get(url)
   
   #api from dolar scraping
   # precios = price()
   # ves_price = precios
   
   #api dolar blue
   # api from dolar today
   urlars = "https://dolar-api-argentina.vercel.app/v1/dolares/blue"
   rves = requests.get(urlars)
   ars_price = float(rves.json()["venta"])

   # print(r.status_code)

   near_price = float(r.json()["tickers"][0]["last"])
   # ves_near = near_price * ves_price
   ars_near = near_price * ars_price
   # print(ves_near) 
   # #ves  
   # dboperations.act_prices('NEAR', 'VES', ves_near)
   # #ars
   dboperations.act_prices('NEAR', 'ARS', ars_near)
   #
   # dboperations.act_prices('NEAR', 'USD', near_price)
   print('Tiempo de ejecución NEAR FIAT ' + str(datetime.now() - start))

# exec()
'''
'''--- fiat_usdt.py ---
import requests
import json
from datetime import datetime
import dboperations
# from scraping import price

# listSymbol = ["quote.VES.price"
#             , "quote.USD.price"
#             ]

# def symbol_name(pos):
#       dict = {   1: "VES"        
#                , 2: "USD"}
#       return dict.get(pos)  

# def exec():
#     url = 'https://pro-api.coinmarketcap.com/v2/tools/price-conversion'
#     parameters = {
#     'symbol':'USDC',
#     'amount':'1',
#     'convert': 'VES,USD'
#     }
#     headers = {
#     'Accepts': 'application/json',
#     'X-CMC_PRO_API_KEY': '2f48c701-7b9d-485e-8bee-ccd6d981111f',
#     }

#     session = Session()
#     session.headers.update(headers)

#     try:
#         index = 0
#         response = session.get(url, params=parameters)
#         data = json.loads(response.text)
#         df = pd.json_normalize(data['data'])
#         #print(df)
#         for x in listSymbol:
#             index += 1
#             dboperations.act_prices('USDC', symbol_name(index), float(df[x][0]))
#             #print(symbol_name(index))
#             #print(df[x][0])
#     except (ConnectionError, Timeout, TooManyRedirects) as e:
#         print(e)

#     #Actualizar el precio de la moneda ars
#     ars_usdc.exec()

def exec():
   start = datetime.now()
   index = 0
   #api from Coingeko
   # url = "https://api.coingecko.com/api/v3/simple/price?ids=tether&vs_currencies=usd"
   # r = requests.get(url)

   # usd_price = float(r.json()["tether"]["usd"])
   #
   #dboperations.act_prices('USDT', 'USD', usd_price)
   #api from dolar Venezuela
   # precios = price()
   # ves_price = precios
   # dboperations.act_prices('USDT', 'VES', ves_price)
   # print(ves_price)
   #api from vercel
   urlars = "https://dolar-api-argentina.vercel.app/v1/dolares/blue"
   rars = requests.get(urlars)
   ars_price = float(rars.json()["venta"])
   dboperations.act_prices('USDT', 'ARS', ars_price)

      #api from api.exchangerate.host
      # urlcop = "https://api.exchangerate.host/latest?base=USD&symbols=COP"
      # rcop = requests.get(urlcop)
      # cop_price = float(rcop.json()["rates"]["COP"])
      # dboperations.act_prices('USDT', 'COP', cop_price)
   
   print('Tiempo de ejecución USDT FIAT ' + str(datetime.now() - start))
'''
'''--- fiat_wbtc.py ---
import requests
import json
from datetime import datetime
import dboperations

def exec():
   start = datetime.now()
   #api from Coingeko
   url = "https://api.binance.com/api/v3/ticker/price?symbol=WBTCUSDT"
   r = requests.get(url)

   token_price = float(r.json()["price"])
   #
   dboperations.act_prices('WBTC', 'USD', token_price)
   print('Tiempo de ejecución WBTC FIAT ' + str(datetime.now() - start))

# exec()
'''
'''--- fiat_weth.py ---
import requests
import json
from datetime import datetime
import dboperations

def exec():
   start = datetime.now()
   #api from Coingeko
   url = "https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT"
   r = requests.get(url)

   token_price = float(r.json()["price"])
   #
   dboperations.act_prices('WETH', 'USD', token_price)
   print('Tiempo de ejecución WETH FIAT ' + str(datetime.now() - start))

# exec()
'''
'''--- fiat_wnear.py ---
import requests
import json
from datetime import datetime
import dboperations

def exec():
   start = datetime.now()
   #api from Coingeko
   url = "https://api.binance.com/api/v3/ticker/price?symbol=NEARUSDT"
   r = requests.get(url)

   token_price = float(r.json()["price"])
   #
   dboperations.act_prices('wNEAR', 'USD', token_price)
   print('Tiempo de ejecución wNEAR FIAT ' + str(datetime.now() - start))

#exec()
'''
'''--- requirements.txt ---
beautifulsoup4==4.12.2
bs4==0.0.1
certifi==2023.5.7
charset-normalizer==3.1.0
idna==3.4
notify2==0.3.1
psycopg2-binary==2.9.6
pyDolarVenezuela==1.0.3
requests==2.31.0
soupsieve==2.4.1
urllib3==2.0.3

'''