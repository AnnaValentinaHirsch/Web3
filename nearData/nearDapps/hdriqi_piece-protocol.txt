*GitHub Repository "hdriqi/piece-protocol"*

'''--- README.md ---
Piece Protocol
==================

An incentivized protocol both for creators and supporters.

Demo
====

[<img src="https://i.ibb.co/TtDZfms/5f7324b0dd22apiece-thumbnail.png">](https://www.loom.com/share/af2f558cdd2b43e9a8dae1a5d968447f)

Development
===========

1. Prerequisites: Make sure you've installed [Node.js] â‰¥ 12
2. Install dependencies: `yarn install`
3. You can deploy to near testnet using dev account: `yarn deploy:dev`

Smart Contract
==============

The smart contract was deployed at [dev-v1.piece.testnet](https://explorer.testnet.near.org/accounts/dev-v1.piece.testnet) and written in AssemblyScript.

You can call the smart contract via `near-cli`:

Example:

```bash
near call dev-v1.piece.testnet piece "{\"receiverId\": \"receiver_account_id\"}" --amount "5" --gas "100000000000000" --accountId your_account_id
```

When you call `piece`, make sure to attach minimum 100 Tgas. For other function, you can just attach the default 30 Tgas.

Custom Deployment
=================

`create-account.js` helps you generate a sub-account for your contract deployment. You can just change a few lines of code so that it matches your main test account.
'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports');
'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json", 
  "entry": "assembly/main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
}
'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__tests__/main.spec.ts ---
// import { genUser, getReward, piece } from "../main"

import { getProfile, getProfileList, piece, updateProfile } from '../main'

describe('Main ', () => {
	// it("should create run piece", () => {
	// 	const m = 20
	// 	genUser(0, m)

	// 	for (let i = 1; i < m; i++) {
	// 		piece(i.toString())
	//   }

	//   for (let i = 1; i < m; i++) {
	// 		log(getReward(i.toString()))
	//   }
	// })

	it('should update and get profile', () => {
		updateProfile('bob', 'avatar', 'bio')
		const newProfile = getProfile('bob')
		expect(newProfile).toBeTruthy()
		if (newProfile) {
			expect(newProfile.userId).toBe('bob')
			expect(newProfile.avatar).toBe('avatar')
			expect(newProfile.bio).toBe('bio')
		}

		const profileList = getProfileList(0)
		expect(profileList.length).toBe(1)
	})

	// it('should getProfile', () => {
	// 	updateProfile('bob', 'avatar', 'bio')
	// 	const newProfile = getProfile('bob')
	// 	log(newProfile)
	// 	// expect(newProfile.userId).toBe('bob')
	// })
})

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/main.ts ---
import {
	context,
	PersistentDeque,
	PersistentMap,
	u128,
	ContractPromiseBatch,
	storage,
	PersistentVector,
} from 'near-sdk-as'

const len = 4

const mappedPoolKey = 'm:pool'
const mappedRewardKey = 'm:reward'
const mappedProfileKey = 'm:profile'
const mappedRewardActivityKey = 'm:reward:activity'
const mappedBalanceActivityKey = 'm:balance:activity'
const vectorProfileKey = 'v:profile'

export type Pool = PersistentDeque<string>
export type ActivityList = PersistentVector<Activity>
export const mappedPool = new PersistentMap<string, Pool>(mappedPoolKey)
export const mappedReward = new PersistentMap<string, string>(mappedRewardKey)
export const mappedProfile = new PersistentMap<string, Profile>(
	mappedProfileKey
)
export const mappedRewardActivity = new PersistentMap<string, ActivityList>(
	mappedRewardActivityKey
)
export const mappedBalanceActivity = new PersistentMap<string, ActivityList>(
	mappedBalanceActivityKey
)
export const vectorProfile = new PersistentVector<string>(vectorProfileKey)

@nearBindgen
class Activity {
	from: string
	value: string
	createdAt: u64

	constructor(from: string, value: string) {
		this.from = from
		this.value = value
		this.createdAt = context.blockTimestamp
	}
}

@nearBindgen
class Profile {
	userId: string
	avatar: string
	bio: string

	constructor(userId: string, avatar: string, bio: string) {
		this.userId = userId
		this.avatar = avatar
		this.bio = bio
	}
}

const initKey = 'contract::init'
const ownerKey = 'contract::owner'

export function init(): void {
	assert(
		storage.get<string>(initKey) == null,
		'[PieceProtocol] ALREADY_INITIALIZED'
	)
	storage.set<string>(ownerKey, context.sender)
	storage.set<string>(initKey, 'done')
}

export function getOwner(): string {
	const owner = storage.get<string>(ownerKey)
	if (owner) {
		return owner
	}
	return ''
}

export function setOwner(userId: string): boolean {
	assert(getOwner() == context.sender, '[PieceProtocol] ONLY_OWNER')
	storage.set<string>(ownerKey, userId)
	return true
}

export function getProfileList(page: i32 = 0): Profile[] {
	const limit = 8
	const start = page * limit

	if (start > vectorProfile.length || vectorProfile.length === 0) {
		return []
	}

	const len =
		vectorProfile.length - start > limit ? limit : vectorProfile.length - start

	const profileList: Profile[] = []
	for (let i = start; i < len; i++) {
		const userId: string = vectorProfile[i]
		if (userId) {
			const profile = mappedProfile.get(userId)
			if (profile) {
				profileList.push(profile)
			}
		}
	}
	return profileList
}

export function getRewardActivityList(
	userId: string,
	page: i32 = 0
): Activity[] {
	const limit = 8
	const start = page * limit

	const arr = mappedRewardActivity.get(userId)
	if (!arr) {
		return []
	}
	if (start > arr.length || arr.length === 0) {
		return []
	}

	const len = arr.length - start > limit ? limit : arr.length - start

	const activityList: Activity[] = []
	for (let i = len - 1; i >= start; i--) {
		const activity: Activity = arr[i]
		if (activity) {
			activityList.push(activity)
		}
	}
	return activityList
}

export function getBalanceActivityList(
	userId: string,
	page: i32 = 0
): Activity[] {
	const limit = 8
	const start = page * limit

	const arr = mappedBalanceActivity.get(userId)
	if (!arr) {
		return []
	}
	if (start > arr.length || arr.length === 0) {
		return []
	}

	const len = arr.length - start > limit ? limit : arr.length - start

	const activityList: Activity[] = []
	for (let i = len - 1; i >= start; i--) {
		const activity: Activity = arr[i]
		if (activity) {
			activityList.push(activity)
		}
	}
	return activityList
}

export function getProfile(userId: string): Profile | null {
	const profile = mappedProfile.get(userId)
	if (profile) {
		return profile
	}
	return null
}

export function updateProfile(
	userId: string,
	avatar: string,
	bio: string
): Profile {
	assert(userId == context.sender, '[PieceProtocol] SENDER_NOT_MATCH')
	const newProfile = new Profile(userId, avatar, bio)
	const exist = mappedProfile.get(userId)
	if (!exist) {
		vectorProfile.push(userId)
	}
	mappedProfile.set(userId, newProfile)
	return newProfile
}

export function getReward(userId: string): string {
	const curBal = mappedReward.get(userId)
	if (curBal) {
		return curBal.toString()
	}
	return '0'
}

export function claimReward(): string {
	const curBal = mappedReward.get(context.sender)
	if (curBal) {
		ContractPromiseBatch.create(context.sender).transfer(u128.from(curBal))
		let receiverActivityList = mappedBalanceActivity.get(context.sender)
		const newActivity = new Activity(context.contractName, curBal)

		if (!receiverActivityList) {
			const key = genActivityListKey(context.sender, 'balance')
			const newActivityList = new PersistentVector<Activity>(key)
			receiverActivityList = newActivityList
		}
		receiverActivityList.push(newActivity)
		mappedBalanceActivity.set(context.sender, receiverActivityList)
		return rewardSub(context.sender, curBal)
	}
	return '0'
}

export function piece(receiverId: string): void {
	const userId = context.sender
	assert(receiverId != userId, '[PieceProtocol] CANNOT_SELF_PIECE')
	const value = context.attachedDeposit
	const forOwner: u128 = u128.div10(u128.mul(value, u128.from(9)))
	const forSupporter: u128 = u128.sub(value, forOwner)
	let pool = mappedPool.get(receiverId)
	if (!pool) {
		const poolKey = genPoolKey(receiverId)
		const newPool = new PersistentDeque<string>(poolKey)
		newPool.pushFront(getOwner())
		mappedPool.set(receiverId, newPool)
		pool = newPool
	}

	ContractPromiseBatch.create(receiverId).transfer(forOwner)
	let receiverActivityList = mappedBalanceActivity.get(receiverId)
	const newActivity = new Activity(context.sender, forOwner.toString())

	if (!receiverActivityList) {
		const key = genActivityListKey(receiverId, 'balance')
		const newActivityList = new PersistentVector<Activity>(key)
		receiverActivityList = newActivityList
	}
	receiverActivityList.push(newActivity)
	mappedBalanceActivity.set(receiverId, receiverActivityList)

	disburse(receiverId, pool, forSupporter)
	pool.pushFront(userId)
	mappedPool.set(receiverId, pool)
}

function genActivityListKey(userId: string, type: string): string {
	if (type == 'balance') {
		return 'activity' + '::' + mappedBalanceActivityKey + '::' + userId
	} else {
		return 'activity' + '::' + mappedRewardActivityKey + '::' + userId
	}
}

function genPoolKey(userId: string): string {
	return 'pool' + '::' + mappedPoolKey + '::' + userId
}

function rewardAdd(userId: string, value: string): string {
	const curBal = mappedReward.get(userId)
	const newBal = curBal
		? u128.add(u128.from(curBal), u128.from(value))
		: u128.from(value)
	mappedReward.set(userId, newBal.toString())
	return newBal.toString()
}

function rewardSub(userId: string, value: string): string {
	const curBal = mappedReward.get(userId)
	assert(
		u128.ge(u128.from(curBal), u128.from(value)),
		'[PieceProtocol] NOT_ENOUGH_REWARD_BALANCE'
	)
	const newBal = u128.sub(u128.from(curBal), u128.from(value))
	mappedReward.set(userId, newBal.toString())
	return newBal.toString()
}

function disburse(receiverId: string, pool: Pool, forSupporter: u128): void {
	if (pool.length > 0) {
		const rewardCount: i32 = pool.length > len ? len : pool.length
		const pieceForSupporter = u128.div(forSupporter, u128.from(rewardCount))
		for (let j = 0; j < rewardCount; j++) {
			const userId = pool.popFront()
			rewardAdd(userId, pieceForSupporter.toString())
			pool.pushBack(userId)

			let receiverActivityList = mappedRewardActivity.get(userId)
			const newActivity = new Activity(
				receiverId,
				pieceForSupporter.toString()
			)

			if (!receiverActivityList) {
				const key = genActivityListKey(userId, 'reward')
				const newActivityList = new PersistentVector<Activity>(key)
				receiverActivityList = newActivityList
			}
			receiverActivityList.push(newActivity)
			mappedRewardActivity.set(userId, receiverActivityList)
		}
	}
}

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- config.js ---
function getConfig(env, contractName) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: contractName,
        walletUrl: 'https://wallet.mainnet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'default',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: contractName,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
      }
    case 'devnet':
      return {
        networkId: 'devnet',
        nodeUrl: 'https://rpc.devnet.near.org',
        contractName: contractName,
        walletUrl: 'https://wallet.devnet.near.org',
        helperUrl: 'https://helper.devnet.near.org',
      }
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: contractName,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
      }
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: contractName,
      }
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: contractName,
        masterAccount: 'test.near',
      }
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: contractName,
        masterAccount: 'test.near',
      }
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- create-account.js ---
const Near = require('./near')

const main = async () => {
  const userId = process.argv[2]
  if (userId.length > 0) {
    const near = new Near()
    await near.init()
    await near.createAccount(`${userId}.piece.testnet`)
    console.log('Account creation success')
  }
}

main()
'''
'''--- near.js ---
const fs = require('fs')
const { KeyPair, connect } = require('near-api-js');
const { parseNearAmount } = require('near-api-js/lib/utils/format');
const homedir = require('os').homedir()
const path = require('path')
const { UnencryptedFileSystemKeyStore } = require('near-api-js').keyStores

const CREDENTIALS_DIR = '.near-credentials';
const credentialsPath = path.join(homedir, CREDENTIALS_DIR)

const config = require('./config')(
	process.env.NODE_ENV || 'development'
)

class Near {
	constructor() {
		this.ctx = null
		this.masterAccount = null
	}

	async init() {
		const near = await connect({
			deps: {
				keyStore: new UnencryptedFileSystemKeyStore(credentialsPath),
			},
			...config,
		})
		this.ctx = near
		this.masterAccount = await near.account('piece.testnet')
	}

	async createAccount(newAccId) {
		const keyPair = KeyPair.fromRandom('ed25519')
		const newAccount = await this.masterAccount.createAccount(
			newAccId,
      keyPair.publicKey.toString(),
      parseNearAmount('100')
    )
    const account = {
      account_id: newAccId,
      public_key: `ed25519:keyPair.publicKey.toString()`,
      private_key: `ed25519:${keyPair.secretKey}`
    }

    fs.writeFileSync(path.join(credentialsPath, `default`, `${newAccId}.json`), JSON.stringify(account))
    
		return newAccount
	}

	async deployContract(contractId) {
    const contractAcc = await this.ctx.account(contractId)
		console.log('Setting up and deploying contract')
		const contractPath = path.join(process.cwd(), 'out/main.wasm')
		await contractAcc.deployContract(
			require('fs').readFileSync(contractPath)
		)
		console.log(`Contract ${contractAcc.accountId} deployed`)
	}
}

module.exports = Near

'''
'''--- package.json ---
{
  "name": "piece-protocol",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "NODE_ENV=development nodemon --watch assembly -e ts --exec asp",
    "build": "asb",
    "deploy:dev": "NODE_ENV=development npm run build && near dev-deploy",
    "deploy:staging": "NODE_ENV=staging npm run build && near deploy dev-v1.piece.testnet",
    "deploy:prod": "NODE_ENV=production npm run build && near deploy v1.piece.testnet"
  },
  "dependencies": {
    "near-api-js": "^0.29.0"
  },
  "devDependencies": {
    "near-sdk-as": "^2.0.0",
    "near-shell": "^0.24.9",
    "nodemon": "^2.0.4"
  },
  "author": "Rahmat Albariqi",
  "license": "MIT"
}

'''