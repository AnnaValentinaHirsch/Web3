*GitHub Repository "near-examples/poker"*

'''--- Cargo.toml ---
[workspace]
members = ["poker"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- README.md ---
# Poker

Play online poker without third parties (and without fees). Bet with NEAR. **Profit**.
Based on [Mental Poker](https://en.wikipedia.org/wiki/Mental_poker) algorithm [proposed by Shamir, Rivest, Adleman](https://apps.dtic.mil/dtic/tr/fulltext/u2/a066331.pdf).

## Security details

The `poker` contract is a "fair game" with some caveats.

**Pros:**

- Unbiased deck shuffling.
- Provable and secret card drawing.

**Cons:**

- If a player leaves the game the game stalls. Tokens of the player that left the game are slashed and remaining tokens are turned back to other participants.
- ZK-Proofs are required to avoid:
  - players submitting invalid data while shuffling deck and partially revealing a card.
  - players learning secret information from other players.

## Setup

1. `npm install -g near-shell`. This will create a global command `near`. Check with `near --version`.

2. `pip install -r client/requirements.txt`

3. Log in with wallet. Make sure you have access to you keys, usually they are stored on `neardev/**/<account_id>.json`
    - Create an account at [the wallet](https://wallet.nearprotocol.com/).
    - Log in using `near login`

4. Launch the python client: `python3 client /path/to/account_id_key.json`

Once you start using the python client watch `poker.log` to see all the interactions taking place with the blockchain.

## How to play

This is how a games look using the client. On start type `help` as suggested to see all commands:

```
[bob]>>> help
Available commands:
[d]deck_state   Show raw deck state.
                args: <room_id>

[e]enter        Enter a room. Can only enter to play in rooms that are Initiating.
                args: <room_id>

[f]fold         Fold your cards for this round.
                args: <room_id>

[h]help         Show this help
                args:

[l]list         List all rooms.
                args:

[n]new_room     Create a new room.
                args: <name>

[p]poker_state  Show raw poker table state.
                args: <room_id>

[r]raise        Increase your current bet TO amount.
                args: <amount> <room_id>

[s]start        Start the game in a room if it is Initiating or Idle
                args: <room_id>

[t]state        Show game state.
                args: <room_id>
```

### Create a new room

```
[bob]>>> new_room poker_arena
Created room poker_arena with id 1
```

### List all rooms

```
[bob]>>> list
000 qwerty Idle
001 poker_arena Initiating
```

Each row of the output describes a room: `id name current_status`
You can only enter in rooms with state: `Initiating`

### Enter a room

```
[bob]>>> enter 1

[bob]>>>
  Name  | Cards | Total | Staked | On Game | Turn
--------+-------+-------+--------+---------+------
 bob(*) |       |  1000 |   0    |   True  |

Status: Initiating
```

Notice that the id is an integer. So no need to provide leading 0.
Right now fake tokens are used and all player start with 1000 tokens.

### Start the game

Wait for other players join the game. Board is updated automatically as new players join:

```
  Name  | Cards | Total | Staked | On Game | Turn
--------+-------+-------+--------+---------+------
 bob(*) |       |  1000 |   0    |   True  |
--------+-------+-------+--------+---------+------
 alice  |       |  1000 |   0    |   True  |
--------+-------+-------+--------+---------+------
 carol  |       |  1000 |   0    |   True  |

Status: Initiating
```

After entering a room you don't need to provide room argument necessarily for subsequent commands. Last room entered will be used by default.

Start the game writing `start`. You should see something similar to this:

```
[bob]>>>
  Name  | Cards | Total | Staked | On Game |    Turn
--------+-------+-------+--------+---------+-----------
 bob(*) |       |  1000 |   0    |   True  |
--------+-------+-------+--------+---------+-----------
 alice  |       |  1000 |   0    |   True  | Shuffling
--------+-------+-------+--------+---------+-----------
 carol  |       |  1000 |   0    |   True  |

[bob]>>>
  Name  | Cards | Total | Staked | On Game |    Turn
--------+-------+-------+--------+---------+-----------
 bob(*) |       |  1000 |   0    |   True  |
--------+-------+-------+--------+---------+-----------
 alice  |       |  1000 |   0    |   True  |
--------+-------+-------+--------+---------+-----------
 carol  |       |  1000 |   0    |   True  | Shuffling

[bob]>>>
  Name  | Cards | Total | Staked | On Game |    Turn
--------+-------+-------+--------+---------+-----------
 bob(*) |       |  1000 |   0    |   True  |
--------+-------+-------+--------+---------+-----------
 alice  |       |  1000 |   0    |   True  | Shuffling
--------+-------+-------+--------+---------+-----------
 carol  |       |  1000 |   0    |   True  |

[bob]>>>
  Name  | Cards | Total | Staked | On Game |    Turn
--------+-------+-------+--------+---------+-----------
 bob(*) |       |  1000 |   6    |   True  |
--------+-------+-------+--------+---------+-----------
 alice  |       |  1000 |   0    |   True  | Revealing
--------+-------+-------+--------+---------+-----------
 carol  |       |  1000 |   3    |   True  |

[bob]>>>
```

The board is being updated while state is changing. Initially all players need to shuffle and encrypt the deck (this is done automatically but requires some time). After deck is shuffled initial cards are dealt to participants.

```
[bob]>>>
  Name  | Cards  | Total | Staked | On Game |   Turn
--------+--------+-------+--------+---------+---------
 bob(*) | 10♠ 9♦ |  1000 |   6    |   True  |
--------+--------+-------+--------+---------+---------
 alice  |        |  1000 |   0    |   True  | Betting
--------+--------+-------+--------+---------+---------
 carol  |        |  1000 |   3    |   True  |

[bob]>>>
```

For example carol will be seeing a different board:

```
[carol]>>>
   Name   | Cards | Total | Staked | On Game |   Turn
----------+-------+-------+--------+---------+---------
   bob    |       |  1000 |   6    |   True  |
----------+-------+-------+--------+---------+---------
  alice   |       |  1000 |   0    |   True  | Betting
----------+-------+-------+--------+---------+---------
 carol(*) | 8♦ 9♥ |  1000 |   3    |   True  |

[carol]>>>
```

And alice:

```
[alice]>>>
   Name   | Cards | Total | Staked | On Game |   Turn
----------+-------+-------+--------+---------+---------
   bob    |       |  1000 |   6    |   True  |
----------+-------+-------+--------+---------+---------
 alice(*) | 3♠ 4♦ |  1000 |   0    |   True  | Betting
----------+-------+-------+--------+---------+---------
  carol   |       |  1000 |   3    |   True  |

[alice]>>>
```

Staked column denotes how much is at stake at this moment by every participant. Initially there is a big blind of 6 token by player at seat 1, and small blind by previous player (at seat n). Player next to the big blind is first to play, in this case alice at seat 2.

Turn column denotes which player should play and what is the expected type of action from it.
User interaction in the middle of a round is only required on state `Betting`.

For the purpose of demonstration we will show the point of view of each player. You can notice which player we are referring to from the context of from the name in the prompt.

### Betting

When is the turn to bet for a player it has two options: (`Fold` and `Raise`).

**Folding**

Alice will fold as she has very bad hand and nothing at stake.

```
[alice]>>> fold
{'Ok': None}

[alice]>>>
   Name   | Cards | Total | Staked | On Game |   Turn
----------+-------+-------+--------+---------+---------
   bob    |       |  1000 |   6    |   True  |
----------+-------+-------+--------+---------+---------
 alice(*) | 3♠ 4♦ |  1000 |   0    |  False  |
----------+-------+-------+--------+---------+---------
  carol   |       |  1000 |   3    |   True  | Betting
```

After alice fold its Carol turn. The column *On Game* denotes player that haven't fold so far. Since Alice just fold it is not longer playing this hand.

**Raise**

When typing `raise amount` it imply you will increase your stake to `amount` (not adding). It is not valid to raise less than max stake or more than total amount of token. There is a particular case when it is allowed to raise less than max stake and it is when is raised to total token (*All-in*).

Carol will raise the bet to 10 using:

```
[carol]>>> raise 10
{'Ok': None}

[carol]>>>
   Name   | Cards | Total | Staked | On Game |   Turn
----------+-------+-------+--------+---------+---------
   bob    |       |  1000 |   6    |   True  | Betting
----------+-------+-------+--------+---------+---------
  alice   |       |  1000 |   0    |  False  |
----------+-------+-------+--------+---------+---------
 carol(*) | 8♦ 9♥ |  1000 |   10   |   True  |

[carol]>>>
```

**Calling**

And Bob will see Carol bet.

```
[bob]>>> raise 10
{'Ok': None}

...

[bob]>>>
  Name  | Cards  | Total | Staked | On Game |   Turn
--------+--------+-------+--------+---------+---------
 bob(*) | 10♠ 9♦ |  1000 |   10   |   True  |
--------+--------+-------+--------+---------+---------
 alice  |        |  1000 |   0    |  False  |
--------+--------+-------+--------+---------+---------
 carol  |        |  1000 |   10   |   True  | Betting

Table: 9♣ 4♥ 8♥
```

A lot of boards will be displayed before this last board, since to reveal each card all participants needs to interact with the blockchain which might take some time.

Notice in the bottom of the board the three cards revealed on the *Flop*.

## Summary

Up to this point you have the basics about how to interact with this tool. Notice that rounds might take long time since it requires communication with the blockchain sequentially (not in parallel) from all players.

## Deploying the poker contract

1. Login with the account you will use to fund the contract. (Let's call it `macboy`).

2. Create the account to deploy the contract (Let's call it `poker`)

    `near create_account poker --masterAccount macboy --initialBalance 100 --keyPath neardev/default/macboy.json`

3. Build the contract. Requires to have [rust installed](https://www.rust-lang.org/tools/install).

    `./scripts/build.sh`

4. Deploy the binary:

    `near deploy --wasmFile res/poker.wasm  --accountId poker --keyPath neardev/default/poker.json`

## Disclaimer

This project is work in progress, it is missing some features and has some bugs. See TODO in the code for more details.

### Roadmap

1. Determine round winners and give pot back to them.
2. Use NEAR tokens.
3. Player who loose al its cash should be removed from the game.
4. Slash participant that stalls the game and recover from that state.
5. Add ZK-Proof to avoid invalid data while interacting with the deck.
    - [Shuffle and encrypt](http://www.csc.kth.se/~terelius/TeWi10Full.pdf)
6. Improve communication performance.

'''
'''--- client/__init__.py ---

'''
'''--- client/__main__.py ---
import argparse
import json

from lib import App, register
from watcher import watch
from poker import Poker
from ui import PokerUI

CONTRACT = 'poker'

class PokerCli(App):
    @register(name="list", help="List all rooms.")
    def list_all(self):
        rooms = [(int(room['id']), room['name'], room['status'])
                 for room in self.near.view("all_rooms", {})]

        if len(rooms) == 0:
            print("No rooms found.")
            return

        rooms.sort()
        for room_id, name, status in rooms:
            print(f"{room_id:>03} {name} {status}")

    @register(help="<name> | Create a new room.")
    def new_room(self, name):
        room_id = self.near.change("new_room", dict(name=name))
        print(f"Created room {name} with id {room_id}")

    @register(help="<room_id> | Enter a room. Can only enter to play in rooms that are Initiating.")
    def enter(self, room_id):
        room_id = int(room_id)
        result = self.near.change("enter", dict(room_id=room_id))
        self.ui.enter(room_id)
        watch(self.near, room_id, self.ui)
        self.room_id = room_id

    @register(name="start", help="<room_id> | Start the game in a room if it is Initiating or Idle")
    def _start(self, room_id=None):
        if room_id is None:
            room_id = self.room_id
        room_id = int(room_id)
        result = self.near.change("start", dict(room_id=room_id))
        print(result)

    @register(name="raise", help="<amount> <room_id> | Increase your current bet TO amount.")
    def _raise(self, amount, room_id=None):
        if room_id is None:
            room_id = self.room_id
        room_id = int(room_id)
        amount = int(amount)
        result = self.near.change("submit_bet_action", dict(
            room_id=room_id, bet={"Stake": amount}))
        print(result)

    @register(help="<room_id> | Fold your cards for this round.")
    def fold(self, room_id=None):
        if room_id is None:
            room_id = self.room_id
        room_id = int(room_id)
        result = self.near.change("submit_bet_action", dict(
            room_id=room_id, bet="Fold"))
        print(result)

    @register(short="t", help="<room_id> | Show game state.")
    def state(self, room_id=None):
        if room_id is None:
            room_id = self.room_id
        room_id = int(room_id)
        result = self.near.view("state", dict(room_id=room_id))
        print(result)

    @register(help="<room_id> | Show raw deck state.")
    def deck_state(self, room_id=None):
        if room_id is None:
            room_id = self.room_id
        room_id = int(room_id)
        result = self.near.view("deck_state", dict(room_id=room_id))
        print(result)

    @register(help="<room_id> | Show raw poker table state.")
    def poker_state(self, room_id=None):
        if room_id is None:
            room_id = self.room_id
        room_id = int(room_id)
        result = self.near.view("poker_state", dict(room_id=room_id))
        print(result)

if __name__ == '__main__':
    parser = argparse.ArgumentParser('Poker game')
    parser.add_argument(
        'node_key', help="Path to validator key. Usually in neardev/*/<account_id>.json.")
    parser.add_argument('--contract', help="Contract to use", default=CONTRACT)
    parser.add_argument('--nodeUrl', help="NEAR Rpc endpoint")

    args = parser.parse_args()

    app = PokerCli(args.node_key, args.contract, args.nodeUrl, PokerUI())
    app.start()

'''
'''--- client/cryptography.py ---
import random

# Some primer numbers of different magnitudes.
# 1000000007
# 1000000000039
# 1000000000000000003
# 1000000000000000000000007
# 1000000000000000000000000000057
# Big prime number. Increase it for more security.
MOD = 1000000000000000003

def extended_gcd(a, b):
    s, old_s = 0, 1
    t, old_t = 1, 0
    r, old_r = b, a

    while r != 0:
        q = old_r // r
        old_r, r = r, old_r - q * r
        old_s, s = s, old_s - q * s
        old_t, t = t, old_t - q * t

    return old_r, old_s, old_t

def generate_secret_key():
    while True:
        sk = random.randint(100, MOD - 1)
        if extended_gcd(sk, MOD - 1)[0] == 1:
            return sk

def inverse(a, mod):
    g, x, y = extended_gcd(a, mod)
    assert g == 1
    return (x % mod + mod) % mod

def encrypt_and_shuffle(partial_shuffle, secret_key):
    partial_shuffle = [pow(num, secret_key, MOD) for num in partial_shuffle]
    random.shuffle(partial_shuffle)
    return partial_shuffle

def partial_decrypt(progress, secret_key):
    pw = inverse(secret_key, MOD - 1)
    return pow(progress, pw, MOD)

'''
'''--- client/lib.py ---
import re
import json
import relaxedjson
from subprocess import PIPE, Popen, check_output
import logging

logging.basicConfig(filename='poker.log', filemode='a+',
                    format='%(asctime)s - %(levelname)s - %(message)s', level=logging.DEBUG)

ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')

def get_account_id(path):
    with open(path) as f:
        data = relaxedjson.parse(f.read())
    return data['account_id']

def parse(inp):
    inp = ansi_escape.sub('', inp)
    logging.debug(f"Parsing: {repr(inp)}")
    return relaxedjson.parse(inp)

class Command:
    def __init__(self, short, name, help, callback):
        self.short = short
        self.name = name
        self.help = help
        self.callback = callback

class Near:
    def __init__(self, node_key_path, contract, node_url):
        self.node_key_path = node_key_path
        self.contract = contract
        self.node_url = node_url
        self.account_id = get_account_id(node_key_path)

    def _parse(self, output):
        lines = output.strip('\n').split('\n')
        pos = 0
        while pos < len(lines) and not lines[pos].startswith("Loaded"):
            pos += 1

        if pos == len(lines):
            raise ValueError(f"Error parsing output: {output}")

        output = '\n'.join(lines[pos + 1:])
        return parse(output)

    def add_command_url(self, command):
        if self.node_url:
            command.extend(["--nodeUrl", self.node_url])
        return command

    def view(self, name, args={}):
        command = [
            "near",
            "view",
            self.contract,
            name,
            json.dumps(args),
            "--keyPath",
            self.node_key_path,
            "--masterAccount",
            self.account_id
        ]
        command = self.add_command_url(command)

        logging.debug(f"View Command: {command}")
        proc = Popen(command, stdout=PIPE, stderr=PIPE)

        ret = proc.wait()
        logging.debug(f"Exit code: {ret}")
        if ret == 0:
            result = proc.stdout.read().decode()
            return self._parse(result)
        else:
            logging.warn(f"Command stdout: {proc.stdout.read().decode()}")

    def change(self, name, args={}):
        command = [
            "near",
            "call",
            self.contract,
            name,
            json.dumps(args),
            "--keyPath",
            self.node_key_path,
            "--accountId",
            self.account_id
        ]
        command = self.add_command_url(command)

        logging.debug(f"Change Command: {command}")
        proc = Popen(command, stdout=PIPE, stderr=PIPE)

        ret = proc.wait()
        logging.debug(f"Exit code: {ret}")
        if ret == 0:
            result = proc.stdout.read().decode()
            return self._parse(result)
        else:
            logging.warn(f"Command stdout: {proc.stdout.read().decode()}")

def register(function=None, *, short=None, name=None, help=""):
    if function is None:
        def dec(function):
            function._command = True
            function._name = name or function.__name__
            function._short = short or function._name[0]
            function._help = help
            return function
        return dec
    else:
        function._command = True
        function._name = name or function.__name__
        function._short = short or function._name[0]
        function._help = help
        return function

class App:
    def __init__(self, node_key_path, contract, node_url, ui):
        self.near = Near(node_key_path, contract, node_url)
        self.ui = ui
        self.ui.set_account_id(self.near.account_id)
        self._commands = {}
        for func_name in dir(self):
            if func_name.startswith('__'):
                continue
            func = self.__getattribute__(func_name)
            if '_command' in dir(func):
                self._register(func._short, func._name, func._help, func)

    @property
    def account_id(self):
        return self.near.account_id

    def get_account_id(self):
        print(self.account_id)

    def _register(self, short, name, help, callback):
        assert not short in self._commands
        assert not name in self._commands
        command = Command(short, name, help, callback)
        self._commands[name] = command
        self._commands[short] = command

    @register(help="Show this help")
    def help(self, *args):
        print("Available commands:")
        for key, command in sorted(self._commands.items()):
            if key == command.name:
                parts = command.help.split('|')
                if len(parts) == 2:
                    _args = parts[0]
                    _expl = parts[1].strip()
                elif len(parts) == 1:
                    _args = ''
                    _expl = parts[0].strip()
                else:
                    _args = ''
                    _expl = ''
                print(f"[{command.short}]{command.name:<12} {_expl}")
                print((" " * 16) + f"args: {_args}")
                print()

    def feed(self, command):
        command = command.strip(' ')
        if not command:
            return

        comm, *args = command.split()

        if not comm in self._commands:
            print(f"Command [{comm}] not found.")
            self.help()
        else:
            callback = self._commands[comm].callback
            try:
                callback(*args)
            except Exception as e:
                print(*e.args)
        print()

    def start(self):
        print(
            f"Welcome to poker game {self.account_id}. Print [h]help for options.")
        logging.info(f"Start game with: {self.account_id}")

        while True:
            self.ui.display()
            command = input()
            self.feed(command)

'''
'''--- client/poker.py ---
def view_function(function):
    def real_function(self):
        return self.near.view(function.__name__, dict(room_id=self.room_id))
    return real_function

class Poker:
    def __init__(self, near, room_id):
        self.near = near
        self.room_id = int(room_id)

    @view_function
    def state(self):
        pass

    @view_function
    def deck_state(self):
        pass

    @view_function
    def poker_state(self):
        pass

    @view_function
    def get_partial_shuffle(self):
        pass

    @view_function
    def get_turn(self):
        pass

    def submit_partial_shuffle(self, partial_shuffle):
        self.near.change("submit_shuffled", dict(
            room_id=self.room_id, new_cards=partial_shuffle))

    def submit_reveal_part(self, progress):
        self.near.change("submit_reveal_part", dict(
            room_id=self.room_id, card=progress))

    def finish_reveal(self):
        self.near.change("finish_reveal", dict(room_id=self.room_id))

'''
'''--- client/requirements.txt ---
git+https://github.com/mfornet/relaxedjson.py

'''
'''--- client/ui.py ---
import io
from lib import logging
from utils import get

SUITES = '♥♠♦♣'
VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']

def card(num):
    num = int(num)
    return VALUES[num % 13] + SUITES[num // 13]

def build_table(table_i):
    cols = [0] * len(table_i[0])
    for row in table_i:
        for ix, value in enumerate(row):
            cols[ix] = max(cols[ix], len(str(value)))

    for i in range(len(cols)):
        cols[i] += 2

    table = io.StringIO()

    first = True
    for row in table_i:
        if first:
            first = False
        else:
            first_row = True
            for col in cols:
                if first_row:
                    first_row = False
                else:
                    print("+", end="", file=table)
                print("-" * col, end="", file=table)
            print(file=table)

        first_row = True
        for ix, value in enumerate(row):
            if first_row:
                first_row = False
            else:
                print("|", end="", file=table)
            print(str(value).center(cols[ix]), end="", file=table)
        print(file=table)

    return table.getvalue()

def parse_id(value):
    if isinstance(value, str):
        return value
    elif isinstance(value, dict):
        return list(value.keys())[0]
    else:
        raise ValueError(f"Type not hadled {type(value)}({value})")

class PokerUI:
    def __init__(self):
        self.room_id = None
        self.account_id = None
        self.cards = []
        self.state = None
        self.deck_state = None
        self.poker_state = None
        self.turn = None
        self._last_status = None

    def set_account_id(self, account_id):
        self.account_id = account_id

    def enter(self, room_id):
        self.room_id = room_id

    def update_table(self):
        table = [
            ["Name", "Cards", "Total", "Staked", "Turn"],
        ]

    def update_state(self, room_id, state, deck_state, poker_state, turn):
        if room_id != self.room_id:
            return

        self.state = state
        self.deck_state = deck_state
        self.poker_state = poker_state
        self.turn = get(turn, 'Ok')
        logging.debug(repr(self.state))
        logging.debug(repr(self.deck_state))
        logging.debug(repr(self.poker_state))
        logging.debug(repr(self.turn))
        self.display(False)

    def update_card(self, room_id, card):
        if room_id != self.room_id:
            return

        self.cards.append(card)
        self.display()

    def get_action(self):
        g_state = get(self.state, 'Ok')

        if g_state == 'PokerAction':
            return parse_id(get(self.poker_state, 'Ok', 'status'))

        elif g_state == 'DeckAction':
            return parse_id(get(self.deck_state, 'Ok', 'status'))

        else:
            return g_state

    def get_revealed_cards(self):
        res = get(self.deck_state, 'Ok', 'revealed')

        if res is None:
            return []

        total_players = len(get(self.deck_state, 'Ok', 'players'))

        cards = []
        for card in res[2 * total_players:]:
            if card is not None:
                cards.append(card)
        return cards

    def display(self, force=True):
        status = io.StringIO()
        print(file=status)

        if self.state is not None:
            players = get(self.deck_state, 'Ok', 'players')
            tokens = get(self.poker_state, 'Ok', 'tokens')
            staked = get(self.poker_state, 'Ok', 'staked')
            folded = get(self.poker_state, 'Ok', 'folded')

            action = self.get_action()
            turn = self.turn

            if len(players) > 0:
                tables = [
                    ["Name", "Cards", "Total", "Staked", "On Game", "Turn"],
                ]

                # TODO: Show revealed cards after showdown.
                if len(self.cards) > 0:
                    my_cards = ' '.join(map(card, self.cards))
                else:
                    my_cards = ''

                turn_by_player = False

                for ix, player in enumerate(players):
                    if player == self.account_id:
                        player += "(*)"
                        cards = my_cards
                    else:
                        cards = ""

                    row = [player, cards, tokens[ix],
                           staked[ix], not folded[ix], ""]

                    if turn == ix:
                        turn_by_player = True
                        row[5] = action

                    tables.append(row)

                print(build_table(tables), file=status)

                revealed_cards = self.get_revealed_cards()
                if len(revealed_cards) > 0:
                    print("Table:", ' '.join(
                        map(card, revealed_cards)), file=status)
                    print(file=status)

                if not turn_by_player:
                    print("Status:", action, file=status)
                    print(file=status)

        print(f"[{self.account_id}]>>> ", end="", file=status)

        cur_status = status.getvalue()
        if cur_status != self._last_status or force:
            print(cur_status, end="")
        self._last_status = cur_status

if __name__ == '__main__':
    print('♥')

'''
'''--- client/utils.py ---
import json
import os

BASE = os.path.expanduser("~/.poker_near")

def dump(name, data):
    os.makedirs(BASE, exist_ok=True)
    with open(os.path.join(BASE, name + '.json'), 'w') as f:
        json.dump(data, f, indent=2)

def load(name):
    os.makedirs(BASE, exist_ok=True)
    target = os.path.join(BASE, name + '.json')

    if not os.path.exists(target):
        return None

    with open(target) as f:
        return json.load(f)

def get(dic, *keys):
    for key in keys:
        try:
            if not key in dic:
                return None
        except TypeError:
            return None
        dic = dic[key]
    return dic

'''
'''--- client/watcher.py ---
import logging
import threading
import time
import os
import hashlib

from cryptography import encrypt_and_shuffle, partial_decrypt, generate_secret_key
from poker import Poker
from utils import load, dump, get

class PokerRoomWatcher(threading.Thread):
    def __init__(self, near, room_id, ui):
        self.ui = ui
        self.room_id = room_id
        self.near = near
        self.poker = Poker(near, room_id)
        self.player_id = None
        self.cards = []
        self.load()
        super().__init__()

    def load(self):
        # Load cards
        self.cards = load(self.filename("cards")) or []
        self.ui.cards = self.cards[:]

        # Load secret key
        self.secret_key = load(self.filename(
            "secret_key")) or generate_secret_key()
        self.secret_key = int(self.secret_key)
        dump(self.filename("secret_key"), self.secret_key)

    def find_player_id(self):
        players = get(self.poker.deck_state(), 'Ok', 'players')

        if not self.near.account_id in players:
            logging.debug(
                f"{self.near.account_id} is not in game {self.room_id}. Found: {players}")
            return True
        else:
            self.player_id = players.index(
                self.near.account_id)
            logging.debug(
                f"{self.near.account_id} playing in game {self.room_id}. Found {players}")
            return False

    def update_state(self):
        self._state = self.poker.state()
        self._deck_state = self.poker.deck_state()
        self._poker_state = self.poker.poker_state()
        self._turn = self.poker.get_turn()
        self.ui.update_state(self.room_id, self._state,
                             self._deck_state, self._poker_state, self._turn)

    def is_deck_action(self):
        return get(self._state, 'Ok') == 'DeckAction'

    def check_deck_shuffling(self):
        if not self.is_deck_action():
            return

        index = get(self._deck_state, 'Ok', 'status', 'Shuffling')

        if index is None:
            return
        index = int(index)

        if index != self.player_id:
            return

        partial_shuffle = self.poker.get_partial_shuffle()["Ok"]
        delta = 2 if self.player_id == 0 else 0
        partial_shuffle = [int(value) + delta for value in partial_shuffle]
        partial_shuffle = encrypt_and_shuffle(partial_shuffle, self.secret_key)
        partial_shuffle = [str(value) for value in partial_shuffle]
        self.poker.submit_partial_shuffle(partial_shuffle)

    def filename(self, mode):
        node_env = os.environ.get("NODE_ENV", "")
        chain_enc = f"{self.near.node_url}-{self.near.contract}-{node_env}"
        suffix = hashlib.md5(chain_enc.encode()).hexdigest()[:8]
        return f"{self.near.account_id}-{self.room_id}-{mode}-{suffix}"

    def on_receive_card(self, card):
        if card in self.cards:
            return

        self.cards.append(card)
        dump(self.filename("cards"), self.cards)
        self.ui.update_card(self.room_id, card)

    def check_revealing(self):
        if not self.is_deck_action():
            return

        index = get(self._deck_state, 'Ok', 'status', 'Revealing', 'turn')

        if index is None:
            return

        index = int(index)

        if index != self.player_id:
            return

        progress = int(get(self._deck_state, 'Ok',
                           'status', 'Revealing', 'progress'))

        progress = str(partial_decrypt(progress, self.secret_key))

        if get(self._deck_state, 'Ok', 'status', 'Revealing', 'receiver') == self.player_id:
            self.on_receive_card(int(progress) - 2)
            self.poker.finish_reveal()
        else:
            self.poker.submit_reveal_part(progress)

    def step(self):
        if self.player_id is None:
            if not self.find_player_id():
                return

        self.update_state()
        self.check_deck_shuffling()
        self.check_revealing()

    def run(self):
        time_to_sleep = 1.

        while True:
            self.step()
            time.sleep(time_to_sleep)

WATCHING = set()

def watch(near, room_id, ui):
    if room_id in WATCHING:
        logging.debug(f"Already watching room: {room_id}")
        return

    WATCHING.add(room_id)
    PokerRoomWatcher(near, room_id, ui).start()
    logging.debug(f"Start watching room: {room_id}")

'''
'''--- poker/Cargo.toml ---
[package]
name = "poker"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = { git = "https://github.com/nearprotocol/json", rev = "1f5779f3b0bd3d2a4b0b975abc46f3d3fe873331", features = ["no_floats"] }
near-bindgen = { version = "0.6.0" }
borsh = "0.6.1"
wee_alloc = "0.4.5"

[profile.release]
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- poker/src/deck.rs ---
use crate::types::AccountId;
use crate::types::CryptoHash;
use crate::types::{CardId, PlayerId};
use borsh::{BorshDeserialize, BorshSerialize};
use near_bindgen::env;
use serde::Serialize;

#[derive(Serialize, BorshDeserialize, BorshSerialize, Debug)]
pub enum DeckError {
    DeckInProgress,
    DeckNotInShufflingState,
    NotPossibleToStartReveal,
    PlayerAlreadyInGame,
    PlayerNotInGame,
    InvalidTurn,
    InvalidPlayerId,
    InvalidCardId,
    /// Tried to fetch revealed card, but it is not revealed yet.
    CardNotRevealed,
    /// Tried to reveal part but not in revealing state
    NotRevealing,
    /// Tried to reveal part but it's not player turn to reveal
    PlayerCantReveal,
}

#[derive(PartialEq, Eq, Clone, BorshDeserialize, BorshSerialize, Serialize, Debug)]
pub enum DeckStatus {
    Initiating,
    Shuffling(PlayerId),
    Running,
    /// Revealing progress is ongoing
    Revealing {
        // Card to be revealed
        card_id: CardId,
        // Player to whom this card will be revealed.
        // None if it is going to be revealed to all players.
        receiver: Option<PlayerId>,
        // Player that should submit its part in this turn.
        // It can be the receiver if it should fetch its part.
        turn: PlayerId,
        // Partially decrypted card.
        progress: CryptoHash,
    },
    Closed,
}

impl Default for DeckStatus {
    fn default() -> Self {
        Self::Initiating
    }
}

#[derive(BorshDeserialize, BorshSerialize, Default, Serialize, Clone)]
pub struct Deck {
    status: DeckStatus,
    players: Vec<AccountId>,
    cards: Vec<CryptoHash>,
    pub revealed: Vec<Option<CryptoHash>>,
}

impl Deck {
    // TODO: Add password.
    // TODO: Add minimum/maximum amount of players.
    pub fn new(num_cards: u64) -> Self {
        Self {
            status: DeckStatus::Initiating,
            players: vec![],
            cards: (0..num_cards).map(|num| num.to_string()).collect(),
            revealed: vec![None; num_cards as usize],
        }
    }

    pub fn get_players(&self) -> Vec<AccountId> {
        self.players.clone()
    }

    pub fn num_players(&self) -> u64 {
        self.players.len() as u64
    }

    pub fn get_player_id(&self) -> Result<PlayerId, DeckError> {
        let account_id = env::signer_account_id();
        self.players
            .iter()
            .position(|player_account_id| player_account_id == &account_id)
            .map(|pos| pos as PlayerId)
            .ok_or(DeckError::PlayerNotInGame)
    }

    pub fn enter(&mut self) -> Result<(), DeckError> {
        if self.status == DeckStatus::Initiating {
            let account_id = env::signer_account_id();
            if self.players.contains(&account_id) {
                Err(DeckError::PlayerAlreadyInGame)
            } else {
                self.players.push(account_id);
                Ok(())
            }
        } else {
            Err(DeckError::DeckInProgress)
        }
    }

    pub fn start(&mut self) -> Result<(), DeckError> {
        match self.status {
            DeckStatus::Initiating | DeckStatus::Closed => {
                self.status = DeckStatus::Shuffling(0);
                let num_cards = self.cards.len();
                self.cards = (0..num_cards).map(|num| num.to_string()).collect();
                self.revealed = vec![None; num_cards];
                Ok(())
            }
            _ => Err(DeckError::DeckInProgress),
        }
    }

    pub fn get_status(&self) -> DeckStatus {
        self.status.clone()
    }

    pub fn get_turn(&self) -> Option<PlayerId> {
        match self.status {
            DeckStatus::Closed | DeckStatus::Running | DeckStatus::Initiating => None,
            DeckStatus::Shuffling(player_id) => Some(player_id),
            DeckStatus::Revealing { turn, .. } => Some(turn),
        }
    }

    pub fn get_revealed_card(&self, card_id: CardId) -> Result<CryptoHash, DeckError> {
        self.revealed
            .get(card_id as usize)
            .ok_or(DeckError::InvalidCardId)?
            .clone()
            .ok_or(DeckError::CardNotRevealed)
    }

    pub fn get_partial_shuffle(&self) -> Result<Vec<CryptoHash>, DeckError> {
        if let DeckStatus::Shuffling(_) = self.status {
            Ok(self.cards.clone())
        } else {
            Err(DeckError::DeckNotInShufflingState)
        }
    }

    pub fn close(&mut self) {
        self.status = DeckStatus::Closed;
    }

    // TODO: Add zk-proof for correct computation of the cards (given previous set of cards and public key)
    pub fn submit_shuffled(&mut self, new_cards: Vec<CryptoHash>) -> Result<(), DeckError> {
        if let DeckStatus::Shuffling(current_player_id) = self.status {
            let player_id = self.get_player_id()?;
            if player_id != current_player_id {
                Err(DeckError::InvalidTurn)
            } else {
                self.cards = new_cards;

                if current_player_id + 1 < self.num_players() {
                    self.status = DeckStatus::Shuffling(current_player_id + 1);
                } else {
                    self.status = DeckStatus::Running;
                }

                Ok(())
            }
        } else {
            Err(DeckError::DeckNotInShufflingState)
        }
    }

    /// Reveal card at position `card_id` to player at position `player_id`.
    /// If `player_id` is None, reveal the card to all
    pub fn reveal_card(
        &mut self,
        card_id: u64,
        receiver_player_id: Option<PlayerId>,
    ) -> Result<(), DeckError> {
        if self.status == DeckStatus::Running {
            if card_id as usize >= self.cards.len() {
                return Err(DeckError::InvalidCardId);
            }

            if let Some(receiver_player_id) = receiver_player_id {
                let num_players = self.num_players();

                if receiver_player_id >= num_players {
                    return Err(DeckError::InvalidPlayerId);
                }

                let turn = if num_players == 1 {
                    0
                } else if receiver_player_id == 0 {
                    1
                } else {
                    0
                };

                self.status = DeckStatus::Revealing {
                    card_id,
                    receiver: Some(receiver_player_id),
                    turn,
                    progress: self.cards[card_id as usize].clone(),
                };

                Ok(())
            } else {
                self.status = DeckStatus::Revealing {
                    card_id,
                    receiver: None,
                    turn: 0,
                    progress: self.cards[card_id as usize].clone(),
                };
                Ok(())
            }
        } else {
            Err(DeckError::NotPossibleToStartReveal)
        }
    }

    // TODO: Add zk-proof using previous part and public key
    pub fn submit_reveal_part(&mut self, card: CryptoHash) -> Result<(), DeckError> {
        if let DeckStatus::Revealing {
            card_id,
            receiver,
            turn,
            progress: _,
        } = self.status.clone()
        {
            let player_id = self.get_player_id()?;

            if player_id != turn || receiver.map_or(false, |receiver| player_id == receiver) {
                return Err(DeckError::PlayerCantReveal);
            }

            let mut next_turn = turn + 1;

            if let Some(receiver) = receiver {
                if receiver == next_turn {
                    next_turn += 1;
                }
            }

            if next_turn == self.num_players() {
                if receiver.is_some() {
                    self.status = DeckStatus::Revealing {
                        card_id,
                        receiver,
                        turn: receiver.unwrap(),
                        progress: card,
                    }
                } else {
                    self.revealed[card_id as usize] = Some(card);
                    self.status = DeckStatus::Running;
                }
            } else {
                self.status = DeckStatus::Revealing {
                    card_id,
                    receiver,
                    turn: next_turn,
                    progress: card,
                };
            }

            Ok(())
        } else {
            Err(DeckError::NotRevealing)
        }
    }

    /// Receiver of the revealing card should call this function after downloading
    /// partially encrypted card to finish the revealing process.
    pub fn finish_reveal(&mut self) -> Result<(), DeckError> {
        if let DeckStatus::Revealing {
            card_id: _,
            receiver,
            turn,
            progress: _,
        } = self.status.clone()
        {
            let player_id = self.get_player_id()?;

            if let Some(receiver) = receiver {
                if receiver == player_id && turn == player_id {
                    self.status = DeckStatus::Running;
                    return Ok(());
                }
            }
            Err(DeckError::PlayerCantReveal)
        } else {
            Err(DeckError::NotRevealing)
        }
    }
}

'''
'''--- poker/src/game.rs ---
use crate::deck::{Deck, DeckError, DeckStatus};
use crate::poker::{ActionResponse, BetAction, Poker, PokerError, PokerStatus};
use crate::types::{CryptoHash, PlayerId, RoomId};
use borsh::{BorshDeserialize, BorshSerialize};
use serde::Serialize;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug)]
pub enum GameError {
    RoomIdNotFound,
    OngoingRound,
    DeckError(DeckError),
    PokerError(PokerError),
}

impl From<DeckError> for GameError {
    fn from(deck_error: DeckError) -> Self {
        GameError::DeckError(deck_error)
    }
}

impl From<PokerError> for GameError {
    fn from(poker_error: PokerError) -> Self {
        GameError::PokerError(poker_error)
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Eq, PartialEq, Clone)]
pub enum GameStatus {
    // Start haven't been called. Players are able to enter the game.
    Initiating,
    // Round already finished. Call start to start next round.
    Idle,
    // Need action by some player in deck.
    DeckAction,
    // Need action by some player in poker.
    PokerAction,
    // Game have been closed
    Closed,
}

impl GameStatus {
    pub fn is_active(&self) -> bool {
        *self != GameStatus::Closed
    }

    pub fn is_initiating(&self) -> bool {
        *self == GameStatus::Initiating
    }
}

// TODO: Use NEAR Tokens
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
pub struct Game {
    pub name: String,
    pub id: RoomId,
    pub status: GameStatus,
    deck: Deck,
    poker: Poker,
}

impl Game {
    pub fn new(name: String, id: RoomId) -> Self {
        Self {
            name,
            id,
            status: GameStatus::Initiating,
            deck: Deck::new(52),
            poker: Poker::new(),
        }
    }

    pub fn enter(&mut self) -> Result<(), GameError> {
        self.deck.enter().map_err(Into::<GameError>::into)?;
        // TODO: Put min tokens / max tokens caps
        self.poker.new_player(1000);
        Ok(())
    }

    // TODO: An idle game should be started by all players.
    pub fn start(&mut self) -> Result<(), GameError> {
        match self.status {
            GameStatus::Initiating | GameStatus::Idle => {
                self.deck.start().map_err(Into::<GameError>::into)?;
                self.status = GameStatus::DeckAction;
                Ok(())
            }
            _ => Err(GameError::OngoingRound),
        }
    }

    pub fn close(&mut self) -> Result<(), GameError> {
        match self.status {
            GameStatus::Initiating | GameStatus::Idle => {
                self.deck.close();
                self.status = GameStatus::Closed;
                Ok(())
            }
            _ => Err(GameError::OngoingRound),
        }
    }

    fn check_status(&mut self) {
        self.status = match self.poker.status {
            PokerStatus::Idle => {
                self.deck.close();
                GameStatus::Idle
            }
            PokerStatus::Dealing {
                player_id, card_id, ..
            } => {
                self.deck.reveal_card(card_id, Some(player_id)).expect(
                    format!(
                        "Impossible to reveal card {} for player {}",
                        card_id, player_id
                    )
                    .as_ref(),
                );

                GameStatus::DeckAction
            }
            PokerStatus::Betting { .. } => GameStatus::PokerAction,
            PokerStatus::Revealing { card_id, .. } | PokerStatus::Showdown { card_id, .. } => {
                self.deck.reveal_card(card_id, None).expect(
                    format!("Impossible to reveal card {} for the table.", card_id).as_ref(),
                );
                GameStatus::DeckAction
            }
            PokerStatus::WaitingRevealedCards => {
                self.poker.submit_revealed_cards(self.deck.revealed.clone());
                self.deck.close();
                GameStatus::Idle
            }
        };
    }

    /// Deck finalized one step.
    fn check_next_status(&mut self) {
        let deck_status = self.deck.get_status();

        if deck_status != DeckStatus::Running {
            self.status = GameStatus::DeckAction;
            return;
        }

        self.poker.next();
        self.check_status();
    }

    pub fn deck_state(&self) -> Deck {
        self.deck.clone()
    }

    pub fn poker_state(&self) -> Poker {
        self.poker.clone()
    }

    pub fn state(&self) -> GameStatus {
        self.status.clone()
    }

    pub fn player_id(&self) -> Result<PlayerId, GameError> {
        self.deck.get_player_id().map_err(Into::into)
    }

    /// Current player that should make an action.
    pub fn get_turn(&self) -> Option<PlayerId> {
        match self.status {
            GameStatus::Closed | GameStatus::Idle | GameStatus::Initiating => None,
            GameStatus::DeckAction => self.deck.get_turn(),
            GameStatus::PokerAction => self.poker.get_turn(),
        }
    }

    // TODO: Mechanism to slash participants that are stalling the game
    //       Discussion: Using some number of epochs, elapsed without inactivity.
}

// Implement Deck public interface for Game
impl Game {
    pub fn get_partial_shuffle(&self) -> Result<Vec<CryptoHash>, GameError> {
        self.deck.get_partial_shuffle().map_err(Into::into)
    }

    pub fn submit_shuffled(&mut self, new_cards: Vec<CryptoHash>) -> Result<(), GameError> {
        self.deck
            .submit_shuffled(new_cards)
            .map_err(Into::<GameError>::into)?;

        self.check_next_status();
        Ok(())
    }

    pub fn finish_reveal(&mut self) -> Result<(), GameError> {
        self.deck.finish_reveal().map_err(Into::<GameError>::into)?;

        self.check_next_status();
        Ok(())
    }

    pub fn submit_reveal_part(&mut self, card: CryptoHash) -> Result<(), GameError> {
        self.deck
            .submit_reveal_part(card)
            .map_err(Into::<GameError>::into)?;

        self.check_next_status();
        Ok(())
    }
}

// TODO: On Initiating/Idle games allow leaving and claiming back all winned tokens.
// Implement Poker public interface for Game
impl Game {
    pub fn submit_bet_action(&mut self, bet: BetAction) -> Result<(), GameError> {
        self.poker
            .submit_bet_action(ActionResponse {
                player_id: self.player_id()?,
                action: bet,
            })
            .map_err(Into::<GameError>::into)?;

        self.check_status();
        Ok(())
    }
}

'''
'''--- poker/src/lib.rs ---
mod deck;
mod game;
pub mod lobby;
mod poker;
mod types;

'''
'''--- poker/src/lobby.rs ---
use crate::deck::Deck;
use crate::game::{Game, GameError, GameStatus};
use crate::poker::BetAction;
use crate::poker::Poker;
use crate::types::PlayerId;
use crate::types::{CryptoHash, RoomId};
use borsh::{BorshDeserialize, BorshSerialize};
use near_bindgen::near_bindgen;
use serde::Serialize;
use std::collections::HashMap;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[derive(BorshDeserialize, BorshSerialize, Serialize)]
pub struct RoomInfo {
    name: String,
    id: RoomId,
    status: GameStatus,
}

impl From<&Game> for RoomInfo {
    fn from(poker: &Game) -> Self {
        Self {
            name: poker.name.clone(),
            id: poker.id,
            status: poker.status.clone(),
        }
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default, Serialize)]
pub struct Lobby {
    last_room: RoomId,
    rooms: HashMap<RoomId, Game>,
}

#[near_bindgen]
impl Lobby {
    pub fn new() -> Self {
        Self {
            last_room: 0,
            rooms: HashMap::new(),
        }
    }

    pub fn new_room(&mut self, name: String) -> RoomId {
        let room_id = self.last_room;
        self.last_room += 1;
        let poker = Game::new(name, room_id);
        self.rooms.insert(room_id, poker);
        room_id
    }

    pub fn all_rooms(&self) -> Vec<RoomInfo> {
        self.rooms.values().map(Into::into).collect()
    }

    pub fn all_active_rooms(&self) -> Vec<RoomInfo> {
        self.rooms
            .values()
            .filter_map(|val| {
                if val.status.is_active() {
                    Some(val)
                } else {
                    None
                }
            })
            .map(Into::into)
            .collect()
    }

    pub fn all_initiating_rooms(&self) -> Vec<RoomInfo> {
        self.rooms
            .values()
            .filter_map(|val| {
                if val.status.is_initiating() {
                    Some(val)
                } else {
                    None
                }
            })
            .map(Into::into)
            .collect()
    }

    fn room_ref(&self, room_id: RoomId) -> Result<&Game, GameError> {
        self.rooms.get(&room_id).ok_or(GameError::RoomIdNotFound)
    }

    fn room_mut(&mut self, room_id: RoomId) -> Result<&mut Game, GameError> {
        self.rooms
            .get_mut(&room_id)
            .ok_or(GameError::RoomIdNotFound)
    }
}

/// Game interface for Lobby
#[near_bindgen]
impl Lobby {
    pub fn enter(&mut self, room_id: RoomId) -> Result<(), GameError> {
        self.room_mut(room_id)?.enter()
    }

    pub fn start(&mut self, room_id: RoomId) -> Result<(), GameError> {
        self.room_mut(room_id)?.start()
    }

    pub fn close(&mut self, room_id: RoomId) -> Result<(), GameError> {
        self.room_mut(room_id)?.close()
    }

    pub fn deck_state(&self, room_id: RoomId) -> Result<Deck, GameError> {
        Ok(self.room_ref(room_id)?.deck_state())
    }

    pub fn poker_state(&self, room_id: RoomId) -> Result<Poker, GameError> {
        Ok(self.room_ref(room_id)?.poker_state())
    }

    pub fn state(&self, room_id: RoomId) -> Result<GameStatus, GameError> {
        Ok(self.room_ref(room_id)?.state())
    }

    pub fn get_turn(&self, room_id: RoomId) -> Result<Option<PlayerId>, GameError> {
        Ok(self.room_ref(room_id)?.get_turn())
    }
}

/// Deck interface for Lobby
#[near_bindgen]
impl Lobby {
    pub fn get_partial_shuffle(&self, room_id: RoomId) -> Result<Vec<CryptoHash>, GameError> {
        self.room_ref(room_id)?
            .get_partial_shuffle()
            .map_err(Into::into)
    }

    pub fn submit_shuffled(
        &mut self,
        room_id: RoomId,
        new_cards: Vec<CryptoHash>,
    ) -> Result<(), GameError> {
        self.room_mut(room_id)?
            .submit_shuffled(new_cards)
            .map_err(Into::into)
    }

    pub fn finish_reveal(&mut self, room_id: RoomId) -> Result<(), GameError> {
        self.room_mut(room_id)?.finish_reveal().map_err(Into::into)
    }

    pub fn submit_reveal_part(
        &mut self,
        room_id: RoomId,
        card: CryptoHash,
    ) -> Result<(), GameError> {
        self.room_mut(room_id)?
            .submit_reveal_part(card)
            .map_err(Into::into)
    }
}

/// Poker interface for Lobby
#[near_bindgen]
impl Lobby {
    pub fn submit_bet_action(&mut self, room_id: RoomId, bet: BetAction) -> Result<(), GameError> {
        self.room_mut(room_id)?.submit_bet_action(bet)
    }
}

'''
'''--- poker/src/poker.rs ---
use crate::types::CardId;
use crate::types::CryptoHash;
use crate::types::PlayerId;
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Clone, PartialEq, Eq)]
pub enum Stage {
    Flop,
    Turn,
    River,
    Showdown,
}

impl Stage {
    fn next(&self) -> Self {
        match self {
            Stage::Flop => Stage::Turn,
            Stage::Turn => Stage::River,
            Stage::River => Stage::Showdown,
            Stage::Showdown => panic!("No next stage after showdown"),
        }
    }

    fn cards_to_reveal(&self) -> u8 {
        match self {
            Stage::Flop => 3,
            Stage::Turn => 1,
            Stage::River => 1,
            Stage::Showdown => panic!("No cards to reveal at showdown"),
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Clone, Eq, PartialEq)]
pub enum PokerStatus {
    Idle,
    Dealing {
        player_id: PlayerId,
        card_id: CardId,
        first_card: bool,
    },
    Betting {
        // Waiting for player `target` to make an action.
        target: PlayerId,
        // Last player to raise. If raised is false this is big blind.
        until: PlayerId,
        // If some player have raised in this round.
        raised: bool,
        // Current max stake that must be called or raised
        max_stake: u64,
        // Next stage to play.
        next_stage: Stage,
    },
    Revealing {
        stage: Stage,
        card_id: CardId,
        missing_to_reveal: u8,
    },
    Showdown {
        player_id: PlayerId,
        card_id: CardId,
        first_card: bool,
    },
    WaitingRevealedCards,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Debug)]
pub enum PokerError {
    InvalidPlayerId,

    TooLowStake,
    NotEnoughStake,

    NotBettingRound,
    NotBettingTurn,
}

#[derive(Serialize, Deserialize)]
pub enum BetAction {
    Fold,
    Stake(u64),
}

pub struct ActionResponse {
    pub player_id: PlayerId,
    pub action: BetAction,
}

// TODO: Remove automatically from the game players with 0 tokens.
//       Mainly regarding card signatures.

/// Raw poker implementation.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Clone)]
pub struct Poker {
    /// Number of tokens each player has available.
    tokens: Vec<u64>,
    /// Currently staked tokens.
    staked: Vec<u64>,
    /// Players that have already folded its cards in this turn.
    folded: Vec<bool>,
    /// Current status.
    pub status: PokerStatus,
    /// Number of token used for the big blind. This value will double on each game.
    blind_token: u64,
    /// Player which is the big blind on next round.
    big_blind: PlayerId,
    /// Card on the top of the stack.
    first_unrevealed_card: CardId,
}

impl Poker {
    pub fn new() -> Self {
        Self {
            tokens: vec![],
            staked: vec![],
            folded: vec![],
            status: PokerStatus::Idle,
            blind_token: 6,
            big_blind: 0,
            first_unrevealed_card: 0,
        }
    }

    pub fn new_player(&mut self, tokens: u64) {
        self.tokens.push(tokens);
        self.staked.push(0);
        self.folded.push(false);
    }

    fn prev_player(&self, player_id: PlayerId) -> PlayerId {
        if player_id == 0 {
            self.num_players() - 1
        } else {
            player_id - 1
        }
    }

    fn next_player(&self, player_id: PlayerId) -> PlayerId {
        if player_id + 1 == self.num_players() {
            0
        } else {
            player_id + 1
        }
    }

    fn next_on_game(&self, mut player_id: PlayerId) -> PlayerId {
        for _ in 0..self.num_players() {
            if !self.folded[player_id as usize] {
                return player_id;
            } else {
                player_id = self.next_player(player_id);
            }
        }
        panic!("All players folded.");
    }

    /// Number of players who have already folded
    fn total_folded(&self) -> u64 {
        self.folded.iter().filter(|&folded| *folded).count() as u64
    }

    /// Increase the stake for player_id to stake. If stake is less than current staked
    /// by this player, it will return Error without changing anything.
    /// If stake is bigger than total tokens, it will stake all tokens.
    fn try_stake(&mut self, player_id: PlayerId, stake: u64) -> Result<(), PokerError> {
        let total = self
            .tokens
            .get(player_id as usize)
            .ok_or(PokerError::InvalidPlayerId)?;

        if stake < self.staked[player_id as usize] {
            return Err(PokerError::TooLowStake);
        }

        self.staked[player_id as usize] = std::cmp::min(stake, *total);
        Ok(())
    }

    pub fn get_status(&self) -> PokerStatus {
        self.status.clone()
    }

    pub fn get_turn(&self) -> Option<PlayerId> {
        match self.status {
            PokerStatus::Betting { target, .. } => Some(target),
            _ => None,
        }
    }

    /// Get topmost card not used yet. Mark this card as used.
    fn get_card(&mut self) -> CardId {
        self.first_unrevealed_card += 1;
        self.first_unrevealed_card - 1
    }

    fn card_id_from_player(&self, player_id: PlayerId, first_card: bool) -> CardId {
        2 * player_id + (!first_card as u64)
    }

    pub fn next(&mut self) {
        match self.status.clone() {
            PokerStatus::Idle => {
                // Make small blind and big blinds bet
                self.try_stake(self.big_blind, self.blind_token).unwrap();
                self.try_stake(self.prev_player(self.big_blind), self.blind_token / 2)
                    .unwrap();

                self.status = PokerStatus::Dealing {
                    player_id: 0,
                    card_id: self.get_card(),
                    first_card: true,
                };
            }
            PokerStatus::Dealing {
                player_id,
                first_card,
                ..
            } => {
                if first_card {
                    self.status = PokerStatus::Dealing {
                        player_id,
                        card_id: self.get_card(),
                        first_card: false,
                    };
                } else {
                    if player_id + 1 == self.num_players() {
                        // All cards where already dealt. Start first round of betting.
                        let target = self.next_player(self.big_blind);
                        self.status = PokerStatus::Betting {
                            target,
                            until: self.big_blind,
                            raised: false,
                            max_stake: self.blind_token,
                            next_stage: Stage::Flop,
                        };
                    } else {
                        self.status = PokerStatus::Dealing {
                            player_id: player_id + 1,
                            card_id: self.get_card(),
                            first_card: true,
                        };
                    }
                }
            }
            PokerStatus::Revealing {
                stage,
                missing_to_reveal,
                ..
            } => {
                if missing_to_reveal == 0 {
                    // Find next player who have not folded after the big blind.
                    let target = self.next_on_game(self.next_player(self.big_blind));
                    self.status = PokerStatus::Betting {
                        target,
                        until: self.big_blind,
                        raised: false,
                        max_stake: self.blind_token,
                        next_stage: stage.next(),
                    };
                } else {
                    self.status = PokerStatus::Revealing {
                        stage,
                        card_id: self.get_card(),
                        missing_to_reveal: missing_to_reveal - 1,
                    };
                }
            }
            // TODO: Fix issue with infinite showdown loop
            PokerStatus::Showdown {
                player_id,
                first_card,
                ..
            } => {
                if first_card {
                    self.status = PokerStatus::Showdown {
                        player_id,
                        card_id: self.card_id_from_player(player_id, false),
                        first_card: false,
                    };
                } else {
                    let next_player = self.next_on_game(player_id);

                    if next_player < player_id {
                        // All cards were revealed
                        self.status = PokerStatus::WaitingRevealedCards;
                    } else {
                        self.status = PokerStatus::Showdown {
                            player_id: next_player,
                            card_id: self.card_id_from_player(player_id, true),
                            first_card: true,
                        };
                    }
                }
            }
            PokerStatus::Betting { .. } => panic!("Called next on betting state."),
            PokerStatus::WaitingRevealedCards => {
                panic!("Called next while waiting for revealed cards.")
            }
        }
    }

    /// Call when the round is over. Update the state of the game for the next round.
    fn finish(&mut self, _winners: Vec<PlayerId>) {
        self.status = PokerStatus::Idle;
        self.big_blind = self.next_player(self.big_blind);
        self.blind_token *= 2;
        self.first_unrevealed_card = 0;

        // TODO: Reassign stake to winners.
        // TODO: Reset state
    }

    fn start_stage(&mut self, stage: Stage) {
        if stage == Stage::Showdown {
            let player_id = self.next_on_game(0);
            self.status = PokerStatus::Showdown {
                player_id,
                card_id: self.card_id_from_player(player_id, true),
                first_card: true,
            };
        } else {
            let missing_to_reveal = stage.cards_to_reveal() - 1;
            self.status = PokerStatus::Revealing {
                stage,
                card_id: self.get_card(),
                missing_to_reveal,
            };
        }
    }

    pub fn submit_revealed_cards(&mut self, _cards: Vec<Option<CryptoHash>>) {
        if self.status != PokerStatus::WaitingRevealedCards {
            panic!("Not waiting revealed cards");
        }

        // TODO: Find winners from cards revealed.

        self.finish(vec![]);

        todo!();
    }

    /// Submit the bet option from the player that is its turn.
    pub fn submit_bet_action(&mut self, action: ActionResponse) -> Result<(), PokerError> {
        match self.status.clone() {
            PokerStatus::Betting {
                target,
                until,
                raised,
                max_stake,
                next_stage,
            } => {
                if target != action.player_id {
                    return Err(PokerError::NotBettingTurn);
                }

                match action.action {
                    BetAction::Fold => {
                        self.folded[action.player_id as usize] = true;
                        let next_player = self.next_on_game(action.player_id);

                        if self.total_folded() + 1 == self.num_players() {
                            // All players but one have folded. That is the winner.
                            self.finish(vec![next_player]);
                            Ok(())
                        } else {
                            self.status = PokerStatus::Betting {
                                target: next_player,
                                until,
                                raised,
                                max_stake,
                                next_stage,
                            };
                            Ok(())
                        }
                    }
                    BetAction::Stake(stake) => {
                        if stake < max_stake {
                            Err(PokerError::TooLowStake)
                        } else if stake > self.tokens[action.player_id as usize] {
                            Err(PokerError::NotEnoughStake)
                        } else {
                            self.staked[action.player_id as usize] = stake;

                            if stake > max_stake {
                                // Raise
                                // TODO: Put a lower bound on raising
                                let next_player =
                                    self.next_on_game(self.next_player(action.player_id));

                                self.status = PokerStatus::Betting {
                                    target: next_player,
                                    until: next_player,
                                    raised: true,
                                    max_stake: stake,
                                    next_stage,
                                };
                                Ok(())
                            } else {
                                // Call
                                if action.player_id == until {
                                    // Finish betting round. All players call big blind bet.
                                    self.start_stage(next_stage);
                                    Ok(())
                                } else {
                                    let next_player =
                                        self.next_on_game(self.next_player(action.player_id));
                                    if next_player != until || !raised {
                                        // Missing some players to place their bets.
                                        self.status = PokerStatus::Betting {
                                            target: next_player,
                                            until,
                                            raised,
                                            max_stake,
                                            next_stage,
                                        };
                                        Ok(())
                                    } else {
                                        // Finish betting round. All players call last raised stake.
                                        self.start_stage(next_stage);
                                        Ok(())
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => Err(PokerError::NotBettingRound),
        }
    }

    fn num_players(&self) -> u64 {
        self.tokens.len() as u64
    }
}

'''
'''--- poker/src/types.rs ---
pub type PlayerId = u64;
pub type CardId = u64;
pub type RoomId = u64;
pub type AccountId = String;
pub type CryptoHash = String;

'''
'''--- scripts/build.sh ---
#!/bin/bash
rustup target add wasm32-unknown-unknown
cargo build -p poker --target wasm32-unknown-unknown --release
mkdir -p res
cp target/wasm32-unknown-unknown/release/poker.wasm ./res/

'''
'''--- scripts/deploy.sh ---
#!/bin/bash
./scripts/build.sh
echo Deploying deck contract to poker
near deploy --wasmFile res/poker.wasm  --accountId poker --keyPath neardev/local/poker.json

'''
'''--- scripts/redeploy.sh ---
#!/bin/bash
echo Deleting poker contract
near delete poker node0
echo Creating poker account
near create_account poker --masterAccount node0 --initialBalance 1000 --keyPath ~/.near/localnet/node0/validator_key.json
./scripts/deploy.sh

'''