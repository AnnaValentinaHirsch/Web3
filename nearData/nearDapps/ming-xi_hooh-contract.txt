*GitHub Repository "ming-xi/hooh-contract"*

'''--- .idea/encodings.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="Encoding">
    <file url="PROJECT" charset="UTF-8" />
  </component>
</project>
'''
'''--- .idea/jsLibraryMappings.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="JavaScriptLibraryMappings">
    <file url="file://$PROJECT_DIR$/server" libraries="{Node.js Core}" />
  </component>
</project>
'''
'''--- .idea/misc.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CMakeSettings">
    <configurations>
      <configuration PROFILE_NAME="Debug" CONFIG_NAME="Debug" />
    </configurations>
  </component>
  <component name="MarkdownNavigator.ProfileManager" plain-text-search-scope="Project Files" />
  <component name="MarkdownProjectSettings" wasCopied="true">
    <PreviewSettings splitEditorLayout="SPLIT" splitEditorPreview="PREVIEW" useGrayscaleRendering="false" zoomFactor="1.25" maxImageWidth="0" showGitHubPageIfSynced="false" allowBrowsingInPreview="false" synchronizePreviewPosition="true" highlightPreviewType="NONE" highlightFadeOut="5" highlightOnTyping="true" synchronizeSourcePosition="true" verticallyAlignSourceAndPreviewSyncPosition="true" showSearchHighlightsInPreview="false" showSelectionInPreview="true" openRemoteLinks="true" replaceUnicodeEmoji="false" lastLayoutSetsDefault="false">
      <PanelProvider>
        <provider providerId="com.vladsch.idea.multimarkdown.editor.swing.html.panel" providerName="Default - Swing" />
      </PanelProvider>
    </PreviewSettings>
    <ParserSettings gitHubSyntaxChange="false" emojiShortcuts="1" emojiImages="0">
      <PegdownExtensions>
        <option name="ABBREVIATIONS" value="false" />
        <option name="ANCHORLINKS" value="true" />
        <option name="ASIDE" value="false" />
        <option name="ATXHEADERSPACE" value="true" />
        <option name="AUTOLINKS" value="true" />
        <option name="DEFINITIONS" value="false" />
        <option name="DEFINITION_BREAK_DOUBLE_BLANK_LINE" value="false" />
        <option name="FENCED_CODE_BLOCKS" value="true" />
        <option name="FOOTNOTES" value="false" />
        <option name="HARDWRAPS" value="false" />
        <option name="HTML_DEEP_PARSER" value="false" />
        <option name="INSERTED" value="false" />
        <option name="QUOTES" value="false" />
        <option name="RELAXEDHRULES" value="true" />
        <option name="SMARTS" value="false" />
        <option name="STRIKETHROUGH" value="true" />
        <option name="SUBSCRIPT" value="false" />
        <option name="SUPERSCRIPT" value="false" />
        <option name="SUPPRESS_HTML_BLOCKS" value="false" />
        <option name="SUPPRESS_INLINE_HTML" value="false" />
        <option name="TABLES" value="true" />
        <option name="TASKLISTITEMS" value="true" />
        <option name="TOC" value="false" />
        <option name="WIKILINKS" value="false" />
      </PegdownExtensions>
      <ParserOptions>
        <option name="ADMONITION_EXT" value="false" />
        <option name="ATTRIBUTES_EXT" value="false" />
        <option name="COMMONMARK_LISTS" value="true" />
        <option name="DUMMY" value="false" />
        <option name="EMOJI_SHORTCUTS" value="true" />
        <option name="ENUMERATED_REFERENCES_EXT" value="false" />
        <option name="FLEXMARK_FRONT_MATTER" value="false" />
        <option name="GFM_LOOSE_BLANK_LINE_AFTER_ITEM_PARA" value="false" />
        <option name="GFM_TABLE_RENDERING" value="true" />
        <option name="GITBOOK_URL_ENCODING" value="false" />
        <option name="GITHUB_LISTS" value="false" />
        <option name="GITHUB_WIKI_LINKS" value="false" />
        <option name="GITLAB_EXT" value="false" />
        <option name="GITLAB_MATH_EXT" value="false" />
        <option name="GITLAB_MERMAID_EXT" value="false" />
        <option name="HEADER_ID_NON_ASCII_TO_LOWERCASE" value="false" />
        <option name="HEADER_ID_NO_DUPED_DASHES" value="false" />
        <option name="JEKYLL_FRONT_MATTER" value="false" />
        <option name="MACROS_EXT" value="false" />
        <option name="NO_TEXT_ATTRIBUTES" value="false" />
        <option name="PARSE_HTML_ANCHOR_ID" value="false" />
        <option name="PLANTUML_FENCED_CODE" value="false" />
        <option name="PUML_FENCED_CODE" value="false" />
        <option name="SIM_TOC_BLANK_LINE_SPACER" value="true" />
      </ParserOptions>
    </ParserSettings>
    <HtmlSettings headerTopEnabled="false" headerBottomEnabled="false" bodyTopEnabled="false" bodyBottomEnabled="false" embedUrlContent="false" addPageHeader="true" embedImages="false" embedHttpImages="false" imageUriSerials="false" addDocTypeHtml="true" noParaTags="false" plantUmlConversion="0" mathConversion="-1">
      <GeneratorProvider>
        <provider providerId="com.vladsch.idea.multimarkdown.editor.swing.html.generator" providerName="Default Swing HTML Generator" />
      </GeneratorProvider>
      <headerTop />
      <headerBottom />
      <bodyTop />
      <bodyBottom />
    </HtmlSettings>
    <CssSettings previewScheme="UI_SCHEME" cssUri="" isCssUriEnabled="false" isCssUriSerial="true" isCssTextEnabled="false" isDynamicPageWidth="true">
      <StylesheetProvider>
        <provider providerId="com.vladsch.idea.multimarkdown.editor.swing.html.css" providerName="Default Swing Stylesheet" />
      </StylesheetProvider>
      <ScriptProviders />
      <cssText />
      <cssUriHistory />
    </CssSettings>
    <AnnotatorSettings targetHasSpaces="true" linkCaseMismatch="true" wikiCaseMismatch="true" wikiLinkHasDashes="true" notUnderWikiHome="true" targetNotWikiPageExt="true" notUnderSourceWikiHome="true" targetNameHasAnchor="true" targetPathHasAnchor="true" wikiLinkHasSlash="true" wikiLinkHasSubdir="true" wikiLinkHasOnlyAnchor="true" linkTargetsWikiHasExt="true" linkTargetsWikiHasBadExt="true" notUnderSameRepo="true" targetNotUnderVcs="false" linkNeedsExt="true" linkHasBadExt="true" linkTargetNeedsExt="true" linkTargetHasBadExt="true" wikiLinkNotInWiki="true" imageTargetNotInRaw="true" repoRelativeAcrossVcsRoots="true" multipleWikiTargetsMatch="true" unresolvedLinkReference="true" linkIsIgnored="true" anchorIsIgnored="true" anchorIsUnresolved="true" anchorLineReferenceIsUnresolved="true" anchorLineReferenceFormat="true" anchorHasDuplicates="true" abbreviationDuplicates="true" abbreviationNotUsed="true" attributeIdDuplicateDefinition="true" attributeIdNotUsed="true" footnoteDuplicateDefinition="true" footnoteUnresolved="true" footnoteDuplicates="true" footnoteNotUsed="true" macroDuplicateDefinition="true" macroUnresolved="true" macroDuplicates="true" macroNotUsed="true" referenceDuplicateDefinition="true" referenceUnresolved="true" referenceDuplicates="true" referenceNotUsed="true" referenceUnresolvedNumericId="true" enumRefDuplicateDefinition="true" enumRefUnresolved="true" enumRefDuplicates="true" enumRefNotUsed="true" enumRefLinkUnresolved="true" enumRefLinkDuplicates="true" simTocUpdateNeeded="true" simTocTitleSpaceNeeded="true" />
    <HtmlExportSettings updateOnSave="false" parentDir="" targetDir="" cssDir="css" scriptDir="js" plainHtml="false" imageDir="" copyLinkedImages="false" imageUniquifyType="0" targetPathType="2" targetExt="" useTargetExt="false" noCssNoScripts="false" useElementStyleAttribute="false" linkToExportedHtml="true" exportOnSettingsChange="true" regenerateOnProjectOpen="false" linkFormatType="HTTP_ABSOLUTE" />
    <LinkMapSettings>
      <textMaps />
    </LinkMapSettings>
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_6">
    <output url="file://$PROJECT_DIR$/out" />
  </component>
  <component name="ProjectType">
    <option name="id" value="jpab" />
  </component>
</project>
'''
'''--- .idea/modules.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/build_config/build_config.iml" filepath="$PROJECT_DIR$/build_config/build_config.iml" />
      <module fileurl="file://$PROJECT_DIR$/build_script/build_script.iml" filepath="$PROJECT_DIR$/build_script/build_script.iml" />
      <module fileurl="file://$PROJECT_DIR$/contract/contract.iml" filepath="$PROJECT_DIR$/contract/contract.iml" />
      <module fileurl="file://$PROJECT_DIR$/server/server.iml" filepath="$PROJECT_DIR$/server/server.iml" />
    </modules>
  </component>
</project>
'''
'''--- .idea/vcs.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="" vcs="Git" />
    <mapping directory="$PROJECT_DIR$" vcs="Git" />
  </component>
</project>
'''
'''--- README.md ---
### Overview

What is HOOH？

- [Click Here](https://www.hooh.fun/)

### Repositories

This is the Smart Contract repository：[https://github.com/ming-xi/hooh-contract](https://github.com/ming-xi/hooh-contract)

This is the app repository：[https://github.com/ming-xi/hooh](https://github.com/ming-xi/hooh)

### Roadmap

Stage 0 - Sep 2022（Done）

- create\_account let users create wallets following web 2's user habits
- show\_stats inquires total amount of user accounts
- show\_account inquires accounts details
- show\_accounts inquires multiple accounts details
- update\_accounts\_balance updates balance of $ORE in user accounts

Stage I - Q1-Q2 2023（On going）

- Connect wallet to login
- Read NFT assets in wallets: using api from NFT marketplaces in the ecosystem to get NFT data
on the mainnet
'''
'''--- build_script/deploy_local_server (docker).sh ---
#!/bin/bash
cd ../server/ || exit
if ! docker build -f ../build_config/Dockerfile --build-arg ENV_FILE=.env_staging -t hooh-contract-connector:test .; then
    echo "docker image build error"
    exit
fi

docker stop connector
docker rm connector
docker run --name connector -p 3100:3100 -d hooh-contract-connector:test
'''
'''--- build_script/deploy_local_server.sh ---
#!/bin/bash
cd ../server/ || exit
if [ ! -d ".near-credentials" ]; then
    mkdir .near-credentials
fi
cp -R ~/.near-credentials/ .near-credentials/
yarn start

'''
'''--- build_script/k8s_init_deploy.sh ---
#!/bin/bash
cd ../build_config || exit
kubectl apply -f eks-connector.yaml
echo '::connector'
kubectl get all -n hooh-connector
kubectl get pods -n hooh-connector -o wide
kubectl get ingress -n hooh-connector --output=wide
'''
'''--- build_script/k8s_update_deploy.sh ---
#!/bin/bash
kubectl rollout restart deployment connector-staging -n hooh-connector

'''
'''--- contract/Cargo.toml ---
[package]
name = "contract"
version = "0.1.0"
authors = ["hooh.xyz"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = { version = "*", features = ["derive"] }
serde_json = "*"
#near-contract-standards = "3.2.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- contract/src/lib.rs ---
//! This contract implements simple counter backed by storage on blockchain.
//!
//! The contract provides methods to [increment] / [decrement] counter and
//! [get it's current value][get_num] or [reset].
//!
//! [increment]: struct.Counter.html#method.increment
//! [decrement]: struct.Counter.html#method.decrement
//! [get_num]: struct.Counter.html#method.get_num
//! [reset]: struct.Counter.html#method.reset

use std::collections::HashMap;

use near_sdk::{AccountId, near_bindgen};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;

use crate::token::Account;

mod token;

// near_sdk::setup_alloc!();

// add the following attributes to prepare your code for serialization and invocation on the blockchain
// More built-in Rust attributes here: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Hooh {
    // See more data types at https://doc.rust-lang.org/book/ch03-02-data-types.html
    accounts: LookupMap<AccountId, Account>,
    account_amount: u32,
}

impl Default for Hooh {
    fn default() -> Self {
        Self {
            account_amount: 0,
            accounts: LookupMap::new(b"acc".to_vec()),
        }
    }
}

#[near_bindgen]
impl Hooh {
    pub fn show_stats(&self) -> u32 {
        self.account_amount
    }

    pub fn show_account(&self, account_id: AccountId) -> Option<Account> {
        self.accounts.get(&account_id)
    }
    pub fn show_accounts(&self, account_ids: Vec<AccountId>) -> Vec<Account> {
        let mut result = vec![];
        for account_id in &account_ids {
            if let Some(account) = self.accounts.get(&account_id) {
                result.push(account);
            }
        }
        result
    }

    pub fn add_account(&mut self, account_id: AccountId) -> Account {
        match self.accounts.get(&account_id) {
            None => {
                let account = Account::new(account_id.clone());
                self.accounts.insert(&account_id, &account);
                self.account_amount += 1;
                account
            }
            Some(a) => {
                a
            }
        }
    }

    pub fn update_accounts_balance(&mut self, records: HashMap<AccountId, u128>) -> u128 {
        let mut count = 0;
        for (key, value) in &records {
            if let Some(mut account) = self.get_account(&key) {
                account.balances = vec![value.clone()];
                self.accounts.insert(&account.account_id, &account);
                count = count + 1;
            }
        }
        count
    }
    fn get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id)
    }
}

/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-counter-tutorial -- --nocapture
 * Note: 'rust-counter-tutorial' comes from cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;

    // Allows for modifying the environment of the mocked blockchain
    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn update_account() {
        println!("::update_account");
        let mut context = get_context(accounts(1));
        // Initialize the mocked blockchain
        testing_env!(context.build());

        // Set the testing environment for the subsequent calls
        testing_env!(context
            .predecessor_account_id(accounts(1))
            .build());

        let mut contract = Hooh::default();
        contract.add_account(accounts(1));
        println!("account_id={}", accounts(1));
        let account = contract.get_account(&accounts(1));
        println!("account={:?}", account);
        assert!(account.is_some());
        let account = account.unwrap();
        println!("account.balances[0]={}", account.balances[0]);
        assert_eq!(account.balances[0], 0);
        let mut records = HashMap::new();
        records.insert(accounts(1), 100 as u128);
        contract.update_accounts_balance(records);
        let account = contract.get_account(&accounts(1));
        assert!(account.is_some());
        let account = account.unwrap();
        println!("updated_account={:?}", account);
        assert_eq!(account.balances[0], 100);
    }

    #[test]
    fn get_nonexistent_account() {
        println!("::get_nonexistent_account");
        let contract = Hooh::default();
        let account = contract.get_account(&accounts(1));
        println!("account={:?}", account);
        assert!(account.is_none());
    }
}
'''
'''--- contract/src/token.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, env};

#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, PartialEq, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Tokens {
    Ore,
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    pub account_id: AccountId,
    pub balances: Vec<Balance>,
    pub claim_timestamp: u64,
}

impl Account {
    pub fn new(account_id: AccountId) -> Self {
        Self {
            account_id,
            balances: vec![0],
            claim_timestamp: env::block_timestamp(),
        }
    }
}
'''
'''--- server/README.md ---
# feiyu-canvas-war-connector

Connector for Feiyu Canvas War

## Install

### Set Up Environment

1. Install `nvm`: follow the instruction [here](https://github.com/nvm-sh/nvm#install--update-script)
2. Install `node`: run the command `nvm install --lts`
3. Install `yarn` and `pm2`: `npm install -g yarn pm2`

### Set Up Project

Download repository, and install dependencies

```bash
git clone https://github.com/near-x/feiyu-canvas-war-connector
cd feiyu-canvas-war-connector/server
yarn
```

## Configure and Launch

1. Configure environment variables

Add the environment variables in `.env` (look at `.env.example` as an example)

```env
MONGODB_URI=mongodb://localhost:27017/test
AES_ENC_KEY=...
AES_IV=...
```

2. Launch the server

Run the command: `pm2 start`
'''
'''--- server/app.js ---
const big = require('big.js');

const express = require('express');
const cors = require('cors');
const nearAPI = require('near-api-js');
const {generateSeedPhrase, parseSeedPhrase} = require('near-seed-phrase');
const BN = require('bn.js');
const getConfig = require('./config');
const {connection} = require("./utils/near-utils");
const {Account} = require("near-api-js");
const {appAccount, contract, withNear, hasAccessKey} = require('./middleware/near');
const {appName, contractName, userMethods, ownerMethods} = getConfig();
const {
    utils: {
        PublicKey,
        format: {
            parseNearAmount
        }
    }
} = nearAPI;
const {ensureSufficientBalance, getContract, getAccount} = require('./utils/near-utils');
// const mongodb = require('./utils/db');
// const {saveKey, loadKey, loadKey2, saveKey2, loadAccountId, loadAccount} = require('./utils/keys');
// const {insertActivity} = require('./utils/activity');
const {handleError, handle_request_error, handle_server_error} = require('./utils/handler');

// mongodb.init();

const app = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());
app.use(withNear());

app.get('/', (req, res) => {
    res.send('hooh blockchain server');
});

// app.post('/has-access-key', hasAccessKey, (req, res) => {
//     res.json({success: true});
// });

const INITIAL_ACCOUNT_BALANCE = '0.00182';

const create_account = async (userId) => {
    const {seedPhrase, publicKey, secretKey} = generateSeedPhrase();
    const username = userId + "." + appName;
    const result = await appAccount.createAccount(
        username, // new account name
        publicKey, // public key for new account
        parseNearAmount(INITIAL_ACCOUNT_BALANCE) // initial balance for new account in yoctoNEAR
    );
    // const success = await saveKey(userId, {
    //     accountId: username,
    //     seedPhrase,
    //     publicKey,
    //     secretKey
    // });
    console.log('\ncreated account: %s\n%s\n', username, publicKey);
    // await send_inks(username, 70, "0");
    return {username, seedPhrase, result};
}

// WARNING NO RESTRICTION ON THIS ENDPOINT

//debug
app.post('/show-stats', async (req, res) => {
    log_request(req.path, req.body);
    if (res.writable) {
        res.json({"account_amount": await get_contract_result(appAccount, res, "show_stats", null)});
    }
});
app.post('/update-accounts-balance', async (req, res) => {
    log_request(req.path, req.body);
    const records = req.body;
    if (!records) {
        return handle_request_error(res, "records is missing");
    }
    let count = await get_contract_result(appAccount, res, "update_accounts_balance", {
        "records": records
    }, true, 300);
    if (res.writable) {
        res.json({
            "changed_records_count": count
        });
    }
});
app.post('/get-account', async (req, res) => {
    log_request(req.path, req.body);
    const {account_id} = req.body;
    if (!account_id) {
        return handle_request_error(res, "account_id is missing");
    }
    if (res.writable) {
        res.json(await get_contract_result(appAccount, res, "show_account", {account_id: account_id}));
    }
});
app.post('/get-accounts', async (req, res) => {
    log_request(req.path, req.body);
    const {account_ids} = req.body;
    if (!account_ids) {
        return handle_request_error(res, "account_ids is missing");
    }
    if (res.writable) {
        res.json(await get_contract_result(appAccount, res, "show_accounts", {account_ids: account_ids}));
    }
});
// app.post('/create-account', async (req, res) => {
//     log_request(req.path, req.body);
//     const {account_id} = req.body;
//     if (!account_id) {
//         return handle_request_error(res, "account_id is missing");
//     }
//     await get_contract_result(appAccount, res, "create_account", {account_id: account_id});
// });
app.post('/create-account', async (req, res) => {
    log_request(req.path, req.body);
    const {account_id} = req.body;
    if (!account_id) {
        return handle_request_error(res, "account_id is missing");
    }
    try {
        // let result = await create_account(account_id);
        // console.log(JSON.stringify(result));
        let result = await create_account(account_id);
        let contract = getContract(appAccount, userMethods);
        let account = await contract["add_account"]({
            args: {account_id: account_id}
        });
        res.json({account: account, phrase: result.seedPhrase});
    } catch (e) {
        console.log(e);
        handle_server_error(res, e.message, ERROR_GENERIC, e.message);
    }
    // await get_contract_result(appAccount, res, "create_account", {account_id: account_id});
});

const Tokens = {
    Ore: 'Ore',
};

function log_request(path, body) {
    console.log(`path=${path} body=${JSON.stringify(body)}`);
}

// const FT_TRANSFER_FEE = 0.01; // 1%
// const FT_MIN_STORAGE_COST = parseNearAmount('0.00256');
// const FT_TRANSFER_DEPOSIT = '1';
const ERROR_GENERIC = 1000;
//
// // WARNING NO RESTRICTION ON THIS ENDPOINT
// app.post('/transfer', async (req, res) => {
//     const {sender, receiver, amount, memo, feeMemo} = req.body;
//     if (!sender || !receiver || !amount) {
//         return handleError(res, "sender, receiver or amount is missing", "Invalid paramters");
//     }
//
//     const {accountId, secretKey} = await loadKey(sender);
//     if (!accountId || !secretKey) {
//         return handleError(res, `Sender account ${sender} doesn\'t exist`, "Sender account doesn't exist");
//     }
//
//     const _account = await getAccount(accountId, secretKey);
//     const _contract = getContract(_account, userMethods);
//     const pixel_cost = await getPixelCost();
//
//     // If the balance of sender is less than amount * (1 + fee%), stop here
//     const available_balance = parseInt(await _contract.ft_balance_of({
//         account_id: accountId
//     }) || 0) / pixel_cost;
//     const fee = amount * FT_TRANSFER_FEE;
//     if (amount + fee > available_balance) {
//         return handleError(res, `Sender account doesn't have enough balance`, "Sender doesn't have enough balance");
//     }
//
//     await ensureSufficientBalance(accountId); // send balance if not sufficient balance
//
//     try {
//         async function ft_transfer(receiver_id, amount, memo = "") {
//             const parsedAmount = BigInt(parseInt(amount * pixel_cost)).toString();
//             return await _contract.ft_transfer({
//                 args: {
//                     receiver_id,
//                     amount: '' + parsedAmount,
//                     memo
//                 },
//                 gas: new BN("10000000000000"),
//                 amount: FT_TRANSFER_DEPOSIT
//             });
//         }
//
//         async function storage_deposit(receiver_id) {
//             const storage_balance = await _contract.storage_balance_of({
//                 account_id: receiver_id
//             });
//             // if no storage balance, deposit some
//             if (!(storage_balance && storage_balance.total > 0)) {
//                 await _contract.storage_deposit({
//                     args: {
//                         account_id: receiver_id,
//                         registration_only: true,
//                     },
//                     gas: new BN("10000000000000"),
//                     amount: FT_MIN_STORAGE_COST
//                 });
//             }
//         }
//
//         // 1. If the receiver doesn't have a NEAR account, create one
//         let {accountId: receiver_id} = await loadKey(receiver);
//         if (!receiver_id) {
//             const data = await create_account(receiver);
//             receiver_id = data.username;
//         }
//
//         // 2. If the receiver doesn't have FT storage, call `storage_deposit`
//         await storage_deposit(receiver_id);
//         // 3. call `ft_transfer` to transfer the token to receiver
//         const result = await ft_transfer(receiver_id, amount, memo);
//         // 4. pay the fees to the app account
//         await ft_transfer(appName, fee, feeMemo);
//
//         res.json({success: true, result});
//         console.log(`User ${sender} transferred ${amount} herrings to ${receiver}`);
//     } catch (e) {
//         return handleError(
//             res,
//             `Failed to transfer herring between accounts: ${e.message}`,
//             `Cannot transfer herring between accounts: ${e.message}`
//         );
//     }
// });

async function get_contract_result_with_account_id(accountId, res, contract_method_name, args, isChangeMethod) {
    let account = await loadAccount(accountId);
    // console.log(account);
    return get_contract_result(account, res, contract_method_name, args, isChangeMethod);
}

async function get_contract_result(account, res, contract_method_name, args) {
    get_contract_result(account, res, contract_method_name, args, false);
}

async function get_contract_result(account, res, contract_method_name, args, isChangeMethod, gas = 0) {
    try {
        let contract = getContract(account, userMethods);
        if (checkMethod(contract, contract_method_name)) {
            // return await contract[contract_method_name](args || {});
            let finalArgs;
            if (isChangeMethod) {
                finalArgs = {
                    args: args || {}
                };
                if (gas !== 0) {
                    finalArgs['gas'] = big.Big(gas).times(10 ** 12).toFixed();
                }
            } else {
                finalArgs = args || {};
            }
            console.log(`finalArgs=${JSON.stringify(finalArgs)}`);
            return await contract[contract_method_name](finalArgs);
        } else {
            return handle_server_error(res, `no method in contract: ${contract_method_name}`, ERROR_GENERIC, "internal error");
        }
    } catch (e) {
        return handle_server_error(res, e.message, ERROR_GENERIC, e.message);
    }
}

async function get_contract_result_with_deposit(accountId, res, contract_method_name, args, deposit) {
    let account = await loadAccount(accountId);
    try {
        let contract = getContract(account, userMethods);
        if (checkMethod(contract, contract_method_name)) {
            console.log(`prepare to call method:${contract_method_name}, args:${args}, deposit:${deposit}`);
            res.json(await contract[contract_method_name](args || {}, new BN("30000000000000"), deposit));
        } else {
            return handle_server_error(res, `no method in contract: ${contract_method_name}`, ERROR_GENERIC, "internal error");
        }
    } catch (e) {
        return handle_server_error(res, e.message, ERROR_GENERIC, e.message);
    }
}

function checkMethod(object, method_name) {
    if (typeof object[method_name] === 'function') {
        console.log(`check method ${method_name}: ok`);
        return true;
    } else if (typeof object[method_name] === 'undefined') {
        console.log(`check method ${method_name}: failed, method undefined`);
        return false;
    } else {
        console.log(`check method ${method_name}: failed, it's neither undefined nor a function. It's a ${typeof object[method_name]}`);
        return false;
    }
}

app.listen(port, () => {
    console.log(`\nContract Account ID:\n${contractName}\nListening at http://localhost:${port}`);
});

'''
'''--- server/config.js ---
const appName = process.env.NEAR_ENV === 'mainnet'
    ? 'hooh-tech.near'
    : 'hooh-tech.testnet';
const testName = 'test1.';
// const testName = 'test2.';
const contractName = testName + 'hooh.' + appName;

module.exports = function getConfig() {
    let config = {
        networkId: 'default',
        nodeUrl: process.env.NEAR_TESTNET_NODE_URL || 'https://rpc.testnet.near.org',
        // walletUrl: 'http://localhost:1234',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        appName,
        contractName,
        contractMethods: {
            viewMethods: ['get_pixel_cost', 'get_account_balance']
        },
        userMethods: {
            changeMethods: [
                'add_account',
                'update_accounts_balance',

                'ft_transfer', 'storage_deposit'
            ],
            viewMethods: [
                'show_account',
                'show_accounts',
                'show_stats',

                'ft_balance_of', 'storage_balance_of', 'storage_balance_bounds'
            ]
        },
        ownerMethods: {
            changeMethods: [
                'send_tokens', 'reward'
            ]
        },
    };

    if (process.env.NEAR_ENV === 'mainnet') {
        config = {
            ...config,
            networkId: 'mainnet',
            nodeUrl: process.env.NEAR_MAINNET_NODE_URL || 'https://rpc.mainnet.near.org',
            walletUrl: 'https://wallet.near.org',
            helperUrl: 'https://helper.mainnet.near.org'
        };
    }

    return config;
};

'''
'''--- server/ecosystem.config.js ---
module.exports = {
    apps: [
        {
            name: "Ancient_Arena_Connector",
            script: "yarn",
            args: "start",
        },
    ],
};

'''
'''--- server/middleware/near.js ---
const nacl = require('tweetnacl');
const crypto = require('crypto');
const bs58 = require('bs58');
const {near, connection, appAccount, contract} = require('../utils/near-utils');

const withNear = () => (req, res, next) => {
    req.near = near;
    next();
};

const VALID_BLOCK_AGE = 100;

const validBlock = async (blockNumber) => {
    const currentBlock = (await connection.provider.status()).sync_info.latest_block_height;
    const givenBlock = Number(blockNumber);
    if (givenBlock <= currentBlock - VALID_BLOCK_AGE || givenBlock > currentBlock) {
        return false;
    }
    return true;
};

const verifySignature = async (accountId, data, signature, contractName = '') => {
    const nearAccount = await near.account(accountId);
    try {
        const hash = crypto.createHash('sha256').update(data).digest();
        let accessKeys = await nearAccount.getAccessKeys();
        if (contractName.length) {
            accessKeys = accessKeys.filter(({access_key: {permission}}) => permission && permission.FunctionCall && permission.FunctionCall.receiver_id === contractName);
        } else {
            accessKeys = accessKeys.filter(({access_key: {permission}}) => permission === 'FullAccess');
        }
        return accessKeys.some(({public_key}) => {
            const publicKey = public_key.replace('ed25519:', '');
            return nacl.sign.detached.verify(hash, Buffer.from(signature, 'base64'), bs58.decode(publicKey));
        });
    } catch (e) {
        console.error(e);
        return false;
    }
};

const hasAccessKey = async (req, res, next) => {
    const {accountId, contractName, blockNumber, blockNumberSignature} = req.body;

    if (!accountId || !contractName || !blockNumber || !blockNumberSignature) {
        return res.status(403).send({error: 'You must provide an accountId, contractName, blockNumber, and blockNumberSignature'});
    }

    if (!(await validBlock(blockNumber))) {
        return res.status(403).send({error: `You must provide a blockNumber within ${VALID_BLOCK_AGE} of the most recent block; provided: ${blockNumber}, current: ${currentBlock}`});
    }

    if (!(await verifySignature(accountId, blockNumber, blockNumberSignature, contractName))) {
        return res.status(403).send({error: `blockNumberSignature did not match a signature of blockNumber=${blockNumber} from accountId=${accountId}`});
    }

    return await next();
};

module.exports = {
    appAccount,
    contract,
    withNear,
    hasAccessKey,
};

'''
'''--- server/package.json ---
{
  "name": "hooh-connector",
  "version": "1.0.0",
  "description": "connector for hooh contract",
  "main": "app.js",
  "scripts": {
    "start": "PORT=3100 REACT_APP_ENV=dev node -r dotenv/config app.js",
    "dev": "REACT_APP_ENV=dev nodemon app.js --config ./nodemon.json",
    "test": "mocha -r dotenv/config --timeout 60000"
  },
  "author": "hooh.xyz",
  "license": "ISC",
  "dependencies": {
    "big.js": "^5.2.2",
    "axios": "^0.21.1",
    "bs58": "^4.0.1",
    "cors": "^2.8.5",
    "express": "^4.17.1",
    "mocha": "^8.3.1",
    "near-api-js": "^0.44.2",
    "near-seed-phrase": "^0.1.1",
    "tweetnacl": "^1.0.3"
  },
  "devDependencies": {
    "dotenv": "^9.0.2",
    "nodemon": "^2.0.7"
  }
}

'''
'''--- server/pm2.json ---
{
  "name": "HooH_Connector",
  "script": "yarn start"
}
'''
'''--- server/run.sh ---
if [ ! -d ".near-credentials" ]; then
    mkdir .near-credentials
    cp -R ~/.near-credentials/ .near-credentials/
fi
docker build -t feiyu-connector .
docker run feiyu-connector
'''
'''--- server/test/account.js ---
const assert = require('assert');
const axios = require('axios');

const client = axios.create({
    baseURL: 'http://localhost:3100'
});

describe('account operations', () => {
    before(() => {
        // if (!process.env.DAPP_KEY || !process.env.DAPP_SECRET) {
        //   console.log("Please set environment variables DAPP_KEY and DAPP_SECRET before run test")
        // }
    })

    it('should successfully create an account', (done) => {
        client.post("/create-account", {
            'userId': 'tester'
        }).then(res => {
            assert.strictEqual(res.data.success, true);
            done();
        }).catch(err => {
            assert.strictEqual(err.data.error, "Account already created");
            done();
        })
    });

});

'''
'''--- server/test/contract.js ---
const assert = require('assert');
const axios = require('axios');

const client = axios.create({
    baseURL: 'http://localhost:3100'
});

describe('contract calls', () => {
    before(() => {

    })

    it('should send ink tokens to the account', (done) => {
        client.post("/send-inks", {
            userId: 'tester02',
            amount: 10,
            memo: "0"
        }).then(res => {
            assert.strictEqual(res.data.success, true);
            done();
        }).catch(err => {
            console.error("err", err);
            done();
        })
    });

    it('should buy ink tokens for the account with feiyu tokens', (done) => {
        client.post("/buy-inks", {
            'userId': 'tester',
            'amount': 0.1
        }).then(res => {
            assert.strictEqual(res.data.success, true);
            done();
        }).catch(err => {
            console.error("err", err);
            done();
        })
    });

    it('should draw two pixels on canvas', (done) => {
        client.post("/draw", {
            'userId': 'tester02',
            'pixels': [
                {
                    "x": 9,
                    "y": 7,
                    "color": 255
                },
                {
                    "x": 9,
                    "y": 8,
                    "color": 0
                }
            ]
        }).then(res => {
            console.log('res', res.data);
            assert.strictEqual(res.data.success, true);
            assert.strictEqual(res.data.result.length, 0);
            done();
        }).catch(err => {
            console.error("err", err);
            done();
        })
    });

    it('should only draw one pixel on canvas', (done) => {
        client.post("/draw", {
            'userId': 'tester02',
            'pixels': [
                {
                    "x": 9,
                    "y": 7,
                    "color": 255
                },
                {
                    "x": 9,
                    "y": 9,
                    "color": 0
                }
            ]
        }).then(res => {
            console.log('res', res.data);
            assert.strictEqual(res.data.success, true);
            assert.strictEqual(res.data.result.length, 1);
            done();
        }).catch(err => {
            console.error("err", err);
            done();
        })
    });

    it('should select farming preference of Feiyu token', (done) => {
        client.post("/select-farming-preference", {
            'userId': 'tester',
            'token': "Herring"
        }).then(res => {
            assert.strictEqual(res.data.success, true);
            done();
        }).catch(err => {
            console.error("err", err);
            done();
        })
    });

    it('should purchae product for the user with Feiyu token', (done) => {
        client.post("/purchase", {
            'userId': 'tester02',
            'amount': 0.001,
            'productId': 'painting'
        }).then(res => {
            assert.strictEqual(res.data.success, true);
            done();
        }).catch(err => {
            console.error("err", err);
            done();
        })
    });

    it('should reward the user with Feiyu token', (done) => {
        client.post("/reward", {
            'userId': 'tester02',
            'amount': 10,
            'category': 'activity'
        }).then(res => {
            assert.strictEqual(res.data.success, true);
            done();
        }).catch(err => {
            console.error("err", err);
            done();
        })
    });

});

'''
'''--- server/utils/handler.js ---
function handleError(res, reason, message, code) {
    console.error("ERROR: " + reason);
    res.status(code || 500).json({error: message}).end();
}

function handle_request_error(res, ret_message) {
    console.error("ERROR: " + ret_message);
    res.status(400).json({
        msg: ret_message
    }).end();
}

function handle_server_error(res, reason, ret_code, ret_message) {
    console.error("ERROR: " + reason || ret_message);
    res.status(500).json({
        code: ret_code,
        msg: ret_message
    }).end();
}

module.exports = {
    handleError,
    handle_request_error,
    handle_server_error,
}
'''
'''--- server/utils/keys.js ---
const mongodb = require('./db');
const aes = require('./aes');

const saveKey = async (userId, keys) => {
    const {accountId, seedPhrase, publicKey, secretKey} = keys;

    const query = {userId};
    const col = mongodb.collections.secret;
    try {
        const user = await mongodb.db.collection(col).findOne(query);
        if (!user) {
            await mongodb.db.collection(col).insertOne({
                userId,
                accountId,
                publicKey,
                seedPhrase: aes.encrypt(seedPhrase),
                secretKey: aes.encrypt(secretKey),
                created: new Date()
            });
            return true
        }
    } catch (e) {
        console.error("Failed when saving key", e);
    }
    return false
}

const loadKey = async (userId) => {
    const query = {userId};
    const col = mongodb.collections.secret;
    try {
        const user = await mongodb.db.collection(col).findOne(query);
        if (user) {
            const {secretKey, accountId} = user;
            return {
                accountId,
                secretKey: aes.decrypt(secretKey)
            }
        }
    } catch (e) {
        console.error("Failed when loading key for user %s", userId, e);
    }
    return false
}

const loadAccountId = async (userId) => {
    if (!userId) return false;

    const query = {userId};
    const col = mongodb.collections.secret;
    try {
        const user = await mongodb.db.collection(col).findOne(query);
        if (user) {
            const {accountId} = user;
            return accountId;
        }
    } catch (e) {
        console.error("Failed when loading account id for user %s", userId, e);
    }
    return false
}

module.exports = {
    loadAccountId,
    loadKey,
    saveKey
}

'''
'''--- server/utils/near-utils.js ---
const fs = require('fs');
const nearAPI = require('near-api-js');
const getConfig = require('../config');
const {nodeUrl, networkId, appName, contractName, contractMethods, userMethods, ownerMethods} = getConfig();
const {
    keyStores: {InMemoryKeyStore},
    Near, Account, Contract, KeyPair,
    InMemorySigner, utils
} = nearAPI;

const credentials = JSON.parse(fs.readFileSync(`${process.env.HOME}/.near-credentials/${networkId}/${appName}.json`));
const keyStore = new InMemoryKeyStore();
keyStore.setKey(networkId, appName, KeyPair.fromString(credentials.private_key));
const near = new Near({
    networkId,
    nodeUrl,
    deps: {keyStore},
});
const {connection} = near;
const appAccount = new Account(connection, appName);
const contractAccount = new Account(connection, contractName);
const contract = new Contract(contractAccount, contractName, contractMethods);

function getContract(account, methods = contractMethods) {
    return new Contract(account, contractName, {...methods});
}

const nearForAccessKey = new Near({
    networkId,
    nodeUrl,
    deps: {
        keyStore: new InMemoryKeyStore()
    },
});

const createAccessKeyAccount = (secretKey) => {
    const near = nearForAccessKey;
    const keyPair = KeyPair.fromString(secretKey);
    keyPair.toString = () => keyPair.secretKey;
    near.connection.signer.keyStore.setKey(networkId, contractName, keyPair);
    const account = new Account(near.connection, contractName);
    return account;
};

const getAccount = async (accountId, secretKey) => {
    const keyPair = KeyPair.fromString(secretKey);
    keyPair.toString = () => keyPair.secretKey;
    const signer = await InMemorySigner.fromKeyPair(networkId, accountId, keyPair);
    const near = await nearAPI.connect({
        networkId, nodeUrl, deps: {keyStore: signer.keyStore},
    });
    const account = new nearAPI.Account(near.connection, accountId);
    return account;
};

const getAvailableBalance = async (accountId) => {
    const account = await near.account(accountId);
    const balances = await account.getAccountBalance();
    return utils.format.formatNearAmount(balances.available);
}

const MINIMUM_BALANCE = 0.005;
const MINIMUM_LARGE_BALANCE = 0.01;
const INCREASED_AMOUNT = "0.02";

const ensureSufficientBalance = async (accountId, size = "M") => {
    try {
        const available = await getAvailableBalance(accountId);
        const minimumBalance = size === "L" ? MINIMUM_LARGE_BALANCE : MINIMUM_BALANCE;
        if (available != null && parseFloat(available) < minimumBalance) {
            await appAccount.sendMoney(accountId, utils.format.parseNearAmount(INCREASED_AMOUNT));
            console.log(`${accountId} has only ${available} Ⓝ. Sent ${INCREASED_AMOUNT} Ⓝ to the account.`);
        }
    } catch (e) {
        console.error(`Failed when filling balance for account ${accountId} : `, e);
    }
}

module.exports = {
    near,
    keyStore,
    connection,
    contract,
    contractName,
    appAccount,
    contractAccount,
    userMethods,
    ownerMethods,
    createAccessKeyAccount,
    getContract,
    getAccount,
    ensureSufficientBalance,
};

'''